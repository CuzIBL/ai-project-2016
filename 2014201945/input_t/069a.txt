                                                                                           We are constructing such a system, called SAFE [1], 
                                                                                   which accepts an informal software specification as input and 
                                                                                   produces a formal operational equivalent (see [1] for example). 
                 META-EVALUATION AS A TOOL FOR                                     Most of the transformation is accomplished automatically via 
                                                                                   the techniques described in this paper, but some interaction 
                      PROGRAM UNDERSTANDING 
                                                                                   with the specifier is also required to resolve particular 
                                                                                   informal constructs for which insufficient context exists. 
             Robert Balzer, Neil Goldman and David Wile 
                                                                                           This system consists of three phases: (Da Linguistic 
                      Information Sciences Institute 
                                                                                   Phase which acquires a model of the domain [2] and identifies 
                    University of Southern California 
                                                                                   the individual actions to be performed, (2) the Planning Phase 
                           4676 Admiralty Way 
                                                                                   which creates a control structure for these actions, and (3) the 
                    Marina Del Rey, California 90291 
                                                                                   Meta-Evaluation Phase which is the focus of this paper. 
                                 ABSTRACT 
                                                                                           The purpose of the Meta-Evaluation process is to 
         Formal program specifications are difficult to write.                     simulate the run-time environment of a program to provide the 
They are always constructed from an informal precursor. We                         context for disambiguating informal constructs contained in the 
                                                                                   program description. It thus must provide three separate 
are exploring the technology required to aid in the 
                                                                                   capabilities: (1) the ability to simulate the state of a program 
construction of the formal specification from the informal 
                                                                                   as it is being executed, (2) the ability to form an ordered set 
version. 
                                                                                   of hypotheses for the intended meaning of an informal 
                                                                                   construct, and (3) the ability to test these hypotheses against 
         An informal specification differs from a formal one in 
                                                                                   some criteria. The second of these capabilities represents a 
 that much information which the writer believes the reader can 
                                                                                   theory of informality resolution for program specification; the 
 infer from the context has been supressed from the 
                                                                                   third, provides an operational theory of well-formed programs 
specification. Resolution of the supressed information 
                                                                                   which eliminates hypothesis which do not satisfy the rules of 
depends upon information contained in other parts of the 
                                                                                   this theory; while the first provides the data for testing these 
specification and upon Knowledge of what makes a 
                                                                                   well-formedness rules. 
specification well-formed and the ability to model the parts of 
 the specification interacting with one another. 
                                                                                           The combination of these three capabilities provides a 
                                                                                   mechanism for effectively applying our theories of informality 
         This paper describes the technology used in a running 
 system which embodies theories of program well-formedness                         resolution of program specifications and of program 
 and informality resolution within the context established by                      well-formedness to the task of understanding informal program 
 symbolically executing the program to systematically discover                     specifications. The following sections describe the major 
 the intended meaning of each informal construct within an                         features of each of these capabilities and is followed by an 
 informal specification.                                                           example illustrating the interaction between them as an 
                                                                                   informal program specification is Meta-Evaluated. 
 KEYWORDS: Meta-Evaluation, Symbolic Execution, Informal 
 Specification, Program Specification, Understanding Systems,                              However, before describing the capabilities, we must 
 Informality Resolution, Program Well-Formedness                                   first consider the language in which the program to be 
                                                                                   disambiguated is expressed and the types of informality which 
                                                                                   are allowed. 
                               INTRODUCTION 

        Producing a good specification has been recognized as a                                              THE PROGRAM MODEL 
critical precursor to producing an acceptable software 
implementation. Considerable effort has been expended to                                   As we mentioned, the Meta-Evaluation process is the 
produce better formalisms for software specification. We                           third and final phase of a larger system [1] which deals with a 
believe, however, that the difficulty lies in the formalisms                       wide range of informal constructs in program specifications 
themselves and that an aid in creating such formalisms, rather                     and starts from a parsed version of a natural language 
than a better formalism, is required.                                              program specification. This system acquires (or augments) a 
                                                                                   description of the relevant domain in which the specified 
        Since software specifications are always first created in                  program will operate. In this regard, it is very similar to 
an informal language and then converted, external to any                           Simon's UNDERSTAND [3] system as it determines what objects 
computer system, to some formalism, a system which aided this                      exist in the domain, how they relate to other objects, what 
conversion process, from informal to formal, would significantly                   constraints they must satisfy, and how they are to be 
aid the specifier.                                                                 manipulated by the program being specified. 

                                                                                           This work has been described elsewhere [4} Here we 
  NOTE: This research was supported by the Defense Advanced                        are concerned with how the acquired domain is represented, 
    Research Projects Agency (DARPA) under Contract                                how the specified program is expressed, and what informal 
    No. DAHC15 72 C 0308, ARPA Order No. 2223, Program                             constructs remain unresolved. 
    Codes 3D30 and 3P10. 
                                                                                           We begin with our model of what a program should be, 
    ACKNOWLEDGEMENT: We are deeDly indebted to Professor 
   Herbert Simon for his comments on this work which have                          which we feel is central to the success of our system. This 
   deepened our understanding and sharpened our perception                         model is derived from the desire to minimize the translation 
   of its relation to his pioneering work with Professor Newell                    from the informal natural language specification, to avoid 
   in understanding ill-formed problems.                                           issues of representation and optimization (which have colored 

                                                             Auto. Pro*.-2: Bal 7(*r 
                                                                             398 many other program models), and to keep the semantics of the                      statement OF <pattern> THEN statement-1 ELSE statement-2") 
programs as simple as possible so that programs could be                          causes statement-1 to be executed if the pattern is matched 
understood and composed by our system.                                            and statement-2 to be executed otherwise. The iterative 
                                                                                  statement (TOR ALL <pattern> DO statement-1") causes 
        Although our program model was largely derived from                       statement-1 to be repeatedly executed for each portion of the 
concerns of simplifying our system's task of resolving informal                   data base which matches the pattern with the placemarkers in 
program specifications, we strongly believe that this program                     the pattern bound to the named objects in the matched portion 
model (with suitable syntactic sugar) is also appropriate for                     of the data base. The demonic statement ("WHENEVER 
people to express formal unambiguous operational program                           <PATTERN> DO statement-D causes statement-1 to be 
specifications.                                                                   executed whenever a relation is added to the data base which 
                                                                                  enables the patten to be matched. 
        To avoid issues of data representation, the most uniform 
representation known, and one which closely mirrors the                                    Finally, to prevent the intrusion of representation 
original parsed natural language specification, was selected.                      considerations, the associative relational data base supports 
This representation is a fully associative relational data base                    inference so that the distinction between explicit and implicit 
and is used to hold all data manipulated by the program. An                        (computed) data can be ignored. 
object in this data base can be thought of as a named point in 
space whose meaning is defined totally by the other objects                                Thus, to first order our programming model represents 
(points) and it is connected to by relations (lines).                              the integration of the data handling of a fully associative 
                                                                                   relational data base and the control aspects of a conventional 
        The only actions (changes) allowed in this data base are                   programming language. We believe that this combination 
the creation and destruction of named objects and the making                       provides a particularly simple basis for stating and analyzing 
and breaking of relations between them. In addition,                               unoptimized operational program specifications, and hence, 
information can be extracted from the data base in a                               provides a solid foundation for our work on informality 
side-effect free manner (i.e., the extraction mechanism does                       resolution. 
not change the data base) via a pattern-match language. This 
language enables the full associativity of the data base to be                                              PROGRAM SIMULATOR 
used to access any object connected to a named object via the 
appropriate relation. Any object so accessed may be bound                                  The purpose of the program simulator is to simulate the 
to a placemarker which may then be used to access further                          run-time environment which will exist at each step in the 
objects, and so on. Placemarkers once bound by a                                   execution of a program to provide the data to resolve 
pattern-match are never rebound. They are merely an                                informalities in the program. The complexity of this capability 
indirect reference to the named object to which they are                           arises from our desire to simulate the run-time environment 
bound.                                                                             for a "typical" execution rather than for some particular set of 
                                                                                   input data. In essence, we wish to represent the run-time 
        Placemarkers have completely replaced variables in our                    environment as a function of some prototypal state. 
programming model (which contains neither variables nor 
assignment statements) and their semantics are particularly                               The technique of Symbolic Execution [5-12] was 
simple. They are bound only via a pattern-match to a named                        developed to symbolically express the output as a function of 
object in the data base, and once bound, they are not rebound.                    the inputs. This technique has generally been applied to 
Thus, they provide the means for focusing attention on some                       numeric problems where well known simplifications and 
portion of the data base and of accessing further information                     theorems exist which prevent the resulting expression from 
associated with the referenced named object.                                      becoming overly complex. However, even with these 
                                                                                  simplifications the complexity of the output expression is such 
        There is one exception to the rebinding rule. Inside of                   that individual paths through the program are normally 
a loop (which takes the form of TOR ALL <pattern> DO                              explored one at a time. 
<statement>) all placemarkers bound in the iteration pattern 
are rebound on each successive iteration so that a different                              In non-numeric problems the simplification techniques 
named object (or named objects if more than one unbound                            are much less developed and the expressions describing the 
placemarker appears in the iteration pattern) can be accessed                     state of the computation become very complex. Particularly 
and manipulated by the loop body.                                                 difficult are loops and conditional statements. Loops require 
                                                                                  the use of universal quantification over the loop predicate as 
        The only data manipulated by the programming model                        the condition which controls application of the loop body. 
are patterns composed of relations and the operations AND,                        Conditional statements require a splitting of the computation 
OR, and NOT. Each relation has arguments which must be a                          state into cases controlling which branch of the conditional will 
named object, a function which evaluates to a named object, or                    be executed. 
a placemarker. The placemarker must either be bound to a 
named object or be unbound. If an unbound placemarker                                     The alternatives for dealing with this complexity are 
occurs in a pattern being retrieved from the data base, then if                   quite clear; either it must be mastered, or it must be avoided. 
the pattern is successfully matched with some portion of the                      The majority of researchers in the field have pursued the first 
data base, the placemarker is bound to the corresponding                          alternative and are working on theorem provers and 
named object. If the match is unsuccessful, then the                              simplification systems better able to cope with these 
placemarker remains unbound.                                                      complexities. Compiler writers, on the other hand, have 
                                                                                  avoided this complexity in such techniques as data flow 
        The control statements available are a subroutine call, a                 analysis by recognizing that for their purposes, it is not 
sequence of statements, a conditional statement, an iterative                     important to know the exact circumstances under which some 
statement, and a demonic statement. The conditional                               particular data will be accessed, but only that there exist some 
                                                           Auto. Prop.-2: Ralzer 
                                                                            399 (unknown) circumstances under which it can be accessed.                                    As Meta-Evaluation proceeds, more and more of the 
Their particular needs allow a much weaker form of analysis                        input data for the program is created because it is accessed 
than symbolic execution to be applied to the program, avoiding                     by the program and does not already exist. Although the 
the complexity.                                                                    named objects in this data base are "symbolic" in that their 
                                                                                   identity is unknown, they are manipulated by the program just 
        In a similar way, our use of the "analysis" of the                         like actual data. As data is accessed by the program, 
program is not to describe the outputs as a function of the                        placemarkers are bound to these "symbolic" data, and the 
input, but rather to resolve informalities in the program itself.                  program creates new relations involving these objects and/or 
For this reason, a weaker form of program interpretation,                          deletes old ones. 
which we call Meta-Evaluation, is adequate. This technique 
avoids complexity by only executing each loop once (the                                    Occasionally constraints on the data base, such as a 
informalities within the loop must make sense during the first                     particular relation being single-valued, will enable the identity 
execution) and by picking an arbitrary branch of conditional                       of a "symbolic" object or the equivalence of two different 
statements for execution (informalities following a conditional                    "symbolic" objects to be determined. When this occurs, the 
statement must make sense no matter which branch was                               Meta-Evaluation process and the state of the data base are 
executed).                                                                         restored to the point at which the "symbolic" object was first 
                                                                                   used and the process is resumed using the discovered identity. 
        In addition, rather than representing the state of the 
computation as a simple compound expression, we represent it                               With these rules for data base access during 
as the running program (in our program model) would, as a set                      Meta-Evaluation and the update of the data base caused by 
of relations in the associative data base. As Meta-Evaluation                      ASSERT and DELETE statements, the remainder of the 
proceeds and control passes from statement to statement in                         Meta-Evaluation process pertains to individual types of 
the program, this data base is altered to reflect the additions                    program statements: 
and deletions specified in the program. Thus, the data base 
will reflect the state of the run-time data base for the program 
as control reaches each statement in the program. This                               A. Subroutine call. The actual parameters are 
simulation of the run-time data base enables each statement to                             substituted for the formals and the subroutine is 
be Meta-Evaluated in an appropriate environment which                                      simulated. If it is a routine in the informal 
provides the context to resolve any informalities in the                                   specification then the Meta-Evaluation process is 
statement and to test the program for well-formedness.                                     recursively applied to it. Otherwise, the routine is 
                                                                                           simulated by assuming all of its pre-conditions and 
        Simulating this data base as execution proceeds through                            by asserting its post-conditions. Pre- and 
the program would be quite simple if some particular set of                                post-conditions provide a way of summarizing the 
input data were selected. However, this data base must                                     requirements and results of a routine without 
represent the program's behavior on arbitrary input data.                                  actually executing it (and must be provided for the 
Therefore, symbolic data must be created and the data base                                 library routines which the program invokes so that 
expressed in terms of this symbolic data.                                                  they can be simulated during Meta-Evaluation). 

        Once we recognize that the input data to any program                         B. Sequence of statements. Each statement in the 
expressed in our program model consists of those relations in                              sequence is Meta-Evaluated in turn. 
the data base which it accesses without having previously 
created, the representation of symbolic data in the data base                        C. Loops. If the loop predicate matches existing 
becomes quite simple. A program simulation is started with an                              relations in the Meta-Evaluation data base, then the 
empty data base. Whenever the program attempts to access                                   loop body is Meta-Evaluated for each such match 
the data base (except in the predicate of a conditional                                    with the placemarkers bound to the matched named 
statement) the following rules are applied. If the accessed                                objects. If no match exists, then symbolic data is 
pattern already matches data existing in the data base, then                               created so that a single match of the loop predicate 
the pattern match proceeds normally binding any placemarkers                               will succeed, and then the loop body is 
in the pattern to the corresponding named objects in the data                               Meta-Evaluated for the (newly created) matched 

base. Ift on the other hand, the pattern does not match                                     pattern. Thus, whether or not the pattern is initially 
existing data, then new symbolic data is created (and assumed                               matched (and normally it won't be, so that a single 
to be part of the input data to the program) so that the                                    new symbolic relation satisfying the pattern will be 
 pattern match can succeed.                                                                 created), the loop body will be executed for each 
                                                                                            known relation satisfying the loop predicate. Thus, 
         The rationale for creating new data to match the                                   even though we have no way of representing 
 accessed pattern is that the program has assumed that this                                 universal quantification, such quantification has been 
 data already exists because it is unconditionally accessing it.                            operationally applied to the data base so that the 
 Hence, unless that data does exist, the program will not                                   resulting state is consistent with universal 
 operate correctly. Therefore, to enable the program                                       quantification. 
 simulation to proceed, suitable data is created to satisfy the 
 accessed pattern. However, only the existence of named                              D. Conditional statement. The predicate of the IF 
 objects rather than their particular identity can be inferred for                         statement is assumed to be false (i.e., is deleted from 
 arguments in the pattern specified by unbound placemarkers.                               the data base) and the ELSE clause is 
 Therefore, new "symbolic" instances of the appropriate type of                             Meta-Evaluated. Then the data base is restored to 
 object are created as part of the assumed relation.                                       its state before Meta-Evaluating the IF statement, 
                                                                                           the predicate is assumed to be true (i.e., is asserted 
                                                                                           in the data base), and the THEN clause is 

                                                             Auto. Proft.-2: Ralzer 
                                                                              U00         Meta-Evaluated.. Our present implementation is                            placemarker is replaced in the program by the placemarker 
        incapable of simultaneously representing the effects                      previously bound to the symbolic object thus equating the two 
        of the THEN and ELSE clauses as separate                                  references in different parts of the program. If the pattern 
        alternatives, and one branch—the THEN clause—is                           match for the descriptive reference fails, then new symbolic 
        chosen as the one whose effects will be reflected in                      objects are created so that the match will succeed and the 
        the data base for Meta-Evaluation of succeeding                           reference placemarker is bound to the appropriate symbolic 
        statements. This choice is based on the fact that                         object and is left unaltered in the program. It is treated as a 
        the THEN clause is usually more fully developed than                      separate placemarker which must be bound to an actual named 
        the ELSE clause and because it is normally the                            object at run-time rather than as a reference to other 
        expected case—the normal path through the                                 placemarkers or literals in the program. 
        program. 
                                                                                          Pronouns are replaced by a reference of the type 
                THEORY OF INFORMALITY RESOLUTION                                  required for that argument. For both these typed references 
                                                                                  and those which explicitly occur in the input, (e.g. "the 
        The previous section described how a program's                            message") an ordered set of possibilities is constructed. 
behavior could be simulated statement by statement on                             These possibilities are all drawn from the current context by 
symbolic data. The purpose of this simulation is to provide                       their degree of closeness to the typed reference according to 
the context for resolving informalities in the program. This                      the following categories relating the type (X) of the reference 
resolution is composed of two parts: (1) The hypothesizing of                     to the type (Y) of a placemarker in the context: X equals Y, X 
one particular interpretation for the informality from a set of                   is a subtype of Y, X is a part of Y, Y is a part of X, X is 
possible interpretations and (2) the testing of hypotheses.                       connected via a path of single valued relations to Y, and X is a 
                                                                                  supertype of Y. Within a category the placemarkers are 
        There are many types of informalities which can occur in                  ordered by their use in the program as: scope placemarkers 
a program specification (See [13]). These informalities                           (placemarkers bound in an IF statement predicate or a loop 

correspond in one way or another to the suppression of                            predicate), parame\erst and the remaining previously bound 
explicit information. Each informality is expressed by use of a                   placemarkers. 
partial construct in place of some intended complete construct. 
For each partial construct we have algorithms which generate                              Completely omitted references are treated exactly like 
an ordered set of possible completions. The alternatives are                      the pronoun case except that literal instances of the required 
tested by the well-formedness criteria explained in the next                      type are added as possibilities before any supertype ones. 
section. The generation algorithms represents our theory of                       Furthermore, if a literal instance is selected as the accepted 
informality resolution.                                                           binding, and all other literal instances are also acceptable, then 
                                                                                  the omitted reference is treated as a don't-care situation. 
        Although there are many types of informality handled by 
the SAFE system, we will consider only those which are                                    One remaining kind of informal reference remains--a 
resolved during the Meta-Evaluation process.                                      reference of inappropriate type. Either a descriptive 
                                                                                  reference or explicit type reference was specified but its type 
        These informalities arise because in natural                              was not compatible with the type required by the action or 
communication the first usage of an object is not labeled and                     relation in which the reference occurred. This difficulty is 
then reused for later references to that object. Instead,                         resolved by creating a new placemarker of the required type 
references tend to include as little detail as required to                        and determining an ordered set of possible conversions from 
reference objects from the current context. This might simply                     the specified type (X) to the required type (Y) from the 
be a pronoun ("it" or "one"), a type name ("the message"), a                      following list: X is a subtype of Y, X is a part of Y, Y is a part 
partial description ("the red one"), or a completely omitted                      of X, X is connected via a path of single valued relations to Y, 
reference when the desired object is already part of the                          Y is a subtype of X. 
context. Otherwise, either a full reference sufficient to 
unambiguously select the desired object from the data base, or                            Thus, for each kind of informality, an explicit ordered set 
simply a type name if the desired object is associated with an                    of possible interpretations has been created. These 
object already in context, must be used. Any references in a                      possibilities are explored by a simple backtracking search 
description may themselves be incomplete. All these                               process integrated with the Meta-Evaluation of the program so 
ambiguities are resolved in the context established by the                        that whenever an informal construct is encountered during 
running program rather than the context of the input                              Meta-Evaluation the first possible interpretation is selected 
description. This context is the set of objects already bound                     and Meta-Evaluation continues until the program has been 
and accessible in the program block. This includes the                            completely Meta-Evaluated or the program is found to be 
parameters of the program, embedding iteration placemarkers                       ill-formed (as described in the next section). In the latter 
and placemarkers bound in preceding statements.                                   case, the Meta-Evaluation process and the state of the 
                                                                                  simulated program is restored to its state at the point of the 
        Descriptive references are resolved by pattern matching                   most recent informality interpretation selection for which 
them with the simulated run-time data base. If the pattern                        remaining, untried possibilities exist. The next untried 
match succeeds then the reference placemarker is bound to                         possible interpretation for that informal construct is selected 
the matched object which must either be a literal in an                           and the Meta-Evaluation process resumed. 
asserted relation previously produced by the program or a 
previously created symbolic object (because those are the                                 This process will terminate either by finding a set of 
only categories of objects which exist in the simulated data                      interpretations which, within the documentation capabilities of 
base). If a literal was matched, then the placemarker is                          the system, yields a well-formed formal program, or by 
replaced in the program by that literal. Otherwise (a                             determining that the informal specification was unintelligible 
previously created symbolic object was matched), the                              because no well-formed program could be discovered for it. 

                                                            Auto. Pror.-;              Ralzor 
                                                                            401                 PROGRAM WELL-FORMEDNESS RULES                                       7. All expectations must be fulfilled. Informal 
                                                                                          specifications normally include descriptions of why 
        In this section we describe some of the rules which                               certain actions are being performed to help create a 
provide the basis for rejecting the current selected set of                               context for people to understand the process being 
interpretations as producing an ill-formed program. Programs                              cJescribed. Such statements create an expectation 
are highly constrained objects (one reason they are hard to                               about how the process will behave and can be used 
construct) and these constraints provide the means of                                     as a constraint on the process' behavior. 
rejecting interpretations of informality which don't make sense.                   Specific Rules—uncovers an implicit informality and specifies 
                                                                                   how to resolve it: 
        These rules are divided into two categories: (1) general 
ones which are resolved by backtracking through the current                          1. Each typed reference must have a non-empty set of 
set of selected interpretations and (2) specific ones for which                            possible interpretations—if not, then the reference 
particular fixes to the program are known. The general ones                                cannot be resolved within the current context. 
pertain to incorrect interpretations of informalities which                                Solution: Assume (and verify) that it can be resolved 
explicitly appear in the program and for which a set of                                    by the caller of the current routine. Make it a 
alternative interpretations has been generated as explained in                             parameter of the current routine and add it as an 
the previous section. The specific ones, on the other hand,                                omitted reference to all calls of this routine. 
pertain to implicit informalities in the program, which until the 
specific well-formedness rule was violated, were not known to                        2. Parameters must be directly referenced within a 
exist and for which unknowingly one particular interpretation                              routine—if they are only indirectly referenced, then 
was chosen without considering the other alternatives. The                                 those components of the parameter directly 
chosen alternative caused the specific well formedness rule to                             referenced should replace the unreferenced object 
be violated and, hence, the other alternatives must now be                                 as parameters of the routine. 
tried. 
                                                                                     3. Statements outside a conditional cannot 
        General Rules--resolved by backtracking through the                                unconditionally consume results produced in one 
explicit informalities:                                                                    branch of that conditional—either make the 
                                                                                           consuming statement part of the producing branch, 
  1. An error cannot occur during Meta-Evaluation~-in our                                  or condition its execution with the predicate of the 
        program model errors can only occur by violating                                   conditional. This corresponds to informality in 
        constraints on the data base. These constraints are                                natural language that the end of conditional 
        particular to a domain and are discovered during the                               statement is normally not explicitly signaled. 
        domain acquisition process. They may involve only 
        a single relation (such as requiring it to be single                         4. Non-produced goal (this is a specialization of the 
        valued) or combinations of relations (such as, "the                                general expectation rule)--if a statement is invoked 
        boss of a person must work for the same company                                    and is expected to produce some result but only 
        as that person").                                                                  produces a portion of the goal and the goal does not 
                                                                                           contain any unbound placemarkers outside of the 
  2. The predicate of conditional statements must not be                                   portion produced, then assert the goal using the 
        determined during Meta-Evaluation—if it is, then the                               produced portion. This corresponds to the 
        predicate is independent of the input data and the                                 informality that a "passive" construct specifying the 
        same branch of the conditional will always be                                      desired effect of some action actually indicates that 
                                                                                           the desired effect should be created from the results 
        executed. Thus, the program is ill-formed. 
                                                                                           of that action. 
 3. Each demon and procedure specified must be invoked 
        somewhere -if not, why bother to describe it.                                                              CONCLUSION 

 A. At least one placcmarkcr in the loop predicate mu^t                                    The techniques described in this paper are only the 
        be referenced within the loop body--otherwr.e, the                         beginning of a technology for understanding informal program 
        loop' body is independent of the loop predicate (we                        specifications based on theories of informality resolution and 
        are explicitly ruling out "counting loops" which                           program well-formedness acting in the context established by 
        simply determine the number of objects which                               Meta-Evaluation of the program. Each of these areas requires 
        satisfy some criteria).                                                    further development and we have only started to experiment 
                                                                                   with their interactions and, yet, this prototype system has 
 5. An action should not be invoked which only produces                            successfully transformed a few small (approximately one page) 
        redundant results (i.e., doesn't chance the data                           informal program specifications into their formal operational 
        base)—the invocation produced no effect. Lither it                         equivalents. These examples have been (carefully) extracted 
        should not be invoked or invoked with different                            from actual functional specification manuals and the prototype 
        arguments or some previous action should not have                          system accommodated to the needs of the example by 
        been invoked or invoked with different arguments.                          developing one or more of these areas. We expect that such 
                                                                                   example driven growth of the system will continue for some 
 6. All produced relations in the data base mu.t be                                time until the theories and the Meta-Evaluation technology 
        consumed (read-accessed) either by the program or                          mature and become more complete. Unfortunately, we have 
        as part of the output—otherwise, its existence in the                      been unable, so far, to represent the theories in other than a 
        data base has no effect.                                                   procedural manner so that growth and modification are ad-hoc 
                                                                                   and quite intertwined with the Meta-Evaluation process itself. 

                                                             Auto. Pror.-2: Ralzer 
                                                                             U02 