                Fast Algorithm for Connected Row Convex Constraints∗

                                            Yuanlin Zhang
                                         Texas Tech University
                                     Computer Science Department
                                           yzhang@cs.ttu.edu


                    Abstract                          is the number of constraints and γ the maximum degree of
                                                      the constraint graph.
    Many interesting tractable problems are identiﬁed   In this paper, making use of the row convexity and connect-
    under the model of Constraint Satisfaction Prob-  edness of constraints, we propose a new algorithm to solve
    lems. These problems are usually solved by forcing CRC constraints with time complexity of O(nσ2d + ed2)
    a certain level of local consistency. In this paper, where σ is the elimination degree of the triangulated graph of
    for the class of connected row convex constraints, the given problem. We observe that the satisﬁability of CRC
    we propose a novel algorithm which is based on    constraints is preserved when a variable is eliminated with
    the ideas of variable elimination and efﬁcient com- proper modiﬁcation of the constraints on the neighbors of the
    position of row convex and connected constraints. eliminated variable. The new algorithm simply eliminates the
    Compared with the existing work including ran-    variables one by one until it reaches a special problem with
    domized algorithms, the new algorithm has better  only one variable.
    worst case time and space complexity.               A key operation in the elimination algorithm is to com-
                                                      pose two constraints. The properties of connectedness and
1  Introduction                                       row convexity of the constraints make it possible to get a fast
                                                      composition algorithm with time complexity of O(d).
Constraint satisfaction techniques have found wide applica- In this paper, we present the elimination algorithm after
tions in combinatorial optimisation, scheduling, conﬁgura- the preliminaries on CRC constraints. The methods to com-
tion, and many other areas. However, Constraint Satisfaction pute composition of row convex and connected constraints
Problems (CSP) are NP-hard in general. One active research are then proposed. We examine the elimination algorithm on
area is to identify tractable CSP problems and ﬁnd efﬁcient problems with sparse constraint graphs before we conclude
algorithms for them.                                  the paper.
  An interesting class of row convex constraints was iden-
tiﬁed by van Beek and Dechter (1995). It is known that if 2 Preliminaries
a problem of row convex constraints is path consistent, it is
                                                      A  binary constraint satisfaction problem (CSP) is a triple
tractable to ﬁnd a solution for this problem. However, when V,D,C   V                       D  ={D  | x ∈
the problem is not path consistent, path consistency enforcing ( ) where is a ﬁnite set of variables, x
                                                      V and Dx is the ﬁnite domain of x}, and C is a ﬁnite set of
might not lead to global consistency due to the possibility that                        V
the row convexity of some constraints is destroyed. Deville binary constraints over the variables of . As usual, we as-
                                                      sume there is only one constraint on a pair of variables. We
et al. (1997) restrict row convexity to connected row convex- n e d
ity (CRC). In fact, the scene labeling problem and constraint use , , and to denote the number of variables, the number
                              [                       of constraints, and the maximum domain size of a CSP prob-
based grammar examples given in van Beek and Dechter,             i, j, . . . x, y, . . .
1995] are CRC constraints. One can ﬁnd a solution of CRC lem. We use    and        to denote variables in this
                                                      paper. The constraint graph of a problem (V,D,C) is a graph
constraints by enforcing path consistency. Deville et al. also    V          E =  {{i, j}|c  ∈ C}
provide an algorithm more efﬁcient than the general path con- with vertices and edges     ij     . A CSP
sistency algorithm by making use of certain properties of row is satisﬁable if there is an assignment of values to variables
                                                      such that all constraints are satisﬁed.
convexity. The algorithm has a worst case time complexity                                             D
of O(n3d2) with space complexity of O(n2d) where n is   Assume there is a total ordering on each domain of .
the number of variables, d the maximum domain size. Re- When necessary, we introduce head and tail for each variable
cently, Kumar (2006) has proposed a randomized algorithm domain such that head (tail respectively) is smaller (larger
                                      O(γn2d2)        respectively) than any other value of the domain. Func-
for CRC constraints with time complexity of    and              u, D   u  ∈  D  ∪{      }           u, D
space complexity O(ed) (personal communication) where e tions succ( i)(        i   head  ) and pred(   i)
                                                      (u ∈ Di ∪{tail}) denote respectively the successor and pre-
  ∗
   The research leading to the results in this paper was funded in decessor of u in the current domain Di∪{head, tail}. The
part by NASA-NNG05GP48G.                              domain Di is omitted when it is clear from the context.

                                                IJCAI-07
                                                   192                                                                           
  Given a constraint cij and a value a ∈ Di, the extension (V −{x},D,C ) where C = C ∪{cxj ◦cix ∩cij | cjx,cix ∈
set cij[a] is {b ∈ Dj | (a, b) ∈ cij}. cij[a] is also called the Rx and i = j}−Rx. In the elimination, when composing
image of a with respect to cij. Clearly cij[head]=cij[tail]= cix and cxj,ifcij ∈/ C we simply take cij as a universal
∅. Standard operations of intersection and composition can constraint, i.e., Di × Dj.
be applied to constraints. The composition of cix and cxj
is denoted by cxj ◦ cix. It is convenient to use a Boolean Theorem 1 Consider an arc consistent problem P =(V,D,C)
matrix to represent a constraint cij. The rows and columns of CRC constraints and a variable x ∈ V .  Let
are ordered by the ordering of the values of Di and Dj. P =(V ,D,C) be the problem after x is eliminated. P is
  A constraint cij is arc consistent (AC) if every value of satisﬁable iff P  is satisﬁable.
Di has a support in Dj and every value of Dj has a support
                                                                                                
in Di. A CSP problem is arc consistent if all its constraints Proof We ﬁrst prove if P is satisﬁable, so is P . Let s be
are arc consistent. A path x,...,y of a constraint graph is a solution of P , sx an assignment of x by s, and sx¯ be the
                                                                       
consistent if for any assignments x = a and y = b such that restriction of s to V . We only need to show that sx¯ satisﬁes
                                                            
(a, b) ∈ cxy, there is an assignment for each of other variables cij ∈ C for all cix,cxj ∈ C. Since s is a solution of P , sx¯
                                                                                            
in the path such that all constraints over the path are satisﬁed satisﬁes cix, cjx and cij. Hence, sx¯ satisﬁes cij.
by the assignments. A constraint graph is path consistent if Next we prove if P  is satisﬁable, so is P . Let t be a solu-
every path of the graph is consistent. A CSP is path consistent tion of P . We will show that t is extensible consistently to
if the completion of its constraint graph is path consistent. A x in P . Let Vx be {i | cix ∈ Rx}. For each i ∈ Vx, let the
CSP is partially path consistent if its constraint graph is path assignment of i in t be ai. Let S = {cix[ai] | i ∈ Vx}. Since
consistent [Bliek and Sam-Haroud, 1999].              all constraints of P are row convex and P is arc consistent,
  A constraint cij is row convex if there exists a total order- the sets of S are convex and none of them is empty.
      D
ing on  j such that the 1’s are consecutive in each row of Consider any two sets cix[ai],cjx[aj] ∈ S. Since t is a
the matrix of cij. The reduced form of a constraint cij, de-    P  (a ,a ) ∈ c     c               P 
         ∗                                            solution of ,  i  j    ij where ij is a constraint of .
noted by cij, is obtained by removing from Di (and Dj re-         
                                                      The fact that cij = cxj ◦ cix ∩ cij, where cij is either in C
spectively) those values whose image with respect to cij (cji
                                                      or universal, implies that there exists a value b ∈ Dx such
respectively) is empty. For a row convex constraint cij, the
                                                      that ai,aj and b satisfy cix,cjx and cij. Hence, cix[ai] ∩
image of a ∈ Di can be represented as an interval [u, v] c [a ] = ∅
      u              v                 D               jx  j    . By the property on the intersection of convex
where   is the ﬁrst and is the last value of j such that sets, the intersection of the sets of S is not empty. For any
(a, u), (a, v) ∈ cij. A row convex constraint cij is connected v ∈∩ E                (t, v)            P
            [a, b]  [a,b]                                E∈S   , it is easy to verify that is a solution of .
if the images   and       of any two consecutive rows Therefore, P is satisﬁable.                      2
(and columns respectively) of cij are not empty and satisfy
[a, b]∩ [    a b] = ∅   [a, b]∩ [a    b ] = ∅     Based on Theorem 1, we can reduce a CSP with CRC con-
       pred(  ),        or         , succ(  )     .   straints by eliminating the variables one by one until a trivial
Note that, for our purposes, the deﬁnition of connectedness problem is reached.
here is stronger than that by Deville et al. (1997). If a con-
straint is row convex and connected, it is arc consistent. A
constraint cij is connected row convex if its reduced form is Algorithm 1: Basic elimination algorithm for CRC con-
row convex and connected. The constraints obtained from the straints
                                                          eliminate (inout(V, D, C), out consistent, s)
intersection or composition of two CRC constraints are still 1 // (V, D, C) is a CSP problem, s is a stack
connected row convex. The transposition of a CRC constraint 2 enforce arc consistency on (V, D, C)
                                                           3 if some domain of D becomes empty then
is still connected row convex. Enforcing path consistency on 4  consistent ← false, return
a CSP of CRC constraints will make the problem globally    5 consistent ← true
                                                                   
consistent [Deville et al., 1997].                         6 C ← C, C ←∅, L ← V
                                                           7 while L = ∅ do
  The consistency property on row convex constraints is due 8   select and remove a variable x from L
                                                                             
                                           U               9    Cx ←{cyx | cyx ∈ C }
to some nice property on convex sets. Given a set and a                     
                                                          10    foreach cix,cjx ∈ Cx where i<jdo
            ≤          A  ⊆ U                                      
total ordering on it, a set   is convex if its elements   11       cij ← cxj ◦ cix
                                                                                
are consecutive under the ordering, that is               12       if cij ∈ C then cij ← cij ∩ cij
                                                                                 
                                                          13       C ← (C −{cij }) ∪{cij }
         A = {v ∈ U | min A ≤ v ≤ max A}.                                              
                                                          14       collect to Q the values not valid under cij
                                                          15    remove from the domains the values in Q and propagate the removals
Consider a collection of sets S = {E1,...,Ek} and an or-  16    if some domain becomes empty then
                                                                         ←
dering ≤ on ∪i=1..kEi where every Ei(1 ≤ i ≤ k) is convex. 17      consistent false, return
                                                                C ← C − C
                          S                               18            x
The intersection of the sets of is not empty if and only if          
                                                          19    C ← C  ∪ Cx
the intersection of every pair of sets of S is not empty [van 20 s.push (x)
                                                                 
Beek and Dechter, 1995; Zhang and Yap, 2003].             21 C ← C , consistent ← true

3  Variable elimination in CRC                          The procedure eliminate((V,D,C), consistent, s) in Al-
Consider a problem (V,D,C) and a variable x ∈ V . The rele- gorithm 1 eliminates the variables of (V,D,C). When it
vant constraints of x, denoted by Rx, are the set of constraints returns, consistent is false if some domain becomes empty
{ cyx | cyx ∈ C}.Toeliminate x is to transform (V,D,C)to and true otherwise; the eliminated variables are pushed to the

                                                IJCAI-07
                                                   193stack s in order and C will contain only the “removed” con- of connectedness is stronger than the original deﬁnition. The
straints associated with the eliminated variables. Most parts following property is clear and useful across this section.
of the algorithm are clear by themselves. The body of the
while loop (lines 7 – 20) eliminates the variable x. Line 18 Property 1 Given two row convex and connected constraints
            C                       x     C
discards from  the constraints incident on , i.e., x. and cix and cxj, let cij be their composition. For any u ∈ Di,
               x                               C
Line 19–20 push  to the stack and put the constraints x, cij[u]
                                                         is not empty.
which are associated to x, into C . After eliminate, the
stack s, D (revised in lines 2, 15), and C will be used to ﬁnd To compose two constraints cix and cxj, one can simply
a solution of the original problem.                   multiply their matrices, which amounts to the complexity of
                                                          3
  On top of the elimination algorithm, it is rather straightfor- O(d ) . We will present fast algorithms to compute the com-
ward to design an algorithm to ﬁnd the solutions of a prob- position in this section. Constraints here can use an interval
lem of CRC constraints (Algorithm 2). L (line 5) represents representation deﬁned below. For every cij ∈ C and u ∈ Di,
the assigned variables. Cx in line 8 contains only those con- cij[u].min is used for min{v | (u, v) ∈ cij}, and cij[u].max
straints that involve x and an instantiated variable. In line 10, for max{v | (u, v) ∈ cij}.
when Cx is empty, the domain Dx is not modiﬁed.
                                                      4.1  Basic algorithm to compute composition
                                                      With the interval representation, we have procedure compose
   Algorithm 2: Find a solution of CRC constraints
                                                      in Algorithm 3. For any value u ∈ Di and v ∈ Dj, lines 6–8
   solve (in (V, D, C), out consistent)
    1 // (V, D, C) is a CSP problem                   compute whether (u, v) ∈ cxj ◦ cix. By Property 1, min ≤
    2 create an empty stack s                         max is always true for line 10.
    3 eliminate ( (V, D, C), consistent, s)
    4 if not consistent then return
    5 L ←∅
    6 while not s.empty () do                                        Basic algorithm for computing the composition
         x ←                                             Algorithm 3:
    7       s.pop ()                                     of two constraints
    8    Cx ←{cix | cix ∈ C, i ∈ L}
                                                                  c  ,c     c
    9    for each i ∈ L, let bi the assignment of i       compose (in ix xj , out ij )
                                                            u ←        D
   10    Dx ←∩c  ∈Cx cix[bi]                               1    succ (head, i)
               ix                                               u =
         choose any value a of Dx as the assignment of x   2 while tail do
   11                                                           v ←       D
   12    L ← L ∪{x}                                        3       succ (head, j )
                                                           4    min ← tail, max ← head
                           L
   13 output the assignment of the variables of            5    while v = tail do
                                                           6       if not disjoint (cix[u], cjx[v]) then
                                                           7          if v>max then max ← v
                                                           8          if v<min then min ← v
                                                           9       v ← succ (v, Dj )
Theorem 2 Assume the time and space complexity of the     10    cij [u].min ← min, cij [u].max ← max
composition (and intersection respectively) of two constraints 11 u ← succ (u, Di)
are O(α) and O(1). Further assume the time and space com- disjoint (in cix[u],cjx[v])
                                   O(ed2)    O(β)         12 if (cix[u].min >cjx[v].max) or (cix[u].max <cjx[v].min) then
plexity of enforcing arc consistency are  and     .       13    return true
Given a CRC problem P =(V,D,C), a solution of the prob-   14 else return false
lem can be found in O(n3α) with working space O(n + β).

  Assume the constraint graph of P is complete. For every
variable, there are at most n neighbors. So, to eliminate a Proposition 1 The procedure of compose has a time com-
variable (line 10–14) takes O(n2α). Totally, n variables are plexity of O(d2) and space complexity is O(1).
                                           3
removed. So, the complexity of eliminate is O(n α). The
                                                        The two while loops (lines 2, 5) give a time complexity of
procedure eliminate dominates the complexity of solve     2
and thus to ﬁnd a solution of P takes O(n3α + ed2) where O(d ).                                        2
ed2 is the cost (amortizable) of removing values and its prop- We emphasize that, due to the interval representation of
agation. Working space here excludes the space for the rep- constraints, for any cix and cxj we need to call compose
resentation of the constraints and the new constraints created twice to compute cij and cji separately. This does not af-
by elimination. It is useful to distinguish the existing non- fect the complexity of those algorithms using compose.For
randomized algorithms. Throughout this paper, space com- example, for eliminate to use compose we need to change
plexity refers to working space complexity by default. A i<j(line 10 of Algorithm 1) to i = j.
stack s and a set L are used by solve and eliminate to
hold variables. They need O(n) space. The total space used 4.2 Remove values without support
by solve is O(n+β) where β is the space cost (amortizable) Although composition does not lead to the removal of values
of removing values and its propagation.          2    under our assumption, the intersection will inevitably cause
                                                      the removal of values. In this case, to maintain the row con-
4  Composing two CRC constraints                      vexity and connectedness, we need to remove values without
                                                      support from their domains. The algorithm removeValues,
In this section, we consider only constraints that are row con- listed in Algorithm 4, makes use of the interval representation
vex and connected. These constraints are arc consistent in (line 6–11) to propagate the removal of values. If a domain
accordance with our deﬁnition. Remember that our deﬁnition becomes empty (line 13), we let the program involving this
                                                      procedure exit with an output indicating inconsistency.

                                                IJCAI-07
                                                   194                                                                                c .l              u   D
   Algorithm 4: Remove values                         row that contains at least a 1, ij  the ﬁrst value of i
                                                              c  [u]    min  c .l             v   D
   removeValues (in (V, D, C), Q)                     such that ij .min=   , ij ⊥ the last value of i such
    1 // Q is a queue of values to be removed         that cij[v].min=min, cij.r the ﬁrst value u of Di such that
    2 while Q = ∅ do                                 c [u]     max      c .r             v   D
    3    take and delete a value (u, x) from Q         ij  .max=    , and ij ⊥ the last value of i such that
    4    foreach variable y such that cyx ∈ C do      cij[v].max=max.Ifcij is row convex and connected, cij.t
    5        foreach value v ∈ Dy do
    6           if cyx[v].min = u = cyx[v].max then   = succ(head, Di) and cij.b = pred(tail, Di). The ﬁelds are
    7              Q ← Q ∪{(v, y)}                    related as follows.
    8           else if u = cyx[v].min then
    9              cyx[v].min ← succ (u, Dx)
   10           else if u = cyx[v].max then           Proposition 3 Given a row convex and connected constraint
   11              cyx[v].max ← pred (u, Dx)          cij, for all u ∈ Di such that cij.l ≤ u ≤ cij.l⊥, cij[u].min=
   12           delete u from Dx                      min; for all u such that cij.r ≤ u ≤ cij.r⊥, cij[u].max=
   13           if Dx = ∅ then output inconsistency, exit
                                                      max; and the relation between cij.l (cij.l⊥) and cij.r
                                                      (cij.r⊥) can be arbitrary.

                                                              ...........................................................................................................................................................
                                                                       ..... .....    ..... .....
                                                           t          ....  .....    ..... ....
                                                                      ..... .....    ..... .....
                                                                  ......................................................... ..... ..... ...
                               (V,D,C)                                       .....  .....
Proposition 2 Given a CSP problem       of CRC con-                           ..... .....       l1
                                                              ..............................................................................................................................................................
straints with an interval representation, the worst case time l2
                             O(ed2)                                   b shape        d shape
complexity of removeValues is       with space com-           ...........................................................................................................................................................
                                                                ...    ...                ...    ...
                                                           l    ...     ...              ...     ...
                                                            2   ...     ...              ...     ...
        O(nd)                                                    ...    ...              ...    ...
plexity of    .                                                  ...    ...              ...    ...
                                                                 ...     ...            ...     ...
                                                              ..................... ................................ ............................................................... ................................. ............
                                                           l3
Let δi be the degree of variable i ∈ V . To delete a value         \ shape     o shape    / shape
                                                              .............................................................................................................................................................
(line 4–12), the cost is δid. In the worst case, nd values are l      .....                .....
                                                           3         .....               .....
                                                                   ....................................................... .. .. .....
                                                                       .....  ..... ..... .....
                                         δid × d =                      ..... ..... ..... ..... l4
removed. Hence the time complexity is i∈1..n                            ..... ..... ..... .....
    2                                                      b  ................................................................................................................. ..........................................
O(ed ). The space cost for Q is O(nd).           2                     q shape       p shape
  Given a problem of CRC constraints that are represented
                           c      u ∈  D              Figure 2: The possible shapes of the strips of a constraint that
by matrix, for each constraint ij and    i, we setup  is row convex and connected
cij[u].min and cij[u].max and collect the values of Di with-
out support. Let Q contain all the removed values during the Consider a row convex and connected constraint cij. Let
setup stage, we then call removeValues to make the prob- l1,l2,l3,l4 be the sorted values of cij.l, cij.r, cij.l⊥, and
lem arc consistent. This process has a time complexity of cij.r⊥. The matrix of cij consists of the following strips. 1)
    2
O(ed ) with working space complexity O(nd) (due to Q). Top strip denotes the rows from cij.t to l2,2)middle strip the
  By the above process, Theorem 1, and Proposition 2, it rows from l2 to l3, and 3) bottom strip the rows from l3 to
is clear that the procedure solve equipped with compose cij.b (b in the diagram).
and removeValues  has the following property. Note that The row convexity and connectedness of cij implies that
the time and space cost of removeValues are “amortized” the 1’s in its top strip can be of only ’b’ shape or ’d’ shape, the
in eliminate.                                         1’s in its middle strip of only ’\’ shape, ’o’ shape, or ’/’ shape,
                                                      and the 1’s in its bottom strip of only ’q’ shape or ’p’ shape
Corollary 1 Given a problem of CRC constraints, solve (see Figure 2). Note that these shapes are abstract shapes and
can ﬁnd a solution in time O(n3d2) with space complexity do not have the ordinary geometrical properties. The strips
O(nd).                                                and shapes are characterised by the following properties.

4.3  Fast composition of constraints                  Property 2 Top strip: for every u1,u2 ∈ [cij.t, l2] where
As one may see, compose makes use of the row convexity to u1 ≤ u2, cij[u1] ⊆ cij[u2]. Middle strip: for ev-
the minimal degree. In fact, we can do better.        ery u1,u2 ∈  [l2,l3] where u1 = pred(u2), shape ’\’ im-
                                                      plies cij[u1].min≤cij[u2].min and cij[u1].max≤cij[u2].max;
                     ..     ..
                     .......... .. ..........
              tt.....   .. . ....                                     c [u ]=c    [u ]
                     ..... .. .....                   shape ’o’ implies ij 1    ij 2 ; and shape ’/’ implies
                     ..... .. .. .....
                    ....... ... .....
                  ....... .... .. ...........         c [u ]   ≤c  [u ]       c  [u ]   ≤c  [u ]
              l   .    ..  ... .  r                    ij 2 .min  ij 1 .min and ij 2 .max  ij 1 .max. Bot-
               
      ... ..       

                     ..  .. ...
                    .   ... ..                                           u ,u  ∈  [l ,c .b]     u  ≤  u
                      ... ...                         tom strip: for every 1 2     3  ij  where  1     2,
                  .. ... ..  .. ..
                  ....... ... .. .. ..........
              l     ..... .. .. ..... r               c [u ] ⊆ c [u ]
               ⊥     ....... .. ...... ⊥               ij 2    ij  1 .
                     ..... .. .......
                     . ..... ... ... ..... .
              b      .......... . .......... b
                                                        Assume  cix and cxj are row convex and connected. The
 Figure 1: The area of 1’s in the matrix of a CRC constraint new algorithm to compute cxj ◦ cix, listed in Algorithm 5,
  The 1’s in the matrix of a CRC constraint form an ab- is based on the following two ideas. 1) We ﬁrst compute
stract shape (the shaded area in Figure 1) where the slant cij[u].min for all u ∈ Di (line 2–21), which is called min
edges mean monotonicity rather than concrete boundaries. phase, and then compute cij[u].max for all u ∈ Di (line
It is characterised by the following ﬁelds associated with 22–41), which is called max phase. 2) In the two phases,
cij. Let min =min{cij[u].min | u ∈ Di}  and max  =    the properties of the shapes and strips of cix are employed to
max{cij[u].max | u ∈ Di}. The ﬁeld  cij.t denotes the speed up the computation.
value of Di corresponding to the ﬁrst row that contains at In the min phase, the algorithm starts from the top strip of
least a 1, cij.b the value of Di corresponding to the last cix. Let u = cix.t. Find cij[u].min (line 5) and let it be v.

                                                IJCAI-07
                                                   195      Algorithm 5:             Fast algorithm for computing the composition                                        Algorithm 6:            Search methods for computing the composition
      of two constraints                                                                                           of two constraints
       fastCompose (in        cix,cxj    ,  out  cij )                                                              searchToLeft (inout         cix,cxj    ,u,l,v,cij    )
         1  let l1,...,l4    be the ascendingly sorted values of l,l⊥,r,r⊥        of cix                            1  // search to the left of v
         2  // min phase                                                                                              2   while u  ≤l  do
         3  // process the top strip of cix                                                                           3         ﬁnd ﬁrst v1 from  v down to  head  of Dj  such that
         4  u  ←   cix.b                                                                                                        cix[u]  ∩  cjx[pred(v1)] =       ∅
                                           v  ∈  D             c   [u] ∩  c    [v] = ∅
         5  ﬁnd from  head   to tail the ﬁrst      j such that  ix          jx                                        4         cij [u].min =  v1, v ←   v1,  u  ←  succ   (u, Di)
         6  cij  [u].min ←   v
                                                                                                                    searchToLeftWrap          (inout  cix,cxj    ,u,l,v,cij    )
         7  searchToLeft       (cix,cxj   ,u,l2,v,cij     )
                                                                                                                      5  // search to the left of v
         8  // process the middle strip                                                                               6  wrapToRight    ←  false
         9  if the middle strip is of ’o’ shape then                                                                  7   while u  ≤l  do
                   u  ←  l
       10                 2                                                                                           8         ﬁnd ﬁrst v1 from  v down to  head  of Dj  such that
                          u ≤   l     {c    [u]      ←   v  u ←          u, D    }
       11          while         3 do    ij    .min       ,       succ   (     i)                                               cix[u]  ∩  cjx[pred(v1)] =       ∅ and  cix[u]   ∩ cjx[v1]    = ∅
       12   if the middle strip is of ’\’ shape then                                                                  9         if v1 does not exist then {wrapToRight    ←  true, break  }
       13          if v = cjx.t  and  cix[u].max    <cjx[pred(v)].min       then                                   10          else {cij [u].min  ←   v1, v ←   v1,  u  ←  succ   (u, Di)}
                         searchToLeftWrap         (cix,cxj   ,u,l3,v,cij     )
       14                                                                                                           11   if wrapToRight   is true and u ≤l  then
       15          else searchToRight      (cix,cxj    ,u,l3,v,cij     )                                            12          searchToRight       (cix,cxj   ,u,l,  succ   (head, Dj  ), cij )
       16   if the middle strip is of ’/’ shape then                                                                searchToRight        (inout   cix,cxj   ,u,l,v,cij     )
       17          if v = cjx.t  and  cix[u].min   >cjx[pred(v)].max         then                                  13   // search to the right of v
       18                searchToLeftWrap         (cix,cxj   ,u,l3,v,cij     )                                      14    while u  ≤l  do
                                                                                                                    15          ﬁnd ﬁrst v1 from  v to tail of Dj such that
                                            c    ,c    ,u,l3,v,c
       19          else searchToRight      (  ix   xj               ij )                                                        cix[u]  ∩  cjx[pred(v1)] =       ∅ and  cix[u]   ∩ cjx[v1]
       20   // bottom strip                                                                                         16          cij [u].min ←   v1,  v ←   v1,  u ←   succ   (u, Di)
            searchToRight        (cix,cxj   ,u,cij   .b, v, cij )
       21                                                                                                           searchToRightMax          (inout  cix,cxj    ,u,l,v,cij    )
       22   // max phase                                                                                            17   // search to the right of v
       23   // process the top strip                                                                                18    while u  ≤l  do
       24   u  ←   cix.b
                                                                                                                    19          ﬁnd last v1 from v  to tail of Dj such that cix[u]  ∩ cjx[v1]    = ∅
       25   ﬁnd the last v ∈  Dj   such that cix[u]  ∩  cjx[v]   = ∅
                                                                                                                    20          cij [u].max  ←   v1,  v ←   v1, u  ←   succ  (u, Di)
       26   cij  [u].max  ←   v
                                                                                                                                                      c    ,c    ,u,l,v,c
       27   searchToRightMax         (cix,cxj   ,u,l2,v,cij     )                                                   searchToRightWrap          (inout   ix   xj             ij )
                                                                                                                                                v
       28   // process the middle strip                                                                             21   // search to the right of
                                                                                                                                      ←
       29   if the middle strip is of ’o’ shape then                                                                22   wrapToLeft       false
                                                                                                                                u  ≤l
       30          u  ←  l2                                                                                         23    while        do
                                                                                                                                        v        v           D
       31          while  u ≤   l3 do {cij  [u].max  ←   v, u  ←   succ  (u, Di)}                                   24          ﬁnd last  1 from    to tail of j such that
                                                                                                                                cix[u]  ∩  cjx[succ(v1)] =       ∅ and  cix[u]   ∩ cjx[v1]    = ∅
                                     \
       32   if the middle strip is of ’ ’ shape then                                                                25          if v1 does not exist then {wrapToLeft   ←   true, break }
                     v  = c   .b      c   [u]       <c     [      (v)]
       33          if       jx    and   ix     .max      jx  succ       .min then                                   26          else {cij [u].max   = v1, v  ←   v1, u  ←   succ  (u, Di)  }
       34                searchToRightWrap         (cix,cxj    ,u,l3,v,cij     )
                                                                                                                    27   if wrapToLeft  is true then
                                               c    ,c    ,u,l   ,v,c
       35          else searchToLeftMax       (  ix   xj       3       ij )                                         28          searchToLeftMax        (cix,cxj   ,u,l,  pred   (tail, Dj ), cij )
       36   if the middle strip is of ’/’ shape then                                                                searchToLeftMax         (inout   cix,cxj   ,u,l,v,cij     )
                     v  = c   .b      c   [u]      >c      [      (v)]
       37          if       jx    and   ix     .min      jx  succ      .max  then                                   29   // search to the left of v
                                                    c   ,c     ,u,l   ,v,c
       38                searchToRightWrap         ( ix    xj       3       ij )                                    30    while u  ≤l  do
                                                                                                                                         v        v                   D
       39          else searchToLeftMax       (cix,cxj    ,u,l3,v,cij     )                                         31          ﬁnd ﬁrst  1 from    down to  head  of   j such that
                                                                                                                                cix[u]  ∩  cjx[v1]   =  ∅
            // bottom strip
       40                                                                                                           32          cij [u].max  ←   v1,  v ←   v1,u   ←  succ   (u, Di)
       41   searchToLeftMax        (cix,cxj    ,u,cij   .b, v, cij )
       42   set the ﬁelds of cij : t, b, l,l⊥,r,r⊥

                                                                                                                 The max phase is similar. Finally, according to the new                                    cij,
                                                                               c    [u]
Due to the property of the top strip, we can ﬁnd                                 ij     .min    for          we set the attributes of              cij   in a proper way (line 42). Clearly,
all  u   ∈    [cij.t, l2]     in order by scanning                once     from     v   down to              for each phase, we only need a time cost of                             O(d).
head     of   Dj, i.e., searching to the left of                  v  (line 7). The search
procedure         searchToLeft               is listed in Algorithm 6 where one
                                v                            v                                               Proposition 4            The algorithm             fastCompose               is correct and
needs to note that                  is replaced by             1   in line 4. Similarly,                     composes two constraints in time complexity of                                     O(d)       with
we can process the bottom strip by searching to the right of                                                 space complexity of               O(1).
v  ∈   Dj    (line 21). For the middle strip, we have three cases for
the three shapes. By Property 2, lines 9–11 are quite straight-
forward for the ’o’ shape. For the ’\’ shape (line 12–15),                                                   5      CSP’s with sparse constraint graphs
if  v   is not the ﬁrst column of                   cxj   and     cix[u]     is “above” the                  The practical efﬁciency of                   eliminate            is affected by the or-
interval of the column before                      v  of   cxj    (line 13), we need to                      dering of the variables to be eliminated. Consider a constraint
search to the left of              v   to be sure we do not miss any value                                   graph with variables              {1,   2,  3,  4,  5}   that is shown in the top left
of   Dj    that is smaller than               v  but is a support of              a   ∈    [u, l3].          corner of Figure 3. In the ﬁrst row, we choose to eliminate                                        1
Due to the property of the ’\’ shape, after we hit the                                  head      of         ﬁrst and then         3. In this process, no constraints are composed.
Dj     and no support is found, we need to search to the right                                               However, if we ﬁrst eliminate                       2  and then        4  as shown in the
until    tail  if necessary (line 14). This process is implemented                                           second row,           eliminate             needs to make 3 compositions in
as  searchToLeftWrap                     (line 5–12 of Algorithm 6). The cor-                                eliminating each of variable                   2  and    4.
rectness of this method is assured by the connectedness as                                                       The topology of a constraint graph can be employed to ﬁnd
well as row convexity of                     cix   and     cxj. The details are not                          a good variable elimination ordering. Here we consider trian-
given here due to space limit. Otherwise (line 15), we only                                                  gulated graphs. An undirected graph                           G    is  triangulated         if for
need to search to the right of                   v   for values in        [u, l3]. The pro-                  every cycle of length 4 or more in                          G, there exists two non-
cess for the ’/’ shape is similar to that for the ’\’ shape with                                             consecutive vertices of the cycle such that there is an edge
some “symmetrical” differences (line 17).                                                                    between them in               G. Given a vertex                x    ∈    G,N(x) denotes

                                                                                                 IJCAI-07
                                                                                                      196