                  Decidable Reasoning in a Modiﬁed Situation Calculus
                         Yilan Gu                               Mikhail Soutchanski
                Dept. of Computer Science                 Department of Computer Science
                   University of Toronto                         Ryerson University
                  10 King’s College Road                     245 Church Street, ENG281
              Toronto, ON, M5S 3G4, Canada                Toronto, ON, M5B 2K3, Canada
               Email: yilan@cs.toronto.edu                   Email: mes@scs.ryerson.ca

                    Abstract                          of knowledge representation formalisms, which play an im-
                                                      portant role in providing the formal foundations of several
    We consider a modiﬁed version of the situation cal- widely used Web ontology languages including OWL in the
    culus built using a two-variable fragment of the  area of the Semantic Web. Many expressive DLs can be trans-
                                                                2
    ﬁrst-order logic extended with counting quantiﬁers. lated to FO and offer considerable expressive power going
    We mention several additional groups of axioms    far beyond propositional logic, while ensuring that reasoning
    that can be introduced to capture taxonomic rea-  is decidable [Borgida, 1996]. DLs have been mostly used to
    soning. We show that the regression operator in this describe static knowledge bases. However, several research
    framework can be deﬁned similarly to regression in groups consider formalization of actions using DLs or exten-
    the Reiter’s version of the situation calculus. Using sions of DLs. Following the key observation that reasoning
    this new regression operator, we show that the pro- about complex actions can be carried in a fragment of the
    jection and executability problems are decidable in propositional situation calculus, [Giacomo et al., 1999] give
    the modiﬁed version even if an initial knowledge  an epistemic extension of DLs to provide a framework for the
    base is incomplete and open. For an incomplete    representation of dynamic systems. However, the representa-
    knowledge base and for context-dependent actions, tion and reasoning about actions in this framework are strictly
    we consider a type of progression that is sound with propositional, which reduces the representation power of this
    respect to the classical progression. We show that framework. In [Baader et al., 2005], Baader et al. provide
    the new knowledge base resulting after our progres- another proposal for integrating description logics and ac-
    sion is deﬁnable in our modiﬁed situation calculus tion formalisms. They take the well known description logic
    if one allows actions with local effects only. We ALCQIO  (and its sub-languages) as foundation and show that
    mention possible applications to formalization of the complexity of executability and projection problems (two
    Semantic Web services.                            basic reasoning problems for possibly sequentially composed
                                                      actions) coincides with the complexity of standard DL rea-
                                                      soning. However, actions (services) are represented in their
1  Introduction                                       paper meta-theoretically, not as ﬁrst-order (FO) terms. This
The situation calculus is a popular and well understood pred- can potentially lead to some complications when speciﬁca-
icate logic language for reasoning about actions and their ef- tions of other reasoning tasks (e.g., planning) will be consid-
fects [Reiter, 2001]. It is used to provide a well-deﬁned se- ered because it is not possible to quantify over actions in their
mantics for Web services and a foundation for a high-level framework. In our paper, we take a different approach and
programming language Golog [Reiter, 2001; McIlraith and represent actions as FO terms, but achieve integration of tax-
Son, 2002]. However, because the situation calculus is for- onomic reasoning and reasoning about actions by restricting
mulated in a general predicate logic, reasoning about effects the syntax of the situation calculus and by introducing addi-
of sequences of actions is undecidable (unless some restric- tional axioms to represent a taxonomy.
tions are imposed on the theory that axiomatizes the initial Because after doing longer and longer sequences of ac-
state of the world). The ﬁrst motivation for our paper is tions, solving projection problems becomes increasingly
intention to overcome this difﬁculty. We propose to use a more difﬁcult, it is beneﬁcial to progress the initial incom-
                      2
two-variable fragment FO of the ﬁrst-order logic (FOL) as a plete knowledge base (KB) to represent the current state of
foundation for a modiﬁed situation calculus. Because the sat- the world. Then, the subsequent projection problems can be
isﬁability problem in this fragment is known to be decidable solved with respect to a new progressed KB. The task of com-
(it is in NEXPTIME), we demonstrate that by reducing rea- puting a progressed KB is called the progression problem.
soning about effects of actions to reasoning in this fragment, Our paper is structured as follows. In Section 2, we brieﬂy
one can always guarantee decidability. The second motiva- review the Reiter’s situation calculus and the extension of
                                                         2
tion for our paper comes from description logics. Description FO with counting quantiﬁers. In Section 3 we discuss de-
Logics (DLs) [Baader et al., 2003] are a well-known family tails of our proposal: a modiﬁed situation calculus. In Section

                                                 IJCAI07
                                                  18914 we consider an extension of regression (the main reasoning rally. Regression is a central computational mechanism that
mechanism in the situation calculus). Finally, in Section 5 we forms the basis for automated solution to the executability
discuss the progression problem and in Section 6 we discuss and projection tasks in the SC [Reiter, 2001]. A recursive
brieﬂy other related approaches to reasoning about actions. deﬁnition of the regression operator R on any regressable
                                                      formula φ is given in [Reiter, 2001]. We use notation R[φ] to
                                                                                               Poss
2  Background                                         denote the formula that results from eliminating atoms
                                                      in favor of their deﬁnitions as given by action precondition
The situation calculus (SC) Lsc is a predicate language for axioms and replacing ﬂuent atoms about do(α, s) by logically
axiomatizing dynamic systems. All dialects of the SC Lsc equivalent expressions about s as given by SSAs repeatedly
include three disjoint sorts: actions, situations and objects. until it cannot make such replacement any further. The
Actions are FO terms consisting of an action function sym- formula G(do([α1, ··· ,αn],S0)) is a particularly simple
bol and its arguments. Actions change the world. Situa- example of a regressable formula because it is uniform in
tions are FO terms which denote world histories. A distin- do([α1, ··· ,αn],S0)), but generally, regressable formulas
guished constant S0 is used to denote the initial situation, can mention several different ground situation terms. The re-
and function do(a, s) denotes the situation that results from gression theorem shows that one can reduce the evaluation of
performing action a in situation s. Every situation corre- a regressable formula φ to a FOL theorem proving task in the
sponds uniquely to a sequence of actions. Objects are initial theory together with unique names axioms for actions:
                                                                  D|=  φ   D   ∪D     |= R[φ].
FO terms other than actions and situations that depend on               iff S0    una
the domain of application. Fluents are relations or func- This fact is the key result for our paper: it demonstrates
tions whose values may vary from one situation to the next. that an executability or a projection task can be reduced to

Normally, a ﬂuent is denoted by a predicate or function sym- a FOL theorem proving task. However, because DS0 is an
bol whose last argument has the sort situation. For example, arbitrary FO theory, this type of reasoning is undecidable.
F (x, do([α1, ··· ,αn],S0)) represents a relational ﬂuent in Two of the most common ways to overcome this difﬁculty
the situation do(αn,do(··· ,do(α1,S0) ···) resulting from is to introduce the closed world assumption or introduce
execution of ground action terms α1, ··· ,αn in S0.Wedo the domain closure assumption (i.e., assume the domain
not consider functional ﬂuents in this paper.         is ﬁnite). In many application domains these assumptions
  The SC includes the distinguished predicate Poss(a, s) to are unrealistic. Therefore, we consider a version of the SC
                                                                     2
characterize actions a that are possible to execute in s.For formulated in FO ,orinC2.
                                                                                2
any SC formula φ and a term s of sort situation, we say φ is Two-variable FO logic FO is the fragment of ordinary
a formula uniform in s iff it does not mention the predicates FO logic (with equality), whose formulas only use no more
Poss, it does not quantify over variables of sort situation, it than two variable symbols x and y (free or bound). Two-
                                                                                              2
does not mention equality on situations, and whenever it men- variable FO logic with counting C2 extends FO by allowing
tions a term of sort situation in the situation argument position FO counting quantiﬁers ∃≥m and ∃≤m for all m ≥ 1. [Pa-
of a ﬂuent, then that term is s (see [Reiter, 2001]). If φ(s) is a cholski et al., 1997] show that satisﬁability problem for C2
uniform formula and the situation argument is clear from the is decidable and recently [Pratt-Hartmann, 2005] proves that
context, sometimes we suppress the situation argument and this problem is in NEXPTIME even when counting quantiﬁers
write this formula simply as φ, and also introduce a notation are coded succinctly. See additional background on DLs and
φ[s] to represent the SC formula obtained by restoring situa- discussion of connections between DLs with C2 in [Baader
tion s back to all the ﬂuents and/or Poss predicates (if any) et al., 2003; Borgida, 1996; Gu and Soutchanski, 2006].
in φ. It is obvious that φ[s] is uniform in s.
                          D
  A basic action theory (BAT) in the SC is a set of axioms 3 Modeling Dynamic Systems in a Modiﬁed
written in Lsc with the following ﬁve classes of axioms to
model actions and their effects [Reiter, 2001]: action precon- Situation Calculus
           D                             D
dition axioms ap, successor state axioms (SSAs) ss, initial In this section, we consider dynamic systems formulated in a
      D                     D
theory S0 , unique name axioms una, domain independent modiﬁcation of the language of the SC so that it can be con-
                             Σ                                               2
foundational axioms for situations .                  sidered as an extension to C (with an additional situation ar-
             D = D    ∪D    ∪D    ∪D   ∪ Σ                    1
  Suppose that     una    S0   ap    ss    is a BAT,  gument). The key idea is to consider a syntactic modiﬁcation
α1, ··· ,αn is a sequence of ground action terms, and G(s) is of the SC such that the executability and projection problems
a uniform formula with one free variable s. One of the most are guaranteed to be decidable as a consequence of the de-
important reasoning tasks in the SC is the projection problem, cidability of the satisﬁability problem in C2. Moreover, since
that is, to determine whether D|= G(do([α1, ··· ,αn],S0)). the modiﬁed SC has strong connections with description log-
Another  basic  reasoning task  is  the  executabil-  ics, which will be explained in detail below, we will denote
                      executable(do([α , ··· ,α ],S ))               DL
ity problem.     Let                 1      n   0     this language as Lsc .
be an abbreviation of the  formula Poss(α1,S0)  ∧      First of all, the three sorts in LDL (i.e., actions, situations
 n   Poss(α ,do([α , ··· ,α ],S )).                                               sc
 i=2       i      1      i−1   0      Then,     the   and objects) are the same as those in Lsc, except that they
executability problem  is   to  determine   whether
D|=    executable(do([α1, ··· ,αn],S0)). Planning and    1The reason that we call it a ”modiﬁed” SC rather than a ”re-
high-level program execution are two important settings stricted” SC is that we extend the SC with other features, such as
where the executability and projection problems arise natu- adding acyclic TBox axioms to basic action theories.

                                                 IJCAI07
                                                  1892  obey the following restrictions: (1) all terms of sort object where each variable vector x(i,n,b) (or x(j,n,b) respectively)
  are variables (x and y) or constants, i.e., object functional (i =1..m0,j=1..m1,n ∈{0, 1},b ∈{+, −}) represents a
  symbols are not allowed; (2) all action functions include no vector of object variables, which can be empty, x, y, x, y  or
  more than two arguments. Each argument of any term of sort y, x . Moreover, [∃x] or [∃y] represents that the quantiﬁer
                                           x   y                                        +
  action is either a constant or an object variable ( or ); (3) included in []is optional; and each φi (x(i,1,+)),i=1..m0
  variable s of sort situation and/or variable a of sort action are φ−(x ),j =1..m              C2
                                        D−Σ   −D        ( i  (j,1,−)         1, respectively), is a formula
  the only additional variables being allowed in una    with variables (both free and quantiﬁed) among x and y.
  in addition to variables x, y.
                                                        Note that when m0 (or m1 respectively) is equal to 0, the
                       LDL
    Second, any ﬂuent in sc is a predicate either with two corresponding disjunctive subformula is equivalent to false.
  or with three arguments (including the one of sort situation). Acyclic TBox axioms DT : Similar to the TBox axioms in
  We call ﬂuents with two arguments (dynamic) concepts, and DL, we may deﬁne new concepts using TBox axioms. Any
                                                LDL
  call ﬂuents with three arguments (dynamic) roles.Insc , group of TBox axioms DT may include two sub-classes:
  (static) concepts (i.e., unary predicates with no situation ar- static TBox DT,st and dynamic TBox DT,dyn. Every formula
  gument) and (static) roles (i.e., binary predicates with no sit- in static TBox is a concept deﬁnition formula of the form
  uation argument), if any, are considered as unchangeable tax-            G(x) ≡ φ  (x),
  onomic properties and unchangeable classes of an application                     G
                                                                                                      2
  domain. Moreover, each concept (static or dynamic) can be where G is a unary predicate symbol and φG(x) is a C for-
  either primitive or deﬁned.                           mula in the domain with free variable x, and there is no ﬂuent
    Third, apart from the standard FO logical symbols ∧, ∨ in it. Every formula in dynamic TBox is a concept deﬁnition
  and ∃, with the usual deﬁnition of a full set of connectives formula of the form G(x, s) ≡ φG(x)[s],
                 DL                               ≥m          φ (x)    C2                        x
  and quantiﬁers, Lsc also includes counting quantiﬁers ∃ where G   is a  formula with free variable , and there
      ≤m                                    DL
  and ∃   for all m ≥ 1. Equality = is allowed in Lsc . is at least one ﬂuent in it. All the concepts appeared in the
    The dynamic systems we are dealing with here sat-   left-hand side of TBox axioms are called deﬁned concepts.
  isfy the open world assumption (OWA): what is not     We also require that the set of TBox axioms must be acyclic
                                                                   D
  stated explicitly is currently unknown rather than false. (acyclicity in T is deﬁned exactly as it is deﬁned for TBox ).
  In this paper, the dynamic systems we are interested  RBox axioms  DR: Similar to the idea of RBox in DL, we
  in can be formalized as a basic action theory (BAT) D may also specify a group of axioms, called RBox axioms be-
  using the following seven groups of axioms in LDL:    low, to support a role taxonomy. Each role inclusion axiom is
                                                 sc                       R (x, y)[s] ⊃ R (x, y)[s]
  D =Σ∪Dap     ∪Dss  ∪DT  ∪DR   ∪Duna  ∪DS   .Fiveof    represented as     1           2       ,
                                            0                 R      R
  them (Σ, Dap, Dss, Duna, DS ) are similar to those groups where 1 and 2 are primitive roles (either static or dy-
                           0                                                                      D
  inaBATinLsc, and the other two (DT , DR) are introduced namic). If these axioms are included in the BAT , then it
  to axiomatize description logic related facts and properties is assumed that D is speciﬁed correctly in the sense that the
                                  DL
  (see below). However, because Lsc   allows only two   meaning of any RBox axiom included in the theory is cor-
  object variables, all axioms must conform to the following rectly compiled into SSAs. That is, one can prove by induc-
  additional requirements.                              tion that (D−DR)  |= ∀s.R1(x, y)[s] ⊃ R2(x, y)[s]. Al-
                                                        though RBox axioms are not used by the regression operator,
  Action  precondition axioms  Dap:    For  each  ac-
               DL                                       they are used for taxonomic reasoning in the initial theory.
  tion A  in Lsc ,  there is one  axiom  of the form                                      2
                                                        Initial theory DS : It is a ﬁnite set of C sentences (assum-
  Poss(A, s) ≡   ΠA[s] (or Poss(A(x),s)  ≡  ΠA(x)[s],                  0
                                                        ing that we suppress the only situation term S0 in all ﬂuents).
  or Poss(A(x, y),s) ≡ ΠA(x, y)[s], respectively), if A is an
                                                        It speciﬁes the incomplete information about the initial prob-
  action constant (or unary, or binary action term, respectively),
                                                   2    lem state and also describes all the facts that are not change-
  where ΠA  (or ΠA(x),orΠA(x, y), respectively) is a C
                                                        able over time in the domain of an application. In particular,
  formula with no free variables ( or with at most x, or with at
                                                        it includes static TBox axioms DT,st as well as RBox axioms
  most x, y as the only free variables, respectively). This set of
                                                        in the initial situation S0 (if any). In addition, DS also in-
  axioms characterize the preconditions of all actions.                                            0
                                                        cludes all unique name axioms for object constants.
  Successor state axioms Dss:  There are two types of
            DL                                            The remaining two classes (foundational axioms for situ-
  ﬂuents in Lsc : primitive dynamic concepts of the form      Σ                                D
  F (x, s)                                              ations  and unique name axioms for actions una) are the
         (ﬂuents with exactly one non-situation argument) same as those in the BATs of the usual SC. Note that these
  and primitive dynamic roles of the form F (x, y, s) (ﬂuents
                                                        axioms (as well as Dap and Dss) use more than two variables
  with exactly two non-situation arguments). Let variable
                                                        (e.g., Dss use action and situation variables in addition to ob-
  vector x to be x,ory,orx, y ; a SSA is speciﬁed for each
       F (x, do(a, s))                                 ject variables), but we will see in the next section, that these
  ﬂuent            .  According to the general syntactic axioms will be eliminated in the process of regressing a re-
  form of the SSAs provided in [Reiter, 2001], without loss of gressable formula to a sentence that will use no more than
  generality, we can assume that the axiom has the form two object variables and no other variables.
              F (x, do(a, s)) ≡ ψF (x, a, s),   (1)
  where the general structure of ψF (x, a, s) is as follows: 4 Modiﬁed Regression with Lazy Unfolding
     m
        0 [∃x][∃y](a=A+(x     ) ∧ φ+(x   )[s]) ∨                                                DL
       i=1           i   (i,0,+)  i  (i,1,+)           After giving the deﬁnition of what the BAT in Lsc is, we
            m1              −            −
F (x, s) ∧¬( j=1[∃x][∃y](a=Aj (x(j,0,−)) ∧ φj (x(j,1,−))[s])), turn our attention to the reasoning tasks.

                                                   IJCAI07
                                                    1893                       DL                                     
  Given a formula W of Lsc in the domain D, the deﬁni- Poss(A(t),σ), for terms of sort action and situation respec-
                               DL                              DL
tion of W being regressable (called Lsc regressable below) tively in Lsc . Then there must be an action precondition
is slightly different from the deﬁnition of W being regress- axiom for A of the form Poss(A(x),s) ≡ ΠA(x, s), where
able in Lsc (see [Reiter, 2001]) by adding the following two the argument x of sort object can either be empty (i.e., A is
conditions: (i) any variable (free or bounded) in W is either an action constant), a single variable x or two-variable vector
                                                                                                 DL
x or y; (ii) every term of sort situation in W is ground. More- x, y . Because of the syntactic restrictions of Lsc , each
        DL
over, in Lsc we have to be more careful with the deﬁnition of term in t can only be a variable x, y or a constant C. Then,
                   R                                           8
the regression operator for two main reasons. First, to deal     R[(∃y)(x = y ∧ Π (x, y, σ))] t = x, x,
                                       LDL                     >                A          if
with TBox we have to extend regression. For a sc regress-      > R[(∃x)(y = x ∧ Π (x, y, σ))]   t = y, y,
           W                                                   <                A          else if
able formula ,weextend below the regression operator de- R[W ]=  R[Π  (t, σ)]                  t = x, C
       [          ]                                            >     A                     else if       or
ﬁned in Reiter, 2001 with the lazy unfolding technique (see    >                           t = x, y t = x,
                                                               :>                                  or
[Baader et al., 2003]) to expand deﬁned dynamic concepts.           f  
                                       DL                        R[ΠA(t, σ)]               otherwise,
We still denote such operator as R. Second, Lsc uses only
two object variables and we have to make sure that after re- C                 φ
                                DL                    where    is a constant and denotes a dual formula for
gressing a ﬂuent atom we still get a Lsc formula, i.e., that formula φ obtained by replacing every variable symbol x
we never need to introduce new (free or bound) object vari- (free or quantiﬁed) with variable symbol y and replacing
ables. To deal with the two-variable restriction, we modify every variable symbol y (free or quantiﬁed) with variable
                    R
our regression operator in comparison to the conventional symbol x in φ, i.e., φ = φ[x/y, y/x].
operator deﬁned in [Reiter, 2001]. For example, when replac-
ing Possatom or ﬂuent atoms about do(α, σ), the deﬁnition c. If W is a deﬁned dynamic concept, so it has the form
of the conventional regression operator in [Reiter, 2001] has G(t, σ) for some object term t and situation term σ, and there
the assumption that the quantiﬁed variables in the right-hand must be a TBox axiom for G of the form G(x, s) ≡ φG(x, s).
                                                                                           LDL      t
side of the corresponding axioms should be renamed to new Because of the restrictions of the language sc , term can
variables different from the free variables in the atoms that to only be a variable x, y or a constant. Then, we use lazy
                                                      unfolding technique as follows:
be replaced. This assumption of using new variables for re-    j
naming assures equivalence of original formula and the for-      R[φG(t, σ)] if t is not variable y,
                                                       R[W ]=      f
mula after regression. To avoid introducing new variables (as    R[φG(y, σ)] otherwise.
required by the Reiter’s regression operator) and to assure de-
                                                      d.     If W  is a primitive concept (a primitive role,
ﬁned dynamic concepts being handled, we modify the regres-
                    DL                                respectively), so it has the form F (t1,do(α, σ)) or
sion operator for each Lsc regressable formula. Possibility
                                                      F (t1,t2,do(α, σ)) for some terms t1 (and t2) of sort
of reusing variables is guaranteed by the general format of the
                                                      object, term α of sort action and term σ of sort situation.
SSAs given in the previous section and the additional condi-
                           DL                         There must be a SSA for ﬂuent F such as Eq. (1). Because
tion (ii) in the deﬁnition of the Lsc regressable formula.                         DL
                                                      of the restriction of the language L , the term t1 and t2 can
  The complete formal deﬁnition of our R is as follows,                            sc
                                                      only be a variable x, y or a constant C and α can only be
where σ denotes the term of sort situation, and α denotes the
                                                      an action function with no more than two arguments of sort
term of sort action.
                                                      object. Then, when W is a concept,
                                                               j
•   If W is not atomic, i.e. W is of the form W1 ∨ W2,
                                                               R[ψF (t1,α,σ)] if t1 is not variable y,
W1 ∧ W2, ¬W  , Qv.W  where Q represents a quantiﬁer (in- R[W ]=    f
                                                                 R[ψF (y, α, σ)] otherwise, i.e., if t1 = y;
cluding counting quantiﬁers) and v represents a variable sym-
                                                      and, when W is a role,
bol, then                                                      8
 R[W  ∨ W ]=R[W   ] ∨R[W  ],   R[¬W ]=¬R[W   ],              > R[(∃y)(x = y ∧ ψF (x, y, α, σ))] if t1 = x, t2 = x;
     1    2       1      2                                     >
 R[W  ∧ W ]=R[W   ] ∧R[W  ], R[Qv.W ]=Qv.R[W ].              < R[(∃x)(y = x ∧ ψF (x, y, α, σ))] if t1 = y, t2 = y;
     1    2       1      2                                          f
                                                       R[W ]=    R[ψF (y, x, α, σ)]          if t1 = y, t2 = x;
•  Otherwise, W is atom. There are several cases.              >
                                                               :>                            or t1 = y, t2 = C;
                                 
a.   If W is of the form A1(t)=A2(t ) for some action            R[ψF (t1,t2,α,σ)]           otherwise.
                                                  2
function symbols A1 and A2, then by using axioms in Duna, Based on the above deﬁnition, we are able to prove the
we deﬁne the regression of W as                       following theorems.
                                                                       W      LDL
                  ⊥            if A1 = A2,           Theorem 1  Suppose   is a sc regressable formula, then
        R[W ]=                                                  R[W  ]
                    |t| t = t         .              the regression    deﬁned above terminates in a ﬁnite num-
                    i=1 i   i  otherwise              ber of steps.
  Otherwise, if W is situation independent atom (including Proof: Immediately follows from conditions (i) and (ii)of
                                                                      DL
equality between object constants or variables), or W is a the deﬁnition of Lsc regressable formula, acyclicity of the
concept or role uniform in S0, then                   TBox axioms, and from the assumption that RBox axioms
                    R[W ]=W.                          are compiled into the SSAs and consequently do not partici-
                                                                                                       
       W                Poss                          pate in regression.
b.   If   is a regressable   atom, so it has the form                           DL
                                                      Theorem 2  Suppose W is a Lsc regressable formula with
                                                                                                      DL
  2Notice that the action functions with different number of argu- the background basic action theory D. Then, R[W ] is a Lsc
ments always use different function symbols (i.e., different names). formula uniform in S0 with no more than two variables (x

                                                 IJCAI07
                                                  1894and y). Moreover,    D|=  W  ≡R[W   ],         and    have a progression relationship). The progression can be iter-
      D|=  W      D   |= R[W ].
               iff  S0                                atively repeated if the progressed KB has the same format as
                                                      the initial KB and we can consider the computed progression
Proof:  According to the deﬁnition of the modiﬁed regres-
                                                      as the new initial KB at the next iteration. [Lin and Reiter,
sion operator, prove by induction over the structure of W .
                                                      1997] shows that the (classical) progression of a ﬁnite FO
The ﬁrst statement holds because all replacements done by
                                                      KB is not always FOL deﬁnable (but it is always deﬁnable in
R transform W to logically equivalent formula. The sec-
                                                      the second-order logic). By using an example similar to [Lin
ond statement follows from the regression theorem in [Reiter,
                                                     and Reiter, 1997], one can prove
2001].                                                                                  DL
                                                      Theorem 5  Progression of a theory in Lsc is not always FO
                  W      LDL                                                                     DL
Theorem 3 Suppose    is a sc regressable formula with deﬁnable, therefore it is deﬁnitely not deﬁnable in Lsc .
the background basic action theory D. Then, the problem                             D
       D|=  W                                         Proof:    We consider the theory 1 obtained by modify-
whether       is decidable.                           ing the theory D given in [Lin and Reiter, 1997] as follows:

Proof:   According to Theorem 2, D|=  W  iff DS0 |=   (1) replace one constant symbol 0 in D by an inﬁnite set of
R[W ]       R[W  ]                D      C2
     , where      and the axioms in S0 are   formu-   constant symbols {0, 1, 2, ···}; (2) replace function symbol
las. Therefore, the problem whether D|= W is equivalent succ(x)=y in D by predicate succ(x, y) which will be true
             ∧¬R[W   ]
to whether DS0         is unsatisﬁable or not, which is a iff y is the successor of x; (3) replace the empty initial KB

decidable problem, according to the fact that the satisﬁability by the new DS0 which includes inﬁnitely many axioms of the
           2
problem in C is decidable.                           form c1 = c2 for any non-identical constant symbols c1 and
                                                                                                       
  This theorem is important because it guarantees that the c2 given above and of the form succ(c, c ) where constant c
                                    DL
projection and executability problems in Lsc are decidable is the successor of constant c in the sense of natural numbers.

even if the initial KB DS0 is incomplete. [Gu and Soutchan- The rest of the proof is exactly the same as the proof given in
ski, 2006] give some detailed examples that illustrate the ba- [Lin and Reiter, 1997].                 
sic reasoning tasks described above and reduction techniques                               DL
                                                        Notice that the proof assumes that an Lsc theory D1 is
for dealing with properties that need more than two variables,
                   DL                                 inﬁnite. The problem whether progression of a ﬁnite theory
and show that using Lsc , one can model realistic dynamic DL
                                                      in Lsc is always FO deﬁnable remains open.
domains such as school enrollment services and on-line shop- Now, we consider a (weaker than classical) modiﬁed pro-
ping services.                                        gression for certain type of incomplete KBs only. For this
  We say that the SSA for a ﬂuent F is context-free if the
       F                                              special case of incomplete KBs, we show below that a mod-
SSA for  has the form                                 iﬁed progression of a KB is in LDL and it is sound wrt a
  F (x, do(a, s)) ≡ γ+(x, a) ∨ F (x, s) ∧¬γ−(x, a).                            sc
                  F                   F               classical progression of this KB.
Then, we have the following theorem about the complexity First, we restrict the syntactic form of the KBs that are al-
analysis for reasoning about projection problem.      lowed. We use e to range over ewffs, that is, quantiﬁer-free
                                        DL
Theorem 4 Given a basic action theory D in Lsc , suppose boolean formulas with equalities and inequalities only. For
that the SSA for a ﬂuent F is context-free, then the com- any vector x that is x, y  (or a variable x,ory) and any vec-
                                                                         
putational complexity of answering the queries of the form tor of object constants B that is B1,B2  (or a single constant
                                                                   
F (X,σ) is co-NEXPTIME, where X  is a vector of object B), we write x = B as an abbreviation for x = B1 ∧ y = B2
constants and σ is a ground situation term.           (or x = B, respectively). We use l(x, S) to range over ﬂuent
Proof:  The result follows from the complexity analysis of literals, where S is a ground situation term. We call formu-
projection problem in [Reiter, 2001] (Chapter 4), Theorem 3, las of the form ∀x.e(x) ⊃ l(x, S) equality-based formulas.
and the theorem in [Pratt-Hartmann, 2005] that the satisﬁa- We deﬁne a CNF-based KB DS = KBI ∪KBS, where KBI
                2
bility problem in C is decidable in NEXPTIME.        is a set of situation-independent formulas (including unique
                                                      name axioms for object constants, i.e., KBI is a subset of
                                                      DS  ), and KBS is a ﬁnite set of sentences uniform in S,
5  Progression of   CNF-based KBs                        0
                                                      where each sentence (also called clause below) is a disjunc-
The progression problem (also known as ﬁltering and update) tion of ﬁnitely many equality-based formulas. In particular,

is how to compute the new theory in response to a given se- DS0 =KBI ∪KBS0 . A CNF formula composed from ground
quence of actions. In this section, we consider the progres- ﬂuent literals uniform in S is a simple example of KBS.
                               DL
sion problem for KBs in language Lsc . In this section, let Secondly, we consider an action theory D that is local-
D = Dss ∪Dap  ∪ Σ ∪Duna.                              effect. Let a SSA of a ﬂuent F have the syntactic form
                                                                      +                     −
  A formal deﬁnition of (classical) progression is given in F (x, do(a, s)) ≡ γF (x, a, s) ∨ F (x, s) ∧¬γF (x, a, s). This
                             D                                           +            −
[Reiter, 2001]. A set of sentences Sα is the (classical) pro- SSA is local-effect if γF (x, a, s) and γF (x, a, s) are disjunc-
                     D                       D
gression of the initial KB S0 (wrt basic action theory ) af- tions of formulas of the form ∃z[a = A(y) ∧ φ(y, s)], where
                         α              S    D
ter performing a ground action in the situation 0 iff Sα is A is a action function, y contains x, z = y − x, and φ is
         do(α, S ) D|= D                     M
uniform in      0 ,      Sα , and for every model α of quantiﬁer-free. An action theory D is local-effect if each SSA
D∪D                   M    D         M     M
     Sα , there is a model of such that and  α have   in D is local-effect. Let ∗ be + or −. Consider a ground ac-
the same domain and interpret situation independent predi- tion α and a ﬂuent Fi in a local-effect action theory D of
                                                                DL
cates, function symbols, Possand all ﬂuents about the future language Lsc , then it is easy to see that the right-hand side
of do(α, S0) identically (in the sequel, we say that M and Mα (RHS) of SSA for Fi(x, do(α, s)) has the following syntactic

                                                 IJCAI07
                                                  1895