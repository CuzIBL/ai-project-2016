                An Improved Algorithm for Optimal Bin Packing 

                                           Richard E. Korf 
                                     Computer Science Department 
                                 University of California, Los Angeles 
                                         Los Angeles, CA 90095 
                                            korf@cs.ucla.edu 

                    Abstract                           turn to the fullest bin in which it fits. First-fit decreas•
                                                       ing requires three bins to pack the set of numbers above, 
    Given a set of numbers, and a set of bins of 
                                                       while best-fit decreasing packs them into two bins. Both 
    fixed capacity, the NP-complete problem of bin 
                                                       algorithms run in O(nlogn) time. 
    packing is to find the minimum number of bins 
                                                         In this paper we are concerned with finding optimal 
    needed to contain the numbers, such that the 
                                                       solutions, for several reasons. In applications with small 
    sum of the numbers assigned to each bin does 
                                                       numbers of bins, even one extra bin is relatively expen•
    not exceed the bin capacity. We present two 
                                                       sive. In addition, being able to find optimal solutions 
    improvements to our previous bin-completion 
                                                       to problem instances allows us to more accurately gauge 
    algorithm. The first speeds up the constant fac•
                                                       the quality of approximation algorithms. Furthermore, 
    tor per node generation, and the second prunes 
                                                       an anytime algorithm for finding optimal solutions, such 
    redundant parts of the search tree. The re•
                                                       as that presented in this paper, can make use of any ad•
    sulting algorithm appears to be asymptotically 
                                                       ditional time available to find better solutions than those 
    faster than our original algorithm. On prob•
                                                       returned by polynomial algorithms. Finally, optimal bin 
    lems with 90 elements, it runs over 14 times 
                                                       packing is computationally challenging, and may lead to 
    faster. Furthermore, the ratios of node gen•
                                                       insights applicable to other problems. 
    erations and running times both increase with 
                                                         First we review previous algorithms for optimal bin 
    increasing problem size. 
                                                       packing, including our bin-completion algorithm [Korf, 
                                                       2002]. We then describe two improvements to bin com•
1 Introduction and Overview                            pletion. The first is an algorithm for generating un-
Given a set of numbers, and a fixed bin capacity, the  dominated bin completions more efficiently, reducing the 
bin-packing problem is to assign each number to a bin  constant time per node generation. Next we describe a 
so that the sum of the numbers assigned to each bin    method to reduce the branching factor of the search, by 
does not exceed the bin capacity. An optimal solution  eliminating branch points that are dominated by previ•
uses the fewest number of bins. For example, given the ous branches. In experiments on millions of problem in•
set of numbers 6, 12, 15, 40, 43, 82, and a bin capacity stances with uniformly distributed random numbers, our 
of 100, we can assign 6, 12, and 82 to one bin, and 15, new algorithm appears to be asymptotically faster than 
40, and 43 to another, for a total of two bins. This is our original bin-completion algorithm. This is based on 
an optimal solution to this instance, since the sum of all the observation that both the ratio of nodes generated by 
the numbers, 198, is greater than 100, and hence at least the two algorithms, and also their running times, grow 
two bins are required. An example application is given a with increasing problem size. On problems of size 90, our 
set of orders for wire of varying lengths, and a standard new algorithm runs over 14 times faster than our original 
length in which it is manufactured, how to cut up the  bin-completion algorithm. We also report mixed results 
minimum number of standard lengths to fill the orders. on a common set of benchmark problems. 
  Bin packing was one of the earliest problems shown 
to be NP-complete[Garey & Johnson, 1979]. The vast     2 Previous Work 
majority of the literature on this problem concerns 
polynomial-time approximation algorithms, such as first- 2.1 Martello and Toth 
fit decreasing (FFD) and best-fit decreasing (BFD), and A well-known algorithm for optimal bin packing 
the quality of the solutions they compute. First-fit de• [Martello & Toth, 1990a; 1990b] is based on depth-first 
creasing sorts the numbers in decreasing order, orders branch-and-bound. The numbers are first sorted, and 
the bins, and assigns each number in turn to the first are considered from largest to smallest. It first computes 
bin in which it fits. Best-fit decreasing sorts the num• an approximate solution as an initial upper bound, using 
bers in decreasing order and then assigns each number in the best solution among first-fit, best-fit, and worst-fit 


1252                                                                                              SEARCH decreasing. Then, for each number, the algorithm places        we can always put x and y in the same bin, resulting 
it in each partially-filled bin that it fits into, or in an    in a smaller problem [Gent, 1998]. Unfortunately, this 
empty bin. Thus, the algorithm branches on the differ•         does not extend to three or more elements that sum to 
ent bins that a number can be placed in. It also uses a        exactly the bin capacity. 
lower-bound function to prune the search.                        As another example, consider an element x such that 
                                                               any two remaining elements added to x will exceed c. 
2.2 More Recent OR Approaches                                  In other words, at most one additional element can be 
An anonymous reviewer pointed out some more recent             added to the bin containing x. Let y be the largest 
references on optimal bin packing from the operations          remaining element such that Then, we can 
research literature, based on integer programming for•         place y in the same bin as x without sacrificing solution 
mulations, with linear-programming relaxations. [Vale-         quality. The reason is that if we placed any other single 
rio de CarvaJho, 1999; Scholl, Klein, & Jurgens, 1997;         element z with x, then we could swap y with z, since 
Vanderbeck, 1999; DeGraeve & Schrage, 1999; Vance et 
a/., 1994; Vance, 1998] While we have not yet fully di•          As a final example, again assume that y is the largest 
gested this work, we report below some comparison re•          remaining element that can be added to x such that x + 
sults on a standard set of benchmarks.                         y c, and that y equals or exceeds the sum of any set 
                                                               of remaining elements that can be added to x without 
2.3 Bin Completion 
                                                               exceeding c. In that case, we can again put x and y in 
In [Korf, 2002], we described our bin completion algo•         the same bin, without sacrificing solution quality. The 
rithm, which uses a branching structure different from         reason is that any other set of elements that were placed 
that of Martello and Toth. A feasible set is a set of          in the same bin as x could be swapped with y without 
numbers whose sum does not exceed the bin capacity.            increasing the number of bins. 
Initially, we sort the numbers in decreasing order of size.      To illustrate the general form of this dominance rela•
We then generate feasible sets that include the largest        tion, let A and B be two feasible sets. If the elements 
number. If there is more than one such set, the search         in B can be partitioned into subsets, and the subsets 
may branch at that point. Each node of the search tree,        can be matched to the elements of A such that the sum 
except the root node, represents a complete assignment         of the elements in each subset doesn't exceed the cor•
of numbers to a particular bin. The children of the root       responding element of A, then set A dominates set B. 
represent different ways of completing the bin contain•        In other words, if the elements of B can be packed into 
ing the largest number. The nodes at the next level            bins whose capacities are the elements of A, then set A 
represent different feasible sets that include the largest 
remaining number, etc. The depth of any branch of the 
tree is the number of bins in the corresponding solution. 
   Bin completion is also a branch-and-bound algorithm. 
It starts with the best-fit decreasing solution as an upper      Given all the feasible sets that contain a common el•
bound, and applies a lower-bound heuristic function to         ement x, only the undominated sets need be considered 
prune the search. Rather than assigning numbers one            for assignment to the bin containing x. The reason is 
at a time to bins, it branches on the different feasible       that if we complete the bin containing x with a domi•
sets that can be used to complete each bin. Bin com•           nated set, then we could swap each subset of numbers 
pletion appears asymptotically faster than the Martello        in the dominated set with the corresponding element of 
and Toth algorithm, and outperforms it by a factor of          the dominating set, and get another solution without 
a thousand on problems of size 60. The key property            increasing the total number of bins. 
that makes it more efficient is a dominance condition on         Martello and Toth use this dominance relation to some 
the feasible completions of a bin that allows us to only       extent. In particular, they take each element x, starting 
consider a small subset of them.                               with the largest element, and check if there is a single 
                                                               completion of one or two more elements that dominates 
2.4 Set Dominance                                              all feasible sets containing x. If so, they place x with 
Some sets of elements assigned to a bin cannot lead to         those elements in the same bin, and apply the reduction 
solutions that are any better than those achievable by         to the remaining subproblem. They also use dominance 
assigning other sets of elements to the same bin. We           relations to prune some element placements as well. 
begin with some simple examples of these dominance               Our bin-completion algorithm, however, makes much 
relations, and then consider the general formulation.          greater use of this dominance condition. In particular, 
   First, consider two elements x and y whose sum is           when branching on the completion of any bin, it only 
exactly the bin capacity c. Assume that in one solution,       considers undominated completions. 
x and y are in different bins. In that case, we can swap y 
with all other elements in the bin containing x, without       3 Finding Undominated Completions 
increasing the number of bins. This gives us an equally 
good solution with x and y in the same bin. Thus, given        The first contribution of this paper is a faster algorithm 
a problem with two values x and y such that = c,               to generate all the undominated completions of a bin. 


SEARCH                                                                                                              1253  3.1 Previous Algorithm                                        subsets below it, and the right branch excludes the same 
 The simplest algorithm is to generate all feasible sets       element from all subsets below it. The tree is traversed 
 that include a particular element, and then test each         depth-first using only linear memory. 
 pair of sets for dominance. Our original implementation         To generate feasible completions of a bin containing a 
 improved on this by only generating a subset of all feasi•    number x, we add an upper bound on the sum to each 
 ble completions, and testing for pairwise dominance only      recursive call, which is initially the residual capacity, or 
 among those. In particular, if only one additional num•       the bin capacity minus x. We sort the remaining unas-
 ber can be added to a bin, only the largest such number       signed numbers in decreasing order of size. We only 
 is added. If only two additional numbers can be added to      include numbers that are less than or equal to the up•
 a bin, the set of two-element undominated completions         per bound. When we include a number by taking the 
 can be found in linear time, as follows.                      left branch from a node, we subtract it from the upper 
   Each undominated two-element completion must have           bound of all recursive calls below that branch. When 
 a sum greater than the largest feasible single number,        the upper bound drops to zero, we prune the tree below 
 and less than or equal to the remaining capacity of the       that node, since no further numbers can be added. This 
 bin. The remaining values are kept in sorted order, with      generates all feasible completions of a bin containing x. 
two pointers, one initially assigned to the largest value        Generating undominated feasible completions requires 
and the other to the smallest value. If the sum of these       a little more work. When we exclude a number that ex•
 two numbers exceeds the remaining capacity, the pointer       ceeds the upper bound, by taking the right branch from 
to the larger number is moved to the next smaller num•         the corresponding node, nothing additional is required, 
ber. If the sum of the two numbers is less than or equal       since it can't be a member of any feasible set below that 
to the largest single feasible number, the pointer to the      node. If we exclude a number that equals the upper 
smaller number is moved to the next larger number. If          bound, we can terminate that branch of the binary tree 
the sum of the two numbers is within this range, the           immediately, because any feasible subset of included el•
pointer to the smaller number is increased to the largest      ements below that node cannot sum to more than the 
number for which the sum of the two is still in range,         excluded element, and any subset with a smaller sum 
and these two values form an undominated two-element           would be dominated by the excluded element. 
completion. Then the pointer to the larger number is             What happens when we exclude a number that is less 
moved to the next smaller number, and the pointer to           than the upper bound? To prevent the excluded clement 
the smaller number is moved to the next larger number.         from dominating any included subset below it, the sum 
This process continues until the two pointers meet.            of the numbers in any such subset must exceed the ex•
   If the sum of the numbers in two feasible sets are un•      cluded element. This generates a lower bound on the 
equal, only the one with the larger sum can dominate the       sum of the elements in any included subset below this 
other. If two sets have the same sum, only the one with        node, which is equal to the excluded element plus one, 
the smaller cardinality can dominate the other. Once           assuming that the numbers are integers. As with the 
a subset of the feasible completions is found, each pair       upper bound, the lower bound is reduced by any sub•
was tested to see if either dominates the other. This          sequently included elements in the recursive calls below 
was done by trying to pack the numbers of the poten•           the corresponding nodes. The lower bound generated by 
tial dominated set into bins whose capacities were the         an excluded element is only used if it exceeds the current 
numbers of the potential dominating set. These small           lower bound on that node. 
bin-packing problems were solved by brute-force search.          Thus, we perform a depth-first traversal of the binary 
   There are two drawbacks to this approach. The first is      tree representing all possible subsets of numbers remain•
the time to generate and then test the dominated feasible      ing to be assigned. This traversal is pruned by the upper 
sets. The second is the memory needed to store the             and lower bounds propagated down the tree as described 
dominated feasible sets before they are pruned.                above, and generates complete subsets at the leaf nodes. 
                                                               These will include all undominated feasible sets, but may 
3.2 Generating Undominated Sets Faster                         include some dominated feasible sets as well. 
Ideally, we would like to generate all and only undomi•          To eliminate these, we perform an additional test on 
nated bin completions, without pairwise testing of feasi•      the feasible bin completions generated. The residual ca•
ble sets for dominance. We describe such an algorithm          pacity r of a bin is the bin capacity c minus the largest 
in three stages: 1) how to generate all subsets of a uni•      number in the bin, which is common to all feasible com•
verse, 2) how to generate only feasible subsets, and 3)        pletions of a given bin. Let t be the sum of all the num•
how to generate only undominated feasible subsets.             bers in a feasible set A, excluding the common largest 

   The easiest way to generate all 2n subsets of n el•         number. The excluded numbers are all remaining num•
ements is to recursively traverse a binary tree, where         bers less than or equal to r that are not included in A. 
each node represents a collection of subsets. The root         Set A will be dominated if and only if it contains any 
node represents the entire power set, and the leaf nodes       subset whose sum s is less than or equal to an excluded 
represent individual subsets. Each interior level of the       number x, such that replacing the subset with x will not 
tree corresponds to a different element. At each node,         exceed the bin capacity. This will be the case if and only 
the left branch includes the corresponding element in all      if Thus, to guarantee that a feasible set 


1254                                                                                                            SEARCH A is undominated, we check each possible subset sum s,         this solution is redundant, and doesn't need to be con•
and each excluded number x, to verify that                     sidered again. In particular, below the branch of 
   This algorithm generates feasible sets and immediately      the search tree, any solution that assigns x and y to the 
tests them for dominance, so it never stores multiple          same bin will be redundant and can be pruned. 
dominated sets. It tests for dominance by comparing              In general, given a node with more than one child, 
subset sums of included elements to excluded elements,         when searching the subtree of any child but the first, 
rather than comparing pairs of sets for dominance.             we don't need to consider bin assignments that assign 
   Pseudo-code for this algorithm is given below. The          to the same bin all the numbers used to complete the 
feasible function takes a set I of included elements, a set    current bin in a previously-explored child node. More 
E of excluded elements, a set R of remaining elements,         precisely, let be a set of brother nodes 
a lower bound / and an upper bound u. It generates all         in the search tree, and let be the sets 
feasible sets of remaining elements whose sum is within        of numbers used to complete the bin in each node, ex•
the two bounds, and calls the test function on each. In        cluding the first number assigned to the bin, which is 
the initial call, I and E are empty, R contains all remain•    common to all the brother nodes. When searching the 

ing elements less than or equal to the residual capacity r     subtree below node Nt for i 1, we exclude any bin 
of the bin, u is set to r, and I is set to the largest single  assignments that put all the numbers in Sj in the same 
element that can feasibly be added to the bin, plus one.       bin, for j < i. Thus, no bin completion below node Ni 
Test is the test described above, and is a function of the     can have as a subset the numbers in for By re•
included elements J, the excluded elements E, and the          jecting these bin assignments as redundant, the number 
residual capacity r.                                           of node generations is reduced. 
                                                               4.1 Current Implementation 
                                                               Our current implementation of this pruning rule propa•
                                                               gates a list of nogood sets along the tree. After generating 
                                                               the undominated completions for a given bin, we check 
                                                               each one to see if it contains any current nogood sets as 
                                                               a subset. If it does, we ignore that bin completion. 
                                                                 To keep the list of nogood sets from getting too long, 
                                                               occupying memory to store them and time to test them 
                                                               against bin completions, we prune the list as follows. 
                                                               Whenever there is a non-empty intersection between a 
   To improve this algorithm, we use the same optimiza•        bin completion and a nogood set, but the nogood set is 
tions used in our original algorithm to generate feasible      not a subset of the bin completion, we remove that no-
sets. Namely, if only one more number can be added to          good set from the list that is passed down to the children 
a bin, we only add the largest such number, and if only        of that bin completion. The reason is that by including 
two more numbers can be added, we generate all un•             at least one but not all the numbers in the nogood set 
dominated two-element completions in linear time. This         in a bin completion, we've split up the nogood set, guar•
algorithm speeds up the generation of all undominated          anteeing that it can't be a subset of any bin completion 
sets, without affecting the number of bin completions          below that node in the search tree. 
considered. For that, we turn to our next contribution.          This implementation could probably be improved with 
                                                               more sophisticated data structures for representing arid 
4 Pruning the Search Space                                     manipulating sets of elements. 
Consider a number w in a bin, with a capacity of c. As•
sume that two undominated feasible completions of the          5 Experimental Results 
                                                               We tested our algorithm on large sets of problems with 
                                                               uniformly-distributed high-precision numbers, and on a 
                                                               set of benchmark problems of relatively low precision. 
our search explores bin completions in decreasing order        5.1 Uniform High Precision Numbers 
of subset sum, so in this case we consider before 
         Furthermore, assume that after exhausting the         We compared our original algorithm to our new bin-
subproblem below the assignment and while                      completion algorithm on the same problem instances 
exploring the subproblem below the assignment                  and on the same machine. Since high-precision numbers 
we find a solution that assigns x and y to the same bin,       are often more difficult to pack than low-precision num•
say Since and bers, we used a bin capacity of one million, and random 
            we could swap z with x and y, resulting in         numbers uniformly distributed from one to one million. 
a solution with the same number of bins, but including         Given the enormous variation in the difficulty of indi•
the bin assignments and However, all                           vidual problem instances, we ran one million instances 
possible solutions below the node representing the bin         of each problem size, which ranged from 5 to 95 numbers, 
assignment have already been explored. Thus,                   in increments of 5. Table 1 shows the results. 


SEARCH                                                                                                              1255 [N     Optimal     Original       Without Pruning         With Nogood Pruning            Ratios 
         Bins        Time         Nodes        Time         Nodes         Time       Nodes     Time 
5         3.215            6           .064          6           .064           5     1.000    1.200 1 
  10      5.966           13           .119         13           .119          12     1.000    1.083 
  15      8.659           19           .362         20           .360          19     1.006    1.000 
  20     11.321           27           .727         28           .716          26     1.015    1.038 
  25     13.966           36          1.249         37          1.204          35     1.037    1.029 
  30     16.593           44          2.046         46          1.878          43     1.099    1.023 
  35     19.212           55          3.376         57         2.827           52     1.194    1.058 
  40     21.823           73          6.325         71         4.452           65     1.421    1.123 
  45     24.427          103         13.346         94         7.338           81     1.819    1.272 
| 50     27.026          189         29.414        136        12.364          104     2.379    1.817 
  55     29.620          609        124.476       367         28.931          174     4.303    3.500 
  60     32.210        2,059       391.847       1,097       108.527          518     3.611    3.975 
  65     34.796       28,216      7,984.196     15,694       649.553        2,658   12.292    10.616 
  70     37.378       41,560      9,408.125    22,628        786.126        3,549   11.968    11.710 
  75     39.957      194,851    57,529.770    119,928      5,308.159       21,739   10.838     8.963 
  80     42.534     408,580    113,746.144    233,367      7,560.130       30,972   15.046    13.192 
  85     45.108     412,576    129,618.988    282,851      8,697.441       36,098   14.903    11.429 
  90     47.680    2,522,993                              38,176.160      171,778             14.688 
  95     50.253                                          324,811.294    1,343,092 

                  Table 1: Experimental Results for Uniformly Distributed, High-Precision Numbers 

   The first column gives the problem size, which is the       ber of node generations to the corresponding column 
number of values being packed. The second column               without pruning shows the effect of nogood pruning. 
shows the average number of bins needed in the optimal           The last two columns give performance ratios of our 
solution. Since the numbers range uniformly from zero          best program, including nogood pruning. The node ra•
to the bin capacity, the expected value of any number is       tio is the number of nodes generated without nogood 
half the bin capacity, and the expected value of the sum       pruning, divided by those generated with nogood prun•
of the numbers is the half the bin capacity times the          ing. The time ratio is the running time of our original 
number of values. As expected, the average minimum             program, divided by our current best program. 
number of bins is slightly more than half the number of          As problem size increases, nogood pruning generates 
values, due to the inevitable wasted space in the bins.        increasingly fewer nodes than without pruning. On the 
   The third column gives the average running time of          largest problems we ran both algorithms on, the ratio 
our original bin-completion algorithm [Korf, 2002], in         of node generations is about a factor of 15. The fact 
microseconds. This is also the total time in seconds to        that the node generation ratio increases with increasing 
solve all one million problem instances. All implementa•       problem size suggests that nogood pruning reduces the 
tions are on a 440 Megahertz Sun Ultra 10 workstation.         asymptotic time complexity of bin completion. 
                                                                 The ratios of the running times displays a similar 
   The next two columns, labelled "Without Pruning", 
                                                               trend, although the values are less than the ratios of 
give the average node generations and running times in 
                                                               node generations. This is due to the increased overhead 
microseconds for our implementation of bin completion 
                                                               of nogood pruning. On the larger problems, our new al•
with our new method of generating undominated feasi•
                                                               gorithm is over an order of magnitude faster than our 
ble sets, but without pruning nogood sets. While this 
                                                               original algorithm. Problems of size 95 take an average 
program considers the same number of candidate solu•
                                                               of only 1.343 seconds per problem to solve optimally. 
tions as our original one, the node generations differ from 
those reported in our earlier paper [Korf, 2002]. The          Variation in Individual Problem Difficulty 
reason is that we define a node as a recursive call to the     There is tremendous variation in the difficulty of individ•
search routine, and our current implementation checks          ual problems. For example, in 68.56% percent of the one 
terminating conditions before making a recursive call,         million problems with 95 numbers, the best-fit decreas•
rather than at the beginning of the search function. Our       ing solution uses the same number of bins as the lower 
new program outperforms our original one by a factor of        bound, solving the problem without any search. Among 
up to 1.84 in running time. We didn't run it on problems       the same problems, however, twenty instances generated 
of size 90 or 95 due to the time that would be required.       more than a billion nodes, three of those generated more 
   The next two columns, labelled "With Nogood Prun•           than ten billion nodes, and one of those generated more 
ing" , give the average number of nodes generated and          than a hundred billion nodes. Our program solved over 
average running time in microseconds for our full algo•        125,000 problems of size 100 in about a day, and then 
rithm, including nogood pruning. Comparing the num•            failed to solve the next problem in over 43 days. What 


1256                                                                                                            SEARCH 