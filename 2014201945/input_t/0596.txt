                                                                          ∗
                              Limited   Discrepancy      Beam    Search

                       David  Furcy                                 Sven  Koenig
             University of Wisconsin  Oshkosh             University of Southern California
              Computer   Science Department                Computer   Science Department
                 Oshkosh,  WI  54901-8643                   Los Angeles,  CA  90089-0781
                    furcyd@uwosh.edu                              skoenig@usc.edu


                                                             layer 0 = start state
                    Abstract                                 layer 1
                                                             layer 2
    Beam search reduces the memory consumption of best-      layer 3
                                                             layer 4
    ﬁrst search at the cost of ﬁnding longer paths but its   layer 5
    memory consumption can still exceed the given mem-       layer 6
                                                             layer 7
    ory capacity quickly. We therefore develop BULB (Beam                     G
    search Using Limited discrepancy Backtracking), a com-                    a) Breadth−first search
    plete memory-bounded search method that is able to
    solve more problem instances of large search problems    layer 0 = start state
                                                             layer 1

    than beam search and does so with a reasonable runtime.  layer 2              slice 1
    At the same time, BULB tends to ﬁnd shorter paths than   layer 3           slice 1 slice 2
                                                             layer 4         slice 1 slice 2 slice 3
    beam search because it is able to use larger beam widths layer 5      slice 1 slice 2 slice 3 slice 4
    without running out of memory. We demonstrate these      layer 6   slice 1 slice 2 slice 3 slice 4 slice 5
                                                             layer 7
    properties of BULB experimentally for three standard            slice 1 slice 2 G slice 3 slice 4 slice 5 slice 6
    benchmark domains.                                              B          b) Beam search


                                                             layer 0 = start state
                                                             layer 1
1  Introduction                                              layer 2
                                                             layer 3
Best-ﬁrst search methods, such as A*, do not scale up to     layer 4
large search problems due to their memory consumption, and   layer 5
                                                             layer 6
linear-space best ﬁrst search methods [Korf, 1993] have unac- layer 7         G
ceptable runtimes for large search problems. Beam search re-
                                                                             c) Depth−first beam search
duces the memory consumption of best-ﬁrst search at the cost
of ﬁnding longer paths. It uses breadth-ﬁrst search to build its Figure 1: Visualization of Search Methods
search tree but keeps at most the B states at each level of the
search tree with the smallest heuristic values, where the value
of the beam width B is set at the beginning of the search. The reduce the memory consumption of best-ﬁrst search at the
smaller the beam width, the more states beam search prunes cost of ﬁnding longer paths. We develop BULB (Beam search
at each step of the search and the less memory it needs to Using Limited discrepancy Backtracking) that is able to solve
store each level of the search tree. Unfortunately, more prun- more problem instances of large search problems than beam
ing typically increases the probability of pruning states on search, and does so with a reasonable runtime. At the same
short paths from the start state to a goal state and thus often time, BULB tends to ﬁnd shorter paths than beam search be-
increases the lengths of the paths found. Excessive pruning cause it is able to use larger beam widths without running out
can even prevent one from ﬁnding any path. Thus, the beam of memory. It behaves like beam search until it exhausts the
width has to be large. Our experiments show, for example, memory capacity without ﬁnding a path. It then uses lim-
that beam search with a beam width of 10,000 solves about ited discrepancy backtracking to retract its previous pruning
eighty percent of random problem instances of the 48-Puzzle. decisions. The choice of a good backtracking strategy is im-
The average path length found is on average about one order portant since, for example, beam search with chronological
of magnitude smaller than the one found by variants of WA* backtracking has unacceptable runtimes.
[Pearl, 1985], which are alternatives to beam search that also
  ∗The Intelligent Decision-Making Group is partly supported by 2 Beam Search
NSF awards to Sven Koenig under contracts IIS-0098807 and IIS-
0350584. The views and conclusions contained in this document are Beam search is any search technique “in which a number of
those of the authors and should not be interpreted as representing [...] alternatives (the beam) are examined in parallel. [It] is a
the ofﬁcial policies, either expressed or implied, of the sponsoring heuristic technique because heuristic rules are used to discard
organizations, agencies, companies or the U.S. government. [prune] non-promising alternatives in order to keep the size                                                      2004] for several variants of WA*.
         Table 1: Beam Search on the 48-Puzzle
       B    Path  Generated Stored Runtime Problems
           Length  States  States (Seconds) Solved
       1     N/A     N/A     N/A    N/A     0 %       3   Improving   Beam  Search
       5   11,737.12 147,239 58,680 0.090 100 %
       10  36,281.64 904,632 362,799 0.601 100 %      We  study how to increase the number of solved problem
       50  25,341.44 3,211,244 1,266,902 2.495 86 %
      100  12,129.88 3,079,594 1,212,579 2.296 86 %   instances to one hundred percent while reducing the path
      500  2,302.86 2,899,765 1,148,559 2.205 74 %    lengths of the solved problem instances. This cannot be
     1,000 1,337.95 3,346,004 1,331,451 2.822 84 %
     5,000  481.30 5,814,061 2,365,603 5.500 86 %     done by varying the beam width since increasing it reduces
     10,000 440.07 10,569,816 4,312,007 11.307 80 %   the number of solved problem instances while decreasing it
     50,000  N/A     N/A     N/A    N/A     0 %       increases the average path length of the solved problem in-
                                                      stances. Rather, we notice that many of the unsolved problem
of the beam as small as possible” [Bisiani, 1987]. We assume instances are due to misleading heuristic values that prevent
that all actions have a cost of one and study beam-search vari- states from being included in the beam. For example, the
ants of breadth-ﬁrst search in this paper. Their objective is to goal state G is put into the third slice of the seventh layer in
reduce the memory consumption of breadth-ﬁrst search from Figure 1 (b). Beam search thus does not ﬁnd the goal state
exponential to linear in the depth of the search tree, as illus- since it visits only the ﬁrst slice of each layer. Our solution
trated by the shaded areas of Figure 1 (a) and (b) for breadth- to this problem is to backtrack and choose a different slice.
ﬁrst search and beam search, respectively. Beam search uses Figure 1 (c) shows DB (Depth-ﬁrst Beam search), our sim-
breadth-ﬁrst search to build its search tree but splits each level plest variant of beam search with backtracking. DB behaves
of the search tree into slices of at most B states, where B is like beam search until it exhausts the memory capacity with-
called the beam width. The number of slices stored in mem- out ﬁnding a path. It then uses chronological backtracking to
ory is limited to one at each level. When beam search expands purge existing slices and replace them with others. DB, un-
a level, it generates all successors of the states at the current fortunately, has unacceptable runtimes, which we explain as
level, sorts them in order of increasing heuristic values (from follows: Chronological backtracking revisits the most recent
left to right in the ﬁgure), splits them into slices of at most decisions ﬁrst, that is, the decisions close to the bottom of the
B states each, and then extends the beam by storing the ﬁrst search tree. This is problematic since the heuristic values are
slice only. Beam search terminates when it generates a goal usually the more inaccurate the farther a state is away from
state or runs out of memory.                          the goal state and thus the closer it is to the top of the search
  Table 1 shows experimental results for beam search on the tree. Thus, it is important to revisit decisions close to the
48-Puzzle with a memory limitation of 6,000,000 states. We top of the search tree more quickly. We therefore use limited
created 50 problem instances with random start conﬁgura- discrepancy search rather than chronological backtracking to
tions in which the goal conﬁguration had the blank in the build a more sophisticated variant of beam search with back-
upper left corner. We used the Manhattan distance as heuris- tracking.
tic function. (We could have used pattern databases instead
[Korf and Taylor, 1996] but did not since we use them later in 3.1 Original Limited Discrepancy Search
this paper in the context of 2 additional benchmark domains.) LDS (Limited Discrepancy Search) [Harvey and Ginsberg,
The runtime of beam search was always small since it ran out 1995] was designed to work on ﬁnite binary trees. The suc-
of memory in seconds. Beam search with a beam width of 1 cessors of a state are sorted in order of increasing heuristic
solved none of the problem instances. This is not surprising values. Thus, the heuristic values always recommend the left
since it is similar to greedy search (gradient descent) and thus successor over the right one. Choosing the right successor
likely to ﬁnd rather long paths unless it gets stuck in dead against the recommendation of the heuristic values is called
ends because the current state has only successors that are al- a discrepancy. First, LDS searches the tree greedily, that is,
ready in memory, in which case it does not ﬁnd any path at with no discrepancy. If LDS does not ﬁnd a goal state, then it
all. Beam search with a beam width of 10 solved all of the made at least one wrong decision due to misleading heuristic
problem instances. As the beam width increased, its memory values. LDS then searches the tree with increasing numbers
consumption increased, the average path length of the solved of allowed discrepancies. Figure 2 contains the pseudo code
problem instances decreased, and the number of solved prob- of LDS. The top-level function LDS() repeatedly performs
lem instances eventually decreased. Beam search with beam a limited discrepancy search from the start state (Line 4) by
width 50,000 solved none of the problem instances. This is calling LDSprobe() with an increasing number of allowed dis-
not surprising since beam search with a beam width of inﬁn- crepancies (Line 6), starting with no discrepancy (Line 2).
ity is breadth-ﬁrst search and thus guaranteed to ﬁnd shortest Unless the current state is a leaf of the tree (Line 9), LDS-
paths unless it runs out of memory and then does not ﬁnd probe() generates its successors and recursively calls itself on
any path at all, which is likely given the exponential memory them. If the maximum number of allowed discrepancies is
consumption of breadth-ﬁrst search. Consider beam search zero, then only the sub-tree below the best successor is vis-
with a large beam width that still solved a substantial number ited with no discrepancy allowed (Line 12). Otherwise, the
of problem instances, say beam search with a beam width of sub-tree under the worst successor is visited with one less
10,000 that solved eighty percent of the problem instances. discrepancy allowed (since one was just consumed, Line 14),
The average path length of the solved problem instances was then the sub-tree under the best successor is visited with the
an order of magnitude smaller than the one reported in [Furcy, same number of allowed discrepancies (since none was con-   1.  procedure   LDS(sstart  , h(.)): path length                                                             1.  procedure  BULB(sstart    , h(.), B): path length
   2.     discrepancies     := 0                                                                                2.     discrepancies     := 0; g(sstart  ) := 0; hashtable    := {sstart }
   3.     while ( true  ) do                                                                                    3.     while ( true  ) do
   4.           cost  :=  LDSprobe(sstart   , 0, discrepancies,   h(.))                                         4.           pathlength    :=  BULBprobe(    0, discrepancies,   h(.),  B)
   5.           if ( cost <  ∞   ) then return cost                                                             5.           if ( pathlength  <   ∞  ) then return  pathlength
   6.           discrepancies     := discrepancies     +  1                                                     6.           discrepancies     := discrepancies     +  1
   7.     end  while                                                                                            7.     end while
   8.  procedure   LDSprobe(state,   depth,   discrepancies,    h(.)): path length                              8.  procedure  BULBprobe(depth,      discrepancies,    h(.), B):  path length
   9.     if ( state is a leaf ) then return ∞                                                                  9.     hSLICE,     value,  index  i :=  nextSlice(depth,  0, h(.), B)
  10.     else hbest, secondi    :=  generateSuccessors(state)                                                 10.     if ( value ≥  0  ) then return value
  11.     if ( (best =  sgoal ) or (second  =   sgoal ) ) then return depth  +  1                              11.     if ( discrepancies   =   0 ) then
  12.     if ( discrepancies    =  0 ) then return LDSprobe(best,    depth  +  1, 0, h(.))                     12.           if ( SLICE   =  ∅  ) then return ∞
  13.     else                                                                                                 13.           pathlength    :=  BULBprobe(depth      +  1, 0, h(.), B)
  14.           cost  :=  LDSprobe(second,     depth   +  1, discrepancies    −  1, h(.))                      14.           for each s in SLICE    do  hashtable    := hashtable\{s}     end  for
  15.           if ( cost <  ∞   ) then return cost                                                            15.           return pathlength
  16.           return  LDSprobe(best,   depth   +  1, discrepancies,    h(.))                                 16.     else
                                                                                                               17.           if ( SLICE   6= ∅  ) then
                                                                                                               18.                 for each s in SLICE    do  hashtable   :=  hashtable\{s}     end  for
           Figure      2:  Original       Limited       Discrepancy           Search                           19.           while ( true  ) do
                                                                                                               20.                 hSLICE,    value,   index  i :=  nextSlice(depth,  index  , h(.), B)
                                                                                                               21.                 if ( value ≥  0 ) then
                                                                                                               22.                       if ( value <  ∞   ) then return value
   1.  procedure   GLDS(sstart   , h(.)): pathlength                                                           23.                       else break
   2.     discrepancies     := 0; hashtable    := {sstart  }                                                   24.                 if ( SLICE   =  ∅  ) then continue
   3.     while ( true  ) do                                                                                   25.                 pathlength    :=  BULBprobe(depth     +  1, discrepancies    −  1, h(.), B)
   4.           pathlength    :=  GLDSprobe(sstart    , 0, discrepancies,   h(.))                              26.                 for each s in SLICE    do  hashtable   :=  hashtable\{s}     end  for
   5.           if ( pathlength   <  ∞   ) then return pathlength                                              27.                 if ( pathlength  <   ∞  ) then return  pathlength
   6.           discrepancies     := discrepancies     +  1                                                    28.           end while
   7.     end  while                                                                                           29.           hSLICE,     value,  index  i :=  nextSlice(depth,  0, h(.), B)
                                                                                                               30.           if ( value ≥  0 ) then return  value
   8.  procedure   GLDSprobe(state,    depth,  discrepancies,     h(.)): path length
                                                                                                               31.           if ( SLICE   =  ∅  ) then return ∞
   9.     SET    := ∅
                                                                                                               32.           pathlength    :=  BULBprobe(depth      +  1, discrepancies,    h(.), B)
  10.     for each successor  s of state do
                                                                                                               33.           for each s in SLICE    do  hashtable    := hashtable\{s}     end  for
  11.           if ( s = s      ) then return depth   +  1
                           goal                                                                                34.           return pathlength
  12.           if ( s ∈/ hashtable  ) then SET    := SET    ∪  {s}
  13.     end  for                                                                                             35.  procedure  nextSlice(depth,index    ,h(.),B):  h array of states, integer, integer i
  14.     if ( SET   =  ∅ ) then return ∞                                                                      36.     currentlayer     := {s  ∈  hashtable   | g(s)  =  depth}
  15.     if ( hashtable  has only one empty  slot ) then return ∞                                             37.     SUCCS      :=  generateNewSuccessors(currentlayer,      h(.))
  16.     best  :=  arg mins∈SET     { h(s)  }                                                                 38.     if ( (SUCCS    =  ∅) or (index   =  |SUCCS|)      ) then return h∅, ∞,   −1i
  17.     if ( discrepancies    =  0 ) then                                                                    39.     if ( sgoal ∈ SUCCS      ) return h∅, depth   +  1, −1i
  18.           hashtable    := hashtable    ∪ {best}                                                          40.     SLICE     := ∅; i := index
  19.           pathlength    :=  GLDSprobe(best,    depth   +  1, 0, h(.))                                    41.     while ( (i <  |SUCCS|)     and  (|SLICE|    <   B) ) do
  20.     else                                                                                                 42.           if ( SUCCS[i]    ∈/ hashtable    ) then
  21.           SET    := SET\{best}                                                                           43.                 g(SUCCS[i])       := depth;  SLICE     := SLICE     ∪  {SUCCS[i]}
  22.           while ( SET    6= ∅ ) do                                                                       44.                 hashtable    := hashtable   ∪  {SUCCS[i]}
  23.                 state  :=  arg mins∈SET     { h(s)  }                                                    45.                 if ( hashtable  is full ) then
  24.                 SET    := SET\{state}                                                                    46.                       for each s in SLICE    do hashtable    := hashtable\{s}      end  for
  25.                 hashtable    := hashtable    ∪ {state}                                                   47.                       return h∅, ∞,   −1i
  26.                 pathlength    :=  GLDSprobe(state,     depth   +  1, discrepancies     −  1,             48.           i := i +  1
           h(.))                                                                                               49.     end while
  27.                 hashtable    := hashtable\{state}                                                        50.     return hSLICE,     −1,  ii
  28.                 if ( pathlength   <  ∞   ) then return pathlength
  29.           end  while                                                                                     51.  procedure  generateNewSuccessors(stateset,     h(.)):  array of states
  30.           hashtable    := hashtable    ∪ {best}                                                          52.     index   := 0
  31.           pathlength    :=  LDSprobe(best,    depth  +  1, discrepancies,    h(.))                       53.     for each state  in stateset  do
  32.     hashtable    := hashtable\{best}                                                                     54.           for each successor s of state  do
  33.     return  pathlength                                                                                   55.                 if ( s ∈/ hashtable  ) then
                                                                                                               56.                       SUCCS[index       ] := s; index  :=  index  +  1
                                                                                                               57.           end for
        Figure      3:  Generalized          Limited       Discrepancy           Search                        58.     end for
                                                                                                               59.     Sort states in SUCCS    in order of increasing h(.)-values
                                                                                                               60.   return SUCCS
sumed       at  the    current      level    by   following         the   heuristic      recom-
mendation,          Line     16).     LDS      terminates        when       it generates        the                                              Figure      4:   BULB
goal    state    (Line     11).

3.2       Generalized              Limited         Discrepancy              Search                           limited     discrepancy          search     from     a  given     state   for   a given     num-
                                                                                                             ber   of  allowed       discrepancies.           First,   it  generates       all  successors
To   apply      LDS      to  beam      search,      we    need     to  generalize         it from
                                                                                                             of  the   state    that   are   not   already      in   the   hash    table    (Lines      9-13).
binary      trees    to   arbitrary      graphs.        First,    LDS      must     be    able    to
                                                                                                             It backtracks         if  the   goal    state    is  found     (Line      11),   there     are   no
handle      branching         factors     that   are    nonuniform          and    larger     than
                                                                                                             successors        (Line     14),    or   the   hash    table     is full   (Line     15).    Oth-
two.    Second,        LDS     must     be   able    to  avoid     cycles.      GLDS       (Gen-
                                                                                                             erwise,      it identiﬁes        the   best    successor        as   one    with    a  smallest
eralized       Limited       Discrepancy           Search)       addresses         the   ﬁrst    is-
                                                                                                             heuristic      value     (Line      16).    If  the    number        of  allowed        discrep-
sue    by   picking       a  successor        s  of   a  given     state    with     a  smallest
                                                                                                             ancies     is  zero,    then     GLDSprobe()             calls   itself    on   the   best    suc-
heuristic      value     h(s).     Choosing        any    other     successor       is  counted
                                                                                                             cessor     with     no    allowed       discrepancies           (Line     19).     Otherwise,
as   one    discrepancy,          and    the    successors        are    tried    from     left   to
                                                                                                             GLDSprobe()             calls   itself    repeatedly        on   the   remaining         succes-
right.     GLDS         addresses        the    second      issue     by    performing          cy-
                                                                                                             sors    with     one     less   allowed        discrepancy          (Line      26)    and     then
cle   detection       with     a  hash    table     and    not   generating         successors
                                                                                                             calls   itself    on   the   best    successor        with    the    same     number        of  al-
that   are    already      in  the   hash     table.     Figure      3  shows      the   pseudo
                                                                                                             lowed      discrepancies          (Line     31).
code     for    GLDS.        The     top-level       function        GLDS()         repeatedly
performs        generalized          limited      discrepancy          searches        from     the
start   state   (Line     4)  by   calling     GLDSprobe()             with    an   increasing               3.3       BULB
number        of   allowed        discrepancies           (Line     6),   starting      with     no          BULB        (Beam       search      Using      Limited        discrepancy          Backtrack-
discrepancy          (Line     2).    GLDSprobe()              performs        a  generalized                ing)    combines         beam      search      with     GLDS.        Figure      4  shows       the                                                          beams. (Other linear-space search methods often store
         Table 2: Taxonomy of Search Methods              the siblings of states as well, which makes it unnec-
 beam width             type of backtracking
            none     chronological limited discrepancy    essary to re-generate the successors of states but in-
          greedy search guided    limited discrepancy search
    1
         (gradient descent) depth-ﬁrst search (LDS/GLDS)  creases the memory consumption substantially.) BULB
 intermediate beam depth-ﬁrst beam search beam search using limited is a memory-bounded search method and thus contin-
   values   search     (DB)     discrepancy backtracking (BULB)
          breadth-ﬁrst breadth-ﬁrst  breadth-ﬁrst         ues its search after memory runs out by purging states
    ∞
            search     search          search             from memory, resulting in a complete search method.
                                                          This means that BULB ﬁnds a path as long as there is
                                                          one with a length of the maximum search tree depth or
pseudo code for BULB. The top-level function BULB() is    smaller, which approximately equals M/B, where M
basically identical to GLDS(). The function BULBprobe()   is the memory capacity measured by the maximal num-
performs beam search with generalized limited discrepancy ber of states one can store. BULB thus improves on
search for a given number of allowed discrepancies. It ﬁrst beam search, which is incomplete, and on breadth-ﬁrst
generates the ﬁrst slice of the next level (Line 9). If the search, which is complete but whose maximum search
slice contains a goal state, the slice is empty, the subtree has
                                                          tree depth approximately equals logb(M), where b is the
been searched exhaustively, or the hash table (which stores average branching factor of the search tree, and can thus
the beam) is full, then it aborts (Lines 10 and 12). If the num- solve only smaller search problems than BULB.
ber of allowed discrepancies is zero (Line 11) and the slice is
not empty (Line 12), then BULBProbe() calls itself with no • The runtime of BULB is often small. In fact, BULB
allowed discrepancies (Line 13), and clears the hash table of frequently ﬁnds a path without any backtracking or with
the slice (Line 14). Otherwise, BULBProbe() clears the hash only a very limited amount of backtracking. It also elim-
table of the slice (Line 18), calls itself repeatedly on the re- inates all cycles (loops) and some transpositions (differ-
maining slices with one less allowed discrepancy (Line 25) ent paths from the start state to a given state), which
and then calls itself on the best slice with the same number are often responsible for the large runtimes of depth-
of allowed discrepancies (Line 32). The function nextSlice() ﬁrst search. BULB, as a generalization of breadth-ﬁrst
generates a successor slice for a slice that is already in the search, eliminates all cycles since it never generates
hash table at a given depth. It ﬁrst locates the given slice states that are already in the hash table. BULB does not
(Line 36), generates all successors of its states (Line 37), and make any effort at eliminating transpositions. Neverthe-
then locates the slice of the given index within the successors. less, BULB, as a generalization of beam search, elim-
It does this by inserting successors into both an empty slice inates some transpositions since it does not re-expand
(Line 43) and the hash table (Line 44), starting with the suc- states that are already in its beam.
cessor at the given index (Line 40), until either B successors
have been inserted into the slice or the end of the layer has
been reached (Line 41). If the hash table is full (Line 45), 4 Experimental Evaluation
then it clears the hash table of the incomplete slice (Line 46) We now present an experimental study of BULB in three stan-
and aborts (Line 47). The function generateNewSuccessors() dard benchmark domains: the N-Puzzle, the 4-Peg Towers
generates the successors s of a given set of states that are of Hanoi and the Rubik’s Cube. Note that our ﬁgures show
not already in the hash table and sorts them in order of in- graphs only for search methods that were able to solve all
creasing heuristic values h(s). (The successors can contain random problem instances since we are interested in increas-
duplicates.)                                          ing the number of solved problem instances to one hundred
                                                      percent. Additional results are reported in [Furcy, 2004].
3.4  Properties of BULB
Heuristic search methods that repeatedly ﬁll up and purge 4.1 N-Puzzle
memory can be rather complicated [Chakrabarti et al., 1989;
                                                      Our ﬁrst benchmark domain was the N-Puzzle, as already de-
Russell, 1992; Kaindl and Khorsand, 1994; Zhou and
                                                      scribed in the context of Table 1. Beam search solved all
Hansen, 2002]. In contrast, BULB is relatively simple be-
                                                      problem instances of small N-Puzzles with a small average
cause it purges contiguous regions of memory and is only an
                                                      path length and did so in fractions of a second. It is there-
approximation algorithm that does not necessarily ﬁnd short-
                                                      fore not surprising that neither DB nor BULB signiﬁcantly
est paths. Table 2 shows a taxonomy of search methods.
                                                      improved on beam search for N smaller than 48. The sit-
BULB  generalizes beam search to beam search with back-
                                                      uation was different for the 48-Puzzle. DB did not signiﬁ-
tracking, limited discrepancy search to beam widths larger
                                                      cantly improve on beam search for the 48-Puzzle either. On
than one, and breadth-ﬁrst search to beam widths smaller than
                                                      the other hand, BULB was able to solve all problem instances
inﬁnity.
                                                      with a beam width of 10,000 while beam search was only
  • The memory  consumption of BULB is O(Bd), where   able to solve all problem instances with beam widths of 10
    d is the maximum search tree depth. This is achieved or smaller. BULB was able to ﬁnd paths of average length
    by only storing one slice for each level, which requires 440 with this beam width while beam search was only able
    BULB  to re-generate all successors of the states of a to ﬁnd paths of average length 11,737 with beam widths that
    slice every time it backtracks. The resulting small mem- allowed it to solve all problem instances (for B = 5, which
    ory consumption allows for deeper searches with wider is not shown in Table 1). Thus, BULB was able to reduce                     a) Path Length
                                                            Table 3: Beam Search on the Towers of Hanoi
                                beam search                  B     Path  Generated Stored Runtime Problems
      100000                         BULB                         Length  States States (Seconds) Solved
                                                              1     N/A     N/A   N/A     N/A    0 %
                                                              5  37,775.12 730,901 188,860 0.306 68 %
                                                             10  33,489.26 1,261,982 334,850 0.581 46 %
                                                             50   8,468.59 1,619,300 423,103 0.900 68 %
                                                             100  4,629.57 1,784,654 462,443 1.012 70 %
       10000                                                 500  1,363.59 2,632,408 678,792 1.855 74 %
                                                            1,000  831.90 3,196,242 824,784 2.388 58 %
                                                            5,000   N/A     N/A   N/A     N/A    0 %

        1000                                          was no beam width that allowed beam search to solve all 50
    Solution  cost (log scale)                        random problem instances but BULB was able to solve them
                                                      for a wide range of beam widths. The smallest average run-
            1      10     100    1000   10000         time of BULB with a beam width that solved all problem in-
                        B (log scale)                 stances was about 12 seconds. It was obtained with a beam
                    b) Memory Usage                   width of 6 and resulted in an average path length of about
                                                      181,000. A larger beam width of 20,000, that still solved
                                beam search
                                     BULB             all problem instances, increased its average runtime to about
       1e+07                                          120 seconds but reduced the average path length to 1,130,
                                                      which is less than 5 times the shortest path length. Figure 6
                                                      shows that BULB was also able to improve the average path

       1e+06                                          length of two multi-state commitment search methods for the
                                                      48-Puzzle by at least one order of magnitude with an aver-
                                                      age runtime of only about 20 seconds. These alternatives to
                                                      beam search are MSC-KWA*  [Furcy and Koenig, 2005], a
      100000
                                                      combination of KWA* [Felner et al., 2003] and MSC-WA*
                                                      [Kitamura et al., 1998], and MSC-KRTA* [Furcy, 2004], a
                                                                          [               ]          [

    Number  of Stored Nodes (log scale)               combination of KWA* Felner et al., 2003 , MSC-WA* Ki-
       10000
            1      10      100     1000   10000       tamura et al., 1998] and RTA* [Korf, 1990].
                        B (log scale)
                                                      4.2  Towers  of Hanoi
      Figure 5: BULB on the 48-Puzzle (B Varies)      Our second benchmark domain was  the 4-Peg Towers of
                                                      Hanoi. We  created 50 random problem instances with 22
                                                      disks in which the goal state had all disks stacked on one
                                beam search
                                     BULB             peg. We  set the memory capacity to 1,000,000 states and
                                  MSC-KWA*            used a pattern database similar to that of [Felner et al., 2004]
                                 MSC-KRTA*
                                                      as the heuristic function. Table 3 shows that, similarly to the
       10
                                                      48-Puzzle, beam search with large beam widths solved many
                                                      problem instances, and the average length of the paths found
                                                      was short. However, there was no beam width that allowed
                                                      beam search to solve all 50 random problem instances (which
        1
                                                      is the reason why Figure 7 contains no graphs for beam
                                                      search) but BULB was able to solve them for a wide range
                                                      of beam widths. The smallest average runtime of BULB with
    Time  in Seconds (log scale)                      a beam width that solved all problem instances was about 1.5
      0.1                                             seconds. It was obtained with a beam width of 40 and re-
               1000         10000        100000
                  Solution Cost (log scale)           sulted in an average path length of about 10,000. A larger
                                                      beam width of 1,000, that still solved all problem instances,
  Figure 6: Search Methods on the 48-Puzzle (B Varies) increased its average runtime to about 7 seconds but reduced
                                                      the average path length to about 870. Figure 7 contains de-
                                                      tailed data points about BULB.
the path length or, synonymously, solution cost by a fac-
tor of about 25. At the same time, the average runtime of 4.3 Rubik’s Cube
BULB  was still on the order of 30 seconds on a Pentium 4 Our third benchmark domain was the Rubik’s Cube. We cre-
PC clocked at a 2.2 GHz. Figure 5 contains detailed data ated 50 random problem instances in which the goal state was
points about BULB. Since BULB generates states in exactly the original conﬁguration of the cube. We set the memory ca-
the same order as beam search, the graphs of BULB simply pacity to 1,000,000 states and used the pattern databases from
extend the ones of beam search to larger beam widths. For the [Korf, 1997] as the heuristic function. Beam search was only
80-Puzzle and a memory capacity of 3,000,000 states, there able to ﬁnd paths of average length 55.18 with beam widths