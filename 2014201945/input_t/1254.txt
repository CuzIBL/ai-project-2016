                    Cohesion,     coupling   and   the  meta-theory     of actions

                                Andreas  Herzig   and Ivan  Varzinczak   
                                     IRIT – Universite´ Paul Sabatier


                       118 route de Narbonne  – 31062  Toulouse  Cedex  04 France
                                              ¡


                                      e-mail:  herzig,ivan ¢ @irit.fr


                    Abstract                            With this in mind, one can see the speciﬁcation of domain
                                                      descriptions as a task similar to project development in soft-
    In this work we recast some design principles com- ware engineering: Item 4 above is what has been called elab-
    monly used in software engineering and adapt them oration tolerance [McCarthy, 1988]. In this way a represen-
    to the design and analysis of domain descriptions tation is elaboration tolerant to the extent that the effort re-
    in reasoning about actions. We show how the infor- quired to add new information (a new action or effect) to the
    mal requirements of cohesion and coupling can be  representation is proportional to the complexity of that infor-
    turned into consistency tests of several different ar- mation [Shanahan, 1997]. Items 1, 2 and 3 reﬂect the concept
    rangements of modules. This gives us new criteria of modularity, which means that different modules have no
    for domain description evaluation and clariﬁes the elements in common. Such a notion of modularity is going to
    link between software and knowledge engineering   lead us along the present work.
    in what concerns the meta-theory of actions.
                                                        This paper is an elaboration of the results we have pre-
                                                      sented in [Herzig and Varzinczak, 2004]. Here we pursue the
1  Introduction                                       following plan: in Section 2 we recall some important con-
                                                      cepts from software engineering; after discussing the ontol-
Among the principles of the object-oriented paradigm are the ogy of dynamic domains (Section 3) we apply the concepts
following:                                            of Section 2 to the design of domain descriptions (Sections 4
 1. Work with modules (or components, functions, etc.). and 5) making a step towards formal criteria for domain de-
                                                      scription evaluation. In Section 6 we present the main results
 2. Minimize interactions between such modules.       that follow from our approach, and before concluding we ad-
 3. Organize the modules into well-deﬁned layers to help dress related work found in the literature on this subject.
    minimize interactions. The goal is to have components
    of one layer using only components from immediate 2   Some  principles of software  engineering
    neighbors, wherever possible.                     One of the ﬁrst steps in software development is that of ab-
 4. Anticipate what kind of extensions or modiﬁcations straction. Abstraction consists mainly in rendering lower-
    might be made in the future, and support this at design level details invisible to upper levels in order to facilitate the
    time so that one can extend the system with minimal dis- understanding and design of complex systems. As an exam-
    ruption later.                                    ple, a speciﬁcation of a data or knowledge base query does
                                                      not need to take into account the algorithmic process that will
  There seems to be an agreement that such principles for be carried out in order to answer the query.
object-oriented programming or design are the same as for In parallel to abstraction, one of the most important guide-
knowledge representation. To witness, the design of domain lines in project design is that of modularity: dividing the soft-
descriptions in reasoning about actions has much more in ware into modules, based on their functionality or on the simi-
common  with software engineering than one might think: in larity of the information they handle. This means that instead
the same way as for software projects, one can talk about con- of having a “jack of all trades” program, it is preferable to
sistency, evolution and correctness of domain descriptions. split it up into specialized subprograms. For instance, a pro-
  All the principles above can be applied to the design of do- gram made of a module for querying a database and a module
main descriptions, too. We argue that a good domain descrip- for checking its integrity is more modular than a single mod-
tion should be one whose consistency check and maintenance ule that does these two tasks at the same time.
complexities are minimized, so that any further modiﬁcation Among the major beneﬁts of modular systems are reusabil-


is localized, with a bounded scope.                   ity, scalability and better management of complexity.
  £
   Supported by a fellowship from the government of the FEDER- There is more than one way to split up a program. One
ATIVE REPUBLIC OF BRAZIL. Grant: CAPES BEX 1389/01-7. of the most used techniques is that of forcing functional in-dependence of its modules. One ensures functional indepen- is illustrated by Figure 1, where we can see the relationship
dence in a project by deﬁning modules with only one pur- among the different types of entities.
pose and “aversion” to excessive interaction with other mod- A domain description consists of a description of effects
ules [Pressman, 1992].                                of actions, their non-effects, executabilities, inexecutabilities
  Among  the criteria commonly used for evaluating func- and also state constraints that do not depend on any particular
tional independence of modules (and thus how modular a action.
piece of software is) are the informal notions of cohesion and


                                                                        domain description


                                                                            ¥¤ ¦§


                                                                          ¤    §


                                                                          ¥     ¦ §




coupling.                                                               ¤


                                                                      ¤            §


                                                                    ¤   ¥         ¦  §


                                                                  ¤                    §


                                                                ¤     ¥             ¦     §


                                                              ¤                             §


                                                            ¤                                 §
                                                                                      ¦


  Cohesion is how closely related pieces of a single compo-         ¥


                                                          ¤                                     §
nent are to each other. A module is cohesive when at the high effects non-effects exec. inexec. state constraints
level of abstraction it does only a single task. The more a
module is focused on a precise goal the more it is cohesive. Figure 1: “Class diagram” of modules in designing domain descrip-
  A highly cohesive module will be simpler to understand, tions. Edges represent has-a relations.
having to do only a single task, while a lowly cohesive mod-
ule, performing so many tasks, will be difﬁcult to understand. Among the effects of actions, we can distinguish direct ef-
  It is difﬁcult to reuse a task-overloaded module, while a fects and indirect effects (ramiﬁcations).
highly cohesive module is simpler to reuse and to extend. Non-effects of actions are related with the frame prob-
  Coupling is the interdependency between a method and the lem [McCarthy and Hayes, 1969], and indirect effects with
environment (other methods, objects and classes). Low cou- the ramiﬁcation problem [Finger, 1987]. In this work we
pling means to keep dependencies (communication, informa- abstract from these problems and assume we have a con-
tion sharing) between components at a minimum.        sequence relation powerful enough to derive the intended


  A design that has low coupling is more amenable to  conclusions. We suppose given a ‘doped’ consequence re-
                                                            ©
change, since it reduces the probability of changes cascading lation ¨ , which encapsulates some traditional approach in
and affecting a larger part of the system.            the literature (e.g., [Schubert, 1990; Lin, 1995; McCain and
                                                      Turner, 1995]), with which all intended frame axioms and in-
  Unanimously in object-oriented development, the best way direct effects can be derived, and we use it henceforth. As
to design a software is to have low coupling and high cohe- examples we have



sion. We sum this up in two informal design principles:          



                                                                            ©            
                                                                  loaded ¨ loaded do wait
P1. Maximal cohesion: Every module should be conceived


    in such a way that it is maximally cohesive.      (i.e., waiting does not change the status of loaded) and
                                                       



P2. Minimal coupling: All modules should be conceived in      walking 


                                                                                   


                                                                   


                                                                                 ©               !


    such a way that they minimize coupling.               walking     alive      ¨  walking do shoot


                                                           


                                                                          
                                                            alive  do shoot
3  Natural  modules   in domain  descriptions         Hence shooting has the indirect effect that the victim will no
Like in object-oriented programming, in describing a domain longer be walking.
different entities should be separated in different modules. We use small letters to denote variables, and capital letters
Moreover, each module should be conceived in such a way to denote constant symbols. Free variables are supposed to
that it has no direct access to the contents of the others. In be universally quantiﬁed.
reasoning about actions, accessing a module means using it To sum it up, our main concern here will be with direct
to perform reasoning tasks like prediction, postdiction, plan- effects (henceforth effects), inexecutabilities, executabilities
ning and others. This amounts to using its logical formulas and state constraints. We introduce this in what follows.
in inferences. In this section we establish the ontology of do- Effect laws Logical frameworks for reasoning about ac-
main descriptions and present the way we arrange in different tions contain expressions linking actions and their effects. We
modules the axioms commonly used to describe them.    suppose that such effects might be conditional, and thus get a


                                                      third component of such axioms. An effect law for action " is
  Every domain description contains a representation of ac- of the form


tion effects. We call effect laws formulas relating an action
                                                                                         #"$!
to its effects. Statements of conditions under which an ac-     Poss #"$%'&()+*, do


tion cannot be executed are called inexecutability laws. Ex-
                                                                                                    
                                                      where &( is a simple state formula about situation , and


ecutability laws in turn stipulate the context where an action


                                                           #"$                              #"$
                                                      *, do    is a simple state formula about situation do .
is guaranteed to be executable. Finally, state constraints are
                                                        A simple state formula about a situation term - contains no
formulas that do not mention actions and express constraints
                                                      Poss-predicate and no situation terms other than - [Lin, 1995].
that must hold in every possible state. These are our four in- An example of effect law is



gredients that we introduce more formally in the sequel.                            


                                                                  %   )           !.
                                                         Poss  shoot   loaded       alive do shoot
  If we think of a domain description as a software appli- saying that whenever shoot is executable and the gun is


cation, we can imagine its organization in an object-oriented loaded then after shooting the turkey is dead. Another one


                                                                 /            !
view and attempt to have a kind of class diagram for it. This is Poss  tease walking do tease : the result of teas-
                                                      ing is that the turkey starts walking.                                                                                                  9:J;>=KF


Inexecutability laws The design of domain descriptions  For parsimony’s sake, we deﬁne 5?6GFGHI5?68 ,
                                                                  5?=@;,FNHL5?=@;O8
must also provide a way to express qualiﬁcations of actions, HL9:<;>=M8 , and  . We suppose all these sets are


i.e., conditions under which an action cannot be executed consistent.
                                                                              P


at all. An inexecutability law for action " is of the form A domain description   is a tuple of the  form
                                                      Q




                                                       5?6R94:<;>=S5?=@;$B@CTDECU .


                        
                             #"$
                 &(0 Poss


                                                        Once the information contained in a module is not mixed
                                    


where &( is a simple state formula about .       with others’, it can be expected that undesirable side effects


                           


                                      
  For example, HasGun 1 Poss shoot  states that due to further modiﬁcations are less likely to propagate to
shoot cannot be executed if the agent has no gun.     other parts of the domain description. The same thing can be
State constraints (alias domain constraints) Frameworks obtained for the consistency check if beyond of being sepa-
allowing for indirect effects make use of formulas that link rated the modules are designed in such a way that their inter-
invariant propositions about the world. Such formulas char- action is minimized. This is what we address in this section.
acterize the set of possible states. A state constraint is a sim- As we have seen, in software engineering functional inde-
                                                      pendence is evaluated by means of two criteria: cohesion, a
ple state formula about the situation term  that is consistent.


                                                      criterion for evaluating the relative functional strength of a
                             
An example is walking  alive , saying that if a turkey
is walking, then it must be alive [Thielscher, 1995]. module, and coupling, an assessment of relative interdepen-
                                                      dence among different modules. Both these notions are quite
Executability laws With only state constraints and effect informal, even in software engineering, and cannot be mea-
laws one cannot guarantee that action shoot is executable if sured in an objective way.



the agent has a gun. An executability law for action " is of Here we explore these concepts when applied to domain


                    #"$   &(


the form &(2 Poss , where     is a simple state descriptions and show how the informal requirements of soft-


                                 (       
formula about  . For instance HasGun  Poss shoot     ware engineering can be turned into tests of consistency of


says that shooting can be executed whenever the agent has a several different arrangements of modules.
                
gun, and Poss  tease that the turkey can always be teased.
  Whereas all the extant approaches in the literature that al- 4 Cohesion
low for indirect effects of actions contain state constraints
and effect laws, the status of executability laws is less con- Normally cohesion comes with modularization, and its eval-
sensual: some authors [Schubert, 1990; Doherty et al., 1996; uation depends mainly on the entities that one takes into ac-
McCain and Turner, 1995; Thielscher, 1995] more or less tac- count when describing a domain.
itly consider that executability laws should not be made ex- In talking about sets of logical formulas we take cohesion
plicit but rather inferred by the reasoning mechanism. Others as how simple or well-deﬁned a logical module is, consider-
[Lin, 1995; Zhang et al., 2002] have executability laws as ﬁrst ing the different types of formulas that can be derived from it.
class objects one can reason about.                   We thus reﬁne our ﬁrst design principle:
  We nevertheless would like to point out that maximizing P1’. The less types of laws a given module entails alone, the
executability, as usually done in the literature, is not always more cohesive it is.


intuitive: suppose we know that if we have the ignition key, As an example consider the following module:
                                                               V


the tank is full, 34343 , and the battery tension is beyond 10V,


                                                                               


                                                                                         .


then the car (necessarily) will start. Suppose we also know        HasGun  Poss shoot


                                                                                         W
that if the tension is below 8V, then the car will not start. What HasGun ) Poss shoot


should we conclude in situations where we know that the ten-                               
                                                      From such a set alone one can derive both HasGun ,



sion is 9V? Maximizing executabilities makes us infer that it 


                                                                         )       
                                                       Poss  shoot and HasGun      Poss shoot  , which are
will start, but such reasoning is not what we want if we would formulas of two different kinds. In this case we say that such a
like to be sure that all possible executions lead to the goal. set is a lowly cohesive module, for alone it functions to derive
  It seems a matter of debate whether one can always do executabilities and inexecutabilities. A better approach would
without executabilities. We think that in several domains one be to decompose such a module into the following ones:




wants to explicitly state under which conditions a given ac-          



                                                                                    


                                                                    F           )        
tion is guaranteed to be executable, such as that a robot should 9:J;X= shoot HasGun  Poss shoot


never get stuck and should always be able to execute a move            



                                                                     F         0       
                                                             5?=@; shoot HasGun      Poss shoot
action. In any case, allowing for executability laws gives us
                                                        Total cohesion is not always easy to achieve. Suppose, for
more ﬂexibility and expressive power.
                                                      instance, a hypothetical situation in which we reason about


Domain descriptions Given the four types of entities de- the effects of drinking a cup of coffee:


                                                                                                    ^
                                                                               


ﬁned above, we arrange them in the following way: for a               Poss  drink


                                                                   \


          "  57618                      9:<;>=<8


                                                                                     !.


given action ,   is the set of its effect laws, is the                 sugar    happy do drink


                                                          576    FZY [
                                                                                                    [






                             5?=@;A8                         drink
                                                                    [
                                                                                                    _


set of its inexecutability laws, and is the set of its ex-                                          [
                                                                               


                                                                      Poss  drink


                                                                                                    `
              BCDEC



ecutability laws.  denotes the set of all state constraints                    




                                                                      
                                                                                            !


                                                                      salt  happy do drink




                                                                    [
                                                                                                    [


                      5?6   57=@;    94:<;>=


                               8         8


of a given domain. Thus, 8 ,     and      , for each




                                                                    []
                                                                                                    [


                                                                                           


           BCDEC                                         5?6               .a !0      
action " , and  are the natural modules we consider here Then, drink entails sugar salt      Poss drink .

in designing a domain description.                    This means that from 5?6 drink alone we do not get only effect

                                                                       V


                                                                                   


laws but also inexecutability laws. Therefore 5?6 drink is not            walking     alive


                                                               B@CTDEC{rxF


                                                                                    


                                                                                               W
                                                                                          
as cohesive as one might have expected.                                    dead | alive
  One step towards augmenting cohesion of a module of ef-

                                                      Observe that to derive the domain constraint walking }




fect laws can be by completely specifying the preconditions 


                                                                       BCDEC
                                                       dead    one only needs   r , i.e., no other module is re-
of effects of actions. For example, the weaker effect laws



                                                      quired for that. On the other hand, to conclude dead }


                                                     ^


                                                      


                                                                            BCDEC~r 94:<;>=Jr


                                                       Poss  tease one needs both    and      .
                     


            Poss  drink
         \


                                                       Totally decoupled descriptions are not common in appli-


                 @a   )        .


             sugar     salt     happy do drink


5?6cb  FZY [                                         [


                                                     [_


   drink  [                                           cations of real interest. For the example above, it seems to
                     


            Poss  drink


                                                     `


                                                                                                B@CTDAC~r
                                 


                                                     be impossible to diminish the interaction between and


                a    )          !


             salt    sugar        happy do drink


                                                      9:J;>=


                                                           r
                                                     [


          [                                                 without abandoning the concept of state constraints.


          []                                         [




                                                        On  the other hand, if 57=@;yr in our example contained
                                   b


guarantee a higher cohesion of module 5?6 drink in comparison
                                                               
                                                      Poss  tease , things would be different: in this case, with


to that of 576 drink.
                                                                                                      


                                                      9:J;>=<r one would be able to infer the state constraint alive ,
                   B@CTDAC
  By the deﬁnition of   , it is easy to see that from the but such a law cannot be derived from BCDEC{r alone. A higher

state constraints we can derive formulas of any type, so BCDEC degree of interaction between this set and the others is nec-
is by nature a lowly cohesive module.                 essary in order to do that. In such a case one would say that


  We are thus interested in reﬁning even more our principle there is a high coupling among Pr ’s modules.
of high cohesion P1’ by the following ones:


                                                        The principle of minimal coupling P2’ can be reﬁned in


             ©e&(  fg¨ ©e&(


P1’-1. If 9:J;>=d¨ , then      .                     two more speciﬁc design principles:


              ©e&(N   #"$  fg¨ ©e&(N


P1’-2. If 9:<;>=d¨      Poss    , then               P2’-1. No implicit inexecutability laws:
        #"$


    Poss    .                                                           


                                                               ©&(0   #"$


                                                          if P¨         Poss     , then


                                                                              


                                                          9:J;>=SB@CTDEC¨ ©e&( #"$


            ©e&(   f1¨ ©e&(


P1’-3. If 5?=@;R¨  , then       .                                               Poss


                        


             ©e&(L     "$ fg¨ ©e&(i


P1’-4. If 5?=@;h¨        Poss    , then               P2’-2. No implicit state constraints:


    


         "j


                                                               ©&(  BCDECg¨ Fz&(


     Poss     .                                           if P¨     , then          .


             ©     "j?k'&(?l*, #"$!


P1’-5. If 57=@;h¨ Poss               do       , then


      ©     "$)%'&()+*, #"$!
    fg¨ Poss                  do      .                 P2’-2 is a useful feature of descriptions: beyond being a


                                                      reasonable principle of design that helps avoiding mistakes,


            ©e&(  fg¨ ©e&(


P1’-6. If 5?6m¨   , then       .                      it clearly restricts the search space, and thus makes reasoning


        5?6m¨ ©e&(n   #"$  f1¨ ©e&(o


P1’-7. If               Poss    , then                easier. To witness, if P satisﬁes P2’-2, then its consistency
        #"$


    Poss    .                                         amounts to that of BCDEC :


                       


        576p¨ ©e&(N   #"$  fg¨ ©e&(N


P1’-8. If                Poss    , then               Theorem  5.1 If P has no implicit state constraints, then
    



     Poss "j .


                                                                         ©e   B@CTDECg¨ FNg3
                                                                      Pn¨    iff
  All these principles say is that a formula of a given type
entailed by a module of a different type must be a theorem of 5.1 No implicit inexecutability laws
the logic.



                                                      Consider the following domain description Pt :


                                                                                                     ^


                                                                                      !.


5  Coupling                                                     \ Poss tease     walking do tease


                                                        5?6t7F


                                                                          


As we have seen, coupling evaluates how much a module is          Poss shoot                         _


                                                                Y


                                                                                                     `


                                                                               


                                                                         )          !!


tied to or dependent upon other modules. We take as coupling       loaded      alive do shoot
                                                                ]



of two or more sets of different types of action laws how much                    



                                                                                             .


interaction among them is needed to derive a formula of a 94:<;>=Mt7F57=@;>t?FfEBCDECTt?F walking alive


                                                                    0            


given type. Interaction here means sharing logical formulas. From Poss  tease walking do tease it follows with


                                                                       0         !
Now we reﬁne our second design principle:             B@CTDECt that Poss tease alive do tease , i.e., in every
P2’. The less new consequences two or several modules situation, after teasing the turkey is alive:


    have, the less coupled they are.


                                                                     ©                  !


                                                          5?6t{B@CTDACtc¨ Poss tease alive do tease
                                       qut


(The new consequences of modules qsr and   are those


                                                                               


                                                                 ©                  


                                                      Now  as P2tc¨  alive       alive do tease  , the sta-


              q    q
                      t
consequences of rMv    that are not consequences neither


                                                      tus of ﬂuent alive is not modiﬁed by the tease action,
           qut


of qpr nor of  alone.)


                                                                                             


                                                                 576 .BCDEC ¨ ©N #-"O>@a !
                                                                          t
                                                      and we have   t          Poss            alive


  For instance, consider the domain description Pwr :


                                                                         


                                                             #-"O>a  -"EX!!


                                                       alive do          alive do         . From this it fol-


                                               ^


                                                                          


                               !.


                                                          P2tc¨ ©             


         \  Poss tease     walking do tease           lows       alive       Poss tease , i.e., the turkey can-


                                                                                              


                                                                                94:<;>= B@CTDEC ¨ ©  0


                                                                                    t     t


  5?6  F


     r                                                not be teased if it is dead. But         alive


                    




            Poss shoot                         _


          Y                                           


                                               `


                        
                                                                


                                                       Poss  tease , hence Principle P2’-1 is violated. The for-


                  )           !!


             loaded     alive do shoot


                                                                     


                                                                0        


          ]                                           mula  alive      Poss tease   is an example of what we


           





                        
            


                  )        X57=@;yrxFzf
   9:J;>=<rxF alive     Poss tease                   call an implicit inexecutability law.  In the literature, such laws are also known as implicit qual- Checking whether a domain description satisﬁes Princi-
iﬁcations [Ginsberg and Smith, 1988], and it has been argued ple P2’-2 can be made with little adaptation of the material
that it is a positive feature of reasoning about actions frame- on the subject present in the literature [Zhang et al., 2002;
works to leave them implicit and provide mechanisms for in- Lang et al., 2003; Herzig and Varzinczak, 2004]. We do not
ferring them [Lin, 1995; Thielscher, 1995]. The other way deepen into further details here, and just present the main re-
round, one might argue as well that implicit qualiﬁcations in- sults that we obtain when considering descriptions that satisfy
dicate that the domain has not been described in an adequate the design principles that have been proposed (due to space
manner: inexecutability laws have a form simpler than that of limits no proof is given).
effect laws, and it might be reasonably expected that it is eas-

                                                      Theorem  6.2 Let P   be  the  translation into Situa-


ier to exhaustively describe them. (Note that nevertheless this
                                                                                                  /c
                                                      tion Calculus of  a  domain  description in      .
is not related to the qualiﬁcation problem, which basically

                                                      If  P    has  no   implicit state constraints, then


says that it is difﬁcult to state all the executability laws of a


                                                         ©     #"$    &(    *,  "j!!
                                                      Pn¨  Poss                              do       iff


domain.) Thus, all the inexecutabilities should be explicitly


                                                                       ©     #"$%'&()+*, "j!!
                                                      5?68E9:J;>=M8>B@CTDEC¨ Poss       do      .
stated, and this is what Principle P2’-1 says.


                                                      This means that under P2’-2 one has modularity inside 576 ,


5.2  No implicit state constraints                    too: when deducing the effects of action " we need not con-
Executability laws increase expressive power, but might con- sider the action laws for the other actions. Versions for exe-
                                                      cutability and inexecutability can be stated as well.


ﬂict with inexecutability laws. For instance, let P be such


                        



                                   


   576  F576  9:J;X= F              .


             t      


that         ,           alive      Poss tease   ,
                                                                                      P


         
                                            Theorem  6.3 There exist descriptions not satisfying P2’-2


5?=@; F             BCDEC FB@CTDEC


                                         t


         Poss tease   , and               .  (Note


                                                                 ©     "j &( *, "j!!
                                                      such that P¨ Poss                     do       and


that Principle P2’-1 is satisﬁed.) We have the unintuitive


                                                                       ©    #"$%'&()+*, "j!!


                                                      5?68E9:J;>=M8>B@CTDEC¨ Poss       do      .


            ©     
9:J;>=@~57=@;>(¨ alive : the turkey is immortal! This is


                                                      For example, just take P as before:


an implicit state constraint because alive  does not follow


                                                                            


                                                      P   ¨ ©       ª    g         !


                                                           Poss shoot       alive      alive do shoot  ,
    B@CTDEC


from      alone: P2’-2 is violated.


                                                                      9:J;>=M .BCDECT¨ ©   «


  The existence of implicit state constraints may thus in- however 5?6 shoot shoot     Poss shoot


                                                       




                                                      
                                                                             !
dicate too strong executability laws: in our example, one alive ) alive do shoot .
wrongly assumed that tease is always executable. It may also
indicate that the inexecutability laws are too strong, or that 7 Related work
the state constraints are too weak.                   Pirri and Reiter [1999] have investigated the metatheory of
                                                      the Situation Calculus. In a spirit similar to ours, they use
6  Results  for a dependence   based solution to      executability laws and effect laws. Contrarily to us, their
   the frame  problem                                 executability laws are equivalences and are thus at the same
                                                      time inexecutability laws. There are no state constraints, i.e.,
Given an axiomatic theory of actions with a solution to the

                                                      B@CTDEC¬F­f . For this setting they give a syntactical con-
frame and the ramiﬁcation problems, we are interested in dition on effect laws forcing them not to interact with ex-
knowing whether domain descriptions encoded in it satisfy ecutability laws, which precludes implicit state constraints.
or not our set of design principles. Here we chose to use the Basically, the condition says that when there are effect laws



modal framework of /c [Castilho et al., 1999], which


                                                                    '&(u &( #"$! "ju
                                                      Poss #"$u          do       and Poss


has been shown to support Reiter’s solution to the frame prob-




                                                      & }®& 
                                                                     "$! &( & 


                                                        b        b
                                                                  do       , then    and  b   are inconsis-
    [                    ]
lem Demolombe  et al., 2003 and also proposes an assess- tent (which essentially amounts to having in their domain de-


ment of the ramiﬁcation problem.                      scriptions a kind of “implicit state constraint schema” of the
      {$!



  Let         be a translation of a domain description in  


                                                            '&(Ma& !


                                                      form           b   ).


0                                       "   


      into the Situation Calculus. Dependences         This then allows them to show that such descriptions are al-
                                                 "
are translated into predicates X '¡)#"$ , meaning that action ways consistent. Moreover they thus simplify the entailment
may cause literal  to be true. The extension of dep is then cir- problem for this calculus, and show for several problems such


cumscribed (cf. Schubert’s explanation closure assumption). as consistency or regression that only some of the modules of


                      


                             


As examples, ~ ¢¡) shoot walking means that shoot may a domain description are necessary.


                                                 


cause walking to be false, and the absence of X '¡) tease alive




                     
                                


                                           !
induces the frame axiom alive ) alive do tease .  Amir [2000] focuses on design and maintenance of ac-


                                                      tion descriptions applying concepts of the object-oriented
                                           0
Theorem 6.1 If P2£A¤<¥M¦ is a domain description in ,


                                                      paradigm in the Situation Calculus. In that work, guidelines


    {§$!¨©#P2£A¤<¥ 
then              ¦  satisﬁes Principles P1’-1—P1’-7.


                                                      for a partitioned representation of a given description are pre-
         /c
  Even in      , however, it is possible to derive inexe- sented, with which the inference task can also be optimized,


cutabilities from 576 (see the example in Section 4), which as it is restricted to the part of the domain description that is
violates Principle P1’-8. Establishing maximal cohesion of really relevant to a given query. This is observed specially


5?6 in this case involves weakening of preconditions of ac- when different agents are involved: the design of an agent’s
tion effects. Anyway, conceiving an algorithm to accomplish description can be done with no regard to others’, and after
this task is not difﬁcult (due to space limitations we omit its the integration of multiple agents, queries about an agent’s
presentation here).                                   beliefs do not take into account the belief state of other agents.