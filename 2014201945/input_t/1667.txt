                              The   Rules   of Constraint    Modelling
             Alan M.  Frisch  and  Chris Jefferson  and  Bernadette   Mart´ınez Hernandez´
              Artiﬁcial Intelligence Group, Dept. of Computer  Science, Univ. of York, UK
                                    {frisch,caj,berna}@cs.york.ac.uk
                                              Ian  Miguel
                         School of Computer  Science, Univ.  of St Andrews, UK
                                         ianm@dcs.st-and.ac.uk

                    Abstract                          supported by existing constraint solvers. Hence, we refer to
                                                      our rules as reﬁnement rules. Our current focus is on gener-
    Many  and diverse combinatorial problems have     ating a set of correct models that includes those that a human
    been solved successfully using ﬁnite-domain con-  expert would generate. Future work will focus on generating
    straint programming. However, to apply constraint only good models.
    programming to a particular domain, the problem
    must ﬁrst be modelled as a constraint satisfaction
    or optimisation problem. Since constraints provide 2  Challenges  and  Contributions
    a rich language, typically many alternative models A central task, arguably the central task, of modelling most
    exist. Formulating a good model therefore requires combinatorial problems is choosing a representation of com-
    a great deal of expertise. This paper describes   plex decision variables. Current ﬁnite-domain constraint
    CONJURE, a system that reﬁnes a speciﬁcation of a solvers provide decision variables whose domains contain
    problem in the abstract constraint speciﬁcation lan- atomic elements, which we call atomic variables.1 Yet, com-
    guage ESSENCE into a set of alternative constraint binatorial problems often require ﬁnding a more complex
    models. Reﬁnement is compositional: alternative   combinatorial structure. For example, the Social Golfers
    constraint models are generated by composing re-  Problem (SGP, see [9] problem 10) requires partitioning a set
    ﬁnements of the components of the speciﬁcation.   G of golfers in each week of play. Thus, the goal is to ﬁnd
    Experimental results demonstrate that CONJURE is  a multiset of partitions of G, i.e. a multiset of sets of sets
    able to generate a variety of models for practical of G. Modelling the SGP requires deciding how to represent
    problems from their ESSENCE speciﬁcations.        this complex decision variable as a constrained collection of
                                                      atomic variables.
                                                        In concert with choosing a representation of complex de-
1  Introduction                                       cision variables is the task of representing the constraints
                                                      of the problem. In its natural form, a combinatorial prob-
To employ ﬁnite-domain constraint programming technology lem imposes constraints on the combinatorial structure that is
to solve a problem, the problem ﬁrst must be characterised, sought. These constraints must be “translated” so that they
or modelled, by a set of constraints on decision variables that are imposed on the representation of the decision variables.
solutions must satisfy. Modelling can be difﬁcult and requires
                                                        This paper shows how these two central tasks of modelling
expertise, thus limiting widespread use of constraint technol-
                                                      can be formalised and automated, and in doing so reports two
ogy. The vast majority of research on constraint modelling
                                                      principal contributions. First, we have designed a language,
presents alternative models to a particular problem and eval-
                                                      called ESSENCE, that enables combinatorial problems to be
uates these alternatives through analysis and/or experiment.
                                                      stated at a high level of abstraction. This level of abstrac-
The process by which the alternative models are generated is
                                                      tion is a consequence of three features: (1) The language sup-
rarely, if ever, discussed. Each constraint programmer must
                                                      ports a wide range of types (including sets, multisets, rela-
learn the art of modelling by forming generalisations from
                                                      tions, functions, partitions) and decision variables can be of
these studies.
                                                      these types. (2) All types can be nested to arbitrary depth; for
  We show that a set of rules can formalise the generation of example, a decision variable can be of type set, set of sets,
alternative models. Doing this requires a language in which to set of set of sets, and so forth. (3) Constraints can contain
express the abstract problem structure of which models are a quantiﬁers that range over decision variables. For example, if
function. If all modelling choices are to be open to the rules, a decision variable X is of type set of sets, a constraint can
the language must have a level of abstraction above that at
which modelling decisions are made. We have designed such 1Some ﬁnite-domain constraint solvers support variables whose
a language and call it ESSENCE.                       domain elements are ﬁnite sets of atomic elements. Though all as-
  The rules are embedded in the CONJURE system, which, pects of our work have considered this, for the sake of simplicity this
given an ESSENCE speciﬁcation, generates models of the type paper pretends such variables do not exist.be of the form ∀x ∈ X.φ. The ESSENCE language is out-  Given n, put n integer ticks on a ruler of size m such that all inter-tick distances
lined in Sec. 3, though only in enough detail to enable the are unique. Minimise m.
presentation of our second principal contribution.          given       n: int
  Our second major contribution is the formulation and au-  where       n ≥ 0
                                                            letting     bound be 2n
tomation of a set of rules that can reﬁne constraints on com- find      T icks: set (size n) of 0..bound
plex variables in an ESSENCE speciﬁcation into constraints  minimising  max(T icks)
on atomic variables, which is the level of abstraction pro- such that   ∀{i, j}⊆T icks.∀{k, l}⊆T icks.
                                                                          {i, j} 6= {k, l} → |i − j| 6= |k − l|
vided by existing constraint languages and toolkits. Our for-
mal rules are presented in Sec. 4.
  An attempt to formulate such a set of reﬁnement rules con- Figure 1: ESSENCE speciﬁcation of the Golomb Ruler prob-
fronts two primary difﬁculties and many secondary ones. Be- lem.
fore proceeding it is worth considering the primary ones.
  The ﬁrst difﬁculty arises because expressions, particularly the appropriate channelling constraints.
decision variables of non-atomic type, can usually, if not al- We conjecture that the good models of a problem can
ways, be reﬁned in multiple ways. Furthermore, the reﬁne- be generated automatically by formulating the problem in
ment of an operator depends on how its operands are reﬁned. ESSENCE and then reﬁning the speciﬁcation using rules of
For example, in reﬁning the constraint S1 = S2, where S1 the kind presented in this paper. We have implemented a
and S2 are atomic set variables, the treatment of equality is program, called CONJURE, that currently reﬁnes a subset of
different for every combination of ways that S1 and S2 can ESSENCE, called mini-ESSENCE. This gives us a platform
be reﬁned. Indeed, it is possible that an operator is inapplica- with which we have experimentally tested our conjecture, as
ble to certain reﬁnements of its operands.            reported in in Sec. 7.
  The second major difﬁculty arises from arbitrary nesting
of types. Reﬁning an operator that is applied to expressions 3 An Introduction to ESSENCE
whose types are nested provides the biggest challenge. Con-
sider reﬁning the constraint A = B, where A and B are de- This section brieﬂy introduces the abstract speciﬁca-
cision variables of some type τ that is nested arbitrarily deep. tion language ESSENCE. It is an evolving and grow-
The generated constraint must involve all components of both ing language; version 1.0 is used within this paper.
A and B. Since there is no bound on the nesting of τ, this A full speciﬁcation of the language can be found at
complex constraint would have to be generated through re- www.cs.york.ac.uk/aig/constraints/AutoModel/.
cursive rule applications, none of which can look arbitrarily Let us begin by considering the speciﬁcation of the
deep into the nesting of τ. Furthermore, we wish to produce Golomb Ruler Problem (GRP, problem 6 at www.csplib.org),
reﬁnements in which A and B do not have the same kind of shown in Fig. 1). A speciﬁcation is a list of state-
representation. An especially tricky case is when a quanti- ments, of which there are seven kinds, signalled by the
ﬁer ranges over a decision variable of a nested type, such as keywords given, where, letting, find, maximising,
∀x⊆A  φ, where A is as above.                         minimising  and such  that.  Statements are composed
  Modelling in constraints involves more than just represent- into speciﬁcations according to the regular expression
ing decision variables and problem constraints. Constraint (given | letting | where)∗ find+
models often contain many symmetries, often enormous      [minimising   | maximising]  (such  that)∗
numbers of them, which result in redundancies in the search Identiﬁers in CONJURE come in four categories: constant,
space. Expert modellers are able to identify such symmetries parameter, quantiﬁed variable, and decision variable. “Let-
and break them, either by introducing symmetry-breaking ting” statements declare constant symbols and give their val-
constraints or using a symmetry-aware search method. It has ues. “Given” statements declare the problem’s parameters;
been argued that detecting symmetries in a model is as hard the values of the parameters are provided to specify the in-
as graph isomorphism. We maintain that symmetries enter a stance of the problem class. Parameter values are not part of
model from two sources: either a symmetry is inherent to the the problem speciﬁcation; as in other modelling languages,
combinatorial problem or it is introduced by the modelling they are provided elsewhere. “Where” statements impose
process. An automated modelling system ought to identify restrictions on the parameter values; only parameter values
the symmetry that it introduces into a model. Sec. 5 explains meeting the restrictions specify a problem instance. “Find”
how this can be integrated into our architecture for model statements declare decision variables. A “minimising” or
generation.                                           “maximising” statement gives the objective function, if any.
  Another technique used by expert modellers is to repre- Finally, “such that” statements give the problem’s constraints.
sent a complex decision variable with multiple representa- The GRP speciﬁcation begins by declaring n to be a pa-
tions simultaneously and impose channelling constraints to rameter, restricting it to be non-negative and declaring bound
keep the representations consistent with each other [4; 8; to be a constant. Since n is used in the declaration of bound,
11]. This sometimes yields more propagation, and therefore the declaration of bound must come after the declaration of
reduced search, than a single representation. As will be seen, n. Every symbol must be deﬁned before it is used. This re-
the rules of CONJURE generate models with multiple repre- striction prevents cyclical deﬁnitions and means that decision
sentations. Sec. 6 explains how our reﬁnement rules can gen- variables cannot be used in the deﬁnitions of constants and
erate the information that is needed to automatically generate parameters.  The speciﬁcation language is strongly typed and every ex- A Sonet communication network comprises a number of rings, each joining a num-
                                                       ber of nodes. A node is installed on a ring using an ADM and there is a capacity
pression and subexpression has a type. The type of the deci- bound on the number of nodes that can be installed on a ring. Each node can be
sion variable T icks indicates that the goal of the problem is to installed on more than one ring. Communication can be routed between a pair of
ﬁnd a set containing n elements, each of which is an integer nodes only if both are installed on a common ring. Given the capacity bound and
                                                       a speciﬁcation of which pairs of nodes must communicate, allocate a set of nodes
in the range 0 to bound. The types supported by ESSENCE to each ring so that the given communication demands are met. The objective is to
include the atomic types int (integer), bool (Boolean) and minimise the number of ADMs used. (This is a common simpliﬁcation of the full
l..u (an integer range type), where l and u are integer expres- Sonet problem, as described in [8])
sions. ESSENCE also provides enumerated types and a new given    nrings:int, nnodes:int, capacity:int
and very useful atomic type: type (size α), a type of α where    nrings≥ 1, nnodes≥ 1, capacity≥ 1
                                                       letting   Nodes be 1..nnodes
unnamed elements.                                      given     demand:set (size m) of set (size 2) of Nodes
  ESSENCE  is the ﬁrst constraint language to support fully- find rings: mset (size nrings) of set (maxsize capacity) of Nodes
                                                       minimising       |r|
compositional type constructors. So, for example, a decision     Pr∈rings
variable may be of type integer, set of integer, set of set of such that ∀pair ∈ demand. ∃r ∈ rings . pair ⊆ r
integer, and so forth. If τ is a type, α is an integer expres-
        I , . . . , I
sion, and 1     n are expressions of type range then the Figure 2: ESSENCE speciﬁcation of the Sonet problem.
following are types that appear in this paper:
   set (size α) of τ, set (maxsize α) of τ two kinds of set
   mset (size α) of τ, mset(maxsize α) of τ two kinds of multiset a short step to an established constraint language, such as
   matrix [indexed by I1, . . . , In] of τ matrix     OPL, Solver, or Eclipse. To perform this step, we are de-
Also among the types of ESSENCE are relations between any veloping a suite of back-end translators. In future, we also
two types, partial and total functions from any type to any intend to translate to more restricted languages, such as SAT
type, partitions of a set of any type and permutations of any and Pseudo-Boolean formulations.
type.
  Constraints in this speciﬁcation language are built from 4 The Architecture of CONJURE
the parameters, constants and decision variables using opera-
tors commonly found in mathematics and in other constraint This section discusses the reﬁnement rules CONJURE uses to
speciﬁcation languages. The language also includes variable reﬁne an ESSENCE expression into a set of ESSENCE0 ex-
                                                      pressions. For concision we give only a small subset of all
binders such as ∀x, ∃x and Px, where x can range over any
speciﬁed ﬁnite type (e.g., integer range but not integer). The the reﬁnement rules2; the remainder follow a similar pattern.
constraint in the GRP can be paraphrased as “For any un-
ordered pair {i, j} of ticks and any unordered pair {k, l} of Reﬁning a Simple ESSENCE Speciﬁcation
ticks, if the two pairs are different then the distance between Reﬁnement of an ESSENCE speciﬁcation begins by reﬁning
i and j is not the same as the distance between k and l.” To each constraint and the objective function in turn. Let us be-
clarify the notation, the expression {i, j} ⊆ T icks means that gin by considering the single-constraint MicroSonet1 speci-
two distinct elements are drawn from T icks and, without loss ﬁcation (Fig. 3), where the goal is to ﬁll two rings with the
of generality, one is called i and the other is called j. same nodes.
  Now consider the speciﬁcation of the Sonet problem shown A key consideration in reﬁning MicroSonet1 is the repre-
in Fig. 2. Notice that Nodes is declared to be a range. A subtle sentation of each ring, each of which is a ﬁxed-size set. This
point is that the third line of the speciﬁcation is declaring two paper uses two representations of ﬁxed-size sets. The explicit
parameters. When the demand parameter is instantiated to a representation is a one-dimensional matrix of Nodes indexed
particular set of sets, the size of the outer set will be known. by 1..capacity. Each element of the matrix corresponds to an
Hence, the value of m is given indirectly. This declaration element of the set. To represent the set properly, the elements
also requires the inner sets to have cardinality two. The goal of the matrix are constrained to take distinct values. The oc-
is to ﬁnd a multiset (representing the rings), each element of currence representation is a one-dimensional Boolean matrix
which is a set of Nodes (representing the nodes on that ring). indexed by Nodes, where a true entry indicates that the corre-
The objective is to minimise the sum of the number of nodes sponding node is in the set. To represent the set properly, the
installed on each ring. The constraint ensures that any pair number of true entries must be equal to capacity (for count-
of nodes that must communicate are installed on a common ing we treat true/false as 1/0). Fig. 3 gives ESSENCE0 mod-
ring.                                                 els using both representations. Note that some symbols of
                                                      ESSENCE, such as “∀” and “Σ”, can also be written textually,
                             0
The Target Language: ESSENCE                          such as “forall” and “sum”. In writing ESSENCE0 we use the
ESSENCE  speciﬁcations are reﬁned into a target language textual version.
called ESSENCE0, which is a subset of ESSENCE with a level The reﬁnement operator, ρ, is a function that maps ev-
of abstraction similar to that of existing constraint languages, ery ESSENCE expression to a set of ESSENCE0 expressions.
OPL [19] being the closest. The only types ESSENCE0 has As explained later, each of these ESSENCE0 expressions is
are integers, integer ranges, Booleans and matrices; it does tagged with further information necessary to construct the
not have enumerated types or types of unnamed elements.
Binders, such as quantiﬁers and summations, range only over 2See http://www.cs.york.ac.uk/aig/constraints/AutoModel/ for
integer ranges. From this generic constraint language, it is the complete set.         given      nnodes : int, capacity: int       decision variables (since ring1 is a decision variable).
         where      nnodes ≥ 1, capacity ≥ 1                         genSymbol
         letting    Nodes be 1..nnodes                  Deﬁnitions via          and type information (except
         find       ring1 : set (size capacity) of Nodes for the input expression) are given on the right of the long
                    ring2 : set (size capacity) of Nodes vertical bar. The bar itself has no meaning beyond separating
         such that  ring1 = ring2                     the details of the rule from the types and deﬁnitions.
 given    nnodes: int, capacity: int                    Since SIZEDSETEQUALITY1   chooses to represent both
 where    nnodes ≥ 1, capacity ≥ 1                    sets explicitly, the expression e “ i jS0 i S0 j
 letting  Nodes be 1..nnodes                                                      =  (∀ ∃  1[ ] = 2[ ]) ∧
            0
 find     ring1 : matrix [indexed by 1.. capacity] of Nodes (n1 = n2)” is used to constrain the two explicit matrices to
            0
          ring2 : matrix [indexed by 1.. capacity] of Nodes
                                       0      0       represent the same set (note the introduction of the quantiﬁed
 such that forall (i : 1..capacity) exists (j : 1..capacity) ring1[i] = ring2[j]
                    0                                 variables denoted by i and j). Since, in general, it may be
          AllDifferent(ring1)
                    0                                                                  0
          AllDifferent(ring2)                         the case that e is not yet in ESSENCE , it is reﬁned further
                                                      and the result, denoted by φ, is returned. In this example,
     given     nnodes: int, capacity: int                           0        0
     where     nnodes , capacity                      e = “∀i ∃j ring1[i] = ring2[j] ∧ (capacity = capacity)”
                    ≥ 1     ≥ 1                                    0
     letting   Nodes be 1..nnodes                     is in ESSENCE , so ρ(e) = e. For brevity, the model shown
                  0
     find      ring1 : matrix [indexed by Nodes] of bool
                  0                                   in Fig. 3 omits capacity = capacity; a simpliﬁer could eas-
               ring2 : matrix [indexed by Nodes] of bool
                            0     0                   ily remove it. This convention is followed in all subsequent
     such that forall (i : Nodes) ring1[i]= ring2[i]
                           0
               sum (i : Nodes) ring1[i]= capacity     models generated by SIZEDSETEQUALITY1.
                           0
               sum (i : Nodes) ring2[i]= capacity       Recall that the explicit representation of a set(size n)
                                                      of τ is a matrix of n distinct elements, each of type τ. Thus,
Figure 3: ESSENCE speciﬁcation and two ESSENCE0 models when a rule generates this explicit representation, it must in-
of the MicroSonet1 problem.                           troduce into the generated model a constraint that the ele-
                                                      ments of the matrix are all different. In particular, the SIZED-
                                                      SETEQUALITY1   rule must introduce two such constraints:
                                                                  0                  0
ﬁnal model. ρ is deﬁned inductively by a set of uniquely- AllDifferent(S1) and AllDifferent(S2). And, since the ele-
                                   0   0         0              0      0
named equations of the form R ρ(e) = e1 ∪ e2 ∪ · · · ∪ en, ments of S1 and S2 have not been reﬁned, ρ must be ap-
where R is the name of the equation, e is an ESSENCE expres- plied to these two constraints, resulting in the ESSENCE0 con-
             0                  0
sion and each ei is a set of ESSENCE expressions, usually straints named χ and ψ in the rule.
given via set comprehension. For perspicuity, each equation Consider where χ and ψ should occur in the generated
                             ref 0        ref 0       model. From the ESSENCE0 model of Fig. 3 it might appear
is split into rules, written: R1 ρ(e) → e1, R2 ρ(e) → e2, . . .,
       ref 0                                          that χ and ψ should be conjoined to φ, returning φ ∧ χ ∧ ψ.
Rn ρ(e) → en.                                         To see that this is incorrect, observe that this treatment would
  The SIZEDSETEQUALITY   equation is responsible for re-
                                                      reﬁne ¬(ring1 = ring2) to ¬(φ ∧ χ ∧ ψ), whereas the de-
ﬁning expressions of the form S1 = S2, where both S1 and sired reﬁnement is (¬φ) ∧ χ ∧ ψ. The correct reﬁnement is
S2 are expressions of type ﬁxed-size set. Fig. 4 gives two obtained by returning φ as the reﬁnement, tagging the reﬁne-
rules of this equation. The complete version of SIZEDSETE- ment with χ ∧ ψ, and once the ESSENCE0 model is generated,
QUALITY gives one rule for for each combination of a repre- adding χ ∧ ψ to its constraints. Since, in this case, the tag is
sentation of S1 and a representation of S2 and a constraint for a constraint, it is labelled by such that.
imposing equality between the them.                     When  a rule builds a reﬁnement R, a part P of which
  To illustrate the operation of a rule, we now discuss has been generated from a recursive call to ρ, the tags of
how the SIZEDSETEQUALITY1   rule reﬁnes ring1 = ring2. P are, by default, added to the tags of R. Hence, in
SIZEDSETEQUALITY1   reﬁnes S1 and S2 into explicit one- SIZEDSETEQUALITY1, the tags attached to a reﬁnement of
                              0      0
dimensional matrices denoted by S1 and S2. The SIZED- φ, χ and ψ are implicitly added to the such that tag explic-
SETEQUALITY2   rule proceeds similarly. The reader may itly given in the rule. As will be seen later, this default can be
wonder at the strategy of reﬁning the arguments of the equal- overridden.
ity constraint inside the equality rule itself. This is explained Space precludes giving the full derivation of the explicit
in the next sub-section.                              ESSENCE0  model (Fig. 3). The reﬁnements triggered via
  When  a rule needs to introduce a new identiﬁer, such SIZEDSETEQUALITY1 in the example are, however, straight-
                   0
as that denoted by S1, it does so by making use of the forward. Universal quantiﬁcation over a ﬁnite range of inte-
genSymbol  function. This function takes two arguments. gers is in ESSENCE0 and can be viewed as a conjunction or
The ﬁrst is either an explicit category (see Sec. 3), or an simple ‘for’ loop. Similarly, existential quantiﬁcation over a
identiﬁer from which the category information is copied. ﬁnite range of integers can be treated as disjunction. Hence,
The second is the type of the new identiﬁer, such as a the ﬁrst constraint in the explicit ESSENCE0 model comes di-
one-dimensional matrix used for the explicit representation. rectly from SIZEDSETEQUALITY1. The occurrence model
The genSymbol  function creates a new identiﬁer of the follows similarly.
required category and type that appears nowhere else in After reﬁning the constraints and the objective function of
the ESSENCE0 model being constructed. When, for ex-   an ESSENCE  speciﬁcation, the given find and letting
                                              0
ample, reﬁning ring1 with SIZEDSETEQUALITY1, S1  =    statements are generated. This is done by scanning the set
genSymbol(ring1, matrix [indexed by Nodes] of 1..n),  of constraints and adding an appropriate deﬁnition for each
        0
and so S1 will denote a unique identiﬁer for a matrix of unique identiﬁer. where statements are reﬁned in the same                                                  ref
 SizedSetEquality1 ρ(S1 : set (size n1) of τ = S2 : set (size n2) of τ) →
                                        0
  {   φ                               S1 = genSymbol(S1, matrix [indexed by 1..n1] of τ)
                                        0
      such that χ ∧ ψ                 S2 = genSymbol(S2, matrix [indexed by 1..n2] of τ)
      |                               i = genSymbol(“Quantiﬁed variable”, 1..n1)
               0     0
      φ ∈ ρ((∀i∃jS1[i] = S2[j]) ∧ (n1 = n2)) j = genSymbol(“Quantiﬁed variable”, 1..n2)
                   0
      χ ∈ ρ(AllDifferent(S1))
                   0
      ψ ∈ ρ(AllDifferent(S2))     }
                                                  ref
 SizedSetEquality2 ρ(S1 : set (size n1) of τ = S2 : set (size n2) of τ) →
  {   φ                              τ is [a..b] or bool
                                      0
      such that χ ∧ ψ                S1 = genSymbol(S1, matrix [indexed by τ] of bool)
                                      0
      |                              S2 = genSymbol(S2, matrix [indexed by τ] of bool)
             0     0
      φ ∈ ρ((∀iS1[i] = S2[i]) ∧ (n1 = n2)) i = genSymbol(“Quantiﬁed variable”, τ)
             0
      χ ∈ ρ(ΣiS1[i] = n1)
             0
      ψ ∈ ρ(ΣiS2[i] = n2)       }
                         ref
 ForallRange1 ρ(∀i : n1..n2 φ : bool) →
                  0
  {   forall (i : n1..n2) φ
      such that forall (i : n1..n2) Γ
      |
      (φ0 with such that Γ) ∈ ρ(φ) }
                                       ref
 ForallSizedSet1 ρ(∀i : τ ∈ S : set (size n) of τ.φ : bool) →
  {   forall (j : 1..n) φ0               j = genSymbol(i, 1..n)
      such that χ∧ forall (j : 1..n) Γ   S0 = genSymbol(S, matrix [indexed by 1..n] of τ)
      |
      (φ0 with such that Γ) ∈ ρ(φ[i 7→ S0[j]])
      χ ∈ ρ(AllDifferent(S0))        }
                                               ref
 SizedSubset1 ρ(S1 : set (size n1) of τ ⊆ S2 : set (size n2) of τ) →
  {   φ                    τ is [a..b] or bool
                            0
      such that χ ∧ ψ      S1 = genSymbol(S1, matrix [indexed by 1..n1] of τ)
                            0
      |                    S2 = genSymbol(S2, matrix [indexed by τ] of bool)
             0  0
      φ ∈ ρ(∀i.S2[S1[i]])  i = genSymbol(“Quantiﬁed variable”, 1..n 1)
             0
      χ ∈ ρ(Σj S2[j] = n2) j = genSymbol(“Quantiﬁed variable”, τ)
                   0
      ψ ∈ ρ(AllDifferent(S1)) }

                                     Figure 4: Example Reﬁnement rules.

way that constraints are.                             two such  that tags, both of which impose that all the el-
                                                      ements of a matrix of sets must be different. Since these el-
Reﬁning Nested Types: A Simple Example                ements may be of a non-atomic type, this AllDifferent con-
To see how expressions of a nested type are reﬁned, con- straint must be reﬁned. For space reasons the deﬁnition of
sider the Microsonet2 speciﬁcation (Fig. 5), where the goal the ALLDIFFERENT reﬁnement rules are omitted.
is to generate two identical sets of rings. The key decision
                                                        The main constraint generated by SIZEDSETEQUALITY1
is the representation of rings and rings , two sets of sets.
                         1        2                   is ρ(∀i∃jrings0 [i] = rings0 [j]). The FORALLRANGE equa-
Reﬁnement begins with ρ(rings = rings ), requiring SIZED-         1         2
                          1      2                    tion is now applicable (Fig. 4 gives FORALLRANGE1). This
SETEQUALITY.   Of the rules given in Fig. 4, only SIZED-
                                                      rule works by reﬁning φ, which contains the free variable i.
SETEQUALITY1   is applicable, since “set (size capacity)
                                                      Each resulting reﬁnement φ0 and its tag Γ, both of which con-
of Nodes” is neither a range of integers nor Boolean: in-
                                                      tain the free variable i, are wrapped in “forall i : n ..n .”
dexing a matrix by a complex type (here each index would                                           1   2
                                                      Reﬁnement continues with ρ(∃j rings0 [i] = rings0 [j]). EX-
correspond to one of the possible sets of Nodes) would often                          1         2
                                                      ISTSRANGE  operates in the same way as FORALLRANGE,
lead to unfeasibly large matrices. Future work will consider
                                                      so we omit the details.
relaxing this condition in certain cases.
                                                                          0          0
  The justiﬁcation for reﬁning the arguments of the equal- We now have ρ(rings1[i] = rings2[j]), for which SIZED-
ity constraint inside the equality rule itself becomes clear in SETEQUALITY is used. Both rules are applicable, since
                                                          0           0
the context of nested types. A seemingly more-natural ap- rings1[i] and rings2[i] are sets of Nodes. The reﬁnement
                                                      in Fig. 5 uses SIZEDSETEQUALITY2 to generate an occur-
proach to reﬁning S1 = S2 would be to reﬁne S1 and S2 and
constrain the results to be equal. However, given unbounded rence representation of the inner sets. The rule operates as
nesting of types and multiple possible reﬁnements of each described earlier, but we highlight how genSymbol treats in-
type, constraining the results to be equal is not straightfor- dexed matrices. genSymbol respects the index structure of
                                                      its ﬁrst argument. Hence, given the indexed one-dimensional
ward. Consider the case where S1 and S2 are not sets of inte-
                                                      array rings0 i , genSymbol rings0 i , matrix... creates a
gers, but sets of sets of . . . sets of integers. Having reﬁned S1 1[ ]       (    1[ ]        )
                                                      two-dimensional Boolean matrix, rings00 (see Fig.5), and re-
and S2 there is no ﬁxed constraint on their reﬁnements that                            1
                                                      turns the partially-indexed rings00[i], which is the reﬁned ver-
enforces equality on S1 and S2. Instead of this approach, our
rules are designed to “peel off” a layer of nesting so that the sion of an element of the set of sets.
associated constraint/operator can be formed without looking The remaining reﬁnements are straightforward. Note that
                                                          0      0
arbitrarily deep inside a reﬁned expression.          rings1, rings2 are not in the model. These are intermediate
  Performing SIZEDSETEQUALITY1   requires reﬁning the representations which, although more concrete than rings1