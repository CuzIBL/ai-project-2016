            The Complexity of Quantiﬁed Constraint Satisfaction Problems
                                under Structural Restrictions          ∗
                 Georg Gottlob                Gianluigi Greco          Francesco Scarcello
          Inst. fur¨ Informationssysteme     Dip. di Matematica                DEIS
           Technische Universitat¨ Wien   Universita` della Calabria  Universita` della Calabria
             A-1040 Vienna, Austria         I-87030 Rende, Italy        I-87030 Rende, Italy
            gottlob@dbai.tuwien.ac.at       ggreco@mat.unical.it      scarcello@deis.unical.it

                    Abstract                          network I may be represented by the conjunction of all its
                                                      constraint atoms. For simplicity, we limit our attention here
    We give a clear picture of the tractability/intracta- to closed quantiﬁed constraint formulas, where all variables
    bility frontier for quantiﬁed constraint satisfaction occurring in I are quantiﬁed. However, all our results may be
    problems (QCSPs) under structural restrictions. On easily extended to formulas with free variables.
    the negative side, we prove that checking QCSP      As  an  example,  consider the following quantiﬁed
    satisﬁability remains PSPACE-hard for all known
                                                      constraint formula φe: ∀S, X, Y, T, R, U, P ∃V,Z ∀W
    structural properties more general than bounded   a(S, X, T, R) ∧ b(S, Y, U, P ) ∧ c(T,U,Z) ∧ d(W, X, Z) ∧
    treewidth and for the incomparable hypergraph     e(Y,Z)  ∧ f(R, P, V ) ∧ g(X, Y ). This formula is a QCSP
    acyclicity. Moreover, if the domain is not ﬁxed, the
                                                      instance, whose constraint network CN (φe) is represented by
    problem is PSPACE-hard even for tree-shaped con-  the constraint atoms occurring in the conjunction. The quan-
    straint scopes. On the positive side, we identify rel-
                                                      tiﬁer preﬁx (short: preﬁx) of φe is the string ∀∃∀.
    evant tractable classes, including QCSPs with pre-
                                                        Not surprisingly, the increased expressive power of QCSPs
    ﬁx ∃∀ having bounded hypertree width, and QCSPs
                                                      comes at a cost. Indeed, while deciding the satisﬁability of
    with a bounded number of guards. The latter are
                                                      traditional (i.e., purely existential) CSPs is NP-complete, this
    solvable in polynomial time without any bound on
                                                      problem is PSPACE-complete [Borner et al., 2003], in the
    domains or quantiﬁer alternations.
                                                      general quantiﬁed setting. Hence, much effort has been spent
                                                      to identify tractable classes of QCSPs.
1  Introduction                                         These approaches can be divided into two main groups:
                                                      techniques that identify tractable classes of QCSPs by ex-
Quantiﬁed constraint satisfaction problems (QCSPs) are a ploiting particular properties of constraint relations, and tech-
generalization of constraint satisfaction problems (CSPs), niques that identify tractable classes by exploiting the struc-
where variables may be existentially and universally quanti- ture of constraint scopes, usually known as structural de-
ﬁed, and nested quantiﬁcations are allowed. This framework composition methods. While several deep results have been
is clearly much more expressive than plain existential-CSP, already achieved by techniques in the former group (see,
and may be fruitfully exploited for modeling a wide spectrum e.g., [Borner et al., 2003; Bulatov et al., 2000; Bunind et
of problems from several domains.                     al., 1995; Chen, 2004a; Creignou et al., 2001; Jeavons et
  A QCSP  instance (or quantiﬁed constraint formula) φ is al., 1997]), only a few papers focused on structural de-
an expression of the form Q1V¯1 ···QmV¯m I, where I is a
                          CN                          composition methods, though they were proven to be use-
constraint network (denoted by (φ)), Qi is a quantiﬁer in                                  [
{∃ ∀}                     ¯                          ful in the non-quantiﬁed setting (see, e.g., Dechter, 2003;
  ,   (with Qi = Qi+1), and Vi is a set of variables, for Gottlob et al., 2000]).
1 ≤ i ≤  m. The string of quantiﬁers Q ···Qm is called
                                   1                    Recall that the structure of constraint network I is best rep-
the preﬁx of φ. Recall that a constraint network is a triple
                                                      resented by its associated hypergraph H(I)=(V,H), where
I =(Var , U¯, C), where Var is a ﬁnite set of variables, U is
                                                      V =  Var and H = {var(S) | C =(S, r) ∈C}, and var(S)
the set of domains U(V ), for each variable V ∈ Var , and
                                                      denotes the set of variables in the scope S of constraint C.
C = {C  ,C ,...,Cq} is a ﬁnite set of constraints. A con-
       1  2                                           Some graph-based techniques are based on the primal graph
straint Ci =(Si,ri) consists of a list of variables Si called
                                                      G(H(I)) =   (V,E) of H(I), where two variables are con-
constraint scope, and of a relation ri, called constraint rela-
                                                      nected in E if they occur together in some hyperedge (i.e., in
tion, providing Ci’s allowed combinations of values for the
                                                      the scope of some constraint).
variables in its scope. Sometimes it is more comfortable to
                                                        Chen recently presented an interesting result about struc-
denote Ci by its so called constraint atom ri(Si). Then, the
                                                      turally tractable QCSPs [Chen, 2004b]. He describes a
  ∗This work was supported by the Austrian Science Fund (FWF) polynomial-time algorithm for classes of QCSPs having (pri-
project: Nr. P17222-N04 Complementary Approaches to Constraint mal graphs with) bounded treewidth, ﬁxed domain, and ﬁxed
Satisfaction.                                         preﬁx. In fact, the complexity of this algorithm depends                                                              
dramatically on the number of quantiﬁer alternations and on   
the size of the largest variable domain. As noted in [Chen,   
                                                              
2004b], the same result has been independently derived by     
                                                              
[Feder and Kolaitis, 2004], by exploiting Courcelle’s theo-   
                                                              
rem about monadic second order logic on bounded treewidth     
                                                              
structures.                                                   
  Notice that there is no indication that these results are op- 
                                                              
timal, and in fact several interesting questions arose, and will 
                                                              
be the subject of this paper:                                 
                                                              
  (1) Are QCSPs having bounded treewidth tractable if do-     
                                                              
mains are not ﬁxed?                                           
  (2) May we extend this result to other structural notions,  
                                                              
possibly more general than bounded treewidth?                 
                                                              
  (3) Are there different kind of restrictions on quantiﬁed  
                                                             
constraint formulas that make QCSPs tractable?                
  The answers to these questions comprise both good news
                                                        Figure 1: Structural restrictions and (in)tractable QCSPs.
and bad news. We prove strong hardness results, but we also
identify new tractable classes of QCSPs, having neither ﬁxed if for each constraint (Si,ri) ∈C, σ(Si) ∈ ri. An extension
                                                                  ¯    ¯                    ¯ 
bound on domains nor ﬁxed bound on quantiﬁer alternations. of σ to a set V ⊃ V is an assignment σ for V such that
                                                                              ¯                   ¯ 
Our main contributions, shown in Figure 1, are the following: σ (V )=σ(V ) for each V ∈ V . We denote by ext(σ, V ) the
                                                      set of all the extensions of σ to V¯ . For the trivial assignment
  We prove that, without the ﬁxed domain restriction, even                                 
                                                      σ∅ for the empty set of variables, ext(σ∅, V¯ ) is clearly the
 QCSP instances whose structure is a tree and whose preﬁx                    
   ∀∃                                                 set of all assignments for V¯ .
 is   are co-NP-hard. Moreover, adding further alternations      ¯    ¯    ¯       ¯
 we get complete problems for all levels of the polynomial Let φ : Q1V1Q2V2Q3V3 ...QmVm I be a QCSP instance,
                                                      and let σ0 be the trivial assignment σ∅.Astrategy for φ is
 hierarchy. It follows that this problem is PSPACE-complete                                         ≤  ≤
 if there are no bounds on the quantiﬁer preﬁx.       any function s such that, for each pair Qi,σi−1, with 1 i
                                                      m, s(Qi,σi− ) is either one assignment in ext(σi− , V¯i),if
  On the positive side, we prove that, if the preﬁx is ∃∀ (or   1                                1
                                                      Qi = ∃, or the whole set of possible extensions ext(σi− , V¯i),
 some substring of it), then solving acyclic QCSPs is fea-                                          1
                                                      if Qi = ∀. A complete assignment σm is derivable from a
 sible in LOGCFL and hence in polynomial time. More-
                                                      strategy s if there are m − 1 assignments σ ,...,σm− such
 over, this tractability extends to all known generalizations                             1        1
                                                      that σi ∈ s(Qi,σi− ), for any 1 ≤ i ≤ m. Then, s is a
 of acyclicity, and in particular to bounded hypertree-width           1
                                                      solution for φ if all derivable assignments satisfy I. A QCSP
 QCSPs  [Gottlob et al., 2000].
                                                      instance is satisﬁable iff it has a solution.
  We prove that, for ﬁxed domains, the tractability result
                                                        It is worthwhile noting that, in the deﬁnition of QCSPs,
 for bounded treewidth is almost optimal. Indeed, solving
                                                      different variables have different domains, in general. This is
 QCSPs over the binary domain {0, 1} remains PSPACE-
                                                      especially useful in the quantiﬁed setting. However, in the
 complete even if the structure is an acyclic hypergraph,
                                                      literature, QCSPs are sometimes deﬁned over a unique do-
 whose incidence graph has bounded treewidth, and whose
                                                      main U or, equivalently, with the same domain U(V ) for each
 primal graph has small (i.e., logarithmic) treewidth.
                                                     variable V . We say that such QCSPs are untyped, in contrast
   All these results show that traditional structural techniques to the general ones, called typed. The following proposition
 do not help very much, but for some simple cases and with shows that the two formalisms are in fact logically equivalent.
 limited quantiﬁcation. Indeed, our hardness proofs show
 that the presence of quantiﬁers radically alters the structural Proposition 2.1 For any QCSP instance φ, there exists an
                                                      untyped equivalent instance φ. Moreover, if CN (φ) is a bi-
 properties of the constraint scopes. We thus realize that it is   
 worthwhile taking into account how they interact with the nary network, φ can be computed in polynomial time.
 scope structure, and in fact considering quantiﬁers as part Notice that going from typed to untyped instances may be
 of the scope structure itself. Following this idea, we iden- exponential for non-binary networks, as the former setting
 tify a different kind of restriction on quantiﬁed constraint allows more succinct and efﬁcient representations.
 formulas that ensure tractability and that is incomparable We remark that all complexity results in this paper hold
 with the other structural classes. In particular, for any ﬁxed for both settings. Indeed, we prove membership results and
 k, we deﬁne the class k-GQCSP of k-guarded QCSPs, that provide algorithms for the general typed setting, and prove
 are solvable in polynomial time, without any restriction on hardness results by using either binary networks, or a unique
 domains or quantiﬁer alternations.                   binary domain for all variables.
                                                        We say that a class S of hypergraphs has the bounded hy-
2  Quantiﬁed CSPs                                     pertree width property, denoted by BHTW, if there is a k>0
Let I =(Var , U, C) be a constraint network. An assignment such that every hypergraph in S has hypertree width at most
σ for a set of variables V¯ ⊆ Var is a function mapping each k [Gottlob et al., 2000]. Similarly, we deﬁne the property
variable V ∈ V¯ onto its domain U(V ) ∈U.IfV¯ = Var , σ BTW, meaning bounded treewidth [Robertson and Seymous,
is said complete, otherwise it is a partial assignment. We say 1986] of the primal graph (of the constraint hypergraph), and
that a complete assignment σ satisﬁes I, denoted by σ |= I, the property BITW, meaning bounded treewidth of the inci-dence graph. Moreover, we say that a class S of hypergraphs
has the small hypertree width property, denoted by SHTW,if
the hypertree width of every hypergraph H∈S is at most
log |H|. The small treewidth property STW of primal graphs
is deﬁned similarly. We also consider the property ACYCLIC
(resp., TREES) of any class of acyclic hypergraphs (resp., pri-
mal graphs).
  We study how the complexity of QCSPs change as a func-
tion of quantiﬁer alternations and of constraint structures.
Moreover, we distinguish the case of arbitrary domains, de-
noted by ANY, and of binary domains, denoted by {0, 1}.
  Let Q¯ be a string of quantiﬁer alternations, S a hyper-
graphs property, and D a domain property in {ANY, {0, 1}}.
Then, QCSP(Q,¯ S, D) is the problem of deciding whether
an instance φ  ∈  class(Q,¯ S, D) is satisﬁable, where
class(Q,¯ S, D) is any class of QCSP instances over domains
of kind D, with alternation preﬁx Q¯, and whose associated
                                                      Figure 2: Constraint network I(Φ)¯ in Theorem 3.4. In the
hypergraphs have property S.
                                                      right-bottom box, encodings of constraints in Theorem 3.7.
3  Structural methods do not help very much             Consider the following CNF formula, that we use as a run-
3.1  Some tractable instances                         ning example: Φ=(¯ V1 ∨ V2 ∨ V3) ∧ (V1 ∨¬V4) ∧ (V1 ∨ V6 ∨
                                                          ∧    ∨
From  [Gottlob et al., 2000], we already know  that   V4)   (V2  V6). Then, Figure 2 shows the constraint struc-
QCSP(∃, BHTW, ANY) is in polynomial time, and the same ture (i.e. the constraint hypergraph) of I(Φ)¯ . Note that in this
holds for any structural restriction stronger than bounded case hypergraph and primal graph representations coincide,
hypertree-width.  Moreover, it is easy  to see that   as CN (Φ)¯ contains only binary constraints.
QCSP(∀, BHTW, ANY) is even easier. We next show that also The set of variables Var is the union of a set of clause
QCSP(∃∀, BHTW, ANY) is tractable.                     variables C¯ = {Cj | 1 ≤ j ≤ m} corresponding to the m
  Let φ be a QCSP instance, I =(Var , U, C) the constraint clauses of Φ, of a set B¯ = {Bi | Vi ∈ V¯ }, corresponding
network of φ, and Y¯ be a set of universally quantiﬁed vari- to the n Boolean variables occurring in Φ, and of two sets
                                                       c     c                     v      v
ables. Let r(X,¯ Y¯ ) a constraint of I over variable sets X¯ S¯ = {Sj , | 1 ≤ j ≤ m − 1} and S¯ = {Si , | 1 ≤ i ≤ n −
             
and Y¯ , where Y¯ is the set of Y¯ variables occurring in the 1} of special variables, called clause selectors and variable
                          
scope of r. Denote by cart(Y¯ ) the relation containing all selectors, respectively.
                                                ¯ 
combination of values from the domains of variables in Y , For a variable Vi of Φ, the domain of I(Φ) contains literal
   cart ¯    ×
i.e.,  (Y )=   Y ∈Y¯  U(Y ).                         constants vi and ¬vi associated with its truth-values. More-
              ¯
  Then, deﬁne Y-red (r) as the relation containing all and over, for any clause cj in which Vi occurs, the domain of I(Φ)
only those tuples t of relation r such that, for any combi-                       j   j
                                                   contains a literal constant in {vi , ¬vi } encoding the truth
nation t of values for variables Y¯ , t[X¯] · t ∈ r. Note that,                                        j
for the special case Y¯  = ∅, we get Y¯-red (r)=r; for the value for Vi that makes cj true. We denote by li (resp., li )
                                                     any of these (positive or negative) literals, and by ¬li (resp.,
special case X¯ = ∅, we simply require all combinations of j
                                                    ¬                                      satLit
values for Y¯ , that is, Y¯-red (r)=r,ifr is precisely cart(Y¯ ), li ) its complement. Moreover, we denote by (cj) the
                                                                                                ∨¬
otherwise it is the empty relation.                   set of literals that make cj true. E.g., for c2 =(V1 V4) in
                                                      ¯  satLit     { 2 ¬  2}
  Denote by Y¯-red (φ) the QCSP obtained from φ by replac- Φ, (c2)=  v1,  v4 .
ing each constraint relation r by Y¯-red (r).           In more detail, the domains of I(Φ) variables are the fol-
Lemma 3.1  For any QCSP φ and set of universally quanti- lowing: for any variable Cj (corresponding to clause cj of
                                                                    satLit
ﬁed variables Y¯ , Y¯-red (φ) can be computed in logspace. Φ), U(Cj)=     (cj); for any Boolean variable Bi,
                                                               {   ¬  }                       c     c
                                                      U(Bi)=    vi, vi ; for any clause-selector Sj , U(Sj )=
  After the above lemma and exploiting the fact that no use-                                   v     v
                                                           U(Cj ); ﬁnally, for any variable-selector S , U(S )=
ful assignment is lost with this transformation, we can show j ≥j                             i     i
the following.                                          i≥i U(Bi ).
Theorem 3.2 QCSP(∃∀,  BHTW, ANY) is in polynomial time. Intuitively, Boolean variables encode a truth-value assign-
                                                      ment to Φ, whereas any clause variable Cj chooses some
Moreover, it is LOGCFL-complete, and hence tractable and      satLit
parallelizable.                                       literal in    (cj) that satisﬁes it. Any selector variable
                                                      may take a value coming from either variable connected to it.
3.2  Encoding Boolean formulas as acyclic QCSPs       Thus, any choice of all variable selectors corresponds to the
                                                      propagation of a literal value li coming from some Boolean
To any CNF formula Φ=c1∧...∧cm  over Boolean variables
                                                      variable Bi in the left branch. Similarly, any choice of clause
V¯ = {V1,...,Vn},weassociate a binary acyclic constraint
               Var  U C                               selectors corresponds to the propagation in the right branch
network I(Φ) = (   , ,  ) . This constraint network will           j
be used hereafter for characterizing the complexity of acyclic of some literal lk satisfying some clause cj. If for all possible
                                                                                              j
and quasi-acyclic quantiﬁed CSPs.                     propagations from both branches, no pair li, ¬li of comple-mentary literals meets at the topmost constraint of the net- Proof. For space limitations we only prove Hardness for
work, then the values of Boolean variables encode a satisfy-                 ≥                P
                                                      Point 2, here. For any m 1, consider the Σ2m-complete
ing truth-value assignment for Φ. We next describe the con- problem of deciding whether a quantiﬁed Boolean formula
straints in C that implement the above idea, where the indices 
                                                      Ψ  = ∃V  ∀V ···∀V m¬Φ  is satisﬁable, where Φ is in CNF.
i and i actually are values in the interval [1 ...n] and where 1 2    2
                                                     From this formula, we build in polynomial time the follow-
the indices j, j are values in [1 ...m].              ing instance of QCSP((∃∀)m∃, TREES, ANY): QC(Ψ)=
• The topmost constraint (Sv,Sc), called evaluate, has
                         1   1                        ∃B1∀B2  ···∀B2m, C¯ ∃SI¯ (Φ). From Lemma 3.3, it can be
                                       j      j                                         
 a constraint relation consisting of {(li, ¬li ) | li ∈ seen easily that Ψ is satisﬁable iff QC(Ψ ) is satisﬁable.
 satLit(cj)}. Note that evaluate is satisﬁed only by assign- Membership. The proof is by induction. First observe that,
 ments where its variables take complementary literals. given any instance Q = ∃V¯1∀V¯2φ of QCSP(∃∀, BHTW, ANY),
                   v                             v                             c
• For any constraint (Si ,Bi) between a variable-selector Si its complementary problem Q (deciding whether for all as-
 and a Boolean variable Bi, its constraint relation consists of signment σ to V¯1 there exists an extension to V¯2 that does
                              
 the tuples: {(li,li)}∪{(li ,li) | i >i}.            not satisfy φ) is in LOGCFL and hence in polynomial time,
• For any constraint between a pair of adjacent variable- by Theorem 3.2 and the fact that LOGCFL is closed under
           v   v                        v
 selectors (Si ,Si ) and for the constraint (Si ,Bn) with complementation. Then, we prove the basis of the induc-
               +1                              
 i =  n −  1, the constraint relation is {(li ,li ) | i > tion, m =1. The problem QCSP(∀∃∀, BHTW, ANY) is in
                                                       P                           ∀ ¯ ∃ ¯ ∀ ¯
 i}∪{(li,li ) | i >i}.                               Π1  =  co-NP. Indeed, let Q =  V1 V2  V3φ be any in-
                    c                             c
• For any constraint (S ,Cj ) between a clause-selector S stance of this problem. Then, its complement can be de-
                    j                            j                                        ¯
 and a clause variable Cj, its constraint relation consists of cided in NP: guess an assignment σ to V1 and check that
                                                                       
             j  j   j                   j  j   j      for all assignment σ ∈ ext(σ, V¯2) there is a complete as-
 the tuples: {(lh,lh) | lh ∈ satLit(cj)}∪{(lk ,lh) | lh ∈              
                                                             σ  ∈  ext(σ , V¯ )
           j                                         signment             3  that does not satisfy all the con-
 satLit(cj),lk ∈ satLit(cj ),j >j}.                  straints in φ. From the observation above, this check is feasi-
• For any constraint between a pair of adjacent clause- ble in polynomial time. Moreover, QCSP(∃∀∃∀, BHTW, ANY)
           c  c                         c                   P
 selectors (Sj ,Sj+1) and for the constraint (Sj ,Cm) with is in Σ2 , as any instance of this problem may be solved
 j =  m − 1, the constraint relation consists of the tuples: by a non-deterministic Turing machine with an oracle for
   j  j   j                        j  j   j             ∀∃∀ BHTW ANY
 {(lh ,lh ) | lh ∈ satLit(cj ),j >j}∪{(lk,lh ) | lk ∈ QCSP(    ,    ,   ). The induction step is a simple adap-
           j                                        tation of the above reasoning for any m>1.       2
 satLit(cj),l ∈ satLit(cj ),j >j}.
           h                                          Corollary 3.6 The quantiﬁed constraint satisfaction problem
  If µ is a truth-value assignment for all variables V¯ of Φ, (on arbitrary domain) is PSPACE-complete, even if restricted
then, σµ, denotes the assignment such that σµ(Bi)=vi if on constraint networks whose structure is a tree.
µ(Vi)=true, and σµ(Bi)=¬vi  if µ(Vi)=false.
                                                      3.4  Fixed domain helps only with ﬁxed arity
Lemma 3.3  Let µ be a truth-value assignment for all vari-
                                                      We now show that hypergraph acyclicity does not help in
ables V¯ of Φ and σµ the corresponding assignment for B¯.
                                                      making easy the QCSP problem, even if we consider Boolean
Then, µ is a satisfying assignment for Φ if and only if there
                                                     domains only. The same holds even in case we additionally
exists an assignment σ ∈ ext(σµ, C¯) such that, for every
  ∈ ext  ¯v ∪ ¯c   |                            require that the incidence graph has bounded treewidth, and
σ      (σ , S   S ), σ = I(Φ) holds.                  the primal graph has small (logarithmic) treewidth. This en-
  After this lemma, we immediately get that, even for acyclic tails that the problem remains intractable as long as we have
binary constraint networks with just two quantiﬁer alterna- non-ﬁxed arities, even for very simple constraint interactions.
tions, solving a quantiﬁed CSP is intractable.        Theorem 3.7 For any natural number m ≥ 1,
                  ∀∃  TREES ANY                       •        ∀∃  m ACYCLIC ∩ BITW ∩ STW {0 1}     P
Theorem 3.4 QCSP(    ,     ,   ) is co-NP-hard.         QCSP((    ) ,                    ,  ,  ) is Π2m−1-
Proof. From a CNF Boolean formula Φ, we build in poly- complete;
                      ∀ ¯ ¯ ∃ ¯                       •        ∃∀  m∃ ACYCLIC ∩ BITW ∩ STW {0 1}      P
nomial time QC(Φ) =    B,C    SI(Φ), where  I(Φ) is     QCSP((    )  ,                     ,  ,  ) is Σ2m-
the acyclic constraint network associated with Φ. From complete.
Lemma 3.3, satisfying assignments for Φ are in one-to-one Proof. Let Φ be a Boolean formula, and I(Φ) = (Var , U, C)
correspondence with assignments to the variables in B¯ and its associated acyclic constraint network. We consider the
                                                                          
C¯ such that all their complete extensions do not satisfy I(Φ). network I(Φ) = (Var , {0, 1}, C), deﬁned as follows. For
                                                                               
Thus, Φ is not satisﬁable iff QC(Φ) is satisﬁable. 2  each variable X ∈ Var , Var contains |U(X)| distinct vari-
                                                                                         
                                                      ables X1, ..., Xlog |U(X)|, with domain U (Xi)={0, 1} for
3.3  Intractable acyclic instances                                                         
                                                      each Xi. For each constraint r(X, Y ) in C, C contains a con-
After having shown in the previous section the tractability for 
                                                      straint r (X1, ..., Xlog |U(X)|,Y1, ..., Ylog |U(Y )|), whose con-
∃∀ and the intractability for ∀∃, we now settle the complexity                                          
                                                      straint relation is such that, for each tuple (xi,yj) in r, r
of acyclic QCSPs with arbitrary quantiﬁer preﬁxes.
                                                      contains the tuple (enc(xi), enc(yj )), where the string of bits
Theorem 3.5 For any natural number m ≥ 1,
              m                  P                    enc(xi) (resp. enc(yj)) is the binary encoding of domain
 1. QCSP((∀∃)   ∀, BHTW, ANY) is Π m− -complete, and
                              m  2  1                 value xi (resp. xj). The right-bottom box in Figure 2 shows
    hardness holds for QCSP((∀∃) , TREES, ANY), too;                                   ¯
              m                   P                   a portion of the constraint network I (Φ) associated to the
 2. QCSP((∃∀)   ∃∀, BHTW, ANY) is Σ m-complete, and           ¯
                              m   2                   formula Φ of our running example. Observe that the con-
    hardness holds for QCSP((∃∀) ∃, TREES, ANY), too. straint network I(Φ) is in ACYCLIC ∩ BITW ∩ STW. Indeed,                         
the hypergraph associated to I (Φ) is acyclic, and the number Example 4.2 Consider again QCSP instance φe presented in
of variables in each hyperedge is bounded by 2 log c, where the Introduction, and the following equivalent instance, where
c is the size of largest domain over all the variables in Var . form(φe) is rewritten as
Therefore, the treewidth of the primal graph is at most 2 log c. ψ = ∀S, X, Y, T, R, U, P ( a(S, X, T, R) ∧ b(S, Y, U, P ) ∧
Moreover, it is easy to check that the treewidth of the inci- ∃Vf(R, P, V ) ∧∃Z ( g(X, Y ) ∧ c(T,U,Z) ∧
dence graph of I(Φ) is 3. Finally, observe that there exists a ∀Wd(W, X, Z) ∧ e(Y,Z)))
                                                                                                   ∈   ∗
one-to-one correspondence between assignments to variables This is a 2-guarded constraint formula, i.e., ψ G2.
in I(Φ) and in I(Φ), and thus the result immediately follows The guard of formula ψ is guard(ψ)={a(S, X, T, R),
                                                 2
from Theorem 3.5.                                     b(S, Y, U, P )}. For the formulas ψ1 = ∃Vf(R, P, V ),
                                                      ψ  =  ∃Z ( g(X, Y ) ∧ c(T,U,Z)  ∧∀Wd(W, X, Z)    ∧
Corollary 3.8 The quantiﬁed constraint satisfaction problem 2
                                                      e(Y,Z))and    ψ  =  ∀Wd(W, X, Z), we have the fol-
is PSPACE-complete, even if restricted on Boolean constraint         3
                                                      lowing guards: guard(ψ )={f(R, P, V )}, guard(ψ )=
networks whose structure is in ACYCLIC ∩ BITW ∩ STW.                       1                         2
                                                      {g(X, Y ),c(T,U,Z)}, and guard(ψ3)={d(W, X, Z)}. 2
4  Guarded formulas and tractable CSPs                  Note that the above deﬁnition of k-guardedness is con-
                                                      genial to the speciﬁc syntax of quantiﬁed CSPs and differs
In this section, we describe a wide class of quantiﬁed con-
                                                      from that of k-guarded ﬁrst order logic [Andreka et al., 1998;
straint formulas that are tractable, even if there is no constant
                                                      Gradel,¨ 1999]. In the standard formalisms of the guarded
bound on domain sizes or quantiﬁer alternations. Recall that
                                                      fragment GF of ﬁrst order logic or of the k-guarded fragment
any QCSP instance φ may be represented by a logical expres-
                                                      GFk  of ﬁrst order logic [Gottlob et al., 2003], the guards
sion, as shown in Section 1 for QCSP φe. Technically, let us
                                                      of an existentially quantiﬁed subformula ψ are added con-
denote the pure logical formula of φ (without the encoding of                                 ∗
                                                      junctively to ψ (guard(ψ) ∧ ψ), just as for G . However,
relations, domains, etc.) by form(φ).                                                         k
                                                      the guards of a universal formula ψ are added in form of an
  Following [Kolaitis et al., 2000], we denote by FO∧, the
                                              +       implication: guard(ψ) → ψ. This is much more natural,
fragment of ﬁrst order sentences where arbitrary quantiﬁca-
                                                      since these logics have negation and guardedness needs to be
tions and conjunctions are allowed, but where negations and
                                                      correctly preserved under negations. For example, the nega-
disjunctions are forbidden. They observed that the existential
                                                      tion of a guarded formula ¬∃Y¯ (g(Y¯ ) ∧ ψ(Y¯ )) is logically
fragment ∃FO∧,+ of FO∧,+ has the same expressive power
                                                      equivalent to ∀Y¯ (g(Y¯ ) →¬ψ(Y¯ )). Since the logic FO∧,
as the constraint satisfaction problems. By allowing any kind                                          +
                                                      of constraint formulas has conjunction (∧) as unique binary
of quantiﬁers, this observation may be clearly extended to the
                                                      connective, it is syntactically impossible to express an im-
connection between general FO∧,+ formulas and quantiﬁed
                                                      plication guard(ψ) → ψ in FO∧, (in fact, this is also se-
constraint formulas. Notice that, in this more general set-                        +
                                                      mantically impossible). On the other hand, since negation
ting, there are different equivalent logical representation of
                                                      is missing in FO∧, , no problems involving “wrong guards”
the same instance. For example, one may use parentheses for           +
                                                      can arise through negation when using the natural (but non-
distinguishing subformulas and delimiting quantiﬁer scopes.
                                                      standard) guards introduced for the above deﬁned fragments
In this section, we represent QCSPs by FO∧,+ formulas that ∗
                                                      G  of FO∧, .
are not necessarily in the traditional prenex form. Notice, k   +
                                                        For the k-guarded fragment GFk of ﬁrst order logic (i.e.,
however, that each FO∧, formula can be easily transformed
                    +                                 for the standard k-guarded fragment) the following tractabil-
into an equivalent prenex formula.
                                                      ity result was shown in [Gottlob et al., 2003]:
4.1  The fragment  k-GQCSP   of k-guarded QCSPs       Proposition 4.3 The combined  complexity of evaluat-
We show that, for each constant k, a simple and appealing ing a GFk formula φ over a set of ﬁnite relations D is in
                                                      O(|φ|×|D|k).
fragment of FO∧,+ is decidable in polynomial time. Since
we have no bound on the number of variables in a formula, Let us now show that also the class k-GQCSP of k-
we assume w.l.o.g. that each variable is quantiﬁed over only guarded QCSPs is tractable, notwithstanding the “nonstan-
once, i.e., quantiﬁed variables are not reused. In the follow- dard” guards for universally quantiﬁed subformulas.
ing, we denote by free(ψ) the free variables of a logical for- Lemma 4.4 There is an algorithm TRANSFORM which for
mula ψ.                                               each QCSP φ ∈  k-GQCSP  computes a pair (D, φ∗) where
                                                                              ∗
Deﬁnition 4.1 The class k-GQCSP of k-guarded QCSPs    D is a ﬁnite database and φ ∈ GFk, such that φ is satisﬁed
                                                              ∗
consists of those QCSPs instances φ whose formula form(φ) iff D |= φ . The TRANSFORM algorithm runs in logspace.
                     ∗                           ∗
belongs to the fragment Gk of FO∧,+ deﬁned as follows. Gk Proof. Let φ ∈ k-GQCSP, and let R be the set of con-
                                                                                                     
is the smallest subset of FO∧,+ such that:            straint relations of CN (φ). Consider a subformula ψ =
                      ∗
• every atom belongs to Gk;                           ∀Y¯ (guard(ψ) ∧ ψ) of form(φ), where ∀Y¯ is a maximal pre-
                ∗                ∗
• if φ1 and φ2 ∈ Gk, then φ1 ∧ φ2 ∈ Gk;               ﬁx of universally quantiﬁed variables, and where guard(ψ)
• let α1,...,αi be atoms, where i ≤ k, and let ψ be a for- is a conjunction of m atoms ri(Y¯i, X¯i), with 1 ≤ i ≤ m ≤ k,
        ∗
mula in Gk. If the free variables free(ψ) ⊆ var(α1) ∪···∪ where Y¯i are the variables in its scope included in Y¯ , and X¯i
var(αi), then, for each tuple of variables y¯ and each quanti- its other variables, hence X¯i ∩ Y¯ = ∅.For1 ≤ i ≤ m,we
                           
ﬁer Q ∈{∃, ∀}, the formula ψ : Qy¯(α1 ∧···∧αi ∧ ψ)    denote by ri ↓ the relation obtained from the constraint rela-
           ∗                                                              ¯                            ¯
belongs to Gk. The set of atoms {α1,...,αi} is referred to tion ri by keeping allYi-columns and projecting out all Xi
                                     
                                                 2                 i↓        i
as the guard of ψ and is denoted by guard(ψ ).        columns, i.e., r := Y¯i r .