            Conjunctive Query Answering for the Description Logic                   SHIQ

                      Birte Glimm1, Ian Horrocks1, Carsten Lutz2, Uli Sattler1
          1 School of Computer Science             2 Institute for Theoretical Computer Science
          University of Manchester, UK                       TU Dresden, Germany


                    Abstract                          for structures that are invariant under (guarded) bisimula-
                                                      tions. For this reason, many applications require conjunctive
    Conjunctive queries play an important role as an  query answering as a stronger form of querying, i.e., com-
    expressive query language for Description Logics  puting the certain answers to a conjunctive query over a DL
    (DLs). Although modern DLs usually provide for    knowledge base.
    transitive roles, it was an open problem whether
                                                        Until now it was an open problem whether conjunctive
    conjunctive query answering over DL knowledge                                 SHIQ
    bases is decidable if transitive roles are admitted query answering is decidable in . In particular, the
    in the query. In this paper, we consider conjunc- presence of transitive and inverse roles makes the problem
                                                                 [               ]
    tive queries over knowledge bases formulated in   rather tricky Glimm et al., 2006 , and results were only avail-
    the popular DL SHIQ and allow transitive roles in able for two restricted cases. The ﬁrst case is obtained by
    both the query and the knowledge base. We show    stipulating that the variables in queries can only be bound to
    that query answering is decidable and establish the individuals that are explicitly mentioned in the ABox. The
    following complexity bounds: regarding combined   result is a form of closed-domain semantics, which is differ-
    complexity, we devise a deterministic algorithm for ent from the usual open-domain semantics in DLs. It is easily
    query answering that needs time single exponential seen that conjunctive query answering in this setting can be
    in the size of the KB and double exponential in the reduced to instance retrieval. In the second case, the binary
    size of the query. Regarding data complexity, we  atoms in conjunctive queries are restricted to roles that are
    prove co-NP-completeness.                         neither transitive nor have transitive sub-roles, and it is known
                                                      that conjunctive query answering in this setting is decidable
                                                      and co-NP-complete regarding data complexity [Ortiz et al.,
1  Introduction                                       2006].
Description Logics (DLs) [Baader et al., 2003] are a well- In this paper, we show that unrestricted conjunctive query
established family of logic-based knowledge representation answering in SHIQ is decidable. More precisely, we de-
formalisms that have recently gained increased attention due vise a decision procedure for the entailment of a conjunctive
to their usage as the logical underpinning of ontology lan- query by a SHIQ knowledge base, which is the decision
guages such as DAML+OIL and OWL     [Horrocks et al., problem corresponding to conjunctive query answering. It
2003]. A DL knowledge base (KB) consists of a TBox, which is well-known that decidability and complexity results carry
contains intensional knowledge such as concept deﬁnitions over from entailment to answering. Our decision procedure
                                                      for query entailment consists of a rather intricate reduction to
and general background knowledge, and an ABox, which                        
contains extensional knowledge and is used to describe in- KB consistency in SHIQ , i.e., SHIQ extended with role
dividuals. Using a database metaphor, the TBox corresponds conjunction. The latter is easily seen to be decidable. The
to the schema, and the ABox corresponds to the data.  resulting (deterministic) algorithm for conjunctive query en-
  In data-intensive applications, querying KBs plays a cen- tailment in SHIQ needs time double exponential in the size
tral role. Essentially, there are two forms of querying. The of the query and single exponential in the size of the KB.
ﬁrst one is instance retrieval, which allows the retrieval of all This result concerns the combined complexity, i.e., it is mea-
certain instances of a given (possibly complex) concept C, sured in the size of all inputs: the query, the ABox, and the
i.e., it returns all individuals from the ABox that are an in- TBox. Since query and TBox are usually small compared to
stance of C in every model of the KB. Technically, instance the ABox, the data complexity (measured in the size of the
retrieval is well-understood. For the prominent DL SHIQ, ABox, only) is also a relevant issue. We show that (the deci-
which underlies DAML+OIL and OWL Lite, it is EXPTIME- sion problem corresponding to) conjunctive query answering
complete [Tobies, 2001], and, despite this high worst-case in SHIQ is co-NP-complete regarding data complexity, and
complexity, efﬁcient implementations are available. On the thus not harder than instance retrieval [Hustadt et al., 2005].
other hand, instance retrieval is a rather poor form of query- This paper is accompanied by a technical report which con-
ing: concepts are used as queries, and thus we can only query tains full proofs [Glimm et al., 2006].

                                                IJCAI-07
                                                   3992  Preliminaries                                      be a KB and I =(ΔI, ·I ) an interpretation. An interpretation
                                                      I         K            T   H      A    Γ
Syntax and Semantics of SHIQ                            satisﬁes  if it satisﬁes , ,and  .If    is a TBox,
                                                      ABox, or KB and I satisﬁes Γ, we say that I is a model of Γ
Let NC, NR,andNI be sets of concept names, role names,and
                                                      and write I|=Γ. A knowledge base K is consistent if it has
individual names. We assume that the role names contain
                                                      a model.
a subset NtR ⊆ NR of transitive role names.Arole is an
                 −
element of NR ∪{r  | r ∈ NR}, where roles of the form Conjunctive Queries
r−
   are called inverse roles.Arole inclusion is of the form Let NV be a countably inﬁnite set of variables disjoint from
r  s    r, s                   H
     with   roles. A role hierarchy is a ﬁnite set of role NC, NR,andNI.Anatom is an expression A(v) (concept
inclusions.                                           atom)orr(v, v) (role atom), where A is a concept name, r is
                       I I                                        
  An interpretation I =(Δ , · ) consists of a non-empty set    v, v ∈ NV                   q
 I                               I                    a role, and       .Aconjunctive query is a non-empty
Δ  ,thedomain of I, and a function · , which maps every set of atoms. Intuitively, such a set represents the conjunction
concept name A to a subset AI ⊆ ΔI , every role name                        Var(q) Var(at)
                          I     I     I          I    of its elements. We use     (      ) to denote the set
r ∈ NR to a binary relation r ⊆ Δ × Δ   such that r   of variables occurring in the query q (atom at). Let I be an
is transitive for every r ∈ NtR, and every individual name a      q                      π : Var(q) → ΔI
             I     I                                  interpretation, a conjunctive query, and          a
to an element a ∈ Δ . An interpretation I satisﬁes arole total function. We write
        r  s  rI ⊆  sI                  H
inclusion     if       , and a role hierarchy if it sat- •I|=π  C(v)  (π(v)) ∈ CI
isﬁes all role inclusions in H. We use the following standard        if          ;
                                                              π                      I
notation:                                               •I|=    r(v, v ) if (π(v),π(v )) ∈ r ;
   Inv(r):=r−    r ∈ N     Inv(r):=s   r = s−               π                              π
(1)            if     R and           if      for a   If I|=  at for all at ∈ q, we write I|= q and call π a
         s
role name .                                           match for I and q. We say that I satisﬁes q and write I|= q
                    H  ∗
(2) For a role hierarchy , H is the reﬂexive transitive clo- if there is a match π for I and q.IfI|= q for all models I of
           H∪{Inv(r)    Inv(s) | r  s ∈H}
sure of over                               ,andwe     aKBK, we write K|=  q and say that K entails q.
   r ≡∗ s                   r ∗  s    s ∗ r
use   H   as an abbreviation for H and    H  .          The query entailment problem is deﬁned as follows: given
                     H           s
(3) For a role hierarchy and a role ,wedeﬁnetheset    a knowledge base K and a query q, decide whether K|= q.
Trans
     H of transitive roles as                         It is well-known that query entailment and query answering
                    ∗                                 can be mutually reduced and that decidability and complexity
 {s |∃role r with r ≡H s and r ∈ NtR or Inv(r) ∈ NtR}.
                                                      results carry over [Calvanese et al., 1998; Horrocks and Tes-
(4) A role r is called simple w.r.t. a role hierarchy H if, for saris, 2000]. In the remainder of this paper, we concentrate
                    ∗
each role s such that s H r, s/∈ TransH.             on query entailment.
                     ∗
  The subscript H of H and TransH is dropped if clear  For convenience, we assume that conjunctive queries
from the context. SHIQ-concepts (or concepts for short) are closed under inverses, i.e., if r(v, v) ∈ q,then
are built inductively using the following grammar, where Inv(r)(v,v) ∈ q. If we add or remove atoms from a query,
A ∈ NC, n ∈ IN , r is a role, and s is a simple role: we silently assume that we do this such that the resulting
                                                      query is again closed under inverses. We will also assume
     C  ::= |⊥|A    |¬C | C 
 C  | C  C  |
                            1    2   1    2           that queries are connected. Formally, a query q (closed under
            ∀r.C |∃r.C | ns.C | ns.C.                                              
                                                      inverses) is connected if, for all v, v ∈ Var(q), there exists
                                                                v ,...,v          v  =  v v  =  v
               SHIQ                                   a sequence 0      n such that 0    , n     ,andfor
The semantics of     -concepts is deﬁned as usual, see   i<n                    r          r(v ,v  ) ∈ q
   [                  ]                               all      , there exists a role such that i i+1    .
e.g. Horrocks et al., 2000 for details.                           q ,...,q                            q
                                              C      A collection 0     k of queries is a partitioning of if
  A general concept inclusion (GCI) is an expression  q =  q ∪···∪q    Var(q ) ∩ Var(q )=∅     i<j≤    k
D, where both C and D are concepts. A ﬁnite set of GCIs    0         k,     i        j     for          ,
                                                      and each qi is connected. The following lemma shows that
is called a TBox.Anassertion is an. expression of the form
A(a), ¬A(a),r(a, b), ¬r(a, b),ora = b,whereA is a concept connectedness can be assumed w.l.o.g.
name, r is a role, and a, b ∈ NI.AnABox is a ﬁnite set Lemma 1. Let K be a knowledge base, q a conjunctive query,
of assertions. We use Ind(A) to denote the set of individual and q0,...,qn a partitioning of q.ThenK|= q iff K|= qi
names occurring in A. An interpretation I satisﬁes aGCI for all i ≤ n.
C   D if CI ⊆  DI. Satisfaction of assertions is deﬁned
in the obvious way, e.g. A(a) is satisﬁed if aI ∈ AI.An
interpretation I satisﬁes a TBox (ABox) if it satisﬁes each 3 Forests and Trees
GCI (assertion) in it.                                In this section, we carefully analyze the entailment of queries
  Observe that, in ABox assertions C(a), we require C to by knowledge bases and establish a set of general properties
be a (possibly negated) concept name. This is a standard as- that will play a central role in our decision procedure. We
sumption when the data complexity of DLs is analyzed, see start by showing that, in order to decide whether K|= q,it
e.g. [Donini et al., 1994]. In this paper, we will sometimes sufﬁces to check whether I|= q for all models I of K that are
also allow ABox assertions C(a),whereC is an arbitrary of a particular shape. Intuitively, these models are shaped like
concept. To make this explicit, we will call such ABoxes a forest (in the graph-theoretic sense), modulo the fact that
generalized.                                          transitive roles have to be interpreted in transitive relations.
                                                             ∗
  A knowledge base (KB) is a triple (T , H, A) with T a Let IN be the set of all (ﬁnite) words over the alphabet IN .
                                                                                                   ∗
TBox, H a role hierarchy, and A an ABox. Let K =(T , H, A) A tree T is a non-empty, preﬁx-closed subset of IN .For

                                                IJCAI-07
                                                   400                                                                      ∗
w, w ∈  T , we call w a successor of w if w = w · c for TransH such that si H ri for all i ≤ n, and then replacing
                                                           
some c ∈ IN ,where“·” denotes concatenation. We call w a ri(vi,vi) with
neighbor of w if w is a successor of w or w is a successor
                                                                      s (v ,u ),s (u ,v)
of w .                                                                  i  i  i  i  i i
                                                                               or
                           K                 I                                           
Deﬁnition 2. A forest base for is an interpretation that           si(vi,ui),si(ui,ui),si(ui,vi)
interpretes transitive roles in unrestricted (i.e., not necessarily
                                                                           
transitive) relations and, additionally, satisﬁes the following for all i ≤ n,whereui,ui ∈ Var(q).WeusetrK(q) to denote
conditions:                                           the set of all transitivity rewritings of q w.r.t. K. 
                     ∗
T1  ΔI  ⊆ Ind(A) × IN such that, for all a ∈ Ind(A),the We assume that trK(q) contains no isomorphic queries, i.e.,
    set {w | (a, w) ∈ ΔI } is a tree;                 differences in (newly introduced) variable names are ne-
                      I                            glected. Together with Lemma 3, the following lemma shows
T2  if ((a, w), (a ,w )) ∈ r , then either w = w = ε or                   K|=  q
    a = a   w               w                       that, to decide whether   , it sufﬁces to check the exis-
          and   is a neighbor of ;                    tence of some canonical model I, some forest match π,and
                     I                                                          π  
T3  for all a ∈ Ind(A), a =(b, ε) for some b ∈ Ind(A). some q ∈ trK(q) such that I|= q .
A model I of K is canonical if there exists a forest base J for Lemma 5. Let I be a model of K.
K         J             I                                                                       
  such that is identical to except that, for all non-simple 1. If I is canonical and I|= q, then there is a q ∈ trK(q)
    r                                                                  
roles ,wehave                                             such that I|=π q, with π a forest match.
                          
             I    J               J                                    
            r  = r  ∪           (s )+.                  2. If I|= q with q ∈ trK(q),thenI|= q.
                      s∗r, s∈Trans                   Proof. (1) can be proved by using the match and the canonical
                                                                 I
                    J                 I              structure of to guide the rewriting process. (2) holds by
In this case, we say that is a forest base for .      deﬁnition of transitivity rewritings and the semantics. J
Observe that, in canonical models I, each individual a is
               (b, ε)      a =  b                     The most important property of forest matches is the follow-
mapped to a pair    ,where       does not necessarily       I|=π q     π                 π              q
hold. We need this since we do not adopt the uniqe name ing: if    with a forest match, then splits the query
                                                      into several subqueries: the base subquery q contains all role
assumption (UNA):ifa, b ∈ NI with a = b, then we allow                                   0
     I    I                                           atoms that are matched to root nodes:
that a = b . If desired, the UNA can easily be adopted by
                 a = b                                                              
adding an assertion   for each pair of individual names     q0 := {r(v, v ) ∈ q | π(v),π(v ) ∈ NI ×{ε}};
in Ind(A) to the ABox.
                                                      Moreover, for each (a, ε) ∈ NI ×{ε} which occurs in the
Lemma 3.  K |= q iff there exists a canonical model I of K
                                                      range of π,thereisanobject subquery qa:
such that I |= q.
                                                                                               ∗
                                                          qa := {at |∀v ∈ Var(at):π(v) ∈{a}×IN  }\q0.
Proof. Using standard unravelling (see e.g. [Tobies, 2001]),          
each model of K can be converted into a canonical model      q = q  ∪    q
                                                     Clearly,    0     a a. Although the resulting subqueries
of K. Moreover, if I|= K and I is the canonical model are not a partitioning of q in the sense of Section 2, one of the
obtained by unravelling I, then it is not hard to show that
                                                     fundamental ideas behind our decision procedure is to treat
I |= q implies I |= q, for all conjunctive queries q. J the different subqueries more or less separately. The main
                                                      beneﬁt is that the object subqueries can be rewritten into tree-
Lemma 3 shows that, when deciding whether K|= q,itsuf-
                                                      shaped queries which can then be translated into concepts.
ﬁces to check whether I|= q for all canonical models I of K.
                                                      This technique is also known as “rolling up” of tree conjunc-
As a next step, we would like to show that, for canonical mod-
                                                      tive queries into concepts and was proposed in [Calvanese et
els I, to check whether I|= q, we can restrict our attention
                                                      al., 1998; Horrocks and Tessaris, 2000].
to a particular kind of match π for I and q.Amatchπ for I
                                                       Formally, a query q is tree-shaped if there exists a bijection
and q is a forest match if, for all r(v, v ) ∈ q, we have one of                            
                                                      σ from Var(q) into a tree T such that r(v, v ) ∈ q implies
the following:                                                                 
                                                      that σ(v) is a neighbor of σ(v ) in T . Before we show how to
            
  • π(v),π(v ) ∈ NI ×{ε};                             rewrite the object subqueries into tree-shaped queries, let us
                       ∗
  • π(v),π(v) ∈{a}×IN   for some a ∈ Ind(A).         substantiate our claim that tree-shaped queries can be rolled
                                                      up into concepts. The result of rolling up is not a SHIQ-
                                                                                           
Alas, it is not sufﬁcient to only consider forest matches for I concept, but a concept formulated in SHIQ , the extension
                                                                                                      
and q. Instead, we show the following: we can rewrite q into of SHIQ with role intersection. More precisely, SHIQ is
a set of queries Q such that, for all canonical models I,we obtained from SHIQ by admitting the concept constructors
                      π            
have that I|= q iff I|= q for some q ∈  Q and forest  ∃α.C, ∀α.C,  α.C,and  α.C,whereα  is a role conjunc-
     π
match  . Intuitively, this complication is due to the presence tion r1 
···
rk with the ri (possibly inverse) roles.
of transitive roles.                                    Let q be a tree-shaped query and σ a bijection from Var(q)
                                                     into a tree T . Inductively assign to each v ∈ Var(q) a
Deﬁnition 4. A query q  is called a transitivity rewrit-    
                                                      SHIQ    -concept Cq(v):
ing of q w.r.t. K if it is obtained from q by choosing                                   
     r (v ,v ),...,r (v ,v ) ∈ q      s ,...,s ∈      •   σ(v)          T     C  (v):=        A
atoms 0  0  0      n  n  n     and roles 0     n          if     is a leaf of ,then q      A(v)∈q

                                                IJCAI-07
                                                   401                                                                                                    ∗
  • if σ(v) has successors σ(v1),...,σ(vn) in T ,then   3. if r(v, v ) ∈ q \q , then there is a role s such that s  r,
                                                     s ∈ Trans,andtherearev0,...,vn  such that v0 = v,
      C  (v):=      A 
       ∃        r .C (v ).                                
        q                                  q  i           vn = v ,ands(vi,vi+1) ∈ q for all i<n.
               A(v)∈q   1≤i≤n   r(v,vi)∈q             A query q is a tree transformation of q w.r.t. K if there exist
                                                      queries q0 and q1 such that
Then the rolling up Cq of q is deﬁned as Cq(vr),wherevr
                                                        • q                q
is such that σ(vr)=ε. (Recall that σ is a bijection, hence, 0 is a collapsing of ,
     vr
such a  exists.) The following lemma shows the connection • q1 is an extension of q0 w.r.t. K,and
between the query and the rolled up concept.
                                                        • q is a tree-shaped reduct of q .
             q                       I                                             1
Lemma 6.  Let be a tree-shaped query and an interpreta-      tt (q)
tion. Then I|= q iff CI = ∅.                         We use  K    to denote the set of all tree transformations of
                  q                                   q w.r.t. K.                                      
We now show how to transform a query q into a set Q of tree-
shaped ones. To describe the exact goal of this translation, We remark that Condition 5 of query extensions is not strictly
                                                      needed for correctness, but it ensures that our algorithm is
we need to introduce tree matches as a special case of forest                          K
matches: a match π for a canonical model I and q is a tree only single exponential in the size of . As in the case of
                                         ∗            tr (q)              tt (q)
match if the range of π is a subset of {a}×IN ,forsome  K   , we assume that K  does not contain any isomor-
                                                      phic queries.
a ∈ NI. Now, our tree transformation should be such that
                    π                                   The next lemma states the central properties of tree trans-
    (∗) whenever I|=  q with I a canonical model
                                                     formations. Before we can formulate it, we introduce two
        π                I|=π  q                                                      π           π  
    and  a tree match, then       for some (tree-     technical notions. Let q ∈ ttK(q), I|= q,andI|=  q .
                q ∈ Q             π                            
    shaped) query     and tree match .                Then π and π are called ε-compatible if the following holds:
                                                                                                      
Recall the splitting of a query into a base subquery and a set if v ∈ Var(q), v was identiﬁed with variable v ∈ Var(q )
                                                                                                    
of object subqueries qa, induced by a forest match π. It is not during the collapsing step, and at least one of π(v),π (v ) is
                                                                               
hard to see that for each qa, the restriction of π to Var(qa) is in NI ×{ε},thenπ(v)=π (v ). Furthermore, we call π an
                                                                                 ∗
a tree match for I and qa. Thus, object subqueries together a-tree match if π(v) ∈{a}×IN for all v ∈ Var(q).
                       π                        ∗
with their inducing matches satisfy the precondition of ( ). Lemma 8. Let I be a model of K.
  The rewriting of a query into a tree-shaped one is a  1. If I is canonical and π an a-tree match with I|=π q,
three stage process. In the ﬁrst stage, we derive a col-                                           
                                                          then there is a q ∈ ttK(q) and an a-tree match π such
       q                     q                                     
lapsing 0 of the original query by (possibly) identify-       I|=π  q    π π    ε
ing variables in q. This allows us, e.g., to transform atoms that     and  ,  are  -compatible.
                                                                            π  
r(v, u),r(v, u ),r(u, w),r(u ,w) into a tree shape by iden- 2. If q ∈ ttK(q) and I|= q , then there is a match π
             
tifying u and u . In the second stage, we derive an exten- with I|=π q and π, π are ε-compatible.
sion q1 of q0 by (possibly) introducing new variables and
                                            r(v, v)  Proof. The proof of (2) is straightforward, but the proof of
role atoms that make certain existing role atoms      (1) is quite complex. The basic idea behind the proof of (1) is
redundant, where r is non-simple. In the third stage, we                       I   K               π
              q   q                                  that, given a canonical model of and a tree match such
derive a reduct of 1 by (possibly) removing redundant     I|=π q           π    I
                    r(v, v)                          that      , we can use and  to guide the transformation
role atoms, i.e., atoms    such that there exist atoms                    4|q|   171|q|2
s(v ,v ),...,s(v  ,v ) ∈ q    v =  v v =  v s ∗ r   process. The bounds of and       in Conditions 4 and 5
   0 1         n−1  n     with 0    , n    ,      ,   of extensions are derived by computing the maximum number
and s ∈ Trans. Combining the extension and reduct steps al-
                                             r(v, v)  of variables and atoms that might be introduced in the guided
lows us, e.g., to transform a non-tree-shaped “loop”  transformation process.                          J
into a tree shape by adding a new variable v and edges
s(v, v),s(v,v) such that s ∗ r and s ∈ Trans,andthen Intuitively, using a-tree matches and ε-compatibility in
removing the redundant atom r(v, v).                  Lemma 8 ensures that, if we are given a match for the base
  In what follows, the size |q| of a query q is deﬁned as the subquery and a tree match for a tree transformation of each
number of atoms in q.                                 object subquery, then we can construct a forest match of the
                                                      original query.
Deﬁnition 7. A collapsing of q is obtained by identifying
          q        q               q     K
variables in . A query is an extension of w.r.t. if:  4   The Decision Procedure
    q ⊆ q
 1.      ;                                                K                       q
                                                     Let   be a knowledge base and a conjunctive query such
 2. A(v) ∈ q implies A(v) ∈ q;                        that we want to decide whether K|= q.Acounter model for
 3. r(v, v) ∈ q \ q implies that r occurs in K;     K and q is a model I of K such that I |= q. In the following,
                                                      we show how to convert K and q into a sequence of knowl-
 4. |Var(q)|≤4|q|;
                                                      edge bases K1,...,K such that (i) every counter model for
                                  2
 5. |{r(v, v ) ∈ q | r(v, v ) ∈/ q}| ≤ 171|q| .       K and q is a model of some Ki, (ii) every canonical model
                                                         K                    K     q
A query q is a reduct of q w.r.t. K if:               of a  i is a countermodel for and , and (iii) each consis-
                                                          K                          K|=  q        K
    q ⊆ q                                            tent i has a canonical model. Thus,  iff all the i are
 1.      ;                                            inconsistent. This gives rise to two decision procedures: a de-
                           
 2. A(v) ∈ q implies A(v) ∈ q ;                       terministic one in which we enumerate all Ki and which we

                                                IJCAI-07
                                                   402use to derive an upper bound for combined complexity; and • τ(v0)=a and vn = v;
a non-determinstic one in which we guess a Ki and which
                                                        • for all i ≤ n, τ(vi)=a or τ(vi) is undeﬁned;
yields a tight upper bound for data complexity.                                                   
                                                        • for all i<n, there is a role r s.t. r(vi,vi ) ∈ q .
  Since the knowledge bases Ki involve concepts obtained                                    +1
                                                                                
by rolling up tree-shaped queries, they are fomulated in We call τ a split mapping for q if, for all a, b ∈ Ind(A), a =
      
SHIQ    rather than in SHIQ. More precisely, each KB Ki b implies Reach(a, τ) ∩ Reach(b, τ)=∅. Intuitively, each
                                                                        
is of the form (T∪Tq, H, A∪Ai),where                  split mapping τ for q represents the set of forest matches π
                                                      of q such that π(v)=(τ(v),ε) for all v in the domain of
  • (T , H, A) is a SHIQ knowledge base;                                              
                                                     τ. Each injective split mapping for q induces a splitting of
  •T                C        C  SHIQ                 
     q is a set of GCIs   with   a        concept;    q  into a base query and object queries. Split mappings τ
                                
  •Ai                     SHIQ         1              need not be injective, however, and thus the general picture is
        is a  generalized        -ABox    such that                                            
    Ind(Ai) ⊆ Ind(A).                                 that they induce a splitting of the collapsing q of q obtained
                                                                              v, v    τ(v)=τ(v)
In what follows, we call knowledge bases of this form ex- by identifying all variables with        .This
tended knowledge bases. Using a standard unravelling argu- splitting is as follows:
ment, it is easy to establish Property (iii) from above, i.e., qτ := {r(v, v) ∈ q | τ(v),τ(v) is deﬁned}
                                   K                       0
every consistent extended knowledge base has a canonical   qτ  :=  {at ∈ q | Var(at) ⊆ Reach(a, τ)}\qτ
model.                                                     a                                       0
  The actual construction of the extended knowledge bases for all a ∈ NI that are in the range of τ. Observe that the
is based on the analysis in Section 3. To start with, Lemma 3 condition which distinguishes splitting candidates and split
                                                                                          τ        τ
and 5 imply the following: to ensure that a canonical model of mappings ensures that a = b implies Var(qa ) ∩ Var(qb )=∅.
an extended KB is a counter model for K and q, it sufﬁces to This condition is satisﬁed by the splittings described in Sec-
                                
prevent forest matches of all queries q ∈ trK(q).Inorderto tion 3, and it is needed to independently roll up the subqueries
                                                       τ
prevent such matches, we use the parts Tq and Ai of extended qa into concepts.
knowledge bases.                                        In the following, we use sub(q) to denote the set of sub-
  More precisely, we distinguish between two kinds of forest queries of q, i.e., the set of non-empty subsets of q.Let
matches: tree matches and true forest matches, i.e., forest Q := {q |∃q ,q : q ∈ tr (q),q ∈ sub(q ),q ∈ tt (q )}
matches that are not tree matches. Preventing tree matches   3   1  2  1    K     2       1   3    K  2
     
of a q ∈ trK(q) in a canonical model is relatively simple:   cl(q)                             C 
                                                    and let     be the set of rolled up concepts q ,forall
by Lemmas 8 and 6, it sufﬁces to ensure that, for all q ∈ q ∈ Q SHIQ        A          q
                                                           .A          ABox     is called a -completion if it
tt (q )                       C  
 K    , the corresponding concept q does not have any contains only assertions of the form
instances. Therefore, Tq is deﬁned as follows:
                                                        •¬C(a)          C  ∈ cl(q)   a ∈ Ind(A)
                                                             for some        and           and
  Tq = {  ¬Cq | q ∈ ttK(q ) for some q ∈ trK(q)}.
                                                        •¬r(a, b) for a role name r occurring in Q and a, b ∈
It is easily seen that true forest matches π always involve Ind(A).
                              π(v) ∈ N  ×{ε}
at least one ABox individual (i.e.,   I       for at      τ                      q ∈  tr (q)     A   q
least one variable v). In order to prevent true forest matches, Let be a split mapping for K  and    a  -
                                                      completion. We say that A spoils τ if one of the following
we thus use an ABox Ai. Intuitively, we obtain the ABoxes
                                                      holds:
A1,...,A by considering all possible ways of adding asser-
      K                      q ∈ tr (q)                           r(v, v) ∈ qτ      ¬r(τ(v),τ(v )) ∈A
tions to such that, for all queries K , all true forest (a) there is an      0 such that                ;
matches are prevented. This gives rise to the knowledge bases       a              τ         ¬C(a)  ∈A
K ,...,K                                               (b) there is an in the range of such that        ,
 1      .                                                where
  As suggested in Section 3, we can prevent a true forest
                                                                        C :=        Cq .
     π    q ∈  trK(q)          π                                                  τ
match  of            by splitting into a base subquery                        q ∈ttK(qa )
and a number of object subqueries and then making sure that
either the base query fails to match (this involves only indi- Intuitively, (b) prevents tree matches of the object subqueries,
vidual names from the ABox) or at least one of the object c.f. Lemmas 8 and 6.
                                                        Finally, a q-completion A is called a counter canidate for
subqueries fails to have a tree match. In Section 3, however,                                          
we used a concrete forest match π to split a query into sub- K and q if for all q ∈ trK(q) and all split mappings τ for q ,
                                                      A      τ     A  ,...,A                          K
queries. Here, we do not have a concrete π available and must spoils .Let 1   be all counter candidates for
                                                          q    K ,...,K
consider all possible ways in which a forest match can split a and and 1  the associated extended KBs.
query.                                                          K|=  q  K  ,...,K
                                                    Lemma 9.        iff 1       are inconsistent.
  Let q ∈ trK(q).Asplitting candidate for q is a partial
       τ : Var(q) → Ind(A)                           We now deﬁne the two decision procedures for query entail-
function                  with non-empty domain. For         SHIQ
a ∈ Ind(A)      Reach(a, τ)                           ment in      : in the deterministic version, we generate all
         ,weuse            to denote the set of variables q        A   A           K|=  q
v ∈ Var(q) for which there exists a sequence of variables -completions of and return “   ” if all generated
                                                      A that are a counter candidate give rise to an inconsistent
v ,...,vn, n ≥ 0, such that
 0                                                    extended KB. Otherwise, we return “K |= q”. In the non-
                                                                                                
  1Recall that an ABox is generalized if it admits assertions C(a) deterministic version, we guess a q-completion A of A,re-
                                                                      
with C an arbitrary concept.                          turn “K |= q”ifA is a counter candidate and the associated

                                                IJCAI-07
                                                   403