                    propagating logical combinations constraints                         fahiem bacchus∗                                toby walsh†                     university toronto                         nicta unsw                       toronto canada                              sydney australia                   fbacchuscstorontoedu                        twcseunsweduau                        abstract                             inconsistent valid assignments                                                        constraint satisfaction problem consists set vari      constraint toolkits provide logical connec                                                        ables each domain values set constraints      tives like disjunction negation implication      permit complex constraint expressions    each constraint consists scope variables                                                        applied relation allowed values variables      built primitive constraints                                                        convenience represent domains variables      propagation complex constraint expres      sions typically limited present  set possible assignments example                                                         variables        simple light weight method propagat                                                          let domainx  set values      ing complex constraint expressions provide                        domainxa      ∈d      precise characterization method en domain variable                                                                                  assignment set τ set assignments variables      forces generalized arcconsistency addition                                                        variable assigned value τ      demonstrate method different                                                        scope                  τ               global constraints easily implemented          assignment set constraint  set vari                                                        ables τ denoted scopeτ scopec given                                                                                       τ      scopec ⊆    introduction                                       constraint assignment set                                                        scopeτ write cτ iff assignments τ satisﬁes  real world problems contain logical combinations cτ iff exists   xk  ak ∈ τ  numerical symbolic constraints example scopecx  xk   xk  ak satisﬁes  ﬁguration problems naturally speciﬁed using implication write ¬cτ  logical connectives car coupe assignment generalized arc inconsistent  convertible roof rack valid option facilitate constraint iff assignment set containing satisﬁes  modeling problems constraint toolkits allow log constraint  inconsistent iff  ical combinations primitive constraints posted ∀τ scopec ⊆ scopeτ ∧  ∈ τ →¬cτ  combinations typically propagated ef straint unique maximal set inconsistent assign  fectively example propagation disjunction ments maxincc example given constraint xy  constraints generally delayed dis          juncts falsiﬁed remaining disjunct maximal set inconsistent assignments assignments  hold propagated                         consistent witness falsifying    present simple light weight method propa condition  consistent iff assignment  gate constraint expressions built logical connectives set τ called support scopeτscopec ∧   primitive constraints method incorporated ∈ τ ∧cτ constraint gac generalized arc  current constraint toolkit simple extension sistent iff value variable scopec  propagators primitive constraints support  inconsistent prune  fore provide user rich language specifying prob domain constraint gac  lems whilst preserving ability prune search space simply pruning values maxincc domains  demonstrate usefulness facility show respective variables  global constraints easily speciﬁed essential notion approach concept  cases effectively propagated using simple constraint expres valid assignment valid assignments dual incon  sions method provide toolkit user sistent assignments assignment valid constraint  low cost alternative enterprise designing iff assignment sets containing satisfy constraint  implementing special purpose propagators unusual  valid iff ∀τ scopec ⊆ scopeτ ∧   global constraints appear problem                                                              ∈  τ  →  cτ inconsistent values    ∗this research funded nserc canada              straint unique maximal set valid assignments    †this research funded national ict australia maxvalidc example given constraint xywith        maximal set valid incnotc dvalid       assignments  possible extensions  valid notc dincc        satisfy constraint xy assignments incorc  ck di incci  extended fail satisfy constraint valid andc  ck valid ci    concepts presented inconsistent assignments incandc  ck ditincandc  ck  dual versions valid assignments example valid orc  ck ditvalidorc  ck  dual consistent assignments notion nonvalid  signments assignment  nonvalid itincandc  ck itvalidorc  ck  assignment set τ scopeτscopec ∧   ∅                 valid  ∅  ∈  τ ∧¬cτ example dual    repeat                  repeat                                                                                                support nonsupport assignment set τ non      incci    valid    valid ci                                                                                                        support assignment  constraint iff         d−inc                  d−valid                                                                                                           scopeτscopec∧x     ∈ τ ∧¬cτ nonsupport        ∪        valid   valid ∪ valid                                                                                               witnesses nonvalidity                     untilinc  ∅            untilvalid  ∅                                                            returninc              returnvalid      constraint expressions                             table  functions computing valid inconsistent assign                                                        ments constraint expression addition inctrue  build complex constraints combine primitive valid false d∅ valid true dincfalse dd  straints using negation disjunction conjunction  straint expression primitive constraint constraint expression dp complete general  wellfounded boolean expression form true false results tractable languages identify tractable cases  notc orc  ck andc  ck each ci computing maxinc maxvalid inter  self constraint expression true primitive constraint ested computing inconsistent assignments arbi  valid whilst false inconsistent trary constraint expressions intractable general  allow expressions impliesc iﬀ propose simple light weight method comput  xorc ifthenc regard addi ing subsets maxinc maxvalid polynomial time  tional connectives abbreviations               method compositional computing inconsistent   impliesc ↔ ornotc                    valid assignments constraint expression        iﬀ   ↔ andornotc   ornotc   inconsistent valid assignments parts                                                  straint expression variable domains functions       xorc ↔ andorc ornotc notc incc valid return subsets maxincc  ifthenc ↔ andornotc orc maxvalidc respectively functions recursively apply                                                        rules table  reach primitive constraints    each constraint expression represents new constraint assume each primitive constraint polytime al  scope equal union scopes prim gorithm compute inconsistent valid assignments  itive constraints assignment set τ satisﬁes iff algorithm optimized simple caching  scopec ⊆ scopeτ boolean expression represent scheme remember previously computed                                                      value incci each subexpression ci subse  ing evaluates true given truth values component                primitive constraints τ example absolute value quent incci  identical restricted  constraint  absy  written constraint ex variables scopeci reuse previ  pression iftheny ≥  yx  −y  similarly max ously computed result incci similar optimization  constraint  maxyz written constraint works valid ci addition compute prune  expression andx ≥ yx ≥ orx  yx          inconsistent values incrementally stop soon    constraint expression constraint variable domain wipeout  sociated constraint expression maximal  set inconsistent assignments maxincc maximal  entailment disentailment  set valid assignments maxvalidc make constraint expression entailed iff holds possible  constraint expression generalized arc consistent prun assignments constraint disentailed iff does hold  ing assignments maxincc useful ob possible assignment show valid  serve duality valid assignments inconsis returns valid assignments valid equals  tent assignments implies maxinc cmaxvalidnotc domains variables scope  xa  ∈  maxinc ↔  ∀τxa  ∈  tau →  ¬cτ ↔     entailed situation modify computation  notcτ ↔ xa  ∈ maxvalidnotc                 valid valid dd note include                                                        domains variables scopec    constraint propagation                             similarly incc equals domains vari    surprisingly nphard compute maxinc ar complexity class dp contains problems  bitrary constraint expression precisely deciding set junction problem np conp papadimitriou  assignments maximal inconsistent set arbitrary yannakakis ables scope disentailed modify simple example bound reached consider  computation incc dd           andc  cn ci xi  xi inand −    show beneﬁt consider impliesevenxoddy  xn  suppose domainxi    dx           nowevery           ﬁrst iteration itinc returns   incimpliesevenx oddy  valid evenx value supported − xn    ∩   incoddy  using unmodiﬁed versions   pruned second iteration returns    valid evenx return just valid values whilst value supported   incoddy  returns just inconsistent values  nth iteration returns xn   compute set inconsistent assign pruned th iteration returns   ments impliesevenx oddy  note value supported − xn   domainx  contains numbers evenx  nd iterations values variables  entailed modiﬁed valid evenx removed note stop ﬁrst variable  return case incimpliesevenx oddy  domain wipeout − iterations    d∩   incoddy  dy  required  maximal set inconsistent assignments                maximality                                                        functions compute maximal sets    correctness                                      maximal sets computed primitive constraints  prove valid correct composed surprising given  return inconsistent valid assignments respectively computing maximal sets arbitrary constraint expres                valid                               sion intractable general following result precisely  theorem           correct assuming incon                 sistent valid assignments correctly computed characterizes returns maximal inconsistent set  constituent primitive constraints                    assignments words following result identiﬁes                                                        exactly pruning values returned ensures  proof  induction structure constraint ex constraint expression gac  pression base case holds assumption step case start number deﬁnitions hypergraph  uses case analysis                                    eh   set vertices hyperedges                             notc     constraint expression          each subset hypergraph  incnotc  dvalid                                 induction acyclic tree decomposition flum et al  iff             valid   signments          valid tree satisfying  onetoone correspondence                           notc   signments inconsistent     dual argument  hyperedges nodes  hy                           valid notc   shows assignments           valid   peredge corresponding tree node called t’s label                             andc       constraint expression         wehave     labelt  vertex ∈hthe set nodes  valid     valid              ∈                             suppose               ∈ labelt form subtree  hyper  valid  ∈ valid ci dby graph conjunctive disjunctive constraint expression  induction hypothesis assignments each valid  andc  ck  orc  ck variables  valid consider assignment set τ  scopec vertices sets variables scopeci  ∈ τ scopec ⊆  scopeτ  valid    hyperedges relax deﬁnition  each ci τ satisfy ci satisfy account disentailment  andc  ck  conjunction  valid cforc    ignore entailed subexpression constructing hy  incandc ck similar argument shows pergraph similarly  orc  ck ignore  signments incci inconsistent deleting disentailed subexpression relaxation deﬁne  assignments cause consistent assignment conjunctive disjunctive constraint expression acyclic                                 lose support incci  reduced domain corresponding hypergraph acyclic tree decompo      still return inconsistent assignments itinc sition example conjunction primitive  computes  incci reach ﬁxed point   straints chain each variable com    similar arguments hold constraint expressions mon previous constraint acyclic acyclic  form orc  ck                                 ity general chain use                                                        acyclicity characterize computes maxinc    termination                                                        theorem   constraint expression vari  itinc itvalid functions require linear able domains incc dmaxincc  size csp number iterations reach ﬁxed point                           incc  worst case                                          primitive constraint                                                            maxincc            itinc    itvalid   ond  theorem                  iterations reach    notc valid dmaxvalidc  ﬁxed points constraint expression variables  orc    incc  dmaxincc                                                                                           domains size  exist constraint expressions  ∈    Θnd iterations reach ﬁxed point                                                                andc  ck incci  proof  each iteration removes value  maxincci ∈    acyclic  reach ﬁxed point nd steps scopeci ∩ scopecj≤ ∈    incc dd                                      characterizes arc consistency achieves gac                                                        conjunctions binary constraints main difference  proof  immediate              valid                           tween result previous results     suppose           maximal      place restriction arity primitive constraints   ∈ valid exists τ  ∈ τ  ¬c τ                     incnotc   τ    result does depend bounded tree width                               tree width constraint graph large ar  assignment prevents inconsistent  incnotc                                        ity primitive constraints given primitive constraints               maximal                             gac efﬁciently computed matter     suppose incci maximal consider   ∈  incorc         ∈       incc    arity result characterizes efﬁciency                            ≤i≤k           lifted complex combinations constraints    ∈ inccj ∈   kas  inccj maximal exists τ  ∈ τ  applications  τ                  incorc    τ                             demonstrate usefulness constraint expressions  assignment prevents inconsistent                                                        propagation algorithm show wide range  incorc  ck maximal              ∈ scopec      ∈d        ∈   global constraints speciﬁed propagated     suppose                                using simple constraint expressions cases light  incc show   ∈ maxincc let  dc  d−incc                                      weight propagation algorithm able achieve gac                    consistent assignments remain method effective low cost means implement  ing variable domains table  observe                                                    constraints especially valuable  incci ∅  condition maxincci ∅       ∈                                     straints useful particular problem specialized           consider acyclic tree decomposition user’s constraint toolkit  associated orient tree root labeled      scopec               ∈ scopec                    note  domain   constraint channels variable  property  acyclic tree decomposition condi sequence  variables representing pos  tion each subtrees ci sible values taken variable precisely  variable common subtrees furthermore domainx  xn ensures  iff xi refalo  subtrees variable common variable  decompose disjunction  scopeci           ∈dc                       τ                    orandx   xn                support              andx       τ ∈dc extend support downwards                                                                           tree decomposition children cj   cj  each equality constraints each conjunct vari  child cj shares variable ci say  ables common pruning values returned                                                     assigned value τ say   ∈d enforces gac                     τ            τ  ∈dc  support    element   constraint indexes array           τ              andc                extend support   each child variable van hentenryck carillon  pre                       τ                           furthermore supports individual children cisely elementix  xnj holds iff xi  jwe                          conﬂict share variable al use look price particular component                 τ       τ     τ               τ  ready assigned  agree included conﬁguration problem decomposes  each value assigned variable simple disjunction  extend τ support ci’s children                                                            orandi    andi     argument each support τ child cj                                      extended support conjuncts equality constraints each conjunct share vari  subtree cj τ extended support ables pruning values returned enforces   ∈ τ   ∈ maxincc gac             andc        note       contains entailed conjuncts member constraint ensures particular value  eliminated changing maximal set                                                        used precisely memberix  xn holds iff  inconsistent assignments apply argument                                                        exists xj  decompose  remaining acyclic conjunction disjunction                    maxincc ⊆d        immediate                                                orx    xn     fact show ﬁve cases                         ones guaranteed maximal pruning values returned enforces gac  reverse direction needs little care compute max constraint computes maximum  value  maxinc chance ﬁve cases taken sequence variables   precisely  ones irrespective constraint subexpressions maxnxxn holds iff exists  xi  guaranteed compute maxinc dual result holds xi ≥ xj jamax constraint decom  characterizes precisely valid computes maxvalid posed disjunction    previous related results shown acyclic database orandn  xx ≥  ≥ xn  queries bounded tree width tractable bounded tree    andn   xx ≥  xx ≥   ≥ xn  width tree width known condition      andn  xnxn ≥  xn ≥ xn−pruning values returned decomposition constraint limits number variables  enforces gac                                         taking values set beldiceanu contejean                                                         precisely amongx  xn  dmn holds  channelling    constraints advantageous    ix     specify multiple viewpoints problem constraints iff           constraint useful                                                        resource allocation scheduling problems introducing  easier specify viewpoint propagate better           channelling constraints needed link additional variables accumulate count  different viewpoints example multiple viewpoints decompose relatively simple constraint expres  proved useful orchestra rehearsal problem prob sion  csplib channelling constraints used andifthenx ∈    speciﬁed constraint expressions                         ifthenx ∈                                                                  ifthenxn ∈  nn−  nn−            iﬀ xi  orxi− yi            iﬀ zk  andxj xj−               xi ∈  abbreviation orxi   xi                                                         dm  problem contained specialized optimality unfortunately does achieve gac  straint speciﬁed constraint expression                                                        composition consider example ∈                                                           ∈         ∈                  impliesxywx                                                   enforcing gac                                                        amongxx   prune    wx   speciﬁed element   whilst returns set similar decompositions  constraint                                           results hold atmostatleastchange                                                        count  constraints  lex constraint lexicographically orders vectors  variables applications dealing sym notallequal constraint ensures vari  metry frisch et al  decompose dis ables value beldiceanu contejean   junction                                             precisely notallequalx  xn holds iff                                                        exists xi   xj decomposed      orx                                        following constraint expression          andx   yx          andx   yx   yx                             orx      xn          andx    xn−  yn−xn ≤ yn                                                        pruning values returned enforces gac  constraints each conjunct share variables prun nvalue constraint counts number values  ing values returned enforces gac lex used sequence variables pachet roy   constraint addition memoize previous results precisely nvaluex  xnn holds iff xi ≤ ≤  comparable efﬁcient algorithm frisch et al  constraint useful wide range prob                                                  lems involving resources alldifferent constraint    choice decomposition global constraint im special case nvalue constraint   portant ensuring propagation possible unfortunately nphard general enforce gac  instance alternative decomposition conjunction nvalue constraint bessiere et al                                                           way propagate constraint polynomial time   andx ≤        impliesx    ≤                       decompose additional set  variables repre                                                    senting characteristic function set values used       impliesandx   xn−  yn−xn ≤ yn                                                              andiﬀ  orx xn   pruning values returned decomposition                                                                  iﬀ sm  orx   xn   enforce gac lex constraint consider                                                                               si   ∈       inconsistent assignments ap domains xi assumed   plied decomposition return set surprisingly does compute maximal set  value  precedence    constraint breaks symme   inconsistent assignments constraint expression                                                                         ∈  ∈      tries sequence variables xn caused example suppose                                                                                         ≤  ≤        indistinguishable values law lee                returns set                                                                            decompose simple conjunction                     inconsistent                                                          similar decomposition result holds common      andx   impliesx            constraint nphard propagate          impliesxn  orx   xn−                                                            related work  theorem  law lee  shows enforcing gac lhomme proposed gac algorithms logical combi  each conjunct achieves gac global constraint nations primitive constraints focused primarily  each conjunct expands simple disjunction pruning given extension lhomme  example  values returned enforces gac global disjunction like orc  ck algorithm tests each  straint
