              callgraph caching transforming programs networks                                               mark perlin                                        school science                                        carnegie mellon university                                           pittsburgh pa                       abstract                          caching callgraphs                                                         paper present new program transformation       programs use   callgraph caching cgc partially evaluates       flow control run different inputs reuses programs control structure       redundancy program execution traces     provide applicability conditions use       exploited preserving suitably abstracted        cgc       callgraphs subsequent reuse introduce    present working prototype eval       new programming transformation callgraph             performs partial evaluation lisp programs       caching cgc partially evaluates con•      executable callgraphs       trol flow sets programs network       formed callgraphs cgc               show cgc helps conceptual       automatically generate efficient statesaving         implementational derivation efficient state      structuresharing incremental algorithms         saving structuresharing incremental network       simple program specifications example         algorithms       show straightforward inefficient lisp       program conjunctive match automatically       illustrate cgc exploits fixed      transformed rete network algorithm          graph structure reverse flow com•      simple understandable changes elegant          putation data flow callgraph in•      functional programs automatically     stead moving topdown       translated cgc new efficient incremental      program program execution       network algorithms abstraction mechanism     driven incremental changes input data       shown class conjunctive matching al•         instead rigidly preset       gorithms establish criteria appropriate utility cgc demonstrated       application cgc ai methods      using cgc transform simple inefficient       planning chart parsing consistency maintenance     lisp program conjunctive matching       analogical reasoning                             classic rete match algorithm forgy                                                              demonstrates use    introduction                                            automatic transformation prototype eval                                                            showing applications cgc ai   caching general efficiency mechanism exploiting  indicating small changes   redundancy computation reusing previously computed  conjunctive match lisp program   information example ai systems cache problem  mechanically generate alternative network join   solving experience learned time knowledge set topologies transformations enable   programs intelligent interactive systems apply   researchers spend minutes modifying short   program set repeated cycles interaction external functional programs instead months   data input define persistent intelligent inter• engaged lowlevel network programming   active systems apply knowledge data                                                            suggesting cgc uniquely suited ai   cycle straightforward implementations persistent sys• potentially increases efficiency   tems inefficient programs persistent knowledgebased systems   knowledge base relevant each cycle potentially   reusable intermediate computations discarded     cgc differs ordinary data instruction     identified key source computational redun• caching baer  control decisions data   dancy programs flow control callgraph struc• actions stored unlike function caching pugh    ture controlflow redundancy exploited cgc caches network traces computed function values                                                       cgc observes records removes control decisions                                                       program executing input program                                                       dependence graph methods ferrante  diminish                                                       control flexibility     work supported grant lm  introducing cgc transformation section   national library medicine pittsburgh nmr  show transform matching programs   institute                                          rete networks section  present number     callgraph trace executing programs flow uses cgc ai section    procedural control recursive languages like lisp   explicit tree programs dynamic procedure calls        tools  callgraph caching                                               tion directed just changes input                                                                      coupled finite differencing statesaving incremental   callgraph caching program transformation ar           algorithms result   bitrary programs network programs defining              price efficiency inflexible control structure   notion program establishing network           network program dags restricted form   programs motivate control flow              basic blocks aho  despite limitation net•  program cached netwoik present         work finds extensive application efficient incremental   mechanics transformation implemen•        spreadsheets use algorithm sketched conjunctive   tation                                                           matching programs cast network form ef•                                                                    ficiency potential applications include represen•   programs                                                      tation dependency relations multiple inheritance consis•  programming languages provide action constructs              tency maintenance reasoning doyle  incremen•  operate input data sequenced according control        tal attribute grammar evaluation reps    organization actions applied data   evaluator lisps eval partially          caching control flow   determine control sequencing program execution               let pxy program language having ar•  proceeds traversing programs actions according         guments suppose ps control structure inde•  control organization evaluating actions       pendent partial evaluation futamura    data example lisps control mechanism recursion         pxy respect fixed xo yield new     coordinates expression actions data ar•            program pxy argument having unique  guments symbols lists traversal lisp           graph   programs code tree recursively executes eval                 interactive programs input depends external   xexpressions arguments each node tree             factors independent external interactions sup•                                                                    pose program pxy interactive argument    network programs                                                                     independent external factors py   programs operate traversing acyclic                completely characterizes pxys interactions   network actions programs reside ex•                  external environment   ecuted network nodes control organization   represented netwoik links links directed                 unique callgraph   acyclic graph dag encode partial ordering             define interactive program pxy basic   nodes programs netwoik traversals guaranteed           independent external factors ps control structure   respect partial ordering belong class net•         independent   work partial order enumeration usually implemented               py unique callgraph cached   version topological ordering knuth           network program later reuse programs actions   assures dag node visited exactly          encoded callgraph nodes each node allocated   each predecessors visited                 local memory programs control flow decisions     input data presented leaves computations        recorded callgraph edges applying input data   propagate through network results local node          callgraph leaves bottomup graph traversal respecting   computations locally stored node memory              nodes partial ordering represented edges   node uses memories predecessor nodes bottomup              correctly execute program new   network computation similarly stack frames use           network program operationally equivalent par•  recursive return values usual programming languages           tially evaluated illustrated figure    netwoik persists cycles finite   differencing paige  reduce redundant computa•  tions node implement incremental strategy   node memory divided shortterm buffer   longerterm store use shown     network programs efficient overhead   linear idagi number nodes   edges hoover  propagating leaves   keeping newly computed values nodes buffer memory   topological ordering assures each node recomputed   exactly perlin changes   subset dag leaves using store memory per•  sists change cycles computation need   propagated transitive closure dag subset af•  fected iaffectedi  idagi produces   statesaving algorithms perform minimal recomputa        initial focus sections   functionalstyle lisp   programs section  look programming language   styles rules                                                                       efficiency gains possible restricting dag       graphs cycles admissible long cycles  traversal subgraph influencing select node computa•  broken run time graph acts like dag          tions                                                                                                                      perlin    transformation                              partially evaluated py preserved callgraph    callgraph caching cgc transformation second step controlflow caching connects ex•   loosely coupled steps step assembles ternal input programs graph shown figure    callgraph subgraph components second  step  resulting callgraph complete program    collects set callgraphs network resulting dag    cached callgraph network structure used reused step operationalizes callgraph us•   data cache pedagogical examples simple polynomials able data structure example graph nodes aug•   detailed perlin                   mented requisite buffer store memory                                                       systemspecific representation     building callgraph                        point saving reusing just single     controlflow caching algorithm builds graph provides fully functional statesaving network    callgraph program input construction program directing input through graph partially    takes                                           ordered node enumeration node memories                                                       data cache perform computations pxoy       • input                                  efficient incremental evaluation finite differencing ef•             compiletime text program    fected using local buffer memory  record             partial input      tracycle computations  differentially update local             runtime program executing   intercycle store memory              complete input                       collecting callgraphs       • outputs callgraph program         callgraph caching transformation completed    procedure employs auxilliary data structure collecting set pxoy callgraphs variety ps    conxrolflow cache used assembly xos set called callgraph cache like    final callgraph structure optional ar• caches usually employs efficient cache management    gument specifying key execution steps cast graph strategies example spreadsheets conjunctive    nodes                                             matchers exploit common shared prefix structure      controlflow caching proceeds three separate steps trielike aho  merging callgraphs single    program partial input userdefinable connected network allocating limited resource    set key steps abstract trace formed space common strategy perform    programs execution each node resulting callgraph costbenefit analysis detemiining callgraphs stay    represents key step programs trace actual cache removed    formation callgraph facilitated specific control   flow cache management strategies strategy  using callgraph cache    abstraction mechanism recording key building callgraphs pxiy  col•   steps nodes strategy used chart    lecting callgraph cache resulting network    parsing winograd  ls exploiting constraints used reused data cache values sets values    posted controlflow cache help reduce execut• propagate bottomup through network employing    ing programs computation dynamic programming buffer memory each propagation cycle store    say lisp program passively memory cycles efficiency correctness    cache succession execution branches network traversal control mechanism partial order    tree regardless specific strategies resulting enumeration implemented topological sort    graph captures space programs execution time completes transformation finite set basic    shown figure  step                       programs programming language efficient                                                       statesaving network program                                                        implementation                                                       demonstrate workability callgraph caching                                                       implemented common lisp simple partial evaluator                                                       eval transforms large class lisp programs                                                       corresponding callgraphs input eval                                                       symbolic lisp expression representing pxoy                                                       xq set labels denoting key execu•                                                      tion steps cache output callgraph each                                                       node specifies                                                           • label node type                                                  • lambda expression containing infor•                                                           mation required execute nodes computa•     figure  controlrow caching assembling callgraph tion applied values immediate                                                            predecessor nodes      program pxy far evaluated input xq                                                             caching programs execution     userdefinable set ranges set possible time breaks unravels cycles present flow   steps                                             trol      tools      • recursively nodes immediate                    applies set tests set objects producing         predecessors                                               filtered set ntuple instantiations      eval performs following computations                        production systems persistent         arrive label key node lisp                  maintain knowledge finite set ex          function symbol abstracted                             perientially derived programs rule set                                                                                     perform eval unevaluated arguments           function                                                 apply programs available data                                                                             each interactive cycle         substitute values function                                                                     inefficient consider just rule having           execute eval lisp functions                                                                     conditions matching data objects set           code tree                                                                     candidate instantiations dn grows exponentially   delayed evaluation recursively caching          fact conjunctive rule matching nphard minton    control structure callgraph callgraphs nodes       generally small fraction object set   abstract set labelled functions preserving lo•    changes each cycle instead rigidly applying rule   cal actions required later execution                         programs data incremental changes      developed variety network structure         data drive matching computation   sharing programs merging callgraphs partial or•          each rule program rule set specifying   der network traversal toolkit executing cached          tests tests atocitestsd computationally ex•  callgraph networks programs working implemen•            pensive subprogram observe   tations demonstrated efficacy transforming                                                                           match  tests    simple lisp specifications efficient incremental net•  work programs ai examples rete matching                     independent external data input                                                                                rete networks example callgraph                               conjunctive matcher pxy programm•  caching                                                                   able ps control independent                                                                             section    rete matching statesaving structuresharing in•             basic callgraph caching generate   cremental algorithm used ops production            efficient statesaving structuresharing incremental   systems conjunctively matching patterns          matching algorithm   objects provides excellent averagecase   behavior important nphard ai problem          transforming rule matching rete networks   extensively studied varied good example      illustrate use callgraph caching generating   callgraph caching program transformation illustrating       rete network simple functional programming   nontrivial usage controlhow cache           specification matching function   graph cache                                                                            stan easily specified in•                                                                            efficient set functional programs    rule matching   forwardchaining rule systems production systems                 using auxilliary controlflow cache par•  ops programming languages match                     tial evaluation basic program   control element program data organized set               matchtx produces callgraph capturing   rules having lefthandside lhs tests rhs actions              matchds control flow callgraph   external input called working memory comes                 usable incremental datadriven   slowly varying set data objects rules tests                 statesaving network program   match objects rule candidate firing              store processed input data intermediate   executed actions serve modify                                  matching results      following common practice fix form rules              callgraph cache merges individual   lhss set conjunctive conditions each condition                callgraphs order conserve space   containing tests restricting set matchable objects             achieve speedup test   instantiation rule having lhs conditions ntuple             sharing nodes common test prefixes   objects satisfying rules lhs tests inter•               combined form single trie data structure   action cycle rule evaluator try match each rule   possible combinatioas objects forming        construction rete network algo•  set instantiations                                         rithm                                                                      rule matching lisp programs                                                                          rule specifies fixed set tests match com•                                                                    ponent conjunctive match program matchtd                                                                     formulated control independent working                                                                     memory write filter match                                                                     functionalstyle lisp program                                                                        efficiency serial processor impose                                                                     fixed ordering rules conditions each test examines                                                                       objects candidate ntuple dn                                                                     objects ordered condition ordering                                                                     order test set associate each test number                                                                                                                       perlin   object examines arrange tests respect    index efficiency match performed    conditional testing candidate ntuple    test subset second through nth    kth test subset  tests    grouped classes        alpha tests single object        beta tests object          tuples € dk      ways write lisp code    simple filter function iteratively recursively    cgc transformation independent pro•   gramming style clarity present match using linear    recursion     match rules tests data    define match tests data        betajoin            tests            second tests            data     join preceding sift     join sets filtering beta test    define betajoin        null            mo            filter                setproduct                    alphasift                    betajoin                        rest rest     sift objects alpha tests    define alphasift        setfilter                                       figure  cgc linearly recursive conjunctive matcher      match takes preordered set tests set data    objects arguments key interesting function changes object set ad needed computing fur•   betajoin merges simple alphasift filter fur• ther instantiations callgraph incremental    ther recursive calls betajoin produces linearly statesaving datadriven network program comput•   recursive callgraph note tests matchs tests ing state single rules match    argument deposited locally each level filtering surprising figure  shows rete net•   control decisions using data argument work beta join topology isomorphic match      auxilliary function setfilter returns subset satis• callgraph figure     fying predicate tests function setproduct    operates similarly pair sets                      collecting callgraphs                                                                rule comprised finite set rules     building callgraph                             form corresponding set callgraphs      step  mle calling eval                 each rules match component set callgraph    matchitcsts set labels match alphasift cache cache management strategy conserving    betajoin save calling structure rules tests cache space associated speedup merge   controlflow cache used functional program callgraph dags connected network    match store growing tree shown figure matchers behavior unchanged proceeding     callgraph linear spine appropriate data input source nodes merged based prefix sharing    tests localized each node                             tests succession callgraphs merging com•     step  figure  free input variable data  mon betajoin node trie depicted figure     attached callgraph input source turning alpha discrimination net added beta join    tree dag                                          trie classical rete match network generated      step  graph structure single rules match implemented addition modifying alphasift lisp    component completed memory intra     function perform tests tail recursively illustrates    cycle buffer intercycle store         cgc readily produces new desired network topologies    information specialized specific graph     small changes lisp program specifications    representation callgraph reused   network filtering program figure            using callgraph cache    domains filtered objects shown                  partial order traversal rete network perform      using buffer memory partial order traversal match rule set cached shared set   callgraph data computes filtered instantiation graphs working memory input intracycle    subset dn nodes longerterm store memories buffer intercycle store memories each node used    initially loaded continually updated data cache preserve partial match computations      tools 
