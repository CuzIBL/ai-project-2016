                  ordering heuristics description logic reasoning                                      dmitry tsarkov ian horrocks                                        school science                                          university manchester                                              manchester uk                                      traskovhorrockscsmanacuk                        abstract                          tion known trace technique uses topdown                                                        struction requiring pspace logics polynomial space      present new  architecture description    order delineate tree structure exponential      logic implementations range new optimisa   size respect size input concept      tion techniques empirical analysis exptime logics implemented modern systems      effectiveness                                    guaranteeing polynomial space usage longer                                                        option logics support inverse roles    introduction                                       shiq strictly approach longer possible  description logics dls family logic based knowl constraints propagated “up” “down”  edge representation formalisms  edges tree  range applications conﬁguration mcguinness  alternative architecture tableaux imple  wright  reasoning database schemas mentations uses set queues instead adap  queries calvanese et al tion standard topdown approach architecture  haps best known basis widely used ontology lan implemented new fact  guages oil damloil owl    horrocks et  number advantages compared topdown ap  al  dls providing formal proach firstly applicable wider range log  pinnings languages declarative semantics ics including expressive logics implemented modern  dl systems used provide computational services systems makes assumptions structure  ontology tools applications knublauch et al  graph particular tree shaped  rectore                                        order graph constructed secondly    modern dl systems based tableaux algo  allows use powerful heuristics try im  rithms algorithms ﬁrst introduced schmidt prove typical case performance varying global order  schauß smolka schmidtschauß  smolka  different syntactic structures decomposed  subsequently extended deal expressive log topdown construction heuristics operate  ics baader et al  systems implement local region graph—typically single vertex  shiq   dl tableaux algorithm ﬁrst pre  sented horrocks et al  logic expres  preliminaries  sive corresponds closely owl ontology language present brief introduction dl particular  spite high worst case complexity satisﬁabil shiq syntax semantics reasoning details  itysubsumption problem logic exptimecomplete reader referred baader et al   highly optimised implementations shown work  realistic ontology applications horrocks  description logics                                                  syntax let set role names transitive    optimisation crucial viability tableaux based normal role names ∪rp  ∩rp  ∅  systems experiments using artiﬁcial test data set shiqroles roles short r∪r−  ∈  application ontologies relatively unoptimised systems let nc set concept names set shiq  formed badly orders concepts concepts short smallest set  magnitude slower optimised systems cases concept ∈ nc concept  hours processing time cases hundreds concepts role simple role ∈  hours proved insufﬁcient unoptimised systems solve ¬c ∀rc ∃rc nrc  problems took milliseconds optimised nrc concepts called respec  massacci  horrocks  patelschneider  tively value exists atmost atleast restrictions  modern systems typically employ wide range optimisa possibly inverse roles called  tions including described baader et al role inclusion axiom ﬁnite set role inclusion axioms   horrocks  patelschneider               called role hierarchy possibly complex    tableaux algorithms try construct graph usually  tree representation model concept structure simple role transitive tran  determined syntactic decomposition sitive subroles restricting number restrictions simple roles  cept implementations employ space saving optimisa required decidability horrocks et al concepts called general concept inclusion gci negation pushed inwards using rewritings  ﬁnite set gcis called tbox             morgan’s laws applies atomic concepts  semantics interpretation  ∆i  ·i  consists non example expansion rule conjunction causes  set ∆i  domain function ·i maps added node label containing                                                    order guarantee termination side conditions prevent rules  role subset ∆ × ∆ ∈ applied change graph                               −i                 ∈ hx yi ∈ iff hy xi ∈  hx yi ∈ labelling  hy zi ∈ ri hx zi ∈ ri  interpretation func forms nondeterminism expansion  tion ·i interpretation  ∆i  ·i  maps additionally procedure ﬁrst place rules simultane                                                      ously applicable order rule applications  concept subset ∆              chosen correctness perspective choice usually      di  ci ∩ di  di    ci ∪ di        irrelevant model          ¬ci  ∆i   ci                               expansion ordering later order      ∃rci    ∈ ∆i  ri  ∅            expansion big effect efﬁciency second                                                        place rules expand graph nondeterministically      ∀rci    ∈ ∆i  ri ¬c  ∅                                                  expansion rule disjunction causes     nrc     ∈ ∆             added node label containing     nrci    ∈ ∆i  ri             correctness perspective choice relevant                                                      cause choice lead successful construction  cardinality set model does usually dealt  ﬁned  hx yi ∈ ri ∈ ci                 backtracking search search  interpretation satisﬁes role hierarchy iff ri ⊆ si worst case consider possible expansions order  each ∈ satisﬁes tbox iff ci ⊆ di considered big effect efﬁ  each ∈  interpretation called model ciency                                              kinds rule particular fol    concept satisﬁable wrt role hierarchy lowing discussion nondeterministic rules trule  tbox  iff model ci  ∅ mentioned generating rules ∃rule  interpretation called model wrt  add new nodes graph applying rules  usual expressive dls subsumption reduced likely “costly” increase size  satisﬁability reasoning wrt tbox role hierarchy graph increase size search space  reduced reasoning wrt role hierarchy hor typically applied lower priority rules  rocks et al                                      fact   architecture    tableaux algorithms                              discussed implementations use topdown  basic idea tableau algorithm expansion based trace technique idea  concept role hierarchy try prove expansion apply ∃rule lowest priority  satisﬁability wrt constructing model apply rule rule applicable  wrt syntactically decomposing added reﬁnement trace technique discard fully ex  derive constraints structure model panded subtrees single “trace” branch  example model deﬁnition contain tree kept memory time  individual element ci  technique advantage simple  form ∃rd model contain individ easy implement—a procedure exhaustively expands  ual hx yi ∈ ri element di  node label applied current node recur  nonatomic continuing decomposition sively each successors does  lead additional constraints construction fails drawbacks ﬁrst place logics inverse  constraints include clash obvious contradiction roles topdown method simply breaks relies  individual element fact rules add concepts label  ¬c concept algorithms normally designed node applied label  guaranteed terminate guaranteed successor nodes result rules  construct model exists algorithm clearly exhaustively applied given node label expan  decision procedure concept satisﬁability         sion label possible presence inverse    practice algorithms work tree shaped graph roles expansion rules add concepts labels  close correspondence model predecessor nodes require expan  cause models nonﬁnite obviously sion discarding fully expanded subtrees  ﬁnitely representable nontrees usually tree longer possible expansion concept added  like typically labelled graph usually tree label predecessor cause concepts added  collection trees nodes represent individuals label sibling node previously fully  model labelled set concepts expanded  instances edges represent role relationships second place method forces non  tween pairs individuals labelled set role deterministic rules applied higher priority  names                                                generating rules size search space caused    decomposition construction usually carried nondeterministic rule expansions practice  applying called tableaux expansion rules concepts  node labels rule deﬁned each correctness algorithms requires priority  syntactic constructs language exception ordering different rulesfar problem tableaux based systems problematical given range possible heuristics choos  horrocks  advantageous apply non ing best use given type problem  deterministic rules lowest priority giunchiglia  far heuristics tried dl reasoners mainly  sebastiani  fact topdown implementations typ adaptions developed sat reason  ically apply nondeterministic rules priority ers known moms heuristic freeman  lower rules generat  jeroslow wang’s weighted occurrences heuris  ing rules horrocks  patelschneider          tic jeroslow  wang  proved largely  todo list architecture fact designed effective degrade performance adverse  intention implementing dls include inverse interaction backjumping baader et al  al  roles investigating new optimisation techniques ternative heuristic ﬁrst presented horrocks  tries  cluding new ordering heuristics currently fact imple maximise effect dependency directed backtracking  ments shif slightly expressive variant shiq backjumping preferentially choosing expansions  values atleast atmost restrictions troduce concept “old” dependencies heuristic  zero                                      relatively little effect performance real    instead topdown approach fact uses todo istic problems problems encountered reasoning  list control application expansion rules ba application ontologies  sic idea approach rules appli conjecture standard topdown architecture  cable concept added node label contributed difﬁculty ﬁnding useful heuristics  happens note nodeconcept pair added todo rules possible choices ruleordering particu  list todo list sorts entries according order lar topdown technique require generating rules  gives access “ﬁrst” element list   applied low priority lead nondeterministic    given tableaux algorithm takes entry todo rules applied deterministic generating rules  list processes according expansion rules rele contrast todo list architecture gives wider range  vant entry during expansion process new possible rule orderings allowed investigate  concepts added node labels entries range new ruleordering heuristics particular heuris  added todo list process continues tics nondeterministic rules lowest priority  clash occurs todo list           factor contributed weakness sat    fact implement todo list architecture derived heuristics treat concepts  set queues fifo buffers possible set priority atoms obviously appropriate case  each rule type ∃ separate queue im propositional satisﬁability case concept sat  plemented each unique priority expansion isﬁability subconcepts complex structure  algorithm asks new entry taken nonempty investigated expansionordering heuristics  queue highest priority algorithm terminates account structure particular concept’s size  queues means ∃rule maximum quantiﬁer depth frequency usage  low priority say  rules knowledge base  priority say  expansion modulo inverse implementation fact fact reasoner uses  roles topdown breadth ﬁrst stacks lifo buffers standard backtracking search technique explore differ  used instead queues priorities ent possible expansions offered nondeterministic rules  expansion simulate standard topdown method trule applying nondeterministic                                                        rule current state saved backtracking    heuristics                                         state restored reapplying rule dif  implementing reasoning algorithms heuristics ferent expansion choice inverse roles supported  used try ﬁnd “good” order apply infer possible sequence deterministic rule applications  ence rules ruleordering heuristics propagate changes graph  nondeterministic rules order explore fore necessary save restore graph struc  different expansion choices offered rule applications ture addition data structures todo  expansionordering heuristics aim list fact trys minimise potentially high cost  choose order leads rapidly discovery model operations lazily saving graph saving parts  case input satisﬁable proof model graph necessitated expansion  exists case input unsatisﬁable usual technique cost saving state makes expensive apply  compute weighting each available option nondeterministic rule state restored dur  choose option highest lowest weight ing backtracking  “art” devising useful heuristics ﬁnding suit discussed section  fact uses todo list ar  able compromise cost computing weight chitecture separate queues each priority level dif  ings accuracy predicting good orderings ferent ruleordering heuristics tried sim    heuristics effective improving ply varying priorities assigned different rule types  performance propositional satisﬁability sat reason low priorities typically given generating non  ers freeman  ﬁnding useful heuristics descrip deterministic rules todo list architecture allows dif  tion modal logics proved difﬁcult choos ferent priority ordering rule types contrast  ing good heuristic choosing bad topdown architecture forces lower priority given  important inappropriate heuristic simply fail generating rules  improve performance seriously degrade fact includes range different expansion                                                        ordering heuristics used choose order    shif  corresponds owllite ontology language hor explore different expansion choices offered  rocks et al                                   nondeterministic trule ordering basis size maximum quantiﬁer depth frequency tests fact used pentium  age each concepts disjunction order   ghz machine mb memory running linux  ascending smallest size minimum depth times averaged  test runs  lowest frequency ﬁrst descending order avoid  ruleordering heuristics  cost repeatedly computing values fact gathers  relevant statistics each concept knowledge tests tried range different ruleordering strate  base loaded caches later use        gies each “strategy” shown sequence letters spec                                                        ifying priorities highest ﬁrst different rule types    empirical analysis                                 “o” refers trule “e” ∃rule “a”                                                        rule type “ao” describes strategy  order evaluate usefulness heuristics imple  mented fact carried empirical analy rule lowest priority rules  sis using reallife ontologies artiﬁcial tests equal higher priority  dl’ test suite horrocks  patelschneider   ontology tests results using different ruleordering    ontologies vary widely terms size complexity strategies various ontologies shown table   structure concepts types axiom used ontologies tested best disjunctionordering  used three ontologies different characteristics order heuristic determined separate tests  heuristics perform each case  winefood  sample ontology makes        kb    dolce    winefood     galen                                                                  sat  sub  sat  sub   sat   sub      owl test suit carroll  roo  small               complex structure includes  gcis           ao           dolce   foundational toplevel ontology developed    aeo             wonderweb project gangemi et al    ae              medium size medium complexity                       aoe         galen   anatomical wellknown medical      terminology ontology rogers et al  large table  ontology tests different ruleorderings       concepts relatively simple structure ﬁrst thing note ruleorderings relatively      includes  gcis                       little effect dolce winefood ontologies    fact  separates classiﬁcation process satisﬁa trast performance best worst strategies dif  bility testing sat subsumption testing sub phases fers factor  galen tests  results sat phase cached used speed galen case difference “o”  subsequent tests standard “modelmerging” optimi strategies assign lowest priority  sation horrocks  patelschneider  fact allows rule “e” strategies assign lowest pri  different heuristics used phases pro ority ∃rule relatively small cases best  cess tests different characteristics result given “aeo” strategy assigning  sat phase nearly tests satisﬁable ontolo lowest priority trule lowest priority  gies typically names unsatisﬁable concepts ∃rule “aeo” best strategy dif  sub phase tests ference best strategy small  satisﬁable measured time cpu seconds taken difference “aeo” “aoe” strategies  fact complete each phase                        small cases factor     addition ontologies used artiﬁcially generated dl tests results using different ruleordering strate  test data dl’ test suite artiﬁcial tests gies dl tests shown table  ﬁrst thing  sense corner cases dl reasoner designed primarily note results ruleordering heuristics  ontology reasoning tests mainly intended signiﬁcant effect ontology tests  vestigate effect hard problems artiﬁcial struc cases performance best worst strategies  tures behaviour heuristics purpose differs factor  tests “e”  selected test suite tests proved strategies best results difference  hard fact                                   “o” “e” strategies marked    each tests consists set  satisﬁability test case ontology tests case test  ing problems similar structure supposedly exponen performance dramatically improved factor  tially increasing difﬁculty idea test determine  “o” strategy used  number largest problem solved  ﬁxed processing time  seconds cpu time test br   br       ph    ph   case names tests form “test p”    time time time time time  “test n” “test” refers kind problem                    “ph” tests derived encodings pigeon ao               hole sorting problems “pn” refers prob aeo            lems test set satisﬁable unsatisﬁable ae            tests reported number largest prob aoe            lem solved  seconds  means  problems solved time cpu seconds table  dl tests different ruleordering strategies  taken hardest problem successfully solved  expansionordering heuristics    ontology weaker claim “real tests tried range different expansionordering  life”                                                heuristics each heuristic denoted letters ﬁrst ofwhich indicates ordering based concept size order br br       ph    ph  “s” maximum depth “d” frequency usage “f”      test  test  test  test  test   second indicates ascending “a” descending sa                       “d” order each group tests used best rule da                       ordering heuristic determined tests section  fa                   ontology tests ontology tests tried different sd                   derings sat sub phases classiﬁcation   dd                      results presented tables    ﬁrst ﬁgure fd                     each column time taken sat phase using  given ordering remaining ﬁgures subsequent table  dl tests different strategies  times taken using different sub phase orderings    dolce table  difference best  analysis  worst orderings factor  possible different ruleordering heuristics tried relatively  derings near optimal winefood table  dif little effect performance reasoner classify  ference best worst orderings factor ing dolce winefood ontologies galen   using sd sat tests dd sub tests gave ontology strategy gave lower priority ∃  best result orderings gave similar trules worked reasonably aeo strategy  results galen table  difference optimal nearoptimal cases crucial factor  best worst orderings large galen giving low priority ∃rule  orderings given allowed tests completed reasonable fact galen large contains gcis  time best result given using da phases contains existential cycles concept inclusion axioms                                                        ∃rd  ∃r−c result graph grow       sat     sa    da    fa    sd    dd    fd         large increases size search space       sub                        gci related nondeterminism apply        sa                      node basis cost saving restoring state dur       da                       ing backtracking search giving low priority ∃rule        fa                      minimises size graph reduce        sd                      size search space cost saving restoring       dd                       effect noticeable ontologies        fd                      cause smaller size andor lower number gcis greatly                                                        reduces maximum size graphs andor search space    table  dolce test different expansionorderings view results fact’s default ruleordering strategy                                                        set aeo       sat     sa    da    fa    sd    dd    fd           picture quite different case dl’ tests       sub                      different strategies make large difference        sa                      strategy universally near optimal ex       da                       pected given tests include little non        fa                      determinism designed force construction        sd                      large models graphs highly       dd                       nondeterministic small models given        fd                      extreme cases representative typical real                                                        life ontologies test results directly relevant   table  winefood test different expansionorderings designed deal ontologies inter                                                        esting badly heuristics behave                 sat        sa     da                   cases fact standard aeo strategy near opti                sub                            mal tests worse optimal                 sa                         strategy factor                  da                           expansionordering heuristics bigger                 fd                        effect ontology reasoning performance rule                                                        ordering heuristics case dolce winefood    table  galen test different expansionorderings strategy uses sd dd sub phase  dl tests table  presents results dl tests near optimal galen using da phases  each column shows times taken using different expan gives far best results character  sion orderings solve hardest problem solvable istic structure ontology fact preferentially  stipulated time limit using ordering  choosing concepts low modal depth tends reduce    test difference best size graph unfortunately strategy univer  worst strategies large factor  sally good dada best galen worst dolce  test strategies good test winefood currently sddd default setting  bad sd dd strategies best ones majority real life ontologies resemble dolce wine  branch tests br br far worst food galen course changed  test strongly dependent satisﬁ  ability result br tests strategies perform similarly topdown architectures necessarily lowest priority  satisﬁable unsatisﬁable cases fd strategy ∃rule generally low priority trule  optimal near optimal cases work relatively ontologies
