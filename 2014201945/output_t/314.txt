session  software support                                                                                  procedural embedding                      theoretically terms notion             knowledge planner                        satisfiability problem                                                         completeness foundation                   carl hewitt                           mathematics intuitively                                                         satisfactory true formulas   artificial intelligence laboratory                   proveable foundation   mit cambridge massachusetts                     mathematics alms theory   usa                                                mathematical truth                                                                  similar fundamental questions    abstract                                           faced foundation            ijcai                    problem solving   planner problem solving formalism                 important differences   continued develop eplstemolgy                 foundation problem solving alms   foundations problem solving               theory actions purposes   extended overview                 theory mathematical truth   formalism given information                foundation problem solving   processing viewpoint simple example                specify goalorlented formalism   explained using snapshots                   problems stated   state problem solving                   furthermore formalism   example worked finally current                   specifying allowable methods   applications formalism                    solution problems    iisted                                              definition formalisms                                                         following elements defined    structural foundations                      data structure control   problem solving                                       structure primitive            like develop                   procedures problem   foundation problem solving                        allowable data structures facts   analogous ways currently               world immediately arises   existing foundations mathematics                 theory actions foundation   need analyze structure                 problem solving confront   foundations mathematics                     problem change account   foundation mathematics provide               taken changing situation   definitional formalism                     world order   mathematical objects defined               problem solving   existence proved example                   problem solver foundation   set theory foundation provides                   problem solving consider   objects built sets               knowledge kind knowledge   deductive                        problem solvers   formalism fundamental truths                 contrast   stated means provided               foundation mathematics   deduce additional truths                   semantics foundation problem   established current                          solving defined terms   mathematical foundations set                  properties procedures   theory quite natural adequate                like mathematical investigations   vast body classical                       adequacy foundations   mathematics objects                          problem solving provided planner   reasoning mathematical domains                chapter dissertation   analysis algebra                   beginnings kind   easily founded set theory                     investigation   existence certain astronomically                            specific   large cardinals poses problems               foundation problem solving   set theoretic foundations                  concern following   problems posed                     complex topics   practical importance certain   category theorists foundations                             procedural embedding   mathematics devoted great deal                 real world knowledge effectively   attention problems                      embedded procedures good   consistency completeness                    ways express problem solution   problem consistency important                  methods plans   foundations                         solution problems formulated   inconsistent formula   whatsoever deduced                                generalized compilation   trivializing foundations                        good methods transforming high   semantics foundations                          level goalorlented language   mathematics defined model                        specific efficient algorithms                                                                        session  software support                                                                      descriptions procedures             verification hovv                recognize candidate    verified procedure does               fits description    intended                                                                           patterns             procedural abstraction                descriptions match configurations    rood methods abstracting                     data example     general procedures special cases               atomic procedure                                                         recognize              approach foundations             atomic    problem solving requires    distinct formalisms                                     data types patterns                                                         used declarations allowable              methods formalism                range domain procedures    specifies allowable methods                   identifiers generally data    solution                                             types analogues form                                                         procedures create destroy              problem specification                  recognize transform data    formalism pose problems                                                                           grammars    problem solver expected                    programmar language terry wlnograd    figure combine available                 represents step    methods order produce solution               kind procedural analogue natural    satisfies problem                          language grammar    specification aims    formulation problem solving                                schematic drawings    clearly separate methods                   procedural analogue methods    solution problems posed                  recognizing particular figures    impossible cheat                 fit schemata    problem solver methods    solving problem                                     proofs correspond    statement problem lie propose                procedures recognizing    bridge chasm methods              expanding valid chains deductions    formalism problem formalism                 proofs fruitfully    consider carefully                      considered define procedures    extremes specification                     proved certain properties    process ing                                                                           models programs             explicit processing                procedures defining properties    methods ability specify               procedures attempting verify    control actions finest                   properties models programs    detalls                                             defined procedures                                                         state relations hold             implicit processing                control passes through program    problems ability specify    end result desired say                                 plans general goal    ach leved                                          oriented procedures attempting                                                         carry task    planner attempts provide formalism    problem solver bridge                                   theorems    continuum explicit                  ouantificational calculus    implicit processing aim                   analogues procedures carrying    maximum flexibility              deductions justified    knowledge available                        theorems example consider    incorporated fragmentary               theorem form implies    heuristic                                       procedural analogue theorem             work planner             consider    investigation procedural                         subgoal order try prove    eristemology study                      form ira goldstein    knowledge embedded                        shown theorems    procedures thesis procedural                elementary plane geometry    embedding intellectual                      natural procedural analogues    structures analyzed through    procedural analogues                                    drawings    try show mean through                    procedural analogue drawing    examples                                           procedure making drawing session  software support                                                                                                          progressive refinement                                                                        session  software support         sophisticated display processors              statement planner     constructed making                     primitive construct list     drawings cathode ray tubes                       objects certain                                                          properties example                       recommendations                   things     planner primitives allow                   green evaluating     recommendations disparate     sections goal oriented language                                 linked order                                  gal     accomplish particular task                                       goal green                                                          reads  xs              goal trees represented             green     snapshot instantaneous                                 patterns looping     configuration problem solving                     recursion represent common structural     processes                                           methods used programs specify                                                          commands repeated              corollary thesis              iteratively recursively     procedural embedding learning                main problems getting computers     entails learning procedures               write programs use     knowledge learned              structural patterns particular     embedded aspect thesis               domain dependent commands     procedural embedding                  available difficult decide     process going general goal                   basic patterns     oriented language capable                appropriate given problem     accomplishing task special                 problem synthesizing programs     purpose efficient algorithm                canned loops formally identical     task mechanized                 problem finding proofs using     expressing properties                     mathematical induction     special purpose algorithm terms                approached problem constructing     procedural analogues use               procedures goal oriented     analogues establish                  language directions     special purpose routine does fact              use canned loops     intended                           statement assume             concerned                priorl kind control structure     theorem prover unify structural                 needed second approach     problem solving methods domain                  try abstract procedure     dependent algorithms data                 protocols action particular     coherent problem solving process                 cases     structural methods mean                         structural method     concerned formal structure              progressive refinement way     argument                 problems solved progressive     semantics domain dependent                    refinement repeated evaluation     content                                             instead trying complete              example structural                  search problem space     method consequences                   repeated refinements     consequent heuristic                        example game like chess     consequences consequent                       game tree     heuristic mean problem                    looked times each time     solver look consequences               certain paths deeply explored     goal attempted               light searches     order idea                  revealed key features     statements useful                   position problems design     establishing rejecting goal                  particularly suitable use              need discover                    progressive refinement     powerful structural methods planner                 proposed designs     intended provide computational               amenable successive refinement     basis expressing structural                     way progressive refinement     methods important                   typically planner     ideas planner brings              repeated evaluation     structural methods problem                expression evaluated solve     solving open                 problem produce     analyzed generalized              value expression evaluated     basic patterns looping     recursion constant use     programmers examples     recursion binary trees lisp session  software support                                                                            information processing overview                  total ordering imposed             readers prefer                assertions buckets    read section  concrete                   sorted imperatives    examples abstract discussion             declaratives stored data    sect ion                                   base assert             ways               expression form objectl    approach description                   placel removed data base    planner section                    expression data base    planner information                form objectl object    processing viewpoint                 removed data base    data structure                data base tree structured    control structure formalism             possible simultaneously                                                        local data bases                                                         incompatible furthermore assertions         data structure                                 data base varying                                                        scopes             associative memory forms               duration process    basis planners data space                temporary subroutine    consists directed graphs    labeled arcs operation putting    getting components data                       control structure planner uses    objects generalized apply              pattern directed multiprocess backtrack    data type whatsoever                    control structure tie operation    example value canonical               primitives    expression      indicator simplified way                        backtrack ing planner    record                  processes capability    canonlcally simplified                    backtracking previous states    degree expression                    process backtrack procedure    simplified determined getting             activation specific instance    value indicator                       invocation procedure    simplified expression                   returned result    operation                     using theory comparative    implemented efficiently using hash                  schematology proved    coding lists vectors                 dissertation use backtrack    introduced gain efficiency              control enables achieve effects    common special case structures                 language lisp    associative memory useful planner              limited recursive control structure    ways monitoring gives planner              achieve backtracking cuts    capability trapping read                subroutine structure    wrlte execute references                  planner backtrack control allows    particular data object monitor                 consequences elaborate tentative    indicator                 hypotheses explored    monitor data object                 losing capability rejecting    action sees fit                 hypotheses    order handle situation                  consequences choice    associative memory used                    basis available knowledge    retrieve value identifier               doesnt work better choice    process getting                     using new information    component code commented               discovered investigating    simply putting actual comment                choice backtrack control    indicator comment                        makes planner procedures easier                                                        debug run backwards             data base                    forwards enabling problem    distinctive way                  solver zero bugs    planner uses data data    base data inserted     removed example inserting bl                       multiprocessing gives planner    data base signify                capability having    block bl place                  locus control problem solving    coordinate expression defined              using multiple processes arbitrary    atom position                  patterns search through conceptual    expression determined                     problem space carried    coordinates assertions stored               processes power create    buckets coordinates using              read write interrupt resume single    associative memory order provide              step fork processes    efficient retrieval addition 
