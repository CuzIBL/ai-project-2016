       qcspsolve solver quantiﬁed constraint satisfaction problems                                    ian gent   peter nightingale                school science university st andrews fife ky ss uk                                     email ipgpndcsstandacuk                                              kostas stergiou                    department information  communication systems engineering                   university aegean samos greece email konstergaegeangr                        abstract                          existing direct approaches solving qcsps discrete ﬁ                                                        nite domains approaches based extending csp tech      quantiﬁed constraint satisfaction problem     niques early stage bordeaux monfroy       qcsp generalization csp    mamoulis stergiou  shown gent et al      variables universally quantiﬁed   approaches signiﬁcantly outperformed      shown solver based encoding  qbf solver applied encoding qcsps qbfs      qcsp qbf outperform existing di     note contrast qcsps ﬁnite domains      rect qcsp approaches orders magni  signiﬁcant body work quantiﬁed problems      tude paper introduce efﬁcient qcsp continuous domains benhamou goualard       solver show knowledge learned    ratschan       successful encoding qcsp qbf uti      lized enhance existing qcsp techniques   paper introduce efﬁcient qcsp solver      speed search orders magnitude   qcspsolve develop solver ﬁrst im      show performance solver     plemented extensions standard csp algorithms fc      enhanced incorporating advanced look  mac gradually enhanced new capabilities      techniques cbj solutiondirected started repeating analyzing experiments      pruning experiments demonstrate solver  gent et al  discover features qbf solver      orders magnitude faster existing account effectiveness compared existing direct      direct approaches qcsp solving signiﬁ    approaches lead identify pure literal rule used      cantly outperforms approaches based encoding   qbf solver main factor contributing ef      qcsps qbfs                                    ﬁciency devised qcsp analogue pure literal                                                        rule incorporated basic solver result                                                        achieved speedup orders magnitude    introduction                                       continued development qcspsolve adding intelli  constraint satisfaction problem csp success gent lookback techniques conﬂictbased backjump  ful paradigm used model solve real ing solutiondirected pruning offer signiﬁ  world problems csp extended ways speedup finally implemented symmetry breaking  deal problems contain uncertainty quanti method based value interchangeability  ﬁed constraint satisfaction problem qcsp extension experimental evaluation algorithms qcsps  variables universally quanti difﬁcult reasons ﬁrst young age  ﬁed each possible value variables area lack benchmarks second general  ﬁnd values remaining existentially quantiﬁed vari ization known random generation models related ar  ables constraints problem satisﬁed eas csp qbf lead ﬂawed models example  qcsp used model pspacecomplete decision gent et al  noted generation method  problems areas planning uncertainty ad used mamoulis stergiou  suffers ﬂaw  versary game playing model checking example makes generated instances insoluble small  game playing want ﬁnd winning strategy problems sizes ﬂaw present random  possible moves opponent manufacturing problem generation methods propose random generation model  required conﬁguration possible creating hard instances used control  possible sequences user choices finally planning probability ﬂaw discovered gent et al   safety critical environment nuclear station certain parameter settings generated instances guaran  require action possible eventuality teed unﬂawed problems created using model    qcsps growing following development qcspsolve orders magnitude faster ex  numerous efﬁcient solvers closely related area isting qcsp algorithms signiﬁcantly outperforms  quantiﬁed boolean formulae qbf qsat qbf encoding based method gent et al   preliminaries                                      csps lookahead techniques try detect deadends early  standard csps variables existentially quantiﬁed pruning values future variables lookback tech  qcsps expressive csps allow uni niques try deal deadends intelligent way  versally quantiﬁed variables enable formulation recording exploiting reasons failures note  problems contingencies allowed techniques delete values  formal deﬁnition                          domains universal variables                                                        discover current assignments values  deﬁnition  quantiﬁed constraint satisfaction problem deﬁnitely lead solution pruning different  qcsp formula form qc sequence standard pruning csps  quantiﬁers qx    qnxn each qi quantiﬁes ∃  ∀ variable xi each variable occurs exactly  preprocessing  sequence conjunction constraints ∧    ∧ cm arc consistency ac extended qcsps bor  each ci involves variables     xn deaux monfroy  mamoulis stergiou    semantics qcsp qc deﬁned recursively  qcspsolve applies ac preprocessing  follows problem true step apart reducing problem size deleting values  form ∃xqx    qnxn qc true iff exists domains existentials ac removes prob                                                      value ∈ dx qx    qnxncx lem constraints form ∃ xi∀ xj cij ∀ xi∀ xj cij   true form ∀xqx    qnxn qc kind ac deletes value dxi  true iff each value ∈ dx qxqnxncx supported values dxj  dxi  true paper restrict attention binary qcsps algorithm determines insolubility lat  binary qcsp each constraint denoted cij  involves ter kind value dxi supported  variables xi xj universally exis values dxj  algorithm determines  tentially quantiﬁed                                  problem insoluble ac applied    example consider following qcsp constraints safely removed problem  sequence  quantiﬁed variables conjunction effect consequence   constraints problem used section  removal universals existential  demonstrate various features qcspsolve       ignored participate constraints  example                                                lookahead  ∃x∃x∀x∀x∀x∃x∃xx   ∧  ∧  ∧ qcspsolve implemented basic forms   ∧x  ∧x  ∧x  ∧x  ∧x  lookahead forward checking fc maintaining arc                                                        sistency mac fc called fc mamoulis stergiou    special case qcsp quantiﬁed boolean formula  extension standard fc qc  qbf qbf form qc deﬁned sps fc backtrackingbased algorithm discover  case domain each variable   deadends early forward checking current variable  boolean formula conjunctive normal form cnf signment existential universal values fu  conjunction clauses each clause disjunction ture existentials constrained current variable  literals each literal variable sign literal slightly modifying forward checking phase fc  said negative negated positive se algorithm called fc mamoulis stergiou   mantic deﬁnition qcsps note binary discover deadends earlier fc fc ex  qcsps unlike qbf qbf problems actly behavior fc current variable  literals clause trivial despite restriction existential current variable xi universal  binary constraints binary qcsps pspacecomplete fc forward checks each value xi future vari  boerner et al                                ables assigning speciﬁc value xi’s val    rest paper assume constraint ues causes domain wipeout fc backtracks  cij  variable xi xj quantiﬁcation sequence existential proceeds instantiating  explicitly speciﬁed refer available value dxi removing values future  universally existentially quantiﬁed variables univer variables inconsistent assignment xi  sals existentials respectively                   way fc discover deadends earlier avoid fruit                                                        exploration search tree branches    description qcspsolve                            mac algorithm extension standard mac                                                        qcsps each variable assignment mac applies ac  section basic features qcspsolve                                                        problem using ac algorithm mamoulis  discuss preprocessing analyze look                                                        stergiou  mac modiﬁed  ahead lookback capabilities qcspsolve standard                                                        way fc yield mac algorithm analogous fc         denotes assignment value variable current variable xi universal mac    qcspsolve currently handle ternary binary applies ac each instantiation xi aj  ∈       straints process extending constraints higher fore committing particular instantiation  arity                                                instantiations causes domain wipeout algorithmbacktracks commits values variable xi fully interchangeable value xi iff  proceeds variable                      solution contains assignment xi remains    rest paper various look solution substitute vice versa freuder  ahead lookback techniques combined fc  value ∈ dxi neighborhood interchangeable  based lookahead techniques combined ni value ∈ dxi iff each cij ∈  macbased lookahead similar way    compatible exactly values dxj                                                         qcspsolve exploits ni break symmetries prun  pure value rule                                                        ing domains universal variables each set  sat qbf literal called pure monotone                                                      ni values representative remove oth  complementary literal does appear clause lit                                                        ers permanently search temporarily during  erals important immediately assigned                                                        search  algorithm proves representative  value need branching cadoli et al                                                         consistent satisﬁes qcsp rest  pure literal rule does example  existential literal occurs positively pure literal rule  lookback  set true repeating analyzing experiments  gent et al  discovered pure literal rule various lookback schemes developed csps  profound impact search effort switching successful conﬂictbased backjumping                                                                     search process slowed orders magni prosser   algorithm successfully com                                                                                        tude immediately gave rise following questions bined fc csps prosser   dllbased pro                                                                                           does pure literal rule correspond qcsps cedure qbf giunchiglia et al    exploit prune search space answer cbj interacts fcbased lookahead qcspsolve  questions use notion pure value     standard csps each variable xi                                                        ﬂict set denoted conf setxi holds past vari  deﬁnition  value ∈ dxi qcsp qc pure iff ables responsible deletion values  ∀q  ∈    ∀b ∈ dx  assign                                              dxi initially conﬂict sets encoun  ments xi xj  compatible            tering deadend cbj exploits information kept conﬂict  way analogous pure literal rule qbf sets backjump variable partly responsible  vised implemented lookahead technique deadend conﬂict sets updated follows  pure value pv rule detects exploits pure values current variable xi existentially quantiﬁed during  prune search space actions taken dual exis ward checking value future variable xj  tential universal pure values existential variable incompatible assignment xi xi added  pure value set value pure value conf setxj domain future variable xj wiped  moved domain universal variable duality variables conf setxj added conﬂict  reﬂects dual semantics existential universal vari set current variable existential universal  ables note values pure dynamically during jumping occur following cases  search constraint propagation example                                                           • current variable xi existential  section  pv rule applied pre values tried qcspsolve  processing technique dynamic lookahead technique jumps rightmost variable belongs  during search pv rule works follows                                                                                                       conf setxi time variables    • pure value existential xi discovered dur conf setxi xk copied conf setxk      ing preprocessing search assignment xi information conﬂicts lost      values permanently tem                                                        • current variable universal value      porarily removed dx  check during search                                                                               deleted domain forward checking      value existential pure need                                                          results domain wipeout qcspsolve      check assignment  compatible                                                          jumps rightmost variable belongs      values future variables fc mac guarantee                           xk                                                              conf setx  variables conf setx  ex       compatible values instantia                                                                                            cept   copied                tions previous variables                         xk             conf setxk      • pure value universal xi discovered dur solutiondirected pruning      ing preprocessing search permanently tem giunchiglia et al  introduced solutiondirected      porarily removed dxi check value jumping qbf allows backjumps universally      universal pure need check future quantiﬁed literals reaching leaf node solu      variables preprocessing ac guarantees tion inspired idea implemented technique      constraints universal previ prune values universal variables reach      ous variable note values universal ing solution consistent leaf node      pure ignore variable            solution directed pruning sdp sdp based fol                                                        lowing idea assume universal  symmetry breaking                                                              qcspsolve utilizes technique symmetry breaking    experiments shown ni during search overhead  based neighborhood interchangeability value pv rule used                                                      boolean qcspsolve   xi    xn ⊂ sequence existentials                                                         preprocessq  right xi assume assignment xi ai leads ←  solution path consistent leaf node  var leftmost variable quantiﬁcation formula                                                         backtrack ﬁrst existential universal  xi ai    xn assignments vari  compute var  ables xi    xn path value xi  var existential  compatible assignments deﬁnitely  values dc var  lead solution values pruned ignored  var ← rightmost variable conf setc var  search algorithm based sdp ﬁrst computes   values universal xi prop  assign var valid value ∈ dc var                                                                   ←  erty values temporarily removed dxi  dwo  fcc var                                                           dwo  false  available values dxi sdp proceeds                                                             unassigned variables  universal immediately xi say xj  checks remaining values compatible assign  universals return true                                                               ments existentials xj repeated recursively  var ← sdp  universal available values left  restore values removed variables var  domain sdp applied algorithm  var ← unassigned variable  tracks universal way possible perform  restore values removed var  solutiondirected backjumps                           var universal                                                          values dc var    algorithm qcspsolve                         var ﬁrst universal return true                                                                       ←  high level description qcspsolve’s algorithm shown  var assigned universal variable  figure  takes qcsp qc returns true                                                           dwo  false  problem satisﬁable false  version  assignment var tried  qcspsolve shown figure  based fc mac     dwo←  fcc var  based version features cbj time  dwo  false  currently available figure            assign var available value ∈ dc var    • var current variable                         fcc var                                                             var ← unassigned variable    • preprocess function preprocesses prob       lem applying ac computing pure ni values  var ← rightmost variable conf setc var    • compute  computes pure values var dur  restore removed values variables var                                                         backtrack ﬁrst existential return false      ing search var existential values  return true      say pure compute var sets var      temporarily removes rest dc var’s val     figure  algorithm qcspsolve      ues var universal compute var      temporarily removes pure values dc var      algorithm backtracks values removed qcspsolve works follows takes input qcsp      compute  restored                   qc  preprocessing problem line  proceeds    • fc implements fctype lookahead called checking assignments values variables truth      current variable existential universal qcsp proved disproved assigning value      signed forward checks assignment var qcspsolve calls compute var com      future variables constrained var value pute pure values var line  var existen                                                        tial deadend occurs algorithm backtracks      future variable xi deleted var added                                                        rightmost variable conf setc var lines –      conf setxi dxi wiped ∀xj xj ∈                                                        wise valid value var forward checked      conf setxi xj added conf setc var                                                        future variables lines  domain wipeout    • fc implements fctype lookahead called dwo algorithm reached consistent leaf node      var assigned universal var variable calls sdp       ward checks dc var’s valid values perform solutiondirected pruning line  qcspsolve      future variables constrained var domain leaf node proceeds moving vari      future variable xi wiped ∀xj xj ∈ able line  dwo value var      conf setxi xj added conf setc var     tried iteration loop    • sdp   implements solution directed pruning sdp  var universal values proved      prunes values universals according rule consistent according current assignments      scribed section  returns universal cases var ﬁrst universal qcsp      values left domain sdp applied solve terminates successfully line                                                         tracks universal line  assigning    algorithm modiﬁed return solutions form value universal variable qcspsolve calls fcc var  search trees                                      perform fctype lookahead lines  isa dwo algorithm backtracks rightmost vari  able conf setc var line  dwo  fcc var called level var    ∃ x                           assigned available value line  assign  ment forward checked future variables line    ∃ x                  qcspsolve proceeds variable line                    pv     better understand algorithm qcspsolve        ∀ x                      works consider following example                                                      cbj                                                                 ∀ x      pv              example  assume domains variables  problem example  follows dx                                                                   ∀ x             sdp         dx      dx    dx                                        fc   dx    dx      dx        ∃ x                 dwo  of  x   let trace execution qcspsolve steps              fc      preprocessing applied arc incon  sistent pure values pruning performed        ∃ x                                                                                                   fc   assignment  fc reduces dx  dx       respectively   figure  search tree example  dark  conf setx  conf setx   value           nodes pruned qcspsolve   pure supported values  nodes feature responsible  future variables pv rule immediately make  pruning included dashed ovals  signment   fc does wipe future  main assignment  fc reduces  dx dx     respectively  value inconsistent assignment remain inconsistent irre   pure removed assignment spective assignments universals existentials   fc reduces dx   fc does problem unsatisﬁable propose  wipe future domain assignment  generator used control probability ﬂaws  fc reduces dx    variables quantiﬁed three blocks block ex  signed available values solution  istentials followed block universals  function sdp called line  sdp discovers block existentialsthe generator takes  parameters   value  universal compatible n∀ npos q∀∃ q∃∃  total number  signments existentials value variables n∀ number universals npos position  removed dx solutiondirected backjump ﬁrst universal uniform domain size  performed  assignment  fc number binary constraints fraction pos  duces dx dx    respectively  sible constraints q∃∃ number goods ∃ xi∃ xj cij  fc applied wipes dx value  incom constraints fraction possible tuples q∀∃  patible value dx similar quantity ∀ xi∃ xj cij constraints described fur  deadend conf setx added conf setx ther types constraints  algorithm backjump rightmost variable removed preprocessing generated  conf setx                              ﬂaw characteristic ∀ xi∃ xj cij    figure  shows search tree generated qcsp straints restrict following way generate  solve illustrates subtrees pruned        random total bijection domain                                                        tuples bijection goods q∀∃ fraction                                                        goods tuples bijection    experiments                                          control probability pf ﬂaw write  gent et al  showed model random gener expression pf  approximating proportions q∀∃ q∃∃  ation qcsps used mamoulis stergiou  probabilities n∀ number universal variables  suffer local ﬂaw makes generated n∃ number inner existential variables each ex  instances false model alternating quanti istential assignment xi probability covered  ﬁers applied disjoint sets variables innermost universal − q∀∃ variable xi ﬂawed  quantiﬁer existential let brieﬂy ﬂaw values conﬂict value univer                                                        sal variable each universal variable cover  suppose series universals     assigned                                                      value use bijection representing  values     ak respectively existential xi  later universals each values existential values using integers probability variable  conﬂict values assigned universals xi ﬂawed given following  assignment values     ak variables     xk                                                                 pxi flaw  ppp ∧              values   ni let ignore sake probability value ﬂawed given previ  example                                       ous −  values ﬂawed given formula 
