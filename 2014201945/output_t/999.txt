            formalizing communication protocols multiagent systems∗                                              munindar singh                                      department science                                      north carolina state university                                       raleigh nc  usa                                               singhncsuedu                        abstract                          singh  winikoff et al  yolum singh                                                         simplify comparison previous work use netbill      protocols structure interactions communi   example protocol netbill customer requests      cating agents commitment machine models      quote goods followed merchant sending      protocol terms commitments   quote customer accepts quote merchant      various parties evolve commitment machines  livers goods customer pays receiving      support ﬂexible behavior providing mean  payment merchant sends receipt customer      ingful basis compliance protocol unfor figure “left” fsm representation netbill      tunately current formulations commitment ma  figures “center” “right” discussed      chines sufﬁciently general rigorous                                                             rfq           rfq            rfq      paper develops generalized commitment ma                                                         chines gcms  elements described            offer          offer           offer                                                                                                                                                          reject                 generically terms inferences com    caccept           caccept       reject caccept      putations inﬁnite supporting nonterminat                                                                                                          goods           goods          goods      ing protocols paper shows gcm                                               understood nondeterministic b¨uchi automa     pay             pay            pay                                                                                                             ton ba acceptance condition accommo        receipt        receipt    receipt      dates inﬁnite ﬁnite executions      deterministic ba readily emulated conven  figure  netbill automata original terminating      tional software script running web  bounded nonterminating states  initial       browser general nondeterministic ba ﬁnal section  explains state  refer      equivalent deterministic ba    message senders customer merchant respectively      wellmotivated technical conditions gcm yields   papers observe original netbill quite      deterministic b¨uchi automaton rigid handle natural situations  mer      necessarily equivalent automata theory terms chant proactively sending quote mimicking idea ad      sound produces computations allowed  vertising price  customer sending “accept” message      gcm  complete produces effect    requesting quote cases trust urgency       computation allowed gcm                  merchant sending goods prior customer accepting                                                        trial offer papers show model proto    introduction                                       cols based commitments enabling each participant                                                        form wider variety actions ensure compliance  protocols streamline communication enable develop                                                        check others’ compliance based actions  ment interoperable agents independent vendors                                                          promising previous work cms sufﬁ  participants protocol able exploit opportu                                                        ciently general rigorous clear assumptions yolum  nities offered environment negotiate exploit spe                                                        singh model actions restrictively approach  cial relationships handle exceptions unfor                                                        indirectly models discharge commitment  tunately conventional engineering techniques specifying                                                        strong point compilation cms ﬁnite state machines  enacting protocols tedious result interactions                                                        winikoff et al use event calculus reconstruct  unnecessarily rigid yolum singh                                                         yolum singh’s work improve methodology    work commitment machines cms shows repre                                                        commitments modeled don’t study com  senting inferencing commitments produce ﬂexible                                                        pilation chopra singh consider richer non  protocols providing basis compliance chopra                                                        monotonic theory action based causal logic don’t    ∗this research partially supported national science discuss compilation general translation causal  foundation grant dst                   logic transition                                                    ijcai                                                      case point current emerging ﬁnancial protocols modeled  protocol function “reg  adequately formalized example price discovery ulative” rules force   ﬁxed   protocols crucial wholesale foreign exchange  vary each protocol kinds rules  transactions conventionally described scenarios captured variety existing action formalisms impor  text descriptions twist  descriptions tantly gcms compiled novel manner determin  ambiguous unwieldy treat each cases istic b¨uchi automata wellknown model inﬁnite com  separately losing opportunities generalization com putations thomas  automata facilitate veriﬁcation  pactness preliminary work twist captures deterministic representations directly executed  key commitments succinctly represents multiple scenar using single thread constant space  ios using primitive patterns validated mod brieﬂy contributions follows seek compu  ularly value commitments modeling analysis tational model protocols natural humans  clear paper strengthens operational aspects reﬂect semantics general producing executable    previous work assumes cm necessarily includes deterministic representation cause exponential blow  states reachable through actions modeled include unnatural states using semantics map  design protocol involve considerations gcms deterministic automata natural states  states include respect integrity secu  rity constraints participants’ preferences espe  technical framework  cially subtle organizational requirements complex  roles involved likewise nonmonotonic speciﬁ introduce action representation review commit  cations valuable monotonic representations enu ments b¨uchi automata agents  merate modeled conditions facilitate veriﬁcation sim formulas α atomic proposition nega  pliﬁed highperformance automatonbased implementations tion identify α ¬¬α  follow speciﬁed protocol    paper introduces generalized commitment machines  generic action theory  gcms general rigorous version meaning action speciﬁed terms propo  cms introduces simple approach modeling actions sition brings reﬂecting “causes” causal logic  clearly state key requirements “initiates” event calculus different conditions each  action models expressed variety existing action described action theory Δ set ax  formalisms including causal logic event calculus ioms capture state protocol evolves  paper handles complete set commitment operations action occurs simplicity performer action    additionally semantics gcms based inﬁnite kept implicit action label deﬁnition  describes ac  computations providing proper treatment nontermi tion axiom schemas correspond potential transitions  nating terminating protocols motivate nonter allowed gcm  mination notice protocols readily cycles fig       ure introduces reject transition induces cycle deﬁnition  p→q means consequence perform  unbounded computations produced ing action state holds  model traditional ﬁnite automaton each computation                                                                   holds p→q performing yields qwhenq  terminate ﬁnal state automaton contrast ¬p overturns pwhenq false means impossible  automatically restart netbill sending receipt                                                                   holds relation → closed inference rules  interpret having ﬁnal state requiring good action theory Δ respect rules  state say state  occurs inﬁnitely bring  means logical consequence  inﬁnite computations figure good state                                                                          qq→      rru  desirable condition relative design goals −−−−−−−−−−−−−a−−−−−−−−−−−−  consequence                                                                    →   achieved traditional applications automata good        state typically stimulus responded −r−−→−−−pr−−−−−−−→−−−q−                                                                  ∧                       conjunction  gcms simple domainindependent basis    →                                                          following inference rule requirement  good state pending commitments                                                            → relation preserve consistency    natural nonterminating protocols involve maintain      ing relationship organization com −−−−p−→−−−q−−−                                                            ¬  ¬                        consistency  pleting transaction participants protocols →   continually send messages respond required        ¬                                                           −p−−→−−−qq−−−−−−−−−−−α−  think underlying relationship standing   ∧     ∧                         inertia                                                               α → α  agreement analogous reallife organizations inertia speciﬁes α holds isn’t  distributed systems don’t want multiagent turned athenα continues hold inertia  terminate want os terminate required convenient property action theories    gcms speciﬁed modularly sets inference rules  cleanly separate rules involving  generic expectations example  example overturn inertia consider state                                                        goods ∧¬pay holds payment  action theories  commitment operations            commitment operations “constituted” setting new state goods ∧ pay holds                                                    ijcai                                                      commitments                                        • customer pays merchant sends  commitment explicitly manipulable directed obliga ceipt making receipt true conditional commitment  tion context ignored simplicity         terminated commitment created                                                            customer did commit paying eliminate  deﬁnition  commitment cxyp relates debtor cred  itor condition speciﬁcally commits bring  mapping existing logics                                                                                                                               inference schemas → deﬁned generic  commitment actions                                    represented existing formal  creation manipulation commitments ism interpreter formalisms  scribed using following operations modeled actions plugged derive appropriate inferences following                                                        causal laws show commitment actions captured    •     createxcxyp                                                                 §         true    →     cxyp establish                   causal logic chopra singh                                                                                 ¬    •  ∧       dischargexcxyp ¬                        discharge causes cxyp cxyp       cxyp      →       cxyp resolve remove                                                           detach maps expressions           cancelxcxyp    •  xy            ¬  xy           →        remove debtor            causes ¬ccxyp ccxyp               yc     •      release xy ¬                                    causes cxyr ccxyp      cxyp    →       cxyp remove creditor                                                                              ¬                      •      assignyzcxy ∧¬                           eliminate causes ccxy ccxy      cxyp     →     cxzp    cxyp change creditor                                                        following event calculus expressions capture    •      delegatexzcxy ∧¬      cxyp      →      czyp   cxyp change debtor   actions winikoff et al  fig  time  debtor cancels commitment subject penal explicit speciﬁcally used formalization  ties creditor release commitment typically  discharge  organizational reasons penalties            terminatese cxyp ← holdsatcxyp ∧                                                            happense ∧ subsumespp ∧ initiatese pt  deﬁnition  conditional commitment ccxyp means  antecedent true debtor  detach maps expressions  come committed bringing consequent            initiatese cxyp ← holdsatccxyp qt ∧                                                                       ∧            ∧               conditional commitment’s antecedent      happens  subsumes   initiates                                                                                  ←  true discharged commitment consequent terminates ccxy                                                                             ∧           ∧  created typically                             holdsat ccxy happens                                                             subsumespp ∧ initiatese pt                detachzccxy qr    •    xy                 ¬   xy   ∧ xy      cc         →        cc                eliminate terminatese ccxyp qt ←                                                            holdsatccxyp qt ∧ happense ∧  conditional commitment’s consequent true                              discharged needed typically  subsumesq ∧ initiatese    •          eliminatezccxyqr ¬            just easily use ecasl extended cognitive      ccxy       →         ccxy            agent speciﬁcation language khan lesp´erance   constituting commitment actions  rules provide semantics commitment ac  buchi¨ automata  tions each setting actions performed finite state machines fsms long used specify  domainspeciﬁc manner protocols commitment actions protocols acceptance condition fsms requires termi  correspond message types cases messages nation ﬁnal state section  argues inter  combine effects multiple commitment actions esting protocols nonterminating model protocols  case partial returns payments multiple mes requires consider automata inﬁnite words  sages needed implement action example b¨uchi automata ba ﬁnitely states  paying  replace commitment pay  com transition rules fsms acceptance  mitment pay  domain action theory capture condition handles nonterminating computations requiring  requirements                                    good state section  visited inﬁnitely  example  consider     conditional  commitment    deﬁnition  ab¨uchi automaton ﬁvetuple    ccmcpay receipt meaning merchant   s gδ wheres set states alphabet  commit sending receipt customer pays     ∈ start state ⊆ set good states                                                        δ ⊆ × × transition relation    • customer pays ﬁrst making pay true      ditional commitment terminated new commit ω ﬁrst inﬁnite ordinal computation τ       ment cmcreceipt created stead detach sas  ωlong alternating series states      merchant actually sends receipt intervening actions computation τ infτ set      proposition receipt true commitment states occur inﬁnitely τ paper      cmcreceipt discharged discharge            ba τ computation                                                    ijcai                                                    deﬁnition  τ realized ∀i ∈   example   previous work formalizes netbill ter  ωsiaisi ∈δ infτ ∩  ∅                minating protocols commitment machines similar ap                                                        proach applies brieﬂy modeling steps  figure example ba  set vertices                                                          •   set edge labels  shown reverse   model atomic propositions request pay  video δ  set edges computation cycles • introduce commitments needed example ac                                       through states        rfq  oﬀer     cept abbreviates cccmgoods pay customer    accept   goods   pay   receipt  receives goods pay merchant  accepted ba visits state  inﬁnitely                                                          • identify states example state  fig  computation cycles through states    ac                                                            ure  means merchant offer  cepted does visit state  figure  shows ba                        ω           ω                       committing delivering goods sending receipt  languages abab aab  respectively                          ω                                 payment formally request ∧ promisereceipt ∧  tice figure accepts  figure doesn’t                                                            promisegoods  viewed automata theoretic terms obviously  equivalent                                             • identify actions messages ex                                                            changed sendaccept sendgoods                                                                                            • assert action theory axioms Δ  sending ac                                                                                                                 sendaccept                                                            cept true →   accept  delivering goods                                                                                sendgoods  ∧    figure  nondeterministic ba deterministic ba promising receipt true → goods promisereceipt                                                          •    inﬁnite computations complicates   identify good states example  cus  pects automata importantly nondetermin tomer request commitments  istic fsms equivalent deterministic fsm non request  merchant delivered  deterministic ba equivalent deterministic ba fig goods receipt customer paid                                                                   ∧      ∧     ∧  ure famous example ba deter request goods  pay   receipt  minized deterministic ba efﬁciently emulated example  gcm analogous figure state  p∨q  script ba correct know script complies state  ∈ gisp ∧ qandΔ includes following axioms  given protocol paper shows produce ∨  ∧       ∧     ∧           ∧    ∨                                                         →  qp  →  qandp   →  possible correct deterministic ba protocol    example helps relate gcms wellknown ba                                                        figure revisited section  scenario    generalized commitment machines                    gcm occur refer organizational                                                        relationships action strengthens relationship  generalized commitment machine gcm speciﬁed ∧ action conﬁrms relationship weaken  states content captured logical expressions ac imagine originally speciﬁed  tions action theory transition states organizational roles played party  set good states terminating computations mod  eled transitioning end artiﬁcial good state  selfloop given state new state reached  compiling gcms buchi¨ automata  forming action logically inferred effect gcm spec reasoning declarative representations runtime  iﬁes meanings states lets inferencing rest expensive increase code footprint agents    construct ba set states ac applications ﬁnancial transactions twist  tions gcms use symbols ganda   ﬂexibility designing protocol rigid  deﬁnitions ≡ means enactment make performance guarantees popu  logically equivalent         larity ajax indicates potential simpliﬁed interact                                                        ing agents compiling gcm deterministic ba  deﬁnition  gcm tuple  s Δ highly desirable gcm essence nondeterministic  ﬁnite set states ﬁnite set actions  ∈ ba general equivalent deterministic ba exist  start state Δ action theory g⊆s set exploit semantics protocol produce  good states members logically distinct ∀sisj ∈ possible deterministic ba practical purposes  si ≡ sj ⇒ si  sj false ∈ state stronger equivalent  good state good ∀si ∈ gsj ∈ sj  si ⇒  sj ∈                                              determinism soundness  deﬁnition  τ generated gcm ∀i ∈ states initial state good states gcm map                       ai                               straight ba importantly ensure  ω  si ∈ ∃ai ∈  si → si infτ ∩  ∅                                                       terminism choose transition  paper “protocol” gcm given given state action algorithm  does  ∈ ∈ transitions action understand min calculation algorithm  imagine              q→r effect gcm functions inference gcm states partially ordered according logical  driven nondeterministic ba                         consequence si placed sj iff si  sjfors ⊆                                                    ijcai                                                    mins unique minimum according                                                                                                                                                                              order example assume performing                                                                                                                        yield swheres ≡ sifs  algorithm                                                                                                                                                  select sifs  select al                                                                                   gorithm  select omitting transition qq               qq                                                                                                   theorem  shows result deterministic    theorem  algorithm  yields deterministic ba    figure  lack coherence failure coverage  proof assume transitions state dashed ellipses represent potential states  action siasj  siask  algorithm   ensures sj  sk sk  sj sj ≡ sk deﬁnition  second gcm computation involve transition  ensures sj  sk deterministic            doesn’t exist ba address basic idea                                                        action rule consequence spe   δ                                               ciﬁc gcm computation realized ba com   foreach si ∈ sa∈                              putation taking strongest state each step real             ∈              si    sk   si → sk                           ized ba complete practical purposes      sj minsi δ  δ ∪siasj             deﬁnition  lemma  capture intuition                                                                                                     algorithm  compiling gcm ba          deﬁnition  computation τ    sas se                                                        mantic supremum computation τ  sas                                                                  example  example  algorithm  yield ba τ begins state involves action                                                        sequence τ each transition siaisi  exercised  figure states   state  transitions                                                                               τ τ exercises transition siaisi  si     based axiom based apply                                     ing consequence  axiom b  b  strongest consequence performing si  included based line  algorithm lemma  computation begins  figure figure equivalent based semantic supremum computation gcm  knowledge meanings practically equiv realized ba produced algorithm   alent                                                proof proof simply transﬁnite induction                                                                                                    example  fortunate compilation doesn’t computations consider preﬁxes length ω  work following develops additional steps make com theorem  establishes main completeness result ﬁ  pilation work determine work correct nessed coherent gcms supremal computations  ness main aspects soundness means com theorem  given coherent gcm compiled ba  piled ba won’t realize computation gcm wouldn’t computation generated gcm begins  generated completeness means gcm exists semantic supremum computation realized  generate computation compiled ba realize ba  cause ba’s transitions chosen proof construction coherent gcm lemma   gcm soundness guaranteed theorem                                                           producing coherent gcms  theorem  let compiled bthenany  computation realized generated          let’s consider question ar                                                        bitrary gcm mapped equivalent coherent                                                                   completeness coherence                       gcm    producing coherent gcm requires ensuring                                                        supremal states exist each action allowed each state  general ba include transitions  gcm complete ba  transition state action   minimal states partial order states  unique strongest required algorithm  address  foreach ∈ ∈                                                                   ∈         basic idea restrict gcms  va →   transition state action strongest tran  va≥  sition state action exploiting action   va  rule conjunction deﬁnition  captures coherence       va ∪w  figure shows situation occur                                                     foreach ∈ ∈  produce qthatisp → →                                                                                                  true ¬∃s ∈   true  hold situation ∧ ∈ coherence   →                            →                                                             announce failure exit  violated                                                                                                           ∪  deﬁnition  ∈ sa ∈ projection                                                                                                     πas set states → agcmis algorithm  producing coherent gcm states                                                 coherent ∀s ∈ sa ∈  πas  ∅⇒∃n ∈  →                                                ∀s ∈ πas    supremal state algorithm ’s ﬁrst foreach block maintains set  meaning strongest resulting state known minimal states gcm  constructed                                                    ijcai                                                    
