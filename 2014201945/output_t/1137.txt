           aﬃne      algebraic      decision     diagrams        aadds                           application        structured       probabilistic       inference                        scott   sanner                            david   mcallester              department      science                   tti   chicago                    university  toronto                         east th  street             toronto    ms   canada                   chicago  il   usa                  ssannercstorontoedu                        mcallestertticorg                        abstract                            conjunctive add disjunctive add additive multiplicative                                                                structure       structure       add structure       propose   aﬃne  extension  adds                                                  aadd   capable compactly  representing        contextspeciﬁc additive multiplicative                                                structure show aadd worst      case time space performance mul      tiplicative constant adds                                           linear number variables cases        adds  exponential number                                                                                                                                   variables provide empirical comparison                                                    tabular add aadd    representations      used standard bayes net mdp inference      algorithms conclude aadd        figure   example adds   showing conjunctive      forms represen structure  ifa     disjunctive structure                                                         ifa    ∧ and∧ additive         tations yields exponential perfor           ∨  ∨        abc      mance  improvement  additive       multiplicative  γ   structure      multiplicative structure exploited     sets terminal values respectively high true edge                                                        solid low false edge dotted      results suggest aadd likely      yield exponential time space improve      ments variety probabilistic inference al adds  oﬀer exponential space savings fully      gorithms currently use tables adds       enumerated tabular representation com                                                        pactness adds does extend case additive                                                        multiplicative independence demonstrated     introduction                                      exponentially large representations structure  algebraic decision diagrams adds  provide eﬃ present unfortunately structure oc  cient means representing performing arithmetic curs probabilistic decisiontheoretic reasoning  operations functions factored boolean domain mains potentially leading exponential running times                                                      space requirements inference domains  realvalued range rely  main principles →                                                           aﬃne     algebraic   decision   diagrams    adds  represent function bn   directed      acyclic graph – essentially decision→ tree address limitations adds introduce      convergent branches realvalued terminal nodes aﬃne extension add aadd capable                                                        canonically compactly representing contextspeciﬁc    adds  enforce strict variable ordering additive multiplicative structure functions      cisions root terminal node enabling bn deﬁne aadds   following bnf      minimal canonical diagram produced    →      given function identical functions al       bf                                                                               var      ways identical add representations              iff    ch  bhfh cl  blfl      variable ordering                                                                                                    ch cl real ﬂoatingpoint constants    shown  figure  adds  provide eﬃ   closed interval   bh bl real constants  cient representation functions contextspeciﬁc halfopen interval   var boolean variable  independence  functions structure associated  fl fh nonterminals  conjunctive disjunctive nature type  impose following constraints additive aadd structure multiplicative aadd structure                                                                                                                                                                                                                                   var        op         var                                                                                                                                        −                                                                                                                                                                                                                                                                                                 var      var                                                                                     var     var                             −            −    −                fh    fl                                                                                                                −         −   −                                                     figure  aadd  nodes binary oper                                                        ation op corresponding notation used paper                                                                                   exponentially sized adds figure represented                                                        generalized aadds  linear size  figure  portions adds ﬁgure expressed let op denote binary operator aadds  generalized aadds edge weights given                                                     possible operations addition substraction multi                                                        plication division min max denoted respectively                    var    variable   does appear fh fl             min   max                                                             ⊕  ª ⊗  ®      · ·          · ·    minch cl                                                             related    work    maxch  bh cl  bl                                                           related work formal veriﬁ    fh   bh   ch   similarly fl                                                        cation literature attempted tackle additive    grammar require   multiplicative structure representation func                                                                                                          tions      include bmds kbmds  expressions grammar called normal evbdds fevbdds→  hdds  phdds     ized aadds  expressions grammar space limitations prevent discussing  called generalized aadds                         diﬀerences aadds   data structures    let alf ρ value aadd variable note major diﬀerences  data structures  value assignment ρ deﬁned recursively diﬀerent canonical forms relying gcd factoriza  following equation                               tion satisfy invariant property aadds                                                        internal nodes range    fact                                                                                                                       var                            data structures integer terminals    alf ρ     ρf     true  ch  bh alfh ρ                                                          ∧    var                ·           quires rational direct ﬂoatingpoint representation                 ρf     false  cl  bl alfl ρ                   ∧                      ·            values experience renders  lemma    normalized aadd  unusable probabilistic inference considerable  alf ρ interval   minρ alf ρ   numerical precision error computational diﬃculties    max alf ρ                       ρ     say satisﬁes given variable ordering   algorithms                              var    form iff  ch  bhfh cl  blfl         var                                var           deﬁne aadd   algorithms analogs     does occur fh fl    given bryant  extended  earliest variable given ordering occuring  propagate aﬃne transform edge weights  say generalized aadd form cbf satisﬁes  recursion compute normalization  order satisﬁes order                    resulting node return  lemma     fix variable ordering non     algorithms rely helper function getgnode  constant function mapping bn     exists  given algorithm  takes unnormalized aadd                                 −→  unique generalized aadd  satisfying given vari node form ifv chbhfh clblfl returns                                                                                                          able ordering ρ gρ     cached generalized aadd node form cr brfr   alg ρ                   ∈                                                                        lemmas proved straightforward induc    reduce  tion second lemma shows given   reduce algorithm given algorithm  takes  variable ordering generalized aadds canonical arbitrary ordered aadd normalizes caches  identical functions identical aadd ternal nodes returns corresponding generalized  representations                                      aadd   nice property reduce algorithm    example aadds  compact additive   does need prespecify structure  multiplicative structure figure  shows portions                                                           bryant gives algorithms binary decision diagrams    normalized aadds grammar restricted bdds essentially identical adds  range   need toplevel positive aﬃne trans algorithms use representation   form generalized aadds grammar allow text use equivalent notationh cbfi  representation functions arbitrary range     make node semantics clear          ialgorithm   getgnodev  ch bh fh  cl bl fl   algorithm    reduce  cr br fr                                       −→                                −→         cr br fr                                                      input     oﬀset multiplier node id                                                                          input    ch bh fh  cl bl fl  var oﬀset mult                                                  output   cr br fr  return values oﬀset             node id highlow branches                     hmultiplieri node id    output   cr br fr  return values oﬀset       begin                               multiplier canonical node id                check terminal node    begin                                                             branches redundant return child                    return                                                                                   cl  ch bl  bh fl  fh                ∧       ∧          return cl bl fl                                  check reduce cache                                                            cr br fr reduce cache        nonredundant compute canonical form                 →noth cachei recurse       rmin  mincl ch rmax  maxcl  bl ch  bh                                                                 ch bh fh  reducech bh fh       rrange  rmax rmin                                                               −                                            cl bl fl  reducecl bl fl       cl  cl rminrrange ch  ch rminrrange                             −                      −       bl  blrrange bh  bhrrange                          retrieve canonical form                                                                                        var        ch bh fh  cl bl fl id node         cr br fr  getgnodef  ch bh fh  cl bl fl        cacheh hthen      ii →                                                                         id  currently unallocated id                         cache          insert ch bh fh  cl bl fl id cache         insert  cr br fr reduce cache                           ii →                                 →              return cached canonical node                   return canonical reduced node       return rmin rrange id                              return  cr br fr                                                                   ·    ·        end                                                   end    aadd   exploit represented function cases case operands  terminal  contains contextspeciﬁc additive multiplicative nodes having taken care previous section  dependence reduce algorithm compactly repre                                    var    var                                                         terminal node        sent structure uniquely automatically wrt assume operation commutative reorder  variable ordering guaranteed previous lemmas   operands  node operand                                                        variable comes later variable ordering     apply                                                        propagate aﬃne transform each f’s branches  apply routine given algorithm  takes gen compute operation applied separately  eralized aadd  operands operation given  each f’s high low branches build                                                                                var  figure  produces resulting generalized aadd statement conditional normalize obtain  control ﬂow algorithm straightforward generalized aadd node cr br fr result  ﬁrst check compute result immedi                                                                                           ch bh fh  apply   bch bbh fh  op  ately normalize operands canonical                                                                                           cl bl fl  apply   bcl bbl fl  op  form check reuse result previously              vari                                                                        cr br fr  getgnodef  ch bh fh  cl bl fl   cached computation                                    choose variable branch recursively                                      var    var                                                        nonterminal  nodes             apply                                                                                                   routine each instantiation variable variables each operand match know  cover steps indepth following sections                                                        result cr br fr simply generalized statement                                                                     ivar    var  terminal  computation                                 branching       true case  function computeresult  given half  operator applied high branches  table  determines result computation likewise false case low branches  immediately computed recursion ﬁrst       ch bh fh  apply  bch bbh fh                                                                                            entry table required proper termination                   bch bbh fh  op  algorithm computes result operation                                                                                                 cl bl fl  apply  bcl bbl fl  applied terminal  nodes                                                                                                                 bcl bbl fl  op  entries denote number pruning optimizations                         var                                                                     cr br fr  getgnodef  ch bh fh  cl bl fl   immediately return node recursion ex                                       ample given operation                                           ⊕                   note ﬁrst case prohibits use non  immediately return result                 commutative    operations simple solution                                                               ª     ®                                                        recursively descend  recursive  computation                                assuming commutativity swapping operands ensure  apply unable immediately compute descent accommodate general noncommutative  result reuse previously cached computation operations used alternate approach spec  recursively compute result  iﬁcation apply routine given algorithm canonical  caching                                    algorithm      apply   op                                                                                              −→  aadd   apply algorithm compute      cr br fr                                                               cache results applying operation directly  operands algorithm provably    input      op  nodes op                                                                                time complexity add apply algorithm  output   cr br fr  generalized node return                                                                          compute      cache result   begin                      i⊕h        cr  brfr  compute                  check result immediately computed                                ⊕        cr    brfr recursion                      computeresult   op                                                                                           →    suggests canonical caching scheme normal     cr br fr null                                                                                                                                    return cr br fr   izes cache entries increase chance cache hit              actual result easily computed      normalized key check apply cache                                                                        cached result reversing normalization en                                                                     hh       ii  sures optimal reuse apply operations cache          getnormcachekey     op                                                                                                                                                           op cr br fr  lead exponential reduction running time           hh              →       noncanonical caching version                    apply cache    introduce additional functions perform         terminal recurse                                                                                         caching getnormcachekey   compute canonical              nonterminal node                                                                    nonterminal node  cache key modifyresult reverse normaliza                    var             var                                                                        comes                                                                                   var  tion order compute actual result algo                 var    rithms summarized half table                                                                                                   var      operations                                                 var    space limitations prevent covering                                                                                         var  operations performed eﬃciently                  var    aadds  brieﬂy summarize                                                                                           var  min  max   computation   min max                var    generalized aadd node   bf  respectively                                                              propagate aﬃne transform branches     normalization                                                    var                                                                 nonterminal var    restriction restriction variable xi func                    ∧                                                                    fl   fl fh  fh  tion true false tf  com                                                                                              cl   cl ch   ch  puted returning proper branc nodes contain                  ·            ·                                                                    bl  bl bh  bh  ing test variable during reduce operation                       ·            ·                                                                                                                                                      sum   outmarginalization    variable                                                                                           lh        lh       lh  summed  marginalized function simply                                         var                                                                 nonterminal var    computing sum  restricted functions                     ∧                                                                    fl   fl fh  fh  xit   xif                                                                            ⊕                                                         cl   cl ch   ch  negationreciprocation                            ·            ·                                                                      bl  bh  negation generalized aadd node   bf                       ·          ·                                                              simple      bf  note  vio                                                                                                               lates normalizationh− −schemei requires             lh        lh      lh     consequently negation performed explicitly          recurse cached result                                                                                           bf  likewise reciprocation hcbf      cl bl fl  apply cl  bl  fl  cl  bl  fl  op   ª                                                                       vi  vi                                                                 ch bh fh  apply       op  performed explicitly   bf                                                                        ®                                cr br fr  getgnodevar ch bh fh  cl bl fl   variable  reordering   generalization rudell’s                                                                                                            result apply cache return  add  variable reordering algorithm  recomputes                                                                                         insert op cr br fr  edge weights reordered nodes   applied                                   →          aadds   loss eﬃciency                              apply cache                                                             return modifyresult cr br fr                                                                                           cache  implementation                             end  use naive cache implementation  lied exact ﬂoatingpoint values hashing equal  ity testing ﬁnd nodes diﬃcult guarantee exact property  exact computation turn eﬃcient hashing scheme outline approx  oﬀsets multipliers diﬀering nu imate approach work eﬃ  merical precision error result§in exponential ciently nearly optimally practice  explosion nodes controlled consequently node cache used getgnode operation  better use hashing scheme considers equality result cache used apply use cache keys containing  range numerical precision error ² ﬂoatingpoint values oﬀsets multipliers                            computeresult   op cr br fr                                                          −→                     operation  conditions                          return value                  bf op   bf                 op                                                               ·              max  bf   bf              bf                                       ≤                                    max  bf   bf              bf                                       ≤                                      bf    bf                        bf                     ⊕                                                                 max  bf   bf                    bf                                                           ≥   ∧   ≥                                                    bf                 ≥    ∧  ≥    ∨    ≥   ∧   ≥                       ≥   ∧   ≥                                       note max operations return opposite min                bf op   bf    op             op  bf                                    ∈ ⊕ ª                                   bf op   bf     op       op  op cf                                    ≥     ∈ ⊗  ®                                   note operations modiﬁed handle   op                                                                                 ∈ ⊕  ⊗                                                           null                                                                                                        getnormcachekey     op modifyresult cr br fr                                         −→  hh   ih    ii                        −→  ri   operation  conditions      normalized cache  key  computation           result modiﬁcation       bf   bf    cr  brfr        bbf                 bcr  bbrfr          ⊕                           ⊕                                               bf   bf    cr  brfr        bbf                 bcr  bbrfr          ª                           ª                         −                     bf   bf    cr  brfr  cb   cb             bbcr  bbbrfr          ⊗                               ⊗                                     bf   bf    cr  brfr  cb   cb             bbcr  bbbrfr          ®                               ®                                        max  bf   bf   cr  brfr  max    cb  bbf   bcr  bbrfr                                            −                                      note min         op  matching    cr  brfr   bf op   bf               cr  brfr                                                                          bf op   bf                    table  input output summaries computeresult getnormcachekey modifyresult routines    aadd   nodes consider tuple                                                                   ﬂoatingpoint values point euclidean space               measure error tuples                                                                                                                                ε   euclidean                                                 distanceh betwieen theseh points asi consequence  triangle inequality dimensions know                                          ε                                                                                          ε                                                                                                  ²       −         −        −         −    ≤    √u       √v         ²                                 ⇒this shown graphically dimensions figure ≤     based inequality use following ap figure  visualization hashing scheme use                                                        points ² dark circle lie  proximate hashing scheme  compute                                                                                   √                                vh                ring having outer inner radius  ²    distance          origin  hashing scheme hashes points within§the ring  hashing extract theh bits thei ﬂoatingpoint                                                        bucket guarantees points ²  base representing fractional portion greater ² hash bucket use squared distancesh  use integer representation hash key avoid √  hash key eﬃciently                                                                                          eﬀectively discretizing distances buckets computed squared distance origin  width ² equality test true metric                                      ²  theoretical results                                    hashing scheme does guarantee present fundamental results aadds  tuples having distance origin      ² hash bucket tuplesh withini² theorem   time  space performance  fall bucket boundaries bucket reduce apply aadds multiplicative  width ²  numerical precision error generally constant adds worst case  small probability proof sketch  variable ordering  nodes equal numerical precision straddling add equivalent noncanonical aadd ﬁxed  bucket boundary empirical results described edge weights     add   reduce  section  hashing scheme suﬃcient prevent apply algorithms seen analogs  uncontrollable cases numerical precision error aadd  algorithms additional constanttime
