                                  firstorder logical filtering                                       afsaneh shirazi    eyal amir                        science department university illinois uc                           urbana il  usa    hajiamineyalcsuiucedu                          abstract                          propositional belief states sets states amir russell                                                         actions observations shown exact ﬁl      logical ﬁltering process updating belief                                                        tering tractable belief states represented propo      state set possible world states sequence                                                        sitional formulae certain natural assumptions met      executed actions perceived observations                                                        domains propositional encodings      general intractable dynamic domains                                                        large possible large numbers objects      include objects relationships po                                                        unknown number objects observations partial      tential applications domains seman                                                        knowledge identity objects      tic web autonomous agents partialknowledge      games encourage research immediate      paper present tractable algorithms theoret      tractability results                             ical results updating belief states represented                                                        firstorder logic fol representations permit belief      paper present polynomialtime algo    states inﬁnite sizes uncertainty number ob      rithms ﬁltering belief states encoded jects identity observations distin      firstorder logic fol formulae sidestep  guish objects enables compact      previous discouraging results show  representations propositional logic      algorithms exact cases                                                          show actions map states       algorithms accept belief states fol                                                        update fol beliefstate formulae efﬁciently linear time      allows natural representation explicit                                                        representation size prior compilation      references unidentiﬁed objects partially                                                        show representation remains bounded polyno      known relationships algorithms en                                                        mial size classes actions including      coding compact important classes actions                                                        actions simple case preconditions actions      strips actions results apply                                                        stripslike preconditions nonconditional ob      expressive modeling languages par                                                        served successfailure present ﬁlter      tial databases belief revision fol                                                        ing algorithms require precompilation ef                                                        ﬁcient update surprising contrast com    introduction                                       mon belief fol used efﬁciently rep  everyday scenarios dynamic partially observ resenting updating partial knowledge winslett   able robot room state lin reiter   room camera overlooking bookshelf detect way contributions form foundations  title book obscured readily ob provide theory fol belief update relate deter  serve money agent applications ministic situation calculus reiter  ﬁrstorder  domains compute information current world transition model blass gurevich   state belief state set possible states distribution belief state set fol models fol language  set actions observations compu state show ﬁltering belief states cap  tation called ﬁltering state estimation belief update tured exactly deduction fol result ﬁltering  database progression use information make deﬁnable fol best hope lin  decisions answer questions explore             reiter  show deduction carried    filtering intractable general discrete domains time step time  eiter gottlob  research dedicated work related limited propositional  approximation stochastic domains boyen case amir russell  boyen koller  koller  approximations introduce  important exceptions cravo et al   bounded errors times unbounded computation dixon wobcke  firstorder agm belief revision  time usable deterministic winslett  belief update revision simple sub  mains recent progress logical methods ﬁltering classes fol lin reiter  progression insituation calculus important difference draw generally values relations functions dy  works provides efﬁcient inference pro namic world vary situation rela  cedures focus use generalpurpose tions truth values vary situation situation  orem provers intractability results             called relational ﬂuents denoted predicate sym                                                        bols taking situation term argument ar    semantics firstorder filtering                 gument true functions  section study logical ﬁltering ﬁrstorder struc deﬁnition  successor state axioms successor state  tures ﬁrstorder language nonlogical symbols axioms deﬁned relational ﬂuent functional  variables function symbols predicate symbols ﬂuent successor state axiom nary relational ﬂuent  ary function symbol called constant note sentence form  binary predicate symbols equality symbol  ossaxn ⇒ ∀y     ∀ym  deﬁne terms formulas generalized induc   pym doaxn ⇔ succpaxn ym  tive deﬁnition variables functions terms predicates                                                        action symbol succpaxn ym  atomic formulas                                  formula uniform free variables    ﬁrstorder language language symbols                                                            xn     ym deﬁne successor state  formulas described turn axiom functional ﬂuent similar way  scription semantics ﬁrstorder languages struc  ture ﬁrstorder language consists           changes world result named ac    nonempty universe domain structure tions action parameterized example      elements called individuals moveb stands action moving object                                              each nary predicate symbol ⊆  room room intended interpretation situa      tuples universe tuples true tions ﬁnite sequences actions doa denotes    each nary function symbol  sn → sequence formed adding action sequences      particular each constant es individual words doa successor situation resulting    sentence ψ true structure denote performing action use situation calculus foun  ψ example suppose structure  dations semantics later section  onwards  predicate ins  hb ri constant csr mention focus belief states  csrs  constant csb csbs  used proofs theorems results  world cs room csr cs book csb predi applicable  cate indicates book room  deﬁnition sentence incsb csr true        example   consider book keeper robot lives    deﬁne logical ﬁltering using situation calculus world consisting rooms robot room  use compatible basic action theory make observations books room  reiter  basic action theory form  book rooms return book library                                                        arbitrary room borrowed book  Σ ∪ dss ∪ dap ∪ duna ∪ ds    • Σ foundational axioms situations     room possible actions moveb returnb    •   set successor state axioms           borrowb actions executable world        ss                                              state change value different predicates functions    • dap set action precondition axioms                                                        predicates roomr bookb inb    • duna  set unique axioms actions      a−→x   a′−→y   a−→x   a−→y  ⇒ −→x  −→y functional ﬂuents constants      a′ action symbols                  deﬁne precondition axiom successor state ax      • ds initial database ﬁnite set ﬁrstorder sen iom action skip      tences uniform                       • precondition axiom  deﬁnition  uniform formula formula uniform     ossmoveb ⇔ bookb s∧roomr s∧  term sort situation mentioned roomr ∧ inb  formula                                                • successor state axioms                                                            ossmoveb ⇒                                                               ′  ′    ′  ′    deﬁne precondition axioms successor state axioms  ∀b  inb   domoveb ⇔                                                                     ′        ′  basic action theory follows                     ∧  ⇒ false                                                                    ′        ′                                                                ∧b   ∧  ⇒ true  deﬁnition  action precondition axioms action               ′         ′                                                               ∧¬b   ∧   precondition axiom sentence form                          ′        ′             ′  ′                                                                   ∧¬b   ∧  ⇒ inb      ossaxn ⇔ precondaxn  nary action symbol precondaxn deﬁnition progression ﬁltering semantics  formula uniform free variables follows      xn                                                        deﬁnition  transition relation structures         xn abbreviation     xn        action theory structure deﬁne transition               ′  lation rds  follows                         deﬁne predicate corresponding each relational ﬂu                                                        ent truth value does depend situation     hs au   s′i   precond  s′                                           snapshot time shows truth values         s′                         hsmi ∈  succpaun sm predicates truth values predicates change          s′                                        moving situation represent predi           hsm sri ∈                        cates symbol relational ﬂuents dif              succfaun sm sr             ferent arity    use xv notion substitution suppose      gr set                                                        stants predicates deﬁne new set symbols  vector variables vector variables constants ′ ′ ′        ′                                                                yn  giynpp′  xv shorthand xv    xv means                                                                     pp′ shorthand g′   g′  view  replacing instances symbol symbol                                                                                          set predicates situation p′ set predi  deﬁnition  logical filtering semantics let σ set cates situation doa  ﬁrstorder structures refer belief state ﬁlter beliefstate formula follows reuse  ﬁltering sequence actions ground obser ilter·· ﬁltering beliefstate formula let ψ  vations ha     oti deﬁned follows ǫ refers                                                        belief state formula aun grounded action cnΨ  sequence                                  set logical consequences Ψ formulae φ    ilterǫσ  σ                                                                       ′              ′                  Ψ  φ cn Ψ set logical consequences    ilteraσ   ∈ σ hs aˆ ∈ rd     Ψ language write cnlΨ set             aˆ                      xv                                 symbols mean cnllΨ    ilteroσ  ∈ σ                                                                                    ′    ilterhai oi     otiσ                                                                                              ilteraunψ  cn ψ ∧ precondaun∧             ilterhai oi     oti                                                                  ′                   ilteroif ilteraiσ         ∀ym piym ⇔ succpiaun ym∧  step  progression step  ﬁltering                                                                    ′                                                           ∀y   ∀z   ⇔ succ       ′    filtering fol formulae                                            fia                                                              deﬁnition ﬁltering applied set ﬁrst  ilteroψ  ψ ∧                  order structures section use fol represent  lief states update representation explicit ﬁlter action assert implicitly pre  reference structures belief state        condition held world state action exe                                                        cutable belief state new belief state false    fol theories belief states                   indicates set prove following  belief state formula ﬁrstorder theory possibly inﬁnite orem deﬁnition ﬁltering approximates seman  represents belief state structure belief state tics deﬁnition   satisﬁes belief state formula use theory theorem  let ψ belief state formula  instead formula required set ﬁrstorder action  consequences ﬁrstorder formula inﬁnite                      ′                                                          ilteras  ψ ⊆  s′ ilteraψ  representable fol formula    simplicity use logical connectives proof section  fol formulas meaning connectives lin reiter  showed progression al  ﬁrstorder theories follows                    ways ﬁrstorder deﬁnable proved pro    ϕ ψ theories inﬁnite size          gression exists set second order sentences    • ϕ ∧ ψ mean ϕ ∪ ψ                            ﬁnite initial databases sides theorem    • ϕ ∨ ψ mean α ∨ β α ∈ ϕ β ∈ ψ similar  equivalent formula  fol      demorgan law                                   words fol strong model progression    • applying negation ¬ assume ϕ initial database following corollary shows      ﬁnite theory logical formula       sides theorem  equal pro    • ∃ replace ∃ new constant symbol gression database fol deﬁnable    rest paper say ”belief state  formula” refer fol theory unless sanctioned corollary  let ψ ﬁrstorder belief state formula  wise assume ﬁrstorder fol represent progression ψ performing                                                        action  language function symbols constants                               ′                                                          ilteras  ψ   s′ ilteraψ    basic algorithm                                      point  assume  progression  section show progress initial ﬁrstorder deﬁnable basic algorithm computes  database represented logical formula applying ilterha  otiψ iteratively applying ﬁltering  single action observation result progression beliefstate formula action observation  new database progression algorithm use sets ψ  ψ ψi  ilteroif ilteraiψi−recursively   using equations deﬁned fresh constant symbol   hold  algorithm correct shown corollary  ilteraϕ ﬁnite  implemented using ﬁrstorder consequence ﬁnder       say stronger actions act                                                        mutations structures executable    sequences actions observations                                                        deﬁnition  permuting actions action permuting  section shows iterative applications progression  structure s′  steps lose information throw away pre s′  vious database start working new  forming each action                                    domains include permuting actions called    break action theory parts initial permutation domains    database ds rest dg  dg ∪ ds  theorem  distribution permutation domains let  deﬁne language action theory follows permuting action let ϕ ψ formulae                                                            deﬁnition  language ld set ﬁrst ilteraϕ ∨ ψ ≡ ilteraϕ ∨ ilteraψ  order formulae predicate function symbols occur  ilteraϕ ∧ ψ ≡ ilteraϕ ∧ ilteraψ                                                                                                 true                                                      iltera¬ϕ ≡ ¬f ilteraϕ ∧ iltera                                                            iltera∃x ϕx ≡ ∃x ilteraϕllx    instance   puta ∧ ∀x boxx                                                       decompose ﬁrstorder formula set  puta ∀x∃y putx ld  boxa                                                     single literals using distribution properties proved                                                         instance ∀x ϕx ∧ ψx equivalent ∀x ϕx ∧    progression assume ground action ∀x ψx rule  break parts ∀x ¬ϕx  formed looking set sentences                                               sa       equivalent ¬∃x ϕx rule  rule  used  serve new initial database sa denotes situation ∀x ϕx ∨ ψx equivalent ¬∃x ¬ϕx ∧ ¬ψx                                              term doa unfortunately lin reiter  showed rule  rule  rule  used  ﬁrstorder deﬁnable       sa                                                 permutation domains decompose formula    deﬁne     set ﬁrstorder sentences uniform             fsa                                        set grounded ﬁrstorder single literals ﬁltering    entailed  use  instead      sa                    fsa         dsa             single literal use formula   ﬁrstorder sentence future                   ψ                 sa  fsa ∪ dg  ψ     factored ﬁltering ff algorithm permutation  iff  ψ following theorem states result mains presented figure  relies theorems     note intersection consequences action   number different grounded single literals  theory ldg ∪ sa uniform sa            ﬁnite number objects ﬁnite  theorem   let action theory deﬁne   calculate ﬁltering single literals preprocess          ′  follows                                ing step retrieve later ﬁnite domains                                                          note arguments literals        cnd ∪  doa ∩ ldg ∪   stants associated existential quantiﬁers constants        cnd ∪  doa ∩ ldg ∪   mentioned initial belief state set ax     ′                                                  ioms observations        cnd ∪  doa  doa             ∩ldg ∪                                                         procedure ffhai oiii≤tψ                                                         ∀i action observation ψ beliefstate formula  actions necessarily different                                                ′                  return ψ  occur dg                                                              return ot∧ ffstepat    proof    section                                         precondat ∧ ffhai oiii≤t−ψ     instance   book  keeper  example     procedure ffstepaψ                                                         action ψ beliefstate formula  ds    bookb roomr inb     ﬁrst action  returnb ds           ψ single literal return singleliteralfilteringa  bookb roomr ¬inb                 ψ                                                            use distribution properties ffstep recursively    factored inference                                      subformulas ψ  distribution properties hold logical ﬁltering  decompose ﬁltering formula ϕ logical figure  filtering fol formula actions  nectives ∧ ∨ ¬ ∀ ∃                               permuting actions  theorem  let action let ϕ ψ ﬁrstorder  formulae                                       theorem  algorithm ff correct ﬁltering    ilteraϕ ∨ ψ ≡ ilteraϕ ∨ ilteraψ single literals given algorithm ff run     ilteraϕ ∧ ψ ⇒ ilteraϕ ∧ ilteraψ time opreconda ∧ ψ ψ belief state formula     iltera¬ϕ ⇐ ¬f ilteraϕ∧f ilteratrue factored ﬁltering algorithm uses consequence ﬁnding    iltera∃x ϕx ≡ ∃x ilteraϕllx    tools preprocessing does affect theruntime open systems time different procedure ucfilterhai oiii≤tψ  new objects added during operation ∀i ai action oi observation ψ beliefstate formula  systems ﬁltering new single literals    return ψ  computed running                      ψt−  ucfilterhai oiii≤t−ψ                                                              return ot∧ filtertrueat ∧ ucstepat precondat ∧ψt−    filtering algorithms different domains          procedure filtertruea  naive ﬁltering algorithm uses consequence ﬁnding tools action  scale large domains following theorem  possa ⇒ condi ⇒ pi ⇔ φi instantiated successor  suggests different reasoning procedure                  state axiom  ≤ ≤                                                             ∅  theorem  let action ψ belief state formula   ≤ ≤  Φϕn ﬁrstorder logical formula atomic    φi  true add casei ⇒ pi  subformulas ϕ     ϕn                 elseif φi  false add casei ⇒ ¬pi                                                              elseif uniﬁableφi φj  add    ilteraψ ≡ Φpn fol formula Φ                                                                 condi ∧ condj  ⇒ pi ⇔ pj mguφiφj             ψ ∧ preconda  Φsuccpa     succpna   elseif uniﬁableφi ¬φj  add                                                                 cond ∧ cond  ⇒ ⇔ ¬p           formula possible Φs considered                       mguφiφj                                                               elseif φi  ∀x qx φj  qt add  general generating Φs impossible cond ∧ cond  ⇒ ¬p ∨   ﬁnitely Φs following sections pro                                                                                     elseif φi  ∃x qx φj  qt add  vide simpler closedform solutions special cases    condi ∧ condj  ⇒ pi ∨ ¬pj   dynamic domains rise practicalpolynomial  return  ϕ                                                                  vϕ∈s  algorithms                                                         procedure ucstepaψ    unitcase successor state axioms                  action ψ beliefstate formula  deﬁnition successor state axioms pair ac  ψ single literal                                                              possa ⇒ condi ⇒ pi ⇔ φi instantiated  tions predicates exactly successor state axiom pro successor state axiom  ≤ ≤  vided successor state axiom action predicate  ∅  pi rewritten                                      ≤ ≤  ossax   ⇒ ∀y      ∀y  doa ⇔         uniﬁableφi ψ add                                                      case ⇒                 case ⇒ φ ∧    ∧ caseli ⇒ φli                            mguφiψ                                                         ii elseif uniﬁableφi ¬ψ add                           li     li        ∧¬casei ∧    ∧ ¬casei  ⇒ φi                          casei ⇒ ¬pimguφiψ                                                              return   ϕ                                                                    vϕ∈s  casei form yj  xj  ∧    ∧ yjk  xjk   use distribution properties ucstep recursively  variable xj argument action variable yj subformulae ψ  argument predicate each variable assignment sat  isﬁes cases successor state axiom         figure  unitcase filtering  called unitcase successor state axiom rewritten                     form φi  ≤ ≤ li   unit clause    break unitcase successor state axiom multiple belief state formula distribution properties  instantiated axioms instantiated successor state axioms                                                                                         used consequently Φsubsucca     subsucca  predicate pi                                                      equivalent literal tautology tautology    • ossaxn ⇒ piym doa ⇔ φ                                             yi xi  size unitcase successor state axioms used       ≤ ≤ li                                compute desired Φs ﬁnite number                                               li    • ossaxn ⇒ ∀ym ¬casei ∧  ∧¬casei  ⇒ steps      piym doa ⇔ φli                                              theorem  let number successor state axioms  yi xi  substitution corresponding casei yi xi  sequences variables process called breaking breaking cases ψ belief state formula  cases note instantiated successor state axioms each predicate arity algorithm ucfilter                                                                                                       form ossa ⇒ condi ⇒ pi ⇔ φi returns ﬁltering ψ action time ·  ·  condi true enumeration instan · ψ ∧ preconda length new belief state formula                                                                 tiated successor state axioms action            ·  · · ψ ∧ preconda    figure  shows unitcase ﬁltering ucfilter algo  rithm algorithm applicable permutation corollary  given sequence actions observa  mains successor state axioms unitcase tions algorithm ucfilter returns ﬁltering ψ time                                                                       algorithm ucfilter actually way compute ot  · ·   · · · ψ length belief state                                                     formula step ψ  ot · rt · kt  rt · kt · ψ   Φsubsucca     subsucca formula  permutation                                          domains head entailment formula  single lit length observations preconditions actions  eral action precondition considered conjunct negligible compared length belief state formula
