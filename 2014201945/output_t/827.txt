 scalebased monotonicity analysis qualitative modelling flat segments                         martin brooks    yuhong yan      daniel lemire                  national research council                      university quebec                   montreal road                        avenue henrijulien                    ottawa ka                           montréal qc ht                   martinbrooksnrcgcca                        lemireondelettecom                    yuhongyannrcgcca                        abstract                          fast require excessive amounts memory                                                             qualitative models suitable     paper address “scalebased monotonicity”      classical quantitative models tasks    problem monotonicity deﬁned relative scale      modelbased diagnosis mbd explaining    deﬁne metric monotonic approximation solve      behavior designing novel devices ﬁrst   following problem given number segments ﬁnd      principles monotonicity important feature  segments having smallest monotonic approximation error      leverage constructing qualitative models                                                          short main novel results paper      detecting monotonic pieces robustly efﬁciently      sensor simulation data remains open       novel optimal segmentation algorithm      problem paper presents scalebased mono       novel deﬁnition scalebased ﬂatness      tonicity notion monotonicity      ﬁned relative scale realvalued functions  monotonicity qualitative modelling      ﬁned ﬁnite set reals sensor data      simulation results partitioned quasi just list examples show monotonic      monotonic segments segments monotonic  features important leverage qualitative modeling      respect scale linear time novel segmen qsim kuipers  qualitative value qv      tation algorithm introduced scale pair qmag qdir qmag landmark value      based deﬁnition “ﬂatness”                     li interval landmark values lili                                                        qdir takes value sign domain  according                                                        increasing steady decreasing respectively    introduction                                       modelbased diagnosis mbd qualitative models  qualitative models used applications model used behavior kinds qualitative  based diagnosis yan  struss  explaining models based respectively absolute relative quanti  behavior Šuc  forbus  kuipers  ties rely monotonicity function ﬁrst  signing novel devices ﬁrst principles williams  finite relation qualitative model frq struss   challenge build qualitative models complex real yan  qualitative relation represented  world engineering systems current research efforts tuples real valued intervals monotonic segment  automatic generation qualitative models numerical xaxb  tuple determined bounding rect  data obtained numerical simulation sensors pro angle   xaxb × min xa xbmax xa xb                                                                                                  posed methods struss  console et al smallest rectangle  xa ≤ ≤   work functions piecewise mono xb ⇒ xy ∈  second qualitative deviation  tonic partitioning data arrays quasimonotonic model console et al  qualitative relation  segments important problem yan et al represented sign deviation ∆y refer    segment data array monotonic segments ence point xre deﬁned   according  using naïve algorithm simply segment increasing decreasing ﬂat example  extremum example easy segment array monotonic increasing ∆y  sign x− xre           monotonic segments signx − xre   ∆x  monotonic segments signiﬁcant appli paper focus abstracting qualitative models  cation hand algorithms robust scattered data obtained numerical simulation  data unavoidably subject noise insigniﬁcant sensors work motivated kinds appli  features want consider array cations applying modelbased diagnosis real         “signiﬁcant” mono world engineering systems need build symbolic qual  tonic segments drop   large itative models numerical simulation engineering  indicate downward trend algorithms models second need explain behaviors fromsensor data qualitative model abstraction paper min ∈Ω maxx∈d  − Ω Ω↑ Ω↓ sign   deﬁned transforming numerical values qualitative val  associated Ω↑ Ω↓  ues functions qualitative constraints Šuc bratko segmentation set sequence    monotonicity analysis deﬁned partitioning ﬁ xxm closed intervals called “segments”                                                                        nite series real values xxxn interval mindmaxd  xi maxxi  minxi xi ∩  “monotonic” segments                                 xj    ii  −  alternatively deﬁne    monotonicity analysis crucial step abstract qualita segmentation set points xi ∩ xi  yi given  tive models scattered data rises problem  xxn → segmentation xi optimal  difﬁculty scattered data contains noise piecewise monotonic approximation function error op  monotonicity absolute neighborhood point mafe segmentation given maxi omafefxi   monotonic segments need signiﬁcant context directions segments xi alternating  problem small ﬂuctuations caused noise direction ﬁrst segment chosen  ignored requires noise removed compu minimize opmafe  tationally efﬁcient methods number remain solving best monotonic function fol  ing segments dependent characterization lows seek best monotonic increasing function  noise                                                ﬁrst deﬁne ↑x  maxfy  ≤ maximum    linear splines obvious approach solve prob previous values  minfy  ≥ mini                                                                            ↑  lem use topdown bottomup sliding window mum values come seek best monotonic  algorithms approximate data set straight decreasing function deﬁne  maxfy  ≥                                                                                  ↓  lines keogh et al   samesign slopes maximum values come  minfy   aggregated monotonic segments various algorithms                                  ↓  derived classic algorithms key et al  hunter ≤ minimum previous values func  mcintosh  downside methods tions computed linear time need  link linear spline approximation error solve best approximation function shown  actual monotonicity data consider  ex theorem wellknown result brooks   using linear splines difﬁcult specify desired ubhaya   number monotonic segments “monotonicity error” theorem  given   xxn → best mono  threshold addition linear ﬁtting algorithms relatively tonic increasing approximation function given  expensive                                                                                                              ↑  ↑    inductive learning used Šuc bratko  au f↑  best monotonic decreasing approxima                                                                                    tomatically construct qualitative models quantitative ex                   ↓  ↓                                                        tion function given f↓    corresponding er  amples induced qualitative model binary tree called                       −                                                                                       ↑ ↑  qualitative tree contains internal nodes called splits ror omafe given maxx∈d  monotonic                                                                            −    qualitatively constrained functions leaves quali         ↓ ↓  tative constrained function takes form mssm  rm → creasing maxx∈d  monotonic decreasing  si ∈ − represents function realvalued implementation algorithm suggested  tributes strictly monotone increasing respect ith orem straightforward given segmentation com  attribute si   strictly monotone decreasing si  − pute opmafe time using passes                   −  example   xy means increasing functions f↑ f↓ called standard  increasing decreasing increasing split optimal monotone functions solution unique  partition variable unsupervised learning algo general  rithm eqquin determines landmarks splits  training data set possible pairs data points eqquin  scalebased monotonicity  checks best split possible hypotheses com  plexity onm quin efﬁcient algorithm present notion scalebased monotonicity  uses greedy search complexity onm tuition ﬂuctuations certain scale  address multidimensional data paper          ignored                                                          given ordered set real values  xxxn                                                                                          monotonicity error                                 consider   xxxn →  given toler                                                        ance value δ   say data points  section deﬁne measure monotonicity sup going upward monotone consecutive mea  pose given set ordered samples noted  sures δ                       xxn ⊂ →    real values fxfxn fxi−fxi  δ deﬁnition use      xn deﬁne fab restric ful measures repeatedly  tion ∩ ab seek best monotonic end value substantially lower start value  creasing decreasing function  → approximating useful deﬁnition upward monotonicity  let Ω↑ resp Ω↓ set monotonic increas require ﬁnd values xi xi   ing resp decreasing functions optimal monotonic fx lower fxi δ fxi − fx  δ  approximation function error omafe given deﬁnition useful worst case                                                         scalebased algorithm                                                            quasimonotonic segmentation                                                        suppose ﬁnite set reals having ele                                                        ments realvalued function  →                                                          begin deﬁning segmentation scale δ δ                                                        segmentation             δ                                                        deﬁnition  let  xxn segmentation                                                        let δ   δsegmentation fol                                                        lowing conditions hold             δ                                              • each xi δmonotone                      δ−pair                                                          • each xi  strictly δmonotone                                                          • xi strictly δmonotone                   figure  δpair                    • adjacent strictly δmonotone segments opposite di                                                            rections  measure δ smaller ﬁrst measure • each strictly δmonotone xi ∈ xi fx  guaranteed data does fact lies closed interval bounded fminxi  increase point add constraint fmaxxi  ﬁnd data points xk  xl fxl • strictly δmonotone ∈                          δ                δ                         greater fxk fxl − fxk ≥         − maxx fx lies open interval bounded                                δ    summarize given value   say se   fminx  fmaxx xn                               δ  quence measures upward monotone succes  strictly δmonotone ∈ xn − minxn fx                                  δ  sive measures decrease  pair lies open interval bounded fminxn−                                       δ  successive measures increases  similarly fmaxxn−  say set measures downward δmonotone           δ                       δ                                        δ               each xi called segment strictly monotone  successive measures increase  proper δsegment strictly δmonotone  measures decrease δ                                                                                                                          xn improper δsegment strictly δmonotone xi    generalized deﬁnition monotonicity introduced minx maxx δextrema  brooks  using δpairs fig                                                                                following theorems show δsegmentations  deﬁnition                                           “equivalent” monotonic approximation error op    •  ∈ δpair pair scale δ fy− mafe known precisely      fx ≥ δ ∈   implies fz − theorem  let δ   let δsegmentations      fx  δ fy − fz  δ                   furthermore ﬁrst δsegments        δ                                               proper improper similarly    •  pair’s direction increasing decreasing accord δsegments      ing fy  fx fy  fx                                                        theorem   let δ   let δsegmentation    notice pairs scale δ having opposite directions monotonic approximation error opmafe ≤ δ                                                   δ  overlap share endpoint pairs scale                     δ  direction overlap nested want compute segmentation given  certain δ                                          approaches depending application                                                        mind ﬁrst choose δ solve    deﬁne δmonotonicity follows                                                        segments brooks  magnitude noise                                                        known doesn’t know choose δ second  deﬁnition  let interval δmonotone approach set maximal number segments espe  δpairs direction strictly δ cially knows shape function focus  monotonic exists δpair second approach begin labelling extrema  case                                                 corresponding scale ∆x    • δincreasing contains increasing δ deﬁnition  let ∈ local extremum x’s delta      pair                                             scale ∆x largest δ   exists δ                                                        segmentation having δextremum    • δdecreasing contains decreasing δpair                                                          immediate deﬁnition δ  ∆x                                                      say pair signiﬁcant scale δ scale δ can’t δextremum δextremum        δ ≥ δ                                            ∆x ≥ δ stated following proposition                                                          proposition  let δ   let  xxn δ    section discuss partition data set segmentation ∆x ≥ δ δextremum  monotonic segments                               observe smallest δ algorithm  computes ∆x extremum ∈  cardinality xδ  x∆x ≥ δ input algorithm  list extrema  extrema data  set xδ contain repeated maxima repeated minima points data array  removed set xδ deﬁne  δsegmentation stated theorem   algorithm  algorithm labels extrema linear time  theorem  let δ   consider set extrema xδ  deﬁnition   x∆x ≥ δ ordered set each extremum xδ input data  list successive extremal values al  maximum minimum sequence ternating maximum minimum each element                                                         extremum record having three ﬁelds value sense index  minima maxima possible consider subset xδ ⊂ xδ                                                index identiﬁes data point value gives f’s value data                                                          point sense indicates extremum maximum    • repeated maxima minima                minimum                                                       output list scale records each scale record    • superset xδ xδ xδ repeated ex ﬁelds scale extremalist extremalist comprises      trema                                              extremum records semantics scale record                                                         indicated extrema indicated scale deltascale  exists δsegmentation xδ ex              δ                                           notes algorithm  lists accessed element  actly set extrema                         numbers data second element data  lists    order compute ∆x extrema useful manipulated functions push pop push thing list   introduce following deﬁnitions                     adds thing list resulting thing ﬁrst element list                                                          poplist removes ﬁrst element list returns ﬁrst  deﬁnition  oppositesense extrema  ∈ ⊂ element value function  makelistitem∗  extremal pair ∈   implies fy pushes items list generated starting ﬁrst item  lies closed interval deﬁned fx fz ex  makescalerecord creates scale record  tremal pair extent fx fz fz fx  increasing decreasing direction according fx  fz let extrema  emptylist  fx  fz extremal pair maximal  let scales  emptylist  extremal pair larger extent similarly push popdataextrema  extremal pair maximal increasing decreasing push popdataextrema  increasing decreasing extremal pair larger extent nextextremum data                                                            lengthextrema   sensenextextremum     intuitively maximal extremal pair forms largest maximum valuenextextremum  valueextrema  creasing increasing segment inside larger increasing sensenextextremum  minimum  creasing segment                                      valuenextextremum  valueextrema                                                              pushmakescalerecord  valueextrema   deﬁnition  recursively deﬁne ordinary special  valueextrema  makelist extrema extrema   tervals ordinary interval ordinary   scales  interval interval ⊂ special j’s endpoints popextrema  constitute maximal extremal pair case popextrema  direction inherited directly endpoints recursively length extrema     special interval  endpoints constituting push pop extremalistscales  extrema   maximal extremal pair direction opposite push nextextremum extrema   special let  special intervals lengthextrema                                                            push makescalerecord  valueextrema   ordinary special interval choose nonempty sub valueextrema  makelist extrema  scales  set collection ji let segmentation popextrema  deﬁned endpoints special intervals subset push  extrema extremalistscales   segment ∈ does contain ji return scales  ordinary interval    special intervals nested principle algorithm  follows loop  endpoints xz special intervals ∆x  ∆z  inside loop detects special interval labels  fx−fz “twins” ∆x endpoints difference values  value ordinary intervals nested endpoints extrema list labelling means  ordinary intervals different ∆x each item list needs checked com  “singleton”                                     ing data item popped extrema fol    extrema having equal value way lowing extremum pushed  choose endpoints constitute maximal extremal pair extrema list loops outside  unique different sets special loop determines δ ordinary intervals  intervals equivalent simplicity push states extremum extrema list  sider case equal valued extrema algorithm  scale just popped scale actually  algorithm  instead explain deal verbally endpoints biggest ordinary interval  introducing algorithms                     pushed scale record list scales identical  desires segments simple mat                                                                                                      ter picking δ small possible                                                                                         signiﬁcant extrema ∆x ≥ δ                                                                                         ﬁrst extrema indexes  −  algorithm                                                                                          shows labelling complete compute                                                                                        segmentation time onk logk consider                                                                                       −                −  linear time small compared uses                                 ﬁxed memory ok principle algo  rithm  select   data points endpoints figure  input ﬂow tank left level tank right  segments endpoints default added white noise  remaining endpoints come largest δextrema                        δ  select largest extrema algorithm   scalebased flatness  know labels twins singleton  loop maximum   data points chosen applications important able ﬁnd “ﬂat” seg  ﬁrst outside smallest δextrema ments robustly data set propose following deﬁ  removed reduce total endpoints   nition  rest code checks ﬁrst endpoints deﬁnition  given δ   consider δmonotonic segment                                   δ  included smallest extrema δsegmentation interval segment δﬂat  moved favor ﬁrst endpoints number standard optimal monotonic approximating function  segments extrema deﬁned theorem  constant  δ value removed                                                          compute standard optimal monotonic                                                        approximating function time ﬁnd ﬂat seg  algorithm  given labelling algorithm algorithm  ments time  algorithm returns optimal segmentation using proposition addresses ﬂat segments differ  segments assumed  extrema ent δsegmentations ﬁrst point derived fact  begin                                        δ increases new segments    input array containing values indexed  −  result mergers previous segments seg    input bound number segments desired  ments small δ subsets segments    output  segmentation points theorem  proposi larger δ second point says old ﬂat segments    tion                                               ﬂat merged segment     ←                          array capacity                                              δ                        δ    index extremum having scale δ visited proposition  let segmentation let                                                                             increasing order                                 segmentation δ  δ  δsegment ∈      insert eδ sorted scale decreasing order subset δsegment ∈  δﬂat interval      sort δ using binary search                   δﬂat      lengthl           pop lastl    lengthl                                 experimental results      remove elements having scale lastl  cascade tank sample data    indexes −  ⊂      index  ∈ index −  ∈ lengthl  source synthetic data consider                                                   consists cascade tanks each tank        remove elements having scale lastl pipe incoming water output pipe outgoing wa      index  ∈ index n− ∈ lengthl ≥ ter tank a’s output pipe input pipe tank        remove elements having scale lastl equations let level water    return  indexes adding  andor −  al tanks respectively change water level proportional    ready present                                       difference input ﬂow output ﬂow                                                        sume input ﬂow tank ﬂow                                                        tank gb output ﬂow tank kuipers     algorithms   assume extrema  value case equal valued extrema mod  ify algorithms increasing complexity              −  algorithm  generalize scalerecord entries             − gb  extremalist ﬁeld lists extrema  value loop extrema principle gb increasing functions  value corresponding list algorithm  assume  ka gb  kb variate input  just need remember removing middle point ﬂow tank control level tank  equal valued extrema equal valued ex way generated sample data added noise  trema treated extrema avoid having fig  input ﬂow tank left  adjacent minima maxima                            level tank right
