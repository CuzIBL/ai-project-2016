                      integration golog planning          jens claßen     patrick eyerich∗    gerhard lakemeyer       bernhard nebel∗                department science    rwth aachen  aachen germany                                   classengerhardcsrwthaachende           ∗ department science university freiburg  freiburg germany                                eyerichnebelinformatikunifreiburgde                        abstract                            passengers served following                                                        choose passenger plan route location follow      action language golog applied suc   route pick passenger plan route destination      cessfully control robots   follow route drop      things greatest advantage    planning easily speciﬁed golog trying      user write programs constrain search actions nondeterministically forwardsearch manner      executable plan ﬂexible manner  til given goal satisﬁed reiter  possi      general planning needed golog sup ble principle quickly infeasible ex      ports principle does measure ample small grid worlds modern planners like      stateoftheart planners paper ff hoffmann nebel  hsp bonet geffner      propose integration golog planning  hand capable handling larger      sense planning problems formulated planning problems natural try combine      golog program solved modern planner   golog modern planner focus planners      during execution program fo  adl pednault  subset plan language      cus adl subset plan language pddl  pddl  fox long       show semantics adl      integration issues arise differences      understood progression situation calculus expressiveness correctness embedding      underlies golog providing   bats situation calculus use power ﬁrst      correct embedding adl golog    order logic adl descriptions restricted exam      show golog integrated existing ple assume ﬁnite domain initial state consists      adl planner closedworld initial databases literals difﬁcult map      compare performance resulting   adl bats purposes paper sufﬁce      original golog                          simply use bat result mapping                                                        companion paper eyerich et al  discusses expres    introduction                                       siveness issue  action language golog levesque et al  correctness need make sure plan  applied successfully control robots burgard et al turned adl planner given goal state descrip   things based reiter’s version tion legal plan situation calculus cor  situation calculus reiter  socalled basic ac responding situation semantics pddl’s adl sub                                                                             tion theories bats deﬁne action preconditions set fox long  given terms state transitions                                                                                                    effects initial situation combined adaptation lifschitz’ semantics strips lifschitz                                                              programming language offers imperative program   roughly state consists set literals tran  ming constructs nondeterministic action choices sition plan operator obtained adding deleting                                                                                                           greatest advantage golog user literals extending earlier work lin reiter    write programs constrain search executable able show adl semantics captured pre  plan ﬂexible manner general planning cisely progression situation calculus refers  needed golog supports principle through use updating description initial situation  nondeterministic actions does measure clusions future drawn using updated  stateoftheart planners                            theory drawn theory                                                        update nice sideeffect obtain purely declarative    running example consider taxidriver agent grid                                  world task deliver passengers destina semantics adl situation calculus  tions actions pickup dropoff moving pednault’s   original semantics adl deﬁned op  left right square grid golog agent’s high erators similarly additions deletions tuples  level control program speciﬁed like relations functions ﬁrstorder structures derived sit                                                     ijcai                                                      obtain results use variant situation σ ∈ r∗ considered sequence ground actions  calculus called es recently proposed lakemeyer ρ   rrk kary ground ﬂuent atom  levesque  compared reiter’s situation calculus world mapping    advantages translation firstorder variables interpreted substitutionally  adl new situation calculus simpler rigid terms rier treated isomorphic  situation terms worry es  situations occur ﬁxed universe discourse similar levesque  semantics semantic deﬁnitions like progres lakemeyer  standard names used  sion simpler longer necessary consider domain given world sentence αwede  arbitrary ﬁrstorder structures certain ones ﬁne  α  α  ﬁxed universe discourse simpliﬁcations lead σ  rrk iff wσf rrk    loss expressiveness fact lakemeyer levesque σ  iff identical   showed es captures precisely nonepistemic σ α ∧ β iff σ  α σ  β  fragment situation calculus golog          σ  ¬α iff σ   α                                                                                    establishing adl plans correct cor σ  ∀x α iff σ  αr foreveryr ∈  responding bat turn embedding adl plan σ rα iff σ ·  α  ner golog particular use latest version σ  α iff σ · σ  αforeveryσ ∈ r∗                                                                   ff hoffmann nebel  implemen notation α means result simultaneously replacing                                                                   tation indigolog sardina et al   incorporates free occurrences variable term  online execution reiter’s forwardsearch planner pro Σ set sentences α sentence write  gression present ﬁrst experimental results showing Σ  α read Σ logically entails α mean  payoff using golog ff versus pure golog        α        α ∈ Σ      α        α                                              es                           read    paper proceeds follows ﬁrst introduce α valid abbreviates   α  show bats formulated logic deﬁne  adl problem descriptions provide formal semantics basic action theories basic action theories  mapping basic action theories section  ﬁned similar reiter’s set sentences Σ basic ac  deﬁne progression establish correctness updating tion theory iff mentions ﬂuents given set                                                                       ΣΣ     ∪ Σ  ∪ Σ  adl state respect progression section  form  pre  postwhere  discuss integration golog ff conclude • Σ ﬁnite set ﬂuent sentences                                                          • Σ                             ≡ π      π    logic  es                                            pre singleton form poss                                                             ﬂuent free variable  language ﬁrstorder modal dialect equality                                                          • Σ   ﬁnite set successor state axioms form  predicate function symbols simplicity assume    post                                                            af  ≡ γf  each ﬂuent ∈fposs  predicates ﬂuent function symbols                                                            γf ﬂuent formula free variables  rigid predicates changed actions func                                                              tions logical connectives ∧ ¬ ∀                                                                        Σ                            Σ  modal operators  term idea  represents initial database pre                                                                                     Σ  including variable connectives like ∨ ⊃ ≡and∃ large precondition axiom post set successor  used usual abbreviations                  state axioms ﬂuents incorporating reiter’s    terms formulas built primitives solution reiter  frame problem  usual way let denote set ground terms  simplicity instead having variables action  adl  sort distinct object sort situation pddl’s adl subset goes strips supporting  calculus lump allow use equality conditional effects typing preconditions                                      rα    α  term action object read “ holds contain negation disjunction quantiﬁers  action r”andα “α holds sequence  actions” formula free variables sentence adl problems deﬁned  formula ﬂuent does contain   ﬁnite list types ττl object  operators does mention special predicate poss ﬁnite list statements form  used denote executable actions addition                                                                           τieither τi ···τi           introduce following special notation type τ unary                          ki  predicate write ∀xτφ instead ∀x τx ⊃ φ                                                            deﬁning τi union τij aprimitive type  semantics intuitively world determine does appear lefthand side  ﬂuents true just initially sequence deﬁnition distinct object  actions formally let denote set pairs σρ                                                           free variables understood universally quantiﬁed  uation calculus formulas adl operators did show outside  lower syntactic precedence logical connec  semantic correspondence              tives possa ≡ π stands ∀apossa ≡ π    original es considers epistemic operators construct higher precedence logical connec  need left                       tives af x ≡ γf abbreviates ∀aaf x ≡ γf                                                      ijcai                                                                                                               ∃z         ∃z          ∧     ﬁnite list ﬂuent predicates ffn              xcoord   ycoord                                                                            ∧¬∃z                                     fj             τj τj                     passenger        associated each list types    kj                                                             inyy      each argument fj  abbreviated τ fj                                                             picking possible taxi    ﬁnite list objects associated primitive types       τ τ                                         location passenger            ok object symbols constants      taxi assume hold    ﬁnite list adl operators aam  person time    initial state                    drop passenger ytaxi true                                                             ∀x       ∀x             goal description form precondition formula   taxi  passenger                                                                ∧ inxx ⇒¬inxx  contain symbols items                                                              finally possible drop taxi’s occupant  require symbols distinct particular                                                            current location  forbids using type fj using object  ai objects implicitly type objectwhichisa  initial state closed world  supertype types case closedworld plan  attaxi   atpassenger    ning initial state simply given ﬁnite set ground destinationpassenger    ﬂuent atoms  set ground literals    connects  east      adl operator triple  τπa awhere τ      connects  north                                        list variables associated types πa precondi  goal description  tion formula  effect formula free vari  ∀p          ∀x       ∀y                        π                                               passenger   xcoord   ycoord  ables  constructed using           destinationp ⊃ atp   symbols items   problem  description operator pary fox long  statetransition semantics  function symbol number parameters deﬁned applying adl operators closedworld                                                                                                            precondition formulas following atomic case idea roughly given closed state                                                         represented set ground atoms operator ap   mula equality atom  each                                                        precondition satisﬁed application  ti variable constant precondition                                                        ap  results new state i obtained  mula φ φ precondition formulas                          −                                                        deleting fj  γ  op   holds  φ ∧ φ ¬φ ∀xτφ loss generality                       fj                                                                           γ    op    sume effect formula conjunction effects adding fj holds  following forms each kind each ﬂuent fj                                                           mapping adl     es                                  ∀x τ  γ  ⇒ fj                     fj                             section generalize approach lin reiter            ∀x  τ   γ−    ⇒¬f                       fj fj                        show applying adl operators corresponds                                                        certain form ﬁrstorder progression es webegin             γ ⇒   ψ  notation       stands conditional effect constructing given adl problem description                    γ  precondition formula holds performing action corresponding basic action theory Σ  ψ true                                                        successor state axioms Σpost coincidence  example   let consider taxi domain reasons normal form  resembles effect axioms used  space consider operators initial state goal reiter construct successor state axioms solution  description                                          frame problem generalizing approach applied    operators                                        pednault  transform set operator descrip                                                        tions set successor state axioms follows let      ytaxiydirection true                                                                                               def                                    ∀x        ∀x         ∀x                             γ                 ∃y ia  aiy ∧ γ         object   xcoord   ycoord                        fj                                fj ai          ∃z        ∃z                                                         xcoord   ycoord                                    γ    ∈nfai              ∧       ∧                    fj ai                  connects                                                                                    γ     ∈ nfai              ∨ inyx ⇒ atxxx ∧   “ fj ai        ” mean disjunct                                                                                                 ∀xobject ∀xxcoord ∀xycoord                                           γ                                                        fj ai effect         ∃zxcoord ∃zycoord                                                    −                                                        ai using similar deﬁnition γf  successor           atyzz ∧ connectsxxyzz∧                                                                                           state axiom fj              ∨ inyx ⇒¬atxxx                                                                                                   −                                                              afj ≡ γ ∧ τ ∨ fj  ∧¬γ      possible taxi            fj                    fj         main cardinal directions lead                                                                       additional conjunct τ fj  ensures fj      grid effect moving location true instantiations consistent      taxi passenger changed accordingly type deﬁnitions fj ’s arguments      pickup ytaxiypassenger                                                                                                                      recall  does require conjunct each fj ai                                                                yτ understood list pairs yiτi   τt abbreviates τt ∧···∧τktk                                                     ijcai                                                      semantics deﬁnes predicates ﬂuent initial situation  operators spe  types situationindependent additionally cial form Σpost deﬁned earlier ensures facts  clude each type τi successor state axiom        remain true successor situations                                                          encode actual initial state include each fj                   aτix ≡ τix                                                                               fjx  ≡   ∨···∨x     applying example                                                    γ   ∃y ∃y       ∧                                                         fjo fjo                                             case closed world assuming                  ∃zxcoord ∃zycoord                      atoms mentioning fj openworld problem            atyzz ∧ connectszzyxx∧    instead include               ∨ inyx                               ∨···∨x     ⊃   ∧    −                                                                           ko        γ   ∃y∃ya  moveyy ∧                                                                                                                                    fjx  ⊃¬x   ∨···∨x  kp           ∃zxcoord ∃zycoord            atyzz ∧ connectsxxyzz∧    objects positive literals fj               ∨ inyx                   objects negative literals ¬fj iin   γ  ∃y ∃y                                                                   Σ               pickup                            closedworld example end  consisting   γ−  ∃y                ∧            drop passenger                          atxxx ⊃ objectx ∧ xcoordx ∧ ycoordx          ∀x       ∀x           ∧                taxi  passenger                  inxx   ⊃  taxix ∧ passengerx  notice stated operators mentioned taxix ≡  taxi    γ   possibly cause positive truth passengerx ≡  passenger  value construction presented objectx ≡ taxix ∨···∨passengerx                                             Σ  incorporates solution frame problem post atxxx ≡  taxi ∧ ∧ ∨  consists following sentences                   passenger ∧ ∧     ≡  γ ∧        ∧              inx      ≡  false                  object     xcoord         ∧        ∨    ∧¬γ−         ycoord                               correctness note simple consequences   ainxx ≡                                               −       construction     γ  ∧ taxix ∧ passengerx ∨ inxx ∧¬γ                                                   lemma    let ap  action operator object   ataxix ≡ taxix                                                        symbols instantiations a’s parameters  object   apassengerx ≡ passengerx                                                        parameters constants ﬂuent fjthen  precondition axiom Σpre precondition axiom                                                           Σ ∧τ  satisﬁable iff  correct types  obtained similar case distinction example                                                                  according adl problem description    π   ∃ytaxi∃ydirectiona moveyy ∨                     ∗ xj    ∗                                                           Σ  γf      iff γf op   satisﬁed origi       ∃ytaxi∃ypassengera pickupyy                      oap          ∧∃zxcoord∃zycoord atyzz               nal adl state iwhere∗∈ −           ∧    ∧¬∃z             ∨                        passenger             Σ  possap  iff πap  satisﬁed original       ∃y                            taxi    drop passenger                          adl state  correct types                                                                                                           ready show correspondence  initial description Σ ﬁnally adl’s statetransition semantics adding deleting lit  encode information initial world state erals ﬁrstorder progression es  deﬁnition  typing objects                          derived lin reiter’s original proposal progres                                                        sion simpler fact need consider              τix ≡ τi ∨···∨τi                                          ki                   arbitrary ﬁrstorder structures      fj xj xj  ⊃ τj xj  ∧···∧τj xj                  kj                  kj   kj        set sentences Σr progression Σ through                                                                      Σ       Σ            τix ≡  oj ∨···∨x   oj               ground term wrt  pre postiff                                      ki                                                                                  Σr            r             objectx ≡ τx ∨···∨τlx            sentences ﬂuent                                                            equivalent rφ ﬂuent formula φ  Σ contains sentence  each “either” statement                                                            Σ ∪ Σ  ∪ Σ   Σr  sentence form  each type       pre  post                                                                                Σ  ∪ Σ  ∪ Σ  declaration predicate arguments each primitive type  world pre   postthereis  τi        oj oj                                      aworldw  Σ ∪ Σ  ∪ Σ            ki objects declared                      pre   post                                                                                               type include sentence form   ﬁnally wrr· σ  iff · σ   clares object union types                                                                  σ ∈ r∗                         sentences establish type consistency  primitive formulas                                                            ∈fincluding  poss    following omit axioms concerning non                                                                                   changing predicates connects destination types r abbreviates rrk stands ttkthenr                                                           xcoord ycoord direction encode grid structure means  ∧···∧rk  tk                                                     ijcai                                                    intuitively observer situation matxxx≡x  taxi ∧ ∧   formed looking “forward” time impossible     ∨  passenger ∧ ∧    distinguish world satisfying original theory minx≡false  Σ                   Σ ∪ Σ   ∪ Σ    satisﬁes pre  post                  theorem   tells closed initial state    basic action theory translation application adl operator statetransition  adl problem quite easy obtain progression semantics progressing initial situation  given action ap  adl state description ipro corresponding bat openworld case prescribes          Σ  ∪Σ       ap   vided   pre poss       following result applying adl operator  ﬁnitely  fj fj  typeconsistent easy show theorem extends arbitrary sequences               xj                                   actions legal plans adl    Σ  γ      addfj                                                        fj oap                                legal plans bat                − xj        Σ  γ             fj         fj oap delete                          golog ff    open worlds additionally delete ¬fj  ﬁrst case golog programming language completely deﬁned                                                                                              add ¬fj  second case denote set situation calculus shown lakemeyer                       adds                             levesque  deﬁned directly  literals added ones deleted es  dels new state description                       core golog uses basic action theory   i  dels ∪ adds                               ﬁne meaning primitive actions initial sit                                                        uation based primitives complex actions                       i  closedworld case corresponds precisely adl formed using constructs imperative programming                                 ap    state results applying according sequence  ifthenelse whileloops procedures  statetransition semantics fox long  addition nondeterministic action choices non                                                                                     πx  theorem  let obtained described given deterministic choice arguments   offer ﬂexibility  adl problem ground action  ap  let executing program including planning                                       Σr   rψ  ψ ∈ Σi  Σi  result primitive actions  applying constructions  i instead ifor experimental results using eclipse                                           −   fj let consistency condition  ¬γf ∧ γf hold prolog implementation indigolog courtesy hector                                                    levesque sardina et al  details seman  Σr progression Σ through closedworld  case                                                 tics indigolog features online execution program    openworld case holds additional executed stepbystep progression sense  condition γ∗ ∗∈ −itis previous section initial state updated each                               fj                       execution primitive action indigolog includes                   ∗ xj                     ∗ xj            Σ∪γ                      Σ  γ       case   fj or satisﬁable   fj or   implementation reiter’s forwardsearch planner speciﬁed                                                        golog procedure called achieveg  let consider progression closedworld example                                                        given goal formula returns plan se  suppose want progress through movetaxi south                                                        quence actions  takes place  short note Σ ∪ Σ  possmthe                                   pre                  achieveg program stepwise execution resumes  reader verify assuming appropriate axiomatization                                                        starting execution   connectsthat          ax           −ax                 underlying bat translation adl problem   Σ  γ             Σ  γ          taxi         taxi             description taxi domain following program  typeconsistent instantiations used tests           γa             γ−a        respectively entailed ∃ppassenger ¬atdestp  Σ                                           γ     disjuncts   πppassenger  γ−  γa     γ−a                                            ¬                            entailed instantiation atdest   achieve atsamepos taxi  xx new state description                   pickuptaxip achieveatdestp   i  attaxi   atpassenger                drop passengertaxi         destinationpassenger                    endwhile         connects  east                   atdestp stands                                connects       north                            ∃xxcoord ∃yycoord atp ∧ destinationp  obtain progression Σm consisting            atsamepost abbreviates    ⊃       ∧                      object    xcoord                 ∃xxcoord ∃yycoord atp ∧ att                                  ∧                                           ycoord             following table summarizes varying grid sizes   ⊃     ∧                     taxi     passenger                   number passengers runtime behavior seconds     x≡x             taxi        taxi                                original indigolog versus indigolog achieve          x≡x                   passenger        passenger                      replaced adl planner ff hoffmann   mobjectx≡taxix ∨···∨passengerx                                                          legal means actions executable goal         fj o Σ ∧ τfj o satisﬁable satisﬁed ﬁnal state progressed situation                                                     ijcai                                                    
