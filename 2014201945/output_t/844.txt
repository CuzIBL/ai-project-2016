                   viewing referring expression generation search                                       bernd bohnet∗   robert dale†                     ∗institute intelligent systems university stuttgart germany                 †centre language technology macquarie university sydney australia                          bohnetiisunistuttgartde robertdalemqeduau                          abstract                             goal referring expression generation                                                            ﬁnd collection attributes values      natural language generation nlg sys     distinguish intended referent po      tems faced problem genera        tential distractors context      tion referring expressions gre given sym      bol corresponding intended referent  years wide variety algorithms      work semantic content referring ex proposed deal speciﬁc aspects problem      pression uniquely identiﬁes entity ques example earlier algorithms focussed use      tion widely explored tributes correspond simple oneplace predicates      problems nlg  years number realised example means adjectives      algorithms proposed addressing   red large later work attempts address use      different aspects problem different lational predicates realised prepositions      approaches taken make difﬁcult compare work looks incorporation      contrast algorithms provided mean boolean operators consequently      ingful way paper show viewing    considerable body research area      problem referring expression generation difﬁcult establish just different algo      search problem allows recast existing algo rithms relate each      rithms way makes similarities          paper represents ﬁrst step consol      differences clear                                idating results area aim developing                                                        framework different algorithms com                                                        pared assessed structure paper follows    introduction                                       section  provide brief overview work gen                                                        eration referring expressions date section  bor  major component task natural language generation row standard approach used artiﬁcial intelligence ai  nlg generation referring expressions given en represent problems elegant uniform way  tity want refer determine content example simon newell  russell norvig  referring expression uniquely identiﬁes intended  sketching gre algorithms expressed  referent widely explored problem nlg terms problemsolving search section  explore  literature dale  standard conception wellknown algorithms expressed  task follows                     framework section  discuss approach en                                                        ables fruitful comparison existing algorithms    assume knowledge base characterises point ways taking work      entities domain terms set attributes      values entities attributes      example knowledge base represent  brief review work date      fact entity value cup attribute type                                                        task referring expression generation dis      value red attribute colour                                                        cussed informally earlier work nlg particular    typical context want refer ei winograd  mcdonald  appelt  ﬁrst      intended referent formally explicit algorithm introduced dale       entities intended referent dis algorithm refer brevity fb      tinguished generally referred distractors algorithm frequently used basis gre al      example want distinguish particular gorithms fb algorithm searches best solution      cup items present context possible referring expressions entity      dining table                                     algorithm derives smallest set attributes referentin question producing referring expression ad problem  equate sense provides information wider context ai russell  needs efﬁcient sense does norvig  present elegant deﬁnition general al  provide information needs       gorithm problem solving search search graph           initial algorithm limited application consists nodes components state pathcost  oneplace predicates dale haddock  introduced problem represented initialstate expandmethod  constraintbased procedure generate referring ex identiﬁes new states search space queuing  pressions involving relations henceforth ir using greedy method determines order states  heuristic guide search                        considered pathcostfunction determines           response computational complexity cost reaching given state framework search  greedy algorithms reiter dale  dale strategy determined combination queuingmethod  iter  introduced psycholinguistically motivated pathcostfunction used  cremental algorithm ia used adapted al        following use framework pro  gorithm based observation people vide characterisation existing gre algorithms terms  produce referring expressions informationally problem solving search given intended referent  dundant algorithm uses preference ordering set properties true intended referent set  attributes used referring expression incorporating distractor entities wish distinguish  attributes rule potential distractor intended referent conceptualise search space           recent years number im consisting states correspond possible descriptions  portant extensions ia contextsensitive extension intended referent each state three components  cs krahmer theune  able generate refer description true intended referent set  ring expressions salient entity context distractor entities description applies  boolean expressions algorithm van deemter  intended referent set properties intended  able derive expressions containing boolean operators referent considered describing  cup does handle sets algo referent  rithm set van deemter  extends basic approach  references sets red cups approaches  initialstate form  reuse parts algorithms branch bound bab set distractors initial context  krahmer et al  algorithm uses brevity al set properties true intended referent  gorithm able generate referring expressions                                                              goal    state            form  attributes relational descriptions using graphbased                   technique                                                hλxp λxp     ﬁrst term                                                            contains set properties intended referent           identiﬁed believe virtue second term set distractors  cited strands research area course set distinguish intended referent  algorithms described litera   contains properties intended referent  ture example horacek  bateman     used description  stone  space limitations prevent complete summary  work intention extend anal  states search space intermediate  ysis presented paper algo states through algorithm adds  rithms possible                                       new properties description           algorithms focus generation  deﬁnite references principle embedded  search strategy carried expandmethod  higherlevel algorithm includes cases queuingmethod characterise  entity previously mentioned leading speciﬁc gre algorithm example fb gh ia  initial indeﬁnite reference referent used  focus leading pronominal reference  practice work tends focus exclusively deﬁ  pathcostfunction allows route search  nite reference dale  krahmer theune  required used account salience  dale  discussion general case weights embody kind heuristic search                                                          given algorithm methods functions     gre perspective problem               need implemented particular     solving                                            algorithms require pathcostfunction  algorithms choose useful  uniform framework discuss com use notion property correspond  pare algorithms unfortunately difﬁcult given tribute value considerably simplify notation  variety different approaches taken provide   gre algorithms terms problem                 deﬁnition  basic algorithm structure     solving                                              makerefexp   adopt object oriented formalism al  create initial queue single node                                                            nodequeue  ← new nodeinitialstate  lows representation dependencies algo nodequeue  ∅  rithms means inheritance overwriting             node ← removefrontnodequeue           enable fruitful comparison different goalnodegetstate  gre algorithms want distinguish aspects   return node  success  algorithms true algorithms end  unique each particular algorithm section  nodequeue ← queuenodequeueexpandnode                                                            end  ﬁrst elements shared algo return nil  failure  rithms distinct aspects each   algorithm turn      common elements                                                        algorithms ‘utility function’ method rule  following previous section deﬁnitions sout takes property relation set distrac  node state classes shown deﬁnition  ﬁg tors returns set distractors ruled  ure shows deﬁnitions initialstate goal  remain constant algorithms                                                                 machinery place rede                                                        ﬁne existing algorithms terms core differences   deﬁnition  node state classes              correspond essentially different ways expanding    class node                                         search space      state     pathcost  cost path node     getstate                                           brevity algorithm      return  returns state node                                                        distinctive property brevity fb algorithm        class state                                        computes combinations available properties      set chosen properties andor relations     increasing length ﬁnd shortest com      set distractors                            bination succeeds identifying intended referent      set available properties andor relations           behaviour captured expand method                                                       shown deﬁnition  method creates set successors    initialstate return new state∅cp            creating node each property far     goal set distractors                                                                                                checked provided rules distractor    goals                                                                         sc  ∅ return true                                fb algorithm uses breadthﬁrst search im      return false                                 plementation queue shown deﬁnition  conse                                                       quently solution goal returns true                                                        minimal number properties breadthﬁrst search                                                        considers smaller combinations properties ﬁrst           given components main method mak  erefexp represented deﬁnition  takes  fb algorithm uses expand method  arguments serve parameters distinguish createnode method shown deﬁnition   algorithm expand method create suc invoked makerefexp method shown  cessors given state queue method deﬁnes deﬁnition   insert nodes node queue depending  der nodes inserted different search strategies  incremental algorithm  realized example nodes inserted distinctive property incremental algorithm  queue search strategy depthﬁrst reduces computational complexity constructing  nodes inserted end queue search strat referring expression considering properties use se  egy breadthﬁrst nodes queue sorted quence predeﬁned ordering available properties  estimated distance goal search type implementation expand method shown deﬁni  bestﬁrst                                 tion  provides behaviour           addition require number general      set properties current state sp  purpose methods used number different ﬁrst property according given    follow code conventions typically used oo der chosen set properties current state  languages names classes start upper case char sp  node created new state method  acters names methods variables start lower case createnode note createnode method  characters                                           used fb algorithm shown deﬁnition  deﬁnition  brevity algorithm               deﬁnition  set algorithm    expandnode                                          set referents      ←  ∅                                              createnodenode       ←  nodegetstate                                  ← rulesoutp sc      foreach ∈ sp                                    ¬∃x ∈ rx ∈ out∃x ∈ cx ∈        ← ∪  createnode node                       return new nodesc − sl∪psp −      end                                                   return new nodesc sl sp −      return                                                    createnodenode       ← nodegetstate      ← rulesoutp sc                            set intended referents rules       ∅                                  entity set distractors property        return new nodesc − sl ∪           does fulﬁl condition node current                      sp −                        state returned process continued ia      return new nodesc sl sp −         property                                                              gre  involving relations                                                        algorithm gre involving relations ir introduced   deﬁnition  breadthﬁrst queueing                   dale haddock  constraintbased search    queueactnodes newnodes                          strategy used fulﬁl constraints combination       append nodes end                    greedy search chooses relation leads      return actnodes ∪ newnodes                        smallest set distractors depthﬁrst search                                                       entities intended referent entities                                                        referenced relations                                                                 strategy explained best means           unlike expand method used fb algo andortree shown figure  node rep  rithm set nodes returned contains resents state relational properties consid  node main method applies goal predicate ered additions set chosen properties each search  node returns true node containing state step consists stages ﬁrst stage choose  list properties referring expression relation pi rules largest number distractors  turned                                               second stage each entity referenced                                                        chosen relation described repeating process   deﬁnition  incremental algorithm               recursively depthﬁrst manner                                                        related entity uniquely distinguished pj     predeﬁned constant order properties         intended referent participates chosen    expandnode                                                       process continues entities uniquely      ←  ∅      ←  nodegetstate                              scribed success relations chosen fail      sp  ∅                                  ure        ← choose ﬁrst ∈ sp        ←  ∪   createnodenode                                   nbowlxcxb      end      return                                                                       choose relation                                                                           betweenxwv   onxy                                                                    entity        extension ia sets  algorithms considered far concerned                          constructing descriptions individual referents van  deemter  introduced algorithm extends     figure  expansion tree ir algorithm  ia sets extension shown terms framework  deﬁnition                                                 algorithm represented problem solv           note precisely algorithm ing paradigm deﬁnition  expand method  extension ia algorithm reuse expand method chooses relation rules largest number dis  algorithm consequently extension requires tractors calls method createnode recur  rewriting createnode method sively calls makerefexp each new referent contained  tribute pi chosen does rule entities relation deﬁnition  involving relations                      deﬁnition  contextsensitive algorithm     referent                                          referent    expandnode                                         createnodenode       ←  nodegetstate                                  ←  nodegetstate      pc ← nil                                              ← rulesoutp sc       chosen relation pc rules           ←  sc −       largest number distractors                  ←  sl      foreach ∈ sp                                     ∅ contrastiver        pc  nil                                        ←  ∪                                                                                                      rulesoutp sc  rulesoutpc sc             expresses relation                                                                                            pc ←                                             noder ← makerefexpr         end                                                     ←  ∪ noder getstatel      end                                                     end      nodec ← createnodenode pc                          end      nodec  nil return ∅                        mostsalientr      return nodec                                     ←  ∪   defart                                                               salient rules distractors    createnodenode                                      ←  ∅      ← nodegetstate                                   end      ←  sc− rulesoutp sc                            return new nodec sp −      ← sl ∪                                              extend description                   foreach ∈ rprp ∈ referentsp  rp                                    noder ← makerefexpr         noder  nil return nil  failure      viewed search problem effectively build        ← ∪ nodegetstatel      end                                               search space consisting possible descriptions      return new nodec sp −                           three signiﬁcant advantages ap                                                       proach                                                                 allows determine algorithms                                                        common particularly interesting al    contextsensitive gre                            lows begin assemble collection core function                                                        alities usable variety different approaches  krahmer theune  introduced number ex gre apparent terms general frame  tensions ia use salience weights order add work example notions states ini  deﬁnite article description salient entity tialisation deﬁnition goal state  contrastive properties order add properties impose overall algorithmic pattern shared terms  contrast entities relational extension ‘helper’ routines rulesout mostsalient  similar spirit form ir algorithm modularised essence different algorithms  described                                      reused           sets algorithm commonality     second makes possible clearly  ia algorithm surfaces reuse algo essential differences algorithms really  rithm’s expand method createnode method needs original forms differences obscured  rewritten deﬁnition  model variant absence common vocabulary expressing  framework introduce following additional methods algorithms representing algorithms common  cf krahmer theune                      framework easier algorithms dif                                                        fer differences simply differences    • contrastive takes referent property pi checks      property consideration contrastive notation presentation using framework problem                                                        solving search effectively decomposed algo    • mostsalient takes referent set properties rithms number key elements search srategy repre      set distractors checks entity sented queuingmethod expandmethod      set distractors lower salience weight encompasses aspects each algorithm basic strat                                                        egy adopted particular kinds referring expressions                                                        covered furthermore expandmethod decomposes    conclusions future work                        general strategy expansion example  foregoing shown number brevity algorithm incremental algorithm  frequently discussed algorithms generation refer createnode method varies depending kind  ring expressions represented common frame referring expression targetted  work framework believe intuitively appeal     allows clearly logical  ing process constructing referring expression space algorithms reside ways
