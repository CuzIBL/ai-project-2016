                                                        model compilation realtime planning diagnosis feedback                                           anthony barrett                                      jet propulsion laboratory                                  california institute technology                        oak grove drive ms  pasadena ca                                     anthonybarrettjplnasagov                                                                                                                      abstract                                 offline  online      paper describes mexec implemented                                                                                      target      micro executive compiles device model  compiler        evaluator    state     feedback structure subsequent      evaluation  computes               sensor     effecter       likely current device mode sets sensor              readings   commands                                                         model     measurements step reconfiguration                      hardware      plan likely result reaching                    adapters      target mode – plan exists  user tunes      increasing improve       figure  onlineoffline architecture mexec      capability cost realtime performance mode linear time  system’s architecture                                                    consists offline compiler online evaluator                                                    figure      introduction                                    addition online performance guarantee global   past decade spacecraft complexity exploded reasoning during compilation handles feedback   increasingly ambitions mission requirements  loops explicit mechanism    relatively simple flyby probes replaced compiled structure facilitates mode identification   capable remote orbiters orbiters slowly planning  evaluating way computes likely   communications relay satellites current mode given sets measurements evaluating   ambitious mobile landers like current mars exploration way computes best step reconfiguration   rover planned mars science lab suggested plan given current target modes – plan exists   aerobot titan  increased complexity paper starts defining device representation   increased probability components break language compares livingston’s    unexpected ways subtle interactions  presents simple example device shows   traditional approaches handcraft rulebased diagnosis compile internal representation linear time   recovery systems difficulty creating rule bases planning diagnosis  subsequent section shows   quickly gets hand component interactions structure evaluated planning   subtle  modelbased approaches address issue diagnosis  provide realism implementation   acceptance retarded complexity described number experiments  finally paper   underlying evaluation systems compared ends discussion future work conclusions   simple rule evaluator performance guaranteed   linear number rules darwiche   representing devices     paper combines ideas livingston williams mexec’s device modeling language simplified   nayak  results knowledge compilation equally expressive variant livingstones mpl   diagnosis darwiche  planning barrett model device connected set components    create mexec micro executive each component operates number modes    modelbased onboard evaluation essentially each mode defines relationships   simplicity comparable rule evaluator  component’s inputs outputs  precisely   involves taking device model compiling use constructs define types connections abstract   structure facilitates determining system’s relations components modes relations   current mode reconfigure desired target inputs outputs modules define multiple component  subsystems toplevel diagnosed   model compilation    following conventions facilitate defining syntax                                                     provide example modeled device consider     • word italic denotes parameter like value following single siderostat     • ellipsis denotes repetition like value…      tracking star interferometer      • square brackets denote optional contents like value kept simple possible order facilitate use     • vertical bar denotes choice options like running example rest paper  starts       false  true                                 defining values defines component using                                                     values finally defines terms      conventions entire language’s syntax component  semantic restriction mentioned   defined figure  constructs respectively syntax definition used   define connection types wellformed formulas appeared  keeps modelers crafting infinite   arguments user defined relations components modules recursive definitions    just like livingstone name’s    structure connected set components modules  defvalues boolean false true    inputoutput ports unlike livingston inputs  defvalues command idle track    outputs form feedback loops statically  defcomponent siderostat                                                          ports  command inboolean valid    defined connections sensed connections sensors     modes tracking model  valid true    commanded connections affectors  wffs               cost    components refer variables local component             idling model  valid false   ports wffs constraint entries refer variables               cost                                                                  unknown cost    defined structure elements locally defined     transitions     variables                                           tracking  idling  idle      divergence livingstone involves      idling  tracking  track    modeling components  syntax similar        unknown true cost     semantics revolves concept cost  essentially  defsystem tst                                                         sensors boolean    mode’s cost denotes unlikely irrespective     affectors command    information transition’s cost denotes unlikely     structure siderostat sw    preconditions hold  getting costs    livingston’s probabilities simple matter taking  model cnf    probability’s negative log formalism makes users compiling device model starts taking    directly specify costs reflect number specified definition recursively expanding modules using    manually guessed just like probability       defmodules components remain optional                                                     conjunctive constraint  example lacked     defvalues ctype   value…                    defmodules step results single component called     wff → false  true  wff  wff…   wff…    “sw” siderostat following list                cname value   cname cname  rname arg…    command effecter boolean observation sensor       →    arg  wff  cname  value                         siderostat sw     defrelation rname  parameter…  wff                                                       example implies substitution occurs     defcomponent stype                             during expansion  inputs outputs replaced         ports  ctype cname…                    actual parameter names – valid respectively         modes     mname cost int model wff…  visible example         transitions    mname    mname wff cost int … components unique names prefixing each structure     defmodule stype                                element current module  instance         ports           ctype cname…           tst module sw tstsw         connections  ctype cname…              connection names similarly prefixed          structure  stype sname  cname… …     naming convention facilitates allowing module constraints        constraint  wff                          refer connections modes substructure                                                       determining components mode definitions     defsystem                                 converted boolean expression  involves         sensors    ctype cname…                                                      building equation following form sname        affectors    ctype cname…             component’s each disjunctive entry        connections  ctype cname…             different mode mname model wff  form         structure  stype sname  cname… …     notice subscripts vary         constraint wff                                                        snamemode mname                                                                 wff …           figure  syntax device modeling language                example example resulting disjunctive normal form dnnf largest   equation following                  dnnf equivalent exponentially larger cnf                                                      fortunately smaller dnnf equivalents      swmode tracking                  true                           approach mirrors boolean approach              swmode idling           finding ddnnf darwiche  recursively                 false                        partitioning cnf disjuncts traversing      higher disjuncts replicated each step partition tree generate dnnf    transition disjuncts added  transition disjuncts purpose partitioning disjuncts    following form sname   group refer variables    component denotes xth component transition refer different variables different partitions                                                      each disjunct refers multiple variables   frmxtox respectively denote transition’s   sourcedestination wff  denotes precondition case disjuncts sibling partitions                         xi                         refer variable minimizing cross   step  frmx “” frmx constraint dropped   denote transition enabled  partition variables dramatically reduces size                                                     dnnf equation  partitioning essentially converts      snametrans                                                    flat conjunct disjuncts equation tree internal           snamemodei frmx                  snamemode  wff             nodes disjuncts literals leaves                                xi            number propositions appearing multiple branches      finally userdefined disjuncts supplemented node minimized   systemdefined disjuncts transitioning  mirroring boolean compiler partitioning   look respectively follows noop mapping cnf equation hypergraph nodes   equation’s size depends number transitions hyperarcs respectively correspond disjuncts   order avoid choosing transition transition variables  nodes each hyperarc connects   enabled                                       determined disjuncts hyperarc’s        snametransi noop               corresponding variable appears  given hypergraph           snamemodei snamemodei       recursive partitioning using probabilistic mincut                 snamemode  frm                                                  algorithm wagner klimmek  computes                    wff  …                              xi                     relatively good partition tree disjuncts     finally constructs compiler turns set generalizing algorithm weighting hyperarcs   components single boolean equation conjoins associated variable cardinalities does better    equation conjunction constraint wffs figure  extremely simple example   subsequently flatten equation cnf form disjuncts three variables cardinalities                                                       equation tree perspective node      cnf dnnf                                 disjuncts leaves  branches    unfortunately finding minimal satisfying assignment node share variable recorded    cnf equation npcomplete problem node’s sep set      compilation needed achieve linear time evaluation      fortunately results knowledge compilation research af bt bf ct    darwiche marquis  show convert    cnf representation decomposable negation normal             partition    form dnnf  turns form logical                          expression evaluated linear time compute                 likely diagnosis optimal level plan     sep       dnnf defined previously terms    boolean expression make slight extension    af bt      bf ct   variable logic equations negation variable    assignment replaced disjunct figure   example partitioning cnf equation    possible assignments variable  extends    dnnf formalism constraint satisfaction problems equation tree computed computing                                                     dnnf involves extracting each node’s associated    definition  variable logic equation    shared variables using equality    decomposable negation normal form  contains                                                                   ∨       ∧           negations  subexpressions each conjunct eqn          eqn                                                                 c∈domainv   refer disjoint sets variables                                                     eqnvc equation generated replacing      just boolean case multiple possible disjuncts containing vc true removing    variable logic dnnf expressions equivalent cnf assignments disjuncts  disjunct    objective small possible  ends assignments false     formally dnnf equation recursively  mode estimation   defined equation tree using formulas evaluating dnnf structure determine component   second apply internal leaf nodes modes starts assigning costs namemode                                          α                                                        respectively  formula’s instancesnsep  refers variables costs come cost entry   set possible assignments vector variables associated  each mode original model   nsep consistent α  instance running missing cost entries assumed zero  instance   formulas figure ’s tree starts calling transitions associated costs model   dnnfroottrue instances bt bf                                                     resulting assigning zero nametrans leave   rootsep assignments agree costs  finally sensed values assigned zero   true  general number consistent instances grows infinity depending value sensed  case   exponentially nsep leading use mincut                                                     sensed values true   reduce size nsep each partition                                                         swmode  tracking    dnnf nα ≡   ∨      β ∧  ∧  dnnf cα ∧ β         true                                 β∈       α    ∈                             instances  sep  kids          swmode   tracking                                                                                                                                             swtrans   noop                               α                                                              ⎧   true     ⇒ disj                   true                 ⎪                                          track                dnnf disj α  ≡ ⎨ ∨  β     ∃β ⊃ α ⇒ ¬β        inf                              β ∈disj α ⇒ ¬β                                          ⎪                                                                             ⎩   false                               swmode  idling inf                                                       inf   track                         walking equation tree does provide dnnf                                                                           inf   false   equation evaluated linear time                                                          swtrans     important optimizations involve merging common sub   swmode  idling   expressions decrease size computed structure inf  false        inf  caching computations visiting node  swmode  idling inf                                                           swtrans   noop   improving compiler performance darwiche                           figure  common subexpressions merge inf  false                                                                                    inf  resulting dnnf expression appears    inf  idle                                                                             bt ct bf af                   swmode  tracking inf                                                            idle                                                        inf                        onboard evaluation                                 true                                                         swtrans      illustrate trivial dnnf expression consider    figure  siderostat dnnf  actually slight figure  evaluating  level dnnf structure determine    simplification generated dnnf siderostat mode sets observations    generated siderostat model lacked unknown following simple propagation step associated    mode – omission motivated space node costs appear nodes figure   note    limitations  expression’s rightmost node cost level node   value used   three children each child refers unique set prune search descending tree   variables  disjoint sets                                                     determine assignment swmode   respectively                                  likely siderostat mode matches observations       swmode swmode swtrans approach assumes forgetting old state                                                     information enhanced remember      given dnnf nodes disjoint branches likely state set likely states using    property finding optimal satisfying variable assignments particle filter approach  difference    simple threestep process             approaches revolves leaf cost assignments     associate costs variable assignments leaves requisite changes manageable     propagate node costs through tree      assigning min sum descendents’ costs  reconfiguration planning      node respectively            evaluating dnnf structure reconfiguration     root’s cost  infinity value plan cost assigned each variable using number      respectively return default assignments failure planning dependent preferences  performing      descend root determine return action zero cost  results associating zero      variable assignments contribute cost leaves set transitions noops  second leaves      actually algorithm little general denoting transitions assigned costs come    step  computes number mincost assignments cost entries associated transitions     step  extract linear time example costs assumed zero  finally  namemode namemoden entries assigned costs    depend respectively current target mode     leaf assignments consistent modes    cost zero inconsistent leaves infinite cost     instance figure  documents evaluation    currently tracking siderostat make idle  case    cost propagated used guide                                                             collector combiner   descent desired cost effecter variable                    fast steering                                                                                      mirror                                                                      siderostat     star tracker      inf swmode  tracking         true                  inf        swmode   tracking                                                wide                                                      angle         swtrans  noop                                                               wide                                                 pointing                               angle          true                                                                     pointing                                                              intensity          track                                      gradient laser                                                           detector                   delay line                                                                          laser counter fringe tracker      inf swmode  idling inf           track                                                                    figure  simplified schematic formation interferometer          false                              testbed fit left side dotted line represents         swtrans                             collector spacecraft right side dotted line represents         swmode  idling                       combiner spacecraft          false                      inf swmode   idling                      formation interferometer test bed fit                             inf              swtrans   noop                        model extension stb model                                      false                              stb represents single spacecraft interferometer fit           idle                                                             represents separated spacecraft interferometer                                      illustrated figure  fit composed combiner right         swmode  tracking                    collector left spacecraft collector spacecraft          idle            true                           precisely points star reflects starlight beam                                                    combiner spacecraft  combiner spacecraft         swtrans                                                       points star collect starlight   figure  evaluating  level dnnf structure compute accurately points collector spacecraft order   reconfiguration plan                             combine starlight collector spacecraft      need example simple motivating    tagging transitions costs tags reflect                                                      device                    likelihood transition preconditions met                                                                                       transitions consistent preconditions                                                      stb                   underlying evaluation actually adjust                                                       fit                  preconditions maximize likelihood triggered   transitions result attaining target conditions  table  dnnf sizes nodes interferometers   implies planning algorithm finds step components variables sensors levels   solutions probabilistic planning problems like compiling models instantaneous     buridan kushmerick et al   vantage through three step   dnnf structures results   point mexec’s compiled internal structure viewed generation table   initial message pull   limited policy solving pomdp problems exercise instantaneous dnnf structures   solution steps perspective diagnosis tend extremely compact   fully explored                         increases does dnnf size  increasing                                                     makes able reason longer durations      implementation experiments                diagnosing planning increased    currently implemented allegro common capability comes cost longer evaluation times    lisp  lines compute device’s cnf dnnf equation evaluation linear equation size      equation  lines compute cnf equation’s work planning barrett  strict dnnf    associated dnnf  lines evaluate compilation darwiche  leads suspect    dnnf equation minimal cost satisfactions scaling issue improved  case empirical      addition testing mexec various switching experiments scaling issue improved    circuit examples work developing order magnitude  results reported chung    experimenting models space interferometer barrett   node dnnf structure    mission test bed  stb model ingham et al  fit model   
