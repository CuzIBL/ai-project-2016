                improved algorithm optimal bin packing                                                richard korf                                        science department                                    university california los angeles                                            los angeles ca                                                korfcsuclaedu                         abstract                           turn fullest bin fits firstfit decreas•                                                         ing requires three bins pack set numbers       given set numbers set bins                                                          bestfit decreasing packs bins       fixed capacity npcomplete problem bin                                                          algorithms run onlogn time       packing minimum number bins                                                            paper concerned finding optimal       needed contain numbers                                                          solutions reasons applications small       sum numbers assigned each bin does                                                          numbers bins extra bin relatively expen•      exceed bin capacity present                                                          sive addition able optimal solutions       improvements previous bincompletion                                                          problem instances allows accurately gauge       algorithm speeds constant fac•                                                         quality approximation algorithms furthermore       tor node generation second prunes                                                          anytime algorithm finding optimal solutions       redundant parts search tree re•                                                         presented paper make use ad•      sulting algorithm appears asymptotically                                                          ditional time available better solutions       faster original algorithm prob•                                                         returned polynomial algorithms finally optimal bin       lems  elements runs  times                                                          packing computationally challenging lead       faster furthermore ratios node gen•                                                         insights applicable problems       erations running times increase                                                            review previous algorithms optimal bin       increasing problem size                                                          packing including bincompletion algorithm korf                                                           improvements bin com•   introduction overview                            pletion algorithm generating  given set numbers fixed bin capacity  dominated bin completions efficiently reducing   binpacking problem assign each number bin  constant time node generation   sum numbers assigned each bin    method reduce branching factor search   does exceed bin capacity optimal solution  eliminating branch points dominated previ•  uses fewest number bins example given ous branches experiments millions problem in•  set numbers       bin capacity stances uniformly distributed random numbers    assign    bin  new algorithm appears asymptotically faster     total bins original bincompletion algorithm based   optimal solution instance sum observation ratio nodes generated   numbers  greater  algorithms running times grow   bins required example application given increasing problem size problems size    set orders wire varying lengths standard new algorithm runs  times faster original   length manufactured cut  bincompletion algorithm report mixed results   minimum number standard lengths orders common set benchmark problems     bin packing earliest problems shown   npcompletegarey  johnson  vast      previous work   majority literature problem concerns   polynomialtime approximation algorithms  martello toth   fit decreasing ffd bestfit decreasing bfd wellknown algorithm optimal bin packing   quality solutions compute firstfit de• martello  toth based depthfirst   creasing sorts numbers decreasing order orders branchandbound numbers sorted   bins assigns each number turn considered largest smallest computes   bin fits bestfit decreasing sorts num• approximate solution initial upper bound using   bers decreasing order assigns each number best solution firstfit bestfit worstfit                                                                                                     search decreasing each number algorithm places        bin resulting   each partiallyfilled bin fits    smaller problem gent  unfortunately   bin algorithm branches differ•         does extend three elements sum   ent bins number placed uses        exactly bin capacity   lowerbound function prune search                        example consider element                                                                  remaining elements added exceed    recent approaches                                  words additional element   anonymous reviewer pointed recent             added bin containing let largest   references optimal bin packing operations          remaining element   research literature based integer programming for•         place bin sacrificing solution   mulations linearprogramming relaxations vale         quality reason placed single   rio carvajho  scholl klein  jurgens          element swap   vanderbeck  degraeve  schrage  vance et    vance  fully di•          final example assume largest   gested work report comparison re•          remaining element added    sults standard set benchmarks                         equals exceeds sum set                                                                  remaining elements added    bin completion                                                                  exceeding case   korf  described bin completion algo•         bin sacrificing solution quality   rithm uses branching structure different         reason set elements placed   martello toth feasible set set          bin swapped   numbers sum does exceed bin capacity            increasing number bins   initially sort numbers decreasing order size      illustrate general form dominance rela•  generate feasible sets include largest        tion let feasible sets elements   number set search         partitioned subsets subsets   branch point each node search tree        matched elements sum   root node represents complete assignment         elements each subset doesnt exceed cor•  numbers particular bin children root       responding element set dominates set   represent different ways completing bin contain•        words elements packed   ing largest number nodes level            bins capacities elements set   represent different feasible sets include largest   remaining number depth branch   tree number bins corresponding solution      bin completion branchandbound algorithm   starts bestfit decreasing solution upper      given feasible sets contain common el•  bound applies lowerbound heuristic function         ement undominated sets need considered   prune search assigning numbers            assignment bin containing reason   time bins branches different feasible       complete bin containing domi•  sets used complete each bin bin com•           nated set swap each subset numbers   pletion appears asymptotically faster martello        dominated set corresponding element   toth algorithm outperforms factor          dominating set solution   thousand problems size  key property            increasing total number bins   makes efficient dominance condition         martello toth use dominance relation   feasible completions bin allows       extent particular each element starting   consider small subset                               largest element check single                                                                  completion elements dominates    set dominance                                              feasible sets containing place   sets elements assigned bin lead         elements bin apply reduction   solutions better achievable         remaining subproblem use dominance   assigning sets elements bin           relations prune element placements   begin simple examples dominance               bincompletion algorithm makes   relations consider general formulation          greater use dominance condition particular      consider elements sum           branching completion bin   exactly bin capacity assume solution       considers undominated completions   different bins case swap   elements bin containing        finding undominated completions   increasing number bins gives equally   good solution bin given        contribution paper faster algorithm   problem values                generate undominated completions bin       search                                                                                                                 previous algorithm                                        subsets right branch excludes    simplest algorithm generate feasible sets       element subsets tree traversed    include particular element test each         depthfirst using linear memory    pair sets dominance original implementation         generate feasible completions bin containing    improved generating subset feasi•    number add upper bound sum each    ble completions testing pairwise dominance      recursive initially residual capacity    particular additional num•       bin capacity minus sort remaining unas   ber added bin largest number       signed numbers decreasing order size    added additional numbers added      include numbers equal up•   bin set twoelement undominated completions         bound include number taking    linear time follows                      left branch node subtract upper      each undominated twoelement completion           bound recursive calls branch    sum greater largest feasible single number        upper bound drops zero prune tree    equal remaining capacity       node numbers added    bin remaining values kept sorted order      generates feasible completions bin containing   pointers initially assigned largest value        generating undominated feasible completions requires   smallest value sum       little work exclude number ex•   numbers exceeds remaining capacity pointer       ceeds upper bound taking right branch   larger number moved smaller num•         corresponding node additional required   ber sum numbers equal       member feasible set   largest single feasible number pointer      node exclude number equals upper   smaller number moved larger number          bound terminate branch binary tree   sum numbers range           immediately feasible subset included el•  pointer smaller number increased largest      ements node sum   number sum range         excluded element subset smaller sum   values form undominated twoelement           dominated excluded element   completion pointer larger number             happens exclude number   moved smaller number pointer           upper bound prevent excluded clement   smaller number moved larger number         dominating included subset sum   process continues pointers meet            numbers subset exceed ex•     sum numbers feasible sets un•      cluded element generates lower bound   equal larger sum dominate       sum elements included subset   sets sum        node equal excluded element plus   smaller cardinality dominate           assuming numbers integers   subset feasible completions each pair       upper bound lower bound reduced sub•  tested dominates          sequently included elements recursive calls   trying pack numbers poten•           corresponding nodes lower bound generated   tial dominated set bins capacities         excluded element used exceeds current   numbers potential dominating set small           lower bound node   binpacking problems solved bruteforce search          perform depthfirst traversal binary      drawbacks approach      tree representing possible subsets numbers remain•  time generate test dominated feasible      ing assigned traversal pruned upper   sets second memory needed store             lower bounds propagated tree described   dominated feasible sets pruned                generates complete subsets leaf nodes                                                                  include undominated feasible sets    generating undominated sets faster                         include dominated feasible sets   ideally like generate undomi•          eliminate perform additional test   nated bin completions pairwise testing feasi•      feasible bin completions generated residual ca•  ble sets dominance algorithm          pacity bin bin capacity minus largest   three stages  generate subsets uni•      number bin common feasible com•  verse  generate feasible subsets         pletions given bin let sum num•  generate undominated feasible subsets             bers feasible set excluding common largest        easiest way generate subsets el•         number excluded numbers remaining num•  ements recursively traverse binary tree         bers equal included   each node represents collection subsets root         set dominated contains   node represents entire power set leaf nodes       subset sum equal excluded   represent individual subsets each interior level       number replacing subset   tree corresponds different element each node         exceed bin capacity case   left branch includes corresponding element      guarantee feasible set                                                                                                                   search undominated check each possible subset sum         solution redundant doesnt need con•  each excluded number verify                     sidered particular branch      algorithm generates feasible sets immediately      search tree solution assigns   tests dominance stores multiple          bin redundant pruned   dominated sets tests dominance comparing              general given node child   subset sums included elements excluded elements         searching subtree child   comparing pairs sets dominance             dont need consider bin assignments assign      pseudocode algorithm given          bin numbers used complete   feasible function takes set included elements set    current bin previouslyexplored child node   excluded elements set remaining elements         precisely let set brother nodes   lower bound  upper bound generates         search tree let sets   feasible sets remaining elements sum        numbers used complete bin each node ex•  bounds calls test function each        cluding number assigned bin   initial contains remain•    common brother nodes searching     ing elements equal residual capacity     subtree node nt  exclude bin   bin set set largest single  assignments numbers sj   element feasibly added bin plus       bin  bin completion node ni   test test described function     subset numbers re•  included elements excluded elements          jecting bin assignments redundant number   residual capacity                                           node generations reduced                                                                   current implementation                                                                  current implementation pruning rule propa•                                                                 gates list nogood sets tree generating                                                                  undominated completions given bin check                                                                  each contains current nogood sets                                                                  subset does ignore bin completion                                                                    list nogood sets getting long                                                                  occupying memory store time test                                                                  bin completions prune list follows                                                                  nonempty intersection      improve algorithm use optimiza•        bin completion nogood set nogood set   tions used original algorithm generate feasible      subset bin completion remove  sets number added          good set list passed children   bin add largest number        bin completion reason including   numbers added generate un•             numbers nogood set   dominated twoelement completions linear time         bin completion weve split nogood set guar•  algorithm speeds generation undominated          anteeing subset bin completion   sets affecting number bin completions          node search tree   considered turn contribution          implementation probably improved                                                                  sophisticated data structures representing arid    pruning search space                                     manipulating sets elements   consider number bin capacity as•  sume undominated feasible completions           experimental results                                                                  tested algorithm large sets problems                                                                  uniformlydistributed highprecision numbers                                                                  set benchmark problems relatively low precision   search explores bin completions decreasing order         uniform high precision numbers   subset sum case consider            furthermore assume exhausting         compared original algorithm new bin  subproblem assignment                      completion algorithm problem instances   exploring subproblem assignment                  machine highprecision numbers   solution assigns bin       difficult pack lowprecision num•  say bers used bin capacity million random               swap resulting         numbers uniformly distributed million   solution number bins including         given enormous variation difficulty indi•  bin assignments                           vidual problem instances ran million instances   possible solutions node representing bin         each problem size ranged   numbers   assignment explored                   increments  table  shows results       search                                                                                                                   optimal     original       pruning         nogood pruning            ratios            bins        time         nodes        time         nodes         time       nodes     time                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        table  experimental results uniformly distributed highprecision numbers        column gives problem size       ber node generations corresponding column   number values packed second column               pruning shows effect nogood pruning   shows average number bins needed optimal           columns performance ratios   solution numbers range uniformly zero          best program including nogood pruning node ra•  bin capacity expected value number       tio number nodes generated nogood   half bin capacity expected value sum       pruning divided generated nogood prun•  numbers half bin capacity times          ing time ratio running time original   number values expected average minimum             program divided current best program   number bins slightly half number          problem size increases nogood pruning generates   values inevitable wasted space bins        increasingly fewer nodes pruning      column gives average running time          largest problems ran algorithms ratio   original bincompletion algorithm korf          node generations factor  fact   microseconds total time seconds        node generation ratio increases increasing   solve million problem instances implementa•       problem size suggests nogood pruning reduces   tions  megahertz sun ultra  workstation         asymptotic time complexity bin completion                                                                    ratios running times displays similar      columns labelled pruning                                                                  trend values ratios   average node generations running times                                                                  node generations increased overhead   microseconds implementation bin completion                                                                  nogood pruning larger problems new al•  new method generating undominated feasi•                                                                 gorithm order magnitude faster   ble sets pruning nogood sets                                                                  original algorithm problems size  average   program considers number candidate solu•                                                                  seconds problem solve optimally   tions original node generations differ   reported earlier paper korf           variation individual problem difficulty   reason define node recursive     tremendous variation difficulty individ•  search routine current implementation checks          ual problems example  percent   terminating conditions making recursive         million problems  numbers bestfit decreas•  beginning search function       ing solution uses number bins lower   new program outperforms original factor        bound solving problem search    running time didnt run problems       problems instances generated   size   time required       billion nodes three generated      columns labelled nogood prun•           billion nodes generated   ing  average number nodes generated          billion nodes program solved   average running time microseconds algo•         problems size  day   rithm including nogood pruning comparing num•            failed solve problem  days                                                                                                                   search 
