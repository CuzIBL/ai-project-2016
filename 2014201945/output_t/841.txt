                               planning petri net unfolding                     sarah hickmott jussi rintanen sylvie thiebaux´    langwhite                                           national ict australia               school electrical  electronic engineering university adelaide                     sciences laboratory australian national university                        abstract                          net acyclic avoids certain conﬂicts petri net                                                        analysis problem prove absence      factored state representation concurrency deadlocks unfolding amounts breadthﬁrst search      semantics petri nets closely related stops generated occurrence net represents mark      concurrent planning domains planning  ings reachable original net size unfolded      petri net analysis developed independently  net bounded typically exponentially larger      minimal usually unconvincing attempts size original petri net bounded      crossfertilisation paper investigate typically exponentially smaller size      exploit relationship areas fo state space represents searching unfolding space      cusing petri net unfolding attractive offers potential gains state space search      reachability analysis method naturally enables                                                          section  provide necessary background petri      recognition separate resolution indepen nets unfolding pointing differences ap      dent subproblems hand based                                                        proximate reachability analysis performed planning      folding develop new forward search method                                                        graph blum furst  section  trans      costoptimal partialorder planning lation planning problems safe place transition nets      exponentially efﬁcient state space                                                        low level nets offtheshelf unfolding tools apply      search hand inspired wellknown                                                          section  new planning method      planning heuristics investigate automatic                                                        costly option ﬁrst build complete      generation heuristics guide unfolding result                                                        folded net extract partially ordered plans      ing efﬁcient directed reachability analy                                                        time linear size capitalise      sis tool petri nets                                                        approach planning instead embed heuristic search                                                        unfolding resulting directed modelchecker    introduction                                       edelkamp et al  petri nets show mono                                                                                       petri nets traditionally used modelling analysing tonic planning heuristics haslum geffner  distributed systems murata  provide compact  directly computed original petri net  description state space way plan guide unfolding minimal cost plans  ning operators additionally represent independence loss completeness  concurrency causal relations actions way finally section  present analyse experimen  enables recognition separate resolution inde tal results obtained benchmark problems inter  pendent subproblems confers ability rea national planning competition standard petri net  son partially ordered sets actions having benchmark proofs omitted grounds space  consider interleavings exploited early available technical report hickmott et al   godefroid kabanza  synthesize reactive plans    fair say work failed  petri nets unfolding  sufﬁciently develop utilize connections  areas recent exception edelkamp jabbar’s  placetransition net   work applying planning heuristic search consider low level petri nets called placetransition pt  tecting deadlocks petri nets primary goal work nets ptnet lefthand side figure  consists  contrast determine techniques developed net initial marking net directed bipar  petri net analysis successfully applied planning tite graph types nodes places transitions    focus petri net unfolding mcmillan  esparza represent state variables events  et al anexact reachability analysis technique derlying arcs capture dynamics  particularly attractive preserves exploits directed places transitions vice versa  structure inherent petri net unfolding process marking ptnet represents state  generates forward simpler type net called occurrence models assigns each place  tokens                                                     ijcai                                                    deﬁnition  ptnet tuple path through net events causal history  disjoint ﬁnite sets places transitions conﬂict  spectively ×  ∪ ×  →  ﬂow  lation indicating presence  absence  arcs  conﬁgurations   → initial marking                   understand unfolding built important               •                                        notions conﬁguration local conﬁguration    preset   node  net set   event conﬁguration represents possible partial run   ∈   ∪       thepostset    • node       yx                                    ofthenetitisanysetofeventsc  set ∈ ∪ simplicity assume  transition nonempty preset postset partic  causally closed event                                    ∀  ∈         ≤        ﬁguration ancestors occurrence  ular marking enables transition pfp                               mp occurrence ﬁring transition absorbs net ∀e ≤ ∈ ⇒ ∈  ken each preset places produces token  contains forward conﬂict — motivated  each postset places moving net fact events forward conﬂict                      −            ∀ ∈           occur order simultaneously run  new marking                                                   •    •  corresponds state transition modelled net ∀ ee ∈   ⇒ ∩  ∅  set transitions  concurrently enabled marking                                                                                               instance ﬁnite preﬁx figure    is possible ∈ occur simultaneously viz conﬁguration conﬁguration associated  ∀  ∈               ≤            t∈t    instance net marking markc original net identifying  figure  transitions   concurrently enabled conditions contain token events ﬁred                                                                                                    •  •  given marking transitions   conversely transi initial marking markcϕb ∪   tions   forward conﬂict means whilst c•  e•e ∈ •c  •ee ∈ cthatis  each individually enabled ﬁre firing marking conﬁguration identiﬁes resultant state  transitions   order concurrently followed original petri net events oc  transition  results token each places gwesay cur instance figure  marking conﬁguration  ptnet nsafe number tokens each place ϕc cg  exceed paper consider safe nets local conﬁguration event denoted consists                                                        event ancestors minimal conﬁg    unfolding placetransition net               uration containing example ee ea  unfolding method reachability analysis ex set conditions simultaneously marked union  ploits preserves concurrency information planning local conﬁgurations presets forms conﬁguration  terms unfolding approach allows searching partially unfolding process involves identifying transitions  ordered plans considering unnecessary interactions enabled conditions currently occurrence  actions unfolding ptnet produces oc net simultaneously marked identiﬁed tran  currence net nodes called conditions events sitions referred possible events new instance  represent particular occurrences places tran each added occurrence net instances  sitions respectively possible runs original net places each postsets  initial marking unfolding achieves eliminat  finite complete preﬁx unfolded net  ing cycles backward conﬂicts transitions output                                                        cases unfolding β petrinet inﬁnite  place backward conﬂict eliminating                                   know exactly transitions ﬁred obtain par reason seek complete ﬁnite preﬁx β β                                                        contains information β formally pre  ticular marking planning terms elimination   ward conﬂicts achieves property postuniqueness ﬁx β β complete reachable marking                                                                                 ∈    action set backstrom nebel  implies exists conﬁguration β  know exact set actions causes state variable  markcmand  certain value point plan       transition enabled exists    unfolding ptnet β        ﬁguration ∪e e∈ ϕet                             ϕ whereon      bef    occurrence net  key obtaining complete ﬁnite preﬁx identify  ϕ homomorphism mapping events cease unfolding loss  ditions events places transitions respec information events referred cutoff events  tively occurrence net starts conditions representing deﬁned terms adequate order conﬁgurations  places initially marked ptnet ϕ maps mcmillan  esparza et al  following  set conditions preset oneone ⊕e                              ≥                          denotes conﬁguration extends ﬁnite  set places                   set events disjoint    righthand side figure  shows preﬁx                    ≺  folding ptnet example lefthand side notice deﬁnition  partial order ﬁnite conﬁgurations ad  multiple instances place example different equate  paths through reached note tran  ≺ founded  sition  does appear unfolding exists  ⊂ ⇒ ≺                                                     ijcai                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                figure  example ptnet left finite preﬁx unfolding right placescircles transitionssquares tokensdots        ≺ preserved ﬁnite extensions ≺ algorithm  mole unfolding algorithm                            mark     mark   ﬁnite extensions add conditions preﬁx        ⊕e         ⊕e                           isomorphic initialise priority queue events possible                ⊕e   ≺    ⊕e                                        queue  loss information terms threat remove ﬁrst event queue  completeness cease unfolding event eife cutoff  takes net marking caused   add event postset preﬁx  event e e ≺ events identify new possible events  markings proceed proceed     insert queue  e relevant proofs esparza et al  endif                                                        endwhile  deﬁnition  let ≺ adequate partial order event                                                        add postsets cutoff events preﬁx  cutoff event respect ≺ preﬁx contains  event e marke  marke e ≺    mole  freeware program unfolds safe pt  nets uses adequate order ≺ conﬁgurations bound concurrency esparza et al   based comparing cardinality reﬁned com presence concurrency typically leads preﬁxes expo  parisons based parikhvectors foata normal form nentially smaller unfolding builds space  make order strict minimise size gen partially ordered sets events avoids combinato  erated preﬁx esparza et al  preﬁx right rial interleavings events handled concurrently  hand side figure  complete ﬁnite preﬁx mole  generates example events eande  unfolding vs planning graph  cutoff events each local conﬁg  urations ﬁrstly marking local conﬁgura reader ﬁnd useful view unfolding  tion event eief secondly greater powerful planning graph blum furst   local conﬁguration event respect adequate ditions events play role graph’s proposition  partial order implemented mole notice ﬁnite action nodes respectively number impor  preﬁx unfolding ceases cutoff events tant differences firstly whilst planning graph  resulting conditions enable actions performs approximate reachability analysis unfolding                                                        computes reachability exactly byproduct petri net    unfolding algorithm                              semantics mutexes just binary ones prop  mole  builds complete ﬁnite preﬁx following algo agated accounted determining sets possible  rithm  algorithm maintains priority queue possible events secondly unfolding duplicates nodes needed  events increasing order ≺ wrt local conﬁguration guarantee postuniqueness conditions proposi  expensive algorithm computation tion nodes unique event action node predecessor  possible events exponential maximal size consequence differences plans ex  presets transitions esparza et al  tracted unfolding time linear length  details size preﬁx obtained decreases plan extraction planning graph requires search fi  strength ordering concurrency nally global notion level unfolding  original net ordering strict size stead asynchronous vision time confers  unfolding bounded reachable state independent subproblems local levels conse  space net small factor equals quently unfolding lends easily gener                                                        ation partiallyordered plans optimal cost         httpwwwfmiunistuttgartdeszstoolsmole    graph better suited producing stepoptimal parallel plans                                                     ijcai                                                      translating planning   problems ptnets                                  use unfolding tool mole planning need                                                                                      turn planning problems safe placetransition nets                    tools accept input fact safety  helps representing propositional planning operators  reading truth value boolean variable presence                                                                                       absence token allowing multiple tokens place               a        meaningless best require nontrivial  bookkeeping multiple tokens place resulting figure  ptnet translation operator   repeatedly making variable true need a ¬b ¬a d transformation safe op                                                                                                moved make variable false                    erators positive preconditions   a ¬a a    translation operates three steps ﬁrst step                                                                         a ¬a a ¬d d  safety established replacing planning operator  safe ones concept safe operator deﬁned  second step eliminate negative precon  ditions lacking ptnets step second step translation negative preconditions                                                        ¬  resulting problem ﬁnally mapped ptnet prove eliminated usual way gazen knoblock  translation correct characterise extent  replacing corresponding positive precon                                                                                            notion concurrency ptnet obtain ditions forcing state variable value                                                                                               matches independencebased notion concurrency com opposite value operator                                                                                     monly used planning                               placed p e a∪a p∩a∪a¬a ∈                                                        e  ∪¬aa ∈ ∩ a∪a¬a ∈    establishing safety                              instance operator  a ¬b ¬e ¬a b                                                                                                      let set state variables set literals replaced  a de ¬a a ¬b    ∪¬aa  ∈  athecomplement   lit       ∈                   ¬      ¬           ∈  eral  deﬁned             correctness  sets literals deﬁne  ll ∈ eastate                                                                        →   assigns values   state vari deﬁne set operators obtained  ables planning operator pair p e performing steps effect literal                                                           ¬                    ¬                     ∪ ⊆ planning operator p e positive precon iff effect literal effect literal iff                                                                                                ditions ⊆ aitissafe ⊆ effect effect literal executing operator preserves                                                                                      ∈          literals appear negatively preconditions planning property state   problem quadruple a g set state instead executing operator execute  variables  →  initial state set exactly operators effects  planning operators set goal literals  operator depends current state prop    map planning problem equivalent erty state variable mentioned effects actually  property operator positive preconditions changes operator executed def  safe start establishing safety opera inition safety requires  tor  p e ﬁrst replaced ep safe operators following theorem establishes correctness               ⊆                                      translation proof based fact operator  follows let    set effect literals            ﬁne new operator works like changes exactly sequence ∈ replaced oando  literals e addition literals ∩ replaced exactly operator  clearly requires change safe operator changes                                                        theorem   let  a g planning problem  exactly literals retains values effects                                                                ∪    ∪                              p ∪ ∪ epe ∪ ∩ p                    let       o∈os  states                                                                                                      pa ¬b e¬a ¬e operator →   a∪a →  a                                                                       op e replaced safe operators oi piei  sas ∈ reachable state                                                                                           given respective values e  reachable state     ¬b       ¬a ¬e                                              ¬b ¬e  ¬a                                                             mapping ptnets    ¬b ¬d ¬e  ¬a                                               ¬b  ¬a ¬e  ¬e     finally map resulting planning problem ptnet                                              ¬b ¬d  ¬a ¬e  ¬e follows let  a g planning problem                                                        deﬁne ptnet pnetrp m    eliminating negative preconditions                 • places  ∪ a                                                   given set state variables introduce set  • transitions  ∪o∈oso  aa ∈ new state variables idea a true • set arcs obtained  p e∈t  exactly false                                   ∈ p∪t  ∈ ∈ ¬a  ∈                                                     ijcai                                                      • ∈ maiff iaand  ma     mole  actually supports option suf                                           iff iaandforalla   ∈  ∪ maor       ﬁces augment planning operator set dummy op      ma                                          erator precondition goal require mole                                                        stop event labelled corresponding tran  figure  illustrates mapping single operator                                                        sition dequeued local conﬁguration event    reachable marking place ∈                                                        partially ordered plan problem owing  resulting ptnet ma ≤  proof following                                                        fact mole’s queue orders events increasing local  theorem induction length transition sequences                                                        ﬁguration cardinality plan contains fewest actions  leading                                                          cardinalitybased ordering relation used mole  theorem  let planning problem ptnet drawback planning leads mole  pnetr safe                                    perform breadthﬁrst search natural idea change                                                        ordering provide better guidance goal    concurrency                                      generalising restricted notion optimality currently  interested notion concurrent partially place considering arbitrary additive action costs  ordered plans allow simultaneous execution sev turns given arbitrary monotonic heuristic  eral operators question arises notion concur possible build adequate order implements let  rency used connection ptnets obtained ting heuristic guide unfolding optimal plans  translation coincides standard notion concurrency adequacy ensures retaining completeness  ai planning turns case preﬁx generated rejoins work directed model    standard notion concurrency planning indepen checking pioneered edelkamp et al edelkamp et al  dence operators pe pe independent iff  heuristic estimates optimal cost reaching  pi ∩ ej  ∅ ei ∩ ej  ∅ ∈    jthis goal given state hsat goal  captures intuition executed order states let costo positive cost operator oand  yielding result cases               reso result applying state mono    independence does general imply concurrency tonic iff hs ≤ hreso  costo nongoal states  ptnet sense instance consider indepen operators applicable deﬁnitions easily  dent planning operators a b a cthecor transfer ptnet case identifying each operator  responding petri net transitions token corresponding transition considering set places  ﬁre concurrently remedied state variables represented  considering petri nets readarcs complicates places true monotonic heuristics like hm  unfolding process supported mole      haslum geffner  automatically generated    ptnets general converse implication does planning problem description equally easily gen  hold cases transitions erated ptnets deﬁne following ordering  place simultaneously planning context simul conﬁgurations  taneous instance consider petri net transitions       ≺  t •t  t•  •t  cand    deﬁnition   let heuristic conﬁguration   •                                                                                           t   markings places contain deﬁne      e∈c cost ϕ                                                                            ≺                          token transitions ﬁre order mark  deﬁne                                                                            currently transitions interpreted planning op            ¬         ¬     erators         concurrency theorem  monotonic ordering ≺h adequate  possible operators dependent  like general case concurrency relation arising proof matter checking  conditions required  translation strictly stronger independence adequacy nd condition nontrivial prove                                                        makes use monotonicity heuristic  theorem  let  a g planning problem let                              ≺                                                     ordering mole’s queue  mono  pnet      let operators tonic heuristic obtain planner generates partially  transitions tt ∈ ∈    ∈                                                 ordered plans smallest total action cost contrast   ﬁre simultaneously state art deterministic planners optimise parallel  independent executed simultaneously plan length aware partialorder  proven contrapositively assuming planner able optimise sum arbitrary action costs  independent showing safety finally heuristic search unfolding space substantially  complementary role places a implies differs existing partialorder planning algorithms  to ﬁre simultaneously                                                           experimental results    directing mole planning                        implemented petrify extended version trans  problem translated ptnet easy let lation planning operators ptnets petrify handles  mole produce partially ordered plan problem al adl fragment pddl modiﬁed mole  gorithm  slightly altered stop event implement variety search strategies heuristics  taken queue labelled designated transition ﬁned respective ordering relations order                                                     ijcai                                                    
