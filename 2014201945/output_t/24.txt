         efﬁcient beliefstate and–or search application kriegspiel                                        stuart russell jason wolfe                                         science division                                university california berkeley ca                               russellcsberkeleyedu jawolfeberkeleyedu                                 content areas gameplaying uncertainty                        abstract                            follows fact opponent simply                                                        choosing moves random nonzero probability du      paper reports new algorithms solving   plicating ﬁnite behavior optimal opponent      partially observable games existing al  observation logical possibility solver      gorithms apply andor search tree black  guarantee win bounded depth depends      box belief states “incremental” versions treat solver’s information true state      uncertainty new search dimension examining  implies opponent’s information state ran      physical states belief state construct domized strategies need considered shortly      solution trees incrementally newly created  theorem does apply certain strategies      database checkmate problems kriegspiel  win probability  guaranteed      partially observable form chess incrementaliza despite restrictions problem quite general      tion yields speedups orders mag isomorphic ﬁnding guaranteed plans      nitude hard instances                         nondeterministic partially observable environments                                                        particular focus paper kriegspiel variant    introduction                                       chess opponent’s pieces completely invisi  “classical” games chess backgammon fully ble game progresses partial information supplied  observable partially observable games despite greater referee access players’ positions  similarity real world received attention players white black hear referee announce  ai overall computational task games di ment universally accepted set rules adopt  vided conceptually parts state estimation following  process generating updating belief state—a • white propose referee  representation possible states world given legal chess board containing just white’s  observations date second selection process pieces white propose pawn capture  choosing given belief state                 • proposed illegal board containing    partially observable games intrinsically com  white black pieces referee announces “il  plicated fully observable counterparts legal” white try  given point set logically possible states •  large rendering state estimation selec legal announcements  tion intractable furthermore selection consider – piece captured square “capture x”  one’s information state gathering information help – black check “check d”  ful opponent’s information state revealing informa following directions  tion harmful finally gametheoretically optimal strate perspective black’s king knight rank file  gies randomized restricting oneself determinis long diagonal short diagonal  tic strategies provides additional information opponent – black legal moves “checkmate” black  paper koller pfeffer  provides excellent  check “stalemate”  introduction issues                           • finally “black move”    paper focus particular subproblem examples play given section  addition  ciding guaranteed win exists—ie strategy details available online kriegspiel website  guarantees optimal payoff ﬁnite depth wwwcsberkeleyedu˜jawolfekriegspiel  gardless true state play opponent important aspect kriegspiel par  simpler general problem reasons tially observable games planning domains “try  state estimate need represent logically possible untilfeasible” property—a player attempt number  states considering probabilities second  following                                                           wlog assume white’s turn  theorem  guaranteed win exists initial belief legal white’s pieces  state iff exists opponent observation rejected turn referee says “nonsense”of actions legal order selection explains selfplay used generate  tempts matters choice actually plan try given ﬁrst database kriegspiel checkmate problems obser  sequence potentially legal moves branching vation histories  factor actual number sequences section  develops basic and–or tree structure  superexponential number potentially solving kriegspiellike games allowing possiblyillegal  legal moves tryuntilfeasible domains ad moves section  deﬁnes baseline algorithms—versions  mit certain simpliﬁcations mitigate branching factor depthﬁrst search dfs proofnumber search pns—    kriegspiel challenging humans ex solving trees presents basic improve  perts “announced” checkmates extremely rare ments algorithms analyzes performance  socalled material wins—such kqrvsk—when checkmate database  side reduced just king sufﬁcient safe section  develops new family incremental search al  material force win checkmate usually “accidental” gorithms treat uncertainty new search dimension  sense player mates knowing addition depth breadth incrementally proving belief  advance                                           states adding single constituent “physical state”    research groups studied kriegspiel check lution each step leads speedup  mate problem  ferguson  exhibited randomized orders magnitude finally section  shows  strategy kbnvsk endgame wins prob state estimation incremental checkmate search  ability  lone black king escape checkmate interleaved  guessing white’s moves correctly inﬁnitely sub  sequently  derived strategy kbbvsk  state estimation  endgame wins probability −ǫ ǫ    terminology mates guaranteed ﬁnd guaranteed win white state estimation  work opponent board additional material identify logical belief state—the set physical  win strategies deterministic developed cian states conﬁgurations white black pieces  carini et al  bolognesi ciancarini   consistent white’s history moves observations    explain section  algorithms ﬁnding check naive algorithm exact state estimation looks like  mate kriegspiel involve searching and–or tree • initial belief state singleton black’s  nodes correspond belief states idea common    pieces start game normal positions  ai literature partially observable plan • each white attempt apply  ning search example chapters   rus physical state remove states inconsis  sell norvig  proposed kriegspiel  tent subsequent percept  applied analogous partially observable variant • each black turn  shogi japanese chess sakuta iida results sev  eral search algorithms summarized sakuta’s phd  – each sequence  “illegal” percepts  sis  bolognesi ciancarini  add heuristic     unobserved black attempts remove  measures “progress” guide tree search consider physical state fewer dis  positions opponent lone king tinct illegal moves  papers initial belief state determined externally – replace each remaining physical state set    search algorithm developed ginsberg        updated states corresponding black moves  partially observable bridge play works sampling ini legal yield given percept  tial complete deal solving each deal fully ob  state  servable game approach gives substantial speedup    – remove duplicate states using transposition table                                                                                                           solving true game tree acts gather kriegspiel belief state grow large—  hide information essential domains states more—so algorithm practical  kriegspiel previous kriegspielplaying agent certain aggressive styles  know developed parker et al  uses ap play belief state remains larger thousand  proach keeps track sample true belief state states game  each point selects best naive algorithm given viewed  remainder game played fully observable chess breadthﬁrst expansion physicalstate tree branch    solving kriegspiel instance nondeterministic par ing black’s moves pruning percepts alternative  tially observable planning carried method adopt performs depthﬁrst search  symbolic techniques ordered binary decision tree instead advantage generating stream  diagram obdd methods developed bertoli et al  consistent current states moderate  quantiﬁed boolean formulae qbf solvers unfortu effort state furthermore set states far  nately computational penalty generating chess moves does admit checkmate belief state does  symbolic inference methods appears admit checkmate state estimation  ders magnitude selman personal communication   selection terminated early section     paper’s contributions follows section  ad randomized depthﬁrst search generate randomly  dresses problem state estimation purposes selected sample consistent states used ap  paper focus exact estimation using straightfor proximate decision making explore approximate state  ward methods section  describes simple complete estimation subsequent paper assume  kriegspiel player combining state estimation exact belief state available checkmate algorithm  kriegspiel checkmate database                     white                                                          order evaluate checkmateﬁnding algorithms    kriegspiel require database test positions prior        work database existed ﬁrst data  base consists white’s percept histories   kriegspiel games point ply checkmate                     qa  exist white  actual mate instances                                     nearmiss instances “almost” admit          guaranteed checkmate  ply each nearmiss              illegal        checkmate  stance checkmate plan works half  possible physical states    database created analyzing games          different kriegspiel programs ﬁrst program playing  white performs exact state estimation makes complex  static approximation ply lookahead plays                qa             defeated easily skilled human second program         playing black weaker computes limited sub                                                                                     capture   capture   set true belief state attempts moves black                  short check  likely captures checks ﬁrst white’s  lief state  black positions fewer determine  belief state describes mate nearmiss instance                   percept history gameinprogress saved  games white’s belief state grows  po  sitions excluded programs white’s belief  state generally remains fairly small half games     nb      nc            kc  played result problem instances                                                                                                                  capture knight check    obviously checkmate problems generate white  method belief states exceed  physical  states history  phys  ical states ﬁnal position average                           solution ply include branches  illegal attempts addition  actual moves    simply reanalyzing ply nearmiss problems   qb            qc            qb  ply constructed difﬁcult database  depth                          ply mate instances  ply nearmiss instances limit                       databases available website url section     better state estimation search evaluation methods figure  minimal and–or proof tree kriegspiel                                                         ply checkmate problem grayed moves blacktomove  developed possible construct difﬁcult section hidden white  problems better reﬂect kinds positions reached  expert play nonetheless problems far trivial possible physical states differ locations  example  ply nearmiss types black’s pieces white know num  instances basic depthﬁrst search requires  ber remaining black pieces ﬁgure depicts minimal  cpu seconds determine mate exists  ply proof tree problem instance possible moves                                                        white omitted describes following strategy    guaranteed kriegspiel checkmates                                                           white attempts qa belief state   thanks theorem  search problem involves tree   rightmost state true state white wins  nodes correspond white’s belief states figure   qa illegal white attempts  shows simple example miniature ply kriegspiel qa belief state   checkmate root beliefstate node  three                                                             subsequent percept “capture a” black    internet chess club database thousand legal moves nb nc  kriegspiel games guaranteed wins identiﬁed black makes nb referee announces  database omits history attempted moves               “capture b” white mates qb    fact ﬁnd deeper mates through simple expedient ii black makes nc referee announces  classifying leaf nodes wins black checkmated white “knight check” white mates qc  known material win deﬁned                 subsequent percept “capture  short    ordinary play combine selection algorithm diagonal check” black legal  online version approximate depthﬁrst state estima kc white mates qb  tion algorithm    achieve high efﬁciency add extra illegal general beliefstate and–or trees consist three types  tempts white’s history “hints” hints fewer nodes  games satisfy beliefstate size criteria           • ornodes figure  ornodes appear white    sections nodes    ornode rep      resents choice possible moves white function solvetopb returns true false      proven iff children proven inputs beliefstate node      children andnodes each containing results                                                            expandb      applying single possible physical state return solveb    • expandnodes expandnodes appear  black      sections representing black’s moves method solveb ornode returns true false      nodes   black’s moves invisible white childrenb      each expandnode single child      solvetopfirstchildrenb return true      node containing union eliminating duplicates  popchildrenb      legal successors possible physical states return false      expandnode proven iff child proven    •                                                     method solveb expandnode returns true false      andnodes andnodes nodes appear   return solvetopchildb      level tree nodes    phys      ical states andnodes abbreviated circles method solveb andnode returns true false      andnode represents arrival percept  terminalb return valueb      referee terminal nonterminal     childrenb        – physical state andnode terminal solvetopfirstchildrenb return false          win white node terminal value true popchildrenb          physical state terminal draw loss return true          white node terminal value false        – andnode nonterminal             figure  dfs algorithm          children form partition nonterminal          physical states percepts change          lying physical states—see nodes   method expandb ornode                                                            each movesfirststatesb      andnode proven iff beliefstate b′ ← new andnode terminalb′ false      tree children terminal physical states proven  valueb′ true depthb′ depthb    kriegspiel referee makes announcement        childrenb′ list  each attempt kriegspiel beliefstate trees     statesb′ mapsuccessormstatesb                                                             each statesb′  andnodes level intervening nodes alter                                         ′  nate expandnodes black moves sequences        win white remove statesb                                                               terminal depthb   ornodes white attempts turn        b′ ← false break  white involve attempts white’s entire turn b′  false  worstcase branching factor equal factorial pushb′childrenb  number possible moves                                    statesb′                                                                 terminalb′ ← true break    searching beliefstate and–or trees    section describes common algorithms—depthﬁrst figure  ornode instance expand method  search proofnumber search—for searching beliefstate structs evaluates children  and–or trees like existing algorithms solve  beliefstate tree ordinary and–or tree black pns proofnumber search bestﬁrst search algorithm  box beliefstate nodes introducing algorithms and–or trees commonly believed superior  evaluate performance ply checkmate database dfs each step pns expands “mostproving” node  basic improvements             make largest contribution proving dis                                                        proving entire tree mostproving node deﬁned   dfs pns                                       node member minimal proof set min  pseudocode dfs depthﬁrst search shown fig imal disproof set tree minimal proofdisproof  ure  dfs  operates using expand method  set minimalcardinality set unexpanded nodes  constructs evaluates children beliefstate node proveddisproved sufﬁcient provedisprove  described section  example figure  shows root tree mostproving node  expand’s ornode instance use dfs simply initial multiple mostproving nodes pns algorithm chooses  ize ornode root belief state remaining depth arbitrarily allis   pass solvetop figure  numbers  nodes indicate order dfs expand  analysis improvements  searching tree                              figure  shows solving ability search algorithms                                                         problems ply database readability    thanks theorem  illegal black moves considered show subset algorithms tested    pseudocode present paper written sim  plicity does include modiﬁcations necessary handling alter initialization pns’s tree reﬂect fact  possiblyillegal moves actual implementations wins occur white moves attempt  efﬁcient instance construct child time depth limit allis  uncertainty sakuta   nodes differ signiﬁcantly pseudocode shown account                                                      pns  shown performs identically pns                          ipns                                     naturally allocates efforts efﬁciently             gldbu                                       future work investigate effects ordering              ldbu                                     white moves informationgathering likely checking          ldub                                     moves ﬁrst legal percepts checks captures             ledfs              epns                                     ﬁrst black white             gxdfs             pns                                     pruning             gldfs              ldfs                                     proof guaranteed checkmate single branch                dfs                                     ing plan succeed physical state belief                                                    state make following observation                                                        theorem   belief state does admit guaranteed      cumulative  proportion problems solved             checkmate superset belief state admits guaran                                              teed checkmate                            time                                                          straightforward implementation expand method                                                       figure  constructs elements belief state             gldbu                                     fore evaluating theorem  suggests ef              ldbu              ldub                                     ﬁcient strategy evaluate each physical state soon           ipns                                     constructed terminal physical state value false              epns                                     nonterminal physical state depth limit             ledfs                                     construction belief state halted early             gxdfs             pns                                     best case reduces effective search depth level             gldfs                                     single element each belief state depth              ldfs                                     limit constructed shown figure  indicated                dfs                                                    “early termination” simple idea                                                        effective improvements consider section                                                          theorem  suggests pruning speciﬁc                                                        tryuntilfeasible trees consider situation    cumulative  proportion problems solved                                                   white belief state attempts possiblylegal                                                        told illegal white’s new belief state                            time                                                        b′ ⊂ theorem  implies b′ does admit guaran  figure  performance search algorithms ply kriegspiel teed checkmate does words  checkmate database mate instances nearmiss illegal child andnode disproved sufﬁcient  stances yaxes show fraction problems solvable disprove andnode’s parent ornode ex  given cpu time lisp  mhz machine ample node  figure  disproved show  algorithms ranked decreasing order efﬁciency trying qa ﬁrst fails ensure checkmate                                                        white node  gives checkmate  introduce dbu dub ipns algorithms later sec clearly useful pruning rule  tion  performance ply database shown  qualitatively similar does allow accurate discrim pruning greedy combined  ination improved algorithms              legalﬁrst heuristic allows white’s turns solved    basic dfs far slowest algorithms tested backtracking adding moves plan iff  primarily factorial branching factor white lead checkmate legal plan  subsequent algorithms avoid large extent basic include repetitions greedy algorithm gldfs  pns faster notice nearmiss instances greedy legalﬁrst dfs worstcase branching factor  generally difﬁcult solve mate instances white’s turn quadratic number pos                                                        sible moves figure  shows gldfs  heuristic ordering                                    slightly outperforms ldfs pruning  searching beliefstate and–or tree using black applies moves lead checkmate legal  box algorithm dfs possible opportu illegal  nities heuristic ordering white moves ornodes surprisingly experiments show gdfs  percepts andnodes paper focus algorithm performs better tries illegal child ﬁrst  lying search algorithms investigate heuristic order instead resulting algorithm actually  ings white moves test simple effective greedy algorithm shown gxdfs figure   ordering percepts                            performs pns power gxdfs stems    andnodes legal children children ability test subset belief state using possiblylegal  legal generally cheaper dfs moves terminate early disproves subset  explore illegal child lower remain did implement “gpns” algorithm  ing depth suggests simple heuristic investigate greedy pruning force pns choose goals  legal children ﬁrst shown figure  ldfs legalﬁrst proving disproving root does simul  dfs considerably faster dfs hand taneously future work explore issue
