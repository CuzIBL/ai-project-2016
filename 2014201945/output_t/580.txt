                                symmetric component caching                                 matthew kitching     fahiem bacchus                                     department science                                       university toronto canada                                    kitchingfbacchuscstorontoedu                        abstract                          problem tree width cspgraph                                                        graph determined constraint scopes darwiche       caching symmetries search decomposi                                                          component produced decomposition point      tion powerful techniques pruning search                                                        search tree appear nodes search      space constraint problems paper                                                        tree caching allows solve each component      present innovative way efﬁciently combining                                                        reuse solution rest search      techniques branch bound solv                                                        caching added decomposition worst case complexity      ing certain types constraint optimization prob                                                                                           ow       lems cops new method signiﬁcantly      search reduced      dar                                                                                                      duces overhead performing decomposition    wiche  bacchus dalmao  pitassi                                                                                                              during search dynamic variable orderings signiﬁcant speedup practice results sang                                                                        employed addition supports exploita  et al   course caching requires space      tion dynamic symmetries appear during case space requirements completely ﬂexible partic      search symmetries previously com  ular caching used speedup algorithm—it      bined decomposition finally achieve   required correctness cache solved      superior integration decomposition caching components space for—within certain practical      branch bound previous approaches   limits space caching faster search      test methods maximum density  proceed furthermore prune cache      life problem show each ideas yields useful items available space exhausted      signiﬁcant gain search performance            decomposition caching impose signiﬁcant overhead                                                        during search techniques effective                                                        complex constraint problems ﬁnding best solu    introduction                                       tion optimization marinescu  dechter  counting  variables constraint satisfaction problem csp number solutions sang et al  static  assigned during backtracking search problem variable ordering used overhead elim  break disjoint parts consider csp consisting inated using data structures computed prior search dar  variables abmxy  constraints ca wiche  dynamic variable orderings yield  cmxy   make assignment  mthen signiﬁcant reductions size search tree  resulting reduced csp consist disjoint sub pay added overhead marinescu  dechter  problems share variables subproblem  methods reducing overhead                                        mm  variables constraint  making techniques effective  cmm  subproblem needed increase practical beneﬁts dynamic decom                       mm  constraint cmm       position  disjoint subproblems created variable assign paper present method making search  ments components components created decomposition caching effective context  signment  solved independently solution dynamic variable orderings key contribution involves  a   b ﬁrst solution x   y method representing common structure entire set  second combined  obtain components single data structure component  lution original csp a      template individual components instances   y worst case complexity solving csp template share single representation com  exponential number variables decomposition mon information making caching considerable space  components yield signiﬁcant computational gains  efﬁcient templates increase efﬁciency    insight exploited perform search cache lookup—we access template’s  decomposition applied recursively bayardo  pe stances simple array indexing templates allow  houshek  darwiche  park  gelder  sang perform component detection during search efﬁciently  et al  dechter  amir  mcilraith ﬁnal key contribution paper method  yield reduction worst case complexity search automatically detecting symmetries templates          ow        wheren  number variables detected templates symmet                                                    ijcai                                                     ric use discovered symmetry mapping map note equally use objective function  instances symmetric instance tem decomposed product sum objectives  plate symmetry encodes entire set individual compo similarly cast problem minimization task  nent symmetries makes computing template symme maximization task  tries cost effective computing symmetries components backtracking search each node search  individual components template symmetries allow tree corresponds set variable assignments  make effective use cached information—cached assignments cause problem broken  component bounds used provide bounds disjoint components component subset origi  symmetric components yield signiﬁcant nal problem isolated set assignments  ductions size explored search space    present formalization idea tailored    finally show achieve better integration subsequent developments  tween branch bound component caching caching component ρofacopp      v dom o tuple  bounds components requiring compo ρvρoρa ρv⊆v ρo⊆oand   ρa   nents completely solved prior stored cache set assignments vi  ai subject following  marinescu  dechter       conditions let varsρa set variables assigned    sequel ﬁrst expand background values ρa  approach present new technique compo                                                                  ρo        ov ∈ scopeo  nent templates show exploited        ∈ρv     achieved beneﬁts just described present  varsρa ∪ ρv  o∈ρo scopeo  initial empirical results test problem maximum den varsρa ∩ ρv  ∅  sity life                                                                                                   minimal tuple p     background                                             ρvρoρa satisﬁes conditions   paper concentrate solving constraint opti ρv⊆ρv   ρo⊆ρo  ρa⊆ρa    mization problems cops decomposable objective sets strict subset  functions template technique used                                                          component contains set variables  applications component caching search decom                                                        objectives variables furthermore ob  position caching counting solutions                                                        jectives isolated rest problem set  constraint optimization problem cop speciﬁed assignments ρa variables mention ei  tuple v dom cowherev set variables ther variables component instantiated ρa  each ∈v   domv  domain values set furthermore variables component  constraints objective function assigns variables ρv assigned ρa  value complete assignments values variables components node each node set  typical goal solving cop ﬁnd assignment assignments set variables  values variables maximizes time                                                        remain unassigned components ρ ρkare  satisﬁes constraints                                                        components ρiv⊆uthe variables    techniques effective cops decompos components unassigned ρia⊆athe current  able objective functions constraints particular assignments isolate variables component  quire decomposed sum objective sub                                                                                                  functions oi    oi each oi dependent example  consider cop variables                                                                                subset variables scopeoi ⊂vandthat       constraints                     each constraint ∈calso dependent subset cmn node just assignment ma  variables scopec ⊂v constraints objective components ρab  subfunctions uniﬁed treating each constraint ρabv  ab ρabo  candρaba    additional objective subfunction mapping satisfying assign ρxyn ρxynv  xy ρxyno  cc                                                            ρ       ments  violating assignments −∞ the overall xyn                                                  uniﬁed objective function          computing components  node easily accom  problem simply maximize augmented ob plished standard algorithms detecting connected  jective function formulation like softconstraint components graph unionﬁnd depthﬁrst  problem paper regard cop search particular consider undirected graph gn      v dom o       tuple             includes original objec contains node objective  tive subfunctions hard constraints encoded addi uninstantiated variable  edge  tional objective subfunctions use term objectives nodes gn nodes variable node                          denote subfunctions                           objective node ∈ scopeo                                                                                                       objective function constraints decomposed observation  connected components cor  method correct decompositions gen respond minimal components particular ρ  erated during search objective global component exists connected compo  straints reformulated decomposed form    nent gn ρv set variable nodes ρo                                                    ijcai                                                     set objective nodes candρa assignments plying decomposition recursively solve individual  instantiated variables objectives components  observation veriﬁed realizing conditions  templates    deﬁnition component introduce new idea component templates used  achieved incrementally adding connected objectives represent shared information group components  ρo                        ρv      connected variables stopping each instance template  connections follow precisely basic idea quite simple innovation arising  nected components   algorithms algorithms templates exploited algorithmically                             ρa  compute minimal components  computed    deﬁnitions observed  ρv    ρo         ﬁnalized note objective components ρ ρ ρv  ρv   ∅                                       fully instantiated node ρo  ρo sets objectives men                 isolated node single node component tioning variables minimal fur  fully instantiated objectives form components vari thermore variables assigned ρa identical  ables objective assignments required fully variables assigned ρa sets assign  instantiate objective                           variables ρio ρiv fact dif  example  suppose example assign  ference nonequal components containing  assignments   nonempty set variables particular val                                                                      ρa    ρa  generate  components ρab ues assigned       differ consequence                                                        valueρ    valueρ  affected new assignment ρxyn split              differ objec                                                        tives maximized subject differing values  components ρxy  x cn   b ρmn                                                         ρa    ρa  c   a note ρmn contains vari          ables just single fully instantiated objective use component templates represent compo  component ρxy does contains  assignment nents identical set variables formally com                                                                        t d  set parent component ρxyn did        ponent template                    set variables                                                        objectives set variables dis  computation beneﬁts components ρ component joint called dependency variables  value assignment variables ρvis set assignments variables gener  equal sum objectives ρo evaluated set ates instance template taand instance  assignments a∪ρa note objectives ρ tais component ta t athatisthe  functions ρv assignments ρa instance component variables objec  complete assignment ρv ρa sufﬁcient tives templates set assignments  fully instantiate objectives yielding single nu disconnects rest problem  meric value each objective sum example  instance consider component ρab                        ρ valueρ  value maximal value       maximum value a bcm     a seen previous example                                                ρv  achieved assignment variables  component template tab  a m includes                                                       ρ                                 m   a  ρ   valueρ          max                oa∪ρa       ab instances particular ab   ab             aa assignment ρv o∈ρo          using templates during search described                                                        components each node backtracking search  solution component assignment variables determined connected components algorithm run  achieves maximal value note components cor graph gn note gn contains vari  responding fully instantiated objective value equal ables objectives does mention actual values  value instantiated objective note assigned instantiated variables algorithm  value component computed examining assign actually identiﬁes set templates components  ments component’s variables rest prob node particular instances templates  lem ignored                                   termined assignments  proposition  let na set assignments template detected ﬁrst time create  node nandletρρk  set components data structure represent template instance store  maximal value obtain complete set template cache data structure used  assignments variables cop efﬁciently detect instances components  a⊇na     leaf node subtree future nodes search follows    k   valueρi furthermore complete assignment observation  let set assignments node  achieves maximal value equal na nandlett component template instantiates  unioned solution each component ρi        variables variables vthen                                                        ta                                   a       proposition follows fact values components                                                        av ∈a∧v    ∈td                components independent each computationally                      subset assigns                                                                      means solve each component independently variables   obtain computational advantage ap efﬁciently detect variables                                                    ijcai                                                     instantiated node using standard lazy watch techniques metry computation different components  moskewicz et al  assigned key making automatic symmetry detection cost effective  test variables unassigned reduce cost symmetry detection conﬁne  triggered know forms compo variable symmetries ﬁnergrain sym  nent current node template’s variables metries deﬁned variablevalues  objectives removed gn reducing formally require symmetry templates  size connected components run onetoone mapping σ  smaller remaining graph identify components variables td∪tv td∪tv  current node triggering components reducing                                                           td  σtd tv  σtvwhereσ applied  size gn way yield nontrivial improvement                                                            set σsσv ∈  total time needed perform component detection    template triggered need access  assignment variables td∪  formation particular instance exists cur tv value objectives evaluated  rent search node tat d associated each template identical value objectives evaluated  value cache used store upper lower bounds σawhereσ applied set assignments  values instances solutions stored σaσv av   ∈a                       ta  solved instances  template instance otherwords σ keeps dependency variables tem  talb taub denote stored lower              valueta                               plate variables separated preserves value  bounds            instance template objectives value template instance  seen bounds given default initial val                                                        ta maximum sum objectives  ues search subtree current node                                                        der ﬁxed assignment dependency variables td  compute value instance making talb                                                         assignment tvwehavethat  taub compute better bounds value backtrack                                                                             updating bounds template observation    symmetric map                                                             σ                            a  accessing instance’s bounds efﬁcient par ping instance                                                           valuet avaluet  σa  ticular each variable ﬁnite domain values                      each instance tais deﬁned values assign means bounds computed com  variables use instance’s deﬁning se ponent tσa reused component ta  quence values index multidimensional array automatically detect symmetries templates  instances template en during search map problem graph isomorphism  countered during search branch bound problem constructing graph representation each tem  pruning array large use plate graph representation property tem  instance’s sequence values hash code index plates’ graph representations graph isomorphic  small hash table suitable storing sparse data templates symmetric sense deﬁned                                                        graph isomorphism maps vertices graph  example  previous example set                                                         provides variable variable symmetry mapping  ﬁrst time create new template tab tabv                                                         templates  ab tabo  candtabd    represent                                                          solve graph isomorphism problem using available  component ρab instance template tabm  a                                                                                                     immediately created search proceeds variables graph automorphism software case nauty mckay                                                                                    returning upper lower bounds component   shown puget  software sur                                                        prising efﬁcient graph isomorphism known  ρab instantiation  bounds  maximal value achieved objectives polynomial complexity utilize symmetries during                                                        search proceed follows template ﬁrst  tabo possible values subject                                                         created construct graph representation gt nauty  bounds stored template cache tabm   alb    m    aub                               used compute isogt  canonical isomorph        ab            bounds indexed                                              assignment                                          symmetric previously cached template                                                        graph isomorphs equal isogt     assign  later search                                                        isogt   using hashing techniques isogt   unassigned tab triggered bounds new                                                        ﬁnd isomorphic template near constant time iso  instance tm m  k retrieved template’s value                                                        morphic template  utilize invertible map  cache  cached upper lower bounds                                                        pings gt  → isogt   gt → isogt  produced  reused new search node                                                                                                                      nauty compute symmetry map   template symmetries key computational use    utilize symmetry avoid allocating value cache  templates perform automatic symmetry detection ’s instances instead mark symmetric  tween components abstract level templates par  store symmetry map σ continue use  ticular compute symmetries templates during detect instances created transparently  search templates created during search sym rest code read store information  metry templates applied ’s instances instead remap access  instances allowing amortize single sym symmetric instance  instances                                                    ijcai                                                                                                          ccsbbtalb  able utilize bounds computed instances fur                                                            ∅∨taub ≤ lb ∨ talb  taub  thermore bound computed instances stored                                                            return  information instances                                                           lb  talb lb   talb  different templates symmetric symmetries                                                                             map earliest created template means    select variable branch                                                           ts   information computed instance uti       templates contained graph                                                                             tob    tv −v   lized symmetric components                        consisting                                                                     foreach ∈ domv   example  consider cop described earlier                                                             foreach ti ∈ ts  set  ﬁrst time create new template        a∪v   d                                                                                 tid  txy txyv  xy txyo   candtxyd            foreach ∈ ts   a ub  lb                                                                                   represent component ρxyifc type                                                               lbi   lb  ji tj aj ub  constraint graph representation tab                                                               ccsbbtiapilbi   txy isomorphism                                                                     lb ub     tiailb tiaiub  templates case mapping variable  lb  maxlblbd  cache template txy point cache                                                                                              talb taub  maxdlb  maxdub   template tab mapping → create  instance txyn  a use cached results figure  template component caching search branch  tabm  alb tabm  aub                      bound templates try compute valueta    note original cop example  soon discover valueta ≤ lb                   nm  exchangable       symmetry does cache used store values fully solved  exist assigned mechanism components default initial bounds used  detect dynamic symmetries                        trying solve unsolved component    unfortunately space restrictions prohibit present search computed better bounds previous attempt  ing details template graphical representation ﬁrst thing algorithm does line  check  mention choices representation template contains variables case  exist representation utilizes nauty’s ability input tains single objective function fully instantiated  coloured graphs ensure computed graph symme assignments talb taub  tries dependency variables template variables equal value objective taub ≤ lb  separated condition  allows exploitation case required bound achieved                                                  fact objectives exchangeable variables talb  taub case component al  uses colours ensure equivalent objectives ready fully solved actually captures case  map each                                    cases procedure immediately    symmetric component caching search                 return                                                          check known com  search algorithm given figure  shows uti ponent achieve higher value required lb line  lize ideas perform recursive decompositions                               ccsbb                    case algorithm going compute com  tegrated branch bound      attempts ﬁnd  ponent’s maximum value computation aborted  value single component given template instance bounding make efﬁcient reset  ta provided lower bound lb                                                                                       ta         ting lower bound higher value variable  abort computation soon discovers split selected determine compo  achieve value greater bound com nent decompose variable assigned line   putation aborted routine stores best combination template triggering  bounds able compute termination line  nected component analysis triggered templates  storing bounds produced partial computation removed constraint graph each remaining connected  component’s value allows better integration branch component forms new template objective input  bound described bounds stored template ∈to uninstantiated variable  template’s value cache symmetric template’s forms template  v  ∅ o   value cache                                         instance template a upper    branch bound inevitably implies search lower bounds equal evaluated compo  attempt compute value particular template instance nents containing variables generate new templates  times aborting each attempt current automatic symmetry detection performed  bound updating component’s bounds each assigned different values different instances templates  attempts work saved particular each new ts created solved  tempt proceed efﬁciently utilizing stronger                                                          lines   identify new template instances compo  bounds computed previous attempt approach                           contrast presented marinescu  dechter  nents created current value  components                                                        solved lines – abandon assignment         variables xi xj exchangeable objective line  time sum upper bounds  exchanging assigned values effect objective components fails reach required lower bound                                                    ijcai                                                     
