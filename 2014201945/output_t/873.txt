    complexity results checking equivalence stratiﬁed logic programs∗                      thomas eiter michael fink hans tompits stefan woltran                       institut f¨ur informationssysteme technische universit¨at wien                               favoritenstraße – vienna austria                                 eiterﬁnktompitsstefankrtuwienacat                          abstract                          deductive databases attractive features pro                                                        grams unambiguous semantics      recent research nonmonotonic logic program    propositional case polynomial complexity      ming answerset semantics focuses      asp programs contain stratiﬁed subprograms      different notions program equivalence    serve generateandtest methodology gelfond      previous results address impor  leone  niemel¨a  baral  check      tant classes stratiﬁed programs sub   ing candidate fact solution problem      class acyclic recursionfree programs al hand example program      recognized important tools              bad ←   ok      knowledge representation reasoning                                                                      ok ←   choosex      paper consider programs possibly aug      mented constraints results show       choosex  ←   optionx omitx      propositional setting reasoning       omitx  ←   optionx choosex      known polynomial deciding strong uni      form equivalence hard arbitrary normal ﬁrst statements check option      logic programs conpcomplete   chosen output “bad” case typically                                                        eliminate unwanted models constraint ← bad      polynomial restricted cases nonground                           bad      programs behave similarly exponential   added remains true deleted head                                                        ﬁrst rule fact sets rules  ← bad  bad ←      lower bounds hold small programs ok ok ← choosex    ←bad     ← ok      constantly rules particular uniform                                                                                           ok ←  choosex strongly equivalent      equivalence undecidable small horn                    programs plus single negative constraint       replaced  vice versa arbitrary program                                                        rules deﬁne bad  safely drop                                                        constraint ← bad  note example checking    introduction                                       parts acyclic recursion occur                                                        computing transitive closure reachability graph  recent years large body work answerset program remind capability expressing transitive closure  ming asp devoted obtain semantical com assets logic programming  putational characterizations different notions equiva given importance practice paper  lence nonmonotonic logic programs investi sider testing equivalence stratiﬁed programs  gations mainly concerned strong equivalence lif possibly augmented constraints contributions  schitz et al  facilitates replacement property brieﬂy summarized follows  nonmonotonicity akin familiar  provide detailed picture computational  holds classical logic weaker notions uni complexity deciding strong uniform equivalence  form equivalence eiter fink  pearce valverde tween stratiﬁed respectively acyclic logic programs   general case certain fragments like pos propositional case show problems conp  itive programs wellunderstood eiter et al bthe complete simple cases hard  picture remains unclear fragments     general case normal logic programs    important fragments stratiﬁed programs trasts nonground case syntactic restrictions  subclass acyclic recursionfree programs make strong equivalence testing conexptime  widely used knowledge representation cf time complete general easier cases  baral  play instance important role  elucidate role constraints context                                                        constraints cases testing strong equivalence    ∗this work partially supported austrian science fund tractable easier testing uniform equiv  fwf project                           alence remains intractable similar picture                                                    ijcai                                                     nonground case noticeable result estab program constraintfree constraint occurs  lish uniform equivalence programs horn rules horn constraintfree horn pro  undecidable soon permitted contain grams called deﬁnite program called acyclic  horn rules single negative constraint ← resp stratiﬁed iff function  a→n  propositional atom removed each ∈ hrh nonempty fab                                                                            −  decidability presence fah each ∈ ii fab fah resp                                                                                      arbitrary positive constraints                   fab ≤ fah each ∈     discuss effect restrictions interpretation understand set ground  important practice including “small” programs atoms ground rule satisﬁed symbolically   number rules bounded constant strong iff br ⊆ b−r ∩  ∅thenhr ∈  uniform equivalence unsurprisingly tractable satisﬁes ground program  denoted   iff each  propositional case remain intractable exponen ∈ satisﬁed iaseti ⊆ bp answer set  tial nonground case fact uniform equivalence iff subsetminimal set satisfying gelfondlifschitz  mains undecidable                                    reduct gelfond lifschitz  grp     results ﬁll gap knowledge complexity spect igivenby  testing equivalence stratiﬁed programs constraints                                                           hr ← br  ∈ grp i∩ b−r∅  complement previous results show  surprisingly simple propositional programs set answer sets denoted asp aswell  testing strong respectively uniform equivalence intractable known stratiﬁed program answer  recall deciding ordinary equivalence programs set case acyclic deﬁned  answer set polynomial completion beneliyahu dechter   fact feasible linear time furthermore results show consider following notions equivalence  restrictions relevant practice prob programs  lems remain intractable exponential lower bounds                                                          •                    ≡   asp asq  remain undecidable                               ordinary equivalence                                                                            • uniform equivalence ≡u each ﬁnite set    background                                             facts asp ∪ asq  ∪  use language containing following possibly inﬁnite • strong equivalence ≡s each program  sets set predicate symbolsasetv variablesanda asp ∪ sasq    ∪  set constants called domain atom expres             pt       ∈a          αpn        remark difﬁculty deal uniform strong  sion form           arity           equivalence nonground case origin ex  ti ∈c∪vfor  ≤ ≤                                                      tended programs naturally enlarge active domain    rule  form                            original herbrand bases programs          ← bbk bk bm          useful anymore eiter et al  atom bbm atoms ≥  ≥  “not ” denotes default negationifa  propositional case                                         constraintif      factandif           section programs assumed propositional                              hr    hornthehead  given      andthebody     predicates arity  normal unless speciﬁed oth       brb                                           erwise following proposition collects results eiter et         br      b−r       use                              al known properties  assume rules safe each variable            −                                                               ≡                     hr ∪ occurs                 proposition  deciding    normal programs                                                              ∈s    program ﬁnite set rules set variables oc     isinconp programs                                                                             curring expression atom rule program horn problem  stratiﬁed programs deciding                                                        ≡       noted ve set constants resp predicates occur   ring ce resp ae expression ground iff ve  ∅ start proving phardness result simplest class    predicate ∈ap called extensional iffthereis programs considered  ∈ hrp intensional                                                         lemma    deciding ≡e acyclic deﬁnite horn pro  herbrand base bac set ground atoms                                                        grams phard ∈o  predicates constants bp  bap cp herbrand  base program                                  proof reduce pcomplete problem monotone cir    given rule set constants ⊆cwedeﬁne  cuit value goldschlager  equivalence problems  grr set rules obtained possible question circuit given directed acyclic graph  substitutions vr elements program  vewherev  each ∈ satisﬁes  the grounding respect given grp ijelementsofv socalled gates speciﬁc sorts viz   r∈p grr particular grp  stands grp cp   ⊥ ∧or∨ gates sorts indegree  referred simply grounding wherecp   indegree  gates outgo  constant appears                             ing edges called output gate semantics                                                    ijcai                                                     deﬁned straightforwardly induction each gate ≡s  ≡u  normal   constrfree horn  deﬁnite  follows vjresp vj sort deﬁnite     conp    conp              resp ⊥ cases exactly edges horn     conp      conp      ij ij deﬁne vjvi · vi case constrfree conp    conp  sort ∧ vjiff vivi ≥  case normal    conp  sort ∨ deciding vnfor output gate  problem monotone circuit value                 table  complexity landscape propositional programs    given ve deﬁne program follows each  gate sort   fact pj  each gate    sort ∨ having ij ij ewehaverulespj ← pi   disallowing constraints yields conphardness    pj ← pi  each gate sort ∧ having ij programs use negation                  ←           wehavetherule      nowgiven    lemma    deciding ≡s conphard constraint                                    ∪o  ←  output gate  compare programs             free acyclic programs  ∪o  ←  pn obviously programs acyclic horn  constraints constructed given cir proof sketch exact hitting set problem  cuit ve polynomial time using logarithmic space proof lemma  deﬁne                                                                 easily veriﬁed ∪o ← ≡o ∪o ← pn                                                                 ←  cici ← cici ← cici  iff vnholds ve monotonicity    ≤i≤n                                                                     ←  ci ci ci  correspondence extends ≡u ≡s                 establish pmembership result                ←  cici ← cici ← cici                                                                     ←      lemma   deciding ≡s normal program                                horn program programs  ∪b ←  constraintfree                                      ∪a ←   proof sketch constraintfree interpre                                                       acyclic constructible polynomial  tation  ap ∪q model                                                        time shown exists ehs  necessary condition strong equivalence hold test                                                        iff ≡s                            hold horn program                                                          case checking uniform equivalence task conp  constraintfree test amounts check                                                        hard soon negation involved  strongly equivalent deﬁnite horn program test            ≡s                 lemma    deciding ≡u conphard acyclic    let turn acyclic normal programs acyclic straintfree programs horn  programs constraints obtain following result                                                          proof proof lemma   lemma   deciding ≡s conphard acyclic pro ﬁne program containing  ≤ ≤  grams constraints horn                                                              ← cicia←   cicia←  cici   proof use embedding conpcomplete exact  hitting set problem given instance swherec     ← ci ci ci           family subsets ﬁnite set problem                                                       show exists ehs iff ≡u ←  decide exists subset ⊆                                   asp  ∪    s ∩ c           c ∈            s              suppose set facts                each      anysuch      ex  ∪a         a∈                                                                     loss general  act hitting set ehs  conphardness sufﬁ ity assume ⊆ ssincea derived ∪   cient consider containing sets cardinality solet                ≤ ≤  ∩f  ≤                          each                            construct                    ∩f                                                          rules         rules   acyclic program consisting constraints     ehs          ←  cici ← cici ← cici      onlyif direction shows adding ehs                                                        s                      s    ∪ s          ←  ci ci ci                     yields answer set                                                             does occur cwehavea∈ sbuts ∪a ←    ≤ ≤ furthermore consider  ← ←                                                                                                      turn ∪a answer set ∪  acyclic horn show exists                                                               equivalent ∪a ← ≡u ←         ehs iff ≡s clearly equivalence problem                                                          established hardness results carry stratiﬁed  constructible polynomial time size                                                        programs eventually obtain picture complex    suppose ≡s exists classical model                                                        ity deciding ≡e ∈u programs    constraints  model nonempty                                                        considered classes note restrictions stratiﬁed  cicici∩m   each  ≤ ≤ nfurther                                                        acyclic programs did lower complexity  view constraints  cicici∩m≤  hold each  ≤ ≤ nbutthenm ehs    theorem   complexity deciding strong resp uni    onlyif direction easily shows ehs s form equivalence normal propositional programs  classical model  existence summarized table  entries completeness results  ehs implies ≡s                                 hold stratiﬁed acyclic normal programs                                                    ijcai                                                       complement results giving complexity bounds • exptimecomplete horn programs  qand  ordinary equivalence                               • conexptimecomplete normal programs   theorem  deciding ordinary equivalence normal                                                        furthermore known program complexity  stratiﬁed programs complete hardness holds acyclic horn programs constraints pspace  acyclic deﬁnite horn programs complete cf dantsin et al   programs arbitrary normal problem conpcomplete ciding ordinary equivalence acyclic horn programs                                                        easily shown pspacecomplete  structurepreserving notions equivalence impor  tant observation case strong equivalence added strong equivalence note acyclic horn programs  rules destroy syntactical properties programs known strong uniform equivalence coincide  der comparison unwanted given acyclic                                                    classical equivalence refutable nondeterministic  resp stratiﬁed programs  natural com polynomial time using oracle ordinary equivalence  pare programs admissible extensionthat acyclic horn programs feasible exptime  say programs introduce cycles resp pspace acyclic programs turn classical  resp cycles involving negation joined                                                    equivalence hard classes shown     best knowledge equivalence duction deciding inference atom program  tions sensitive compared programs  introduced far notable exception strong theorem  deciding ≡e qwheree ∈o sis  equivalence prioritized logic programs faber exptimecomplete given horn pspace  konczak                                        complete given acyclic horn                                                        each case hardness holds deﬁnite programs  deﬁnition  programs acyclicitypreserving  resp stratiﬁcationpreserving strongly equivalent denoted let consider normal programs arbitrary      ap            sp  ≡s  resp ≡s iff each program programs deciding strong equivalence conexptime  ∪ ∪ acyclic resp stratiﬁed ∪ lin  conexptimehard eiter et al  ∪ possess answer sets               suitable modiﬁcations hardness proof                                    sp                  strengthened acyclic programs obtain    programs negations ≡s clearly  ≡s known results theorem  deciding ≡s conexptimecomplete  case ≡s equals ≡u acyclic stratiﬁed normal programs hardness      ap  ≡s   collapses uniform strong equivalence holds constraintfree programs  positive programs strong uniform equiva               ≡                       lence coincide   witnessed set facts uniform equivalence  shown uniform equiva  does create cycles added                         ≡sp                            lence normal programs undecidable proof    general relation differs strong equiv reduces query equivalence horn programs shmueli  alence illustrated following example consider  uniform equivalence query equivalence    ← ←  ←  ←                                           sp           spect predicate problem deciding given horn  ≡u  ≡s qhoweverp  ≡s   holds                                                                   ≡                      programs     extensional predicates inten  counterexample   destroys struc sional predicates ﬁnite database set  ture programs                 facts holds ∪d ∪d derive                         ap             sp  theorem  deciding ≡s   resp ≡s conp  facts qweuselinear programs programs  hard constraintfree programs horn intensional predicate rule bodies  proof sketch use construction proof query equivalence remains undecidable feder saraiya  lemma  exact hitting set problem  adapt construction eiter et al  corresponding program  show exists reduce query equivalence program equivalence                                                                            ∪     ∪  ehs iff ≡s ←fori ∈ap sp       test                                                                answer sets ﬁnite database follows deﬁne    results general nonground case                    ∗  ∪ q ∪p∗x ←  px    section ﬁrst review known results non    q∗  ∪ q ∪p∗x  ←  px   ground case provide new results revealing fol  lowing insights contrary propositional case q results replacing each intensional pred  prove nonground programs complexity decid icate symbol i p∗ fresh predicate refers  ing strong uniform equivalence decreases acyclic pro query predicate query equivalent  grams certain cases ii show new undecidability respect iff ∗ q∗ program equivalent  result uniform equivalence strengthening earlier map problem program equivalence  sult eiter et al given disjunctive programs linear horn programs uniform equivalence  case normal programs                              mal programs basic idea computation min    let ﬁrst review complexity ordinary equivalence imal models programs transformed computation  follows dantsin et al  deciding ≡o certain maximal models program reducts viz socalled                                                    ijcai                                                     uemodels characterizing uniform equivalence eiter et al small programs small programs programs                                                constant bound number rules proposi    follows given linear horn program exten tional case shows decreasing complexity given ﬁxed  sional predicates ep intensional predicates ip letd integer deciding ≡e programs  new unary predicate new propositional atom rules ∈o feasible polynomial time  each rule ∈  denote                             result nonground setting obtained    •                  br                         programs proving undecidability query equivalence       list atoms having predicate  deﬁnite linear horn programs feder saraiya                                                                                            • dr list dxdxmwherevir  vhr ∪    programs say  three        ver xxmand                             rules number predicates constants bounded                                                        programs → q→ used prove theorem     • ir intensional predicate br exists                                                   small number predicate symbols      wise let                                       original programs easily bound turn bounds           ∗        ¯         ¯  let ap  ap ∪ ep whereep   e¯  ∈ep  new number rules sets   sets    predicate symbols deﬁne → follows         introduce unbounded number rules                                                        sets ﬁxed just three rules using following   ←  hr  ∈ br∅ ∪                     argument rotation technique replace  three rules   ir ← erhrdr   ∈ br  ∅ ∪                                                                                        cck ←   dc ← ∈cp ∪                                                                                                                              xxk ←  xxkx   dx  ← px    ∈a∗   ≤ ≤ n∪                                                        dx   ← dx                                              ∗                                        pxxn ←  dxdxn  ∈ap ∪                                                         cck constants occurring  each   ←  exxn e¯xxn  ∈ep ∪          ∗                                      →                                                        ∈a   letp new predicate replace    ←not                                                                                                                                                                                 xxn ←  pxxn               →                                                                                   observe   normal contains single negation        xxn ←  xxxn  forthcoming result relies observation                                                                  dx   ← px    horn programs domain                                                 → ≡ q→      program equivalent iff       arity theses modiﬁcations undecid  result feder saraiya  obtain ability shown    theorem  deciding ≡u normal programs   theorem   ≡u undecidable small programs  undecidable holds deﬁnite horn                                                          method restrict number rules  programs augmented single negative constraint                                                        gottlob papadimitriou  show horn    remark problem decidable programs faithfully transformed singlerule pro  programs say negationfree nega grams prove logical implication  tion negative constraints possibly augmented single horn rules exptimehard result  “domain predicates” guaranteeing safety intuitively argument rotation technique derive                 monotonicity  disregard negative theorem  deciding ≡e qwheree   ∈s ois                 constraints inconsistent exptimecomplete small horn programs  inconsistent obtain ≡u                                                        bounded predicates arities finally brieﬂy discuss    restricted cases                                   bounding predicate arities constant checking strong  finally consider results equivalence checking case ordinary equivalence signiﬁcantly easier                                                                                             Σp  parameter associated compared programs note checking answerset existence  complete  ﬁxed constant space reasons discussion setting eiter et al size                                                                                succinct informal detailed formal account brand base program polynomial size                                                                                                results given version paper  classical model checking deciding given                                                        ⊆ bp  conp note grounding                                                        exponential strong equivalence sufﬁcient    predicates propositional case ﬁxed number consider extended herbrand base bap cwherec aug  atoms clearly makes considered equivalence problems ments cp polynomially new constant symbols  tractable nonground case traditional technique readily follows proofs given eiter et al  rewriting arbitrary programs programs single case strong equivalence ordinary equivalence  predicate shown faithful respect strong obtain equivalence checking normal pro  equivalence hardness undecidability grams second level polynomial hierarchy  sults nonground case carry programs uniform equivalence similar restriction domain  predicate symbols                                possible fact case disjunctive programs                                                    ijcai                                                     
