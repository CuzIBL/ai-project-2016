                     study residual supports arc consistency                                   christophe lecoutre     fred hemery                                          cril−cnrs fre                                              universit´e d’artois                                                lens france                                  lecoutre hemerycrilunivartoisfr                        abstract                          oedandoedwheree  denotes number constraints                                                        greatest domain size optimal al      arc consistency ac algorithm residual  gorithm ac resides robustness means      support residue support stored ac does suffer pathological cases      during previous execution procedure ac does situation occurs tightness      determines value supported constraint constraints high case equality constraint      point residue guaranteed rep constraint form   naturally      resent lower bound smallest current sup expected demonstrated later ac admits practical      port value paper study theoreti behaviour close worstcase difference      cal impact exploiting residues respect factor theoretical worstcase complex      basic algorithm ac prove acrm   ities reality      ac multidirectional residues optimal      low high constraint tightness second show  paper interested residues ac algo      ac maintained during  rithms residue support stored during      tracking search mac presents respect   previous execution procedure determines      macrm overhead oμed branch    value supported constraint point residue                                                        guaranteed represent lower bound smallest      binary tree built mac μ denotes      number refutations branch num   current support value basic algorithm ac      ber constraints greatest domain size reﬁned exploiting residues follows searching      constraint network consequence support value scratch validity residue      macrm admits better worstcase time complex   associated value checked obtain al      ity mac branch involving μ refuta gorithm denoted acr multidirectionality ex                                                       ploited algorithm denoted acrm      tions μd μdand tightness      constraint low high experi fact acr algorithm advantageously      mental results clearly show exploiting residues replaced ac ac established stand      allows enhancing mac sac algorithms          given constraint network ac                                                        maintained during search macr corresponds                                                        macresidue likitvivatanavong et al     introduction                                       quite competitive hand acrm interesting  wellknown arc consistency ac plays central exploits multidirectional residues just like  role solving instances constraint satisfaction prob ac lecoutre et al  let  lem csp mac algorithm algorithm exploiting residues  maintains arc consistency during search prove paper acrm contrary ac  lution considered efﬁcient generic ap admits optimal behaviour tightness  proach cope large hard problem instances fur straints high illustrate let consider domino  thermore ac heart stronger consistency called problem introduced bessiere et al   singleton arc consistency sac recently constraints problem correspond equality constraints  tracted lot attention bessiere debruyne  results obtain running ac ac  lecoutre cardon                           ac new algorithm acrm instances    decades algorithms problem depicted table  time seconds  proposed establish arc consistency today ref cpu number constraint checks ccks given  erenced algorithms ac mackworth  each instance form dominond corresponds  simplicity ac bessiere et al  number variables number values each  optimality complex worst domain clearly acrm largely compensates weakness  case time complexities ac ac respectively basic ac                                                    ijcai                                                        instances        ac    acrm    ac  ac                cpu                     given network involves removing values    domino               ccks                 arc consistent                cpu                      domino               ccks                   deﬁnition  let    cn pair                cpu                      domino               ccks                ∈  ∈ domx arc consistent ac iff ∀c ∈                cpu                          domino                                         ∈                                             ccks                   scp  exists support ac                                                        iff ∀x ∈  domx  ∅ ∀a ∈ domx ac  table  establishing arc consistency domino instances following deﬁnitions useful later analyze                                                        worstcase time complexity algorithms    analyse cost managing data structures                                                        deﬁnition  cnvalue triplet form cxa  respect backtracking hand easy embed ∈    ∈           ∈         acrm mac sac algorithms algorithms      scp   dom    require maintenance data structures during mac deﬁnition  let cxa cnvalue scpc  search sac inference hand embedding   optimal algorithm ac entails extra devel                                                          • number supports  denoted  opment effort addition overhead execu                                                                corresponds size set ∈  tion mac overhead oμed branch    cxa                                                                      ∈      binary tree built mac account dom   rel                                                          •                             reinitialization structure called contains number conﬂicts denoted ccxa  smallest supports μ denotes number refu corresponds size set ∈ domy    tations branch denotes number constraints ∈ relc  greatest domain size                                                          note number cnvalues built                                                        binary constraint network oed sum evaluations    constraint networks                                expression exprc wrt cnvalues                                                                                                                                             given cn write  expr    constraint network cn pair                            cxa  asetofn  variables asetofe constraints each vari  able ∈ associated domain denoted domx acrm  contains set values allowed each  straint ∈ involves subset variables  called section introduce acrm propose  scope denoted scpc associated relation tailed analysis complexity important remark  denoted relc contains set tuples allowed algorithm given general case ap  variables scope initial resp current domain plied instances involving constraints arity  variable denoted dominitx resp domx strictly speaking description corresponds gacrm                                                        non binary constraints usually talks gen  each rary constraint scpcxxr  relc ⊆  dominitx    denotes  eralized arc consistency gac simplify theo                                                  retical complexities given binary instances  cartesian product element aar  called tuple dominitx  tx  denotes value precisely theoretical results consider given                                                binary cn     simplify  ai important note assuming total order  domains tuples ordered using lexicographic order loss generality each domain exactly contains values  ≺ simplify presentation algorithms establish generalized arc consistency given cn  use special values ⊥  tuple doac algorithm  called returns true  ⊥≺t ≺                                          given cn arcconsistent described                                                        context coarsegrained algorithm initially pairs                                                              deﬁnition  let rary constraint scpc  called arcs set qonceq                               init               initialized each arc revised turn line andwhena   xxr  artuple dom   xi said  allowed iff ∈ relc valid iff ∀x ∈ scpc tx  ∈ revision effective value removed                                                                              domxi support iff allowed valid set updated line  revision performed                                                        function revise entails removing values                                             tuple said support xia inconsistent respect function  support txia determining tuple  allowed called constraint check solution cn  assignment values variables algorithm  doac     cn boolean  constraints satisﬁed cn said satisﬁable iff ad  ←c  ∈ ∧ ∈ scpc  mits solution constraint satisfaction prob   ∅  lem csp npcomplete task determining  pick delete  given cn satisﬁable csp instance deﬁned  revisecx                                                             domx∅  return false  cn solving involves ﬁnding solu ← ∪cyc   ⊆scpc  tion determining unsatisﬁability arc consistency ac   remains central property cns establishing ac  return true                                                    ijcai                                                     algorithm  revisec  constraint  variable  boolean searching new support scratch    nbelements ←domx                              residue valid natural efﬁ    each ∈ domx                            cient perform search using value residue     suppc valid continue          resumption point exactly ac     ← seeksupportc                         means practice acr interesting        remove domx               embedded mac likitvivatanavong et al  sac     each ∈ scpc suppc ty  ← algorithm                     domx    return nbelements                                   acrm space complexity oed nonoptimal                                                        worstcase time complexity oed possi  algorithm  seeksupportc  tuple              ble reﬁne result follows    ←⊥                                              proposition  acrm worstcase cumulated time                                         complexity seeksupport cnvalue cxaisocs     ct return                                                         ccxa  scxa     ← setnextt uplecx    return                                            proof worstcase terms constraint checks                                                         value removed dominity                                                         calls revisecx  values dominity  ordered  returns true revision effective algorithm way ﬁrst values correspond values  stopped domain wipeout occurs line orthesetq support values correspond                                         values support atheﬁrsts values removed    following principle used ac lecoutre et al dominity  systematically correspond sup   propose mechanism partially beneﬁt ports recorded acrm domain wipeout en  positive multidirectionality idea sup countered calls note initial  port recorded values occurring seeksupportc obtain ∗ constraint  example let consider binary constraint checks hand number operations  scpc  ifa looking validity checks updates supp structure revise  support yb cases performed respect bounded  recorded support worstcase cumulated complexity osc     support yb fact sim ocs    ply record cnvalue cxa support interesting acrm al  xainc unlike ac exploit gorithm optimal adapted instances involving  ing multidirectionality beneﬁt anymore uni constraints low high tightness  directionality means support straint tightness low precisely  valid search new support scratch high worstcase cumulated time com  using multidirectionality guarantee plexity od optimal hand  support corresponds smallest sc maximized   corresponds  support new algorithm requires introduction medium constraint tightness acrm  threedimensional array denoted supp data structure expected good practical behavior medium  used store cnvalue cxa support constraint tightness average asymptotically  xainc initially element structure supp considering random constraints  constraint checks nec              ⊥  set  each revision algorithm  involves essary ﬁnd support tightness   testing value validity support line deduce following result   fails search new support started  scratch algorithm  uses setnextt uple proposition  worstcase time complexity acrm                                                                         ∗  turns smallest valid tuple built oed ccxa scxa  ≺ t txaor does exist      cxa  loss generality assume setnextt uple table  indicates overall worstcase complexities                                        performed constant time note establish arc consistency algorithms ac acrm                                   ⊥  stood constraint check returns false ac ac interesting look worst  search succeeds structures corresponding case cumulated time complexities seek successive supports                          supports updated line                          given cnvalue cxa intro    summarize structure supp allows record duced earlier easy show optimal algorithms admit  multidirectional residues course possible cumulated complexity od observing table   exploit simpler residues likitvivatanavong et al  learn ac acrm optimal tightness  called unidirectional residues exploiting multi low unlike ac acrm  directionality derive new algorithm denoted optimal tightness high  acr replacing line  algorithm             suppc ←                         lack space provide detailed proof    acr ac established stand original complexities given ac                                                    ijcai                                                                                                                            space           time per branch              space              time                                                                                                                       oe  nd     oed  ∗  ccxa       ac   oe  nd od ∗   ccxa   scxa         mac                                                                                            cxa                          cxa       cxa                                                                                                                                                                                                        oed     oed     ccxa ∗ scxa      acrm    oed     oed    ccxa ∗ scxa      macrm                                                                                       cxa                             cxa                                                                                              ac   oed              oed                     mac   min ed       ed μ                                                                                              ac    oed              oed                      mac   min ed       ed μ      table  worstcase complexities establish ac table  worstcase complexities run mac time com                                                        plexity given branch involving μ refutations                            tightness                       low   medium  high                                                    ac    ocd  od  od   od                                               price space complexity ominnded          acrm  cs                                              ac   od    od  od    od            van dongen                                                 ac                         proposition  mac mac worstcase cu  table  cumulated worstcase time complexities seek suc mulated time complexity reinitializing structure  cessive supports cnvalue cxa   oμed branch involving μ refutations                                                          proof refutation occurring branch need                                                        restore data structure worstcase    remark complexities given acrm hold ∗  ∗ operations each cnvalue cxa  acr advantage acrm fact reinitialize lastc stacked value  record recent supports exploit variants ⊥ new recomputed value obtain  ing multidirectionality greater probability μed   residue valid finally note possible                                                             means solution  extend ac framework r´egin  order include μ  concept residues                              backtracking case need restore                                                        structure instance solved opposite                                                        know longest branch built contains    maintaining arc consistency                        nd edges follows each variable exactly  section focus maintaining arc consistency dur −  edges correspond refutations edge  ing search precisely study impact terms corresponds assignment obtain worst  time space embedding ac algorithms mac case cumulated time complexities reinitializing struc                                                        ture oend omitted  mac algorithm aims solving csp instance                     forms depthﬁrst search backtracking maintain show Ωend   ing arc consistency each step search variable nice feature acrm em  assignment performed followed ﬁltering process bedded mac initialization necessary each step  corresponds enforcing arcconsistency mac based principle algorithm record  binary branching scheme means each step support does systematically correspond  search pair xa selected unassigned smallest fact reported lecoutre et al   variable value domx cases consid worthwhile leave unchanged supports  ered ﬁrst corresponds assignment  using ac backtracking having beneﬁt  second refutation               called memorization effect means support    hand important remark known given depth search opportunity valid  ac algorithms including acrm incremental arc weaker depth search backtracking  consistency algorithm incremental worstcase time words worthwhile exploit residues during search  complexity applied time importance limiting mac overhead maintain  given network andwhenitisapplieduptond times   ing data structures employed embedded ac al  consecutive executions value gorithm pointed likitvivatanavong et al   deleted exploiting incrementality complexity result given fact macr corre  complexity terms constraint checks sponds algorithm macresidue introduced likit  branch search tree establishment ac vivatanavong et al     ac acrm non optimal worstcase time  taking account proposition  table  ob                                                        tain results given table  appears  complexity branch search tree guaranteed                       incrementality subtrees longest branch μd mac macrm  explored backtracking occurred better worstcase time complexity mac algo  optimal algorithms ac ac important rithms based optimal ac algorithms know                                                        branch incrementality mac macrm  manage data structure denoted order restart    search exploring subtree backtracking oed  tightness constraint  occurred paper mac mac correspond low high precisely cnvalue cxa ei                                                                                         algorithms record smallest supports ther ccxa orscxa  macrm ad  successively current branch note mits optimal worstcase time complexity oedper                                                    ijcai                                                                                  mac embedding                                        sac −  embedding                       ac   acrm   ac   ac                           ac   acrm   ac   ac     classes random instances mean results  instances academic instances                 cpu                               cpu                                                         domino                ccks                                   ccks                              cpu                               cpu                                                           domino                ccks                                   ccks                          cpu                               cpu                                                            geo                ccks                                  ccks                        cpu                               cpu                                                               qa                ccks                                  ccks                          cpu                               ccks                    realworld instances                                                                                                                cpu                        cpu                                           fapp                                          ccks                              ccks                                                                                                                                  cpu                            cpu                                                                       jsenddr                                           ccks                              ccks                                                                                                                                                                                          cpu                                                            graph                         academic instances                                                  ccks                                                                                             cpu                              cpu                            scen      ehi                                                        ccks                              ccks                              cpu                         geo                ccks                         table  cost establishing sac                 cpu                   qa                ccks                               cpu                        macrm terms constraint checks interestingly      qcp                ccks                   overall analysis remark macrm mac                                                        roughly perform number constraint checks   realworld instances                 cpu                    hand macrm require data struc    fapp                ccks            ture maintained explains quickest ap                 cpu                 jsenddr                                        proach results conﬁrm results obtained macr                ccks                              cpu                macresidue likitvivatanavong et al       scen                ccks                    behaviour similar macrm lack space results                 cpu                      graph                                          macr presented                ccks                                                                 embedded ac algorithms sac ta              table  cost running mac              ble  observe domino instances                                                        volve constraints high tightness acrm clearly shows  branch case macrm outperforms mac   superiority ac realworld instances gap  soon μd observations suggest macrm   tween acrm algorithms increases exam  competitive                           ple sac embedding acrm  times efﬁcient                                                        sac embedding ac scen  times    experiments                                        efﬁcient sac embedding ac fapp  compare different algorithms mentioned paper  performed vast experimentation run pc pen  residues non binary constraints  tium iv ghz mb linux respect ran wonder behaviour algorithm  dom academic realworld problems performances exploits residues applied non binary instances  measured terms cpu time seconds cpu important remark seeking support cnvalue  number constraint checks ccks               scratch requires iterating odr− tuples worst    start tested mac equipped domdeg case constraint arity obtain worstcase  considering  classes binary random instances situated cumulated time complexity seeking support given  phase transition search each class  ndet  cnvalue ordrforgacandordr− gac  deﬁned usually  instances generated bessiere et al  consider constraint  tightness denotes probability pair values al check ord potential calls  lowed relation interesting signiﬁ speciﬁc seeksupport function observe  sampling domain sizes densities tightnesses difference factor dr means differ  troduced table  observe results obtained ence algorithms grows linearly  mac embedding various ac algorithms expected   hand assume  best embedded algorithms ac acrm respectively denote number forbidden allowed tu  tightness low  acrm tightness ples constraint obtain generalizing  high  acrm best tight results section  complexity ocrdr−forgac  ness medium  expected random instances ocs gacrm deduce  results conﬁrmed representative se worstcase cumulated time complexity seeking support  lected academic realworld instances clearly macrm ominc rdrdr−forgacandomincsr rdrfor  outperform mac algorithms terms cpu gacrm   obtain ordr−for  mac best beaten instances gacrm   dr− say optimality                                                    ijcai                                                     
