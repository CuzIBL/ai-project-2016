                  edge partitioning externalmemory graph search                            rong zhou                                  eric hansen                   palo alto research center              dept science eng                     coyote hill road                      mississippi state university                     palo alto ca                       mississippi state ms                        rzhouparccom                           hansencsemsstateedu                        abstract                          pose technique called structured duplicate detection                                                        exploits local structure captured abstract repre      currently using exter  sentation graph graphs sufﬁcient local struc      nal memory disk storage scale     ture structured duplicate detection outperforms delayed du      graphsearch algorithms recent work shows   plicate detection generates duplicates      local structure graph leveraged   temporarily lower overhead reduced com      substantially improve efﬁciency external plexity korf schulze  show improve      memory graph search paper introduces      performance delayed duplicate detection using similar      technique called edge partitioning exploits local structure reduce delay generation du      form local structure  plicates eventual detection removal      sidered previous work new technique im     approaches exploit graph’s local structure      proves scalability structured approaches effective depend graphsearch problem      externalmemory graph search guaran    having appropriate kind local structure sufﬁcient      tees applicability approaches order effective legit      graphsearch problem show effectiveness   imately question approaches equally      externalmemory graphsearch algorithm  effective graphs effective graphs      domainindependent strips planning               paper introduce technique exploits dif                                                        ferent kind local structure exploited previous    introduction                                       work kind local structure exploited technique  breadthﬁrst search related graphsearch algorithms sense created way algorithm expands  store generated nodes memory order able detect nodes particular use novel form incremental  duplicates prevent node regeneration scalability node expansion new technique called edge partition  graphsearch algorithms dramatically increased ing localize memory references graph matter  storing nodes external memory disk storage structure – fullyconnected graph  random access disk orders magni way new technique localizes memory references com  tude slower internal memory externalmemory graph plements kind local graph structure exploited  search algorithms use duplicatedetection strategies seri previous approaches allows new technique  alize disk access way minimizes disk io   combined previouslydeveloped approaches order    widelyused approach externalmemory graph search create powerful externalmemory graphsearch algo  delayed duplicate detection stern dill  korf rithm paper focus use edge partition   edelkamp et al  original simplest ing improve performance structured duplicate detec  form delayed duplicate detection expands set nodes tion implement externalmemory graphsearch al  nodes search frontier checking du gorithm domainindependent strips planning uses  plicates stores generated nodes including duplicates structured duplicate detection show greatly im  disk ﬁle eventually removes duplicates sort proves scalability close paper discuss  ing ﬁle keeping use theoretical edge partitioning used exploit local structure  scientists analyzing complexity externalmemory delayed duplicate detection  graph search munagala ranade  delayed dupli  cate detection makes assumptions structure  structured duplicate detection  search graph undirected unweighted structured duplicate detection sdd zhou hansen    recent work shows performance external  approach externalmemory graph search  memory graph search signiﬁcantly improved ex leverages local structure graph partition stored nodes  ploiting structure graph order localize mem internal memory disk way dupli  ory references zhou hansen   pro cate detection performed immediately during node ex                                                    ijcai                                                    pansion duplicates generated    local structure leveraged approach  revealed statespace projection function  toone mapping original state space abstract  state space each abstract state corresponds set  states original state space state mapped  abstract state ytheny called image xoneway  create statespace projection function ignoring  value state variables example ignore  positions tiles puzzle consider figure  panel shows possible positions blank  position “blank” abstract state space puzzle panel shows abstract statespace graph  abstract states corresponding each possible created statespace projection function considers  position blank                                position “blank”    given statespace graph statespace projection func  tion abstract statespace graph constructed follows  edge partitioning  set nodes abstract graph called abstract  nodes corresponds set abstract states abstract kind local structure exploited sdd cap  node y successor abstract node tured abstract statespace graph maximum  exist states x original state space outdegree abstract node small relative   x successor xandx map y tal number abstract nodes largest outdegree  respectively statespace projection function abstract node reﬂects largest duplicatedetection scope    figure shows abstract statespace graph created turn determines internalmemory require  simple statespace projection function maps state ments search algorithm experiments  abstract state based position blank mains suggest form local structure present                                                        search problems zhou hansen    each abstract node bi figure corresponds set                                                               states blank located position figure  present varying degrees                                                        guarantee present search problem    structured duplicate detection stored nodes origi                                                    degree present affect degree  nal search graph divided “ blocks” each block scalability possible  corresponding set nodes maps ab motivates development technique makes  stract node given partition stored nodes structured sdd effective regardless degree  duplicate detection uses concept duplicatedetection kind local structure present fact new technique  scope localize memory references duplicate detection                                                      introduce effective abstract statespace graph  duplicatedetection scope node original fullyconnected captures local structure  search graph deﬁned stored nodes equivalently idea technique local structure ex  nblocks map successors abstract node                                                    ploited sdd created sense expanding    image node projection function nodes incrementally means generating  puzzle example duplicatedetection scope successors node time generating  nodes map abstract node consists nodes map                                                    successors later incremental node expansion makes pos  abstract node  map abstract node  sible partition original duplicatedetection scope    concept duplicatedetection scope allows search smaller duplicatedetection scopes signiﬁcantly  algorithm check duplicates fraction stored reduce internal memory requirements algorithm  nodes guarantee duplicates original form sdd duplicatedetection scope  externalmemory graph search algorithm use ram node expanded deﬁned stored nodes  store nblocks current duplicatedetection scope map abstract node successor abstract  use disk store nblocks ram node image node expanded    sdd designed used search algorithm largest duplicatedetection scope reﬂects largest num  expands set nodes time breadthﬁrst search ber successors node abstract graph  order nodes set expanded assumes successors generated time  adjusted minimize disk io sdd’s strategy minimiz nodes expanded incrementally possible subdi  ing disk io order node expansions changes vide duplicateduplicate scope smaller scopes  duplicatedetection scope occur infrequently possible each pair abstract node successor abstract node  occur involve change nblocks equivalently each outgoing abstract edge  possible ram  nblocks outside cur key idea edge partitioning considers set  rent duplicatedetection scope ﬂushed disk writing nodes map particular abstract node par  leastrecently used nblocks disk way select ticular outgoing abstract edge applies opera  nblocks write disk expanding nodes tors correspond abstract edge order generate  different nblock nblocks duplicatedetection scope successor nodes correspond successor ab  thatarestoredondiskareswappedintoram                 stract node edge result edge partitioning                                                    ijcai                                                    duplicatedetection scope consists single nblock each successor abstract graph operator  corresponding single abstract node successor group oyy subset oy consists opera  abstract edge later point algorithm differ tors associated abstract edge yy note                                                                                    ent outgoing abstract edge considered different set oyy ∩oyy  ∅   operators applied set nodes order             generate additional successor nodes potential duplicates                    oyy  oy  different nblock eventually operators applied     y∈successorsy  set nodes fully expanded note  expansion node requires sequence incremental successorsy set successors ab  expansions                                           stract graph                                                          technique operator grouping presented    operator grouping                                context searching implicitlyrepresented graphs  statespace projection function abstract state space graphs represented start state set oper  graph used sdd edge partitioning ators generating successors clear  sdd original form nodes expanded incre technique applies little modiﬁcation searching  mentally abstract edge considered time explicitlyrepresented graphs graphs represented set  important identify operators associated vertices set edges  each abstract edge order know successors  edgepartitioned duplicatedetection scope  generate refer annotation edges  abstract graph operator grouping point idea edge partitioning sdd subdivide  “operator” refers instantiated grounded opera duplicatedetection scope smaller scopes each  tor example puzzle total  grounded abstract edge use operator group associ  operators left right ated abstract edge generate successors time  operators prior instantiation               leads concept duplicatedetection scope    operator grouping built state abstraction let abstract edge deﬁned follows     set instantiated operators search problem deﬁnition  duplicatedetection scope abstract            ∈o                               operator     applicable abstract node edge set stored nodes map destination                         exists state original state space abstract edge  applicable xandbx maps consider  puzzle ×operators applica duplicatedetection scope abstract edge guar  ble abstract node blank located anteed contain nodes map single abstract  topleft corner puzzle board right node regardless structure abstract graph  → bordownb   → each  differ following theorem follows deﬁnition  ent instantiations depending tile puz theorem  duplicatedetection scope abstract  zle moved blank position similarly each edge contains stored duplicates successors gener  abstract nodes bbandb  applicable operators                                 ×       ated applying corresponding operator group set  abstract nodes        each              nodes map source abstract edge  applicable operators abstract node  ×   applicable operators                                   theorem  guarantees edge partitioning needs    set applicable operators each abstract node store single nblock ram order catch du                                                        plicates generated worst case  determined operator grouping identiﬁes each applica                                            ble operator abstract edge associated ab works following way each abstract edge yy   stract edge yy edge abstract graph edge partitioning uses operators ∈oyy generate suc  nects pair abstract nodes y y cessors nodes map abstract node edge par  successor refer yasthesource destination titioning expanded nodes using operator group  abstract edge yy                              uses different operator group oyy generate succes                                                                          let oy set operators applicable abstract node sors block operator groups                                                                                        operator ∈oy associated abstract edge used generating successors block chooses  yy exists states x different nblock expand  original state space  applicable xx successors generated edge partition  resulting state applying xandx x map ing node expanded node expansion  y respectively operators deterministic edge partitioning incremental expansion nodes eventu  effects easy ∈oy unique ally fully expanded operators applied  abstract edge yy associated essentially  manytoone mapping operator space  example  abstractedge space                              use following example illustrate edge parti    exploit local structure operator space edge parti tioning works sdd let xi search node represents  tioning uses operator grouping divide set applicable state puzzle blank located position  operators oy abstract node operator groups shown figure suppose stored                                                    ijcai                                                    nodes ab map abstract node shown fig nodes disk switching duplicatedetection  ure let aa bb successors scope consists nodes stored disk implemen  respectively subscript encodes position tation does read nodes disk immediately  blank edge partitioning expands nodes stead waits ﬁrst time node generated    ﬁrst uses operators ∈obb  corresponds reason single operator group used  moving blank right generate ﬁrst suc generate successors nodes nblock gener  cessor nodes note nodes map ate successor node nodes operators  abstract node need stored ram group applicable generated  generated edge partitioning uses operators generated successor nodes fcost greater    ∈obb  correspond moving blank upper bound used branchandbound search lazy ap  generate fourth successor nodes proach avoids overhead reading nodes disk  time nodes map abstract node need order setup duplicatedetection scope ram  stored ram                                     successors generated operator group nblock                                                          previously discussed sdd needs decide    implementation                                     nblocks ram  disk ram                                                                       discussing strategies implementing sdd blocks make current duplicate                                                                            edge partitioning efﬁcient way review key detection scope blocks potentially ﬂushed                                                                                steps implementing sdd                            disk means block does include    search begins sdd uses statestate pro duplicatedetection scope ﬂushed  jection function create abstract graph hopefully disk nodes expanded  captures local structure original search graph allowed implementation avoided  statespace projection function partitions stored nodes possible efﬁciency reasons make simple mod                                                      iﬁcations leastrecently used algorithm ensure   blocks each node abstract graph                                     moved ram disk each nblock instead updating time stamp block                                                        time accessed time stamp updated  able ﬁt ram statespace projection function                                           handcrafted automatically generated described current duplicatedetection scope changes block  zhou hansen                          expanded new scope    like delayed duplicate detection sdd designed simpliﬁes maintenance clock needs  used search algorithm expands set nodes updates duplicatedetection scope changes  time frontier nodes breadthﬁrst search second modiﬁcation instead moving forward  idea sdd expand nodes order clock clock tick duplicatedetection scope                                                        changes algorithm advances clock ticks  minimizes disk io accomplished expanding nodes                             duplicatedetection scope consecutively time stamp tobeexpanded block set                                                        clock tick earlier new clock time finally time  minimizing changes duplicatedetection scope during ex            pansion nodes simple effective heuristic ex stamps blocks new duplicatedetection                                                    scope updated new clock time result  pand nodes order block blocks ordered accord  ing breadthﬁrst traversal abstract graph block expanded does belong new  ram  sdd needs decide nblocks duplicatedetection scope ﬂushed disk                                                        time stamp recent ﬂushable  ram  disk simple effective heuristic                               write leastrecently used nblocks disk         block earlier nonﬂushable block                                                        time stamp equal current clock time    sdd edge partitioning uses similar strategy try  ing minimize changes duplicatedetection scope during finally recall edge partitioning expands nodes  expansion set nodes difference consid single nblock multiple times each operator group  ers duplicatedetection scope abstract edge affects strategy remove nodes stored  requires incremental node expansion simple effective disk currentlyexpanding nblock sim  heuristic apply operators nodes order nblock plest strategy remove nodes disk soon  each nblock order outgoing abstract edge swapped ram incur extra overhead    consider ways improve performance nodes written disk shortly  reduce overhead operator grouping implementa der make room newlygenerated nodes note nodes  tion uses lazy approach operator grouping currentlyexpanding nblock change long  abstract node computed immediately ﬁrst operator group used generate successors  time node maps expanded sociated abstract edge source destination  number abstract nodes nodes “self loop” self loops easy  map during search approach avoids detect implementation postpones removal nodes  head operator grouping abstract nodes stored disk currentlyexpanding nblock “self  observed effectiveness approach tends loop” operator group opera  crease size abstract graph           tor group applied nblock implementation used    implementation uses lazy approach reading expand nblock                                                    ijcai                                                                                     sdd                                    sdd  edge partitioning   problem         ram           disk          exp     secs       ram           disk     increm exp   secs   depots                                    blocks                                  trucks                                storage                         freecell                    elevator                      gripper                 logistics                    driverlog           satellite                   trucks                                                       depots                                                    table  comparison structured duplicate detection sdd using edge partitioning strips planning  problems columns show peak number nodes stored ram ram peak number nodes stored disk disk number  node expansions exp number incremental node expansions increm exp running time cpu seconds secs  ‘’ symbol indicates algorithm solve problem  gb ram      computational results                              memory saved using sdd edge partitioning instead                                                        number node expansions sdd gives  implemented sdd edge partitioning domain estimate nodes need store order  independent strips planner uses underlying solve problem store node ex                                             search algorithm breadthﬁrst heuristic search zhou pands breadthﬁrst heuristic search optimal                hansen  reason using breadthﬁrst heuristic bound expands roughly number nodes  search uses internal memory efﬁciently build disregarding ties based number node expan  ing sdd edge partitioning improves sions shown table  need average  efﬁciency search limiting need access disk   times internal memory solve problems    search algorithm uses regression planning ﬁnd op breadthﬁrst heuristic search sdd edge parti  timal sequential plans admissible heuristic uses tioning  estimate ignores memory needed  maxpair heuristic haslum geffner wetested store open list usually larger  externalmemory strips planner different closed list actually considerable underestimate  mains biennial planning competition including  domains trucks storage recent competi results show sdd edge partitioning al  tion experiments performed amd operton  ready effective solving strips planning prob  ghz processor  gb ram  mb cache  lems indicates search problems contain    table  compares performance sdd great deal kind local structure sdd exploits  edge partitioning problems largest means problems actually present  each planning domains sdd edge par challenge edge partitioning identify addi  titioning solve using  gb tional structure exploited reduce internal mem  ram taking  cpu days running time ory requirements search problems  problems trucks depots solved sdd edge partitioning effective sdd  limits using edge partitioning edge partitioning likely reduce internal memory require  mains table includes largest instances ments larger ratio  solved edge partitioning versions sdd use edge partitioning effective abstract  statespace projection function             graph used sdd does capture local structure    table  shows couple interesting things shows wonder local structure useful anymore  edge partitioning reduce internalmemory longer needed reduce internal memory  quirements sdd average factor  times quirements useful reducing time complexity  planning problems doing increases peak problem solved sdd edge parti  number nodes stored disk  second tioning time overhead incremental node expansion  shows overhead results using incremen avoided edge partitioning used local  tal approach expanding nodes inexpensive al structure fewer successor nodes abstract node  average  times incremental abstract graph fewer incremental expansions  expansions edge partitioning used needed node fully expanded overhead  expansions increases running time incremental node expansion reduced results table    average note extra time taken edge show edge partitioning reduces internal  partitioning includes time operator grouping     memory needed exchange increase average run    indirectly table shows roughly internal ning time actual increase fairly modest                                                    ijcai                                                    
