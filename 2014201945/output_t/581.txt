           abstract interpretation programs modelbased debugging                                   wolfgang mayer        markus stumptner                                   advanced computing research centre                                        university south australia                                        mayermstcsunisaeduau                                                                                 language                      abstract                                               semantics      testcases      developing modelbased  automatic debugging      strategies active research area sev                                                          program      eral years present modelbased debug                                  conformance test                                                                       components      ging approach based abstract interpre                                            fault                                                                                        conﬂict sets      tation technique borrowed program analy                                             assumptions      sis abstract interpretation mechanism inte      grated classical modelbased reasoning en                             mbsd engine      gine test approach sample programs      provide ﬁrst experimental comparison      earlier models used debugging results                                     diagnoses      show abstract interpretation based model      provides precise explanations previous                                                                        figure  mbsd cycle      models standard nonmodel based approaches                                                           modelbased debugging    introduction                                       modelbased software debugging mbsd application                                                        modelbased diagnosis mbd  techniques locat  developing tools support software engineer locating ing errors programs mbsd ﬁrst intro  bugs programs active research area during duced console et al  goal identifying  decades increasingly complex programs require incorrect clauses logic programs approach  effort understand maintain dif extended different programming languages includ  ferent approaches developed using syntactic ing vhdl  java   semantic properties programs languages          basic principle mbd compare modelade    paper extends past research modelbased diagnosis scription correct behaviour observed  mainstream object oriented languages java behaviour traditional mbd systems receive  crete example  show abstract program anal description observed behaviour through direct mea  ysis techniques used improve accuracy results surements model supplied system’s  level capabilities past modelling ap signer difference behaviour anticipated  proaches particular discuss adaptive model reﬁne model actual observed behaviour used iden  ment model reﬁnement process targets loops partic tify components assumed deviate  ular identiﬁed main culprits mal behaviour explain observed behaviour  imprecise diagnostic results exploit information ob key idea adapting mbd debugging ex  tained abstract program analysis generate reﬁned change roles model actual  model allows detailed reasoning conﬂict model reﬂects behaviour incorrect program  detection                                            test cases specify correct result differences    section  provides introduction modelbased diag values computed program anticipated  nosis application automatic debugging section  sults used compute model elements assumed  outlines adaption program analysis module behave differently explain observed misbehaviour  debugger discusses differences clas program’s instructions partitioned set model com  sical analysis frameworks section  contains results obtained ponents form building blocks explanations each  series experiments compares outcome component corresponds fragment program’s source  techniques discussion related future text diagnoses expressed terms original  work concludes paper                             program indicate potential fault programmer                                                    ijcai                                                     figure                                                            →     each component operate normal mode denoted             int   ¬ab  · component functions speciﬁed       int   program abnormal modes denoted ab ·       ≤   different behaviour intuitively each component mode           “ correct  ∗ ”  corresponds particular modiﬁcation program                                                                                  example  program  figure  partitioned  ﬁve components cc each representing sin             assert    gle statement components representing assignments  possible ab mode leave variable’s value undeter figure  example program test speciﬁcation  mined possibility expand assignment  set variables rendering values undetermined                                                                                    loops number iterations altered     example   assume component   representing line                                                         program figure  abnormal case ex    model components formal description seman ecution terminates state satisfying   tics programming language set test cases fore fault line  explain program’s misbe  submitted conformance testing module determine haviour contrast value left undetermined  program reﬂecting fault assumptions consistent line  execution exists program satisﬁes  test cases program consistent test assertion potential explanation  case speciﬁcation program possibly satisﬁes behaviour  speciﬁed test case                              deﬁnition explanation intuitive pre    case program does compute anticipated cise test undecidable approximated differ  sult mbsd engine computes possible explanations ent abstractions proposed literature ranging  terms mode assignments components invokes purely dependencybased representations  pred  conformance testing module determine explanation icate abstraction  following section introduces  valid process iterates possible approximation based abstract interpretation  tech  explanations                         nique borrowed program analysis    formally mbsd framework based reiter’s  ory diagnosis  extended handle multiple fault modes  model construction  component mbsd relies test case speciﬁcations models developed vhdl early models java  determine set fault represents valid explanation based static analysis represented program  each test case describes anticipated result ﬁxed model representing program’s structure test  execution using speciﬁc input values                 cases taken account necessary repre  deﬁnition  debugging problem debugging problem   sent possible executions fault assumptions  triple p c source text pro approach used successfully debug vhdl pro  gram consideration set test cases grams dynamic method lookup exception handling  denotes set components derived         lead large models java programs                                                          mayer stumptner  propose approach                                      set  partition statements contains model constructed dynamically taking account  building blocks explanations returned debugger executions feasible given test case ap  simplicity presentation assumed proach based abstract interpretation  programs  separate component each program statement        generalised fault assumptions test case informa       set      fault  assumptions   Δ        ˆ   tion account following basic principles  ab ab ck valid explanation  introduced detailed presentations given   model modiﬁed components  ci  exhibit     deviating behaviour remaining components exhibit  normal behaviour longer implies incorrect behaviour  abstract interpretation  deﬁnition  explanation fault assumption Δ model derived graph representing effects  sistent explanation debugging problem p c iff individual statements program  alltestcasest ∈ derived executions                   Δ                                deﬁnition  program graph program graph pro   altered reﬂect  violate                     gram tuple vssω e ﬁnite set         ∀t ˆ io∈t    ⊕ Δ ⊕   ⊥      vertices ⊆ × set directed edges s ∈                                                        sω ∈ denote distinct entry exit vertices  represent input values assertions describing vertices program graph represent sets program  correct output values speciﬁed test speciﬁcation states edges represent effects program instructions  spectively  · denotes semantic function program transforming sets program states new sets states  ming language fault assumptions ⊕ denotes ap initial vertex  associated initial program state  plication fault assumptions Δ test assertions described test speciﬁcation execution pro     ⊥     denotes infeasible program state           gram starts initial state s proceeds following                                                    ijcai                                                                                                                                                   ˆ    ˆ                      proximation  computed program guar     s  →             s                                                    ˆ                                                        anteed terminate state γsω work apply                ˆ          ˆ                              s          variant bourdoncle’s bidirectional method                                   ˆ           ˆ    ˆ         ward backward analyses applied repeatedly reﬁne                       approximations                     ˆ             ˆ   ˆ                             ∇ ≤  example  using backward analysis derived      ∇  ≤                                                       program figure  terminate sω  →                           ˆ              ˆ                                       ≤                                                                                     hold  assuming left             ˆ             ˆ            undetermined                                                              ˆ          ˆ                 dynamic model creation                                                                       utilise abstract interpretation debugging deﬁnition                         sˆ     sˆ                              ω                         lifted abstract domain replacing  ·                                                                                                                                           abstract counterparts  · iˆ respectively                                                        translation necessary assumed rep     figure  program graph abstract equation resented assertions programming language                                                                                                                                evaluated using  ·   edges ﬁnal vertex ω reached program framework apply wellknown nonrelational  states sω represent result computed program interval abstraction  approximate concrete program  example  figure  depicts program graph derived states use simple abstraction described   program figure  Δ  ∅ each program state ensure dynamically allocated data structures repre  ment represented edge connecting program state sented ﬁnitely  statement executed successor state contrast purely static program analysis  loop statement line  induces possible successors assume ﬁxed program graph modelling possible execu                                                        tions instead graph constructed dynamically using  transition representing case loop entered       transition representing loop termination starting puts assertions test case speciﬁcations                   →                                 paths executed starting state  initial state     ﬂow graph induces trace                        ⊥  traverses loop times stops sω created paths contain ignored program   →                                               state reached multiple paths followed                                                        apply conventional equationbased analysis remain  case initial state fully speciﬁed parts ing execution framework placed mid  intermediate state undetermined fault assump dle grounds purely static analysis  dynamic  tions potentially inﬁnite number paths followed analysis                         determine states ω                           algorithm determining consistency program    ensure analysis graph ﬁnite concrete fault assumptions Δ test case outlined  program states concrete semantics program follows  replaced abstract versions formally abstract                                                                                         Δ     interpretation framework  uses complete lattices repre  add assertions apply   sent concrete abstract states sˆ sˆ ⊥    construct initial program graph using forward                                                                                 safe abstraction p  ∅ ⊆ ∪ ∩ ⊥ abstract semantics  · initial state iˆ  notes infeasibility  represents possible states  rep  resents abstract state ordering   denote  apply backward analysis approximate initial pro  upper bound greatest lower bound operator respec gram states implying assertion violations later  tively                                                   execution    key component framework pair functions  analyse program graph forward direction using  α γ “galois connection” α maps sets concrete new initial program states eliminate values  program states abstract representation γ imple realised  ments reverse mapping semantic functions operating  repeat step  ﬁxpoint reached                                       · ˆ α◦ · ◦γ  abstract domain deﬁned            case initial program state ⊥ execution  approximation program execution obtained satisfying test case speciﬁcations  translating program graph set equations Δ valid explanation Δ consistent  computing ﬁxpoint solution case abstract lattice test case considered  inﬁnite height program graph cyclic widening  operators ∇ applied ensure termination widen beneﬁts dynamic approach follows  ing operators selectively discard information ab equation concise signiﬁcant  stract states guarantee computation mutually advantage dealing paths representing excep  dependent equations eventually converges                  tions java runtime exceptions thrown    similar equations systems ﬁxpoint solutions large number statements typically                                            ˆ  rived backward analyses given sω ap paths actually followed execution                                                    ijcai                                                      ii ambiguity control ﬂow reduced compared sω   →  → ∞ backward analysis reveals      purely static approach important advan  →  hold loop state      tage precision abstraction dynamic data ﬂicts program state loop contains      structures deteriorates dramatically pres  →  subsequently loop expanded attempt      ence loops program graph               prove Δ does represent true fault pro                                                        cess repeats stops expansions leading state  iii simple nonrelational abstractions sufﬁcient ob   → ∞x → ∞      tain good results values related variables                 point proved                                                        assertion violated sω  ⊥ subsequent      known expressions partially evaluated leading              ⊥              Δ      tighter bounds remaining variables    ward pass derives     eliminates set                                                        potential explanations  iv case values potentially accessed called      method known program state method  fault assumptionsstructural ﬂaws                     ab      does include   components ﬁxpoint compu similar modelbased hardware diagnosis  previous      tation replaced native execution     mbsd approaches great difﬁculty faults mani    ﬁxpoint analysis limited regions execu fest structural differences model dynamic mod  tion values abstract states critical region’s elling approach described ﬂexible fault  execution undetermined fault assumptions af assumptions modifying variables originally af  fect minor program state execution pro fected component’s behaviour addressed  ceed normally unaffected regions consequently al appropriately modelling dynamically allocated data  ternative branches considered purely static structures beneﬁts particular scope fault assump  abstract interpretation eliminated            tions determined precisely compared  example  assume  mbsd    examines Δ        crude modelling previous mbsd approaches led                                                        large fraction undesirable explanations  ab running example case execu  tion proceeds normally line  reached execution expressive speciﬁcations correct behaviour                                                         believe extended fault modes deal effectively  ab leads state  →  unde  termined known execution statement  complex faults  proceed normally ambiguity control ﬂow arises  line  fact entire trace reduces linear chain  evaluation  backward analysis derives value hold af section presents experimental results obtained  ter statement  executed remaining occurrences model described previous sections compares  undetermined values initial state results mbsd approaches results ob  graph ⊥ Δ consistent considered valid ex tained slicing  readers interested theoretical  planation                                            comparison different models referred     iterative reﬁnement                                slicing  partially determined abstract states facilitate iter classic principle program slicing  eliminate  ative model reﬁnement abstraction effects loops statements program inﬂuence value  recursive method calls improved known distinguished variable given location program  states loop method contain conﬂict pair v ariable location denotes slicing criterion  ing values case execution inconsistent working hypothesis typically small fraction  loop method expanded case program contributes variable’s value rest  loop shown terminate example pruned away reduce debugging effort  through syntaxbased methods presented  limit static backward slicing starts variable location  number iterations recursive calls set mentioned slicing criterion recursively collects  user loop expanded result values statements inﬂuence variable’s value pro  lost through widening heap abstraction regained gram execution statements cause  potentially leading contradiction similar im location skipped included process repeats  provements achieved through informed restructuring ﬁxpoint reached static slices com  model based automatically derived userspeciﬁed puted quickly large programs remaining pro  properties program regions space reasons illus gram remains large  trate reﬁnement approach context running dynamic slicing aims reducing number statements  example rely  detailed discussion considering dependencies arise state  example  assume mbsd engine examines candi  ments executed particular test case execution similar  date explanation Δ  ab loop condition static slicing dependencies variable followed  assumed incorrect loop condition evaluated statements contributing variable’s value collected  uniquely implies number loop iterations dynamic slices typically smaller  known program state loop approx static counterparts programs control depen  imated using intervals   → ∞i  → ∞the dencies long dataﬂow chains results remain similar  upper bound intervals widening opera example  static slice program figure  wrt  tor assertion satisﬁed leading slicing criterion i  includes statements                                                       ijcai                                                     remaining statements ignored relevant niﬁcant differences detected test pro  computation test case dynamic slicing com grams exception adder using  putes result difference ap test cases attributed structure  proaches seen case loop executed selected programs large fraction statements  static slice x  contains statements test cases executed test cases  dynamic slice does include statement              seen static slicing dynamic slicing                                                        cases improve compared entire pro    dependencybased mbsd                            gram statements executed test cases similarly dy  number dependencybased mbsd approaches namic slices improve little compared executed  introduced wotawa shown ap statements statements contribute ﬁnal result  proaches provide results equivalent static dynamic slic comparing vbm aim seen aim im  ing case single abnormal variable observed proves vbm cases fact case  following limit attention results obtained through vbm provides fewer explanations explanations  slicing explicitly stating results hold missed vbm comparing aim slicing aim  dependencybased mbsd                                provides signiﬁcantly fewer explanations computation                                                        ally demanding slicing approaches typically compute    valuebased mbsd                                 solutions milliseconds note vbm aim                                                        currently optimised speed rely java inter                              valuebased models vbm  extend simple  preter written visualworks smalltalk  pendency tracking model effects program state  ments explicitly contrast abstract interpretation  related work  based approach discussed vbm does abstract  concrete semantics relies statically delta debugging  aims isolating root cause pro  structed models model effective programs gram failure minimising differences run  dependencybased representations provide ac exhibits fault similar does differences  curate results poor abstraction causes model col program states point executions  lapse loop iterations recursive method calls systematically explored minimised resulting sin  determined precisely                              gle “root cause” explaining program fails                                                          model checking recently applied locate    experimental results                             faults   comparing abstract execution traces leading                                                        correct erroneous program states likely causes  set test programs used evaluate perfor                                                        misbehaviour identiﬁed focussing traces  mance different debugging approaches programs                                                        deviate slightly passing failing test cases  taken siemens test suite  transcribed java                                                          error traces applied synthesise poten  debugging test bench commonly used debugging                                                        tial corrections faulty programs given speciﬁcation  community retained earlier tests                                                        program’s correct behaviour  symbolic evaluation  vbm dependencybased models                                                        used compare symbolic representations program states    summary results obtained given figure                                                         computed program versus states necessary satisfy  loc denotes number noncomment lines pro                                                        post condition program differences pred  gram’s source code comp represents number diagno                                                        icates allow heuristically synthesise replacement expres  sis components used construct explanations sslice dslice                                                        sions correcting single faults program approach  exec denote number statements static slice                                                        able provide corrections automatically formal  dynamic slice number executed statements respec                                                        speciﬁcation given required mbsd  tively vbm aim denote number statements  turned potential explanations vbm model  described paper time average diagnosis time conclusion  seconds wallclock time required aim results introduced basic principle modelbased software  aim vbm limited single fault explana debugging illustrated model centred abstract  tions limitations implementation vbm simulation programs differences previous approaches  diagnoses listed aim included outlined results obtained using different debugging  vbm’s results initial experiments multiple faults indi strategies compared notable improvements  cated number explanations does differ signiﬁ approaches achieved particular “difﬁcult”  cantly static slicing does warrant additional programs traditional debugging techniques  overhead necessary aim vbm               form    each program variants different faults cre abstract interpretation based model shown  ated tested test cases variant achieve considerable improvement compared slicing  test results reported averages each program previous modelbased debugging approaches reduc  variants test cases slight improvements ob tion average number explanations   served using single test case sig static slicing roughly  conversely model com                                                        putationally demanding require optimisation    httpwwwstaticccgatecheduaristotle         applicable midsized large programs interactive  toolssubjects                                       setting                                                    ijcai                                                     
