                          planning temporally extended goals                                    propositional satisﬁability                      robert mattmuller¨                             jussi rintanen                  albertludwigsuniversit¨at                  national ict australia                     institut f¨ur informatik                australian national university                      freiburg germany                            canberra australia             mattmuelinformatikunifreiburgde              jussirintanennictacomau                        abstract                           metric interval temporal logic mitl lin                                                        ear temporal logic ltl tlplan bacchus kabanza      planning temporally extended goals tegs       recently planning domain deﬁnition lan      expressed formulae lineartime temporal     guage pddl extended express state trajectory      logic ltl proper generalization classi constraints gerevini long  talplanner      cal planning allowing specify prop  tlplan forwardchaining planners pruning search      erties goal state plan exe space progressing temporal formula approaches      cution additionally ltl formulae used    include compiling tasks including ltl goals classical      represent domainspeciﬁc control knowledge  tasks cresswell coddington  baier mcilraith      speed planning paper extend sat    solving using classical planner                      ltl                    ltl      based planning  goals akin bounded          bounded modelchecking biere et al  latvala et al      modelchecking veriﬁcation partially ordered  extension planning satisﬁabil      plans signiﬁcantly increasing planning efﬁ ity approach kautz selman  viewed      ciency compared purely sequential sat plan    satbased technique planning tegs ef      ning consider relaxed notion par   ﬁciency satbased planning techniques strongly                                        ltl      tial ordering show planning goals     dependent notion partially ordered parallel plans      nexttime operator translated kautz selman  rintanen et al  extend      sat problem solved efﬁciently ing satbased ltl modelcheckingplanning approach      results extend practical applicability sat parallel plans cases critical obtain efﬁ      based planning wider class planning prob cient planning contribution paper encoding      lems addition applied solving constraints preserve semantics ltl formulae      problems bounded ltl modelchecking ef   parallel plans      ﬁciently                                           section  formal description problem                                                        solved section  present propositional encod                                                        ing use base encoding planning sat    introduction                                       isﬁability kautz selman  reproduced section  classical planning goal agent achieve  translation ltl formulae propositional logic  simply property goal state reach tegs speciﬁ latvala et al  reproduced section  section   cations stating desired properties ﬁnal state shows adaption encoding parallelism constraints  sequence states execution plan sat given rintanen et al  tasks tegs ex  isfying speciﬁcation expressing goals formulae periments described section   adequate temporal logic impose precise  constraints plans classical reachabil  planning temporally extended goals  ity goals instance possible specify mainte  nance goals property maintained indeﬁnitely propositional satisﬁability  goals stating agent react environmen  problem description  tal condition safety goals impose restriction  agent’s behavior change certain properties world notation  state trying achieve reachability goal    let set propositional variables Φ proposi    planning temporal speciﬁcations usually tional temporal formula write lita shorthand  garded extended goals means encoding domain ∪¬a  ∈ litΦ instead litvarΦ  speciﬁc search control knowledge used guide planner varΦ set variables Φiflit set lit                                                                        Φ  different formalisms used temporal ac erals write lit  lit ∩ litΦifΦ propositional  tion logics tal talplanner doherty kvarnstr¨om formula occurs positively negatively Φ iff                                                    ijcai                                                                                                                                                ∞  occurrence Φ nested odd num qi−bmodb−kk note q¯k actually  ber negation signs negative literal ¬a occurs positively path consecutive states related →anltl−x  negatively Φ iff occurs negatively positively Φa formula ϕ valid ﬁnite sequence q¯ written  literal  occurs Φ occurs positively negatively Φ q¯  ϕiffthereisak ∈b−  qb  qk                                                         ∞  write pos Φ neg Φandocc Φ respectively q¯k  ϕ                                                          make sure ∈b−   linear temporal logic                                                        qb  qk allowing idling ﬁnal state enforcing  order specify tegs choose speciﬁcation loop  language use propositional ltl emerson   nexttime operator simple planning  deﬁned semantics sufﬁciently expressive planning task tuple  a ϕ wherea  qualitative tegs                                     ﬁnite set boolean state variables ∈ initial state    set wellformed ltl−x formulae negation ﬁnite set operators ϕ ltl−x formula  mal form set propositional variables ltl−x variables operators form  p wherep  formulae short inductively deﬁned follows propositional formula precondition  ∈ ¬a ltl−x formulae ϕ ϕandϕ ﬁnite set literals unconditional effects oand  ltl−x  formulae ϕ ∧ ϕ ϕ ∨ ϕ fϕ “eventually ﬁnite set pairs  consisting propositional  ϕ” gϕ “always ϕ” ϕuϕ “ϕ ϕ” ϕrϕ formula ﬁnite set literals pairs  “ϕ releases ϕ”                                   conditional effects       ltl           ϕ                                                                                 −x formula    evaluated inﬁ  the set effects written  ♦   nite path state space formally kripke model ∪   ∈ set unconditional effects      q →l  triple set states                                                                                                       set active effects state  →⊆   ×                                               ∪    ∈                reﬂexive binary relation thetran                       single oper  sition relation  → function assigning                                                        ator sq  o∈s oq set operators  each state propositional valuation variables aa                                                     π  →                ∈       aset   operators applicable state   path  function            ∈ consistent identify operator  πn → πn ifπ path ∈ ith                                                                singleton set applicable  sufﬁx π π  → qisdeﬁnedasπ jπi    ∈                                            precondition satisﬁed active effects consistent       ∈ kb       π   · vω                    set operators possibly singleton sequential               apath         consisting ﬁnite                                             preﬁx  ππk− loop  πkπb− plans model idling state                                                   applicable simultaneous application results   repeated inﬁnitely called  loop called q                                  bloop kloop kb         state obtained making literals                                                         true leaving state variables unchanged                 ltl−x         ϕ           π    truth     formula  path  symbol                ically π  ϕ inductively deﬁned follows  write q−→q q−→q  let s¯  ssb−                                                         sequence sets operators state            π   ⇔ ∈ π                                                         sb−                                                        q−→q−→   −−−→qb deﬁned sequence           π  ¬a  ⇔ a∈ π                                                 states execq s¯qqb  called execution      π  ϕ ∧ ϕ ⇔ π  ϕ π  ϕ               s¯ finally let s¯  ssb−  sequence                                                                           ≺    ≺  ≺          π  ϕ ∨ ϕ ⇔ π  ϕ π  ϕ                sets operators ¯         b−  sequence                                                      binary relations ≺t total ordering stsay          π  fϕ ⇔∃i  ∈  π  ϕ                      ≺  ··· ≺              ∈b−                                                                       tst−forall                                                                                                              π  gϕ   ⇔∀i  ∈  π   ϕ                                                tst−                                                    state assume qt−−→qt −−→qt −−→ −−−−−→qt                                                                            ∈b−              π  ϕuϕ ⇔∃i  ∈  π  ϕ                deﬁned                                                                                                                  ¯                                                        sequence     states  execq s≺¯                      ∀j ∈  i−    π   ϕ                                                                              qqqqqqqqb−  called                                                                          s¯        π  ϕrϕ ⇔∀i  ∈  π  ϕ                linearized execution                                                         plan length  a ϕ  tuple s¯                      ∃j ∈i−    π  ϕ                                                        ssb−  st ⊆  ∈b−      given path π bloop ﬁrst states π sequence ≺¯  ≺≺b−   value contain information needed eval ≺t total ordering st ∈b−   uate ϕ π following paths deal q¯  execis¯ ≺¯  deﬁned q¯  ϕ kripke  type                                     model induced    let q¯  qqb  ﬁnite sequence states  qi → qi ∈b−   reduction satisﬁability  ∈b−   qb  qk order able planning satisﬁability kautz selman  roughly  evaluate ltl−x formula q¯ consider inﬁnite works follows given planning task  a ϕ   unraveling q¯ifqb ∈qqb−sayqb  qklet   propositional formulae Φ Φ Φ generated   ∞                  ∞                       ∞  q¯k  → qwhereq¯k  iqiifibandq¯k        exists plan length Φb satisﬁable                                                    ijcai                                                    Φb evaluated using sat solver Φb unsatis  a ϕ  planning task ∈ nthen  ﬁable evaluation proceed Φb plan pb  looptoax  ∧ beforeax ∧ uniqueax  ∧  extracted satisfying valuation Φb bmc                                                                                                                                                                                    inftyax ∧ ϕb                                                                                                   solution quality                                              b−                                                                 looptoax       lt →      ↔ ab                             s¯   s                                     a∈a  quality parallel plan        b−                         b−                                                                  measured respect parallel plan length se beforeax  ¬bef  ∧ bef ↔ bef t− ∨ lt−                       b−                                                   quential plan length  focus ﬁnding               b−                         b−  plans low parallel plan length size uniqueax  bef →¬lt  inftyax   lt                                                                                                  largest propositional formula considered given task  roughly proportional parallel length plan corre fresh auxiliary variables lt bef ∈b−   sponding satisfying valuation sat solver running intended semantics loop qb−                                                                                      times grow exponentially formula size worst qt qt respectively                                                                              case obtaining small formulae particularly important recursive translation ϕb ϕ deﬁned                                                                           tb                                                                                                                                                                                                        b−    propositional encoding                                 a                             lj ∧ aj                                                                                                                                                                                 b−                                                            ¬a           ¬at                lj ∧¬aj    base encoding                                                                                                                                                     b−                                                                   ϕ ∧ ϕ     ϕ ∧ ϕ         lj ∧ ϕ ∧ ϕ   ﬁrst base encoding p transition sys                     j                                            base                                               b−                                          a ϕ              ϕ ∨ ϕ     ϕ ∨ ϕ         lj ∧ ϕ ∨ ϕ   tem induced planning task          bound                            j                                                                                           b−            plan length ﬁrst proposed kautz selman  fϕ       ϕ ∨ fϕ             lj ∧fϕ                                                                                                 omitting reachability goal formula                                 b−                                                                     gϕ       ϕ ∧ gϕ            lj ∧gϕ                                                                                                                           b−                                                 b−                                                                    ϕuϕb   ϕb ∨ ϕb ∧    jlj ∧ϕuϕ                  pbase  ∧     rt                                                                                                                ϕ uϕ  t                                                                                                                                                                    b−              rt conjunction precondition axioms ot → ϕrϕ     ϕ ∧  ϕ ∨        lj ∧ϕrϕ                                                                                               pt effect axioms ot → et conditional effect axioms                                                                                           ∨ϕrϕb         ot ∧ ft →   dt  p ∈o   fd∈c                                                    fϕ    ϕt ∨fϕ           ⊥  and positive negative frame axioms ¬at ∧at →                                                                                gϕ   ϕt ∧gϕ               o∈oot ∧ epc aot ∧¬at →   o∈oot ∧                          epc                         ∈                    ϕ uϕ    ϕ t ∨ ϕ t ∧          ⊥      ¬a respectively  frame                       axioms epc p  deﬁned if ∈ eandas               ϕ uϕ                                                                                    ∈  ∈ dotherwise                                                                                               ϕrϕ   ϕb ∧ ϕb ∨              encoding contains propositional variables                                                                                             ϕ rϕ     state variables ∈ time points ∈b                       ot operators ∈ time points ∈                      ·t   b−                                          notice translation closely related formula             intended semantics holds                                                                            progression procedures used bacchus kabanza   time point iff true operator applied doherty kvarnstr¨om   time point iff ot true sets variables proposi                                                        following theorem states correctness com  tional formulae indexed  actually denotes pleteness propositional translation slightly different  sets formulae variables indexed correspondingly formulation proof latvala et al    following theorem states correctness propo   sitional translation proof rintanen et al         a ϕ                                                   theorem   let               planning task                                                        ∈  exists sequence sets operators  theorem   let    a ϕ  planning task s¯  ssb−  q¯  execis¯ deﬁned                                                                                      exists sequence sets operators s¯  q¯  ϕ iff formula pbase ∧ pbmc satisﬁable  ssb−  execis¯ deﬁned iff formula                                                        parallel plans  pbase satisﬁable                                                        section present main contribution    temporally extended goals                        straints guarantee meaning ltl−x formulae                                                        preserved parallel plans propositional encod  subsection reproduce reduction bounded ing constraints  ltlltl−x  modelchecking problem propositional satis theorem  tells encode requirement  ﬁability given latvala et al  adding constraint sequence s¯ execis¯  ϕbutwe  satisfying sequence states contain loop let sure s¯ fact plan                                                    ijcai                                                    sequence ≺¯ corresponding total orderings set active effects ∈b−  execis¯ ≺¯   ϕ sequence ≺¯ toyieldanadmis possibilities ruled condition  sible linearization ensure q¯  execis¯ ≺¯  bi bii deﬁnition  respectively  deﬁned q¯  ϕ order state rintanen et al  detailed proof claim  achieved need deﬁnitions ﬁrst execis¯ ≺¯  deﬁned using lemma  sufﬁ  subsequent lemma lamport       cient show execis¯ ∼ execis¯ ≺¯  kripke                 π       π      model     q →l whereq    →  form state  deﬁnition  let           ˜ ˜  ˜ ˜                                         varϕ  inﬁnite ﬁnite paths kripke model q →l  space induced  →      deﬁned                                                           ∩ var ϕ  π π˜ called stuttering equivalent π ∼ π˜         true consider sin  short inﬁnite ﬁnite sequences natural gle time point ∈b−  ﬁrst let ≺t total                                                                             ≺  ··· ≺   numbers              ordering say     tst−     jn   ≤    subsequence linearized execution execis¯ ≺¯                                 ik     ik           ik−   ˜jk                                                                               ···−→q −−t→ q−−t→ q−−t→ −−−−−tst−→ −→ ···   ˜jk         ˜jk− ﬁnite subsequence like                                            π   π   ik ik     ik−  ˜ consisting identically la                                     exec is¯  beled states called block                       corresponds subsequence execution                   ϕ      ltl               q →l                              st  lemma   let     −x formula                                ···−→qt−→qt−→ ···  kripke model  → ⊇ varϕ  π π˜ inﬁnite ﬁnite paths π ∼ π˜thenπ  ϕ note condition  deﬁnition  fact  iff π˜  ϕ                                          operator affects operator applied later ≺t makes                                                                    ≺  o  o ϕ ⊆  ϕ    following deﬁnition adapted similar sure   ♦     holds ef                                                                st             ϕ  rintanen et al  crucial rest section fects  qt relevant  effects concerning                                                                            ϕ              describes circumstances operator variable occurring  effects                                                                  applied operator lin operators tst− additional effect                                                                                          earization ≺ set operators wants ensure labeling lqt lqt   lqt                                                                 time points application st qt qt qt qt form block stuttering equiv  dering given ≺t deﬁned ﬁrst place alence execis¯ ≺¯  execis¯ corresponding  execis¯ ≺¯   ϕ                                 block execis¯ singleton qt blocks                                                        constructed analogously  deﬁnition  let  a ϕ  planning task    p o pec ∈otheno affects o iff  o                                                       step ﬁnd propositional formula encoding   literal   ∈ o♦                                                                                        condition time point operators  neg  ii occ   ∈    o    ≺  o        o ϕ  ϕ  ∅                                  affects      applied simultane    ♦                                     ously purpose deﬁne notion disabling            ϕ                                                                                     ♦ restriction ♦ie ofthesetof graph rintanen et al  planning task                                               conditional unconditional effect literals  deﬁnition  let  a ϕ  planning task  literals occurring positively negatively ϕ similarly directed graph  o wheree ⊆ ×oisadisabling      p  ϕ ∩ lit ϕ                                                                                                     graph contains edges      cases correspond different problems poten                                                                                            state reachable operators  tially arise applied linearization o simultaneously applicable  affects o  falsifying precondition o  bi af                              o                        let st set operators subgraph gt  stet   fecting set active effects  bii ∩ ×                    o   o putting risk stuttering equivalence execis¯   disabling graph                                                            induced st acyclic ordering ≺t  execis¯ ≺¯   deﬁnition gives rise condi                                                                                       st operators ≺t af  tion admissibility sequence ≺¯ total orderings                                                         fecting  fact ≺t arbitrary topological                   a ϕ                s¯                    −  lemma   let               planning task     dering stet   strongly connected components  ssb−  sequence sets operators sccs directed graph form directed acyclic graph  exec is¯  ϕ     ≺    ≺ ≺                 ¯          b−  sequence  stead ensuring acyclicity gt sufﬁcient ensure  ≺t total ordering st ∈b−                                                                                acyclicity subgraphs induced sccs  operators ∈ st affects    gi    siei        si    ∩                                                                     ≺t       ∈ b−       s¯            ≺¯                                        et  et ∩ st × st  achieved follows           aplanfor                                               let  o  disabling graph  ccm                                                                               ≺i  proof sketch show execis¯ ≺¯  deﬁned set sccs arbitrary total ordering                                                           ci     oi oi          ∈m     exec is¯ ≺  ϕ                                                  ci             say          ¯    argued rintanen et al                                                                              oi  ≺  ··· ≺ oi         ∈  er  ⊆  order show execis¯ ≺¯  deﬁned sufﬁces      ci                        show operator ∈ st disable operator  ∈ lita deﬁne formulae stating                                                                       ∈ st potentially falsifying precondition altering oioj ∈o  oi ∈ eoj ∈ rand                                                    ijcai                                                    oioj applied simultaneously intuitively operators remark  form sequence precondition  disable operators wrt                     lemma  satisﬁed follows s¯ ≺¯                                                     plan particular execis¯ ≺¯  deﬁned  chaino                                        ¯  ˘                                               ¯    execis≺¯   ϕ     oi → aj  ijoi ∈ eoj ∈ oioj−∩r  ∅    ˘                                              ¯   ∪ ai → aj  ijoioj ⊆r oioj−∩r  ∅   experiments    ˘               ¯   ∪ ai →¬oi  oi ∈                                  setting              i                                         compared cumulative sat solver running times   fresh auxiliary variables nega til ﬁrst satisﬁable formula parallel encoding  tion  deﬁnition  translates conjunction  chain                                           ϕ     described section  sequential encoding derived       formulae time points sccs literals  parallel replacing parallelism constraints  use following sets er                                                        axioms demanding operator time point   e  ∈   ∈ o♦                         evaluation formulae corresponding increasing                                                        plan lengths performed sequentially additionally   r  p ∈o  pos ex  ∈ occ                                                        compared parallel plan lengths resulting plans  similarly negation  deﬁnition  translates used types planning tasks considered              chain                    e∼r∼  conjunction    formulae sets           simple handcrafted logisticslike transportation task     ∼                         ∼                        three portables trucks each goal ﬁnd   e   ∈  ∈  r  ∈   ∈ o♦                                                        ﬁnite plan assuring portables shipped  parallelism constraints encoded formula forth locations indeﬁnitely   goal  formula                                                                                              b−                                    used ϕ    gf    atpi dij wherethe          plin             chainoi oi  e r t pi                  dij                                     ci                portables locations            ∈lita                              tasks adapted  international                                                                                                       planning competition modiﬁed qualitative prefer                                        ∼  ∼  ˜             ∧       chainoi oi  e  r  t                                   ci                 ences tasks rovers domain turning soft tem               ∈litϕ                                 poral constraints preferences hard constraints                                                        ignoring metric function changing soft hard  remark  valuation corresponding sequence                s¯   s            pb          constraints turned necessary drop  sets operators         b−  satisﬁes  lin  order tasks solvable  time points sccs ci disabling graph                       κ    o                        pb                 drawing uniformly random constraints each task           used construction lin  subgraphs retaining ones drawn constraints trans  gi    siei                   acyclic sccs form acyclic lated ltl−x explained gerevini long                               ≺      graph total ordering unlike ﬁrst task rovers tasks lacked explicit  ∈m ci ≺c cjtherearenoo ∈  ci                                                                               nesting temporal operators solvable  ∈ cj  ∈ esincegt acyclic solved plans yielding ﬁnite executions apart                    total ordering ≺t st each ∈b−  ∈ inﬁnite idling ﬁnal state reachability goals speci                                       consistent ordering ≺ used ﬁed problem deﬁnitions required hold                                           struction plin  pair ∈ ci ﬁnal state                                   ∈ ≺t  relations ≺t ∈m sat solver used siege  ryan  ≺c combined lexicographically resulting experiments run pc  ghz amd athlon  dering ≺t st follows ∈b−   cpu  mb ram linux operating                                           ∈ st affects ≺t     following theorem combines conclusions   results  theorem  lemma  remark          table  contains results logistics task modi                                                                         κ  main theorem  let   a ϕ  planning task ﬁed rovers tasks                                                     second columns show size  ∈ nifpbase ∧ pbmc ∧ plin satisﬁable  plan length                    largest scc computed disabling graph compared                                                        overall number nodes fourth column shows  proof sketch theorem  know exists parallel plan lengths bp obtained parallel encoding  sequence sets operators s¯  ssb−  compared sequential plan lengths bs column ﬁve  q¯  execis¯ deﬁned q¯  ϕ order able interval given shortest sequential plan  use lemma  need sequence ≺¯  ≺≺b−  length mbs ≤ precisely determine bs  corresponding total orderings time sat solver running times exceeding timeout                                      point ∈b−  pair ∈ st operators                                                            κ   affecting ≺t  orderings ≺t constructed  tasks remained unsolvable                                                           implicit nesting depth three tem    formally prove similar proof poral operators sometimeafter sometimebefore  rintanen et al                      atmostonce                                                    ijcai                                                    
