                       temporal planning           really   temporal         william cushing     subbarao kambhampati          mausam      daniel weld                 dept comp sci eng                 dept comp sci eng                   arizona state university                     university washington                       tempe az                              seattle wa                           abstract                          architecture appealing conceptually                                                        simple facilitates usage powerful reachability heuris      strips planners search plans                                                        tics ﬁrst developed classical planning bonet et al       unbounded length temporal planners                                                        hoffmann nebel  nguyen et al  helmert      cope fact actions start                                                         sgplan won international plan      point time temporal planners cope                                                        ning competition’s temporal planning track       challenge restricting action start times                                                         progression planner      small set decision epochs en                                                          important technical hurdle tempo      ables search carried statespace                                                        ral statespace planners need overcome each action      leverages powerful statebased reachability heuris                                                        start inﬁnite number time points      tics originally developed classical planning                                                        planners avoid inﬁnite branching factor seemingly      decisionepoch planners won interna                                                        clever idea restricting possible starttime actions      tional planning competition’s temporal planning                                                        small set special time points called decision epochs      track                                                           fortunately popularity approach belies impor      decisionepoch planners largely   tant weakness — decision epoch planners incomplete      unrecognized weakness incomplete    planning problems requiring concurrency mausam      order characterize cause incompleteness weld       identify notion required concurrency     seen juxtaposition phenomenal success      separates expressive temporal action lan   planning competitions incompleteness decision epoch      guages simple ones show decision   planners raises troubling issues      epoch planners complete languages      simpler class prove simple class  benchmarks planning competition captur      ‘equivalent’ strips surprisingly prob     ing essential aspects temporal planning      lems required concurrency included    possible make decision epoch planners complete      planning competitions conclude      retaining efﬁciency advantages      signing complete statespace temporal planning      algorithm hope able achieve    pursuit ﬁrst question focused characteriz      high performance leveraging heuristics ing makes temporal planning really temporal — dif      power decision epoch planners                    ferent classical planning fundamental way                                                        leads notion required concurrency ability                                                        language encode problems solutions    introduction                                       concurrent notion naturally divides space tem  researchers investigated variety architec poral languages require concurrency tem  tures temporal planning planspace zeno pen porally expressive temporally simple  berthy weld  vhpop younes simmons    show temporally simple languages   extended planning graph tgp smith weld  barely different classical nontemporal lan   lpg gerevini serina  reduction lin guages simple class unfortunately class  ear programming lpgp long fox  decision epoch planners complete  popular current approach progression regres pursuit second question show incom  sion search through extended state space sapa pleteness decision epoch planners fundamental anchor  kambhampati  tp haslum geffner  ing actions absolute times appears doomed leaves  talplan kvarnström et al  tlplan bacchus temporal planning enterprise unenviable position  ady  sgplan chen et al  having class planners decision epoch  search node represented worldstate augmented fast incomplete fundamental ways class  set currently executing actions starting times planners partial order ones zeno vh                                                     ijcai                                                    pop complete unacceptably slow action given beginning transition begina  tunately ﬁnd way leverage advantages ending transition enda overall condition oa  approaches temporally lifted statespace planning algo positive rational duration δa  rithm called tempo tempo  uses advantage lift                                                        deﬁnition  plans plan  ssssnis  ing representing action start times realvalued variables                     reasoning constraints partial order planners set steps each step  given action                                                        actions positive rational starting time ts  maintaining advantage logical state informa   tion allows exploitation powerful reachability makespan equals  heuristics rest paper elaborates ﬁndings δp maxtsδactions  − mints                                                                     s∈p                     s∈p      temporal action languages                            rational model time provides arbitrary precision  different modeling languages proposed real complications  planning durative actions interested deﬁnition  problems problem aig                                             relative expressiveness tgp language smith sists set actions initial model goal              weld   example requires action’s precon condition  ditions hold during execution pddl  al  lows modeling ﬂexibility study various restric deﬁnition  states temporal state given  tions pddl  characterized times model staten time tn plan agendan  preconditions effects ‘placed’ action recording actions ﬁnished  notation uses superscripts constraints pre started  conditions subscripts denote constraints effects  lpreconditions template annotations    precise formulation plan simulation long unnec   effects                                              essary paper deﬁnition pddl  fox   “atstart”                                         long   roughly steps plan    “atend”                                           ssn converted transition sequence  “overall” entire duration              classical plan simulating given applying                                                      transitions sequence starting initial model    example  language action pre                 se                                    classical state simulation fails transition sequence  condition hold execution effects                                                        executable simulation fails overall  occur start end pddl  does deﬁne allow                                                        conditions violated case executable  effects interval time used annota                                                        solution goal condition true model  tion preconditions                                                        results simulation    language features included possi  ble restrictions analyze end plans rescheduled plan rescheduling  interesting expect example deadlines differences dispatch times                                                        steps let s  delays result delaying step  exogenous events timed literals conditional effects param       tstsd              s  eters nonground structures preconditions required inter units time        action                                                        actions similarly   delayp result  mediate pointsintervals inside action effects occurring                  ds ∈   arbitrary metric points zeno compiled laying entire plan delay                 lsoe                                            tening steps plans result applying negative  se smith  fox et al  particular                                    analysis just lsoe simultaneously indirect analysis lay step slack executable plan                se                                     s∪delays −t executable plan  syntactically richer languages naturally com             pilations dramatic performance penalties carried value   step slack slackless  practice purpose compilations ease likewise plan slackless step slackless  burden analysis proof course exclude plan “leftshifted”  interesting language features sake simplic deﬁnition  completeness planner complete  ity example metric resources continuous change spect action language problems expressible                                                        planner guaranteed ﬁnd solution ex    basic deﬁnitions                                 ists planner optimal respect language  space precludes detailed speciﬁcation action semantics cost function solvable problems expressible  merely paraphrase relevant aspects planner guaranteed ﬁnd solution minimizing ca  pddl  semantics durative actions fox long planner makespan optimal optimal makespan                                                  cost function  deﬁnition  actions model total function mapping  required concurrency  ﬂuents values condition partial function mapping  ﬂuents values transition given conditions come key insights paper  preconditions effects                       cases handy execute actions concurrently                                                        example lead shorter makespan cases    pddl  denotes level  pddl fox long  concurrency essential deep level                                                     ijcai                                                                                           initially  true                                                                                                   gq                                      rg                                                                                                                                                                                                                                                                                                                                                                                          cl                 dls           ale                bls                  se                 se               ele    figure  preconditions shown actions time point enforced effects depicted action durations shown square                                                        brackets ﬁrst three problems demonstrate le lsandlse temporally expressive respectively ﬁrst  problems solution begin end solution contain end ad  modeling resources easily lead required concurrency example provides temporary access resource utilizes  achieve goal start middle happening achieve makespan optimality  deﬁnition  required concurrency let                precondition action holds entire duration  ssn plan  step ∈   iscon    preconditions actions hold immediately prior apply  current step s ∈    ing effects ﬁnal model  ts ≤  ts ≤  tsδactions      ∪delays δactions executable  ts ≤ ts ≤ tsδactions plan concurrent rescheduling  ﬁnal models simulations  step concurrent plan sequential  identical result applying actions  solvable planning problem required concurrency model induction number concur  solutions concurrent                         rent steps note  fewer concurrent steps                                                                                                make concrete consider plan figure rescheduling sequential solution  literals action denote preconditions theorem  interesting large number                                                  temporal planners tgp tp haslum geffner   low denote effects starting false assuming     ∗  actions problem achieving hsp haslum  tlplan bacchus ady   required concurrency sequential plans cpt vidal geffner  restricted  vice versa fail executable let achieve tgp representation shown simple                                                     essential temporal phenomena modeled note                                                        example common motif temporary resource  deﬁnition  temporally simple  expressive action utilization figure encoded represen                                  language istemporally expressive encode prob tations planners did extremely                                        lem required concurrency temporally three international planning competitions reality  simple                                               majority problems temporal track    temporally simple languages                      require concurrency            lo                                            note proof theorem  demonstrates signiﬁ  theorem    temporally simple tgp rep cantly stronger result theorem does  resentation                                                                                                                problem le sequential solutions                          proof prove le temporally simple show fact sequential rescheduling concurrent solu  ing concurrent solution problem tion idea applied reverse problems tempo  language rescheduled sequential solution rally simple languages optimally solved using classical    fix concurrent solution  problem aig techniques  loss generality assume step ends  say ∈  concurrent step actions effects theorem  let planning problem temporally                                                                                             end model holds simulating simple subset pddl  let correspond  identical model holds immediately apply ing strips problem durations ignored  ing effects actions simulating  action collapsed single transition                                                          lineartime computable bijection         actions execute closed intervals pddl  actions slackless solutions solutions p  overlapping endpoints executing concurrently —  stantaneous moment time                             particular appropriate heuristics optimal         tgp representation temporally simple lutions solving p instead  perfect correspondence strict subset pddl  strips temporally simple languages essentially  slightly different semantics different mutex                                                      equivalent delve details  rules le extremely close                                                     show correspondence formal manner using nebel’s    consider problems ais   asg model holds simulating just past  concurrent steps  sufﬁx sequential solution transformation performed mips lpg sgplan  problem argument gives sequential reschedul planners details edelkamp  gerevini serina  ing preﬁx solving problem      chen et al                                                      ijcai                                                    framework expressive power nebel   proof lineartime procedure mapping solutions  strips problem slackless solutions  bijection theorem omit showing  inverse lineartime computable total function slackless                                                solutions omit proof case le  basic technique pert scheduling applied  minor modiﬁcations case                                  consider solution   aaan  sociate literal fv time  achieved τfv initially  initial value   earliest dispatch time each ai                                 τai following procedure  initializing τa                                                          fv ∈ eﬀectsaiifv  argmax v τfv       set τfvτaiδai    set τai       maxτfvfv       ∈      precondai∪τaiδai   − δai    increment loop       si  actionsiai tsiτai  slackless rescheduling  preserving order ends figure  taxonomy temporal languages ex  actions starting each action precon pressiveness outlined dotted lines discussed  ditions achieved particular slackless text  solution                                              surprising different technique                                                        exploit allowing effects multiple times does    temporally expressive languages                  require preconditions                                   seen language lse express                                                        theorem   lse temporally expressive  problems required concurrency figure course                                                                                                     language pddl  temporally expressive proof theorems    prove le ls  language surprise adding atstart effects lse temporally expressive demonstrating problems    le represent required concurrency each language require concurrency figure  ing note merely shrinking time preconditions respectively                                      hold atstart language le increases ex                       pressiveness fact le particularly special temporally  temporal gap  expressive language exempliﬁes three funda figure  places languages discussion context  mental kinds dependencies allow modeling required lattice pddl sublanguages shows divide  concurrency                                          temporally expressive simple                                                                                                                        shown le approximation tgp temporally sim  theorem  le temporally expressive                                                    ple surprisingly simple syntactic criteria temporal    dual le ls odd language — preconditions gap powerful tool classifying languages temporally  follow effects nonetheless language interesting expressive temporally simple  three minimal temporally expres roughly action temporal gap sin  sive languages                                       gle time point action’s duration preconditions                                                      effects hold easy check simple  theorem  ls temporally expressive                                                        scan action’s deﬁnition language permits temporal    surprising adding atstart effects lan gap actions language potentially tempo  guage allowing atend effects allows modeling required ral gap language forbids temporal gap show  currency obvious technique exploit language temporally simple forbids  facility make precondition action available temporal gap makes intuitive sense tem  during execution action figure good poral gap duration action secondary  example                                              tribute cost action    basic idea compile scheduling planning understanding temporal expressiveness terms tem  problem                                              poral gap reminiscent “unique main subaction restric    technically  positive value tion” yang  used htn schemas make handling task  requirements pddl  temporally simple language interactions easy resemblance coincidental given  nonzero separation requirement tgp  temporal actions decompose transitions   instead                                         way htns specify expansions section                                                      ijcai                                                    deﬁnition  beforecondition precondition  decision epoch planning  required hold action’s ef introduction showed temporal planners  fects likewise aftercondition precondition tably dominating recent ipc temporal tracks use  required hold action’s effects decision epoch architecture section look    gap temporal intervals nonintersecting method exposing disconcerting weakness  meeting each interval incompleteness temporally expressive action languages  union three single interval ac sapa kambhampati  tlplan bacchus                                                                                  ∗  tion temporal gap gap precondi ady  tp hspa haslum geffner   tionseffects                      decisionepoch based planners    gap beforecondition effect  consider each isolation abstract essential el    gap aftercondition effect  ements search space deﬁning dep deﬁning                                                        attribute dep search space temporal states    gap effects                                                        central attribute temporal state world state    actions temporal gap critical point staten world state information responsible  unique time effects occur         success popularity dep enables                                                        computation statebased reachability heuristics developed  theorem  sublanguage pddl  temporally  classical nontemporal planning  simple forbids temporal gap          deﬁne  dep’s search space showing temporal                                                        states reﬁned ways generating children  proof begin showing forbidding temporal gap  necessary language temporally simple       fattening given temporal state generate child    languages permitting gap beforecondition na action ∈a intuitively na represents  effect gap aftercondition effect attempt start executing na differs                                               gap effects superlanguages le lsor adding new step stoagendana actionsa  lse respectively theorems    languages tstn  temporally expressive temporally simple lan                                                                                                   guages require action beforeconditions advancing time generate single child epoch  hold just effect asserted afterconditions simulating forward time just past transition                                                                           nd        dmin   ∈  hold just effect asserted effects agenda epoch simulate                                                                   tts   ttsδ         ≥  asserted time temporally simple lan agenda              action                                                           tn  guage forbid temporal gap                                reverse direction interesting direction deﬁnition emphasizes simplicity efﬁciency  show language forbidding temporal gap tempo rely simulate check action executability inconsistent  rally simple demonstrating slackless solutions temporal states pruned obviously practical implemen  problem rescheduled sequential solutions gen tation check soon possible  eralization proof theorem  fix slackless key property dep selection decision epochs  solution problem language forbidding temporal rule advancing time order dep branch  gap                                                  action selection given time point time ad    consider sequence critical points slackless vanced point time advances just past  lution models hold earliest transition agenda dep choose start  mcmcmn−cnmn  ci critical action action just ended just  points mi models trivial insert arbitrary gun conversely dep unable generate solutions  delay each critical point lengthening beginning action does coincide tran  period time each model holds altering sition forcing kind behavior surprisingly easy  rescheduling steps example multiplying each                                                        theorem   dep incomplete temporally expressive lan  dispatch time maximum duration action achieves                                                        guages  sequential rescheduling preserving sequence each                                                                                                     ls le  critical point ci action’s beforeconditions hold proof sufﬁces show dep incomplete                                                             mi− afterconditions hold mi se show dep incomplete temporally  original plan executable models unaltered expressive languages theorem  figure                                                                              sequential rescheduling rescheduling exe figure gives se example stumps dep—  cutable solution                        achieving goal requires starting middle abut    coming space languages al  decision epochs available interval dep  ready noted popular temporal planners tgp solve problems figure minor          ∗                                                                                             tp hsp  tlplan cpt restrict attention tempo modiﬁcations problems example altering                                                                           rally simple languages essentially equivalent delete ina forces start decision                                                                 strips section shows planners epochs  claim address temporally expressive languages theorem  dep complete temporally simple sub  actually incomplete face required concurrency languages pddl  makespan optimal                                                     ijcai                                                    
