                                       planning loops                                              hector levesque  £                                         dept science                                           university toronto                                          toronto ont ms                                           hectorcstorontoedu                        abstract                          stephan biundo  say “plan generation                                                        level interactive process nontrivial inferences      unlike case sequential conditional plan opinion shared authors      ning work iterative planning plan citations omitted carried fully automatic      ning loops needed leans heavily  way” far tell say today      theoremproving paper does following     fully automated iterative planning completely hope      proposes different approach generating faced intractable reasoning prob      plans decoupled verifying describes lem look compromises paper forego      implementation iterative planner based strong guarantees correctness provided theorem      situation calculus presents examples il proving approach consider new way generating      lustrating sorts plans generated iterative plans does trafﬁc loop invariants non      shows strengths weaknesses negative decreasing expressions items      approach ﬁnally sketches beginnings sociated proving programs correct resulting plans      theory validation plans ofﬂine come weaker guarantees plan validation                                                        need separately                                                          application mind sort highlevel    introduction                                       programming typical cognitive robotics lesp´erance  vast majority work ai planning today deals et al  expect users provide programs  sequential planning generating sequence actions tell robot highlevel considerable  achieve goal smaller community concerned nondeterminism left robot deal runtime  ditional planning plans treelike structures nondeterminism form declarative goals  smaller community concerned iterative plan achieve require planning robot  ning plans graphlike structure loops plans expected small relative overall  reason clear sequential planning admits interesting mission robot main contribution paper  applications quite difﬁcult new way generating small plans loops setting  assumption complete knowledge initial state rest section motivating exam    bulk work iterative planning based ple deﬁne class plans searching present  theoremproving biundo  survey al general approach section  discuss imple  section  exceptions perspec mentation called kplanner novel way  tive plans viewed programs planning kind generates loops section  present three examples  program synthesis manna waldinger kplanner  use section  discuss limitations  notoriously difﬁcult problem reasoning related work section  present beginnings  correctness programs loops terms partial theoretical foundation section  conclude  correctness termination requires mathematical induction  nontrivial algebra difﬁculty words  motivating example  like difﬁculty sequential planning problem wish consider chopping  size search space long plans main problem tree putting away axe sardina et al  short iterative programs quite difﬁcult reason disposal primitive actions chop hits                                                        tree axe assuming tree axe    £ research away sabbatical york available store puts axe away assuming  university toronto rwth aachen universita di roma la available observe following  sapienza university new south wales sydney simon  fraser university vancouver grateful hosts  additional information problem insolu  institutions providing wonderful environment ble way know tree  doing teaching administration sabbaticals rock away axe  told tree hit  times formal deﬁnition execution robot programs      problem solved following sequential plan situation calculus given levesque  example            chop   chop   chop   store                 plans shown earlier including tc prettyprinted versions                                                        robot programs quite limited form recur    told tree hit sion logical expressions ﬂuents variables       times problem insoluble precise sense robot programs inclu      given action lookwhichisasensing action sion ﬁve special primitive actions universal lin                       reiter  telling tree levesque  planning given goal      problem solved following ﬁnd robot program achieves      ditional plan          case look                                    planning approach             store             chop                                 going try solve planning problems like tree                   case look                         chopping unknown quantity dealt                      store                      speciﬁcally assume ﬂuents dealing                      chop    store               single distinguished                   endc                                 planning parameter following properties          endc                                           value known bounded plan time    told tree eventually  loops required achieve goal value      hit repeatedly look action known words loops required      problem solved following iterative plan deal unknown unbounded planning parameter                                                        tree chopping planning parameter number          loop            case look                                chops needed fell tree                  exit                               given application domain planning parameter                chop                              generating plan proving works                                                     values using partial correctness termi                endc                                        nation work bounds try ﬁnd          endl                                         plans loops using bounds particular assume          store                                         following          let plan tc treechop reference                                                              ¯                            Æ                                                              user provide constant ½ called generat  general case goal achievable ing boundandwegenerate plan possibly containing      iterative plan like tc necessary achieve tc number loops provably correct                                                                               Æ  general handles cases conditional assumption ½       plan sufﬁcient                                                              ¯                                       Æ                                                              user provide second larger constant ¾ called    robot programs                                       testing boundandwetest plan generated                                                            ﬁrst step provably correct assump      simple sequential plans                                                                         Æ                                                                tion     ¾  necessary specify exactly mean plan      convenient use variant robot programs guarantee plan                                                                                               Æ   levesque  purpose assume given set return correct assuming ¾ far      primitive actions sensing actions foolproof example conditional plan tree                                                                                                    Æ    ½      each having ﬁnite set possible sensing results robot chopping presented works correctly ½                                                            Æ    ¾               ¿       programs execution deﬁned following ¾   fails      suppose                                                                            Æ    ½    Æ    ½¼¼                                                                                      ¾                                                        user speciﬁed ½              small        nil robot program executed doing est conditional plan satisﬁes bounds                                                    È                                                            ¿ ¢ ½¼¼ · ½                                     Æ          primitive action  robot program                   actions generate plans using ½              È µ          seq ´    robot program executed ﬁrst perform consider smaller plans larger oneswe                                             È      ing ignoring result executing   generate desired iterative plans encounter                                                        undesired conditional ones theory section         primitive action possible sensing              Ê     Ê                          È    È                                                 ½              sults ½    robot programs              ´  ´ Ê È µ  ´ Ê È µµ                        ½                case    ½                robot program    planner          executed ﬁrst performing obtaining                                                            planning setup following                         Ê                      È                                                   sensing result continuing executing                                                                   ¯ user provides problem speciﬁcation deﬁned                  É                          È  robot programs result                                                            list primitive actions ﬂuents formulas char        replacing È occurrences nil exit                                                                acterizing initial goal states each action                                 ´ É µ      rest loop   robot program                                                            preconditions effects sensing results            executed repeatedly executing body                                                                                                    execution terminates exit ¯ user identiﬁes parameter supplies                                               É                           Æ     Æ                                                                                ¾      going executing continuation           numbers  ½         ¯                                     Æ            generate plan correct   ½     generating plans           Æ        cause  ½ small search reasonably                                                        given generating bound Æ use variant progressive          efﬁciently                       planning produce plan correctly achieves goal                                                                          Æ                                               Æ    ¯                                                   assuming      following ﬁnd plan          test plan correct ¾                                                                                          À          cause involves testing given plan achieves goal starting history initially                                                    Æ             reasonably efﬁciently large ¾                                                                       À                                                           holds return nil  practice examples considered date                                                               select primitive action precondi               Æ                 Æ                                 ¾  small ½ large time                                                                tion satisﬁed À maybe criteria                                    Æ      spent ﬁnding plan works ½        planner called kplanner written prolog  sensing results following                                                                                                    À ¡ ´ µ  consists three main modules plan tester plan generator ﬁnd plan È achieves starting ok                                                                                                                                          È µ  formula evaluator used modules     return plan seq ´     formula evaluator      look examples sufﬁces note sensing results following                                                                                         Ê                   À        need able handle projection task each sensing result possible                                                                               Æ           È                    termining formula true sequence actions given     ﬁnd plan achieves                                                                                    À ¡ ´ Ê µ        legality task determining action executed starting history                                                                                          Ä µ     Ä      use regression reiter  need return plan case´  list                                                                      Ê  È µ      Ê     È      able incorporate putative results sensing  ´                                                                                                                                                             previous step      use evaluation instead just keeping track                          Ê                                                                  remaining sensing results impossible      sequence actions performed date maintain                         È                                                                  corresponding “don’t care”  tory consisting pairs actions sensing results                                                           plan previous step unwinding loop  actions sensing results use ok result fi                                                            return loop described  nally need able determine sensing result      occur based history date example  generating loops                                        ¾   tree chopping know    look action  produce sensing result history key question plans loops going  tains legal chop actions                         come proof general universal                                                        theorem suggested generation procedure    testing plans                                    come sequential conditional plans                                                            generated                                Æ  given plan È testing bound need determine                                                              works consider conditional plans                                              Æ      È correctly achieves goal assuming                                                                                                ½                                                        correct tree chopping given     bound need prove theorem                                                          case look           case look   simulate execution È possible results  sensing actions conﬁrm goal satisﬁed store     store                                                                 chop            chop                                                     cases following plan È achieves goal                                                                  store                  case look    starting history À initially                                                              endc                             store                                 À    È   nil  holds history                                                       don’t care                                                                                             endc                      ¼                ´ È µ                      À        È   seq        precondition holds                            endc            ¼                             À ¡ ´ µ      È  achieves history     ok                                                             right does sensing action needed                 ´ Ä µ                     À        È   case       precondition holds                                                                                                      ½                                                             sensing result impossible                  ´ Ê È µ ¾ Ä       Ê                                              each       possible sensing                                                                                            ½                                                            plan remains correct substitution                            Æ È                result given      achieves history                                                            “don’t care” key observation          À ¡ ´ Ê µ                                                                           substitution plan unwinding                                   É     É                È loop unwinds   achieves     loop replace “don’t care” robot program                À                                                                      µ      history                                           seq ´ chop tc tc plan program                                                                                                                                                    obtains unwinding tc conclusion tc                         µ       unwinding loop´    occurrences                                                                             ½                                                        correct returned potential plan  exit replaced occurrences replaced                                                           tested larger bound case successfully             µ  loop´     observe unwinding loop pro  duces plan executes way original loop idea practical possible  signiﬁcant comes generating plans quickly check plan matches unwinding loop                                                        unwinding unwinding    code kplanner number examples just guessing loop using pro  httpwwwcstorontoeducogrobo           log implementation language pays write                                                              µ          guard loops run forever loop ´ nil                                                                                              È É µ                                                        unwind  predicate unwind´   holds loop  need upper bound total number unwindings                                                               performed                                       precisely unwinding unwinding tc     loop unwinds                  primfluentaxe  unwpq   ploopbc subbpcq               primfluenttree                                                        primfluentchopsmax      subbxyq holds     result       replacing   each ’exit’        primactionchopok      each ’next’   unwinding               primactionlookdownup  subq  varq                             primactionstoreok  subexitxyq xloopexit qy  subnextxq xloopnext unwxq       posschopandaxeouttreeup  subseqapxyseqaq subpxyq            posslooktrue  subcaseauxycaseav subluxyv         possstoreaxeout  subloopgpxyloopgq subpxyq                                                        initaxeout  subl                                      inittreeup  sublifrpuxyifrqv                   inittreedown           subpxyq subluxyv                                                        causesstoreaxestoredtrue        figure  prolog code unwind predicate   causeschoptreedowntrue                                                        causeschoptreeuptrue                                                            causeschopchopsmaxxx chopsmax                  É                         É  È unwinds  passing having    return È simpliﬁed code doing figure  settleslookxtreextrue  easy conﬁrm É conditional plan rejectslookupchopsmaxtrue      right prolog variable “don’t care” settleslookdownchopsmaxtrue                                              ﬁrst È returns desired iterative plan tc    method generating loops turned sig parmfluentchopsmax  niﬁcant alternative enumerating possible plans initparmgeneratechopsmax  containing loops practical small plans initparmtestchopsmax                                                            figure  problem speciﬁcation tree chopping    planner action      ready consider kplanner action                                                                     ´ µ                                                                        ¯ poss        precondition       problem speciﬁcations provided user repre                                                                     ´ Ú µ Ú                          sentation use variant indigolog   ¯ init         possible initial value                                                                         ´ Ö fÚc µ                 giacomo levesque  sardina et al    ¯ causes               holds  causes                                                                                          Ú               based situation calculus mccarthy hayes  value Ú  precisely possible                                                                                             Ö  reiter  user supplies deﬁnition predi possible value optional      cates prolog                                                                         ´ Ö fÚc µ                                                                            ¯ settles               known doing        indigolog ﬂuents kplanner functional                                                                                                    Ú                                                             getting result Ö  known value      unlike indigolog ﬂuents interpreted epistemicallyin                                                                  ¯                                                                      Ö fÚc µ                         possible value ac rejects ´           known doing                                                                                                        Ú  cording currently known vassos thisal getting result Ö  known value  lows reason sensing disad ﬁnal predicates action theory  vantages possible worlds demolombe parra  used specify planning parameter possible    predicates described arguments values generating testing      conditions logical formulas closed boolean                                                                              ´ µ        operators quantiﬁers atomic formulas arbitrary ¯ parm fluent  ﬂuent  planning parameter                                                                           ´ Û  Ú µ  Û      prolog goals contain ﬂuents ¯ init parm       generate test                                                                                                          evaluated replacing ﬂuents values Ú possible initial value planning parameter  calling prolog result say formula possibly  true goal succeeds possible value ﬂu  tree chopping example  ents formula known true goal succeeds direct formulation formalize tree chop  possible value ﬂuents                   ping using ﬂuent chops needed planning parameter          prolog predicates deﬁned user action handle testing bound  require                         Ö                        Ú      ﬂuent sensing result condition arbitrary value  deal  possible values ﬂuent instead suf                       ´ µ        ¯ prim  fluent     declares ﬂuent               ﬁcient track maximum possible values                                                            chops max        ¯              ´  Ö Ö µ                                Ò      prim  action     ½          declares                                                              problem speciﬁcation language tree          Ö                             Ò ½          possible sensing results action                                                        chopping example figure  known      considered provide sensing information                                                        tree initially possible    directives help control search initial values tree ﬂuent similarly chop ac                          tion actions like called nondeterministicprimfluentaccn                       goal   acc     input    primfluentinput       unknown fluent               xx   xx   xx                                                         plan  seconds  primactionincraccnok               primactiontestaccsamediff                 incracc                                                         loop  possincracctrue                                 case testacc  posstestacctrue                                     exit                                                              diff  causesincraccnaccnvv accn                    incracc   settlestestaccsameinputvvacc                    incracc   rejectstestaccdiffinputvvacc                    incracc                                                                   initacc                                         endc  parmfluentinput                                   endl   initparmgenerateinputv               incracc  initparmtestinputv                                                                           figure  doing arithmetic               figure  counting example                                                        current node target node nontarget leaf node      literature look action settles value nontarget internal node having left right children                                                                         Ü µ      addition look reports upthenchops max  push to´  internal node left                                                                   know chops max  result having performed right Ü  pop return child node  chop actions result impossible show moments thought convince reader  output run kplanner example problem solved additional storage                                                                                                                                          Ü µ                Ü  sufﬁce say ﬁnds tc  seconds assume push ´ pushes direction                                                        internal stackandthatpop pops stack    counting example                               produces popped value sensing result  turn different example involving sim rest speciﬁcation large display  ple counting problem accumulators use ﬂuent depth max like chops max                                                            node type internal depth max                                           ¼  unknown integer input  primi                                                              know node type                           Ò µ                   Ò  tive actions incr acc´ increment accumulator                                                            leaf bit trickier answer                          start  test acc´½µ sense ﬁrst accumulator  value input goal make second nodes left explore example assuming                                                           search left branches right ones                                ½   accumulator value ¾    complete problem speciﬁcation figure  rightmost branch tree node types                                                            internal target reﬂected following                             ´¾µ   three ﬂuents acc´½µ acc input  planning parameter run kplanner rejectschecknodetypeleafstacks  produces figure  kplanner works iterative allxmemberxslastdirx  deepening numbers output indicate getting result leaf rejects stack moves  level ’x’ indicates generated plan sufﬁ members direction available  cient generating bound did work constraint problem insoluble  testing bound omitted ﬁgure nice plan shown figure  note kplanner generates  note multiplication goal speci nested loop believe nesting required  ﬁcation said multiplication pro  gressive planning disadvantages advantage  discussion related work  does need able test goal  condition satisﬁed need reason goal loops three examples presented  analytic way                               clearly scope existing sequential condi                                                        tional planners far know planner based fully    searching example                              automated theoremproving generate three plans ei                                                        ther camps based theoremproving  turn complex example                                                       considered interesting special case iterative planning  searching unbounded binary tree target node called repeated attempt problems  precisely primitive actions  check node typesense                                                          probabilities consider action      runs eclipse prolog version  mac nonzero probability making true assume    single ghz processor mb memory            repetitions independent outcomes iterative         abstract variant problem building copies plan like tc achieve probability  just  stack coloured blocks                        right trying pick block ngo haddawy     thought simpliﬁed version searching ﬁnd good egg bonet geffner howev  ﬁle unix directory arbitrary depth           er independence untenable tree chopping
