   comparing bestfirst search dynamic programming optimal multiple                                                 sequence alignment                                    heath hohwald ignacio thayer richard korf                                              science department                                          university california los angeles                                                  los angeles ca                                            email heathietkorfcsuclaedu                             abstract                               methodology used comparing approaches                                                                  present results future work discussed section         sequence alignment important problem                                                                  conclude section         computational biology compare different        approaches problem optimally aligning        character strings bounded dynamic        programming bdp divideandconquer fron•            sequence alignment grid problem        tier search dcfs approaches compared        terms time space requirements                pairwise sequence alignment cost function        through  dimensions sequences varying        similarity length bdp performs better          sequences aligned inserting gaps each        three dimensions consumes time        sequences each character sequence corresponds        memory dcfs higherdimensional               character gap each pair corresponding        problems                                                 symbols gaps characters sequences charac•                                                                 terized match identical characters substitution    introduction overview                                    different characters gap gap sequence                                                                  example given sequences acgtacgtacgt   aligning multiple dna protein sequences known           atgtcgtcacgt alignment follows   sequence alignment important problem computa•  tional biology sequence alignment useful compar•                                                                 acgtacgtacgt   ing genomes finding genes determining evolution•                                                                 atgtcgtcacgt   ary linkage different biological sequences predict•  ing protein sequence secondary tertiary structure durbin  cost alignment calculated assigning cost   et al  waterman  consider algo•          each position sequences summing   rithms finding optimal alignment se•     costs positions example cost function   quences bounded dynamic programming bdp divide        charge  units matching characters  unit substitu•  andconquer frontier search dcfs bestfirst search algo•  tion  units gap cost function applied   rithm                                                         alignment result total cost       dynamic programming dp traditional approach    gaps marked  substitution   solving sequence alignment problems dcfs re•        second position optimal alignment   cent approach methods compared      minimizes given cost function sequences   problem aligning three sequences korf      cost function alignment optimal   zhang  extend work comparing   algorithms simultaneously aligning larger numbers se•  quences dcfs faster solve        multiple sequence alignment cost function   larger problems suggesting traditional dp ap•  proach best choice aligning three se• problem optimally aligning multiple sequences   quences                                                       natural extension pairwise alignment insert gaps      begin introducing multiple sequence align•     sequences given cost function minimized   ment problem show mapped prob•       multiple alignments use sumofpairs sp cost func•  lem finding lowestcost cornertocorner path     tion cost alignment multiple sequences   dimensional grid dynamic programming          sum cost induced pairwise alignments cost   approach section  dcfs algorithm section       each position determined given cost function    discuss heuristic evaluation functions use    described previous section exam•  sequence alignment section  section  explain      ple consider following alignment three sequences       search                                                                                                                 agtta                                                     dynamic programming     agctg                                                                  standard dynamic programming     gacag                                                                 dynamic programming dp general technique    using cost function cost align•                                                                used lowestcost path directed grid note    ment  obtained summing costs pairwise    optimal path passing through node include    alignments sequences       optimal path passing through predecessors                                                                 determine lowestcost path node need     grid problem                                         consider possible paths node need                                                                 know costs reach each ns immediate predecessors    sequence alignment problem mapped prob•       observation yields efficient algorithm search•   lem finding lowestcost cornertocorner path di•  ing directed grid case    rected grid each dimension corresponds  grid scan grid left right    sequences needleman wunsch  associate       each node store cost lowest   cost each edge grid cost alignment cost path start node cost minimum    sum edge costs corresponding path   obtained adding cost edge left    directedgrid problem allowed    cost node left cost edge    goal orthogonally diagonally          cost node cost edge      dimensions directedgrid problem diagonally left cost node diagonally    lowestcost path grid lengths left reach goal node    strings path goes upperlefthand cor• cost optimal path trace through    ner lowerrighthand corner legal moves grid associated path dp time    right diagonally right exam•     space complexity store costs nodes   ple sequences subsection  correspond• compute cost each node constant time dp    ing grid optimal solution path shown figure  generalized dimensions time space com•  horizontal corresponds gap vertical se• plexity lk hypercube length    quence vertical corresponds gap   horizontal sequence diagonal moves correspond matches      hirschbergs divideandconquer method   substitutions                                                                 using divideandconquer approach proposed      three dimensions threedimensional grid   hirschberg  space complexity dp   size seven directions   reduced reduction allows   each node grid right axis                                                                 larger problems solved hirschbcrgs method best   axis axis right                                                                 illustrated twodimensional grid problem   right finally right                                                                 node middle row grid guaranteed   general kdimensional directedgrid problem                                                                 optimal path recursively solve   seeks lowestcost path kdimensional grid   —                                                               subproblems finding optimal path start node     possible moves each node aligning sequences                                                                 finding optimal path goal node   length  requires grid size                                                                order node calculate costs                                                                 left right each row middle                                                                 row calculate costs right left each                                                                 row middle row                                                                 forward backward costs reach middle row                                                                 add corresponding entries each node                                                                 node minimum total cost node node                                                                 optimal cornertocorner path storing costs requires                                                                 rows memory topdown computation                                                                 bottomup computation reducing                                                                 space requirement idea                                                                 applied dimensions reducing space complexity                                                                    eppsteins divideandconquer method                                                                 hirschbergs algorithm bidirectional men•  figure  optimal alignment sequences sub    tioned unidirectional version algorithm at•  section  solid line represents solution path tributed eppstein hirschberg  called epp•  dashed line represents substitution                    steins divideandconquer method algorithm best ex•                                                                plained dimensions instead maintaining rows                                                                 costs each direction search proceed row                                                                                                                  search row start row goal row maintain sin•    represent perfect bound pb using opti•  gle row costs pass middle row maintain    mal bound bdp best case scenario terms   each node pointer ancestor middle    performance does depend particular iterative   row lowestcost path initial node    deepening scheme refer scenario bdppb   reach goal state pointer node mid•  use algorithm comparing performance   dle row lowestcost cornertocorner path  dcfs   hirschbergs method smaller pathfinding   problems solve recursively algorithm     disadvantages dynamic programming            space complexity                                                                  bdpub easy implement dimensions ex•                                                                 tending three dimensions diffi•   bounded dynamic programming                                                                  cult researchers noted difficulty zhang   limitation algorithms evalu•     able implement bdpub algo•  ate node grid bounded dynamic programming        rithm written explicitly three dimensions   bdp extension dp introduces upper bound     able extend implementation dimen•  solution cost presented spouge        sions using approach higher dimensions   method finding optimal lattice paths given up•     used generalized implementation explicitly checks   bound total solution cost prune nodes    legal operators each node introduces constant fac•  equal greater cost lie solution path tor time complexity dp processing each node   lower cost each node compute takes longer implementation tailored   gn cost reach initial node         specific dimension   lower bound cost reaching goal node      drawback dp used   node sum equals exceeds upper bound   lowestcost paths directed grids general   know does lie lowercost solution path   grids allow moves directions reason   aligning sequences equal length initial upper bound dynamic programming know priori nodes   computed directly aligning sequences     parents given node general shortest  gaps                                                          path problem use bestfirst search algorithm                                                                  dcfs generalization eppsteins algorithm    iterative upper bounds   general better upper bound solution cost      divideandconquer frontier search   prune nodes initial bound obtained directly   aligning sequences usually greater true   divideandconquer frontier search dcfs recent gen•  cost better approach use iterative deepening korf   eral heuristic search algorithm korf  bestfirstsearch     starting upper bound     algorithms dijkstras algorithm dijkstra    optimal solution cost algorithm fail reach    hart et al  normally store closed list   goal node pruning nodes bound         nodes expanded open list nodes   iteratively increased search repeated goal  generated expanded dcfs   reached strategy applied bounded dynamic     stores open list corresponds frontier   programming ukkonen                                 searched area size closed list      normally upper bound increased lowest cost   larger size open list dcfs reduces   nodes pruned current iteration     space requirement aligning strings length  lh   better quickly running shallow searches bounds   lkx korf    likely optimal solution cost regressing  dcfs does store closed list necessary   depths reached bounds used estimate solu•   prevent generation nodes ex•  tion cost know depth goal node use    panded node stores list operators   predicted bound starting point traditional itera• neighbors node expanded operator   tive deepening eliminating iterations bounds   each neighbor marked used   low method using bdp iterative      expanded used operators applied   upper bounds referred bdpub korf zhang        regenerated    principle iterative upper bounds applied    unlike standard bestfirst search dcfs reaches   conjunction hirschbergs eppsteins algo•    goal node retrace pointers discover solution   rithm practice eppsteins algorithm faster  path closed list saved alternatively stor•  used results follow                               ing path each open node require space linear      using iterative deepening iterations algo•  path length each node order recover solu•  rithm use upper bound optimal solution   tion path starting search hyperplane chosen   cost reach goal hand using up•       divides search space half node   bound greater optimal solution cost examines      open list hyperplane stores pointer node   nodes necessary usually dont know so•       hyperplane optimal path di•  lution cost advance choice use iterative mensions hyperplane simply row column halfway   deepening knew optimal solution cost      dimensions choose hyperplane       search                                                                                                                split longest dimension space algorithm    encounters goal node pointer node    middle plane optimal solution path algo•   rithm recurses optimal path start node   optimal middle node middle node    goal node      dcfs general heuristic search algorithm use    divideandconquer frontier search dcfa cost    function gn cost path    start node node hn heuristic estimate   reaching goal node      heuristic evaluation functions     accurate heuristic evaluation function important limit figure  ways partition edges complete   number nodes visited during search dimen•                                                                 graph nodes include triangle   sions use distance node cornertocorner   diagonal times gap cost heuristic solu•  tion path return diagonal order arrive   goal node general heuristic cost node accurate heuristic function resulting fewer nodes                       times gap cost          visited during search   coordinates goal node                                                                    guarantee heuristic lower bound      three dimensions compute better lower bound   include cost aligning pair sequences   using sumofpairs cost function      example cost pair sequences   use sum optimal pairwise alignments lower     threeway alignment included an•  bound heuristic obviously cost optimal pairwise    threeway alignment pairwise alignment con•  alignment equal cost sider complete graph node each sequence   alignment strings multiple alignment  edge pair nodes representing pair   example optimal alignment three sequences       sequences graph triangle represents threeway                                                                  alignment need partition edges graph                                                                  groups single edges triangles including                                                                  edge group ideally way maximizes                                                                  resulting heuristic value   cost alignment  costs align•  ment shown pairs        example partition edges complete   respectively heuristic estimate cost aligning  graph nodes single edges tri•  strings  optimal pairwise  angle three single edges general want include   alignment pair   shown        threeway alignments possible order make                                                                  heuristic function accurate different                                                                  ways partition edges triplet three                                                                  pairs figure  complete graph nodes      heuristic evaluation particular node grid  different ways partition nodes   lower bound lowestcost path node    triplets pairs way selecting par•  goal corresponds alignment sequence suf•   titioning use evaluate choose   fixes correspond node threedimensional    gives largest heuristic evaluation original se•  alignment precompute store three twodimensional       quences hope larger heuristic evaluation   matrices each pair strings each entry each ma• start node indicator larger heuristic values through•  trix contains cost optimally aligning correspond•   search evaluating possible parti•  ing remaining suffixes pair strings compute  tions instead randomly choosing used time   overall heuristic node cube sum corre•  saved did yield significant savings   sponding elements each three matrices               represent threedimensional heuristics oc•     general case aligning sequences using sum  tree stores certain parts cube   ofpairs cost alignment sequences induced     information generate parts cube   multiple alignment cost op•   needed mcnaughton et al  computing parts   timal alignment sequences     octree demand saves significant space   dimensions include optimal alignments      storing threedimensional heuristics octree   three sequences heuristic threedimensional  leads overall savings hard problems time   alignments expensive compute occupy       used calculate heuristics offset time saved during   space twodimensional alignments including gives    search                                                                                                                   search              time nodes time nodes time nodes time nodes time nodes     bdppb                                                   dcfa                                                  table  average results  generated problems generalized versions algorithms  dimensional problems   length  table displays average time seconds average number nodes expanded dcfa average   number nodes visited bdppb                                                                                                                     time nodes time nodes time nodes time nodes time nodes      bdppb                                                     dcfa                                                              table  average results  generated problems generalized versions algorithms  dimensional   problems length  table displays average time seconds average number nodes expanded dcfa   average number nodes visited bdppb      comparison approaches                                dimensional heuristics ran algorithms using    methodology                                               heuristics reported faster times   compared divideandconquer frontier dcfa         experimental results   bounded dynamic programming perfect bounds bdp  pb problems aligning     sequences      previous work korf zhang  showed dp   goal determine algorithm solve harder      outperforms dcfa three dimensions ran•  problems space limits difficulty problem dom strings new results corroborate findings   determined number length similarity    dimensions bdpub aligns completely random se•  sequences ran tests  ghz intel pentium       quences faster dcfa example length    gb ram  kb li cache  kb cache          average  times faster three di•  dcfa used fixedsize hash table        mensions disparity somewhat smaller dp align•  million nodes occupies  mb memory tested      ing completely random sequences length  average   algorithms randomlygenerated sequences       times faster dcfa exceeds hour time   real sequences balibase thomson et al         limit larger problems      randomlygenerated sequences varied se•           dimensions dcfa able   quence similarity affected performance   solve larger problems bdp memory con•  algorithms generated reference sequence uni•  straints dp allocates memory based problem size   formly alphabet letters simulating dna se•   dimensions able align sequences length    quences generated actual sequences     independent similarity sequences contrast   reference sequence each character actual sequences    dcfa able align completely random sequences   generated independently probability match•     length   minutes   ing corresponding character reference sequence       furthermore problems algorithms   probability randomly generated including        solve dcfa significantly faster bdp ex•  matching character varied   incre•          periments compared dcfa bdppb use   ments  problem instances   identical se•   optimal solution cost initial upper bound re•  quences easy align run order alistic setting bound known priori bdp   upper bound solvable problem size problem instances    fare worse comparison average results     hardest problems sequences    aligning sequences length  arc shown table    completely random ran algorithms  problems      sequences similar performance ad•  each similarity dimension length averaged  vantage dcfa increases   results little variability different random    dimensions bdppb able solve problems   trials experiment                                length  dcfa able align completely      actual sequences used real protein sequences  random sequences length   minutes   balibase database benchmark alignments thomson        align random sequences length  algo•    et al  proteins represented strings al• rithms compared problems aligning sequences   phabet  amino acids pairwise cost function used  length  table  comparing tables   charges  units match  unit substitution  relative performance bdppb random problems de•  units gap multiple sequences used sum      creases moving sequences   ofpairs cost function problems dimen•  bdppb takes  longer dcfa align   sions choice using twodimensional three   completely random sequences length  takes       search                                                                                                               
