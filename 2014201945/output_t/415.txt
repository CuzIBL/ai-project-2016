               dpll trace sat knowledge compilation                                      jinbo huang adnan darwiche                                       science department                                   university california los angeles                                          los angeles ca                                        jinbo darwichecsuclaedu                        abstract                          decades continue build known                                                        dpll search davis et al  examples      show trace exhaustive dpll      complete sat solvers  sat competition      search viewed compilation propo httpsatliveorgsatcompetition      sitional theory different constraints imposed      lifted dpll algorithm compilation   paper sets demonstrate deep connection      belong language ddnnf fbdd  tween sat solving knowledge compilation ﬁrst      obdd respectively languages decreas  direction show advances searchbased sat algo      ingly succinct increasingly tractable support rithms carry exhaustive version dpll      ing polynomialtime queries model count  compiling propositional theories tractable      ing equivalence testing contribution  languages start pointing trace ex      twofold provide uniform frame  haustive dpll search recorded compactly dag      work supported empirical evaluations com viewed compiled representation input theory      piling knowledge various languages different constraints imposed lifted search process      second show given particular variant show compilation language      dpll identifying language membership   ddnnf fbdd obdd respectively languages      traces gains fundamental understanding known decrease succinctness propositional      intrinsic complexity computational power  ory polynomialsize representation ddnnf                                                                                                        search algorithm interesting exam fbdd fbdd obdd darwiche                                                                              ples unveil “hidden power” marquis        cent model counters point potential second direction formulate principles      limitations identify key limitation dpll intrinsic complexity computational power      based procedures general                      dpllbased exhaustive search related language                                                        membership traces applying principles point                                                        recent model counters doing work    introduction                                       actually compile theories ddnnf discuss  knowledge compilation key direction research potential limitation efﬁciency model counters  automated reasoning selman kautz  marquis knowledge compilers using similar algorithms   selman kautz  cadoli donini  based fact algorithms generate traces  darwiche marquis  propositional theories speciﬁc subset ddnnf finally note ef  compiled suitable target language generally ﬁciency dpllbased exhaustive search algorithms  intractable queries answered time polynomial inherently limited inability produce traces  size compilation compiling combinational circuits ddnnf realization signiﬁcant impor  obdds example allows functional equivalence tant computational tasks existential quantiﬁcation  tested polynomial time constant time variables computation minimumcardinality models  variable order used bryant  recent applica efﬁciently accomplished weaker representa  tions compilation ﬁelds diagnosis tion known dnnf strict superset ddnnf  planning involving use dnnf language dar uniform dpllbased framework knowledge  wiche barrett  palacios et al   compilation power successful modern sat techniques    propositional satisﬁability sat hand harnessed including sophisticated conﬂict analysis clause  area importance activity aside learning faster detection unit clauses new branching  theoretical signiﬁcance prototypical np heuristics discuss caching methods speciﬁc  complete problem sat ﬁnds practical applications needs compilation tailored desired target compi  areas artiﬁcial intelligence science large lation language structurebased complexity guar  sat algorithms substantially improved antees ﬁnally relate experimental results imple nnf                         decision node                                                     table  polytime queries supported language ◦ means                                                                      “not supported unless pnp”  means “do know”                                                           lang     va   ce   im   eq   se   ct                            ¬¬¬x ααα βββ               √         √                       √                                                           dnnf     √    √◦   √    √◦   ◦    ◦   √◦   √                                                          ddnnf    √    √    √    √        ◦   √    √                                      alternatively    fbdd     √    √    √    √   √    ◦   √    √                           obdd                              ◦                                                                  √    √    √    √   √    √    √    √                                                          obdd                                         ααα    ¬¬¬a ¬¬¬     ¬¬¬ ¬¬¬           βββ                                                          obdd language subset fbdd sen       figure  nnf sentence decision node   tences satisfy ordering property variables appear                                                        order roottosink paths bryant  fig                                                        ure obdd example particular variable order  mentations three respective compilers theoretical  write obdd denote corresponding obdd  succinctness relations corresponding languages subset sentences use order     remainder paper organized follows sec having option target compilation languages  tion  reviews number propositional languages concerned desirable despite succinctness relations  work theoretical roles relations knowl known reason succinctness language  edge compilation section  uniform frame runs counter tractability—that set queries  work knowledge compilation regard lan supported polynomial time—and best choice  guages based recording trace exhaustive dpll pend task hand given tradeoff  search discuss implications understanding criteria rule thumb according darwiche mar  complexity computational power various search quis  choose succinct language sup  algorithms report experimental results section  ports desired set queries polynomial time  conclude section                                 cases support transformations boolean opera                                                        tions consideration    target compilation languages                         table  lists set polynomialtime queries                                                        terest supported each languages  logical form qualiﬁes target compilation language letter abbreviations stand following queries  supports set nontrivial queries usually including respectively consistency validity clausal entailment  clausal entailment polynomial time review implicant equivalence sentential entailment model  section target compilation languages relevant counting model enumeration darwiche marquis  present paper refer reader darwiche marquis    comprehensive discussion              interestingly table offers explanation popu    languages shall subsets larity obdds formal veriﬁcation efﬁcient equiv  general negation normal form nnf sentence nnf alence testing things critical  propositional formula conjunction ∧ disjunc succinct ddnnf fbdd known admit  tion ∨ negation ¬ connectives polynomialtime equivalence test polynomialtime prob  negation appears variable sharing subformu abilistic equivalence test possible darwiche huang  las permitted means rooted dag figure  blum et al  note    start dnnf language set difference ddnnf fbdd extent  nnf sentences satisfy decomposability conjuncts table question mark equivalence test eq  conjunction share variable language eventually resolved differently languages  dnnf satisﬁes decomposability determinism dis following section use notion recording  juncts disjunction pairwise logically inconsistent trace dpll search establish important link  formula figure example ddnnf  tween sat knowledge compilation providing uniform    fbdd language subset ddnnf framework compiling knowledge lan  root sentence decision node deﬁned guages point view discuss new  recursively constant   disjunction understanding complexity computational power  form figure propositional variable algorithms based exhaustive dpll  α β decision nodes note equivalent  compact drawing decision node—shown fig    dpll trace  ure c—is widely used formal veriﬁcation literature  fbdds equivalently known binary decision start basic dpll search davis et al   diagrams bdds satisfy testonce property each facilitate subsequent discussion variants al  variable appears roottosink path ger gorithm omit unit resolution pseudocode  gov meinel  figure fbdd example discussions valid presence  using compact drawing                      unit resolution following footnotesa cnf               search tree                                                       title paper suggests like think                                                        complete search tree known termination tree        ∨∨∨                                                  cision tree trace left exhaustive dpll search          ∨∨∨¬¬¬ ∨∨∨                                                                          trace corresponds portion search space        ¬¬¬ ∨∨∨ ∨∨∨          unsat           sat    actually explored particular execution algorithm                                                                                            furthermore trace viewed compiled repre                                  unsat sat unsat sat     sentation original cnf formula uniquely                                                        identiﬁes propositional theory—by specifying models                                                          viewpoint knowledge compilation  fbdd            obdd                      search trace recorded present form immedi                                                      ately useful typically size proportional                                                        work produce answering                                                                                           lineartime query compilation example                                                        running search                                                                                         problem remedied reducing trace                                                        tree dag repeated applications following                                                    rules isomorphic nodes nodes                                                        label low child high child merged ii          figure  exhaustive dpll trace       node identical children deleted pointers                                                        redirected children bryant     algorithm  summary dpll sat works apply reduction rules tree figure  cursively doing case analysis assignment selected rename “satunsat” “” dag fig  variable lines  theory satisﬁable ure particular example ﬁrst rule applies  case results satisﬁable subtheory ∆x ∆x terminal nodes second rule does apply ob  denotes cnf obtained replacing occurrences serve dag propositional theory    ∆ simplifying formula accordingly language fbdd accident  effect algorithm performs search space vari  able assignments ﬁnds satisﬁes given cnf  compiling cnf fbdd  formula realizes satisfying assignment exists fact possession cnftofbdd compiler    consider extending algorithm  enu scribed formally algorithm  main difference  merate satisfying assignments—by exploring original dpll line  explore  branches line —rather terminate ﬁnding ﬁrst branches newly introduced function getnode pro  figure depicts search tree exhaustive ver vides means recording trace search form  sion dpll cnf figure particular dag speciﬁcally getnode return decision node  variable ordering using dotted solid line denote labeled ﬁrst argument having second argument  setting variable   refer correspond low child having argument high  ing branch search low high branch note child note lines  modiﬁed return  each leaf tree gives partial variable assignment terminal decision nodes instead boolean constants  satisﬁes theory regardless values unassigned point space required algo  variables tree characterizes precisely set rithm  store fbdd proportional size  satisfying assignments                           ﬁnal result words create                                                         dundant nodes reduced later     incorporate unit resolution simpliﬁed picture reduction rules builtin means unique nodes ta  assignments decision assume chosen ble wellknown bdd community somenzi release  decision variable line  algorithm  implied unit   resolution algorithm simply proceed right branch   speciﬁcally nodes created getnode stored  according implied value variable noting hash table getnode create new node  branch leads unsatisﬁability assume choos node created exists table existing  ing decision variable implied unit resolution node returned ii second arguments  favored represent restriction search argument returned  traces shortly possibly generated                                                          algorithm  dpllf ∆ compiles cnf ∆ fbdd dpll low  algorithm  dpll∆ returns satisﬁability cnf ∆   ercased distinguish algorithm  version    clause ∆               clause ∆     return                                             return sink    variable ∆                   variable ∆     return                                             return sink    select variable ∆                              select variable ∆    return dpll∆x dpll∆x                   return getnodex dpllf ∆x dpllf ∆x  caching despite use unique nodes controls shown exponential cutwidth given  space complexity algorithm  time complex cnf variant caching scheme allows show parallel  ity proportional size tree version search complexity terms pathwidth cutwidth pathwidth  trace portions dag end explored mul comparable  tiple times alleviate problem resorts formula classical obdd construction emphasize  caching majercik littman                  algorithm  represents distinct way obdd construction    algorithm  describes cnftofbdd  com    contrast standard method widely adopted formal  piler caching result recursive veriﬁcation recursively builds obdds compo  dpllf ∆ stored cache line  nents propositional theory compiled  returned indexed key computed line  identifying combines using apply operator bryant   ∆ subsequent ∆ immediately return wellknown problem method  existing compilation ∆ cache line  ∆ termediate obdds arise process grow large  equivalent ∆ key comparison line  make manipulation impossible    practice normally focuses efﬁciently recog ﬁnal result tractable size considering  nizing formulas syntactically identical ﬁnal obdd really algorithm  affords  set clauses various methods pro solution problem building exactly  posed purpose recent years starting ma work linear  jercik littman  used caching probabilis obdd size inconsistent subproblems  tic planning problems followed darwiche  contribute obdd size caching  proposed concrete formula caching method complete empirical comparison compilation al  text knowledge compilation bacchus et al  gorithm traditional obdd construction method  sang et al  context model counting huang darwiche   huang darwiche  darwiche  proposed  reﬁnements darwiche                  fbdd ddnnf    fbdd obdd                                fbdd ddnnf sentence deﬁnition                                                        remains reasonable option compile propositional theo  turn obdd target compilation language ries ddnnf given greater succinctness  note algorithm  dpll free choose variable sidering ddnnf relaxation fbdd obtain  branch line  corresponds use ddnnf compiler relaxing corresponding constraint  dynamic variable ordering heuristic typical sat solver algorithm  speciﬁcally immediately line   keeping spirit fbdd compilation       need insist case analysis performed    surprisingly cnftoobdd compiler ob variable formula instead following tech  tained switching dynamic static variable ordering nique decomposition utilized algorithm   new compiler particular variable order π soon variable instantiation ﬁnishes contra  second argument make sure order enforced diction examine remaining cnf formula  constructing dag line  algorithm  partition subsets share variable line     caching naturally general formula caching method subsets recursively compiled ddnnf  ones described earlier applicable lines – conjoined andnode line  note  algorithm  constrained compiler decomposition takes precedence case analysis  special method available shorter cache keys decomposition possible branch se  used reduce cost manipulation reader lected variable regular dpll lines   referred huang darwiche  details  method allows bound number distinct unit resolution clause learning integrated  cache keys providing space time com algorithm issue arises regarding implications learned  plexity bound particular speciﬁc caching clauses span disjoint components sang et al  scheme space time complexity compiling obdds  discussion issue      algorithm  dpllf ∆ compiles cnf ∆ fbdd       algorithm  dpllo∆ π compiles cnf ∆ obddπ    clause ∆               clause ∆     return sink                                       return sink    variable ∆                   variable ∆     return sink                                       return sink    key  computekey∆                                key  computekey∆    result  cachelookupkey  null        result  cachelookupkey  null     return result                                       return result    select variable ∆                               ﬁrst variable order π appears ∆    result  getnodex dpllf ∆x dpllf ∆x  result  getnodex dpllo∆x π dpllo∆x π   cacheinsertkey result                          cacheinsertkey result   return result                                      return result  note relaxation algorithm  resulted caching caching methods proposed  new type node returned getandnode line  ddnnf compilation latest effective  old getnode function line  returns decision nodes appeared darwiche  refer reader  relaxed sense children necessarily darwiche caching scheme speciﬁc  decision nodes form figure unique nodes dtreebased decomposition method scheme  technique extended straightforward way competitive darwiche   isomorphic andnodes created        miss equivalences caught    point algorithm  produces sen allows show space time complexity  tences subset ddnnf produces dnnf compilation exponential treewidth  special type disjunction nodes—decision nodes cnf formula compared pathwidth cutwidth  relaxed sense recall ddnnf allows disjunc obdd compilation interestingly similar structurebased  tion long disjuncts pairwise logically inconsis measure complexity appears known fbdds  tent come subsection relation andor search recent work explored    static vs dynamic decomposition algorithm  sug  long established notion andor search process  gests dynamic notion decomposition disjoint queries belief constraint networks dechter ma  components recognized each variable split teescu andor search character  dynamic decomposition initially proposed utilized ized search graph alternating layers andnodes  bayardo pehoushek  model counting decisionnodes representing decomposition  adopted recent model counter sang et al  branching dags produced algo  darwiche   proposed static method rithm  andor graphs conversely  performing decomposition preprocessing cnf andor search algorithms described dechter ma  generate decomposition tree dtree binary tree teescu used compile networks  leaves correspond cnf clauses each node multivalued equivalent ddnnf implies  dtree deﬁnes set variables instantiation andor search algorithms capable  guaranteed decompose cnf disjoint components tasks proposed for—model counting  rationale cost dynamically computing par equivalent tasks computing probability  tition line  times during search replaced random variable assignment satisfying constraint query  lesser cost computing static recursive parti discuss following subsection  tion method decomposition allows  provide structurebased computational guarantees  understanding power limitations  discussed later orders magnitude efﬁcient dpll  benchmarks including iscas circuits                                                        main proposal paper view     obtain results effect running exhaustivedpll traces sentences propositional  model counter sang et al  version  available language view provides uniﬁed framework knowl  httpwwwcswashingtoneduhomeskautzcachet bench edge compilation shown earlier show  marks used darwiche  noted major beneﬁt framework using known  programs differ aspects decomposition method ap sults succinctness tractability languages  pears major difference note using dpll understand better intrinsic complexity computa  compilation incurs higher overhead model counting tional power various exhaustive dpll procedures  bookkeeping involved storing dpll trace                                                          consider particular variation dpll say dpllx                                                        suppose traces belong language lx    algorithm  dplld∆ compiles cnf ∆ ddnnf         dpllx run polynomial time formulas    clause ∆                 polynomialsize representation exists lx     return sink    variable ∆                    dpllx runs polynomial time class formu     return sink                                        las dpllx trivial modiﬁcation    components  disjoint partitions ∆                 swer polynomial time query formulas    components                                known tractable language lx     conjuncts       ∆ ∈ components                          example model counters recently proposed                                                      bayardo pehoushek  sang et al        conjuncts  conjuncts ∪ dplld∆c    return getandnodeconjuncts                   employ techniques decomposition   key  computekey∆                              caching simple analysis model counters shows   result  cachelookupkey  null      traces ddnnf language speciﬁc    return result                                    illustrations ddp algorithm bayardo pe   select variable ∆                            houshek  table  sang et al    result  getnodex dplld∆x dplld∆x  fore model counters polynomial   cacheinsertkey result                         time complexity formulas polynomialsize   return result                                     representations exist ddnnf
