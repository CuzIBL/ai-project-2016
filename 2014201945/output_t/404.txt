                             recent progress heuristic search                   case study fourpeg towers hanoi problem                       richard korf                                ariel felner                science department         department information systems engineering             university california los angeles         bengurion university negev                    los angeles ca                 po box  beersheva  israel                       korfcsuclaedu                             felnerbguacil                        abstract                          assumption dunkel  conjecture remains                                                        proven absent proof way verify optimality      integrate number new recent advances  solution given number discs systematic      heuristic search apply  search shorter solutions previously      peg towers hanoi problem include fron  foruptodiscskorf  extend       tier search diskbased search parallel processing discs size problem space nwheren      multiple compressed disjoint additive pat number discs each disc pegs      tern database heuristics breadthﬁrst heuristic discs peg sorted order each      search new ideas include pattern database heuris new disc multiplies size problem space      tics based multiple goal states method      duce coordination multiple parallel threads      method reducing number heuris      tic calculations perform ﬁrst complete      breadthﬁrst searches  disc      peg towers hanoi problems extend ver      iﬁcation “presumed optimal solutions”      problem   discs veriﬁcation      disc problem progress      towers hanoi problems                                  figure  fourpeg towers hanoi problem  standard towers hanoi problem consists three pegs  different sized discs initially stacked decreasing  der size peg task transfer discs  prior work fourpeg towers hanoi  initial peg goal peg moving disc  time placing larger disc smaller simplest search bruteforce search heuristics  disc largest disc initial peg goal complete breadthﬁrst searches generating states  peg smaller discs peg given initial state previously                                                                         remaining auxiliary peg generates sub discs korf    problem form original problem allowing different symmetries used  simple recursive solution easily proven shortest speed search ﬁrst transferring discs  solution problem requires −  moves       initial peg three pegs equiva    problem interesting add lent problems given state sort three non  peg figure  fourpeg towers hanoi initial pegs order largest disc reducing number                                                                                                       problem  years old hinz  optimal solu states factor bode  hinz   tion length known general difﬁculty reduction slightly noninitial  moving largest disc initial goal peg pegs permuting effect                                                                                                 quires remaining discs distributed symmetry solution path bode  hinz                                                              auxiliary pegs don’t know priori distribute   assume ﬁnd path middle statewhere  optimal solution  recursive strategy discs largest distributed auxiliary  proposed constructs valid solution frame  pegs largest disc initial  stewart  optimality proofs “presumed op goal peg execute moves reach  timal solution” offered contained unproven middle state reverse order return                                                        largest disc initial peg executing    auxiliary peg peg initial goal peg moves interchange initial goal pegs                                                    ijcai                                                    largest disc goal peg completing new conﬁguration discs ﬁrst encountered store  solution reach middle state generate corresponding search depth database search  complete solution shortest path middle state gen tinues conﬁgurations generated pattern  erates shortest solution path practice cuts search database constructed used solve  depth half refer halfdepth search problem instances goal state note    korf  used symmetries bruteforce set  differentsized discs generate exactly  halfdepth search verify presumed optimal solution pattern database regardless actual sizes  lengths  discs additional techniques used  frontier search storing nodes magnetic diskand  parallel processing discussed                multiplegoal pattern databases    verifying optimal solution length discs  quires heuristic search previously largest fourpeg main new contribution pattern databases multiple  towers hanoi problem solved optimally goal states initializing breadthﬁrst search  heuristic search  discs zhou  hansen com queue goal state seed goal states  pared  discs bruteforce halfdepth search rea depth zero depth state breadthﬁrst  son heuristic search fulldepth search search length shortest path goal state  computing heuristic single goal state       example construct pattern database number    important new idea paper com moves needed transfer  discs auxiliary pegs                                                                                       pute heuristic estimates length shortest path initialize search queue states   number goal states allows imple discs distributed auxiliary pegs assign  ment heuristic halfdepth search estimating length each value zero database breadthﬁrst search  shortest path middle state naive approach runs conﬁgurations  discs generated  computing heuristic each middle state taking recording depths database state  minimum values each state search im database value minimum number moves needed  practical large number middle states ndisc discs auxiliary pegs  fourpeg problem n− possible middle states appear obvious hindsight escaped  each way distribute n− smallest discs attention three groups researchers working  auxiliary pegs reduced n− assigning towers hanoi felner korf  hanan  used heuris  secondlargest disk auxiliary pegs     tic search additive pattern database heuristics solve                                                         discs felner et al  used compressed pattern    pattern database heuristics                        databases solve  discs zhou  hansen                                                         solved  discs using breadthﬁrst heuristic search  pattern databases lookup tables stored memory culber pattern databases fulldepth heuristic  son  schaeffer  effective heuris searches single goal state using pattern database heuris  tics known problems including rubik’s cube korf tics time researchers knew   slidingtile puzzles korf  felner bruteforce halfdepth searches multiple goal states  pattern database towers hanoi contains entry solve larger problems korf  didn’t  each possible conﬁguration subset discs pat combine  tern discs value each entry number moves multiplegoal pattern databases realworld appli  required pattern discs given conﬁgura cations consider car navigation quickly  tion goal peg ignoring discs felner korf  plan route nearest hospital ﬁrst run dijkstra’s              hanan   given problem instance each state algorithm dijkstra  preprocessing step initially  search use conﬁguration pattern discs com seeded hospital locations storing each map lo  pute index database corresponding value cation distance closest hospital search  used lowerbound estimate number moves direction oneway streets reversed  needed discs goal peg         user requests route current location nearest    size pattern database depends number hospital ﬁnd optimal path linear time  pattern discs represent conﬁguration discs                                  −                 heuristic exact application suppose want  unique index range     encoding   label each address city identity closest ﬁre  location each disc bits using result                                                       station aid dispatching ﬁre trucks run dijkstra’s al  ing nbit binary number index store gorithm initially seeded location ﬁre stations  heuristic values corresponding states modiﬁed each node includes identity  database values  each value stored closest ﬁre station addition distance case  single byte pattern database  discs requires                                                 don’t reverse oneway streets traveling           bytes gigabyte memory              ﬁre station address    construct pattern database perform breadth                                                          addition multiplegoal pattern databases verifying  ﬁrst search starting  discs goal peg each                                                        presumed optimal solution disc problem required    paper use “disc” refer tower integrating number additional recent new research  hanoi disc “disk” refer magnetic storage disk results heuristic search discuss                                                    ijcai                                                      frontier search                                      previous implementations algorithm korf                                                          korf  shultze  stored memory array  limiting resource breadthﬁrst search gener entry each possible ﬁle doesn’t scale  ate pattern databases heuristic search verify optimal large spaces instead maintain memory hash ta  solutions storage search nodes linearspace depth ble names ﬁles exist point time  ﬁrst searches completely impractical problem each ﬁle store corresponding expan  cause generate duplicate nodes representing sion ﬁle exists current andor depth  state reduce number stored nodes expanded merge ﬁle exists  use frontier search korf et al  simplicity list expansion ﬁle names contribute children  scribe breadthﬁrst frontier search standard breadthﬁrst merge ﬁle conserve disk space merge merge  search stores nodes generated closed list ﬁles soon expansion ﬁles expanded  expanded nodes open list nodes generated  expanded frontier search saves open list  closed list reducing nodes stored total  parallel processing  number nodes problem maximum number io intensive algorithm parallelized utilize  nodes depth width problem example cpus process blocks waiting io furthermore  total number states disc fourpeg towers increasingly common multiprocessor systems multiple  hanoi problem   trillion width core cpus offer opportunities parallelism  problem  billion states savings factor algorithm multithreaded different threads expanding   saves each node operators used gener merging different ﬁles parallel merging eligible ﬁles  ate avoid regenerating parent node takes priority ﬁle expansions  children additional work required generate solution nodes given ﬁle largest discs  path case don’t need solution path positions duplicate nodes conﬁned  simply depth given node generate pattern ﬁle duplicate merging different ﬁles  databases verify presumed optimal solutions  independently expanding nodes                                                        children generated moving large disks writ                                                        different merge ﬁles expansion dif    storing nodes disk                              ferent ﬁles send children merge ﬁle pre  unfortunately  billion nodes store mem vious implementations algorithm korf    ory solution store nodes magnetic disk korf korf  shultze  coordinated multiple threads    korf  shultze  challenge ﬁles write children merge ﬁle  sign algorithms rely sequential access random expanded time implementation  access byte disk takes ﬁve milliseconds remove restriction different threads indepen    main reason store nodes detect duplicates dently write children merge ﬁle long  nodes representing state reached ﬁles opened append mode simpliﬁes  different paths normally hash table code speeds requires coordina  randomly accessed node generated tion multiple threads  disk duplicates nodes checked im  mediately merged later sequential pass through  compressed pattern databases  disk delayed duplicate detection combined pattern database heuristic includes components  frontier search problem towers hanoi problem accurate database reﬂects  levels search tree stored korf  teractions included components case    algorithm expands level search space towers hanoi discs included  time types ﬁles expansion ﬁles contain accurate heuristic limitation memory  duplicate nodes merge ﬁles contain duplicates store database example pattern database  nodes ﬁle depth expansion based disc fourpeg problem require   ﬁles expanded children written merge ﬁles  trillion entries “compress” pat  depth fault tolerance ease interrupting tern database smaller database ﬁt memory  resuming program save expansion ﬁles modest lost accuracy follows  current depth completing iteration depth generate entire disc problem space     nodes ﬁle largest discs days using disk storage each state generated use  positions nodes ﬁle specify positions conﬁguration say  largest discs index   smallest discs  bits needed specify  pattern database store entry shallowest depth  discs plus usedoperator bits equals  bits single conﬁguration  discs occurs entry  word example disc problem requires storing minimum number moves required  discs  positions  discs positions  smallest discs goal peg minimization possi  stored each node positions remain ble conﬁgurations remaining seven smallest discs  ing  discs encoded ﬁle generating values pattern database signiﬁcantly larger   ≈  million ﬁle names                        corresponding entries simple disc pattern database                                                    ijcai                                                    values ignore smaller discs depth better solution problem breadthﬁrst  called compressed pattern database felner et al  heuristic search bfhs zhou  hansen bfhs  occupies gigabyte memory case  given cost threshold searches solutions    use compressed pattern database search cost does exceed threshold cost node  problem  discs each state look fngnhnwheregn cost initial  position  largest discs use corresponding state node nandhn heuristic estimate cost  table value heuristic state          reaching goal node bfhs breadthﬁrst                                                        search node total cost exceeds cost thresh    disjoint additive pattern databases                old deleted bfhs form frontier search                                                        stores levels search time  consider towers hanoi problem  discs simple solution additional work required construct  disc pattern database sevendisc pattern database solution path optimal solution cost known ad  moves single disc given conﬁg vance breadthﬁrst iterativedeepeninga zhou  hansen  uration  discs divide  performs series iterations successively  disjoint groups  seven discs each look creasing cost thresholds optimal solution  conﬁguration  discs disc database bfhs ideally suited towers hanoi  look conﬁguration seven discs reasons verify optimality presumed op  disc database sum resulting values ad timal solutions don’t need construct solution paths  missible heuristic disc problem called simply show shorter solutions exist  disjoint additive pattern database korf  felner  ﬁnd shorter solution need gener  felner korf  hanan  special ate verify correctness secondly know   split maximizing size largest database presumed optimal solution length advance set  gives accurate heuristic values             cost threshold value perform    add values compressed database single iteration eliminating iterative deepening  way assume problem  discs disc pattern  database compressed size disc database  simple sevendisc database given state use   minimizing heuristic calculations  largest discs represent  largest discs look search problems time compute heuristic  corresponding entry compressed pattern database evaluations signiﬁcant fraction running time  look conﬁguration seven smallest discs particularly true large pattern databases  eightdisc database add heuristic values randomly accessed resulting poor cache performance  admissible heuristic  discs pattern database heuristics determine max                                                        imum  possible heuristic value maximum values     multiple pattern databases                       each database search algorithms bfhs  order sum values different pattern iterativedeepeninga ida korf  pruning occurs  databases corresponding sets elements dis comparison given cost threshold speed  joint single element searches computing heuristics nodes  given admissible heuristic functions max possibly pruned particular cost threshold  imum admissible furthermore maximum sev maximum possible heuristic value don’t                                                                                                    ≤  eral different pattern database heuristics accu compute heuristics nodes  rate value single pattern database can’t possibly pruned don’t need com  total size compensates overhead pute heuristic shallowest possible depth prun  additional lookups holte et al               ing occur cost additional node ex    continuing example  discs construct pansions compensated faster speed  different admissible heuristics follows divides bruteforce search bfhs searches breadthﬁrst   discs  largest seven smallest discs don’t need load pattern databases depth  adding pattern database values divides start computing heuristics saving memory  seven largest  smallest discs additional parallel threads  adding database values finally maximum  values overall heuristic value use  bruteforce search experiments  databases heuristics                                                        ﬁrst ran complete bruteforce searches fourpeg                                                        towers hanoi compute pattern databases     breadthfirst heuristic search                   reason threepeg problem breadth  frontier search delayed duplicate detection com ﬁrst search depth n− starting discs peg  bined bestﬁrst heuristic search hart nils generate states problem  son  raphael  bestﬁrst search frontier n− radius problem space initial state  cludes nodes different depths usually larger threepeg problem radius opti  breadthﬁrst search frontier nodes mal solution length discs peg                                                    ijcai                                                      believed true fourpeg problem instead built simple pattern databases  korf  showed true seven discs essentially instantaneously  disc disc fourpeg problems disc ran breadthﬁrst heuristic search starting  problem  moves needed discs discs initial peg searching middle state  peg exist  states  moves largest disc distributed auxiliary  standard initial state disc problem pegs example disc problem middle state  optimal solution  moves radius problem  smallest discs moved initial peg  standard initial state  moves happens auxiliary pegs largest disc represented  larger problems unknown                      search used sixfold symmetry    ran ﬁrst complete breadthﬁrst searches  middle state moves complete solu  disc fourpeg towers hanoi problems starting tion moves exists utilizing symmetry  discs peg machine used ibm intellis initial goal states breadthﬁrst heuristic search  tation pro dual gigahertz amd opteron proces run cost threshold set − wherep  sors gigabytes memory running centos linux presumed optimal solution depth efﬁcient  three terabytes disk storage available consisting set cost threshold checking   gigabyte firewire external drives  existence shorter solutions increase conﬁdence   gigabyte internal serial ata drives          results used −  cost threshold    table  shows results ﬁrst column shows num checked actual solution search  ber discs second column optimal solution length given cost threshold ﬁnd solutions cost  transfer discs peg column equal threshold  radius problem space standard initial state each problem took maximum heuristics  fourth column width problem space disc problem uses  discs value  maximum number unique states depth compressed pattern database value  largest  standard initial state column running time discs plus complete pattern database value seven  dayshoursminutesseconds running parallel threads smallest discs compressed database  note problems radius standard ini value  smallest discs plus complete database  tial state exceeds optimal solution depth conjec value seven largest discs smaller problems  ture true problems  discs used disc compressed database looked                                                        remaining discs complete pattern database      optimal  radius           width        time       implemented parallel search algorithm using multi                        ple threads number threads limited available                       memory each thread needs local storage                                                        pattern databases shared read    table  complete search results towers hanoi experiments ran ﬁve parallel threads                                                        processors used seven disks evenly dividing ﬁles                                                        disks maximize parallelism                                                          results shown table  problems pre     heuristic search experiments                     viously veriﬁed ﬁrst column gives number discs  ran heuristic searches fourpeg towers second column length optimal solution  hanoi explained exists solution strategy column running time dayshoursminutesseconds  moves discs peg conjec fourth column number unique states expanded  ture optimal conjecture unproven prior column maximum storage needed  work conjecture veriﬁed  discs megabytes cases presumed optimal solution depth  korf  extended veriﬁcation  discs veriﬁed disc problem took  days run    ﬁrst built disc pattern database compressed generated total  trillion unique nodes  size disc database gigabyte memory quired maximum  gigabytes disk storage  complete breadthﬁrst search processors limiting resource cpu time  disc problem seeded states discs  distributed pegs used fold symme opt         time       unique states  space  try described generate database non                        initial pegs equivalent database did use                                                            symmetry contained entry  possi                 ble conﬁgurations  largest discs make database                lookups efﬁcient took  days construct            pattern database required maximum  giga        bytes disk storage reason longer  time complete search disc problem described table  heuristic search results towers hanoi  access pattern database each  node expanded able run ﬁve parallel threads search disc problem progress press time                                                    ijcai                                                    
