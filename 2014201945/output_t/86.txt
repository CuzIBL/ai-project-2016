                      factor graph model software bug finding                              ted kremenek        andrew ng       dawson engler                                        science department                                             stanford university                                          stanford ca  usa                           abstract                          properly locating ﬁxing bugs requires knowledge                                                         violated program invariants       automatic tools ﬁnding software errors require  traditionally discovering bugs responsibility       knowledge rules program obey    software developers testers fortunately automated       “speciﬁcations” identify bugs bugﬁnding tools based static program anal       present method combines factor graphs  ysis adroit ﬁnding errors op       static program analysis automatically infer spec erationally static analysis tool analyzes program       iﬁcations directly programs illustrate running similar compiler reasons pos       approach inferring functions programs sible paths execution through program conceptually       allocate release resources evaluate ap tool checks analyzed path obeys program       proach three codebases sdl openssh      invariants speciﬁcation rule violated       os kernel mac os xnu inferred    tool ﬂags warning static tools achieved signiﬁ       speciﬁcations highly accurate success recent years research tools ﬁnding thou       discovered numerous bugs                    sands bugs widely used opensource software                                                         linux kernel engler et al  unfortunately     introduction                                       free lunch like human testers tools require knowl                                                         edge program’s speciﬁcation order ﬁnd bugs   software bugs pervasive software   rising cost software errors recently estimated cost key issue possessing adequate speciﬁcations                                                         fortunately important program properties   united states economy  billionyear rti   tunately recent surge research check automated tools domainspeciﬁc tied   veloping automated practical bugﬁnding tools particular api program make matters worse man                                                         ual labor needed specify highlevel invariant properties   tools differ respects identical                                                         overwhelming small programs flanagan et al   know properties check ﬁnd                                                                bugs fundamentally tools essentially employ speciﬁca   large evolving codebases interfaces   tions encode program order distin quickly change complicates problem                                                         keeping speciﬁcation current consequently bugs   guish good program behavior bad                                                         current tools rendered     speciﬁcation set rules outlines acceptable                                                         invisible ignorance necessary speciﬁcations   behavior program “bug” violation rules   example universal speciﬁcation program “should paper describes technique combines factor   crash” crashes failstop errors pro graphs static program analysis automatically infer   gram halts easy detect fac speciﬁcations directly programs illustrate kind   tors lead crash equally difﬁcult diagnose speciﬁcations inferred example speciﬁ   software crashes colorful symptoms cation inference task paper formalizes extends                                                                                                     program behaving badly bugs failstop mem model informally introduced earlier work kremenek                                                                      ory leaks generally leaks application et al   algorithms inference   resources lead through attrition gradual death pro parameter learning changes result signiﬁcantly   gram induce erratic behavior way data improved performance model apply   corruption errors lead unpleasant results loss ideas ﬁnding number bugs sdl   sensitive data securityrelated bugs openssh postgresql wine mac os xnu   allowing compromised failstop  speciﬁcations resource ownership    led signiﬁcant work postmortem analysis software programs make use dynamically allocated   crashes including applying machine learning methods identify sources examples include memory allocated functions   potential causes crash zheng et al      like malloc ﬁle handles opened calls fopensockets                                                     ijcai                                                       file  fp  fopen myfiletxt           checker brieﬂy figure  depicts    file  fp  fdopen fd                    contrived code fragment illustrating use stan    fread buffer nfp                          dard io functions return values fopen    fwrite buffer nfp                         fdopen associate label ro returns ownership    fclose fp                                     ¬ro input arguments pointer type    fclose fp                                     fwrite freadandfclose    associate labels                                                        claims ownership ¬co labels used sim  figure  example use standard io functions    ple checker operates tracing possible paths                                                        function fp fp used                ¬co                                    endof             paths simulate each pointer property dfa figure                                     path                                                     time pointer passed argument function                owned        claimed     deallocator                    endof                             returned function corresponding label                                    ¬co            ro       path                                       endofpath¬co  consulted appropriate transition taken “end                                                  bug                               ofpath” indicates end function reached         uninit      leak                                      ownership      ﬁve ﬁnal states states leak invalid use             ¬ro                              bug                   ¬co        invalid use                error states shaded indicate buggy behavior invalid                                                     use captures “useafterrelease” errors claim                               endofpath  contra               ¬owned                                         ownership      ing nonowned pointer ﬁnal states indicate                                                        pointer used correctly discussed later                                                        details regarding implementation  figure  dfa static analysis checker ﬁnd resource errors checker kremenek et al   shaded ﬁnal states represent error states bugs    database connections functions “allocate”  approach  resources allocators typically matching dealloca  tor function free fclose releases speciﬁcations conceivably come arbitrary forms  source language supports garbage collection pro focus inferring speciﬁcations  entire set  grammers usually enforce manual discipline manag speciﬁcations discrete ﬁnite  given speciﬁca  ing arbitrary allocated resources order avoid resource tion program decomposed elements  related bugs leaks “useafterrelease” errors scribe behavior aspect program exam    numerous tools developed ﬁnd resource bugs ple ownership problem functions  majority focusing ﬁnding bugs uses return value labeled ro function arguments  known allocators malloc heine lam  labeled mn possible combined la  systems deﬁne host allocators deal bellings practice reasonable bugﬁnding  locators manage domainspeciﬁc resources problems speciﬁcations map similar domains  program analysis required ﬁnd resource bugs gener  ally allocators deallocators current tools primary lever inferring speciﬁcations pro  readily extended ﬁnd resource bugs domain grams contain latent information form “behav  speciﬁc allocators aware functions ioral signatures” indirectly documents highlevel    general concept subsumes knowing properties recall role speciﬁcations outline  allocators deallocators knowing functions return acceptable program behavior assume programs  claim ownership resources manage resources creators intended  programs employ ownership idiom resource relative sense “bugs rare” likely speciﬁcation  time exactly owning pointer handle closely matches program’s behavior  tually release resource ownership transferred speciﬁcation fed static analysis checker  pointer storing data structure passing checker ﬂag cases errant behavior  function claims deallocator program finally latent information come myriad  allocators deallocators respectively return claim forms naming conventions functions  ership functions return ownership contract “alloc” provide hints program’s speciﬁcation  similar allocator directly allocate resources motivates approach based probabilistic reason  function dequeues object linked list ing capable handling myriad information  returns caller object removed coupled uncertainty solution employs factor  list caller ensure object fully processed graphs yedidia et al  set random vari  similar narrative applies functions claim ownership ables factor graph represent speciﬁcations desire  knowing functions return claim ownership infer factors represent constraints implied behav  detect wider range resource bugs            ioral signatures factor graph constructed analyzing    paper explores problem inferring domain program’s source code represents joint probability  speciﬁc functions programs return claim distribution space possible speciﬁcations  ership formulation uses encoding set func factor graph constructed employ gibbs sampling  tions easily consumed simple static analysis tool infer likely speciﬁcations                                                    ijcai                                                      factor graph model                                 “coincidentally” exhibit observe                                                        haviors program provide strong evidence  present factor graph model inferring speciﬁ                                                        given speciﬁcation likely true check factors incorpo  cations illustrate terms ownership problem                                                        rate afg beliefs behaviors  make general statements key concepts introduced                                                        mechanism checker used determine behav    begin mapping space possible speciﬁcations                                                        iors program exhibits  random variables each element speciﬁcation                                                          second set factors used model arbitrary  discrete possible values random variable ai  domain example ownership prob domainspeciﬁc knowledge includes prior beliefs  lem each return value function “foo” codebase relative frequency certain speciﬁcations knowledge                                         ro ¬ro    suggestive naming conventions presence  random variable fooret domain                                             ro  ith argument function “baz”wehavea “alloc” function’s implies                                                           discuss classes factors turn  random variable abazi domain ¬co denote  collection variables compound assignment  check factors    represents complete speciﬁcation set  possible speciﬁcations                               check factors incorporate beliefs                                                        possible behaviors program exhibit    preliminaries                                    speciﬁcations imply  goal deﬁne joint distribution factor each ﬁnal state checker corresponds separate  graph review key deﬁnitions pertaining factor behavioral signature observed program given speci  graphs yedidia et al                         ﬁcation  checker observes ﬁve behavioral signa                                                        tures indicate different kinds bugs leaks  deﬁnition  factor afactorf set random vari                                                 three identify different kinds  ables  mapping val                    “good” behavior distinguishing different behav  deﬁnition  gibbs distribution gibbs distribution iors elevate probability values induce  set random variables  xxn deﬁned behaviors consistent beliefs                             terms set factors fjj associated random observe general bugs occur rarely pro                variables cjj cj ⊆                 grams perfect oracle checker em                               j                       ployed deﬁne error case dfa figure                                          ends error state assignment causes                    nz                                                                    checker ﬂag errors likely assign                                                        ment leads ﬂagged errors note  normalizing constant partition function treat errors impossible consider speci  deﬁnition  factor graph factor graph bipartite ﬁcations cause checker ﬂag errors   graph represents gibbs distribution nodes correspond real programs contain bugs  checker ﬂag                                     variables factors fjj edges connect false errors bugfree program  variables factors undirected edge xi kinds errors occur equal frequency  fj xi ∈ cj                                    practice invalid use errors occur far frequently                                                        leaks different speciﬁcations induce    overview model components                     number errors induces leaksthan  deﬁne factors model maintaining termi invalid use errors likely speciﬁcation  nology consistent previous work fac finally errors aside equally weight obser  tor graphs constructed speciﬁcation inference annotation vations different kinds good program behavior  factor graphs afgs follows spec example deallocator signature recognizes pattern  iﬁcations infer ro serve “annotate” owned pointer claimed subse  havior program components random quently used ownership matches behavior allows  variables afg  variables claimed pointer used claimed  hidden variables introduced needed mer behavioral signature harder set    categories factors afg used functions ﬁt chance consequently ob  capture different forms information speciﬁcation serve deallocator pattern potentially weight  ference ﬁrst set factors called check factorsareused stronger evidence given speciﬁcation code  extract information observed program behavior fragment obey ownership pattern finally  given speciﬁcation  assign functions contraownership pattern recognizes correct use  program determine each tracked pointer outcome nonowned pointer easiest pattern ﬁt func  checker described section  outcomes tions labeled ¬ro ¬co checker  ﬂect behaviors checker observed program given ﬂag error speciﬁcation useless  provided speciﬁcation resource leaks pointer cause wish infer ro functions  properly claimed insight  potentially “reward” observations ownership deal  haviors likely errors occur locator signatures contraownership pattern  rarely  behaviors harder program words willing tolerate errors set                                                    ijcai                                                                                                             multiple execution paths note value check                                                         summary analyzed paths function                                                         pointer each analyzed path end different state        afopenret afread afclose afdopenret afwrite dfa instead reporting results analyzed paths                                                         summarize reporting ﬁnal state ana                                                         lyzed paths appears earliest following partial order                                                                invalid use ≺  leak ≺ contraownership   figure  factor graph model code figure  circular         ≺             ≺   nodes correspond variables square nodes factors              ownership   deallocator   shaded factors indicate check factors row depicts example path analysis encounters invalid   factors modeling prior beliefs                       use state reports invalid use check regardless   functions appear consistently ﬁt deallocator ﬁnal states paths idea report bad   ownership signatures                              behavior good behavior     discuss ideas modeled using fac  modeling domain knowledge   tors ﬁrst atomize output checker checks   check distinct instance program spec exploiting information provided checker   iﬁcation obeyed disobeyed ownership factor graph allows incorporate useful domain knowl   problem check statement form edge discuss examples ownership problem   “p  foo” pointer value returned called prior beliefs prior knowledge   function code figure  check relative frequency different speciﬁcations example   fp fp general actual deﬁnition functions claim ownership arguments                                                                         ¬co   check depend speciﬁcations trying infer labeled  hints easily modeled                                                                                    essentially each check represents distinct observation single factor attached each variable attach each                                                                              eθx   point program’s behavior                          fooi factor  fooi      parameters                                                         θ      θ     deﬁne set checks codebase  ¬co shared factors created   each check create corresponding check factor denoted construction analogously deﬁne similar factors each                                                       afooret factors depicted figure     checki intheafg check factors represent  analysis   result checker each check running checker suggestive naming naming conventions functions   using provided set values  preferences function containing “alloc” implies return                                                                 ro   possible outcomes each check variables value  exploited similar fashion se                                                   lected small set wellknown keywords      associated given checki  denoted checki   values consulted checker containing words “alloc” “free” “new” model                                                                               ro                       termine check’s outcome example figure  depicts keyword correlation speciﬁcations each fooret                                                                                         kw   factor graph code example figure  functions contains keyword construct sin                                                                                 check factors shaded fp fp respectively gle factor associated fooret   fp checker needs consult speci                             θkwx                                                                        fafooret  xe                   ﬁcations represented variables afopenret afread                                                          ∈ro ¬ro    fclose variables associated checkfp  factor represented param     check factors simple mathematical deﬁnition eters keyword parameters shared                                                    checki  represents output checker check factors created construction note factor                               checki  checki checki deﬁned present function keyword substring                                                        it’s presence keyword sugges                      eθc                     checki  checki      checki       tive function’s role observed absence   check factor encoded set realvalued pa keyword usually uninformative                                                                                  rameters θc ∈ each distinct behavior observed keyword correlation speciﬁcations similarly mod   checker parameters shared check eled function contain multiple arguments   factors observe set behaviors used each labeled construct “keyword   encode intuitions program behavior spec factor” afooi variables denoted afooparmsfor   iﬁcations imply example expect pa function foo   rameters error states θ θ   lower                  θkwcoi∃ia coθkw¬coi∀ia ¬co                         leak    invalid use             fafooparmse         fooi            fooi   values remaining parameters errors rare                                                                                   parameters speciﬁed hand kremenek et al foo’s arguments speciﬁcation                                                                         θ          θ     paper focus learning partially factor value kwco kw¬co clar   known speciﬁcations observing learned parameters ity keyword factors omitted figure     match intuitions  compare quality   speciﬁcations inferred using handtuned parameters  inference  multiple checkers different check factors conceptually factor graph constructed employ gibbs sam   used analyze program different behavioral proﬁles pling sample joint distribution each ai                                                     ijcai                                                     estimate probability given speciﬁcation           afg size manually classiﬁed speciﬁcations       ro                                                                             ro            rank inferred speciﬁcations prob codebase lines    checks ro ¬ro ¬ro ¬co ¬co total  abilities analogously estimate each check factor   sdl                                                   checki probability values checki cause openssh            checker ﬂag error allows rank possible xnu            errors probabilities    updating value given aj ∈ awemust     table  breakdown project codebase size number manu                                                      ally classiﬁed speciﬁcations afg size  recompute value each check factor checki   ∈       checki  requires actually running checker  time gibbs sampling complete seeding parameters parameters excluding θleak  signment random variables checker simply θinvalid use  initialized value  initial bias                         sults current values determine outcome θleak θinvalid use initialized − provide slight  check clean interface checker primary bias speciﬁcations induce buggy behavior  reason employed gibbs sampling                      estimating gradient each step gradient ascent    checker relatively simple analysis expectations equation  estimated using gibbs sam  expensive run repeatedly compensate                                                      pling each chains relying prop  cache analysis results monitoring values erties stochastic optimization convergence conse  consulted checker determine outcome check quently estimate gradient highly noisy  results speedup orders magnitude                                                        help mitigate noise samples drawn clamped    experienced issues mixing                                                                                                unclamped manner similar contrastive divergence hin  product check factors values vari ton  each sample sampled  ables need ﬂipped outcome check                               clamped                                                        described section  generate sample unclamped   changes explored various strategies improve mixing continue running markov chain used sam  converged simple solution provided consistently                                                                                               ple clamped  unclamping observed variables  acceptable results run  chains   iter  running chain  iterations  ations end each chain record single sample noticeably reduces variation samples  each chain apply following annealing                                                      generated clamped unclamped   schedule each factor following deﬁnition             θ  kth gibbs iteration                                term cj gradient additive                                                        number factors share θc  value range                          min                                                                                                            −numfactorsθcj  numfactorsθcj  causes magnitude                                                        gradient grow size analyzed code  simple strategy signiﬁcantly improved quality                                                        base compensate scale each θc term gradient  samples satisﬁed empirical results pro                                                                                 numfactorsθcj  leaving each term modiﬁed gradient  cedure continue explore faster alternatives   range −  transformation modest  learning                                             learning rate worked extremely experimented                                                        alternate means specify learning rates gradient ascent  discuss procedure parameter learning met empirical success  factors discussed exponential form                 θ                 cj                                       finally afg typically consists multiple  fcj   cje     θcj ∈ set parameters  θ                                                     nected components connected component contains    factors learned partially observed observed variables equation  trivially  fac  data denoted  using gradient ascent maximize                             ⊂                    tors component prune components  loglikelihood  generally   representing par factor graph prior learning  tially known speciﬁcations omit derivation  gradient fairly standard case single    parameter θcj appears single factor fj corresponding  evaluation  term gradient                                                        evaluate model inferring ro functions  ∂ log pdθ                                          three codebases sdl openssh os kernel mac                    ic  −       ic                  clamped      unclamped     ∂θcj                                               os xnu sdl crossplatform graphics library                                                     game programming openssh consists network client  clamped represents conditional distribution server encrypted remote logins manage  variables factor graph observed custom resources sdl uses infrequently called memory  unclamped represents distribution observed data management routines xlib like os kernels xnu  parameter appears multiple factors gradient term deﬁnes host domainspeciﬁc routines managing    θcj summed factors appears sources each project randomly selected manually                                                        classiﬁed  speciﬁcations return values ro    implementation heuristics optimizations     ¬ro arguments ¬co functions table  shows  brieﬂy key features implemen size each codebase number manual classiﬁca  tation gradient ascent domain             tions afg sizes                                                    ijcai                                                    
