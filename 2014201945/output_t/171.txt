       solving    logic   program     conﬂict    through    strong    weak    forgettings                 yan zhang                        norman   foo                     kewen   wang       school  computing        school  comp  sci  eng      school  computing         university western sydney     university new  south wales          grifﬁth university          nsw    australia            nsw     australia            qld    australia      email  yancituwseduau    email normancseunsweduau      email kwangcitgueduau                        abstract                               goodfriendjohn om ←                                                             copyt om assignment ←      consider forget set atoms logic                    goodfriendjohn om      program intuitively set atoms forgot                   completejohn  assignment      logic program atoms set      eliminated program way  sue’s knowledge base Πs      atoms related program      hatesue om ←      affected deﬁne notions strong      ← helpsue john copyt om assignment      weak forgettings logic programs capture  order sue’s knowledge base account sup      intuition reveal close connections                                                        pose john updates knowledge base Πj terms sue’s      notion forgetting classical propositional                                                        Πs applying proper logic program update approach john      ories based notions propose                       final                                                                           Π            framework conﬂict solving logic programs  obtain solution                   sta                                                        ble model know sue help john      general represent impor                                                                                john           om      tant conﬂict solving problems study complete assignment   let  copy                                                                                             Π       Π      essential semantic computational properties assignment conﬂict                                                        solved updating result      relation strong weak forgettings conﬂict      solving framework                         satisfactory instance john wants sue help                                                        integrating information                                                        sue hates tom new knowledge base    introduction                                         alternative john just weaken knowledge                                                        base forgetting atom copyt om assignment Πj  promising approach research reasoning order accommodate sue’s constraint john  knowledge dynamics represent agents’ knowledge bases                final                                                        new program Πj       john remains  logic programs necessary updates conducted maximal knowledge subset consistent sue’s  way model agents’ knowledge evolution key issue condition involved sue’s personal feeling  study solve various conﬂicts inconsistencies tom                                logic programs leite                     formal notion forgetting propositional theories    different logic program update approaches initially considered lin reiter cognitive  developed recently observe typical robotics perspective lin reiter  recently  ﬂict solving problems logic programs thor received great attention kr community  oughly investigated literature let consider sce shown theory forgetting important applications  nario john wants sue help complete assign solving knowledge base inconsistencies belief update  ment knows sue help busy merging abductive reasoning causal theories actions  tom good friend john wants john let copy reasoning knowledge various propositional  john’s assignment john learns sue hates tom modal logic frameworks lang marquis   help lets tom copy assignment lang et al  lin  su et al   completed sue’s help john does paper consider forget set atoms  care sue hates tom consider propositional normal logic program idea  sue’s condition offer help john going used general conﬂict solving context logic  formalize scenario logic programming setting programs rest paper organized follows  john’s knowledge base Πj                             present preliminary deﬁnitions concepts section        completejohn assignment ←                 section  formal deﬁnitions strong weak                       helpsue john                 gettings logic programs based notions section       helpsue john ← notbusysue               propose framework called logic program contexts forgeneral conﬂict solving logic programs section  ci clause sub formula ci subclause  investigate related semantic computational properties ci  section  conclude paper discussions   introduce notion forgetting classical                                                        propositional theory lin reiter  lin  let    preliminaries                                      propositional theory use ptrue pfalse  consider ﬁnite propositional normal logic programs resp denote theory obtained substituting  each rule form                         occurrences propositional atom true false resp                                                        instance  ⊃ ∧ ⊃ qtrue                                        ←  · · ·  bm · · ·  cn        ⊃ qfalse  ¬p deﬁne   propositional atom notion forgetting terms propositional theory                                                        given propositional theory set propositional atoms  · · ·  bm · · ·  cn propositional atoms  rule  called constraint given rule  result forgetting  denoted orgett                                                         deﬁned inductively follows  form  denote headr  posr  · · ·  bm  negr  · · ·  cn rule  forgett ∅    represented form                                  forgett  ptrue ∨ pfalse                                                            forgett ∪p  forgetforgett             headr ← posr negr                                                                   easy ordering atoms  use atomr denote set atoms oc considered does affect ﬁnal result forgetting  curring rule program Π deﬁne notions   consider  ⊃ q∧r ⊃  headΠ     sr∈Π headr posΠ     sr∈Π posr   deﬁnition forgett  ⊃ ∨ ¬p  negΠ   sr∈Π negr atomΠ  set proposi  tional atoms occurring program Π given sets atoms  strong weak forgettings  logic  use notion                                  programs       headr ← posr −  negr −    let consider forget set atoms logic pro  denote rule obtained removing atoms oc gram intuitively expect forgetting set  curring positive negation failure parts atoms occurrences atoms underlying  respectively                                         program eliminated way    stable model program Π deﬁned follows atoms having connections through rules  firstly consider Π program each rule program affected observe notion  does contain negation failure sign ﬁnite set forgetting propositional theories applicable logic  propositional atoms called stable model Π programs disjunctive operation logic pro  smallest set each rule ← · · ·  bm grams different ways handling negation failure  Π · · ·  bm ∈ ∈ let Π arbitrary forgetting lead different resulting programs  normal logic program set atoms program Πs formalize idea forgetting logic programs ﬁrst  obtained Π deleting  each rule Π introduce program transformation called reduction                                             tains   body ∈  forms deﬁnition  program reduction let Π program  bodies remaining rules stable model atom deﬁne reduction Π respect                                         Π stable model Π  program denoted reductΠ program obtained Π  stable models  each rule headr  each rule  program called consistent stable model say ∈ posr replacing new rule  headr ←  atom entailed program Π denoted Π  posr ∪ posr − notnegr ∪ negr   stable model Π                   rule Π replaced     given programs Π Π Π Π equivalent removing rule remaining program let  Π Π stable models Π Π set atoms reduction Π respect  called strongly equivalent program Π Π ∪ Π inductively deﬁned follows  Π ∪ Π equivalent lifschitz et al        reductΠ ∅  Π  observation let Π logic program each rule Π reductΠ ∪  reductreductΠ   following forms  headr  ∅  headr ⊆ posr  posr ∩ negr  ∅ Π note program reduction deﬁnition step                                                                                                            strongly equivalent set                 logic program unfolding brass dix      later reference types rules men unfolding eliminate positive body occurrences  tioned redundant rules                         atom logic program reduction hand    let Π logic program use Πc denote remove rules heads atom  junctive normal form obtained Π translating each example  let Π  ← notb ← ← note  rule form  Π clause a∨¬b ∨· · ·∨¬bm ∨ Π  ← notb ← notd Π  ←  ∨ · · · ∨ cn instance Π  ← notb ← ← notd ← note reductΠ              Π  ∨ ∧ ∨ ¬a general write ← notb note ← note reductΠ  Π                                                 Π   · · ·  cn each ci conjunct Π  reductΠ  ← notd note deﬁnition  strong forgetting let Π logic program proposition  let Π logic program propo  atom  deﬁne program result sitional atoms  strongly forgetting Π denoted sforgetlpΠ  sforgetlpsforgetlpΠ strongly  obtained following transformation      equivalent sforgetlpsforgetlpΠ           Π   reductΠ                                 wforgetlpwforgetlpΠ   strongly    Π  Π −  redundant rule                equivalent wforgetlpwforgetlpΠ               Π   Π −  headr                        example   let Π  ←  ← nota ← notf    Π  Π −  ∈ posr                       sforgetlpΠ  ← notf                                                      wforgetlpΠ     ←  ←  notf      Π   Π −  ∈ negr                                                                                                consider forgetΠ  logically equivalent    sforgetlpΠ  Π                            formula ∨ ¬c ∨ ∧ ∨ clear                                                                                                let closer look deﬁnition  step  just  forgetΠ  ⊃ sforgetlpΠ                                                                                           perform reduction Π respect atom  wforgetlpΠ ⊃ forgetΠ    place positive body occurrences rules example motivates examine deeper  rules having head step  remove redundant relationships strong weak forgettings logic  rules introduced reduction Π programs forgetting propositional theories let Π  respect observation section  know program clause  ∨ · · · ∨ lk  does change program steps   each li propositional literal say Π  remove rules head coherent exists subset Π Π set atoms  positive body note steps   does ⊆ atomΠ sub  exist pair rules headr  clause reductΠ reductΠ sin  ∈ posr intuitive meaning steps   gle clause intuition notion specify  forgetting atom’s information rules having clauses parts clauses generated pro  heads positive bodies lost gram Π through reduction consider program Π  ←  relevant atoms serve support ← notc ← notd clause ∨ Πcoherent  supports atoms clause ¬d ∨ obviously each rule ∈ Π  hand step  states rule containing negation rc Πcoherent following proposition provides  failure removed consideration semantic account Πcoherent clauses                            negr  step follows think support proposition  let Π program Πcoherent  headr ∈ negr forgotten headr’s en clause  Πc ⊃  ⊃ Φ  tire support lost clearly treatment negation clause Φ  Πc ⊃ Φ  failure forgetting quite strong sense  atoms lost notp deﬁnition  let Π logic program ϕ ϕ ϕ three  kind forgetting strong forgetting                 propositional formulas ϕ ϕ conjunctive    different way dealing negation failure normal forms  weak version forgetting deﬁne pro    ϕ called consequence ϕ respect Π   gram result weakly forgetting Π denoted ϕ ⊃ ϕ each conjunct ϕ Πcoherent ϕ  wforgetlpΠ exactly way deﬁ  strongest consequence ϕ respect Π ϕ  nition  step  replaced following step consequence ϕ respect Π does                                                                                                   Π  Π − Π∗ ∪ Π†                             exist consequence ϕ ϕ ϕ ≡ ϕ                                                                                        Π∗    ∈ negr Π†    headr ←   respect Π  ϕ ⊃ ϕ                                            ∗              posr   negr − ∈ Π       ϕ called premiss ϕ respect Π  ϕ ⊃    suppose rule like  headr ← posr       ϕ each conjunct ϕ Πcoherent ϕ weak      negr ∈ negr instead viewing negr     est premiss ϕ respect Π ϕ premiss  support headr treat default ϕ respect Π does exist                                                                             evidence headr condition posr premiss ϕ ϕ ϕ ≡ ϕ respect Π                                                                       atoms negr presented headr  ϕ ⊃ ϕ  derived forgetting result absence                                                       example   example  continued easy verify  case replaced  headr ←                         posr negr −                           sforgetlpΠ strongest consequence                                                        forgetΠc  wforgetlpΠ ac weakest    strong weak forgettings easily extended               case set atoms                               premiss forgetΠ  fact following theorem                                                                                         sforgetlpΠ ∅  Π                               conﬁrms true     sforgetlpΠ ∪                             theorem   let Π   logic program   set           sforgetlpsforgetlpΠ             atoms    sforgetlpΠ strongest  wforgetlpΠ  deﬁned accordingly follow consequence forgetΠc   respect Π  ing proposition ensures strong weak forgettings wforgetlpΠ weakest premiss  logic programs deﬁned strong equivalence forgetΠc   respect Π  theorem  actually provides precise semantic character deﬁnition  preferred solution let Σ Σ logic  ization strong weak forgettings logic programs program contexts say Σ preferred solution Σ  terms forgetting notion corresponding proposi Σ ∈ solutionΣ does exist Σ ∈  tional theory                                        solutionΣ Σ ≺Σ Σ    solving  conﬂicts  logic program                example   let Σ  Φ Φ     contexts                                             Φ                   Φ                                                            Π ←              Π ←  section deﬁne general framework called logic     ← notc          ← note  program context represent knowledge     ← note          ←  sists multiple agents’ knowledge bases consider     ←                ←  issue conﬂicts occurring reasoning ← notf   ← notc  lying logic program context show notions  ← notd notf        ←  strong weak forgettings provide effective way solve     conﬂicts                                                        easy Σ consistent conﬂictfree  deﬁnition  logic program context logic program Π ∪ Π ∪ consistent                                                                                                      text nary tuple Σ  Φ · · ·  Φn each Φi consider logic program contexts Σ  Φ Φ                                                                   triplet Πi ci fi  Πi ci logic programs Σ  Φ  Φ   fi ⊆ atomΠi  set atoms each Φi                                                              Φ  sforgetlpΠ  ith component Σ Σ consistent each Πi ∪ ci                                                             Φ  wforgetlpΦ   consistent Σ conﬂictfree Πi ∪ cj                                                             Φ   wforgetlpΠ  consistent                                                                                                             Φ   wforgetlpΦ    deﬁnition given logic program context veriﬁed Σ Σ solutions Σ  Σ each component Φi represents agent i’s local situation Σ preferred solution   Πi agent i’s knowledge base ci set constraints  agent comply change case                                                           semantic   computational    properties  fi set atoms agent forget necessary  simplify following discussion assume each section study important semantic com  component Φi corresponding agent’s knowledge base Πi putational properties relation strong weak forget  does contain constraints rules heads al tings conﬂict solving  ternatively constraints contained constraint  set ci ci contain rules nonempty heads  semantic characterizations     problem conﬂict solving setting observe consistency program Π does  stated follows given logic program context necessarily imply consistent sforgetlpΠ   Σ  Φ · · ·  Φn consistent conﬂict wforgetlpΠ  set atoms  vice  free ﬁnd alternative logic program context versa example consider program Π  ← ←                                                      Σ   Φ · · ·  Φn Σ conﬂictfree closest weakly forgetting Π result  original Σ sense                      inconsistent program ← notb similarly strongly forget                                                        ting inconsistent program Π  ← nota ←                     let Σ   Φ · · ·  Φ  logic  deﬁnition  solution                                notc consistent program ← notc  program context each Φ  Π                                                     understand happen ﬁrst introduce  logic program context Σ solution solves conﬂicts Σ                                                        notions given program Π  set atoms   Σ satisﬁes following conditions                                                        specify programs  program sub    Σ conﬂictfree                               set Π containing three types rules Π  each                                                  ∈  ∈ headΠ rule ∈ Π ∈ posr    Σ   Φ · · ·  Φn Φi  Πi ci fi Πi                                                         each ∈  ∈ posΠ rule      sforgetlpΠi pi Π   wforgetlpΠi pi                                                      ∈  Π headr   ⊆   rule ∈ Π      pi ⊆ fi                                                        negr ∩  ∅ types    denote set solutions Σ solutionΣ clearly contains rules Π satisfying  deﬁnition  ordering solutions let Σ Σ Σ atomr ∩  ∅ affected reductΠ   three logic program contexts Σ Σ ∈ solutionΣ hand program obtained follows each  say Σ closer close Σ Σ denoted rule type  replacement form                                                   headr ← posr notnegr −    Σ  Σ Σ   each Φi  Πi ci fi ∈ Σ                                                 noted obtained linear time  Φi   Πi  ci fi ∈ Σ  Πi  sforgetlpΠi pi                                                       terms sizes Π   Πi    wforgetlpΠi pi pi ⊆  fi                              Πi   sforgetlpΠi qi Πi   wforgetlpΠi qi    theorem   let Π program set atoms  qi ⊆ fi respectively pi ⊆ qi ⊆ fi subset atoms occurring sforgetlpΠ                                   denote Σ ≺Σ Σ  Σ Σ Σ  Σ  Σ Σ               wforgetlpΠ   stable model sforgetlpΠ wforgetlpΠ  resp iff program Π − Π − removable strongly forgetting atom lr inﬂuenc                                               ∪ resp stable model  −  ing rules finally specify Σsi  Φ Φ                                                                                                                           Φ  Π ∅  ∈ Π Φ  ∅ Π ∅    theorem  presents interesting result given program Π                        −notp  set atoms  computing sforgetlpΠ  convenience use Π denote program  wforgetlpΠ   need exponential time section obtained Π removing occurrences atoms   stable models computed through negative bodies rules Π instance Π                                                                 notc          −notc             program obtained Π linear time  ←         Π         ←       consider existence preferred solutions following characterization result  logic program contexts conﬂict solving easy                                                        theorem   let Π Π consistent programs  logic program context preferred solution                                                                                              Σsi speciﬁed aborve Π siresult updating Π             Σ  ← nota ∅ ∅                              −notl r∈Π                        instance                     solution Π iff Π  Π           ∪ Π Σ   Π ∅   preferred solution following result                                                        ∈ Π ∅ Π ∅ preferred solution Σsi   shows existence Σ’s solution implies  existence Σ’s preferred solution vice versa    paper showed logic program                                                        update approaches eiter et al’s causal rejection  theorem  let Σ logic program context Σ pre                                                        dynamic logic programming eiter et al  leite   ferred solution iff solutionΣ  ∅                                                        dealing sequence programs embedded    deciding Σ preferred solution framework sense logic program context  nphard theorem  section  identify provides uniﬁed framework logic program updates  useful class logic program contexts solutions al  ways exist showed paper major  complexity results  logic program update approaches transformed                                                         assume readers familiar complexity  following form conﬂict solving context                                                                                                    classes np conp Σ Π  coΣ class  proposition  let Σ  Φ · · ·  Φn logic program dp contains languages  ∩  context each Φi  Πi ci fi ci consistent np conp class codp comple  each ∈ Πi fi ∩ atomr  ∅ solutionΣ  ∅ ment class dp readers refer papadimitriou                                                      details  proof   show  Σ       Φ · · ·  Φn                                                         observe main computation strong weak  Φi   ∅ ci fi  ≤ ≤ solution Σ  each fi ∩ atomr  ∅ each ∈ Πi forgettings relies procedure reduction                                                       inherits computation program unfolding  Πi   sforgetlpΠi fi   ∅ note  assumed Πi does contain rules general computing strong weak forgetting need ex  heads instead type rule contained ci ponential steps rule substitutions terms sizes                                                       input program set forgotten atoms  follows Πi ∪ cj  cj   · · ·   sistent ∅ · · ·  ∅ cn fn solution Σ  following result shows inference problem associated                                                        strong weak forgettings remains conp    representing logic program  updates              proposition  let Π logic program set atoms  major advantage proposed framework logic pro atom deciding sforgetlpΠ    gram contexts represent new conﬂict solving wforgetlpΠ   conpcomplete  scenarios traditional logic program update ap                                                        proof sketch hardness followed setting  ∅  proaches handle properly like discussed                                            section  example  fact framework membership proved using theorem   represent previous logic program update approaches il  lustrate sakama inoue’s update approach consider complexity irrelevance  sakama inoue  example note need lation strong weak forgettings conﬂict solving  restrict approach normal logic program setting semantic viewpoint irrelevance tells                                                        strongweak forgetting conﬂict solving procedure af  deﬁnition  sakama inoue  let Π Π fect particular atoms occurring underlying pro                                         consistent logic programs program Π siresult grams studying associated computational proper                                       theory update Π Π  Π consistent  ties important  Π ⊆  Π ⊆ Π ∪ Π  consistent                          program Π  Π ⊂ Π ⊆ Π ∪ Π                 deﬁnition  irrelevance let Π logic program set                                                        atoms atom say irrelevant    transform sakama inoue’s theory update Π Π  iff sforgetlpΠ   Π  iff  logic program context each rule ∈ Π intro                                                      wforgetlpΠ     duce new atom does occur atomΠ ∪ Π                              deﬁne  program Π each ∈  Π rule      generalize notion irrelevance logic pro                                              headr ← posr notnegr ∪  Π gram context formally let Σ logic program context  each ∈ Π simply extend negative body atom say derivable Σ’s ith component                                                unique atom  make each Π denoted Σ Φi  Πi ci fi ∈ Σ Πi 
