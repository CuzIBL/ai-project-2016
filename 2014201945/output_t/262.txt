                              conﬂictdriven answer set solving          martin gebser     benjamin kaufmann        andreneumann´       torsten schaub∗                                institut f¨ur informatik universit¨at potsdam                              postfach    d– potsdam germany                          abstract                            establishing formal background provide                                                        section  constraintbased speciﬁcation asp solving      introduce new approach computing answer   terms nogoods based uniform representation      sets logic programs based concepts develop section  algorithms asp solving rely      straint processing csp satisﬁability checking advanced csp sat techniques notably solving pro      sat idea view inferences answer   cedure centered conﬂictdriven learning      set programming asp unit propagation  jumping section  new asp solver clasp      goods provides uniform constraint implementing approach ﬁnally provide empirical      based framework different kinds infer sults demonstrating competitiveness clasp      ences asp allows apply advanced      techniques areas csp sat    background      implemented approach new asp solver                                                        given alphabet normal logic program ﬁnite set      clasp experiments show approach                   ←         competitive stateoftheart asp solvers    rules form                                                                              ≤  ≤ pi ∈pis  atom  ≤ ≤                                                        body literal atom negation pfora    introduction                                       rule rletheadrp   head body                                                        ppm pmnot pn body rthe  answer set programming asp baral                                                         set atoms occurring logic program Π denoted  attractive tool knowledge representation reason                                                        atomΠ set bodies Π body Π  body   ing corresponding solvers highly optimized                                                        ∈ Π regrouping rule bodies sharing head  cf simons et al  leone et al                                                         deﬁne body pbody  ∈ Π headrpinasp  formance does match stateoftheart solvers                                                        semantics program Π given answer setsbe  satisﬁability checking sat mitchell                                                         ing total wellfounded models Π formal introduction  computational mechanisms sat asp solvers                                                        asp refer reader baral   faroff instance seen success                                                          boolean assignment domain domaisase  satbased asp solvers assat lin zhao                                                         quence σσn signed literals σi form tp fp  cmodels giunchiglia et al  despite close                                                        ∈ doma   ≤ ≤  tp expresses  lationship sat generally constraint processing                                                        true fp false omit attribute signed  csp dechter  stateoftheart lookback techniques                                                        literals clear context denote  areas like backjumping conﬂictdriven learning                                                        complement literal σ σthatistp  fp  restarts established genuine asp solvers fp  tp  ◦                                                                welet        denote sequence obtained  fact recent approaches adopt techniques ward                      schlipf  ricca et al  lin et al  concatenating assignments  abuse  implementationspeciﬁc lack generality           notation identify assignment set    address deﬁciency introducing new compu tained literals given access true false propo                                                        sitions  ∈  doma   tp  ∈   tational approach asp solving centered csp af  ∈ doma  fp ∈  concept nogood apart fact allows                    easily integrate solving technology areas csp canonical representation constraints use                                                        csp concept nogood setting nogood set  sat conﬂictdriven learning backjumping watched lit σ σ   erals provides uniform representation  signed literals expressing constraint vio                                                        lated assignment containing σσn assign  inferences logic program rules unfounded sets       ∪ af   doma     ∩ af   ∅  nogoods learned conﬂicts                     ment                                                                                      solution set Δ nogoods δ  ⊆ δ ∈ Δ    ∗afﬁliated school computing science simon nogood δ literal σ ∈ δ assignment awe  fraser university canada iiis grifﬁth university australia say σ unitresulting δ wrt aifδ   σ                                                    ijcai                                                      σ  ∈ abyσ single literal δ result captures intuition body equiv  contained implies violated constraint does alent conjunction body literals  unitresulting literal condition  makes sure come inferences primarily aiming atoms  duplicates introduced contains σ atom true body body true  longer unitresulting instance literal fq versely elements body false false  unitresulting nogood fp tq wrt assignment fpbut body pββk nogoods           fp fq       fp tq  wrt       wrt        note notion         Δpfp   tβ  fp tβ   unitresulting literal closely related unit clause                            rule dpll cf mitchell  set Δ nogoods example atom body xy  assignment unit propagation iterated Δxfx ty fx tnot   process extending unitresulting literals finally atom false elements body  literal unitresulting nogood Δ false conversely body body true                                                        true body pββk reﬂected    nogoods logic programs                          following nogood    inferences asp rely atoms program rules           δptp   fβfβk  expressed using atoms bodies pro                                                                                 body xy  gram Π ﬁx domain assignments     taking atom                                                                                         δxtx  fy fnot  domaatomΠ     ∪ body Π hybrid approach obtain                            result exponentially smaller search spaces gebser dually proposition  following atoms  schaub  allows adequate represen proposition  let Π logic program  tation nogoods show sequel            set clauses    approach guided idea lin zhao  γ ∈ ΓΔp  ∈ atomΠ∪γδp  ∈ atomΠ  decomposes asp solving local inferences obtain  able clark completion program clark  logically equivalent propositional theory  obtainable loop formulas begin ≡ ∨···∨p      goods capturing inferences clark completion           β        βk    body rule true body literals true ∈ atomΠ body pββk  conversely literals false body combining propositions yields following result  false body β  ppm pmnot pn                                                                       Π  following nogood captures                   theorem  let   tight logic program       δβfβtptpm    fpmfpn          ΔΠ   δβ  β ∈ body Π∪δ ∈ Δβ  β ∈ body Π  intuitively δβ constraint enforcing truth body β ∪δp  ∈ atomΠ∪δ ∈ Δp  ∈ atomΠ  falsity contained literal body                                                                                            ⊆  atomΠ answer set Π iff  ∩  obtain δx yfx tx fy                                                        atomΠ unique solution ΔΠ    additionally body false literals  false conversely contained literals true nogoods ΔΠ capture supported models pro  body true β  ppm pmnot pn gram apt et al  answer set supported model  reﬂected following set nogoods     converse holds tight programs fages                                                         mismatch nontight programs caused loops lin        Δβtβfptβfpm                  tβtp      tβtp            zhao  responsible cyclic support true                                                  atoms cyclic support prohibited loop formu  taking body obtain Δx lasasshowninlee  answer sets program Π  tx fx tx ty               precisely models Π satisfy loop formulas    nogoods induce set clauses used nonempty subsets atomΠ observe ex  investigating logical contents underlying infer ponential number loops worst case lifschitz  ences given program Π associate nogood δ    razborov  makes enumeration loop formulas  tptpm fpmfpn   clause γδ  infeasible loop formulas checked lin  ¬q¬qmqmqn  qi    piifpi  ∈    ear time propagation genuine asp solvers makes  atomΠandqi   pβifpi  β ∈ body Πfor ≤ ≤ sure satisﬁed solution  deﬁne ΓΔ  γδ  δ ∈ Δ set nogoods Δ program Π ⊆ atomΠwedeﬁnethe  bodies Π obtain following correspondence external bodies Π eb Πuas  proposition  let Π logic program                 body  ∈ Π headr ∈ body ∩  ∅    set clauses  γδβ  β ∈ body Π∪γ ∈ ΓΔβ  β ∈ body Π disjunctive loop formula Π lf Πuis                                                                                                                                                          ¬                 ∧     − ¬p →¬          logically equivalent propositional theory         β∈ebΠu   p∈β       p∈β            p∈u   ≡ ∧···∧p    ∧¬p     ∧···∧¬p        β                                                β ∈ body Πβ          note loop formula constructed set atoms                                               set loop sense lin zhao                                                     ijcai                                                          β   β ∩ atomΠ     β−   ∈ β                                          algorithm nogoodpropagation  loop formula set atoms enforces elements                                                          input   program Πaset∇ nogoods  false externally supported lee                                                                   assignment    capture effect loop formula induced set                                                          output extended assignment set nogoods  ⊆ atomΠwedeﬁnetheloop nogood   atom ∈                                                      ←∅                        set unfounded atoms              λp ufβfβk  tp                 loop                                                             ← localpropagationΠ   ∇a  eb Πuββk overall follow                                                            δ ⊆ δ ∈ ΔΠ ∪∇or tightΠ  ing set loop nogoods program Π                                                               return ∇         ΛΠ    u⊆atomΠu∅λp  ∈                                                                                                                                                   ←    observe loop nogoods make direct use bodies     ∅ ← unfoundedsetΠa  eb  uβ   β                    lf      Π               unlike loop formulas Π              ∅ return ∇                           β  lying literals each using bodies loop    let ∈  goods reasonable unit propagation completion      ∇←∇∪λp  nogoods makes body false contains false literal  tp ∈ return ∇  tably usage bodies avoids combinatorial blowup      ← ◦ fp  faced expressing constraints terms body lit  erals fact representing λp terms body literals  yields β ×···×βk nogoods instead single    dropping tightness requirement show                                                        ﬁxpoint unit propagation computed localpropa  completion loop nogoods characterize answer sets                                                        gation yields violated nogood δ line   theorem  let Π logic program let ΔΠ ΛΠ extended solution Π tight unfounded atoms  theorem                                 falsiﬁed cases nogood                                                    ⊆atomΠ  answer set Π iff  ∩ propagation Π nontight check  atomΠ unique solution ΔΠ ∪ ΛΠ        founded set van gelder et al  accumulated uhas  nogoods ΔΠ  ∪ ΛΠ  set constraints falsiﬁed                                                                                       principally checked computing answer sets initially line determine  size ΔΠ linear atomΠ×body Π founded set note nonfalse atom unfounded  ΛΠ exponential magnitudes apply exist unfounded set containing false  ing asp solvers ΔΠ encoded dependency atoms section  implementation                                                                                                          graphs linking atoms bodiesrules given through foundedset require unfounded set  clark completion Π loop nogoods ΛΠ determined nonfalse atoms returned exists select                                                                                              λp  demand dedicated algorithms               line   atom    add loop nogood                                                        ∇ line  true λp violated                                                        return ∇ line  fp unitresulting    conﬂictdriven asp solving                         λp wrt aandweaddfp   line  having  given speciﬁcation asp solving terms nogoods falsiﬁed single element uwereinvokelocalprop  make use advanced techniques csp agation adding loop nogoods fact  sat developing equally advanced asp solving proce completion nogoods ΔΠ sufﬁce falsifying  dures different sat known nogood residual atoms example consider   usually explicated clause algorithms work logic rules ← ← ← yfromfx  programs inducing kinds nogoods particular rive fy fz generally falsifying single element  exponentially nogoods resulting loop formulas does allow falsifying set com  implicitly given program determined pletion nogoods add rule ← example  used propagation key role different kinds fy fz longer derivable reﬂected  partially implicit constraints expressed nogoods line  remove false atoms shrunken  identify reason responsible deriving literal unit set unfounded nonempty im  propagation makes logical fundament asp solv mediately determine loop nogood falsify  ing csp sat solving element observe unfounded atoms  directly apply similar reasoning strategies computed ones expended changing  need sat conversion proprietary designs      set atom selected line  bodies loop    begin speciﬁcation nogood propaga nogood λp change each iteration aiming ﬁrmer  tion procedure algorithm  propagation works pro representation respective unfounded set  gram Πaset∇  recorded nogoods assignment nogood propagation procedure interleaves  invoke localpropagation Π accumu    unit propagation completion accumulated nogoods  lated nogoods ∇ function adds unitresulting literals  derived nogoods ΔΠ ∇thatisa  given unfounded λp tp⊆a                                                    ijcai                                                       algorithm  cdnlasp                                 algorithm conflictanalysis     input  program Π                                  input   violated nogood δ program Πaset∇     output answer set Π                                   nogoods assignment                                                           output derived nogood uip decision level    ←∅           assignment atomΠ ∪ body Π                                                                                        ∇←∅                       set dynamic nogoods  let σ ∈ δ st  ◦ σ ◦ δ σ⊆b    dl ←                              decision level  ρ ∈ δ  dlρdlσ   σ    loop                                                    let ε ∈ ΔΠ ∪∇st σ ∈ ε ε σ⊆b       ∇ ← nogoodpropagationΠ    ∇a                δ ←  δ σ ∪ ε σ                                                                                              ε ⊆ ε ∈ ΔΠ ∪∇then                      let σ ∈ δ st  ◦ σ ◦ δ σ⊆c          dl return answer set                  ←          δ σuip ← onflict nalysis ε Π ∇a                                                    ←  maxdlρ  ρ ∈ δ σ ∪           ∇←∇∪δ                                                          return δ σ         ←  σ ∈   kdlσ         dl ←           ←  ◦ σuip                                                      σ                              dl       ∪  atomΠ  ∪ body Π          belongs new decision level                            return  ∩ atomΠ                             conﬂict analysis procedure determines asserting                                                  nogood δ backjumping δ yields unitresulting         σd ←  selectΠ ∇a                          literal leading algorithm  different search         dl ← dl                                     space traversed similar asserting         ←  ◦ σd                                 clause determined conﬂict analysis cdcl deriv                                                         ing δ follow firstuip scheme stop conﬂict analy                                                         sis ﬁrst uip uips explored                                                           conﬂict analysis procedure similar   recording propagation loop nogoods classical cdcl counterpart need subtle adjustments   underlying program nontight reason unfounded set inference works directed   falsity unfounded atoms determined way falsiﬁes unfounded atoms does “protect”   nogoods approach favors local propagation true atoms unfounded illustration   founded set computations motivated fact sider Πx ←  ←  ←  ←  ←   local propagation does add nogoods ∇ assignment tu note tu   economical unfounded set falsiﬁcation fur cision literal decision level  local propagation ΔΠ   ther discuss relation propagation strategy yields inferences body ux   approaches section                         unfounded set extend deci     conﬂictdriven nogood learning basic algorithm sion literal ty level  local propagation sets atom   deciding program answer set similar body false true set   conﬂictdriven clause learning cdcl firstuip unfounded makes record loop nogood   scheme mitchell  given program Π algorithm  δ  λu vfx tusincea  contains fx   starts assignment set ∇ tu nogood δ violated δ contains lit   learned nogoods decision level dl count decision eral added decision level  fx fx   literals literals derived nogood propa uip example violated nogood δ immedi   gation initial value dl  incremented ately asserting situation like occur classi   decision literal added literal σ ∈ ac cal cdcl initial violated clause contains   cess dlσ decision level σ value dl literal current decision level dif   σ added encountering conﬂict ference cdcl caused directedness unfounded   decision level used guide backjumping          set inference asp “partial” sense     loop algorithm  similar cdcl logical consequences derived terms loop   sketch principal steps function nogood good fβfβk tp unfounded set inference   propagation  deterministically extends ∇asde derive fp tβi body βi  ≤ ≤   scribed yields conﬂict line  function long loop nogood explicit record   flictanalysis determines conﬂict nogood δ ing δ  fx tu unfounded set infer   recorded unique implication point uip σuip anda ence derived fu decision level ifwehad   decision level jump backjumping nogood selected fx decision literal does   recording work cdcl particular conﬂict deci derive tx assignment tu inferred   sion level  indicates nonexistence answer set unit propagation δ available explicit constraint   solution line  atoms Π true form undirected unfounded set inference algorithmi   answer set Π finally nonconﬂicting partial cally solved current algorithms determine unfounded   decision literal σd selected according heuristics atoms bodies true according im   section  details added note plicit loop nogood                                                     ijcai                                                        algorithm  shows conﬂict analysis procedure clasp allows enumerating answer sets accom  worksonanassignmenta   containing violated nogood δ plished interleaving backjumping systematic  program Π ΔΠ recorded tracking solution decision literals  nogoods ∇ line  determine σ literal δ backtracked chronologically backjumping  added mentioned σ stricted repeating enumerated solutions  uip single literal δ current decision strategy avoids generation nogoods excluding entire  level σ uip enter whileloop line  solutions instance smodelscc mchaff   δ contains literal σ clasp’s second major operation mode runs systematic  current decision level note case σ backtracking learning similar strategy  decision literal nogood ε ΔΠ ∇ standard asp solvers like smodels using lookahead  σ unitresulting ε determined operation modes implemented uniform framework  line  line  resolve δ ε new nogood δ allows evaluate efﬁciency advanced  line  determine new σ literal new δ sat implementation techniques watched literals  added each iteration σ moves closer standard asp solver  ﬁnally derive nogood δ contains ex  actly literal σ current decision level worst  experiments  case decision literal line  determine deci                                                        conducted experiments variety problem classes  sion level jump maximum level literal                                                        comparison considers clasp rc major  δ σ algorithm conflictanalysis                                                        modes standard using backjumping learn  similar firstuip scheme cdcl difference                                                        ing systematic backtracking mode using looka  conﬂict resolution start asserting nogood                                                        head learning refer variants claspa                                                        claspb “traditional” asp solver include smod  theclasp                                      els  variations smodels’ strategy sim                                                        ilar claspb incorporate assat  cmod  new clasp  implements approach                                                        els  using mchaff spelt smodelscc   asp solving combines highlevel modeling capac                                                        compared solvers smodelscc closest claspa  ities asp stateoftheart techniques area satbased solvers assat cmodels convert logic program  boolean constraint solving unlike existing asp solvers cnf delegate search supported model  clasp originally designed optimized conﬂict mchaff tight programs approach amounts clasp  driven asp solving applying sat solver mode nontight case assat cmodels delay  cnf conversion clasp directly incorporates suitable checking loop nogoods assignment total  data structures particularly ﬁtting backjumping learning solvers integrate propagation  includes dedicated treatment binary ternary experiments run ghz pc linux                   goods ryan   watched literals unit propaga report results seconds taking average  runs each                                             tion “long” nogoods moskewicz et al   unlike restricted time gb ram timeout indi        cc                      smodels  ward schlipf   builds material cated “—” solvers run default settings  implication graph keeping track multitude                                                        smodelscc used option “nolooka  ference rules asp solving clasp uses eco head” recommended developers instances used  nomical approach sat solvers derived literal                                         Δ  ∪∇          experiments extended results dlv  stores pointer responsible constraint Π  nomore excluded lack space    unfounded set detection clasp combines smodels’ available clasp  brief instances ta  source pointer technique simons  unfounded ble   areas bounded model checking  set computation algorithm described anger et al   des cryptanalysis  blocksworld planning  aims small “loopencompassing” great  hamiltonian cycles clumpy graphs   est unfounded sets determined smodels simons et al hamiltonian paths gryzzles game  sokoban   dlv leone et al notablyclasp recognizes  machine code superoptimization   violated loop nogoods immediately asserting cf sec instances numbered   tight  tion  nogood recorded twice nontight    primary operation mode clasp conﬂictdriven table  gives results computing answer set  nogood learning backjumping learning clasp tight instances  claspa performs comparable assat  features number related techniques typically cmodels slightly faster showing  cdclbased sat solvers clasp incorporates restarts dele lowlevel implementation clasp competitive state  tion recorded conﬂict loop nogoods decision oftheart sat solvers doing work assat  heuristics favoring literals conﬂict nogoods cmodels regarding smodels systematic  features conﬁgurable command line options tracking approach does scale applies  fault restart nogood deletion policies adopted clasp mode instances   tight  minisat e´en s¨orensson  standard heuristics supported models supported model  adjustment berkmin goldberg novikov   algorithm  details search answer set httpwwwprincetonedu∼chaff                                                    ijcai                                                     
