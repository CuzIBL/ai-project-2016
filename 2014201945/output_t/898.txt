                       factored planning using decomposition trees                          elena kelareva              olivier buffet∗ jinbo huang sylvie thiebaux´                   university melbourne      national ict australia australian national university              melbourne victoria  australia             canberra act  australia               ekelarevaugradunimelbeduau             ﬁrstnamelastnamenictacomau                          abstract                            approach different algorithm form                                                        abstract planning makes use factorisation      improving ai planning algorithms relies    problem respect related localised      ability exploit structure problem planning lansky getoor  having advan      hand promising direction factored   tage limited domains explicit hierarchi      planning domain partitioned sub cal structure characteristic algorithm uses      domains little interaction possible decomposition tree dtree darwiche       cent work ﬁeld led detailed theoret junction tree domain factorisation resulting algo      ical analysis approaches couple rithm dtreeplan generic ﬁrst attempt      highlevel planning algorithms prac design new algorithm factored planning backtrack      tical implementations limited experimen  ing beneﬁt different improvements different      tations paper presents dtreeplananew       choices underlying planner possible      generic factored planning algorithm uses    present particular implementation based      decomposition tree efﬁciently partition planning satisﬁability kautz selman using      main discuss aspects progres    zchaff  lowlevel planner moskewicz et al       sively describing speciﬁc implementation explore implementation details aiming      presenting experimental results prototype al reducing backtracking different forms abstrac      gorithm promising contribution—with major    tion use caching techniques results au      possible improvements—and helps enrich pic   tomated algorithms factorisation planning      ture factored planning approaches             experiments show encouraging results analysis                                                        dtreeplan  leads various directions improve                                                        ments possible making promising algorithm    introduction                                         setting background knowledge factored plan  improving ai planning algorithms relies ability ex ning presented section  generic dtreeplan  ploit structure problem hand particularly algorithm introduced section  details imple  interested composite systems planning network mentation improvements described section  sec  components investigate promising direction known tion  presents experimental results followed discussion  factored planning domain partitioned conclusion  subdomains little interaction possible    factored planning related abstract planning  background  involve planning abstracted versions original prob  lem abstract planning usually involves progressively reﬁn  planning problem  ing plan going sequence decreasingly ab  stract domains backtracking current plan planning problem formulation uses strips operators  ﬁned knoblock et al  factored planning conditional effects goals conjunctions literals  different path recent approaches simul large algorithm extends complex  taneously ﬁnding plans given length different settings negative preconditions multivalued variables  subdomains trying merge global solution restricted form objective rigid assumption  amir engelhardt  brafman domshlak  paper optimality criterion consider length  avoid backtracking cost computing possi complete plan  ble plans subdomains potentially running example use remainder  expensive                                            paper window problem described figure                                                         wants throw ball room breaking    ∗olivier buffet laascnrs france        window                                                    ijcai                                                    variables                                            gives dynamic programming algorithm planning    open  true false    broken  true false                              starts leaves goes root plan    ball  inside outside                            executed selected form backtracking                                                        restarting algorithms plans length  actions                                              plan length      open    openfalse                 setopentrue         actions lower levels tree ab      close                                            stracted higher levels subplans disappear    opentrue  brokenfalse   setopenfalse      cause merged way approach      throw                                            potentially huge memory requirements practicability    opentrue  balloutside   setballinside    openfalse  balloutside  setballinside      established local planners                      brokentrue  opentrue         inside given node know actions                                                        nondescendant nodes knowledge help        balloutside  openfalse  brokenfalse  init state                                           prune infeasible plans plans holes         ballinside  openfalse  brokenfalse  goal state                                           ﬁlled finally planners extend length plans                                                        subdomains time leading local optimality              figure  window problem             guaranteeing minimum length complete plan                                                        brafman domshlak     factored planning  factored planning raises questions factor given  algorithm  problem plan using factorisation factoring  abstract planner  process partitioning domain possibly overlap ﬁrst introduce particular abstract planning proce  ping subdomains planning starts solving simple dure using arbitrary ordering action clusters  abstracted problems tries merge solutions im ccc supposed selected planning  prove solutions complex problems process consists planning clusters order  solving original problem                         ing root cluster ci planning problem deﬁned    create subdomains need cluster actions                                                         actions  ci’s real actions plus abstract actions replacing  original domain subdomain di deﬁned                                                            actions cicc ci    variables appearing cluster actions ci variables  variables appearing ci’s real actions    actions real actions actions clus necessarily subset superset variables      ter plus possibly abstract actions abstracted versions clusters      actions clusters              goal  goal deﬁned original problem                                                            cluster ci goal ﬁll set holes  sequence consecutive abstract actions hole plan Λ ···     window problem consider cluster action       λ   λΛ passedonbyci− projected  abstract actions make possible open cluster ci’s variables  close window                                       actions variables deﬁne subdomain level    mainly interested composite systems depends ci clusters tree  set controllable components interacting through shared complete plan seen tree node  variables representing communications possibly indirect plan holes completed children subplans  interactions organised network topology pending ci− passes holes ci time  leads ﬁrst suggestion factoring using components process depthﬁrst breadth  ∈ building blocks seen clusters actions ﬁrst traversal plan completed  causal graph problem intuitively appealing child ci failure signiﬁed parent ci− window  choice actions component prone act problem figure easy solve throw cluster  depend internal variables does tell quickly produces ﬁrst plan throw preceded  set blocks organised abstract action making open true followed  apply tree decomposition components’ making open false  network approaches                       depthﬁrst version detailed algorithm  omit                                                        ting projections subdomains taking hole λi− given  existing factored planners                            ci−  ci tries each plan πi  recent factored planners partplan amir   ci’s real abstract actions satisfying λi− πi’s  engelhardt  lidgf brafman domshlak   holes ﬁlled fillholes each planforhole   use tree decomposition actions distributed returns new plan exhaustion subplans returned  nodes plan recursively computing pos fillholes attached πi’s holes children tree  sible plans holes actions subtrees abstractreplan refillholes used  node planning current node merging subplans holes backtrack make possible look  inserting actions local node incomplete plan subplans ﬁlling given hole loop  plans produced node turn infeasible stops ci returns valid plan subplans  possibility complete ﬁll holes thereisnomoreplantotry                                                    ijcai                                                     algorithm  abstract planner depthfirst          inal domain subdomains leaves corresponding                                                        individual clusters actions dtree’s subtrees seen    abstractplanλi−holepassedonbyci−                                                        neighbourhoods good basis ﬁnding    isleafthis return planforholeλi−                                                        dering leaves dtrees correspond branch decom    repeat                                                        positions known graph theory robertson seymour       πi ← planforholeλi−                                                         used darwiche  specify recur       failureπi return failure                                                       sive decompositions bayesian network fam       Π  ← fillholesπiholes                                                                                          ¬ failureΠ                                  ilies huang darwiche   dtrees used                                                       specify recursive decompositions cnf formula    return πiattachΠ                Λ                                        clauses purposes dtree binary tree    fillholes  i− list holes                     leaves correspond clusters actions planning    isemptyΛi− return ∅      ←                  Λ                              problems figure clusters leaves contain    π   childabstractplan i−head                 single action each node annotated variables    failureπ return failure    Π ←         Λ                                      shared subtrees assume children         fillholes i−tail                         dtree node visited left right    failureΠ       π ← childabstractreplanΛi−head       failureπ return failure                                                        open                                                              throw       Π  ←fillholes Λi−tail              Π    return π                                                                              open                                                                                                        open    abstractreplanλi−holepassedonbyci−                    close                     broken                                                                                          ball    isleafthis return planforholeλi−                                                  open    Π ←         refillholesπiholes                                                  open                                                                                                open               Π                                                                  broken    failure                                                                           broken                                                                open               ball       πi ← planforholeλi−                                                                             throw          close       failureπi return failure                                                        topdown view           dtree view       Π  ← fillholesπiholes                        return πiattachΠ                                                                figure  views running example    refillholesΛi− list holes             Λ    isempty i− return failure                                                              Π ←           Λ                                      generate dtree use tool described darwiche         refillholes i−tail                                                      Π                                       hopkins   employs technique hyper    failure                                  graph partitioning hypergraph constructed hav         ←      abstractreplanΛi−head       π   child                                        ing node each action hyperedge each vari       isemptyπ return failure                                                       able connecting nodes actions variable ap       Π  ←fillholes Λi−tail              Π                                      pears hypergraph recursively partitioned    return π                                            balanced parts attempting minimise number                                                        edges resulting dtree expected rela                                                        tively small cutsets variables shared sub    clusters visited cluster ci trees  called future past clusters ci               dtree speciﬁes recursive decomposition    ordering action clusters                     main actions generally wish                                                        subdomain contain just single action  make algorithm  efﬁcient important accomplished simply regarding internal node  choose visiting order clusters speciﬁes sub dtree subdomain containing actions rep  domains ordering dynamic cluster resented leaves node speciﬁcally im  visit depend variables appear holes plemented clustering process given dtree depth  ﬁll focus ﬁxed ordering work clustering level cl ∈   dtree nodes depth    choosing ordering requires analysing actions  − cl × treated subdomains  variables depend mentioned decomposition takes place section  experiment  subdomains regroup real actions precon alternative scheme action clusters correspond  ditions effects linked group variables components original planning problem dtree  using actions cluster partitions built preformed clusters leaves  domain share variables possible  dering resulting subdomains reordering subtrees  consecutive subdomains share variables possible explained dtree speciﬁes neighbourhood  view early backtracking quickly identifying lationships leaves assume children  satisﬁable constraints                               dtree node visited left right ﬂipping children    sort clusters propose using decomposition tree node produces different ordering subdomains  dtree darwiche  recursively splits orig decide order children employ simple heuris                                                    ijcai                                                    tic inspired goalregression takes list variables algorithm  dtreeplan depthfirst  appearing goal deﬁnition rearranges dtree                                                          dtreeplanλholepassedonbyparent  cluster able modify ﬁrst vis                                                          isleafthis return planforholeλ  ited leftmost leaf process repeated                                                          πl ← leftchilddtreeplanλ  list variables appearing preconditions ﬁrst clus                                                          failureπl return failure  ter place “best” cluster second leaf                                                          Πr ←  fillholesπlholes  means assuming close node figure                                                           failureΠr  complex subtree leaf throw just placed                                                             πl ← leftchildredtreeplanλ  leftmost position variables appearing throw’s precondi                                                             failureπl return failure  tions used open’s subtree position best leaf                                                             Πr ←  fillholesπlholes  simple recursive process happening traversing                                                          return πlattachΠr  tree rearranging way algorithm                                                                      fillholesΛ   list holes                                                          isemptyΛ return ∅                                                                                       algorithm  reorder                                   πl ← rightchilddtreeplanΛ head    reorder                                             failureπl return failure                                                                goalv ars ← variables goal deﬁnition           Π  ←fillholesΛi−tail    reorderrecgoalv ars                                 failureΠ                                                               ←                        Λ    reorderrecvars list variables                      π    rightchildredtreeplan i−head    isleafthis return thisprecondvars           failureπ return failure                                                             Π ←          Λ    ←nsharedvarsvars leftchildmodiﬁedvars                fillholes i−tail                                                                    Π    ←nsharedvarsvars rightchildmodiﬁedvars       return π    lr  swapleftchild rightchild    vars ←reorderrecleftchild vars    vars” ←reorderrecrightchild vars                  • virtual actions abstracted versions actions    return vars”                                            future clusters nonshared variables removed                                                            manytoone mapping real actions fu                                                            ture clusters abstract actions current cluster    dtreeplan                                        note “hole”  “sequence abstract actions”  “h action”                                                          types abstract actions proposed ac  visiting leaves order achieved simple dtree                                                        tions advantage requiring knowledge  traversal result shown algorithm  omit                                                        future clusters apart variables share  redtreeplan refillholes dtreeplan returns plan                                                        current cluster help design planning process  tree leaves unﬁlled holes πholes returns                                                        going through independent components want  holes ordered list note traversal                                                        capabilities private actions informa  plan—seen tree—is depthﬁrst breadth                                                        tive help avoid infeasible holes  ﬁrst traversal holes reﬁned time each                                                        brings closer central planning  “neighbourhood” subdtree                                                          tree traversal    implementation details improvements               use depthﬁrst algorithm makes use  section presents particular implementation  domain factorisation turns compromise  dtreeplan  used experimentation including reﬁning hole time working preferably  improvements                                         neighbourhoods note breadthﬁrst version strictly                                                        equivalent classical breadthﬁrst abstract planner    abstract actions                                   tree traversal depends πholes func  abstract actions informative regarding fu tion return hole each sequence consecutive ab  ture clusters’ abilities deﬁned types abstract stract actions each abstract action  actions view evaluating relative efﬁciency def mer promising reduce backtracking ex  initions point view cluster level periments use  abstraction                                                          caching    •                    hole actions actions changing variable shared backtracking quite common given node      future clusters way implementing asked times solve subproblem      create action violating frame axiom good way avoid replanning cache solutions      shared variable value action subproblems track subproblems      action preconditions solved strategy adopted mixing      modify variable                        ideas    hole actions quite similar ﬂuentsetting actions amir • each leaf node stored computed plans  engelhardt                                     each encountered subproblem                                                    ijcai                                                      • each internal node stored encountered subprob      lems known unsolvable                               table  effect various improvements                                                                      dtree shape                                                           algorithm    informative produces smaller          scac   csca   cacs    ccas  savings helps reduce space complexity note caching basic                plans using actions lead algorithm shar                  partplan     lidgf                      incrnact                   ing similarities             com    incrmaxh                   pute subplans store memory                                                           caching                       planning satisﬁability  sat planners introduced kautz selman  observed each improvement clearly speeds  encode planning problem propositional formula planning process increase number  solved sat solver adopt approach holes gain limited main exception                 dtreeplan  implementation           using publicly available dtree shape cacs vanilla dtreeplan  zchaff          sat solver moskewicz et al           slower incrnact incrmaxh finally important    choice sat planner lowlevel planner aware reorder procedure produce dtree  advantages makes possible shape scac proves efﬁcient  incomplete plan problem subdomain  amounts specifying values variables appropri  various planning parameters  ate time steps second actions easily encoded sat  locally removing frame axiom variables shared having decided use improvements mentioned pre                                                        vious section conducted second set experiments  future clusters sufﬁces specify values dtreeplan  time related values time  evaluate different parameters table   use abstract actions placed past clusters constraints each column presents planning time seconds given  requiring action replacing matches deﬁnition clustering level   component clustering given type                                                        abstract action  action  action col  controlling plan length                           umn shows results central planning zchaff used  typical sat planners search increasingly factorisation ﬁrst column indicates number  longer plans solution guarantees op batteries segments robotcharger problem  timality partplan lidgf guarantee local sidered  optimality    need backtracking partially depends  number holes generated each plan dtreeplan table  effect clustering level type abstract action                                                            iterates increasing number abstract actions batt        planning parameters                                                             each subplan increase linear lead seg                adding huge number clauses instead algorithm plans                  abstract action  abstract action                    number abstract actions                                                                                                                              experiments                                                                                                                                                     improvements                                                            ﬁrst set experiments aimed evaluating effect                 different improvements added basic dtreeplan                            algorithm actions uses robotcharger prob                       lem described amir engelhardt  robot                             wants upgrade battery charger needs charge                                batteries achieving goal designed vari                              ants changing number batteries lines named  xbatyline    table  reports computation times seconds averaged small domain instances parameter settings ap   runs batline clustering level  pear equivalent clustering level   following versions dtreeplan                  actions bad performance beginning cluster                                                        ing level   actions appears scale better  basic basic dtreeplan improvement section  centralised algorithm planning time ap  incrnact basic incremental number actions   pears unimpressive instances conﬁrms  incrmaxh  incrnact incremental number actions actions good means prune infeasible plans  caching incrmaxh plan caching                   experiment shows components    reorder function used differ effective basis decomposition finally unknown values  ent tree shapes possible denoted order visited  correspond durations  minutes failures  clusters switch connectaddline ca charge memory exhaustion probably linked caching strategy                                                    ijcai                                                    
