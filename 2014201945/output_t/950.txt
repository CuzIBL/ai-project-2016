                                 complete mcsbased search                  application resource constrained project scheduling                                               philippe laborie                                                   ilog                               rue verdun  gentilly cedex france                                              plaborieilogfr                        abstract                            article present pure constraint programming                                                        approach based exploration complete search tree      paper describes simple complete search prove project achieved given dead      cumulative scheduling based detection  line exhibit feasible project exists search      resolution minimal critical sets mcs    procedure based detection resolution minimal      heuristic selecting mcss relies estima critical sets mcs laborie ghallab  each node      tion related reduction search space search mcss carefully chosen using heuristic      extension search procedure using self  tries minimize size search space during      adapting shaving proposed approach    search strong constraint propagation enforced using      implemented classical constraint propaga classical scheduling constraint propagation techniques      tion algorithms tested resource constrained timetabling edgeﬁnding precedence energy balance      project scheduling problems rcpsp      constraints laborie       able close  previously open  section recap deﬁnition resource      problems psplib kolisch sprecher     strained project scheduling problem introduces       improve   best      tations section  describes basic search procedure      known lower bounds heavily studied prob heuristic select mcss section  extends      lems new results openshop cumula  basic search procedure perform selfadapting shaving      tive jobshop scheduling reported            paper consists experimental results clas                                                        sical benchmarks general rcpsp openshop cumulative                                                        jobshop problems general rcpsp show ap    introduction                                       proach closes  previously open instances   resource constrained project scheduling problem  improves  best known lower bounds                                                                                                           rcpsp general scheduling problem famous psplib instances kolisch sprecher    extensively studied literature consists schedul approach using exactely settings used                                                                                              ing project set activities linked prece close hard openshop instances gueret´ prins                                                              dence constraints means set limited resources  cpu time improve best known  minimizing total duration project lower bounds close instances cumulative job                                                                          cision variant rcpsp problem determining shop nuijten    exists feasible project makespan smaller  given deadline nphard strong sense  model notations  rcpsp popular frequently studied nphard op resource constrained project scheduling problem  timization problem  years witnessed rcpsp formally stated follows project  tremendous improvement heuristic exact solu set activities linked precedence  tion procedures cf recent surveys given straints precedence constraints represented di  meulemeester herroelen  hartmann kolisch rected acyclic graph  each node rep   currently best lower bounds makespan resents activity each arc ∈ represents  general rcpsp based solving linear programs precedence constraint let da denote  using adequate cutting planes brucker knust  ﬁxed duration activity ∈ sa resp ea  baptiste demassey  stateoftheart techniques denote decision variable representing start resp end  upperbounds rely metaheuristics genetic al time activity set discrete capacity resources  gorithms ant colony optimization large neighborhood considered each resource ∈ having maximal avail  search scheduling problems job shop cumula able capacity qr entire scheduling horizon each  tive job shop openshop modeled special cases activity ∈ requires nonnegative quantity qa  rcpsp                                             resource problem ﬁnd feasible instantiation sof activity start times precedence resource deﬁnition  resolvers minimal critical set φ ⊆  constraints satisﬁed schedule makespan mini ur mcs resolvers φ set temporal  mal formally                                   constraints resφ    ∈ φ                minimize    max ea                       described laborie ghallab  set                           a∈a                          solvers resφ mcs φ simpliﬁed remove             subject                                resolvers ρ ∈ resφ exists                                                                                                         ∀a  ∈     ≤ sa                     resolver ρ ∈ resφ ρ ⇒ ρ given current                                                        temporal network case resolver ρ                           ea  sa  da                                                        dundant simpliﬁcation procedure achieved            ∀a ∈   ea ≤ sb                  ok size mcs using naive algorithm                                  ∀r ∈ ∀t ∈          qa ≤ qr          line  allows removing resolver  exists                                                         ⇒   ⇒  fol                           a∈st                                                        lows assume set resolvers mcs    st set activities executing time simpliﬁed              st  ∈ sa ≤  ea             algorithm  resolver simpliﬁcation algorithm    resource requirement activity resource  procedure simplify resolversφ  triple   qa            resφ ← ∅  resource requirement denote au   φ  activity ru  required resource qu    φ   required quantity su resp eu denote start   uv ← true  resp end time activity denote       φ   ur   uru    set resource requirements             sv  sw ew  eu  resource ϕ ⊆ ur subset resource require            uv ←  false                                                                       break  ments resource denote qϕ  u∈ϕ qu  global resource consumption activities ϕ        uv                                                                     resφ ←  resφ ∪     search                                                 return resφ    branching scheme                                   each search node branching scheme consists se  branching scheme assumes temporal network rep lecting mcs φ branching possible resolvers  resenting relations timepoints activ children nodes mcs approach  ities start end using point algebra vilain clearly complete  kautz  maintained during search im  plementation ensured precedence graph  heuristics  straint ilog scheduler  ilog  denote    resolvers consist temporal constraints form  ∅ ≺       set qualitative relations  timepoints start end  tween time points represent resource require activity interested estimation size  ments denote  eu  sv search space posting precedence constraint    branching scheme relies notion minimal crit fraction search space preserved adding  ical sets mcs resolvers introduced laborie precedence constraint estimated using complementary  ghallab  mcs minimal set resource commitment measure introduced laborie   quirements resource executed si let timepoints respective lower  multaneously case overconsume resource upper bound time value xmin xmax ymin ymax  mcss natural generalization cumulative schedul size search space estimated cartesian  ing pairs activities conﬂicting unary product domain variables area  resource disjunctive scheduling                   rectangle xmin xmax ymin ymax size  deﬁnition  minimal critical set minimal critical set search space preserved adding constraint  resource subset φ ⊆ ur           rectangle line                                                         illustrated figure  fraction search space    qr  qφ                                       preserved estimated follows let    ∀ϕ  φ qϕ ≤ qr                                                                ymax − ymin  xmax − xmin              su ≺ ev consistent current        uv∈φ×φ                                                  −       −           temporal network                                               max    min      max     min                                                                max   −      −         informally different ways resolve minimal critical min       min    min   min    min  set consist posting precedence constraint cmax  max ymax − xmaxymax − xmax    activities                                  fraction equal                             xy                    preserved search space far current partial                             max                                      mcs  φ∗ best mcs far p∗  preservedφ∗                                 preserved                                 search                 preserved search space best mcs far pro                                 space                  cedure line  calls mcs rating selection process                                                        each resource line  rate select mcss               ymin                                     given resource procedure ﬁrst sorts relevant sets                                                        requirements lines   decreasing order qv                                                        using idv break ties order ensure each mcs                                                      scanned starting smallest mcss                                               min         max                      ones containing greedy requirements pro     figure  preserved search space adding  cedure line  returns true given require                                                        ment possibly overlap requirements partial                                                        mcs given current temporal network procedure                                                        line  computes incremental increase preserved space                            −    −                insertion new requirement current         preservedx         min    max            mcs  φ value preserved described sec                                   ·                 tion  main recursive function selecting mcss    example figure  gives     described line   cmin   cmax   preservedx       ω size search space current search algorithm  mcs selection algorithm  node size search space posting temporal                                                          procedure select  mcs  constraint  estimated ω · preservedx                                                              p∗ ← ∞  φ mcs selected resolved cur                                                              rent search node size search space explore                                                                select  mcsr  low current node estimated sum                                                             return φ∗  sizes search space each child node      ω ·  ρ∈resφ preservedρ preservedφ                                                         procedure select  mcsr    ρ∈resφ preservedρ estimates fraction search  sort ur decreasing  space preserved choosing φ mcs  ur  solve heuristic simply chooses resolve mcs  sort unrankedu decreasing  φ minimizes preservedφ mini  ur  mizes estimation size explored search space  rselect mcsruqu  section provides details mcs selection  algorithm                                             procedure rselect   mcsrφqp                                                             qr                  φ mcs    mcs selection algorithm                                  p∗      φ best mcs far  each search node mcs selection procedure develops       p∗ ←  tree partial mcss current partial mcs φ       φ∗ ← φ  extended adding resource requirement each child node                 φ needs extended  deﬁnition preservedφ clear φ ⊂ φ ⇒      ← lastφ  preservedφ ≤ preservedφ φ∗ best mcs    unrankedu  far partial mcs φ reached   unrankedvφ   preservedφ∗ ≤ preservedφ subtree mcs              dp ← delta   preservedvφ  selection tree rooted φ abandoned                       rselect   mcsrφ⊕vqqvpdp    algorithm selecting branching mcs  precisely described algorithm  using following  procedure unrankeduφ  notations idu unique index associated resource  φ  requirement used break ties unrankedu represents        resource requirements possibly overlap     return false  given current temporal constraints  return true  qv   qu qv  qu idv  idu φ  partial mcs currently extended par  procedure delta preserveduφ  tial mcs represented list resource requirements  dp ←   φ   uk denote uk  lastφ deﬁne   φ  operator ⊕ follows φ⊕u   uk  qφ  dp ← dp  preserveduv  preservedvu  consumption current partial mcs  preservedφ  return dp      note course rough estimate particu  lar estimated fraction preservedφ greater  best mcs φ∗ scanned procedure selected solved current search selfadaptation way average  node mcs simpliﬁed using algorithm  shaving attempts αh lead inference new prece  search explores resolvers ρ ∈ resφ∗ child dence number successful shaving  nodes decreasing order preservedρ order ones deviates αh parameter β adapted  effect schedule feasible case accordingly  αh β decreased β  αh  complete search tree needs explored helps ﬁnding β increased β experiments shaving  solution quicker solution exists            took   α      start β        selfadapting shaving                                 experimental evaluation  shaving techniques torres lopez  provide approach implemented ilog  good framework strengthening constraint propagation scheduler  using timetable disjunctive edge  avoiding late failures discovered search tree ﬁnder precedence energy balance constraints ilog  based following principle adding constraint  experiments described section  current node search leads failure run dell latitude laptop  ghz detailed  propagation constraint ¬c inferred results individual lower bounds each prob  cost propagating constraint potential number lem instance new optimal solutions available  constraints try shave shaving techniques httpschedulerilogfr  general computationally expensive    improve pruning search tree implemented  results general rcpsp  following shaving technique based mcss mcs evaluated approach instances psplib  φ resolvers resφ  ρ  ρk ρk kolisch sprecher     activities  ∀i ∈  adding ρi current schedule leads resp sets each instance solve  failure propagation ρk inferred feasibility problem ﬁnding schedule makespan  complexity shaving given mcs φ size lower  starting legal lower bound   onp  cost constraint propagation incrementing problem shown feasi  current node potentially course ex ble case optimal makespan given time  ponential number mcss shave each search node limit solving problem makespan exceeded  expect mcs allow case legal lowerbound search stops  ferring precedence constraint idea speedup providing legal upperbound  shaving process try shaving subset ﬁrst series experiments use basic search  mcss probability infer precedence scribed section  shaving time limit  straint greater given threshold α parameter α previous best lower upper bounds compare  input shaving algorithm roughly esti ones reported psplib recent  mate probability adding precedence constraint improvements instances reported baptiste    current schedule lead failure demassey  results summarized table   propagation proportional  − preservedx  following columns  ρm   argmaxρ∈resφpreservedρ resolver  mcs  φ maximal preserved search space inter  number instances previously open  ested mcss high probability  number improved lower bounds   solvers ρm fail assume probabil agr average gap distance lower upper    ities independent ones Πρ∈resφρm −   bound reduction bound improved  preservedρ greater given threshold  number closed instances   mcss threshold close   sume preservedρ small ﬁrst  inst       agr                                                                               der approximation Πρ∈resφρm − preservedρ ≈   −             preservedρ reasonable                                 ρ∈resφρm                                                       summarize consider shaving                mcs scanned procedure described algorithm   preservedφ − preservedρm ≤ β β table  results rcpsp selfadapting shaving  ing threshold computation criterion adds timelimit  negligible overhead related maintenance ρm  each mcs mcs selection procedure nu  previously open instances able  merous approximations β taken constant theo improve  lowerbounds average gap reduction  retically equal  − α threshold β computed  close  instances                                                          show effect selfadapting shaving run ver    note estimation exact extreme points sion approach using selfadapting shaving  preservedx    propagation fail sure  preservedx    propagation fail  instance lowerbound pert temporal  discovered given current domains straints       inst      agr                     inst       agr                                                                                                                                                                               table  results rcpsp selfadapting shaving table  results rcpsp selfadapting shaving  timelimit                                  timelimit    timelimit results summarized ta   instance ub  optim instance ub  optim                                                               gp    gp    ble   previously open instances able gp    gp    improve  lowerbounds average gap reduction    gp    gp     close  instances main conclusion   gp    gp                                                                 gp    gp    timelimit addition selfadapting gp   gp    shaving slightly increases performances curves  gp    gp    respectively show particular instance   gp    gp    number search nodes given depth search  gp    gp                                                                 gp    gp    tree each node depth ratio number  gp    gp    selected mcss effectively lead inference gp    gp    new precedence total number mcss selected     gp    gp                                                                 gp    gp    shaving clearly region search space gp   gp    nodes concentrated depths     gp    gp      ratio effectively close target ratio gp   gp     instance  nodes explored   mcss selected shaving  ef table  results openshop selfadapting shaving  fectively lead inference new precedence  timelimit                                                           approach settings previous section                                                     openshop problems instances proposed gueret´                                                     prins  instances considered                                                     hard instances openshop problems serve classi                                                     cal benchmark openshop scheduling instance                number nodes                       cent work blum  benchmark consists                                                 instances ranging  jobs ×  machines problems                                                         jobs ×  machines problems  problems                      search depth                       instances open using approach able                                                       close instances cpu time op                                                     timal makespan  previously open instances sum                                                        marized table  column ub corresponds                                                     currently best known upperbound optimality                                                     proof did exist                   actual shaving ratio                target shaving ratio                   experimented open instances                                                       benchmark brucker et al  closed                                          open instances jper    optimal                                                        makespan  jper  optimal makespan                       search depth                                                        jper   optimal makespan     given selfadapting shaving slightly improves  formances time limit used  results cumulative jobshop problems  conﬁguration extended timelimit  sults summarized table   previously tested approach settings cu  open instances improve  lowerbounds mulative jobshop problem benchmark described nuijten   previously open instances average  instances derived classical jobshop  gap reduction  close  instances scheduling problems multiplying number jobs   previously open instances           number activities capacity                                                        sources given factor × × results summa    results openshop problems                    rized table  lb lower bound using  openshop problems represented special cases sistency checking described nuijten  newlb  rcpsp resources unit capacity ad new lower bound approach able close  ditional unary resources used model fact ac ft× ft× instances improve  tivities job overlap tested  lower bounds  open instances
