               strong    equivalence     logic   programs       preferences∗                         wolfgang   faber†                           kathrin   konczak                  department  mathematics                      institut fur¨ informatik                     university calabria                        universitat¨ potsdam                   rende  cs italy           pf     potsdam  germany                  email  fabermatunicalit              email konczakcsunipotsdamde                        abstract                          context gives handle showing equivalence                                                        asp modules program strongly equivalent      recently strong equivalence answer set pro  subprogram use subprogram      gramming studied intensively    instead original program technique serves      shown beneﬁcial modular programming     effective optimization method      automated optimization paper    different line asp research extensions      ﬁne novel notion strong equivalence logic basic formalism proposed inten      programs preferences based deﬁnition sively studied modeling preferences asp cf      semantics preference han delgrande et al  strongly rooted research      dling necessary sufﬁcient conditions pro nonmonotonic formalisms ability specify preferences      grams strongly equivalent results pro acknowledged particularly beneﬁcial asp      vide clear picture relationship se constitute natural effective way resolving      mantics respect strong equivalence indeterminate solutions example preferences      differs considerably relationship successfully used timetabling auctioning conﬁguration      spect answer sets finally based results domains sophisticated application informa      present ﬁrst time simpliﬁcation methods tion site selection described eiter et al       logic programs preferences              emergence applications calls opti                                                        mization methods standard asp    introduction                                         paper tackle issue generalize                                                        tion strong equivalence asp preferences  during  decade  answer  set  programming    plethora formalisms semantics introduced  asp gelfond lifschitz  extending asp preferences limit  creasingly acknowledged tool knowledge representation paper concrete approaches basic clas  reasoning main advantage asp based siﬁcation preference handling elements  solid theoretical foundations able model preference deﬁned ii way preferences  commonsense reasoning arguably satisfactory way interpreted particular aggregated  availability efﬁcient solvers furthermore stimulated work focus ordered programs prefer  use practical applications recent years devel ences deﬁned rules semantically act ﬁl  opment quite implications asp research ters answer sets particular consider three se  example increasingly large applications require features mantics deﬁned delgrande et al  wang et al   modular programming requirement fact brewka eiter  referred   applications asp code generated automatically semantics respectively reason choice  socalled frontends calling optimization methods semantics widely accepted prop  remove redundancies database query erties interrelationships fairly wellunderstood  optimizers purposes recently suggested contributions work follows deﬁne                                    notion strong equivalence asp lifschitz et al  notion strong equivalence ordered programs turns               turner  used asp programs deﬁnition standard asp straightfor  strongly equivalent used interchangeably wardly extended main reasons  “union”    ∗the ﬁrst author partially supported ec project dered programs needs deﬁned properly   ist infomix second author partially sup “union” ordered programs yields valid ordered program  ported german science foundation dfg grant scha overcome problems deﬁne notion admis   tp authors partially supported ec sible extension provides general method deﬁning  der project ist wasp                      strong equivalence arbitrary structures show    †funded apart austrian academy sciences properties strong order equivalence providing necessaryand sufﬁcient conditions programs strongly order higher priority ri formally ordered logic program  equivalent explore relationship strong order olp understood quadruple Π    equivalence three semantics studied paper Π logic program bijective function Π  relationship strong equivalence standard logic set names   set preference relations  programs based results study applicability Π possible leave implicit  program simpliﬁcation rules known standard asp just write Π  olps write  ∅  presence preferences obtain partial order given Π ∅ denotes logic program  simpliﬁcations applied particular contexts interpretation rule higher priority  main results work relationship rule precise different ways fol  three preference semantics changing strong equiva lows consider three interpretations d– delgrande  lence preferences “compiled away” et al  b– brewka eiter  – prefer  modular fashion omit proofs page limit  ence schaub wang  given Π                                                         use  selecting preferred answer sets standard    background                                         answer sets Π recall deﬁnitions se                                                        mantics   answer sets logic program lp ﬁnite set rules                                                        deﬁnition  let Π  olp answer set  ←      pm pm     pn                                                                 Π  –preserving enumeration hr ∈  ≥   ≥  each  ≤ ≤  atom                                                                                                      Π exists st ∈  rule let headr denote head  bodyr body     pm pm     pn  ri  rj                                              −          body         body                                   let                                        ri ∈ rΠx body ri ⊆  headrj   rj ∈  pm     pn set rules Π write headΠ                                             −               rΠx    headr  ∈ Π program basic body  ∅                                                           ∈ Π  rΠx  rules reduct Πx  program Π relative                                                                set atoms deﬁned Π  headr ← body   body ri ⊆             −  ∈ Π body ∩   ∅ set atoms closed         −                                                         body ri ∩ headrj   rj ∈ rΠx   ∅  basic program Π ∈ Π headr ∈                                                                                            Π  body ⊆ smallest set atoms closed cond stipulates enumeration compatible                                                              der basic program Π denoted cnΠ set  cond makes property supportedness explicit  atoms answer set program Π cnΠx   answer set generated supported se                                                                         use asΠ denoting set answer sets Π quence rules –preferences rules supported  follows important concept generating lowerranked ones conda separates handling  rules answer set given set atoms Π deﬁne supported rules preference handling condb guaran                                   −                   tees rules blocked lowerranked ones  rΠx   ∈ Π  body ⊆ body ∩  ∅    strong equivalence answer set semantics deﬁnition  let Π  olp answer set                                                                          lps Π Π regarded equivalent denoted Π ≡ Π Π  –preserving enumeration hriii∈i  iff asΠ  asΠ  lps Π Π strongly  Π exists st ∈  equivalent denoted Π ≡s Π iff lp Π pro  ri  rj    grams Π ∪ Π Π ∪ Π equivalent Π ∪ Π ≡                                                         ri ∈ rΠx  Π ∪ Π shown lifschitz et al  strong equiv                                                                  alence closely related nonclassical logic body ri ⊆ headrj   rj ∈ rΠx   andthere adapted logicprogramming terms                                                         headri ∈ headrj   rj ∈ rΠx   turner turner  let Π lp let ⊆  ⊆  pair  semodel Π  ri ∈ Π  rΠx                        sea                                   Π    Π        Π denote   body ri ⊆  set semodels Π usually set left                                                            body −    head           implicit just writes seΠ lps Π     ∩      ∈ Π         ∅  Π Π ≡s Π iff seΠ  seΠ turner    headri ∈ headrj   rj ∈ rΠx     preferences logic program Π said ordered –preference concept order preservation  set terms serving names rules pref d–preferences weakened condition   suspend  erence relation ⊆ × strict partial order ing conditions head preferred rule  rules write  names ∈ rules derivable alternative way  Π furthermore assume bijective function                                                  deﬁnition  let Π  olp answer set  signing each each rule ∈ Π    ∈                                                                                                                         ∈  simplify notation usually write ri instead nri Π –preserving enumeration iii                                                                              ri ∈ Π given ri rj ∈ Π ri  rj states rj Π exists st ∈                                                         ri  rj      version paper including proofs http  wwwwfabercomresearchpublications                  following index set       Π  ri ∈ Π  rΠx                                                                                       ∗  ∗                            ∗        ∗  body ri ⊆                                  Π       ←  ←            −                                                     ∗                                  ∗   ∗  body ri ∩ headrj   rj ∈ rΠx   ∅  strict partial order Π                                                           olp avoid deﬁne notion admissible  headri ∈                                                        extensions olp  b–preference drops cond decoupling preference han                                                                                     dling order induced consecutive rule applications deﬁnition  let Π  Π  olps                                                                                                  σ ∈ deﬁne asσΠ  set    Π    admissible extension Π  Π ∪                                                              σpreserving answer sets olp Π  shown Π ∪     olp  schaub wang  three strategies yield remark notion compatibility orderings  increasing number preferred answer sets d– deﬁned brewka eiter  similar spirit  preference stronger –preference stronger admissible extensions concerns order relation  b–preference stronger preference rules program  precisely asdΠ  ⊆ asw Π  ⊆    analogously normal logic programs deﬁne  asbΠ  ⊆  asΠ  addition asσΠ ∅  notion equivalence olps  asΠ σ ∈                              deﬁnition  order equivalence let Π                                                          Π  olps σ ∈  Π                                                                      σ                           σ    strong  order   equivalence                        Π   equivalent denoted Π  ≡ Π                                                           asσ           asσ         section deﬁne variants equivalences olps iff Π    Π     deﬁning “standard” equivalence programs permit pre deﬁnition strong equivalence logic pro  cisely answer sets straightforward considering grams interpreted having answer sets  respective preferred answer sets                 extension employ notion admissible extensions    concerning notion strong equivalence deﬁning analogon olps  caveats standard programs strong equiv deﬁnition  strong order equivalence let Π   alence Π Π holds program Π Π ∪ Π Π  olps σ ∈                                                                                                 σ  Π ∪ Π equivalent preferences Π  Π  strongly  equivalent  account Π  Π  Π  iff admissible extensions Π  Π   strongly equivalent Π ∪ Π  ∪  Π ∪ Π  Π  holds Π ∪ Π  ∪  Π ∪ Π   ∪  equivalent problem Π ∪ Π  ∪  ∪  σ equivalent  necessarily olp issues  rule label                                                                            ≡σ  clashes  partial order clashes                abbreviatory write olps strongly                                                        σequivalent    rule label clashes different rules  rule different names resolved  renaming say Π ∗ n∗ ∗ renaming  properties relationships  Π   ∗ new set names rules n∗ want characterize conditions olps  bijective function assigning each rule Π unique fulﬁll st strongly order equivalent  ∗ n∗r ∗ n∗r holds iff nr  nr theorem states strong order equivalence im  ∈ Π union olps deﬁned follows plies strong equivalence underlying logic programs                                               deﬁnition  let Π   Π      theorem  let Π  Π  olps σ ∈                                                                             σ  olps  disjoint sets rule names     Π  ≡s Π  Π ≡s Π    deﬁne union Π   Π        ∗   ∗  ∗   ∗                                      intuitively logic programs strongly equivalent  Π                                 extension admits answer set    • Π∗  Π ∪ Π                                       answer set extension program corre        ∗                                               sponding ordered extensions answer sets    •  new set names rules                                                        means inhibited preferences       ∗                    • ∈ Π ∪ Π bijective function assigning construct extension regenerates                                        ∗      each rule Π ∪ Π unique       program example programs    • ∗  ∪   ∈ Π ∪ Π n∗r ∗       ∗                                           Π ∅     ←       holds nr  nr    Π    ←  ←       holds                                                        preferred answer set Π ad  usually leave ∗ n∗ implicit                                                        ditionally answer set taking Π ∅   ←  write Π ∪ Π  ∪  union Π  Π                                                          ←  yields preferred answer set    observe union olps necessarily                                                        Π∪Π ∅ preferred answer set Π∪Π   olp consider                              note create “compensating” program        Π    ←  ←      answer set inhibited preference rela        Π    ←  ←      tion use new symbols new rules                                                                                       involved preference relation “repair” answer yields Π ∪ Π   ∅ Π ∪ Π    set strong equivalence necessary condition rule used block   strong order equivalence                             preferences ordered    turn attention set generation rules used block  consider following olps                  following concentrate preference               Π ∅   ←  ←             lations consider program             Π ∅   ←  ←                                                                     Π    ←  ←    observe Π ≡s Π taking                                                                    σ       ∗   ∗                                 ∗          preference relation  obtain Π ∅ ≡     Π      ←  ←    Π  holds σ ∈ Π ∅ Π                   σ        ∗  ∗        σ        ∗  ∗  yields ∈ Π ∪ Π    Π ∪ Π   coincide set rules Π ∅ rule    ∅ σ ∈  strongly order considered rule preference  equivalent coincide set gener derivation positive body depends  ating rules Π ∅ contains Π ∅ rule derive adding preference relation  Π ∅ effect                                                             atom adding preference higher pre    preferred answer sets surprisingly does                           ∗   ∗  ferred entails Π∪Π    preferred answer hold considering strong order equivalence taking  set blocked lower preferred rule         ∗   ∗                                                        ←    ←       ←  Π ∪ Π    preferred answer set allows                                                           Π       ←  ←  ←  block alternative way allows suppose                                                                                              strong order equivalence enforces olps coin                         cide rules applicable yields asσΠ ∪ Π   asσΠ ∪  say rule ∈ Π contributes answer set                                ∗                     ∗                      Π   ∪    ∅ Π ∪Π    transitive  exists Π ∈ asΠ∪Π  ∈ rΠ∪Π∗                                                        preference  implying blocked lower  rules contributing answer sets ap                                                                   −                            preferred rule don’t obtain Π ∅ ∪ Π    plicable body ∩ body  ∅ b–preferences  construct program observe  obtain strongly order equivalent programs relevant rules contain new symbols follows  coincide rules contributing answer sets  olps strongly equivalent preference  theorem  let Π  Π  olps     relations coincide             Π  ≡s  Π  Π ∈                                                        theorem   let Π  Π  olps σ ∈  asΠ  ∪ Π    asΠ  ∪  Π  rΠ∪Πx                             σ                                                        Π  ≡s Π    rΠ∪Πx                                                                                           σ  interestingly d– –preferences conditions special case obtain Π ∅ ≡s Π  holds  weakened                                  program Π nonempty preference relation Π                                                        σ ∈ olp Π    theorem  let Π  Π  olps σ ∈                                                                    σ                                  ∅ exists strongly order equivalent program Π  ∅   Π  ≡s Π  Π  ∈ asΠ  ∪Π  asΠ  ∪Π rΠ∪Πxr  ∈    corollary  let Π  olp  ∅                                                                                                       Π∪Π   headr ∈ body  rΠ∪Πxr ∈ Π∪Π     σ ∈ exists logic program Π                                                                   σ     headr ∈ body                                  Π  ≡s Π  ∅   preferences couple rule application interestingly tells transformation  preference handling answer sets inhibited prefer olp nonempty preference relation logic program  ences applied rules enumerable order exists transformed program strongly order  preserving way condition  deﬁnition   equivalent original results given  ﬁnd extension sufﬁcient characterizing strong order equivalence  swer sets regenerated applied “loop” rules                                                       theorem   let Π  Π  olps Π ≡s  headr ∈ body rule exist                                                        Π    Π ∈ asΠ ∪  derives head order preserving way loop                                                        Π  asΠ  ∪ Π rΠ∪Πx   rΠ∪Πx  rules redundant wrt  preferences long                                                             Π  ≡  Π   involved preference relations contrast  preferences decouple preference handling rule ap theorem  let Π  Π  olps σ ∈  plication ﬁnd extension  Π ≡s Π  Π    loop rules regenerate nonpreferred answer set ∈ asΠ ∪Π  asΠ ∪Π rΠ∪Πxr ∈                                                                               preferred program Π∪Π  headr ∈ body  rΠ∪Πxr ∈ Π∪Π   example                                                                              σ                                                        headr ∈ body Π  ≡s Π                                      Π ∅     ←   Π  ∅     ←     ←       example  strongly equivalent taking                                                                 Π ∅   ←  ←       Π    ←  ←               Π ∅   ←  ← aare strongly order equivalent three semantics corollary expresses rule applicable                                                        involved  redundant regarding strong order   Π ∅   ← Π ∅   ←  ← equivalence corollary concentrates loop rules                                                    corollary  let Π  olp σ ∈  fur  strongly     equivalent strongly                                equivalent results formalize fol thermore let ∈ Π st headr ∈ body                                                                                  σ  lowing characterization strong order equivalence  involved  Π  ≡s Π                                                            eiter et al  osorio et al  transformations  corollary  let Π  Π  olps                                                      logic programs reported used sim  Π  ≡  Π  iff Π ≡s Π                                                       plifying program modular transformations  Π ∈ asΠ ∪ Π   asΠ ∪ Π                                                        program strongly equivalent transformed  rΠ∪Πx   rΠ∪Πx                                                        considering olps observe transformations  corollary  let Π  Π  olps σ ∈ general guarantee strong order equivalence transfor                           σ   Π  ≡   Π  iff Π ≡s Π   mation taut expresses logic programs Π                                                                                    Π ∈ asΠ ∪ Π     ∈ Π headr ∈ body Π ≡s Π     asΠ ∪ Π rΠ∪Πx  ∈ Π ∪ Π  headr ∈ corollary  implies analogon olps holds        body   rΠ∪Πx   ∈  Π ∪ Π   headr ∈     semantics long involved                                                        transformation red− expresses logic pro  body                                                                                          −                                                        gram Π rules headr ∈ body  regarding preferred answer sets different strategies bodyr  ∅ Π ≡s Π   preference handling yield increasing number preferred generating rule regardless rules add                                                                                                       −  answer sets interestingly given theorems show Π contributes answer set red  difference behavior d– – feasible olps unless involved  ∈ Π                                                                           −  preferences considering strong order equivalence body ∩ body  ∅ Π ≡s Π   contrast fewer programs strongly order equivalent transformation contra rule ap  b–semantics preference handling decoupled plicable result carried olps  rule application                                     rule involved  transformation nonmin                                                        states ∈ Π headr  headr  theorem  let Π  Π  olps                                                    bodyr ⊆ bodyr Π ≡s Π  holds  Π  ≡s Π  Π  ≡s Π                                                     information appli  Π  ≡ Π  iff Π  ≡ Π                                                     cable transformation olps                               considering answer sets each  preferred answer set involved  applica  preferred each preferred bpreferred ble example consider program  terestingly regarding strong order equivalence obtain                                                     Π ∅   ←  ←  ←  ←  ≡s  iff ≡s  differences  se  mantics compensated extending program                                                  headr  headr bodyr ⊆  suitable way ≡s implies ≡s ≡s im                                                      bodyr Π ≡s Π applicable  plies ≡s  bsemantics imposes strictly stronger crite simpliﬁed program strongly order equivalent taking  rion programs strongly order equivalent reason                                                              ∗  ∗                                 ∗  bpreference decouples preference handling Π      ←  ←   rule application addition differences            σ        ∗   ∗         σ                                                        yields ∈ Π ∪ Π    Π   compensated adding suitable extensions             ∗   ∗                                     σ                                                        r∪Π      ∅ σ ∈ Π ∅ ≡s                                                        Π  ∅ similar considerations apply trans    program    simpliﬁcations                          formation simp ∈ Π                                                                         −                                                        exists ⊆ body headr ∈ headr ∪  corollaries   show olps         −          −                                                        body ⊆ body  body ⊆ body  strongly order equivalent differ rules                                                                    Π ≡s Π   transformation car  volved preference relation appli                     cable additionally  semantics strongly order ried olps involved   equivalent logic programs differ loop rules applicable example taking  head contained positive body results al    Π    ←  ←  low formalize following results concerning transfor                                                                                             mations olps following say rule  yields Π ≡s applicable wrt                                                                                         σ  involved preference relation  exists ∈ asΠ ∪ ← Π ∅ ≡s ∅    holds                                                        Π∗ ∗    ← ry  ← rb  ← ∗ ry              let Π  olp ∈ Π  corollary                                                                    ∗  ∗  involved  Π ∈ asΠ ∪ Π b ∈ asσΠ ∪ Π    ∅  asσr ∪                                     σ                     ∗  ∗  ∈ rΠ∪Π Π  ≡ Πr  holds Π    σ ∈ transformation wgppe states                                                                                      σ ∈                                    rule ∈ Π ∈ body ga  ∈ Π 
