       use offline dynamic programming efficient image interpretation                            ramana isukapalli                                     russell greiner                       crawfords corner road                       department computing science                          lucent technologies                                 university alberta                        holmdel nj  usa                          edmonton ab tg canada                   risukapallilucentcom                              greinercsualbertaca                               abstract                               access inventory imaging operators — like edge de•                                                                 tectors region growers corner locators each        interpretation finds likely mappings                                                                  applied portion image returns meaningful        portions image realworld objects                                                                  tokens like circles regions color inter•       interpretation policy specifies apply                                                                  pretation policy specifies operator apply        imaging operator portion image                                                                  portion image during each step interpretation        during stage interpretation earlier results                                                                  process policies course specify details        compared number policies demonstrated                                                                  specifying exactly bottomup operators        policies select operators maximize                                                                  use portion image switch        information gain cost worked effec•                                                                 bottomup topdown aspects model        tively policies myopic —                                                                  seek        rank operators based immediate re•       wards lead inferior overall results        earlier work llgolb considered various types poli•       better use relatively expensive operator      cies demonstrating information theoretic        operator provides information    policy selects operators maximize informa•       significantly reduce cost subsequent op•       tion gain unit cost imaging operator work ef•       erators                                                  fectively figolb policies evalu       suggests using lookahead process             ate each operator myopically — independent        compute quality operators nonmyopically         cost effectiveness subsequent operators        unfortunately prohibitively expensive        applied performing prob•       domains especially domains          lematic assume task determine        large number complex states use          airplane image seeking various parts air•       ideas reinforcement learning compute          plane — fuselage wings engine pods tailpiece        utility each operator sequence particular     consider oep operator detects locates en•       uses dynamic programming ab•           gine pods engine pods small partially       stract simplifications interpretation states pre  occluded oep probably expensive        compute utility each relevant sequence         parts located expect associated wings        does offline training sample images     easily remaining parts required identify        run time interpretation uses es•     entire airplane myopic policy evaluates oper•       timates decide use imaging oper•         ator based immediate cost miss connec•       ator empirical results challenging real     tion probably prefer cheaper operator        world domain face recognition demonstrate        expensive oep better policy consider operator in•       approach works effectively myopic          teractions relating oep say wing finder opera•       approaches                                               tor deciding operator apply data sec•                                                                 tion  related complex task face recognition shows                                                                  nonmyopic policies accurate    introduction                                                 efficient   interpretation process finding likely mapping      course nonmyopic policies use type   portions image realworld objects ba• lookahead evaluate quality operators   sis number imaging tasks including recognition  combinatorially expensive compute address con•  objectx image identification object   cern  dealing abstract version interpreta•  image forms tracking   tion state space  using dynamic programming   moving objects typex sequence images      techniques abstracted space precomputing   pl hr important interpretation sys• relevant utility sb values offline bdb partic•  tem efficient accurate  ular computes utility imaging operator se      vision                                                                                                                quences each state encountered based data set specifies particular task subsection  lists strategies    training examples produces policy maps each   evaluate subsection  outlines performance do•   state operator appears promis•   main face recognition subsection  describes spe•   ing incorporating lookahead runtime    cific operators use    finds best matching state applies operator associ•   ated situation empirical results domain  input interpretation    face recognition show policies work effectively assume interpretation given fol•   — better best results obtained earlier lowing information    myopic systems                                                distribution images encounter      section  presents relevant related work help frame encoded terms distribution objects views    contributions section  discusses salient features inter• seen face recognition task corre•   pretation strategies section  presents approach sponds distribution people    using reinforcement learning image interpretation  varies race gender age poses    domain face recognition using operators each cor• sizes approximate using images given train•   respond types eigenfeatures section  provides empiri• ing set figure     cal results support claims                          • task — includes parts                                                                  specifies objects seek     related work                                                return second task specification provides                                                                  evaluation criteria policy based    produce interpretation image applying se•    expected accuracy maximum interpreta•   quence operators each operator maps current     tion cost exceed    state typically partial interpretation new state specifies task identify person    effects operator depend information explic•  hisher given test image wrt people included train•   itly contained state description mapping stochas•                                                                 ing set subject accuracy cost requirements    tic each operator cost state associ•   ated final interpretation quality ac•                                                                  set possible operators includes say    curacy interpretation view image                                                                 various edge detectors region growers graph matchers    interpretation task markov decision problem mdp                                                                  each operator specify   means apply host reinforcement learning       • input output    techniques sb problem specific application    • effectiveness specifies accuracy   area image interpretation follows pioneering work       output function input   draper bdboo shows dynamic control policies        • cost function size input pa•  outperform handcoded policies extend work            rameter setting   addressing exploiting issue operator interactions   doing systematic analysis cost accuracy    use specific set operators face recognition   tradeoffs face recognition                                 task section       encode each state entire image    borrowing mdp literature view main in•  unwieldy boutilier et al bdh survey sev•    each operator state dealing   eral types representations planning problems discuss scenes use entire pixel image   ways exploit ease computational cost policies state reasons efficiency use   plans work focuses abstraction aggregation   abstracted view interpretation scene   decomposition techniques use abstractions reduce    section  presents specific abstraction using   size each state state space explor•                                                                  strategies   ing concerned general plan•  ning problem similar forest inventory   strategy infogain selects operator provides   management bdl output        largest information gain unit cost each step   operators provide input operator    myopic strategy computes expected information gain   result operator used nar•         each possible operator argument combination   row search operator sys•     cost executes operator   tem exploit structure specific task bound maximizes ratio    lookahead depth                                                 focus strategy number earlier empirical                                                                  studies demonstrated best my•   framework                                                    opic strategies considered number taskcontexts                                                                  domains including simple blocks world car   suggested overall objective produce ef•                                                                 recognition identifying make model car based   fective interpretation policy — efficiently returns                                                                  tail light assembly face recognition   sufficiently accurate interpretation accuracy ef•                                                                 considered    ficiency each measured respect underlying task   distribution images encountered  strategy bestseq selects operator appears   section makes framework precise subsection       promising current abstract state fs                                                                                                                     vision given utility opti•                       face probability feature probabilities val•  mal mapping state actions section  details uesfeature  corresponding set    face recognition task                                      values each individual   investigate efficiency accuracy strategies   compute   listed domain face recognition tp pms   pwhr ec section briefly discusses promi•  nent eigenface technique face recognition forms   basis approach presents framework describ                                                              ing representation operators use identify   faces finally presents face interpretation algorithm   identifying person given image hisher face   eigenface eigenfeature method todays                                                                  scaling constant   face recognition systems use principal component analysis   pca tp given set training images faces      operators   forms covariance matrix images use classes operators   computes main eigenvectors eigenfaces ev•                                                                  ery training face projected coordinate space detect respectively left eye right eye nose   facespace producing vector                              mouth each specific operator takes pa•     during recognition test face similarly projected    rameters  specifies number   facespace producing vector         eigenvectors considered parameters   compared each training faces best matching                specify space operator   training face taken interpretation tp        sweep looking feature look      following pms extend method recognize       rectangle sweep pixels   facial features — eyes nose mouth — use  centered    help identify individual given test image parti• each instantiated operator takes input im•  tion training data sets construct•           age test face returns probabilistic distribution   ing eigenfeatures collecting statistics           individuals three subtasks locates   each set contains face each peo•  feature entire face   ple feature regions training data extracted   use simple template matching technique search   using operators explained  verified manually fixed region size pixels centered pixel   correctness letting denote person face                       projects relevant region test im•  given                                               age feature space — computingof dimen•  each remaining maps                                sion  subtask uses compute values                                                                                           each person com•     use pca mouth regions each image pro•                                                                 pute probability each person   duce set eigenvectors eigenmouths each face                                                                  use equation  update distribution consid•  image let feature space encoding                                                                   ering nd subsequent features igolb each   mouthregion later compare feature space encod•                                                                 eigenspace dimension empirically determined cost   ing new image vectors milliseconds operators —   assumption suggests htcst   really person — finding small   suggest note refers    norm aka euclidean distance quantify strong   belief compute values  size range increas•                                                                 ing dimensionality feature space improve   each euclidean distance                                                                  accuracy result explicitly   eigenmouth encodings                                                                   increase cost        using training data learn mapping   values probabilities                                   use dynamic programming       use estimate                               section briefly overviews mdps presents state abstrac•  igolb details                                     tion face recognition shows dynamic program•     compute similar estimates facial features ming used compute utility operators ab•  nose left eye le right eye use           stracted states discuss operator interaction de•  naivebayes assumption dh features inde•    scribe exploited face recognition   pendent given specific person  compute cumulative                                                                  uation classification work      course assumption assuredly false sit practice mit       vision                                                                                                                 markov decision problem    markov decision problem described tuple                 — finite set                             — distance pixels centers    states — finite set ac•                              feature small     tions state transition proba•                                                                 using normalized images contain faces    bility function probability                                                                  denoting distance absolute pixel values issue    taking action situation leads state                                                                  general small predefined constant used                       reward agent gets taking     result abstraction large number complex   action state markov property holds           states described small number compact state   transition state using action depends       descriptions course abstract state represent   st previous history policy           multiple states    mapping states actions policy      use lookahead algorithm compute £values   define utility function                            consider features need lookahead                                                                  depth during training                                                                  phase use reward function     corresponds expected cumulative rewards ex•                                                               ecuting apparentlyoptimal action state follow•  ing policy                                         penalizes each operator times time re•     given mdp naturally seek optimal policy           quired seconds positive score obtaining   policy produces cumulative reward         correct interpretation represents correct identity   each state dynamic programming provides way              person image used   during   compute optimal policy computing utilities training phase finds optimal operator sequence   best actions course given values optimal          maximum     action each state simply                               value based abstracted state         challenging general setting se•    dynamic programming   quences actions map state    section shows compute utility values   work reinforcement learning sb designed ad•       tree expansion use classes operators —   dress issues current case                                                        each   partial order states meaning sequence  different values   actions map state use dynamic    total  operators section  parameters   programming compute optimal utility each final             specify rectangular area   step use values compute optimal action operator search does search   utility each penultimate state forth             values instead directly computes values    state abstraction                                          locations features   mdp involves states face recognition task    detected section    attempt define states terms pixel values image expands operator tree exhaustively using   problematic far states  depthfirst search course depth tree   enumerate following bdboo bdl use notion        consider instance each   abstract states basically redefines original state operator path   compact form using certain aspects    computing compute various utility values us•  state recognize person using features  ing dynamic programming approach   define abstraction function                                   apply sequence  different operators                                                               original image produce set possible leaf                                                                  states setwhere   actual complex state present image                                                                  correct interpretation observed locations           denotes location center feature left eye                                                                  various features   right eye nose mouth image total   cost spent far                            ii consider each state involves set                                                                   operators each consider    possible ac•  current posterior distribution possible faces based                                                                  tions apply remaining operator   current evidence location feature                                                                   possible values trivially compute util•  known image use value                                                                  ity each option action   say abstractions   equivalent written                                                             action takes time ta produces        • si « located set features         value  entries                                                              totally                                                                                                                     vision     figure  training images test images    state setto largest  val•   ues action produced largest    values      computing depth states    recur deal depth states forth             figure  policy learned bestseq      course states actually refer ab•   stracted state bin values sup•                                                                 features right eye model lin•  pose encountered abstracted state                                                                  ear function mapping location left eye    later state  de•                                                                 expected location right eye left eye detected   termine reset                                                                  expected location right eye   value values                                                                  window model                                                                     variance — size search window   retrieving promising operator during interpre•        expected position precise let assume   tation entire procedure computing optimal policy  search window feature size        offline during training phase during inter• pixels detecting feature instead search   pretation performance phase state    smaller regioncentered location   nearest neighbour sum distances         computed location using linear function   corresponding features observing features say nose left eye   minimum possible entries ii return oper• estimates location current fea•  ator instantiated                        ture right eye smallest bounding box   operator — say    notstop        use search area locating current feature   runtime executes operator locate  factoring means need consider set     feature produces new state updating total cost   transformations each feature versus   posterior distribution determines three features deal possible subsets   action perform forth                                 make ideas concrete initially given      place perform differ•   information look right eye region   ently policy dictates maintaining                    finding left eye loca  actual cost far actual posterior distribution                   knows asked look   interpretations runtime actually terminate right eye search region   actual cost exceeded specs highest committing looking right eye   probability minimal acceptable value             time just indicating search requested notice      notice given specific setup —  types op• region different consider   erators executed suc•  located left eye knew   ceed — policy obtained viewed straight nose location   left eye   line policy seek specific feature   use refined region —    achieving termination condition figure  ex•  ample general basic dynamic programming approach   produce complex policies                            image interpretation policies                                                                  during interpretation infogain policy produced    operator dependencies                                      bestseq each iteratively select operator   face recognition exploit certain type op• recall values £ determined con•  erator interactions using result operator sim•  text detected features need   plify subsequent detecting feature  specify infogain chooses instantiated op•  say left eye expect idea  erator maximum        vision                                                                                                               
