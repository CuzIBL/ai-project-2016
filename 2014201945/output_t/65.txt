                       fast complete symbolic plan recognition                             dorit avrahamizilberbrand       gal kaminka                                       science department                                         bar ilan university israel                                        avrahadgalkcsbiuacil                          abstract                          vations continuous actions maintained time                                                        instance observation soccer player include      recent applications plan recognition face sev team uniform number current position velocity      eral open challenges matching observations   computational cost matching observations      plan library costly especially com possible plansteps nontrivial grows      plex multifeatured observations ii computing  complexity observation tuple existing inves      recognition hypotheses expensive present   tigations ignore cost second exceptions exist      techniques addressing challenges ing algorithms focus current state query egtambe      show novel application machinelearning   rosenbloom  bui  far      decisiontree efﬁciently map multifeatured ob ignore tambe rosenbloom  portions wærn      servations matching plan steps second pro stenborg  observation history      vide efﬁcient lazycommitment recognition algo   able utilize negative evidence expected action      rithms avoid enumerating hypotheses ev observed      ery observation instead carrying book    paper focuses set efﬁcient algorithms      keeping incrementally algorithms answer      tackle challenges develop method auto      queries current state agent matically generating matching decisiontree efﬁciently      history selected states provide empirical matches multifeature observations plan library sec      results demonstrating efﬁciency capabili ond provide algorithms efﬁciently answering cur      ties                                             rent state state history queries lazycommitment                                                        algorithms avoid computation hypotheses step    introduction                                                                           plan recognition process inferring agent’s algorithms geib harp   instead use  plans based observations interaction en lineartime current state polynomialtime statehistory  vironment recent applications plan recognition require bookkeeping observation allows extraction  observing agents behavior reactive rao  hypotheses needed algorithms complete  observed agent interrupt plan execution switch admit recognition hypotheses consistent  different plan applications include intrusion history observations symbolic pro  detection applications geib harp  virtual train vide hypotheses ranking probabilistic  ing environments tambe rosenbloom  visual explore performance recognition algorithms  monitoring bui                                simulated data show signiﬁcantly    general plan recognition relies plan library plans faster previous techniques efﬁciency com  potentially executed observed agent typically pleteness make particularly suited hybrid plan recog                                                                                                 plan library composed toplevel plans hierar nition approaches geib harp    chically decomposed recognizer matches observations symbolic recognizer ﬁlters inconsistent hypotheses passing  speciﬁc plan steps library infer probabilistic inference engine  swers plan recognition queries currently se  background related work  lected toplevel plans current state query ordered focus brief discussion closely related work partic  sequence completed interrupted selected plans state ularly allowing recognition interruptible plans car  history query                                       rbery  recent survey general plan recognition    existing work leaves challenges open section investigations utilized multifeatured obser   details existing work assumes observations vations continuous actions did address  atomic instantaneous actions observa efﬁciency matching observations plan library  tions recent applications complex multifeatured trast work resc tambe rosenbloom   tuples involving symbolic discrete continuous compo resl kaminka tambe  use hierarchical rep  nents multiple actuators agent obser resentation similar use maintain single hypothesis resc multiple hypotheses resl cur    rent state observed agent algorithms ignore ob                   root  servation history current state hypotheses  address state history contrast algorithms                                                                                              geib et al geib harp  developed phatt hy        defend        attack        score  brid recognizer symbolic algorithm ﬁlters inconsis  tent hypotheses considered probabilistically  phatt assumes instantaneous atomic actions takes          clear  generateandtest approach each observation sym                                                                                             position turn position position turn pass position turn kick  bolic algorithm generates pending set possible expected  observations matched observation      approach   maintain correct state history hypotheses size       ball  pending set grow exponentially geib                                                                                                              trast work decouples current state state history ball ball         ball  ball   ball  ball  queries incrementally maintains hypotheses implicitly figure  example plan library circled numbers denote times  predicting impending observations hypotheses tamps section   computed needed hopefully visible shooting distance conditions  ruled                         satisﬁed plan matches observation    investigations assume atomic observations given time observed agent assumed ex                                    consider cost matching wærn stenborg ecuting plan decomposition path roottoleaf through         explores planrecognition limited observation composition edges figure  shows example portion                                                 tory facilitate recognition reactive behavior retz plan library inspired behavior hierarchies robocup                schmidt  develops approach based matching sub soccer teams kaminka tambe  ﬁg  graphs plan library approach does ure shows decomposition edges solid arrows sequen  allow interruptions plans                     tial edges dashed arrows level plans defend    work differs signiﬁcantly probabilistic ap attack score ﬁgure does show observa  proaches complements principle tion conditions associated plan steps presentation                                       demonstrated geib et al bui  explores proba clarity show decomposition edges ﬁrst  bilistic reactive recognition extending hidden markov mod temporal order child plans ﬁgure path                                  els focusing current state query pynadath wellman root → defend → turn → ball hypothe         explores probabilistic grammar representation ef sis current plan observed player realistic  ﬁcient planrecognition considers cost settings likely path match observa  matching observations separation state history tion tuple result set decomposition  current state queries                                paths set hypotheses current state    matching observations plan library          observed agent answering current state query  commonly plan recognition work bui  observed agent assumed change internal state   utilize hierarchical representation plan ways follow sequential edge  library section  present method efﬁciently plan step second reactively interrupt plan ex  matching multifeature observations library  ecution time select new ﬁrst plan    plan library                                 stance suppose agent executing root → defend →                                                        turn →   ball interrupted execution  represent plan library singleroot directed acyclic plan choose root → attack → pass  connected graph vertices denote plan steps edges root → attack → turn → withball  types vertical edges decompose plan steps  substeps sequential edges specify expected tempo  efﬁcient matching  ral order execution discussion refer ﬁrst phase recognition common recognition ap  children root node toplevel plans proaches matches observations recognizer  nodes simply plans use term plan plans plan library contrast previous work  general sense inclusive reaction plans behaviors consider complex observations consist tuple  recipes represent behaviorbased agents observed features including states world pertain  typically behaviors execute number timesteps agent ega soccer player’s uniform number actions  plans sequential selfcycle allow taken kick execution conditions maintained  reselected cycles allowed hierarchically speed   matching observations plans    each plan associated set conditions observable expensive plans each plan check  features agent actions conditions observed features fact previous work essen  hold observations said match plan exam tially proposes egkaminka tambe   ple kickballtogoal plan robotic soccer player speed process augment plan library  following features ball visible dis feature decision tree fdt efﬁciently maps ob  tance ball given range opponent goal servations matching nodes plan library fdtis decision tree nodes correspond features algorithm  csqmatching results library timestamp  branches conditions values determining plans  ∈  match set observation features efﬁciently achieved  ropagateupv  traversing fdt topdown taking branches corre  ∈  spond observed values features leaf node  taggedv ∧ ¬∃childt aggedt  reached each leaf node points plans match  deletetagv  conjunctive set observations topdown path ide  ← parentv  ally each leaf nodes points plan  possible inherent ambiguity plan library    fdt automatically constructed similarly phases calls ropagateup algorithm algorithm  machine learning ml decision tree ross   tag complete paths planlibrary match  important differences map plan library current observation taking account previous observa  set training examples use modiﬁed tree tion set matching plans assumed ordered  construction algorithm construct fdt each plan step depth parents children lines  example observation conditions – goes resulting tags eliminate  come attribute values class plan step features hierarchically inconsistent parent tagged  tested plan step treated attribute values af children tagged csq meant called  ter generating training set construction fdt new observation tags planlibrary  similar decision tree missing attribute used save information run  values lack space ross  details propagateup algorithm algorithm  uses time    important differences ml tree construction stamps tag nodes plan library consistent  processes goal construct fdt specialized current previous observations  training examples plan step example appears propagates tags decomposition edges  exactly pruning step taken commonly propagation process simple matter following  ml decision trees                           child parent plan match current observation    use fdt efﬁciently match multifeatured ob temporally inconsistent history observations  servations plans novel application methods considered instance suppose ﬁrst observation  machine learning plan recognition beneﬁts plan matches position plans figure  fdt point  recognition signiﬁcant matching time dictated propagation algorithm instances position  height fdt size library marked circled  defend twice attack  let number distinct observable features score instances temporally incon  oretical worst case plans test possible features sistent crossed ﬁgure second instance po  height fdt  worstcase leaf sition defend ﬁrst observation  fdt point ol plans maxi observed clear approachball  mum number plans ambiguously consistent similarly position score inconsistent  single observation  complexity match parent followed attack  ing observations plans worst  observed reasoning hypothesis consistency  contrasted used previous work time key novelty compared tambe rosenbloom  kaminka tambe  decision tree  kaminka tambe   onetime cost constructing fdt storage disqualify hypotheses temporally inconsistent  overhead using costs propagateup exploits sequential edges time  hindrance experiments conducted section stamps assumes calls order                                                     increasing depth discussed allows    recognition algorithms                             sumption line  matching parents tagged                                                        associated observable features  present algorithms answering current state                                                        compatible observations line  checks temporal  query section  state history query                                                         consistency time stamp temporally consistent    current state query algorithms                   three cases holds node question tagged time  important query reactive plan recognition −  continuing selfcycle node  spect current plan step selected observed agent follows sequential edge plan successfully  hierarchical planlibraries—as ours—this query tagged time −  node ﬁrst child  translates determining decomposition paths rootto sequential edge leading ﬁrst child se  leaves consistent observations poten lected time plan interrupted  tially executed observed agent each cases applicable node  path currentstate hypothesis                   temporallyconsistent hypothesis lines –    csq algorithm  efﬁcient algorithm answering tag deleted tags caused  current state query csq’s inputs include plan library climbing graph ﬁnal deletion failing tags  pointers plansteps matching current observa takes place lines –  tion stored fdt leaf works figure  shows process action circled numbersalgorithm  propagateupnode plan library timestamp suppose make observations time      agged ← ∅                                       match kick  score plan plan consistent    propagateupsuccess ← true                            defend attack tagged    ←                                             times    having ob     rootg ∧ propagateupsuccess ∧ ¬taggedv servation   safely rule possibility                                                     defend selected agent score     taggedparentv ∨ featuresparentv  ∅ follow attack lack evidence ei              taggedv    −              ∨    ther clear approach ball time           ∃p reviousseqedget aggedw ithv −    ∨    defend possibility time used         noseqedgesv         tagv                                    rule infer sequence plan paths         agged ← agged ∪                      selected robot attack → position         ← parentv                                   attack → turn          propagateupsuccess ← true                    sure turn’s children selected ﬁnally                                                score →  kick wanted currentstate hy        propagateupsuccess ← false                   potheses time   need modify hy                                                potheses time   generating state history      propagateupsuccess ← false                     hypotheses requires       ¬propagateupsuccess                                               use incrementallymaintained structure hy    ∈ agged      deletetaga                               potheses graph described holds hypotheses ac                                                        cording time stamps time stamp use                                                        structure eliminate hypotheses tagged time  ﬁgure denote timestamps assume −  invalid allows separation  matching algorithm returns time   propagate currentstate hypotheses state history hypothe                                                                                                        gins position instances immediately fails ses addressed previous work geib                                                                                tag instance follows clear approachball harp  bui    tagged   position instance                                                             time   der score initially tagged propagating tag stamp  parent score fails follows attack attack  tagged   tags             defendposition   attackposition  removed score child position  maining instances successfully tag result                                                                defend defend attack attack score score  possible hypotheses root → defend → position           turn        turn turn  turn turn                                                                      turn  root → attack → position                                          ball ball  complexity analysis each plan instance matches      ball   ball ball     ball  observations propagation traverses height  plan library expected olog note previous                     scorekick  works egkaminka tambe  prop    figure  example extracting graph  agation complexity ﬁlter temporalinconsistency                                                          hypotheses graph connected graph ver  csq utilizes timestamps plan library                                                        tices correspond successfullytagged paths plan li  external data structures geib harp                                                         brary hypotheses edges connect hypothesis ver    history states query algorithms               tices tagged time stamp hypothesis vertices tagged  time stamps used csq algorithm used time stamp   constructed levels  answer queries sequence plan steps taken each level represents hypotheses hold cor  agent time   given history responding time stamp each set observations                                                                              observations answering query trivial time ti add level ti nodes current  collection possible current state hypotheses gener state hypotheses successfully tagged   ated times       observations lack create edges vertices     xn level ti  thereof—negative evidence time tk rule current vertices     ym level ti− following manner  state hypotheses consistent time tk−   xi sequence ﬁrst child    example serve illustrate continuing exam connect xi each vertex yj  xi  ple suppose observation time   matches sequence connect xi yj plans  turn plan three instances tag   propagates yj sequential edge plan xi finally xi equal  successfully possible currentstate hypothe yj connect allow selfcycles  ses time   omit common  root preﬁx    generate sequences plan paths consistent                                                                                          defend →   turn →  ball defend →  turn →     observations traverse level ti  ball attack → turn →   ball attack →   backwards level ti− ﬁrst level paths  turn →   ball score →  turn  →  ball   connect level ti level   denote valid state histories  score → turn → ball                             illustrate figure  shows example                                                                − depth       − depth       − depth   complexity analysis let worstcase number                                plans match single observation each node                               time stamp ol                check nodes time stamp t− ol factor                               each additional level observations                                                                                                       worstcase runtime onl                                                                                                     −                                                                                              experiments                                                                       show results experiments evaluating techniques                simulated plan libraries observation sequences                                controlled key parameters library size                                                                                                      number features used each single plan ≤                                 structure temporal edges experiments                            set modifying number toplevel plans children average  runtime sec  root node depth library branching                                                                                                   factor ﬁxed  maximum length observation                    sequence                                                                                                generated valid sequences observations simulat                                 ing execution selection plan steps process ran         number actions each node  domly chose path library used features  path generate observations based existence se figure  runtime fdt solid line resl dashed  quential edges process chose continue execution totally                                                              ordered                  unordered  sequential edge jump new ﬁrst child  experiments contrasted results resl kaminka  tambe  relevant related works    matching experiments  ﬁrst set experiments compares matching runtime using        figure  sequential links types  fdt resl plan library grows size gen  erated differentsized libraries varying library depth ordered children parent form single chain  number toplevel plans demonstrate scaleup ﬁrst child sequential edge siblings  offered fdt observation complexity grows siblings sequential edges leading sib  vary  each values generated ling unordered ordering constraints nodes   random observations sets based planlibraries toplevel plans unordered  averaged runtime matching using resl propagation accuracy key advantage csq resl  ing automatically constructed fdt                 ability use sequential edges history obser    average matching runtime shown figure  vations rule hypotheses temporally inconsistent  ﬁgures arranged  ×  matrix rows correspond section  given sequence observations expect  number toplevel plans    respectively fewer current state hypotheses comparison resl  topdown columns correspond library depths  varied library size through number   right ﬁgure shows results level plans  depth plan library –  largest library approximately  nodes fdts  vary temporal structure library described  included – nodes depending number trials conducted sequences – obser  features associated each plan ﬁgures hor vations recorded number hypotheses maintained  izontal axis shows vertical axis shows av each observation propagated  erage matching time seconds each point ﬁgure figure  shows effect sequential edges types  average  runs                                  number hypotheses ﬁgures each dif    clearly use fdt leads signiﬁcant im ferent depth – axis shows number toplevel  provements matching time compared resl—and plans axis measures average number hy  each plan associated single atomic ob potheses trials conﬁguration each data  servation furthermore growth curve indicates point reﬂects average number hypotheses   beneﬁts maintained observations increase dividual observations organized  random observation  complexity                                           sequences each – observations length based                                                        generated libraries    query answering algorithms                         ﬁgures show totallyordered libraries allow csq  turn evaluate algorithms answering current maximally use past observations result  state statehistory queries answers depend criti hypotheses contrast unordered libraries sequen  cally temporal structure plan library terms tial edges gain information history  sequential edges follow geib harp  vary observations number hypotheses generated  ing temporal structure ways fig  totally case exactly generated resl—which
