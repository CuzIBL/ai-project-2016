  mbdpop new memorybounded algorithm distributed optimization                                        adrian petcu boi faltings           ecole polytechnique f´ed´erale lausanne epfl ch lausanne switzerland                                 email adrianpetcu boifaltingsepﬂch                          abstract                          decentralized asynchronously requires polynomial                                                        memory produce large number small        distributed combinatorial  optimization      messages resulting large communication overheads      problems  dynamic  programming  algorithms         optapo   mailler lesser  centralized      like dpop petcu faltings  require    distributed hybrid uses mediator nodes centralize      linear number messages generating subproblems solve dynamic asynchronous      low communication overheads dpop’s      mediation sessions authors show message      memory  requirements exponential       complexity signiﬁcantly smaller adopt’s      induced width constraint graph  possible mediators solve overlapping      prohibitive problems large width     problems needlessly duplicating effort      present mbdpop new hybrid algorithm   shown petcu faltings  cause scalability      operate bounded memory areas      problems optapo especially dense problems      low width mbdpop operates like standard dpop      dpop  petcu faltings  complete algorithm      linear number messages areas high width  based dynamic programming generates      explored bounded propagations using  linear number messages dpop time      idea cyclecuts dechter                space exponential induced width problem      introduce novel dfsbased mechanisms       problems high induced width      determining cyclecutset grouping    messages generated highwidth areas large      cyclecut nodes clusters use caching     requiring exponential communication memory      darwiche  clusters reduce   paper introduces mbdpop new hybrid algorithm      complexity exponential largest number controlled parameter characterizes      cycle cuts single cluster                   available memory mbdpop tradeoff      compare mbdpop      adopt   modi        linear number messages dpop polynomial memory      et al  current state art      rest paper structured follows section       distributed search bounded memory mb       introduces distributed optimization problem section       dpop   consistently outperforms adopt         presents dpop algorithm extended mb      problem domains  respect  metrics      dpopk hybrid section  section  shows efﬁciency      providing speedups  orders magnitude approach experiments distributed meeting                                                        scheduling problems section  discusses related work                                                        section  concludes    introduction  constraint satisfaction optimization powerful    deﬁnitions notation  paradigms model wide range tasks like   deﬁnition  dcop   discrete distributed constraint  scheduling planning optimal process  control  optimization problem dcop tuple     traditionally problems gathered single                                                          •x     xn set variables  place centralized algorithm applied ﬁnd  solution problems naturally   •d     dn set ﬁnite variable domains  distributed distributed constraint satisfaction discsp •r  rm set relations relation  formalized yokoo et al  problems                             ···x                                                                function scope    ik   divided set agents communicate ×   × →                                                                    ik      denotes utility  solve complete algorithms like  assigned each possible combination values  adopt dpop optapo introduced              involved variables negative utilities mean cost     adopt   modi et al  backtracking based  bound propagation mechanism  operates completely     hard constraints explicitly forbidenforce certain value                                                    ijcai                                                      dcops multiagent instances valued csp    each parentchild pseudoparentpseudochild  framework each variable constraint owned edges identiﬁed treeback edges dfs tree serves  agent goal ﬁnd complete instantiation ∗ communication structure  phases  variables xi maximizes sum utilities algorithm util messages phase  travel bottomup  individual relations                                 value messages phase  travel tree    simplifying assumption yokoo et al  each edges  agent controls virtual agent each variables xi phase   util propagation agents starting  owns simplify notation use xi denote leaves send util messages parents subtree  variable virtual agentwe assume node xi inﬂuence rest problem through  unary binary relations                 xi’s separator sepi message contains                                                        optimal utility obtained subtree each instantiation    depthfirst search trees dfs                   sepi messages sizeexponential separator  mbdpop works dfs traversal problem graph size turn bounded induced width                                                          phase   value propagation topdown initiated  deﬁnition  dfs tree dfs arrangement graph root phase  ﬁnished each node determines  rooted tree nodes edges optimal value based computation phase   property adjacent nodes original graph fall                                                    value message received parent  branch tree   figure  sends value children through value messages    dfs trees investigated means proved petcu faltings  dpop  boost search freuder  dechter  produces linear number messages complexity lies  relative independence nodes lying different branches size util messages largest space  dfs tree possible perform search parallel exponential width dfs ordering used  independent branches combine results    figure  shows example dfs tree shall refer  mbdpopk  bounded inference hybrid  rest paper distinguish tree edges introduce control parameter speciﬁes                         −  shown solid lines   edgesshown maximal inference   maximal message                    −   −   dashed lines                              dimensionality parameter chosen st available                                                                                           deﬁnition  dfs concepts given node xi deﬁne memory each node greater  domain                                                        size    • parent pi   children ci obvious                                                          algorithm identiﬁes subgraphs problem      deﬁnitions   xx                                                        width higher possible perform    • pseudoparents ppi   xi’s ancestors directly  inference dpop each areas clusters      connected xi through backedges pp   bounded lowest node tree                                                                         • pseudochildren pci xi’s descendants directly separator size nodes cluster roots      connected xi through backedges pc   cr                                                          areas cyclecut nodes cc identiﬁed    • sepi separator xi ancestors xi                                                                                                 removed remaining problem width      directly connected descendants subsequently each area combinations values      sep  sep  xxxx                         sep                            cc nodes explored using kbounded dpop utility      removing nodes  completely disconnects                                                                                               propagation results cached  darwiche  bythe      subtree rooted rest problem respective cluster roots integrated messages                                                        overall dpoptype propagation    dpop dynamic programming optimization               ≥ induced width inference                                                        problem mbdpop equivalent dpop  basic utility propagation scheme dpop                                                           linear messages used cycle  introduced petcu faltings  dpop                                                        cutset determined mbdpop similar andor  instance general bucket elimination scheme                                                        cycle cutset scheme mateescu dechter   dechter  adapted distributed case                                                          kw   mb  −  dpopk   performs inference  uses dfs traversal problem graph ordering                                                        areas width lower bounded inference areas    dpop   phases                                                        width higher    phase   dfs traversal graph using                                                          following explain determine highwidth  distributed dfs algorithm like petcu et al                                                         areas respective cyclecuts section   works graph requiring linear number                                                        changes make util value phases section   messages outcome nodes consistently label                                                        section  algorithm described algorithm   combinations simulated soft constraints assigning  −∞  disallowed tuples  allowed tuples maximizing  utility avoids assigning value combinations variables  mbdpop  labeling phase    dpop algorithms easily extend nonbinary intermediate phase dfs util  constraints petcu faltings  petcu et al  phases goal delimit highwidth areas                                                    ijcai                                                    figure  problem graph dfs tree lowwidth areas normal util propagation performed high width                                                                                                  areas shaded clusters bounded util propagation used messages size  cyclecut  nodes bold xxx cluster roots shaded xxx show bounded propagation    identify cc nodes areas emphasize cuts children xi xi sepi≤  process described separate phase sake function simply returns list  clarity results derived small modiﬁcations  original dfs util phases                                                        mechanism  highest nodes cc  nodes ni    labeling works bottomup like util phase each                                                      sorted according treedepth known dfs  node xi waits label messages children xj                                                      phase highest ni−k nodes marked cc                             pi  computes label labeli  sends parent example fig  let  sep   pi                                                   xxx  cclists    ∅⇒n        sep  ⇒       labelpi             message composed  parts    cc   highest xxx  separator sepi node list cci cc nodes    each node xi easily determine separator sepi                                                        mechanism  lowest nodes cc  inverse  union separators received children            −k  parent pseudoparents minus deﬁnition  mechanism  lowest nodes marked cc                                                          example fig  let   sep   formally sepi  ∪xj ∈ci sepj ∪ pi ∪ ppi  xi                                              cc        xxx  cclists    ∅⇒n        sep  ⇒    second label message list cc                           cyclecut nodes send parent each node computes     lowest      list through heuristic function based separator  mbdpop  util phase  node lists cyclecuts received  children section                          labeling phase section  determined areas                                                        width higher corresponding  heuristic labeling nodes cc                     cc nodes following perform     labelsep cclistsk  let                   heuristic function takes boundedmemory exploration areas  input separator node lists cyclecuts original util propagation dpop applies  received children integer returns  list cycle cutset nodes                   memorybounded util propagation    builds set ni  sepi ∪cclists nodes labeling phase identiﬁed cluster root nodes  xi’s separator marked cc nodes xi’s each highwidth area furthermore roots  children ni ktoo nodes marked cc received lists cyclecutset nodes designated  uses mechanism select ni asetccnew children  ni−k nodes labeled cc nodes function let xi root cluster just like dpop xi                                                                     pi  returns set nodes cci  ∪cclists ∪ ccnew      creates utili table stores best utilities subtree    separator sepi xi contains nodes achieve each combination values variables  ensures labeled cycle sepi xi’s children xj separators smaller                                                    ijcai                                                     algorithm  mbdpop  memory bounded dpop           case better utility                                                                                                             rk           xi                     instantiations explored simply sends     mbdpop            each agent does                                                                                                parent updated util table contains     labeling protocol                                                                                                                  best utilities xi’s subtree instantiations variables    wait labelj msgs children                                                         sepi exactly dpop pi continues propagation    sepi≤k                                                                                 ∪cclists  ∅                                  normal dpop complexity i’s processing                   label self cr             transparent       label self normal                                                           example   figure  let  thenc               cci ←∅                                                         xxxxx   area width higher                                                     root ﬁrst node lowest tree       let  sepi ∪cclists                           sepi ≤ using mechanism  selecting cc       select set ccnew n−k nodes         nodes xx cc cycles through       return cci  ccnew ∪ cclists                     instantiations  xx  sends children context                 pi                                      messages form   messages   send labeli   sepicci  pi                                                         travel nodes cluster     util          propagation protocol                           sent nonempty cclists receiving context            utili                          ∈ ci   wait     messages children         messages start bounded util propagation             normal node util  value dpop     dimensions                                                  dimensions                                        cclists      propagations instantiation           easy using scheme memory                cluster root                       requirements oexpk propagation         update util cache each propagation    oexpsep cache tables sep≤k         propagations ﬁnish send util parent  section  overall observe memory limit oexpk                                       ∗                                     value     value  propagationxi receives sepi pi          mbdpop             phase    xi cluster root                         labeling phase determined areas bounded                         ∗                   ∗      ﬁnd cache cc corresponding sepi        inference applied excessive width      assign self according cached value            following processing                ∗      send cc  nodes cc value messages       areas outside original value propagation                                                  dpop applies                                                  ∗                                          perform util cc nodes assigned cc     value message root cluster receives      assign self accordingly                          parent contains optimal assignment                                                                                 sep                           ∗                                 variables separator   cluster              xi ←      ci    pci     send value                             xi  retrieves cache table optimal assignment                                                         corresponding particular instantiation separator                                                         assignment contains value values   sep ≤k              utili          send  normal     messages dpop cc nodes cluster xi informs cc      waits messages stores         nodes cluster optimal values value     children xj larger separator sepj  messages   xi creates cache table entry cachesepi noncc nodes cluster cached   corresponds each particular instantiation optimal values instantiations cc nodes   separator sepi ∈ sepi  size cache table follows ﬁnal util propagation required order   oexpsepi                                      rederive utilities correspond particular     xi starts exploring through kbounded propagation instantiation cc nodes determined   subtrees sent nonempty cclists does optimal expensive process   cycling through instantiations cc variables single propagation dimensionality bounded   cluster each sent children cc nodes instantiated requires   context message children propagate context messages linear number messages expk size   children sent nonempty cclists subsequently outside clusters value propagation   propagates nodes separators larger proceeds dpop   lowest nodes cluster separators   larger                                          mbdpopk  complexity     leaves cluster start bounded propagation lowwidth areas problem mbdpop behaves   nodes speciﬁed context message instantiated exactly dpop generates linear number messages                                                                            current value propagation guaranteed size clusters formed   involve dimensions proceed normal width exceeds klett cluster let    dpop reach xi xi updates best utility number nodes cluster let cct    values far each sepi ∈ sepi  updates number cycle cut nodes cluster mbdpop   cache table current instantiation cc nodes executes dcct  kbounded propagation cluster each                                                     ijcai                                                                                                                                                                                                                                                                                                         runtime  ms                                                             messages                                         adopt                                                 adopt                                 mbdpop                                         mbdpop                                    mbdpop                                            mbdpop                                    mbdpop                                            mbdpop                                    mbdpop                                            mbdpop                                mbdpopdpop                                       mbdpopdpop                                                                                                                                                    number variables                                   number variables                                                                      figure  mbdpopk vs adopt  runtime                                                                  requiring − messages size messages      bounded dk    easy overall timemessage    complexity oexpcctmax tmax                                                                  cluster maximal number cc nodes                                           adopt                          oexpk                                                       mbdpop    memory requirements         design                                        mbdpop                                                                                          mbdpop                                                           total  message size sum sizes bytes mbdpop                                                                                      mbdpopdpop                                                                    experimental evaluation                                                                                                                                      number variables  performed experiments  different problem domains  distributed sensor networks dsn graph coloring gc figure  mbdpopk vs adopt  message exchange  meeting scheduling ms    meeting scheduling generated set relatively large  distributed meeting scheduling problems model improved adopt instances  orders  maheswaran et al  brieﬂy optimal schedule magnitude  set meetings set agents notice mb−dpopk sends  problems large   agents   larger messages adopt overall exchanges  meetings yielding large problems   variables information fig  low believe  reasons  larger problems denser adopt sends messages  difﬁcult induced width                   asynchrony attach context    experimental results presented figure  number produces extreme overheads  messages total information exchanged  sum    dsn gc problems ones used  message sizes bytes figure  runtime maheswaran et al  lack space  milliseconds notice logarithmic scale adopt present detailed results align  did scale problems cut meeting scheduling ones  execution threshold  hours  million messages dsn dsn instances sparse induced  largest problems adopt solve  agents width  mb − dpopk ≥  runs   variables                                       linear number messages   messages    executed mbdpop increasing bounds  size  runtime varies  ms  ms  expected larger bound nodes contrast adopt sends    designated cc messages required messages requires  sec  sec solve  message size memory requirements increase problems overall problems easy    interesting note mb− dpop mbdpop experienced  orders  uses linearsize messages just like adopt performs magnitude improvements terms cpu time number  better adopt solve larger problems messages  smaller number messages example largest graph coloring gc instances small    problems adopt solve mb − dpop   produced   variables tightly connected  improvements  orders magnitude mb − dpop   challenging adopt adopt terminated                                                        required  hour computation time     experiments run machine gb ram million messages problem  variables    each data point average  instances       three  domains   showed   strong performance    mechanism  cc selection used             improvements mbdpop previous state                                                    ijcai                                                    
