                                    design essence             constraint language specifying combinatorial problems                          alan frisch      matthew grum         chris jefferson                            bernadette mart´ınez hernandez´       ian miguel      artiﬁcial intelligence group dept science univ york uk frisch grum bernacsyorkacuk                oxford university computing laboratory univ oxford uk chrisjcomlaboxacuk                    school science univ st andrews uk ianmdcsstandacuk                        abstract                          domain elements combinatorial objects type                                                        constraints operate type enables problems      essence new formal language specify     stated directly naturally decision vari      ing combinatorial problems manner similar    ables appropriate type problem      natural rigorous speciﬁcations use mix “modelled” encoding desired combinatorial object      ture natural language discrete mathematics collection constrained decision variables      essence provides high level abstraction type integers      consequence provision     motivations — methodology      decision variables values combina                                                        sults — developing essence differ greatly      torial objects tuples sets multisets rela lead development constraint languages      tions partitions functions essence al important consider carefully outset      lows combinatorial objects nested ar                                                          primary motivation comes ongoing study      bitrary depth providing example sets                                                        automation constraint modelling constraint mod      partitions sets sets partitions forth                                                        elling process reducing given problem ﬁnite      problem requires ﬁnding com                                                        domain constraint satisfaction optimisation problem csp      plex combinatorial object directly speciﬁed                                                        domains constraints supported      using decision variable type precisely                                                        intended solver technology current practice process      combinatorial object                                                        conducted manually unsystematically —                                                        art current solvers provide decision variables    introduction                                       domains contain atomic values ﬁnite sets                                                       atomic values models terms  paper describes essence new language speci variables atomic atomic set variables respec  fying combinatorial decision optimisation problems tively example consider social golfers problem  high level abstraction essence result attempt sgp requires partitioning set golfers equal  design formal language enables abstract problem sized groups each week tournament subject certain  speciﬁcations similar rigorous speciﬁcations constraint goal ﬁnd multiset regular parti  use mixture natural language discrete mathematics tions satisﬁes constraint model sgp                                                catalogued garey johnson    represent multiset regular partitions col    essence intended accessible lection constrained atomic atomic set variables  background discrete mathematics expertise  ways frisch et al  straint programming needed working hypoth                                                          automatically generate models problem  esis achieved modelling                                                        start formal speciﬁcation problem spec  language rigorous speciﬁcations naturally                                                        iﬁcation sufﬁciently abstract modelling  used combinatorial problems develop                                                        cisions constructing formal  ing form logical language spivey                                                         language writing speciﬁcations provide level ab  npspec cadoli et al  resulted                                                        straction modelling decisions  language ﬁrst approximation constraint lan                                                        refer language problem speciﬁcation lan  guage opl van hentenryck  hnich                                                         guage distinguish modelling languages  esra flener et al  enhanced features                                                        purpose enable speciﬁcation models  greatly increase level abstraction importantly                                                        signing problem speciﬁcation language prerequisite  combinatorial problem requires ﬁnding certain type com                                                        studying automated modelling goal paper  binatorial object essence provides decision variables                                                        forward language makes large step satis    essence version  used paper speciﬁ  cation language york web  partition regular subsets cardinality                                                    ijcai                                                     fying challenging prerequisite                   mystery problem    motivation designing essence formal   given     enum  → int   problem speciﬁcations facilitate communication               → int  int                                                                                                                                            set   tween humans better informal speciﬁcations                   ≤           ≥  currently used beneﬁts accrue stan    u∈u  u∈u  dardising problem speciﬁcation language example golomb ruler problem grp given integer ticks ruler size  informal problem descriptions csplib problem library intertick distances unique minimise  httpcspliborg replaced supplemented given  int                                                              ≥   mal ones doing requires availability problem                                                                     letting    bound   speciﬁcation language founders csplib insisted  ticks set size int bound  describing problems models using formal speci minimising maxticks                                                                    ∀                             ⇒                                                           pairpairset size  int⊆ticks pair pair  ﬁcations human communication imposes requirement           max    − min  max   − min   language natural — similar           pair    pair     pair    pair  manner people think problems style sonet problem sonet communication network comprises number  specify informally naturalness rings each joining number nodes node installed ring using adm                                                         capacity bound number adms installed  important property input language automated ring each node installed ring communication  modelling claim automated routed pair nodes installed common ring given                                                         capacity bound speciﬁcation pairs nodes communicate  modelling using requires major translation allocate set nodes each ring given communication demands  problem system’s input language finally exper met objective minimise number adms used common  tise constraint modelling constraint solving simpliﬁcation sonet problem described frisch etal  needed writing formal problem speciﬁcation   given     nrings nnodes capacity  int   human communication input automated mod    letting   nodes intnnodes  elling                                               given     demand  set set size  nodes                                                                    network  mset size nrings    three primary objectives driven design                     set maxsize capacity nodes                                                                                      essence section discussed language        minimising ring∈network ring                                                                         ∀      ∃           ⊆  natural understood     pair∈demand ring∈networkpair ring  background discrete mathematics provide social golfers problem sgp golf club number golfers  high level abstraction objectives related wish play groups size schedule play weeks                                                         pair golfers play transforms  providing appropriate level abstraction necessary decision problem parameterises problem number  csplib  achieve naturalness design objective prob  lems speciﬁed language effectively mapped given  int                                                          letting  golfers new type size ∗  csps illustration consequence objective sched  mset size rpartition size golfers                                                                  ∀                 ⇒  decision variable essence associated weekweek∈schedweek week                                                                     ∀group∈weekgroup∈weekgroup ∩ group    ﬁnite domain                                            alternative constraint    remainder paper introduces essence argues ∀golfergolferp golfersgolfer  golfer ⇒                                                                            togethergolfer golfer week   largely meets design objectives paper does         week∈sched                    present formal syntax york web   formal semantics frisch et figure  essence speciﬁcations problems  al      introduction essence      example         discrete mathematics able understand                                                        rigorous problem speciﬁcations employ discrete math  through presentation examples section intro ematics little training understand essence  duces essence demonstrates naturalness       speciﬁcations signiﬁcant advantage far    begin asking reader examine ﬁrst essence people familiar discrete mathematics constraint  speciﬁcation given fig  speciﬁcation programming  known problem identify    able identify knap natural problem speciﬁcations                                                        identify given parameters problem  sack decision problem essence speciﬁcation  nearly identical speciﬁcation given garey john combinatorial objects decision vari  son  problem mp page                     ables constraints objects satisfy                                                       solution speciﬁcation introduce    instance finite set each ∈ size su ∈                                                       terminology objective function problem    value vu∈z positive integers                                                      optimisation problem identify conditions                            ⊆             su ≤    questionp subset u∈u         met parameter values essence supports             vu ≥       u∈u                                        components problem speciﬁcation seven kinds    similarity essence speciﬁcation  statements signalled keywords given  naturallyarising problem speciﬁcation illustrates main letting maximising minimising  point problems speciﬁed rigorously discrete letting statements declare constant identi  mathematics essence based notation concepts ﬁers userdeﬁned types given statements declare pa                                                    ijcai                                                     rameters values input specify instance socialisation constraint ﬁrst constraint quantiﬁes  problem class parameter values weeks ensuring size intersection  problem speciﬁcation statements dictate allowed pa pair elements corresponding partitions  rameter values allowed values designate valid prob golfers group  lem instances statements declare decision variables gether alternative constraint quantiﬁes  minimising  maximising statement gives objec pairs golfers ensuring partitioned  tive function finally statements gether global constraint weeks  problem constraints                                  schedule note make use    essence speciﬁcation list statements composed facility common constraint languages treating booleans  according regular expression                   purpose counting                       ∗                          ∗    given  letting   minimising  maximisingsuch    consider speciﬁcation golomb ruler prob  features essence  lem grp problem  csplib fig  instance section explains signiﬁcant features  obtained letting  domain decision vari                                                        essence ﬁrst subsections discuss types  able ticks contains sets elements drawn                          ticks       mains discuss expressions quantiﬁca           consider assignment               tion  solution instance succeeded                                                          essence stronglytyped language expression  goal making essence speciﬁcations natural type parser infer types expres  discrete mathematics background                                               sions perform typechecking types impor  clear given distinct pairs  tant determining denotation overloaded operator  distance pair maxpair − minpair                                        max      −    example union operator denote set union mul  different distance pair   tiset union depending types arguments  minpair believe reader concur                                                          essence ﬁnitedomain language decision vari  essence speciﬁcation closely matches given english able associated ﬁnite domain values  scription substantially closer standard csp mains quite intricate sets values example  model problem                                 domain ﬁnite subset integers    grp speciﬁcation ﬁrst declares parameter valid                            bound                       set twoelement sets drawn given ﬁnite set  positive identiﬁer     declaration  integers  bound uses nson declared ﬁrst identiﬁers                                                          types domains play similar role prescribe  declared use preventing cyclical deﬁnitions deci                                                        range values variable tempting —  sion variables used deﬁne constants param                                                        tempted — view types domains  eters                                                        thing view leads difﬁcult    constraints built parameters constants quanti                                                        unsolvable problem intricate patterns used  ﬁed variables decision variables using operators com                                                        constructing domains handled type  monly mathematics essence includes variable                                                        example ﬁnite subset integers distinct  binders ∀  ∃ Σ  range                                                  type problem assigning types expressions  speciﬁed ﬁnite domain integer range integer                                                        difﬁcult impossible  grp constraint read “for unordered pairs                                                          desired type essence  ticks pair pair pairs different                                                        simple reached decision types domains  distance pair equal distance                                                        distinct closely related concepts types sets  pair”                                                        contain elements similar structure    consider speciﬁcation sonet problem                                                        domains sets drawn single type manner  fig  notice nodes declared domain                                                        each domain associated underlying type ex  elements integers range nnodes param                                                        ample integer type underlying domain comprising  eter demand instantiated set sets                                                        integers   set integers type  each inner set cardinality goal ﬁnd mul                                                        lying domain comprising sets integers  tiset rings each element set nodes                                                          type checking type inference operator  nodes ring objective minimise sum                                                        loading based types domains  number nodes installed each ring constraint  ensures pair nodes communicate types design goal provide essence  stalled common ring                             rich collection types simple type rich    finally fig  gives versions speciﬁcation ness types comes large number types  social golfers problem sgp problem description type constructors supported simplicity  does refer golfers individually speciﬁed type comes fact typing static  naturally unnamed type decision variable rep types disjoint  resented straightforwardly multiset fact atomic types essence int integer bool  set implied constraint regular partitions regularity boolean userdeﬁned enumerated types userdeﬁned  guarantees equalsized partitions each representing week unnamed types userdeﬁned types deﬁned  play speciﬁcations differ expression through letting given statements following                                                    ijcai                                                       letting players new type enum alan ian chris berna mains named annotating type    letting rings new type size                  restrictions select particular values type ex    given players new type enum                    ample int  set size  int     ﬁrst statement deﬁnes new type comprising domains annotations written parenthesis  named atomic elements types disjoint ele type underlying domain obtained  ments type members type moving parenthesised subexpressions types  names used underlying domains int set int  second statement deﬁnes new type comprising el respectively  ements elements named consider atomic types annotated form  elements distinct elements types atomic domains atomic domains formed taking  statement similar ﬁrst enumer subsets integer boolean type enumerated  ation elements type provided input type subsets identiﬁed list contain  speciﬁcation                     ing values value ranges arbitrary set expression    elements integer boolean types examples include  enumerated types totally ordered integers players alanchris players alan chris inclusive  dered usual way booleans ordered  int    mixture values ranges  elements enumerated type order int     positive integers  named letting statement given int  nonzero integers                                                          int lu       integers inclusive  types — userdeﬁned unnamed types     ∪                 compound types — unordered                         int            integers      compound types built type constructors form examples parameters  sets multisets functions tuples relations partitions ma identiﬁers declared letting statement illustrates  trices τττ names types θθ important distinction domains types pa  names ordered types φ ﬁnite rameters appear annotations domain  type bool enumerated type unnamed type appear type decision variables  positive integer following compound appear domains requirement needed speciﬁca  types                                                tions mapped csps    set τ            ﬁnite set drawn τ        consider type constructors annotated    mset τ           ﬁnite multiset drawn τ set multiset partition regular partition relation construc                                  τ → τ             ﬁnite partial function domain τ tors annotated inserting keyword                         codomain τ               “of” size restriction form size intexpormaxsize    tuple ττn   ntuple                    intexp intexp integer expression contains    rel τ ×···×τn      ﬁnite nary relation        decision variables following domains                 φ                             φ    partition        partition elements  set size int                  φ                                  φ    rpartition       regular partition elements  mset maxsize int                               matrix indexed   dimensional matrix          partition  size  mset  maxsize  int       θ θ     τ                                                                                     ×  example set int rel int int types second domains illustrate  type constructors nested arbitrary depth notations attached outer constructor  allowing types                                nested constructors atomic types    set set set int                            essence syntax designed    rel partition players × mset set int       biguity annotation attached    notice ﬁniteness plays central role semantic addition size annotation relation constructor  explanation accompanying each type constructor annotated multiplicities specify ex  consequence types contain inﬁnite ample relation ntom modelled  number elements each element ﬁnite size cardi feature similar feature provided esra  nality necessary achieve objective essence  speciﬁcations mapped csps                    function constructor annotation indi    finally notice parameters decision variables cate function total partial indicate  speciﬁcation enter type names restric function surjective injective bijective ex  tion necessary enable type expression ample following domains  speciﬁcation determined parameters players →total players  stantiated values say essence players →injective players  statically typed                                       players →total surjective players    domains   domain set values type matrix tuple type constructors annotations  essence type domain essence allows course types nested annotated                                                        examples    function ﬁnite deﬁned ﬁnite set values tuple  int  set size  int   similarly relation ﬁnite contains ﬁnite set tuples matrix indexed players int  bool                                                    ijcai                                                     uses matrix constructor domains universal quantiﬁer alternative constraint sgp  dices single range ordered type illustrated speciﬁcation fig  second method obtain  second statement                        values taking elements strict nonstrict subsets    domain ﬁnite inﬁnite domains set partition regular partition quantiﬁcation ex  sociated decision variable ﬁnite pressions knapsack sonet speciﬁcations fig   quired ensure speciﬁcations map csps draw values set set partition regular par  frisch et al given set rules gen tition denoted arbitrary expression including  erating ﬁnite domains paper instead relies expressions contain decision variables seen ex  reader’s intuition understanding determine domain amples mentioned quantiﬁcation expressions kind  contains ﬁnite inﬁnite set elements          need specify types quantiﬁed variables    expressions expressions essence formed can easily inferred example quantiﬁed  manner expect bearing mind ev expression u∈u  knapsack speciﬁcation clear                                                                                       ery expression type constraints restrictions type type set fi  statements expressions type boolean objec nally possible employ methods dictate  tive functions expressions ordered type   values taken quantiﬁed variables example seen    atomic expressions essence constants pa constraint grp speciﬁcation pair  rameters decision variables quantiﬁed variables pair each subset ticks set  unnamed types compound types constructed size   value names  constants language                               abstraction essence    shall explain syntax naming constants  note objective value distinct section explains features essence intro  difﬁculty emptyset member ev duced previous section yield language great  ery type form set τ remedy explicitly deal abstraction  attach type emptyset example set guiding principle design essence  int set players distinct names distinct language force speciﬁcation provide  objects                                              necessary information make unnecessary decisions ex    compound expressions formed applying operators isting languages force speciﬁcation introduce  expressions essence provides wide range operators necessary objects unnecessarily distinguish ob  drawn discrete mathematics intersection function jects typically introduces symmetry speciﬁca  application projection set membership logic conjunc tion demonstrated facilities essence  tion implication global constraints abstraction enable avoided  straint programming alldifferent global cardinality lex high level abstraction provided essence pri  icographic ordering global constraints marily consequence features discuss  constraint languages apply matrices integers subsections  essence apply matrices reasonable type ex wide range types essence supports wide range  ample essence alldifferent applies matrix type types type constructors including sets multisets tuples  lexicographic ordering applies onedimensional relations functions partitions decision variables  matrices ordered type                         domains containing values types    type compound expression function op example knapsack problem requires identifying  erator types operands operators set objects knapsack  loaded example intersection operator applied readily represented decision variable type set  multisets produce multiset applied set objects objects  sets produce set                            given enumerated type need identify    quantiﬁcation  essence provides exceptionally rich say integers notice speciﬁcation garey  set constructs expressing quantiﬁcation examples johnson  does identify objects integers  seen constraints fig  speciﬁcation language force  “minimising” statement sonet speciﬁcation   nested types  essence allows type constructors  each quantiﬁcationp expression consists three components nested arbitrary depth important dis                     ∀   ∃  quantiﬁer   followed nonempty list tinctive feature essence considered  variables quantiﬁed variables important contribution design constraint languages  “declared” followed binding expression dictates observe importance consider sonet problem  ﬁnite set values variables range val requires placing each set communicating nodes  ues type taken type communication rings way  associated quantiﬁed variables ﬁniteness set speciﬁed communication demand met goal  values variable ranges necessary enable ﬁnd set rings each set nodes—and  mapping speciﬁcations csps    binding expressions employ methods dictating    case domain ﬁnite ﬁniteness obtained  values ﬁrst ﬁnite domain sets subset ticks ﬁnite                                                    ijcai                                                     
