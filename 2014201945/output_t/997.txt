                                bestﬁrst utilityguided search                                       wheeler ruml      minh                                         palo alto research center                                            coyote hill road                                         palo alto ca  usa                                     ruml  minhdo    parc  dot com                        abstract                          pearl  applications solutions                                                        needed faster provide ﬁnd solution      shortestpath problems practical inter faster common practice increase weight hn      est insufﬁcient time available ﬁnd provably fngnw · hn ≥  pohl inthe      optimal solution hope achieve    recently proposed ara algorithm likhachev et al       balance search time solution cost   scheme extended return series solutions      respects user’s preferences expressed creasing cost time weight initially set high      utility function time cost current state value decremented δ each solution al      oftheart approaches problem rely lowed continue eventually reaches  cheapest      time algorithms anytime ara       path discovered course ﬁnding optimal solution      algorithms require use extensive train way takes longer simply running directly      ing data compute termination policy      spects user’s utility function propose    algorithms suffer inherent difﬁculties                                                        understood set δ best satisfy      direct approach called bugsy incor      porates utility function directly search user’s needs linked solution cost      obviating need separate termination pol solving time clear achieve desired      icy experiments challenging problem   tradeoff setting high δ low result      domains including sequence alignment tempo  poorquality solutions returned wasting time      ral planning demonstrate direct approach set low δ high algorithm      surpass anytime algorithms requiring  long time ﬁnd solution use weighted      expensive performance proﬁling                   technique user perform pilot experiments                                                        each new problem domain ﬁnd good parameter settings                                                          second anytime algorithms ara user    introduction                                       estimate right time stop algorithm search  important tasks diverse planning sequence align process appears black box emit signiﬁcantly  ment represented shortestpath problems suf better solution moment repeatedly esti  ﬁcient computation available optimal solutions mate probability continuing computation  problems using search admissible worthwhile according user’s utility function  heuristic hart et al  practical sce quires substantial prior statistical knowledge runtime  narios time limited costly desirable performance proﬁle algorithm rests assump  feasible look leastcost path search effort tion learned knowledge applies current  carefully allocated way balances cost stance  paths required computation time trade difﬁculties point general problem anytime  expressed user’s utility function speciﬁes algorithms inherently provide suboptimal performance  subjective value combination solution quality ignorance user’s utility function sim  search time paper introduce new shortest ply possible general algorithm quickly trans  path algorithm called bugsy explicitly incorporates form best solution achievable scratch time  user’s utility function uses guide search best solution achievable given time    bestﬁrst search ‘open list’ unex  worst case visiting nextmostpromising  plored nodes sorted fngnhnwheregn    lution require starting child root node  denotes cost experienced reaching node ability decide during search dis  initial state hn typically lower bound cost tant solution worth expected effort reaching  reaching solution optimal sense time algorithms manually engineered according  algorithm returns optimal solution using policy ﬁxed advance hardcoded policies mean  lower bound function hn visits fewer nodes dechter inevitably situations anytime al                                                    ijcai                                                    gorithms waste time ﬁnding nearby poorquality     cost  solutions overexert ﬁnding high quality        nearest  solution sufﬁced                                              ‘optimistic                                                                                     lower bound’    paper address fundamental issue knowl  edge user’s utility function propose simple vari  ant bestﬁrst search represents user’s desires    utility  uses estimate utility guidance ap  proach bugsy bestﬁrst utilityguided search—yes              upper         cheapest  show empirically domains success         bound  fully adapt behavior suit user signiﬁ                                 time  cantly outperforming anytime algorithms furthermore  utilitybased methodology easy apply requiring  formance proﬁling                                    figure  estimating utility using maximum bounds                                                        nearest cheapest solutions  thebugsy        approach                                                        bound distance search nodes hypothetical cheap  ideally rational search agent evaluate utility                                                        est solution domains additional estimate en  gained each possible node expansion utility                                                        tails trivial modiﬁcations usual function search  expansion depends utility eventual outcomes                                                        distance multiplied estimate time  enabled expansion solutions lying                                                        expansion arrive ts note simple estimation  node instance solution tree                                                        method makes standard assumption constant time  structured space expanding node                                                        node expansion provide informed estimate  lies beneath utility negative utility time costly                                                        compute bounds cost time nearest  approximate true utilities assuming                                                        solution addition cheapest standard heuristic  utility expansion merely utility highest                                                        functions easily modiﬁed produce infor  utility solution lying node                                                        mation estimated maximum    assume user’s utility function utilities convenience notate fn  captured simple linear form fs represents                                                        values inherited whichever hypothesized solu  cost solution sandt represents time tion higher utility  returned user expect user supply figure  illustrates computation schematically  three constants udefault representing utility returning solid dots represent solutions hypothesized  solution wf  representing importance solu cheapest nearest heuristic functions dashed circles  tion quality wt representing importance compu represent possible solutions demonstrating tradeoff  tation time utility expanding node computed extremes dotted lines represent                                                     tours constant utility dotted arrow shows di      unu       −   min   wf · fswt · ts      rection utility gradient assuming solid               default                        dots represent lower bounds upper bound utility                                                        combine cost cheapest solution time  ranges possible solutions available                                                        nearest solution probably signiﬁcant  follow decisiontheoretic tradition better utilities                                                        overestimate note different utility functions dif  positive requiring subtract estimated                                                        ferent slopes dotted lines relative superiority  solution cost fs search time ts discussion                                                        nearest cheapest solutions change  mean lower bounds fs ts                            yield upper bound  formulation allows  implementation  express exclusive attention cost time  linear tradeoff number time units figure  gives pseudocode sketch bugsy implemen                                                        tation algorithm closely follows standard bestﬁrst  user willing spend achieve improvement     cost unit wf wt quantity usually easily elicited search estimate true upper bound  users explicit application underestimate change arbitrarily path  main course utility function neces implies discover better route previously  sary constructing termination policy anytime expanded state duplicate paths search state  algorithm superﬁcially similar weighted detected steps   cheaper path retained  bugsy’s node evaluation function differs wf ap record links node’s children preferred  plied gn hn                          parent utility descendants recomputed    course solutions available node interesting note taking time cheapest  known estimate utilities using cost nearest true lower bound utility  functions analogous traditional heuristic function hn hypothesized solutions lower bounds  instead merely computing lower bound cost reality lie right ﬁgure  cheapest solution node compute lower marked ‘optimistic lower bound’ ﬁgure                                                    ijcai                                                    bugsyinitial                                     properties algorithm   open ←initial closed ←   ← remove node open highest value   goal return                                                        bugsy   trivially sound—it returns nodes   add closed                                                      goals heuristic distance functions used   each n’s children                        inadmissible corrections algorithm complete     goal uc  skipc                                                        search space ﬁnite wt wf  bugsy     old version closed                                                        reduces returning cheapest solution wf        better                          old                            wt  thenbugsy   greedy tn ties broken           update    children                   cold                                 low fn longer route previously visited state    old version open                                                      discarded limits size open size       better                       cold                            search space implying solution eventually          update                    old                                 discovered similarly wf wt  bugsy com    add open                                                        plete tn static state fn term   step                                                         cause longer path previously visited                                                        state discarded bounding search space ensuring   figure  bugsy follows outline bestﬁrst search completeness unfortunately search space inﬁnite                                                        tn inadmissible wt  bugsy complete                                                        cause pathological tn potentially mislead search                                                        forever  step  gn changes nilsson   online                                                          utility estimates perfect bugsy optimal  estimation time expansion omitted clarity                                                        follows proceed directly highest  exact ordering function used open determine                                                        utility solution assuming perfect bugsy ex  ‘better’ steps   prefers high values break                                                        pands start node child node path highest  ing ties low tn breaking ties low fn breaking                                                        utility solution open list bugsy  ties high gn note linear formulation utility                                                        expand node children node  means open need resorted time passes                                                        highest utility open list  nodes lose utility constant rate independent                                                        step closer goal parent previously  estimated solution cost effect utilities stored                                                        highest utility leads solution qual  independent search time far                                                        ity way bugsy proceeds directly highest util    hn tn functions used bugsy ity solution achievable start state incurs loss  lower bounds bugsy requires estimates—there utility wasted time expands nodes  admissibility requirement data previous runs path optimal solution  similar problems information used convert intuitive bugsy application  standard lower bounds estimates russell wefald problems operators different costs   experiments reported eschew distance goal search space correspond  assumption training data available compute cor directly cost search space  rections online running average onestep operators unit cost nearest cheapest  error costtogo distancetogo measured each heuristics bugsy make different choices  node generation errors computed comparing consider situation expan  costtogo distancetogo node sions appears node closer goal  children costtogo decreased cost node result worse overall solution sit  operator used generate child conclude uation easily come admissible  parent’s value low record discrepancy consistent heuristic function time weighted heav  error similarly distancetogo decreased ily solution cost bugsy expand node  correction factors used computing tempt capitalize previous search effort reach goal  node’s utility accurate estimate based quickly hand abandon  experience during search far given raw costtogo search path expand node dogged attempt op  value distancetogo value average errors eh                                                     timize solution cost regardless time  ed   ed   eh temper inad  missible estimate especially utility function speci domains costtogoal distancetogoal  ﬁes solution cost important weight error functions different bugsy signiﬁcant advan  estimates min wtwf  online es tage weighted high weight weighted  timation time expansion cost distance looks cost ﬁnd solution  corrections create additional overhead bugsy relative quickly greedy algorithm bugsy  search algorithms care measure cpu search guided estimate distance solutions  time computing utility values experimental eval cost possibly ﬁnd solution time  uation just node generations                    greedy algorithm                                                    ijcai                                                      empirical evaluation                                          bugsy    ara    aa    sp    gr    determine simple mechanism time                unit costs way movement  blocked  aware search effective practice especially time                                                                               microsec                            imperfect estimates utility compared bugsy  seven algorithms three different domains grid     msec                              world path planning  different varieties multiple se   msec                              quence alignment used zhou hansen  evalu   msec                             ate anytime temporal planning algorithms  msec                             coded objective caml compiled native code run  sec                            processor dual ghz intel xeon machine gb cost                            ram measuring cpu time used algorithms                    unit costs way movement  blocked                                                             time                         detecting duplicates using closed list hash table  microsec                             breaking ties infavorofhighg                  microsec                             weighted                                        msec                                                                                           msec                              greedy like preferring low breaking ties low                                                               msec                               speedy like greedy preferring low time goal tn   msec                                   breaking ties low hthenlowg                          sec                              anytime weighted   continues prun       cost                          ing open list optimal goal           ‘life’ costs way movement  blocked      hansen et al                                  time                                                                                     microsec                               ara  performs series weighted searches starting                                                           microsec                                     decrementing weight δ  follow                                                           microsec                                   ing likhachev et al reusing search effort   ∗                                                       microsec                                a nodes factor  ofthe  microsec                                   lowest value open list expands esti  microsec                                mated closest goal pearl kim    msec                                 note greedy speedy provide inherent msec                          mechanism adjusting builtin tradeoff solution  msec                        cost search time included provide  msec                       frame reference algorithms ﬁrst solu cost                       tion anytime ara  weighted algorithms table  results three varieties gridworld planning  conﬁrmed experimentally omit weighted                              ∗  presentation a performed poorly  preliminary tests taking long time node expan search steps cheapest goal nearest goal  sion omit results domains quantities used compute fn tn  solutions anytime reported thousands solutions estimates obstacles heuristics  limited anytime algorithms report accurate problems quite challenging  ing solutions improve solution quality  table  shows typical results three representative                                                        classes gridworld problems anytime notated aa    gridworld planning                               each row table corresponds different utility func  considered classes simple path planning prob tion including speedy each  lems   grid using way way signed optimal recall each utility function spec  movement three different probabilities blocked cells iﬁes relative weighting solution cost cpu time  different cost functions start state lower taken ﬁnd relative size weights determines  left corner goal state lower right corner important time relative cost words  addition standard unit cost function utility function speciﬁes maximum time  equally expensive tested graduated cost func spent gain improvement  cost unit  tion moves upper row free cost time listed each row table  goes each lower row cost function example ” msec” unit cost problem means  ‘life’ shares everyday living property search algorithm spend millisecond order  short direct solution quickly shallow ﬁnd solution step shorter words means  search tree relatively expensive leastcost solu solution takes  seconds longer ﬁnd  tion plan involves annoying economizing steps  unit cheaper judged superior  cost functions simple analytical lower bounds ignor utility functions tested range orders mag  ing obstacles available cost gn distance nitude search time matters                                                    ijcai                                                    solution cost matters                             bugsy    ara    aa    sp    gr      recall given utility function start search time           bugsy  returns single solution representing best trade  sec                        path cost search time ﬁnd based  sec                        information available record cpu time sec                              taken solution cost greedy notated gr  sec                              table speedy notated sp each return  secs                         solution solutions score according utility cost                      functions extreme emphasis time cost  score poorly general anytime algorithms  table  results protein sequence alignment  time ara return stream solutions time  experiments allowed run optimality  each utility function postprocessed results simply maximum number characters remain  ﬁnd optimal cutoff time optimize each algorithm’s inginanysequence  performance utility function note ‘clair table  shows results each row representing  voyant termination policy’ gives anytime ara different utility function raw scores normalized  unrealistic advantage tests compare easily   each cell represents mean  different utility functions resulting solution  instances little variance scores  utilities linearly scaled fall   each main bugsy performing variety  cell table mean  instances    timecost tradeoffs holding greedy    group unit costs way movement    ends spectrum anytime algo  blocked bugsy performing behaving like rithms fail match performance despite clairvoyant  speedy greedy time important like termination policy  cost important signiﬁcantly surpassing algo  rithms middle range utility functions  temporal planning  groups bugsy performs long time increasing years  importance dominating middle range applying heuristic search algorithms ai planning problems  utility functions balancing time cost crucial zhou hansen  problems search al  inadmissible heuristic means ocassionally gorithm ﬁnd sequence actions connects ini  performs slightly worse ara time tial state si goal state sg tested algorithms  marginal importance cost critical anytime temporal planning problems actions realvalued  performed extremely poorly group taking amounts time socalled ‘durative’ actions objec  hours instance versus  seconds results tive function minimize plan duration makespan  omitted given bugsy does require performance ﬁnd plan used temporal regression planning  proﬁling construct termination policy encourag framework planner searches backwards  ing performance expect greedy performs goal state sg reach initial state si bonet  time important cost impor geffner  guide search compute hn  tant greedy solution useful compared greedy ing admissible heuristic tp planner haslum  speedy offers little advantage                       geffner  heuristic estimates shortest                                                        makespan each single predicate pair pred    multiple sequence alignment                      icates reached initial state si  thisiscom  alignment multiple strings recently popular puted dynamic programming starting  main heuristic search algorithms hohwald et al  search taking account pairwise mutual exclusion  state representation number characters lations actions planning problem  sumed far each string goal reached char bugsy computed expected number  acters consumed moves consume steps reach shortest makespan solution expected  strings represent insertion ‘gap’ character makespan closest solution expected number  computed alignments ﬁve sequences steps closest solution three values estimated  time using standard ‘sumofpairs’ cost function ﬁrst extracting different relaxed plans hoffmann  gap costs  substitution mismatched nongap characters nebel  approximate closest solution terms  costs  costs computed summing pairwise steps shortest solutions terms makespan  alignments tested set ﬁve biological sequence given search node makespan number regression  alignment problems used kobayashi imai  steps plans used cost time esti  zhou hansen  each problem consists ﬁve rela mates closest cheapest solutions bugsy  tively dissimilar protein sequences each sequence approx relaxed plans extracted backward  imately  symbols long alphabet  symbols laxed planning graph starting set goals  representing amino acids heuristic function hn heuristics order goals actions supporting  based optimal pairwise alignments precomputed different favors actions close intial                                                                                     dynamic programming lower bound search nodes state si indicated heuristic fa                                                    ijcai                                                    
