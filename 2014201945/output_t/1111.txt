            optimal      suboptimal     singleton    arc  consistency     algorithms                        christian  bessiere                         romuald    debruyne         lirmm    cnrs    university montpellier     ecole´ des mines nantes   lina                rue ada  montpellier france            rue alfred kastler nantes france                      bessierelirmmfr                        romualddebruyneemnfr                          abstract                          consistency freuder  finally implementing                                                        simply ac algorithm      singleton arc consistency sac enhances        algorithms enforcing sac proposed      pruning capability arc consistency ensuring past sac debruyne bessiere sac      network arc inconsistent af bartak´ erben  far optimal time      ter assignment value variable algo complexity singleton arc consistency lacks      rithms proposed enforce sac analysis complexity paper study com      far optimal time complexity plexity enforcing sac section  propose algo      lower bound time complexity en  rithm sacopt enforcing sac optimal worstcase time      forcing sac propose algorithm     complexity section  optimal time complexity      achieves complexity optimal reached cost high space complexity prevents      costly space large problems use algorithm large problems section       propose sac algorithm trades propose sacsds sac algorithm better worstcase      time optimality better space complexity nev space complexity longer optimal time neverthe      ertheless algorithm better worstcase time complexity remains better sac algo      time complexity previously published sac al rithms proposed past experiments presented      gorithms experimental study shows good    section  show good performance sacopt      performance new algorithms                sacsds  compared previous sac algorithms      introduction                                          preliminaries                                                        constraint network consists ﬁnite set variables  ensuring given local consistency does lead                                                              set domains  di dj     failure enforce having assigned variable                                                        domain di ﬁnite set val  value common idea constraint reasoning                                                        ues variable set constraints   applied ’shaving’                                                              each constraint deﬁned ordered  straint problems numerical domains limiting                                                                          set varck variables involves set solck  signments bounds domains ensuring bounds combinations values satisfying solution                                       consistency does fail lhomme   sat straint network assignment value domain  used way compute accurate heuristics                                                        each variable constraint network  dpll  freeman  li ambulagan  finally                                                        satisﬁed varc  use cij denote solc  constraint satisfaction problems csps intro say binary  duced singleton arc consistency sac                                                          value domain variable denoted  debruyne bessiere studied                                                        consistent constraint iff exists support  theoretically experimentally prosser et al                                                                                 instantiation variables  debruyne bessiere                                                                                            varc  values domain    nice properties sac real advantage                                                        satisfy ck said arc inconsis  local consistencies enhancing ubiquitous arc consis tent constraint network  arc consistent  tency deﬁnition simpler restricted path                                                        iff does contain arc inconsistent value acp                          sistency berlandier   maxrestrictedpath consistency notes network arc inconsistent values                              debruyne bessiere  exotic local removed  acp  domain say  sistencies operational semantics understood arc inconsistent  nonexpert ﬁeld enforcing removes values  domains does change structure prob deﬁnition  singleton arc consistency constraint net  lem opposed path consistency montanari  work  singleton arc consistent iff ∀i ∈x ∀a ∈ di network ia  dia obtained algorithm  optimal sac algorithm  replacing di singleton arc inconsis function sacoptinout  problem boolean  tent ia arc inconsistent say sac  init phase   inconsistent                                          acp  pendinglist ← ∅ return false                                                         foreach ∈    complexity   sac                                    pia ←  copy domains data structures                                                             diai ←  sac  debruyne bessiere sac       ¬propagacpia di   bartak´ erben  oend time complexity    ←   binary constraints optimal                propagacp                                                                   foreach pjb ∈ djb  theorem  best time complexity expect            qjb ← qjb ∪                                                    algorithm enforcing sac binary constraints oend        pendinglist ← pendinglist ∪  proof according mcgregor  know check   return false  ing value ac does fail  propag phase   ia equivalent verifying each domain dj  pendinglist  ∅  value “path  pop pendinglist  sistent a” pair values aj path  propagacpia qia qia ← ∅  sistent iff deleted enforcing path   sistency pairs involving each variable  ←   ﬁnd value ∈ dj  di  ∅ return false                                                              foreach ∈ ∈  path consistent worst case values                           jb                                                                  djbi ← djbi  qjb ← qjb ∪  dj considered path consistency each    pendinglist ← pendinglist ∪  pair need checked                                                         return true  variable looking value compatible  useless consider variables  linked partial form path consis                                                        scratch each subproblem each time value  tency pairs involving removed using                                                                                 sac inconsistent represents nd  optimal time path consistency technique storing supports potential arc consistency calls avoid costly repe  guaranteed consider each value titions arc consistency calls duplicate problem nd  seeking compatible value pair                                                    times each value beneﬁt  worstcase complexity proving path consistency                                                       incrementality arc consistency each  does fail Σ ∈ Σ ∈ Σ ∈   ed                            dj ckj  dk         generic ac algorithms incremental complexity  furthermore enforcing path consistency com problem single nd  pletely independent enforcing path consistency calls consecutive calls differ deletion  value pair path values   consistent path inconsistent                                                        following subproblem sac  deletion pair  path inconsistent              ia                                                  opt stores current domain noted  data  worst case time complexity                               ia                                                      structure corresponding ac enforcement ia  sac algorithm oΣ ∈ ed   oend                               ia                    propagacp  denotes function incrementally                                                        propagates removal set values problem    optimal   time  algorithm   sac                initial ac executed initialising  sac data structure storing values data structure required ac algorithm use returns  sac inconsistent given value removed false iff arc inconsistent  check sac consistency remaining val sacopt composed main steps making  ues sac data structures use fact ac problem arc consistent line  loop line  takes each  does lead wipe ia sac consis value each domain di creates problem pia  tency holds long values acp ia copy current  line  removal  domain removal value sac values different propagated subprob  checks sac consistency values lem pia arc inconsistent pruned ’master’  acp ia leads better average problem removal propagated line   time complexity sac data structures sac advantage propagating immediately master problem  sufﬁcient reach optimality sac waste sac inconsistent values line  twofold  time reenforcing ac ia times scratch subproblem pkc value removed line     algorithm  called sacopt algorithm enforces selection line  created second sub                sac oend  lowest time complexity problems pjb created removal beneﬁt  expected theorem                              propagation created duplication    idea optimal algorithm don’t line  each created subproblem pjb  want redo potentially nd times arc consistency ∈ djbi qjb pjb pendinglistfor future propagation lines –                  ac lists used use    initialisation phase ﬁnished know coarsegrained algorithm ac mackworth   pendinglist contains values sac ac variables domain  inconsistent value removals contained qia changed needed modiﬁcation direct  propagated pia loop line  propagates bear mind ac used decrease space complex  removals line  propagation fails means ity ond time complexity increases oend  sac inconsistent removed ac non optimal  main master problem line  each subproblem  pjb containing updated propagation  losing time optimality save space  list future propagation lines –      jb                                                sacopt used large constraint networks    pendinglist removals propa         gated subproblems values sac oend  space complexity dif                                                        ﬁcult reach optimal time complexity smaller space  theorem  sacopt   correct sac algorithm   requirements sac algorithm maintain ac nd                                                                                             oend  optimal time complexity oend  space com subproblems ia guarantee oed  total time  plexity binary constraints                        subproblems need use optimal time ac algo  proof soundness value removed di rithm does exist optimal ac algorithm  line  line  pia arc inconsistent requiring oed space obtain nd · ed space  pia arc inconsistent initialisation phase sac process  line  sac inconsistency follows immediately let propose relax time optimality reach satisfac  proceed induction remaining case suppose tory tradeoff space time avoid discussing  values removed line  sac inconsistent general terms instantiate idea acbased  pia arc inconsistent line  means pia sac algorithm binary constraints idea  arc consistent containing sac implemented optimal ac algorithms  inconsistent values sac inconsistent sac ac constraints arity algorithm sac  opt sound                                         sds sharing data structures tries use possi    completeness thanks way pendinglist qia ble incrementality ac avoid redundant work  updated lines – – know end duplicating each subproblem ia data structures  algorithm pia arc consistent value required optimal ac algorithms algorithm requires  remaining end sacopt ia arc space sacopt optimal time  inconsistent sac consistent    sacopt each value sacsds stores lo    complexity complexity analysis given networks cal domain dia subproblem ia propagation  binary constraints optimality proof given list qia note aclike presentation qia  networks binary constraints sacopt works list variables domain diaj changed  constraints arity ac algorithm used sacopt list values removed dia  implement sac algorithm space time com sacopt thanks local domains dia know  plexities obviously depend choice let ﬁrst values longer sac removal  discuss case optimal time algorithm value dia  ac bessiere  ac bessiere regin´  local domains used avoid starting each new ac  zhang yap  used line  tells space propagation phase scratch dia exactly  complexity nd times complexity ac algo main start enforcing ac  rithm oend regarding time complexity ﬁrst ia value removal comparison sac  loop copies data structures propagates arc consistency sac restart scratch each new propagation  each subproblem line  tasks respectively main idea sacsds opposed sac  nd · ed nd · ed loop line  each sub opt does duplicate subproblems pia data  problem called nd times arc consistency structures optimal ac algorithm used data  nd subproblems ac ac incre structure maintained master problem   mental means complexity nd restrictions case ac structure maintains  problem ed nd · ed total lasti smallest value dj compatible  cost arc consistency propagation nd subproblems cij built updated   nd · ed add cost updating lists lines used subproblems pia avoid repeating constraint    worst case each value removed checks   nd values nd lists leading nd sacsds algorithm  works follows  updates pendinglist  total time complexity initialisations lines – sacsds repeatedly pops value  oend optimal                           pendinglist propagates ac pia lines – note                                                        ’dianil’ means ﬁrst enforcement ac  remarks  chose present qia lists lists values  initialised line  arc  propagated ac algorithm used spec ia   ia                            ia  iﬁed value removal accurate informa included initialisation step main loop avoid  tion using ﬁnegrained ac algorithm repeating similar lines code better implementation algorithm  sacsds   algorithm                  problems faster lines – know   function sacsdsinout  problem boolean    support cij lower lasti     acp  pendinglist ← ∅ return false subproblem data structure    foreach ∈                               shared subproblems modiﬁed       dia ← nil  qia ←                           propagsubac  lasti guar       pendinglist ← pendinglist ∪            anteed smallest support subproblems    pendinglist  ∅                            achieving ac  propagmainac does update       pop pendinglist                     data structure difference ac       ∈ di                                 line  needs store deleted values removed          dia  nil dia ←  di ∪                                                         during propagation removals performed          propagsubacdia qia qia ← ∅                                                  directly transferred subproblems            di ← di   deleted ←    effort proving inconsistency each subproblem            propagmainacd deleted      function updatesubproblems               updatesubproblemsdeleted              moves values deleted subproblems            return false                         updates local propagation lists qia pendinglist   return true                                        future propagation subproblems   function propag mainsub acinout domain set  theorem  sacsds correct sac algorithm                                                         oend time complexity ond space complexity                            inout deleted set  boolean                                                         binary constraints    ∅      pop                                    proof soundness note ﬁrst structure      foreach ∈ ∃cij ∈              dated achieving ac support         foreach ∈ di lasti ∈ dj dj greater equal lasti            ∃b ∈ dj  lasti ∧ cij domains subproblems subdomains                lasti ←                      support value cij subproblem                                                  greater equal lasti explains               di ← di   ← ∪        propagsubac  beneﬁt structure                deleted ← deleted ∪          losing support lines – observation         di  ∅ return false                soundness comes reason sacopt   return true                                          completeness completeness comes fact      · · ·  propagmainac propagsubac  deletion propagated initialisation lines    procedure updatesubproblemsin deleted set         pendinglist  main loop sacsds pro                                                         cesses subproblem    each time   foreach ∈  djb ∩ deleted  ∅                                ia      qjb ← qjb ∪ ∈  djbi ∩ deleted  ∅     value sac inconsistent ia      djb ← djb  deleted                             arc inconsistent line  deletion      pendinglist ← pendinglist ∪            sacinconsistent value makes arc inconsistent line                                                          propagmainac  called line  removed                                                         subproblems line  pendinglist local   consistent sac inconsistent removed propagation lists updated future propagation lines    line  deletion propagated master  end main loop pendinglist   problem using propagmainac line  value removals propagated value   removed set deleted lines   ∈ dia non arc consistent subdomain   set used updatesubproblems line  pass ia   values removed subproblems complexity data structure requires space   date lists qjb pendinglist propagation oed each nd domains dia contain nd values   modiﬁed subproblems                                  variables nd local propagation                                                                                 point explain difference lists qia   space complexity sacsds   propagmainac  propagates deletions mas  ond considering space requirements   ter problem  propagsubac propagates dele sacsds similar sac   tions subproblems pia parts boxes regarding time complexity sacsds ﬁrst duplicates   long propagmainac propagsubac function domains propagates arc consistency each subprob   propagsubac used propagate arc consistency sub lem lines   tasks respectively nd·nd                                                                      problems follows principle ac algorithm nd · ed  each value removal propagated ia   difference comes fact data struc problems update pendinglist qia dia lines   tures ac algorithm modiﬁed using – requires nd · nd operations each subproblem   ac means updated line  worst case called nd times arc consistency   deed data structure useful achieve ac sub nd subproblems domains each subprob                                                         lem stored ac propagation launched   loop sacopt                    domains state end                                                         cpu time sec                                     cpu time sec                density                           density complete constraint networks                                                                                                                                                                                                                                                                                                                                                                                                                                                       zoom non                                                                                 logarithmic scale                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     zoom non           sacopt sacsds                                       logarithmic scale         sacopt sacsds          sac sac                                                               sac sac          sac   sac                                     sac   sac                                     sac   sac                                     sac   sac                                 tightness                                         tightness                                                                                           figure  cpu time     density  figure  cpu time     density   previous ac propagation subproblem spite  ac propagations subproblem value ing model prosser  algorithms im  removed thanks incrementality arc plemented ran pentium iv mhz  consistency propagation nd value removals                                                       mb memory windows xp sac sac  oed  note reach optimal ed com tested using ac algorithms following  plexity arc consistency subproblems note sacx sacx sacoptx versions  duplicate data structures necessary ac optimal sac sac sacopt based acx note sac  ity total cost arc consistency propagations implementation propagation list ac                                                   nd · ed  total time complexity oend     cording recommendations bartak´ erben    sac sacsds  performs better propagation  each combination parameters tested gener  sac removal value ated  instances report mean cpu times  sacsds checks arc consistency subproblems  jb domains  subproblems sac sufﬁcient bet  experiments sparse constraint networks  ter worstcase time complexity sac sac  oend time complexity sac sacsds im fig  presents performance constraint networks having  proves complexity stores current domain  variables  values each domain density  each subproblem does propagate subprob  constraint networks relatively sparse  lems each time scratch furthermore expect variables ﬁve neighbours average  better average time complexity shared structure tightness lower  values sac  reduces number constraint checks required underconstrained networks sac algorithms check  does permit obtain optimal worstcase time com arc consistency each subproblem storing  plexity potential gain assessed exper support lists sac local subdomains sac  imental comparison different sac versions finally opt sacsds does payoff bruteforce algorithm  sac sac each ac enforcement subproblem  sac sufﬁcient sac shows best  new copy built runtime potentially formance  nd · nd times duplication performed                                                          problems having tighter constraints sac incon  each value sacsds creating subdomains                                                ia       sistent values removed tightness                                                         peak complexity mentioned bartak´    experimental    results                            erben  improved propagation sac use  compared performance sac algorithms ran sparse constraint networks sacx x∈  dom uniform constraint networks binary constraints gener    expensive sacx  ated frost et al  produces instances accord generated problems peak complexity sac                                                        sds clear winner sacopt sac    independent ac algorithm used enforcing  times slower                                ac ac preserves oend  time complexity   times slower
