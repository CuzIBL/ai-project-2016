        computational      complexity     dominance       consistency     cpnets        judy  goldsmith             jer´ omeˆ lang        miroslaw  truszczynski´          nic wilson    dept comp   sci              irit               dept comp  sci         cork constraint   university kentucky    universite´ paul sabatier  university kentucky       computation  centre       lexington ky            toulouse cedex         lexington  ky         university college cork       usa                 france                 usa                ireland    goldsmitcsukyedu            langiritfr            mirekcsukyedu          nwilsoncuccie                        abstract                            study computational complexity prob                                                        lems results obtained far concerned restricted       investigate computational complexity   classes cpnets requiring graph variable      testing dominance consistency cpnets  pendencies implied preference statements cpnet      complexity dominance   acyclic certain assumptions dominancetesting      determined restricted classes problem np additional assumptions      dependency graph cpnet acyclic   domshlak brafman  boutilier et al      preferences deﬁne complexity general case remained      cyclic dependency graphs modeled  open problem show fact pspace      general cpnets show domi     complete propositional case exhibiting      nance consistency testing general cpnets section  pspacehardness proof dominance testing      pspacecomplete reductions used      turn consistency testing acyclic cp      proofs strips planning estab  nets guaranteed consistent case      lish strong connections areas       general cpnets domshlak brafman                                                         brafman dimopoulos  detailed examples    introduction                                       discussions section  show consistency testing  problems eliciting representing reasoning hard dominance testing  preferences multivariable multiattribute domain prove hardness results ﬁrst establish                                                           pspace  arise ﬁelds planning design group  hardness problems related proposi  cision making explicit representation preference tional strips planning show problems  dering elements refer outcomes reduced cpnet dominance consistency testing  multivariable domains exponentially large number exploiting connections actions strips plan  attributes ai researchers developed lan ning preference statements cpnets  guages representing preference orderings succinctly assume familiarity complexity class                                                        pspace                                formalism cpnets boutilier et al      refer papadimitriou  details                                                                                               npspace     popular ones cpnet provides succinct represen particular rely later equivalences                                                        pspace    copspace  tation preference ordering outcomes terms local                                                                          complexity results paper address cyclic cp  preference statements form  xi  xj  xi xj  values variable logical condition infor nets earlier work concentrated acyclic  mally preference statement   means given model argue acyclic cpnets suf                                                    ﬁciently expressive capture human preferences  xi strictly preferred xj ceteris paribus  things equal meaning cpnet given simple domains consider instance diner  certain ordering relation dominance set choose red white wine ﬁsh meat  comes derived reading preference statements given red wine prefer meat conversely given meat  outcome dominates say dominant prefer red wine hand given white wine  preferred                                     prefer ﬁsh conversely given ﬁsh prefer white    reasoning preference ordering dominance rela wine gives consistent cyclic cpnet  tion expressed cpnet far easy key prob acyclic cpnet giving rise preferences  lems include dominance testing consistency testing comes cyclicity preference variables does  ﬁrst problem given cpnet outcomes α β necessarily lead cyclic order outcomes  want decide β dominates α second prob  lem asks dominance cycle dominance  generalized propositional cpnets  ordering deﬁned input cpnet let      xn ﬁnite set variables each  outcome dominates preferred   variable ∈  assume ﬁnite domain dx values anoutcome ntuple     dn dx × · · · × dxn  deﬁnition     paper focus propositional variables vari gcpnet locally consistent ∈                                                                      −         ables binary domains let ﬁnite set propo  formula pc ∧ pc unsatisﬁable locally                                                                                 −        sitional variables ∈  set   ¬     complete ∈  formula pc ∨ pcx  overload notation write vari tautology  able values refer ¬x liter                                                        deﬁnition  propositional cpnet cpnet set                        ¬l                        als given literal write denote dual literal  propositional variables locally consistent lo  focus binary variables makes presentation clearer cally complete gcpnet   impact complexity results    conditional preference rule short preference problems cpdominance cpconsistency  rule expression   ¬l literal ﬁned analogously deﬁnition   atom ∈ propositional formula deﬁnition cpnet differs given  does involve variable                     boutilier et al uses explicit conditional pref                                                        erence tables representation compact  deﬁnition  generalized cpnet generalized cpnet easy verify equivalent gives rise  short gcpnet set conditional prefer                                        −              deﬁnition dominance  ence rules ∈ deﬁne pc pc usually deﬁning decision problem critical specify                      −                 written just follows pc equal way represent input instances representation  disjunction exists rule   ¬x affect complexity problem unless stated oth        −  pcx disjunction exists erwise assume gcpnets cpnets  rule  ¬x  deﬁne associated directed represented set preference rules described deﬁ  graph gc dependency graph consist nition  size gcpnet given total                                                  pairs variables appears size formulas p−x px ∈   p−x    complexity results need following  propositional strips planning  representation gcpnets gcpnet said section derive technical results proposi  junctive form contains rules   ¬l tional strips planning form basis complex  possibly conjunction literals case ity results sections   establish complexity  formulas p−x px disjunctive normal form plan existence problems propositional strips planning  disjunction conjunctions literals including  – restrictions input instances make problem  conjunction literals                       useful studies dominance consistency gcp    gcpnets determine transitive relation outcomes nets  terpreted terms preference preference rule   ¬l let ﬁnite set variables state com  represents statement “given holds preferred plete consistent set literals  ¬l ceteris paribus” intended meaning follows view conjunction members state  outcome β satisﬁes β preferred equivalent outcome deﬁned cpnets context  come α differs β assigns ¬l                                                        deﬁnition  propositional strips planning proposi  variable situation say improv                                                        tional strips instance tuple hv α  γ act  ing ﬂip α β sanctioned rule   ¬l                                                                                         ﬁnite set propositional variables  α     αm sequence outcomes ≥  each  outcome sequence obtained previous  α state  called initial state                                      α      α  improving ﬂip say       γ state called goal  improving sequence α αm gcpnet                                                           act  ﬁnite set    each action  αm dominates α written α ≺ αm                                        actions                  ∈    finally gcpnet consistent outcome α act described consistent conjunction literals  strictly preferred α ≺ α prea precondition consistent conjunction    main objective paper establish com literals posta postcondition effect  plexity following problems concerning notion action executable state α α  prea ef  dominance associated gcpnets fect state α state α containing literals  strictions class input gcpnets           α variables mentioned posta liter                                                        als posta assume action ap  deﬁnition                                                              state effect preconditions                  given gcpnet outcomes α plied  gcpdominance                                         hold assumption effect complexity  β decide α ≺ β                                                                                             problem                    given gcpnet decide    propositional  strips plan existence  gcpconsistency                                                    short decide given  consistent                                        strips plan                                                        propositional strips instance hv α γ act    properties gcpnets essential successful plan sequence actions leading  linking original notion cpnets boutilier et initial state α state satisfying goal γ  al                                     plan irreducible action changes statewe assume loss generality action denote states  pairs α α  literal posta appears prea state integer  ≤ ≤ −   omit literal posta changing effect view compact representation state variables  action posta conjunction     zn assuming binary representation  action omitted act effect    dn dn signiﬁcant digit repre    following result proved bylander   sents state contains zi di   ¬zi                                                                                               act    proposition  bylander                         pe  acyclic executing action incre                                                        ments counter action executed  strips plan pspacecomplete                                                        counter reached value −     typically propositional strips instances require claim plan pe  goals complete restrict consideration com plan pe assume plan pe let  plete goals restriction effect complex π shortest plan pe let length  ity plan existence problem remains pspacecomplete ≤ − state π repeats shorter  goalcompleteness restriction lang  plans π pe exist let α α     αm                                                         γ sequence states obtained executing π let    acyclic strips                                                        action used transition αk αk  deﬁnition  acyclic sets actions set actions act  −  exactly  ≤ ≤  acyclic state α hv α α act action ai applies state α  replacing                                                               nonempty irreducible plan informally non π yields plan started α  leads  trivial directed cycles space states induced act  αm  γ appending plan appropriate                                                                                     −   consider following problems      actions increment counter yields plan                                                        pe conversely τ plan pe plan obtained    acyclic strips plan given propositional strips τ removing actions form bj replacing each      instance hv α γ acti act acyclic action ai plan pe      α    γ decide plan   claim assertion follow            hv α γ acti    actionset acyclicity given set act actions proposition                    act      decide    acyclic                     actionset  acyclicity pspacecomplete  show problems pspacecomplete  proof argument membership pspace  proposition                                          standard  prove pspacehardness  proceed  acyclic strips plan pspacecomplete               follows let pe  hv α γ act strips instance                                                        act acyclic α  γ let new action  proof membership pspace evident problem                                                                               deﬁned prea  γ posta  α  easy                                 pspace                                                      restriction strips plan prove   hardness  act ∪ acyclic exists  exhibit polynomialtime reduction strips plan let                                                        plan pe pspacehardness complement  pe  hv α  γ acti instance strips plan                                                       actionset  acyclicity  problem follows                                       counter  idea reduction introduce  proposition  pspace  copspace  sufﬁces  each time action executed counter incremented                                                        prove hardness assertion       counter count   making  use additional variables counter initialized   reaches −  longer incremented  mapping strips plans singleeffect  action executed set actions strips  plans  resulting instance strips plan acyclic                                                        versions strips plan acyclic strips plan    reduction write     xn  deﬁne pe  hv  α  γ act follows         problems important allow singleeffect ac                                                       tions actions exactly literal postconditions            •       xn     zn zi new vari input propositional strips instances refer      ables use implement counter       strictions se strips plan acyclic se strips plan                                                                  pspace    • α  α ∧ ¬z ∧ · · · ∧ ¬zn                        prove         hardness problems                                                       scribe mapping strips instances singleeffect    • γ  γ ∧ ∧ · · · ∧ zn                                                       strips instances                                                • each action ∈ act  include act actions consider instance pe  hv α γ act strips              ≤ ≤                          plan problem act  necessarily acyclic                prea   prea ∧ ¬zi ∧ zi ∧ · · · ∧ zn        each action ∈ act introduce new variable xa      post ai   post                                  ∧ ∧ ¬ ∧ · · · ∧ ¬       set   va∈act  ¬xa  conjunction                                      • furthermore include act actions bi  ≤ ≤ negative literals additional variables addition                                           each ∈ act set xa  xa ∧ vb∈act−a ¬xb                                                                                              prebi  ¬zi ∧ zi ∧ · · · ∧ zn                 deﬁne instance pe  hv  α γ  sact      postbi  zi ∧ ¬zi ∧ · · · ∧ ¬zn               se strips plan problem follows                        • set variables  ∪ xa  ∈ act         gcpdominance  gcpconsistency  problems                                                       constructing reduction direction    • initial state α  α ∧                                                         reduction complex used    • goal state γ  γ ∧                            boutilier et al  fact cpnets impose    • set actions sact   ai  ∈ act       restrictions strips planning firstly strips           posta                         planning allows multiple effects gcpnets allow      let ∈  act   posta   ∧ · · · ∧ lq ﬂips  ¬x ¬x  change value vari            deﬁne                       able constructed reduction strips                                        prea   prea ∧ ∧ ¬li posta   xa        planning singleeffect strips planning section          qi              qi      prea    xa posta     li                   secondly cpnets impose restrictions local      deﬁne                                    sistency local completeness natural                                        prea     xa ∧ ∧ · · · ∧ lq posta   ¬xa counterparts context strips planning    let π sequence actions act  deﬁne sπ dominance consistency problems considered  sequence actions sact  obtained replacing paper membership pspace demonstrated  each action π     aq  posta considering nondeterministic algorithms consisting  consider sequence τ actions sact  peatedly guessing appropriate improving ﬂips algo  τ action ai  posta   rithms work polynomial space show membership  replace actions form aposta denote problems solve npspace consequently  resulting sequence actions act sτ fol pspace npspace  pspace  lowing properties easy check details omitted space restrictions provide arguments                                                        pspacehardness problems consider  lemma   deﬁnitions   π plan pe sπ plan pe  dominance  generalized cpnets  ii τ irreducible plan pe sτ plan prove gcpdominance problem      pe                                           pspacecomplete   reduction problem se  iii act acyclic sact  acyclic strips plan know pspacecomplete  proposition                                          mapping  singleeffect strips problems gcpnets  se strips  plan  acyclic   se strips  plan    dominance problems  pspacecomplete                                      let hv α γ act instance se strips plan  proof se strips plan acyclic  se  strips plan    problem action ∈ act denote la                                                        unique literal postcondition posta  la  problems restrictions strips plan                   membership pspace   follows pspacehardness    denote pre conjunction literals prea                                                        different ¬la recall convention adopted  acyclic se strips plan  prob                                                               earlier pre does contain la deﬁne ca  lem shown reduction acyclic strips plan                                                                                            conditional preference rule pre  la  ¬la  consider instance pe  hv α γ act acyclic                                                    deﬁne mact   gcpnet  ca ∈ act   strips plan deﬁne pe    hv  α γ  sact  lemma  iii instance acyclic se strips sequence states plan corresponds improving  plan problem lemma  ii exists plan sequence α γ leads following result                                          pe exists plan pe    lemma    notation                                                            nonempty  irreducible plan     dominance                                              hv α γ acti γ dominates α                                                             goal section prove gcpdominance  problem pspacecomplete complexity does ii act acyclic mact  consistent  restrict class inputs cp                                                        theorem   gcpdominance   problem pspace  nets use results propositional strips planning complete remains restrictions  section  prove general gcpdominance gcpnet consistent conjunctive form  problem pspacecomplete show com  plexity does change impose requirements lo proof pspacehardness shown  reduction  cal consistency local completeness input gcpnets acyclic se strips plan proposition  let    similarities dominance testing cpnets hv α γ acti instance acyclic se strips  propositional strips planning ﬁrst noted boutilier plan problem lemma ii mact  consistent  et al  reduction presented gcpnet conjunctive form α  γ  boutilier et al given dominance plan hv α γ act nonempty  problem plan existence problem class propo irreducible plan hv α γ act lemma  sitional strips planning speciﬁcations consisting unary γ dominates α        actions actions single effects prove results  dominance  cpnets                             improving sequence α β                                                                                                      ¯  section show gcpdominance  remains       ls improving sequence αα¯ ββ  pspacecomplete  restriction locallyconsistent ii improving sequence αα¯ ββ¯ lt  locallycomplete gcpnets cpnets refer improving sequence α β  restriction gcpdominance cpdominance         iii consistent consistent    show pspacehardness cpdominance                             reduction gcpdominance consistent gcpnets sketch proof let  vixi ↔ yi deﬁnitions                                                        arranged ensure following cpnet    mapping locallyconsistent gcpnets cpnets                                                         suppose holds outcome outcome  let   locallyconsistent gcpnet let                                                              written αα¯ α improving ﬂip      xn set variables deﬁne                                                             changes variable xi furthermore im  ∪     yn     yn ∩  ∅ deﬁne                                                          proving ﬂip changing variable yi  gcpnet  show cpnet improving ﬂip gcpnet outcome α  end ∈  deﬁne conditional preference                                                            changing variable xi applying ﬂip changing  rules qz   ¬z q−z  ¬z  included                                                            variable yi exactly improving ﬂip possible  specifying formulas qz q−z                                                            changing xi holds follows    each variable xi ∈  set                                                            ing yi immediately ﬂipped                             −                             locally consistent             xi  yi  xi  ¬yi                                                         does hold outcome improving  xi depends yi note                 −                                         ﬂips possible change value variable xi  mulas xi xi satisfy localconsistency local                                                            yi make xi ↔ yi hold  completeness requirements                                                          implies ii implies half iii    each variable yi  ≤ ≤ deﬁne                                                        inconsistent inconsistent conversely                                                                             ei    ↔ ∧ · · · ∧ xi− ↔ yi−        suppose inconsistent exists improving                                                                                 ∧xi ↔  yi ∧ · · · ∧ xn ↔ yn     sequence    outcome                                                        improving ﬂip applied outcome does                             −        −         fi  ei ∧ xi fi  ei ∧ xi         hold increases number xi ↔ yi                                                        holds implies hold outcome  finally deﬁne                                                        cyclic write outcome αα¯                              −                                                                     αα¯                yi  fi ∨ ¬fi ∧ xi                cyclically permute form improving sequence                                                        ii implies exists improving                                                    ﬂipping sequence α showing                −       −                      yi  fi ∨ ¬fi ∧ ¬xi                inconsistent                                                                         yi depends variable                                                     note local consistency formulas fi ∧ theorem  cpdominance pspacecomplete   −  fi   ≤ ≤ unsatisﬁable consequently formulas holds restrict cpnets consistent          −                                        yi ∧ yi  ≤ ≤ unsatisﬁable proof use reduction pspacehardness                         qy  ∨ q−y   locally consistent finally      equivalent gcpdominance  problem gcpnets restricted             −                              fi ∨ ¬xi ∨ fi ∨ xi tautology locally consistent theorem  let consistent                                  complete cpnet                   locally consistent gcpnet  let α    let α   β  outcomes      xn β outcomes  consider cpnet       yn respectively αβ denote outcome variables  constructed lemma ii imply          obtained concatenating ntuples α β β dominates α ββ¯ dominates αα¯                            versely outcome written way consistent lemma iii    let α outcome  deﬁne α¯ hardness assertion follows        come     yn obtained replacing α  component form xi yi component ¬xi  ¬yi  ≤ ≤ αα¯  ei        consistency  gcpnets    let  sequence α     αm outcomes    deﬁne  ls sequence outcomes  section show gcpconsistency problem                                                        pspacecomplete using results sections    αα αα αα αα     αmαm let se                           quence       m outcomes   αα¯ theorem          ¯            m  ββ  deﬁne sequence obtained gcpconsistency pspacecomplete holds  projecting each element iteratively removing restriction gcpnets conjunctive form  elements sequence prede                                                        proof  pspacehardness   shown reduction  cessor consecutive outcomes different                                                        actionset  acyclicity    apply function  lemma   deﬁnitions                   section  followed section  maps
