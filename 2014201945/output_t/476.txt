        bounded search symbolic inference constraint optimization                                martin sachenbacher brian williams                                   massachusetts institute technology                          science artiﬁcial intelligence laboratory                                   vassar street cambridge ma                                        sachenbawilliamsmitedu                        abstract                          subproblems likewise symbolic encoding using decision                                                        diagrams bryant  exploit regularities sets      constraint optimization underlies problems   assignments shared preﬁxes postﬁxes collapse      ai present novel algorithm ﬁnite     smaller representation      domain constraint optimization generalizes   techniques push border size problems      branchandbound search reasoning sets   handled avoid fundamental      assignments individual assignments problem memory explosion      practical cases sets assign    idea presented paper extend branchand      ments represented implicitly com      bound search incorporate decomposition sym      pactly using symbolic techniques deci    bolic encoding particular algorithm simultaneously      sion diagrams setbased algorithm com   maintains sets assignments sets bounds      pute bounds faster explicitly searching stead single assignments set cases      dividual assignments memory explosion  represented manipulated efﬁciently using implicit      avoided limiting size sets varying symbolic representation decision diagram set      size sets yields family algorithms based search compute bounds faster explicitly      includes known search inference algorithms searching individual assignments memory ex      special cases furthermore experiments random plosion avoided limiting size sets      problems indicate approach lead sig approach similar domain splitting size sets      niﬁcant performance improvements                 controlled partitions deﬁned domain each vari                                                        able varying granularity domain partitions    introduction                                       family treebased algorithms obtained includes  problems ai planning diagnosis au cently introduced search algorithm called btd branchand                                                                                                           tonomous control formulated ﬁnite domain bound tree decompositions terrioux jegou´                                                                                                  straint optimization problems schiex et al  dynamic programming kask et al  limiting  ability solve large instances optimization problems efﬁ cases show tradeoff exists ex  ciently key tackling practical applications   tremes practical cases advantageous    depthﬁrst branchandbound ﬁnds optimal solutions pick intermediate point spectrum  searching through space possible assignments paper organized follows introduc  prune parts search tree computes lower bound tion valued constraint satisfaction problem framework                                                                         value current partial assignment compares schiex et al   present way exploit structure  value best solution far upper constraints using tree decomposition datastructure  bound branchandbound memoryefﬁcient symbolic encoding known algebraic decision diagrams                                                                                lead impractical runtime size search adds bahar et al   setbased  tree grow exponentially depth increases   extension branchandbound algorithm show    alternative approach infer optimal solutions generalizes existing algorithms finally preliminary exper  peatedly combining constraints approach iments random problems illustrate tradeoff  searchfree does suffer runtime com search inference beneﬁt hybrid strategy  plexity backtracking exponential memory  quirements render approach infeasible  constraint optimization problems    practical cases constraints exhibit deﬁnition  constraint optimization problem  structure exploited order reduce memory straint optimization problem cop consists tuple  requirements decomposition gottlob et al  ex  variables      xn ﬁnite domains  ploit structural properties low induced width order      dn constraints      fm  break set variables constraints smaller valuation structure ≤ ⊕ ⊥  constraints fj ∈ fare functions fj  ×  ×dn → mapping assignments  values totally ordered ≤ minimum  element ⊥ ∈ maximum element  ∈ ⊕  associative commutative monotonic operation  identity element ⊥ absorbing element     set valuations expresses different levels  straint violation ⊥ means satisfaction  means  unacceptable violation operation ⊕ used combine  aggregate valuations constraint hard  valuations ⊥  notational convenience figure  adder circuit consisting gates  denote xi ← assignment value ∈ di gate xor gates input output values ob  variable xi hard constraint corresponding served indicated  assignment valuation ⊥ value xi   likewise regard elements values  special cases constraints constant functions sinking operation denoted sinkf returns                                                        straint forbids ft ≥ gt  deﬁnition  combination projection let ∈                                                                              ½  constraints let ∈ ×    × dn let t↓y denote               ft  ft  gt                                                                sinkf gt   restriction subset ⊆ variables                        combination denoted ⊕      straint maps each value ft ⊕ gt lifting operation denoted liftf turns constraint    projection set variables  denoted hard constraint allows ft   finally comple      ⇓   constraint maps each value ment hard constraint denoted cmplf constraint                                                      valuation  ft  ⊥ ⊥      minft ft     ftk     tk      assignments ti ↓y  ↓y     given cop subset ⊆ variables  structure constraints                                      lm  solution assignment value  fjt ⇓z  approach based exploiting independence properties  particular  ∅ solution value α∗ constraint functions  repre  assignment minimum constraint violation α∗    lm                                                   sented compactly abstractly explicitly listing    fj ⇓∅                                        assignments section characterize prop    example problem diagnosing adder erties present practical problems  circuit fig  framed cop variables start situations valuation   variables straint depend subset variables  boolean signals domain   variables stance constraint fa valuation depends  mode each gate good formally support constraint  shorted input  shorted input  unknown subset variables depends  failure cop ﬁve constraints fa fa fe fe fo  each gate circuit each constraint expresses deﬁnition  support support constraint  gate correctly performs boolean function noted supf variable set xi ∈  ∃v ∈ di  broken output equals st ⊕ xi ← ⇓xxi ⊕ xi ← ⇓xxi  ﬁrst second input broken                                                          example supfa  supfa   unknown way assumption behav                                                        supfe  supfe   ior valuation structure captures likelihood                                                        supfo  support structure constraint  mode   ≥ ·   · multiplica problem abstractly represented through hypergraph  tion real numbers assume orgates                                                          associates node each variable xi hyper  probability  probability                                                        edge variables supfj each constraint fj fig    probability andgates xor shows hypergraph example  gates  probability  probability notion support captures independence   probability value function’s value variables outside support  best solution corresponds likely fault exist independence support instance  circuit example α∗  corresponding                                                        constraint fo    value   stuckatﬁrstinput fault orgate           regardless value  value     introduce operators use later regardless values generally  compare constraints turn hard constraints property weak support exploited  minimum operation denoted minf returns relationship assignments function’s value  straint valuation minimum ft gt                       ½                                described compactly explicitly listing                          ft ft  gt           assignments support efﬁcient solve          minf gt                           gt                problems symbolic level  symbolic encoding using decision diagrams  following present way recognize support  weak support functions through symbolic encod  ing form decision diagrams    decision diagram represents function boolean  variables set values binary decision diagrams bdds  bryant  represent functions values   alge  braic decision diagrams adds bahar et al  repre  sent functions set values decision diagram  rooted directed acyclic graph each internal node  corresponds boolean variable each leaf node corre  sponds value function internal nodes figure  constraint fo example fig   children recursively interpreted func add using binary variables encode  tion  xi xi boolean vari variable ordering ≺ ≺ ≺ assignments paths  able corresponding node interpret value  shown  subdiagrams root nodes respectively    power decision diagrams derives reduc  tion rules canonicity representation decision dia  gram ordered imposing variable ordering ≺  ≺    ≺ xn paths root  leaves sequence variables encountered obeys  dering ordered decision diagrams reduced itera  tively applying graph reduction rules collapse  signments sharing common preﬁxes postﬁxes share  common postﬁx function value  node deletion rule eliminates nodes diagram  children equal  node sharing rule elimi figure  hypergraph left tree decomposition right  nates nodes root nodes isomorphic sub example fig  tree shows labels χ λ  diagrams reduced ordered decision diagram canon each node  ical representation function bryant   tains variables support function  easy extend technique nonbinary variables map  tree decomposition  ping each nonbinary variable xi block dlog  di tree decomposition gottlob et al  kask et al   boolean variables encode domain values logarithmi way exploit structural properties decompose  cally figure  shows reduced ordered add representing original problem independent subproblems “clusters”  function fo operations functions projec  tion combination directly performed rep deﬁnition  tree decomposition tree decomposition  resentation complexity operations depends problem  triple χ λ   size diagram number nodes arcs rooted tree χ λ labeling functions  number possible assignments sharing associate each node cluster vi ∈ sets χvi ⊆  common substructures number nodes arcs λvi ⊆   orders magnitude smaller number possible  each fj ∈  exists exactly vi  assignments compaction achieved worst fj ∈ λvi vi varfj ⊆ χvi covering  case certain types constraints shown dition  size decision diagram grows logarithmically                                                           each ∈ set ∈  ∈  χv   number assignments bryant                                                                                                                 vertices labeled xi induces connected subtree                                                            connectedness condition    setbased branchandbound tree                                                        addition demand constraints appear close     decompositions                                     root tree possible  section independence proper                                                              varf  ⊆ χv     varf  ⊆ χv      ties functions described previous section support                                                                                          ∈ λv   weak support exploited framework branch parent     andbound search algorithm uses tree figure  shows tree decomposition example  decomposition hypergraph exploit support separator node denoted sepvi set variables  functions setbased search exploit weak sup vi shares parent node vj sepvi  χvi∩χvj  port functions algorithm beneﬁts compact convenience deﬁne sepvroot  ∅ intuitively sepvi  representations functions memory explosion set variables connects subproblem rooted  avoided through depthﬁrst search                    vi rest problemdeﬁnition  subproblem cop tree decompo  limiting cases partitions consisting sin  sition χ λ subproblem rooted vi cop gleton sets pi  di partitions consisting  consists constraints variables vi single set containing domain values pi    scendant vk vi  variables sepvi notational convenience denote xi ∈                                                        restriction variable xi values partition element    subproblem rooted vroot identical problem            ∗                                           constraint variable xi valuation ⊥  ﬁnding α original cop beneﬁt tree value   composition each subproblem needs solved                                                             setbased algorithm proceeds assigning partition el  possibly involving reusing solutions optimal                                                        ements variables  computing lower bounds  solutions obtained optimal solutions sub                                                                      combining constraints variables  problems using dynamic programming complexity                                                        assigned partition element contain  constraint solving reduced exponential                                                        domain value result general function set  size largest cluster                                                        assignments single assignment need    order exploit decomposition during search generalize basic test branchandbound algorithm  variables assigned order compatible – comparing lower bound upper bound – compar  tree ﬁrst assigning variables cluster ing functions  assigning variables rest subproblems  rooted cluster called compatible order proposition  given cop variables ⊆  jegou´ terrioux  terrioux jegou´  let fu function supfu ⊆ let fa set  jegou´ terrioux present algorithm called btd assignments ⊆ fa function supfa ⊆                                                         assignment  extension  tracking tree decompositions exploits tree decom                             lm  positions branchandbound search btd assigns variables variables improve fu  fjt ⇓z   compatible order beginning variables fut sinkfa ⇓z  fu ⇓z    χv                     root  inside cluster proceeds like classical branch sinking operation generalizes comparison                                              λv   andbound taking account constraints lower bound upper bound “ﬁltering out” assign  cluster variables cluster ments improve bounding function   signed btd considers children assume                                                                                              algorithm  shows pseudocode resulting algo  child  btd ﬁrst checks restriction                                                    rithm sbbtd setbased branchandbound tree decom  current assignment variables sepv  previously                                                      position sbbtd given constraint corresponding  computed solution subproblem rooted                                                                                set current assignments values cluster  value solution called “good” retrieved                                                                                              set variables remain assigned  combined value current assignment pre              vi                                                        upper bound function support subset vari  venting btd solving subproblem called                                                                      ables sepv  constant case    “forward jump” search btd solves                                    root                                                        sbbtd returns constraint corresponding extension  subproblem rooted current assignment sepv                                                     assignments solutions subproblem rooted  current upper bound records solution                                                                                                   result constant case    new good value combined value current                                     root                                                        valuation constraint value best solution  assignment result upper bound btd                                                        subproblem rooted vi value greater equal  proceeds child vi                                                        fut best value greater equal fut                                                        sbbtd uses functions  record goods    setbased search                                                          vi  vi                                                        lutions subproblem rooted vi each vi gvi  following generalize btd single assignments soft constraint contains actual goods rvi  single bounds sets assignment sets hard constraint contains information  bounds order exploit symbolic representations signment recorded good use  functions                                            functions necessary good value                                                        function sufﬁcient information    method use extend search single             vi  assignments sets assignments replace step good stored assign                                                        ment recorded good separator    assigning value variable general step                                 vi                                                        recorded  ⊥ case good recorded  stricting variable subset domain generaliza        vi                                                        value initially   ⊥  tion similar domain splitting domain     vi            vi    vi  splitting split subsets subsequent levels sbbtd starts ﬁltering assignments value  search tree consider case each variable exceeds bounding function line  inside cluster lines  occurs each path search tree  sbbtd operates like branchandbound                                                        restricts variables subsets domains partition el  assume each variable xi static predeﬁned partition  domain subsets given                  ements instead single values variables                                                        cluster assigned sbbtd turns children lines  deﬁnition  domain partition partition ﬁnite  sbbtd chooses child vj ﬁrst computes sub                                                                           main di set pi disjoint subsets di whoses union di set assignments fa fa previously recorded  ∩p  ∅  ∈     goods sepv  line  assignments                                p∈pi                       jsbbtdfa vi yvi  fu                               theorem   cop  tree decomposi    fa ← sinkfa fu                                 tion χ λ domain partitions     pn      yvi  ∅                                   variables     xn algorithm sbbtd sound                                                                                                     ∗      ← childrenvi                                complete sbbtd⊥ vroot χvroot   α       ∅ fa                                                            instance consider adder example       choose vj ∈                                                        main partitions              ←  vj                                                                                                                         pa     po  gssu search       fa ←  rvj ⊕ fa                                                       simultaneously explores values        fa                                                         values ss mode variables sbbtd starts          ha ← liftf  ⇓                       sepvj                                                          ← sbbtdh     χv sepv ⇓      assigning variables             clus                                  sepvj   ter  gives assignments hu            ←    ⊕ ⊕                                                                                   vj     vj                                 gi    gi value           ←    ⊕ complh               vj     vj                                sbbtd considers child  instance       end                                                                                                                                            goods recorded cluster far solu       ←  ⊕                 vj                                 tions computed subproblem assignments       ←  sinkf                                                    hu yi  value solutions    end                                                         corresponding failure xorgate      return ⇓               sepvi                                respectively solutions recorded combined                                                          assignments values     choose ∈                 vi                                    respectively solutions subproblem    ←                                                                                                                                                    computed simultaneously assignments hv wi     ←  ∈λv  ∈ supf supf⊆supf ∪x                                                 values   correspond     ∅                                                        ing failure orgate respectively com      choose ∈                                                        bining solutions assignments       ←                                                                                                                                         value   respectively      fa ←  fa ⊕ xi ∈ f∈i                                                       children left sbbtd updates bound best      fu ←  minfu sbbtdfa vi yvi  xi fu   solution  bound prunes subsequent    end                                                        assignments variables hu ai     return fu                                           gi    gi assignments   end                                                        hu yi  subproblem lead values  algorithm  setbased branchandbound tree decom worse bound  returned optimal solution  positions                                               comparison observe btd obtained special                                                        ization sbbtd case pi  di suffers                                                        problem explicitly iterate through possible  recorded goods sbbtd solves subproblem rooted combinations values encountering                                                        best assignment obtained hw yi   vj assignments line  records solu  tions new goods lines   updates val contrast sbbtd handles combinations implicitly dy                                                        namic programming obtained specialization sbbtd  ues current assignments fa lower bounds line   compares current upper bounds line  pi   suffers problem consider  continues child returns solu assignments necessary example com  tions subproblem initial algorithm pute value assignments involving ha ai  hu ui                                                        low corresponds double fault  sbbtd⊥ vroot χvroot     formulation algorithm independent  tradeoff search symbolic  domain partitions deﬁned fig  actually deﬁnes inference  spectrum algorithms parameterized domain  partitions pi each variable limiting cases spec sbbtd uniﬁes search good recording btd dy  trum pi  di pi   corresponding ﬁnest namic programming cte fact goods btd  coarsest granularity domain partitions respectively algorithm computes understood partial construc  ﬁrst case set assignments fa actually consists tion messages sent clusters dynamic  single assignment value smaller  alg  programming algorithm cte kask et al   identical branchandbound tree decomposi limiting cases understood lazy eager forms  tions btd second case restrictions xi ∈ yield dynamic programming respectively btd computes solu  constraints identical ⊥ search tree degener tions subproblems far required compute  ates list case algorithm backtrack optimal solution cte computes completely  free identical dynamic programming previously shown jegou´ terrioux   tree called clustertree elimination cte kask et al btd lazy dynamic programming outperforms cte   cases   pi  di eager dynamic programming search  hybrids search dynamic programming obtained single assignments exploits upper bounds rigorously
