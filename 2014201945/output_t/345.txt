                     conditional planning discrete belief space                                                jussi rintanen∗                        albertludwigsuniversitat¨  freiburg institut fur¨ informatik                             georgeskohlerallee¨  freiburg im breisgau                                                  germany                          abstract                          al  second approach pursued                                                        algorithms conditional planning weld et al       probabilistic planning observability restric bonet geffner  bertoli et al  ignores prob      tions formalized example partially ob abilities directly yields ﬁnitary problem main      servable markov decision processes pomdp   decision problems related nonprobabilistic planning      wide range applications computation partial observability expcomplete rintanen      ally extremely difﬁcult pomdps       main difference pomdps corresponding      general decision problems existence poli nonprobabilistic problems use proba      cies satisfying certain properties undecidable bilistic notions like success probability expected cost      consider computationally easier form plan require plan reach goals certainty      ning ignores exact probabilities al implication success probability  uncertainty      gorithm class planning problems par observations sensing ignored observation      tial observability show basic backup correct probability strictly  good      step algorithm npcomplete pro observation      ceed algorithm backup step  planning problem present iterative algorithm      demonstrate used basis ef resemblance iterative algorithms solving      ﬁcient algorithm constructing plans          pomdps algorithm maintains data structure repre                                                        senting belief states conditional plan    introduction                                       shown exist initially data structure represents                                                        belief states consisting goal states  sequence states visited during plan data structure repeatedly extended performing search  execution exactly predicted example backwards goal belief states  nondeterminism necessary produce plans apply structure paper follows section  deﬁnes  different actions depending plan execution planning problem sections   respectively  proceeded far plans called conditional plans formal framework analyze properties section     construction conditional plans particularly difﬁcult proposes planning algorithm section  presents exper  observability during plan imental results obtained implementation algo  execution possible uniquely determine rithm section  concludes paper  current state world planning problems having  property said partially observable solution  requires sets possible current world states –  planning problem  lief states – implicitly maintained during plan execution section present formalization planning  implicitly represented plan               states atomic objects internal structure    earliest work planning partial observability  framework partially observable markov decision  processes pomdps smallwood sondik  kael deﬁnition  problem instance hs  bling et al  planning pomdps computation set states ⊆ set initial states  ally difﬁcult unbounded horizon lengths unbounded set actions ⊆ × ⊆ set  number probability distributions corresponding belief goal states      cn partition                                                        classes observationally indistinguishable states satisfying  states needs considered ﬁnding optimal plans  general solvable madani et al  natural approach     cn  ci ∩ cj  ∅  easing computational difﬁculty pomdp planning  ≤  ≤  consider horizons bounded length mundhenk et                                                          making observation tells set ci current state    ∗     research partly supported dfg grant ri  belongs distinguishing states given ci possible  action relation states successor block moved happens initially  states action applicable state sos plan goal states     ∈ deﬁne image set states respect                                                                                                                   action imgob  ∈ ss ∈ sos  preimage                                                                                       preimgob  ∈ s∅  imgos ⊆ consisting  states guaranteed reach state  action deterministic partial function    plans directed graphs kinds nodes action compute preimages set actions  nodes observation nodes                          respectively blocks table                                                        split resulting sets different observational classes    deﬁnition  let hs     cni problem                                                                                                                       stance plan triple hn li                                                 • ﬁnite set nodes                                                                                                                            • ∈ initial node                             preimage a−onto−table                                                           preimage b−onto−table                        ×n                                                            •  → o×n∪       function assigns each  preimage c−onto−table      node action successor node ho ni ∈ ×                                                ×n                                       set states successor nodes hc ni ∈                                                                                     cm     cm ⊆          cn ﬁrst case node action  belief states plan consisting      node second observation node       zero actions plans sets states      ∈ hc mi hc mi ⊆ ln ob represented implicitly involve branching      servations intersect ∩  ∅ example plan state set consisting      nodes ln  ∅ terminal                 states respectively blocks table                                                        plan ﬁrst makes    restrict acyclic plans acyclicity means observations branches executes plan asso  graph hn ei hn ni ∈ iff ln  ho ni ciated belief state obtained each case   hc ni ∈ ln acyclic          observational classes each  belief states     plan execution starts initial node maximal state sets branching plan each class  initial states action node label ho ni state belief state chosen observations  execute continue state imgos distinguish belief states class  observation node identify hc ni node label ∈ ﬁnd belief states plans comput  continue plan solves problem ing preimages existing belief states let choose  instance executions terminate terminal node lief states respectively blocks table  goal state execution acyclic plan compute union’s  steps nodes plan    preimage aontotable preimage intersected                                                        observational classes yields new belief states class    problem representation                             clear new state belief state covering                                                        previous belief states class class  introduce representation sets state sets clear new state belief state  plan reaching goal states exists                                                                                                  following example states viewed valuations                           state variables observational classes correspond                        valuations state variables observable                                                                                                                                                                                                 example  consider blocks world state vari                                                                                                                                                                                        ables clearx observable allowing observe                                                                                                                     block each stack three blocks                                     observational classes  valuations                         cleara clearb clearc block clear                    consider problem trying reach state  blocks table each block action computation preimages yields each observa  moving table tional class belief state covering states class                                                        plan belief state             construction cyclic plans requires looking global  properties transition graphs needed acyclic plans example shows exponential number  difﬁculties cyclic plans framework similar state sets corresponding cartesian product ob  mdppomdp framework using average rewards servational classes considered rintanen  repre  stead ﬁnite horizons discounted rewards puterman  sented implicitly algorithm rintanen  explicitly generates state sets number theorem  testing belief space ∈ ﬂatg                                                                                           cases high new representation computa preimgor ⊆ ∈ ﬂatg np  tional complexity shifted size representation complete holds deterministic actions  time takes ﬁnd combination belief states hav  ing useful preimage shift useful reasons proof membership easy  hg     gni choose  space complexity time complexity nondeterministically ri ∈ gi ∈      com  implies traded time complexity state sets pute  preimgor ∪· · ·∪rn verify r∩ci ⊆  represented explicitly unobservable special ∈      ∈ gi each steps  case second succinct representation allows better takes polynomial time  control belief states produce ﬁnd let      cm set clauses propositions  ing new belief state plan takes worstcase expo      ak deﬁne belief space based states  nential time performed clever algorithms     ak aˆ     aˆk     zk zˆ     zˆk states aˆ  sped heuristics                     represent negative literals deﬁne    formalize framework                                                                     ci     aci ∪ aˆa ∈ ¬a ∈ ci ∈                                                                                                                                            hc       zˆ     zk zˆki   deﬁnition  belief space let        par                                                                    hai zii ≤ ≤ ∪ haˆi zˆii ≤ ≤  tition set states belief space ntuple                           ci  hg     gni gi ⊆  ∈      claim satisﬁable ∈                                                                                            ⊂ ∈       ⊆ gi   ﬂatg preimgob ⊆ ∈ ﬂatg                                                          assume  satisﬁable    notice each component belief space                                                                          deﬁne    ziai ∈  ai ∪ zˆiai ∈  setinclusion maximal belief states simplest belief                                                                      ai ⊆ ∈ ﬂatg  spaces obtained sets states bb  hc ∩                                                                                                   each class zi zˆi taken let       cn ∩ bi belief space extended follows                                                           preimgom    ai ∈  ai ∪ aˆiai ∈  ai                                                        show  ⊆ ∈ ﬂatg  deﬁnition  extension let      cn par ∈       ci aj ∈ ci ∩  tition states  hg     gni belief space  aj ¬aj ∈ ci proof goes simi  set states deﬁne g⊕t hg dt ∩c     gn dt ∩                                                                                                  larly zj ∈  aj ∈  aj ∈ cj  cni operation adds set states                                                        aj ¬aj ∈       set sets states eliminates sets set                  ⊆                                                          subset       inclusion maximal deﬁned  ∈ ∪ ⊂ ∈ ﬂatg  ∈ ∪                                                           assume ∈ ﬂatg  preimgob ⊆                                                        ∈ ﬂatg subset ∪ aˆa ∈    belief space  hg     gni represents set                                                        ai aˆi ∈      deﬁne  sets states ﬂatg  ∪ · · · ∪ bnbi ∈ gi ∈       cardinality  ·  ·    ·  model ∈                                                     ∈ show    ∈                                                             corresponding clause ⊆ ∈ ﬂatg    complexity basic operations                                                                                                                  ⊆ ci aj aˆj dci consider  basic operations belief spaces needed planning al                                                                                        case aj aˆj goes similarly aj ∈ ci aj ∈ ci  gorithms testing membership set states deﬁnition  aj  ci holds  belief space ﬁnding set states preimage ∈               respect action contained belief space  analyze complexity operations                                                           planning algorithms  theorem  belief spaces state sets testing based problem representation preceding section                                            ∈ ﬂatg ⊆  com devise planning algorithm repeatedly identiﬁes new  puting ⊕ takes polynomial time                   belief states associated plans plan covering                                                        initial states algorithm figure  tests  proof idea linear number setinclusion tests sufﬁces                                                       plan existence bookkeeping needed outputting                                                        plan size plan proportional number    algorithm extending belief spaces computing erations algorithm performs outputting plan takes  preimage set states lemma  uses exhaustive polynomial time size plan algorithm uses  search runs worstcase exponential time asymp subprocedure ﬁndnew figure  extending belief  totic worstcase complexity likely best possible space nphard subproblem theorem   problem nphard proof fact implementation subprocedure orders sets     fm  reduction sat represent each clause set liter cardinality decreasing order bigger belief states  als satisfying assignment set tried ﬁrst use simple pruning technique deter  literals included sets corresponding ministic actions preimgofi ⊆ preimgofj  question belief spaces              ignore fiprocedure   ﬁndnewoaf                           second lemma says belief states dif   hi preimgoa ⊆ ∈ ﬂath      ferent observational classes each included  return                                        belief state belief space set ﬂath   hi return  ∅                             includes belief states  hf     fm     fki ≥                                                            lemma    let      sets states      ﬁndnewoa ∪ hf      ih                                                                                 ∈      ∈ ﬂath ⊆     ∅ return                                                                                                                             observational class ⊆  end                                                              bi ∩c  ∅ bj ∩c  ∅  return  ∅                                                                                                                                               ∈ ﬂath ∪ · · · ∪ bn ⊆        figure  algorithm ﬁnding new belief states   proof theorem shows algorithm                                                        capable ﬁnding plan constructing  procedure   planiog                              starting leaf nodes construction based   bg                                            ﬁrst assigning belief state each node plan  progress  true                                     showing algorithm reaches belief state                                  progress ⊆ ∈ ﬂath      goal states repeated computation preimages    progress  false               ∈    each                                         theorem   exists ﬁnite acyclic plan                ∅          ﬁndnew                                problem instance algorithm figure  returns true       ∅        begin                                           proof assume plan hn li problem instance            ⊕ preimgob                         hs label nodes plan follows           progress  true                            root node labeled zb         end                                            parent nodes node label assign label    end                                                let ln  ho ni     lnm  hom ni action nodes  end                                                                                                                                                            nm child node let ln   ⊆ ∈ ﬂath return true                                                                                  hc ni        lnk  hck ni    observation  return  false                                                                                                       nodes     nk children zn                                                              zn  ∪ · · · ∪  zn   ∪ zn  ∩  ∪ · · · ∪                                                        imgo            imgom                    figure  algorithm planning partial observability                                                         znk ∩ ck labeling does assign                                                        node assign zn  ∅ each node labeled  lemma   let belief space action pro states possible node execution  cedure ﬁndnewo∅f returns set states show plans zn     znk exist                                                        nk children node possible plan   preimgob ∈ ﬂatf  ⊆  ∈ ﬂath belief state exists algorithm determines plan zn exists  turns ∅                                                induction hypothesis each plan node                                                        paths terminal node length label                                                         zn                  ∈          proof sketch  procedure goes through ele        subset  ﬂat      value                                                        program variable loop exits  ments hb     bni × · · · × fn tests  preimg ∪ · · · ∪  sets ∪ · · · ∪ extended                                                              elements ﬂatf  traversal through × · · · × base case  terminal nodes plan labeled                                                                                            ⊆   generating search tree elements children subsets  lemma                                                        ∈ ﬂath initially  bg  root node elements children child  root node testing preimage repeatedly extended                                                          inductive case ≥  let plan node induc  second parameter procedure represents                                  state set constructed far belief space pa tion hypothesis children zn  ⊆  rameter remaining belief space parameter ∈ ﬂath  belief space extended new belief observation node children     nk  state belong                          respective observations     ck zn ∩                                                           zn ∩ ck occupy disjoint observational classes su    correctness proof procedure plan consists perset zn ∩ ci ∈      ﬂath  following lemma theorems ﬁrst lemma simply says lemma  zn ⊆ ∈ ﬂath                                                                                                            extending belief space monotonic sense action node action child node                                                                                 members ﬂath bigger         imgozn ⊆ zn   induction hypothe                                                        sis zn ⊆ ∈ ﬂath show                                                        zn ⊆  ∈ ﬂath assume  lemma   assume set states ∈ ﬂath lemma  ﬁndnewo∅hh                                                                                ∈ ﬂath ⊕  ⊆          return preimgob  ⊆ ∈ ﬂathand loop exited contrary                   runtime seconds iterations  assumption                                 problem            mbp     bbsp      bbsp                                                           btcs                                                                                    btcs                                                                                   btcs                          theorem  let Π  hs problem instance btcs                        planiog returns true Π solution plan btcs                                                                                   medical                         proof let    sequence belief spaces medical                     produced algorithm show ≥  medical                      ∈ ﬂathi plan reaches        medical                          induction hypothesis hi contains state sets ∈ medical                    ﬂathi plan reaching exists              emptyroom                                                                                 emptyroom                          base case    bg state set  plan reaches                   emptyroom                                                                                emptyroom                        inductive case ≥  hi obtained hi⊕preimgob emptyroom                     ﬁndnewo∅hihi                             ring                              lemma  ∈ ﬂathi induction hypothe  ring                            sis plan π plan executes followed ring                     π reaches preimgob                          ring                            let member ﬂathi show   ring                         plan reaching plan starts ring                     branch show possible observation cor ring                      responding observational class plan ring                    reaches let jth observational class ob bwfo                                                                                   bwfo                            serving cj current state bj  ∩ cj                                                         bwfo                           bj bj ∈ hij bj ⊆ bj hij bwfo                        jth component hi induction hypothesis bwpfo                                                                plan bj bj ∈ hij bj ∈ hijhij  bwpfo                           branch corresponding cj use plan bwpfo                                                                         preimgob bj preimgob ∩ cj               bwpfo                                                                                bwpo                                used partition state bwpo                             space observational classes relatively bwpo                          straightforward generalize deﬁnitions algo bwpo                   rithms case partitions used each  different set actions means possible table  runtime comparison bbsp vs mbp  observations depend action taken      experimentation implementation               mbp runtimes given bertoli et al                                                         better given paper speciﬁcally  implemented algorithm previous sec medical ring problems branching heuris  tion resulting planning bbsp tic used bertoli et al works formulations  heuristic described preceding sections ﬁnd benchmarks branch observable state variable  new chooses bigger belief states ﬁrst implementa possible used slightly different formulation  tion based representing sets states actions manyvalued observation replaced small number                         bdds  burch et al   small improvement boolean observations  belief space representation bdds components  belief space consisting belief state repre runtimes planners given table  runs  sented bdd                                     mhz sun sparcstation solaris                                                        problem instances rintanen     carried comparison mbp planner bertoli                                                        mbp shown cases faster gpt  et al  uses forwardsearch                                                        bonet geffner  faster yka¨  heuristics restricting branching mbp starts search                                                        planner rintanen  problems  initial states proceeds forward taking actions                                                        blocks worlds problems observability  leading set states using observations                                                        btcs bombinthetoilet problem sensing  split current state set smaller ones different                                                        medical problems patients cured performing tests  choices actions observations induce search tree                                                        medicating emptyroom problems navigating    branches needed intersection unknown location center room ring  observational class nonempty plan start problems closing locking windows  action node instead degenerate observation node building consisting cycle rooms bw blocks
