                  counting solutions csps structural approach∗                                                  gilles pesant                          ilog  route des dolines  valbonne france                                          pesantcrtumontrealca                          abstract                          consistency algorithms act domains variables                                                        scope constraint deﬁned ﬁlter      determining number solutions csp  values belong solution constraint      applications ai statistical physics avoiding useless search families      guiding backtrack search heuristics straints values removed polynomial time      complete problem exact ap     globally problem phard vis      proximate algorithms designed suc     ible effect consistency algorithms domains      cessful csp models use higharity global projecting set solutions each variables      straints capture structure problem constraint’s consistency algorithm maintains informa      paper exploits structure derives polytime tion exploited evaluate number valid      evaluations number solutions individ tuples intend show little additional work      ual constraints combined approx sufﬁcient provide close exact solution counts      imate total number solutions used guide constraint given existing consistency algorithm      search heuristics algorithms                                                          global counting problem csps denoted csp      main families constraints discuss                                                        pcomplete restrict binary      possible uses solution counts            straints likely intractable recent theoret                                                        ical work bulatov dalmau  characterizes    introduction                                       tractable classes csps problem quite                                                        restrictive especially practical problems counting  important combinatorial problems artiﬁcial intelli problem boolean csps sat best studied subclass  gence ai operations research disciplines birnbaum lozinskii   cast constraint satisfaction problems csp usually                                                          binary csps exponential time exact algorithms  interested ﬁnding solution csp exists com                                                        described angelsmark jonsson   binatorial existence problem scientiﬁc literature                                                        backtrack search kask et al  adapts iterative join  devoted subject past decades                                                        graph propagation approximate number solutions  important question thoroughly studied                                                        extending partial solution uses results value  solutions combinatorial enumera                                                        ordering heuristic solve csps choosing value  tion problem ability answer question                                                        signment current variable gives largest approximate  applications ai orponen roth dar                                                        solution count implementation optimized binary  wiche  statistical physics burton steif                                                        straints performs compared popular strategies   lebowitz gallavotti  recently                                                        refalo  proposes generic variableordering heuris  guiding backtrack search heuristics ﬁnd solutions csps                                                        tic based impact assignment variable  horsch havens kask et al refalo                                                         reduction remaining search space computed  context estimation number solutions                                                        cartesian product domains variables reports  sought repeatedly search progresses best strategy                                                        promising results multiknapsack magic square latin  overall runtime low trade accuracy                                                        square completion benchmarks necessarily binary  speed computing approximations                                                        csps value variableordering heuristics described    model csp centered constraints rely approximation solution count  structure paper proposes exploit beneﬁt improvement quality andor efﬁ  herent structure derive polytime approximations cient computation approximation  lution count csp combining solution counts com  ponent constraints level individual constraint rest paper section  revisits families                                                        constraints evaluate effort necessary provide solution    ∗research conducted author sabbatical leave counts section  explores possible uses section   ecole´ polytechnique montr´eal               gives examples section  discusses future work  looking constraints                             total number solutions decreases dy − qw    section proceeds through short list usual constraints scy decremented qw ≤ ≤ dy  origin egr´egin  examines domains variables involved  solution counts derived assume straints maintained intervals simpliﬁes com  constraints domain consistent unless stated putation derive closed form  given variable denote domain possible values             ymax−xmin      ymax−xmax−  dx smallest largest value dx xmin             −           xmax respectively number values dx dx              iymin−xmin         use γ mean number solutions constraint γ            ymax · xmax   − xmin · dy                                                                                                binary constraints                                                 −  · xmax  xmax  ymin − ymin   arc consistency algorithms developed clearly preceded equally applies constraints  binary constraints form γx ac ≤  ≥ small adjustments counting  mohr henderson  maintains support counter solutions equality disequality constraints compar  each value dx dy total solution count atively straightforward remember domain consistency  simply sum counters domain achieved  variables                                                     dx                                      γx        scx                        dx · dy − dx ∩ dy                              v∈dx                       appropriate representation intersection                                                        dx  dy incremental version count  scx stands support counter value  requires constant time  domain variable consistency algorithms applications temporal reasoning constants  compute support witnesses needed present binary constraints    support counters available                  constant previous algorithms formulas easily    arithmetic binary constraints                    adapted handle constraints  typically support counters maintained  linear constraints  sistency algorithm arithmetic binary constraints constraint models feature linear constraints form  relies semantics constraint ex                                                        pi aixi ◦ ◦ stands usual relational  ample  knowing xmin ymax sufﬁcient remove operators ai’s integers bound consistency  inconsistent values compute number valid typically enforced fast weak form  couples simply enumerate naively reasoning constraints working domains  require Ωdx · dy time provided domains ﬁltered way likely yield poor approximations  maintained sorted order reasonable assumption enu number solutions  meration Θdx  dy time using running example  constraint −x −x   bound  pointer each domain described algorithm                                                                                             consistent domains dxi      ≤ ≤  admits                                                        seven solutions size cartesian    function lt cardx                              product  value variable totally    let tx ty tables containing values determined combination values taken    domains respectively increasing order upper bound lowered  high                                         constraints actually studied    ≤ dy                                     linear diophantine equations inequations particu      ≤ dx txp  tyq                 lar ajili contejean  offers algorithm adapted                                               constraint programming produces ﬁnite description        −                                    set solutions linear diophantine equa                                               tions inequations    return                                                                             ′                                                              constraints form ≤ pi aixi ≤                                                        ’s ’s belonging knapsack  algorithm  computing number solutions                                                                    straints trick  adapts pseudopolynomial                                                        dynamic programming algorithm builds acyclic graph                    lt cardx           ghaiihxiibb′ size onb time onbd                                                         maxdxi  paths initial node goal node  each value dy ﬁnds number sup correspond solutions pointed enumerating  ports scy dx adds make solutions amounts enumerating paths through depthﬁrst  algorithm incremental storing scy each search time linear size graph  dy qw smallest  tyq each    dx removed dy total number ′                                                        ≤  xaixi  ≤bpaths traversing ghaiihxiibb′    solutions decreases     removed                         scy                dx            iinterestingly approach generalized lift  assignment variables νp   nonnegativity restriction coefﬁcients variables − value extended  expense larger graph size onr repre qx∈xp dx complete solutions  sents magnitude range ﬁnite                               pi                    assignments value  domains                                                                                          νp                                                            cmin − cmax − subset    element constraints                                  identifying νp variables question                                                            signments given each variable ∈ dy∩v   ability index array ﬁnitedomain variable possible values each variable ∈  dz   commonly known element constraint present                                                             possible values totaling  qy∈s dy ∩  practical models given variables array val  ·  dz   assignments  ues elementi constrains equal ith   qz∈p  element  ai note arbitrary putting gives  relation variables functional rela                         cmax  tionship relation potentially number dx · di amongc   dx ·x         solutions corresponding cartesian product vari               x∈xp  kcmin s⊆p  ables functional relationship exactly                          sk−r  tuples consistent values            worst case number sets consider ex               elementi                  ponential number variables preferable                                                      compute faster approximations    exact count improves product domain place constant lower upper bound  sizes factor dx                                 let tin table sizes dx ∩ ev                                                        ery ∈  appear increasing order similarly let tout    regular language membership constraints          table sizes dx  ∈                                                         appear increasing order deﬁne lower bound  given sequence variables  hx     xni       k−r       −kr  deterministic ﬁnite automaton regularx ℓak  qi  tini · qi   touti  strains sequence values taken variables upper bound                                                                   k−r             −kr  belong regular language recognized pesant uak  qi tinp −i·qi  toutp −i   consistency algorithm constraint builds    directed acyclic graph gxa structure similar                       cmax  used trick  knapsack constraints                                                                                        ≥ dx ·x k−r · ℓak   reported section  each path corresponds                                                                             x∈xp kcmin  solution constraint counting represents                                                                                    cmax  complexity overhead respect consistency algo                                                           amongc  ≤     ·      · uak   rithm                                                                          k−r                                                                             x∈xp kcmin   regularx       paths traversing                                             xa           note variables identical domains    constraints                                lower upper bounds coincide obtain exact                                                        count  constraint amongc  variable corresponds  number variables set taking value example  consider amongc    set beldiceanu contejean  let  ∈  dc    dx       dx   dx ⊆  subset variables required value   dx    dx   dx     ∈   dx ∩  ∅ subset    obtain    variables possibly taking value  sets amongc    dx · dx · dx ·  usually maintained consistency algorithm dx ∩   · dx     dx ∩   ·  relationship ≤ ≤ rp  useful ﬁlter domain dx     dx ∩   · dx ∩                                                      ·  ·  ·  ·    ·    ·     using                                                          ≤ amongc        ≤     deﬁne νs number variables set taking                                 value  derive number solutions comparison size cartesian product   ﬁrst make following observations                                                          mutual exclusion global cardinality    νr  constant solution constraints      straint value taken ∈ replaced                                                        constraints concerned      domain remains solution                                                        number repetitions values constraint alldiffx    νxr∪p    constant solution forces variables set different values      constraint value taken ∈  ∪  constraint gccy sequence variables      replaced domain remains  hy     ymi sequence values       solution                                         hv     vmi makes each yi equal number timesa variable takes value vi generalization happen successive transformations                                                distinct connected components safe each resulting    alldiff constraint counting prob matching distinct product  lem includes special case number perfect match number maximum submatchings each connected  ings bipartite graph equivalent phard component bipartite graph identifying connected  problem computing permanent adjacency ma components takes time linear size graph enu  trix representation graph currently merating appropriate cycles paths each  know efﬁcient way compute alldiffx     nected component onm time let  gccy exactly polytime randomized approxima number νg each connected component ∈  tion algorithm permanent recently proposed                                                jerrum et al  time complexity Ωn       alldiffx   ≥   νg           mains prohibitive getting reasonable ap                        g∈c  proximate ﬁgure challenging propose                                                          gcc constraint able adapt ideas  bounds                                                        gave rise previous lower bound consis  upper bound                                           tency algorithm constraint usually based net  dx ⊆ dy variables ∈ regard work ﬂows given network ﬂow through resid  value taken know dy −  ual graph deﬁned circuits graph lead  possibilities remain ∈ dy generalize equivalent ﬂows idea decompose  simple observation considering  dx  ∈ straint constraints singleton sets values  distinct domains each ∈ deﬁne ed  use   ∈  dx  set variables domain  sd  ∈  dx ⊂ set variables  using solution counts constraints  domain properly contained                                                       section examines possible uses solution counts                         ed                           constraints    alldiffx   ≤         −  −                                                       approximate solution count csp                    d∈d                                                         used approximate number solutions  computing requires taking product terms each                                                        csp given model csp consider variables  computed easily onm time probably set constraints collection subsets  faster appropriate data structure maintaining deﬁned scope each constraint add singleton  ed sd sets upper bound interesting variable set partition subset  cause special case domains equal say elements pairwise disjoint union equals      vm simpliﬁes exact solution count section  examples each element                                                      partition corresponds constraint variable case              ym  −    mm −               singleton upper bound number                                                    solutions computed taken cardinality  lower bound                                           domain case singleton product upper                                                        bounds gives upper bound total number solutions  hinted consistency algorithm alldiff                                                        general partitions possible  computes maximum matching bipartite graph                                                        ﬁnd smallest product used  known maximum matching graph ob                                                        course computation variables ﬁxed  tained given maximum matching successive trans                                                        excluded partition new possible partitions emerge  formations through evenlength alternating paths starting                                                        improve solution count  unmatched vertex through alternating cycles each  transformation reverses status edges path  guide search heuristics  cycle question belonged matching longer  does vice versa result necessarily matching saw introduction counts useful  size finding maximum matching develop robust search heuristics allow ﬁner                                                                                                         way costly established evaluation impact generic search heuristic                                                                   fore ﬁnding just transformation away falo  approximation size search  fast provides lower bound number max space worse cartesian product domains                                                                                                    imum matchings equivalently solution count valueordering heuristics kask et al   alldiff                                              good candidates search heuristics following ﬁrst    applying transformations succession fail principle detect failure early possible centered  avoid having check matchings obtained constraints guided count number  distinct sequences transformations fact identical lutions left each constraint focus search                                                        constraint currently having smallest number    alternating path cycle alternates edges belonging lutions recognizing failure necessarily occurs through  given matching belonging    constraint admitting solutions section   evaluate projection tightness                             domains       st partition nd partition                                                          var  solns  impact  solns impact   solns impact  compute ratio approximate solution  count constraint size cartesian product ℓ                   appropriate domains way measuring tightness                       projection constraint individual vari                    ables low ratio stresses poor quality infor                       mation propagated constraints ﬁltered                    domains identiﬁes constraints consistency algo                      rithm improved tightness serve avg  –          –          –      search heuristic focusing constraint currently exhibit                                                        table  comparing different approximations number  ing worst tightness smallest ratio ideal ratio                                                        solutions small map coloring problem  corresponds constraint perfectly captured  current domains variables                                                          corresponding impacts columns      examples                                                                                                note signiﬁcant improvement approxi  purpose section illustrate solution counts mation number solutions cartesian prod  possible uses through simple models easier uct particularly second set partition based  analyse                                              model using alldiff constraint provides    map coloring                                     closer approximation true impact average com                                                        puted impact  away  consider wellknown map coloring problem euro  away average computed impact using cartesian  pean countries belgium denmark france germany lux products  embourg netherlands countries sharing  border color each country asso  rostering  ciate variable named ﬁrst letter represents consider simple rostering problem number daily  color constraints                                    jobs carried employees respecting    ℓ  ℓ  ℓ      labor regulations let set employees days                                                        planning horizon set possible jobs  model problem allow ﬁve colors  le cluding day deﬁne variables jde ∈ ∈ ∈  gal colorings cardinality cartesian product represent job carried employee day  domains variables initially overestimates number ensure job performed given day    set partition  ℓ   state following constraints  provides slightly better estimate using                                                         gcch       day jdee∈e  ∈                                             dx · dy − dx ∩ dy   ·  −       jobs considered demanding  noticing countries pairwise adjacent wish balance workload employees  alternate model                                 troduce variables wde representing workload employee                                                        day link main variables follow         alldiffb ℓ     ing way    yielding better upper bound  solution      elementjde ℓj j∈j  wde   ∈ ∈   count  ·     using  set partition  alldiffb ℓ solution ℓj corresponds load job add  counts constraints csp model particularly straints enforcing maximum workload  high arity quickly provide good approximations                                                                    d∈d wde ≤             ∈       number solutions csps projection tightness              finally work patterns imposed individual rosters  alldiff                             ℓ    taken regularj                ∈      indication search focus                 d∈d    let analyse effect coloring coun appropriate automaton  tries red regardless country choose number approximate number solutions  legal colorings decrease ﬁve fold  colors possibilities set partition variables jded∈de∈e  interchangeable true impact ﬁxing variable mea wded∈de∈e constraints  constraints  sured  minus ratio remaining search space  constraints  deciding  refalo   table  reports af use size number parts qual  ter each country colored red cardinality cartesian ity bounds projection tightness each  product domains column  upper bound straint help partition  size · compared  solution count each set partitions columns   · smaller size
