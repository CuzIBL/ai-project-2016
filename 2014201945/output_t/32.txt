                                 sparsememory graph search                                         rong zhou eric hansen                               department science engineering                           mississippi state university mississippi state ms                                      rzhouhansencsemsstateedu                            abstract                          boundary search graph prevents previously                                                          closed nodes revisited strategy       framework reducing space                                                          adopted pair recent search algorithms korf        complexity graph search algorithms                                                          korif zhang  related earlier work       use open closed lists track                                                          reducing memory requirements dynamic program•      frontier interior nodes search space                                                          ming algorithms sequence comparison hirschberg        propose sparse representation closed list                                                          myers miller  expanded nodes stored       fraction expanded nodes                                                          closed list alternative method solution extraction       need stored perform functions                                                          needed  closed nodes optimal solution path       closed list  preventing duplicate search effort                                                          longer memory search ends       allowing solution extraction proposal                                                          algorithms preserve information nodes       related earlier work search algorithms                                                          middle solution path search ends use       use closed list korf zhang                                                           information divide original problem subproblems       approach ad•                                                          employing divideandconquer strategy recursively re•      vantages make effective wider variety                                                          construct optimal solution path approach reduc•      problems                                                          ing memory requirements results algorithm                                                          distinct phases phase searches start    introduction                                         goal node second phase uses divideandconquer                                                          method reconstruct optimal solution path   graph search algorithms dijkstras algorithm                                                            paper improvements   use open list store nodes search frontier                                                          search strategy earlier search algorithms use strat•  closed list track expanded nodes                                                          egy store closed list korf  korf   closed list performs important fiinctions                                                          zhang  instead include extra information open      allows optimal solution path reconstructed nodes insert additional nodes open list       completion search tracing pointers back• ensure forms boundary prevents leaks       wards goal node start node        closed region instead adding information      graph search problems allows nodes al• open list algorithm preserves ex•      ready reached path recognized panded nodes closed list  create       reached path order prevent boundary allow efficient solution reconstruction       duplicate search effort                           closed region search removed mem•                                                         ory sparse representation closed   functions important storing expanded                                                          list sparsememory approach graph search show   nodes closed list quickly use available memory                                                          results flexible approach reducing memory     willing ability recognize                                                          requirements offers advantages   node reached different paths ida   rbfs solve search problems linear space korf     related search algorithms provide limited abil•  background   ity prevent duplicate search effort storing limited closely related algorithms search algorithm   number expanded nodes reinefeld marsland  introduce paper divideandconquer bidirec•  miura ishida  complex graph search problems tional search dcbs korf  divideandconquer   duplicate paths inability prevent frontier search dcfs korf zhang    duplicate search effort leads poor performance general graphsearch algorithms devel•    fortunately necessary store expanded nodes oped approach performing multiple sequence align•  closed list order eliminate duplicate search ef• ment memorysaving technique use   fort necessary store nodes form used related dynamic programming algorithms se      search                                                                                                  quence comparison hirschberg  myers miller        expansion operators forbidden     provide perspective begin brief     operators used generate successor nodes pre•   description multiple sequence alignment problem   vents search regenerating nodes    detailed description problem refer refer• closed removed memory com•   ences                                                        plication arises case directed graphs  particu•                                                                 lar directed graphs node predecessors     multiple sequence alignment                               potential successors node expanded    alignment multiple dna protein sequences im•      removed memory predecessors    portant problem computational biology provides way   generated inserted open list re•   measure similarity sequences detect re•    generated predecessor nodes later expanded    lated segments alignment involves inserting gaps se•    prevent dcfs modifies open list second way    quences order maximize number matching char•    node expanded generates successor    acters wellknown problem formal•    nodes predecessor nodes  search    ized shortestpath problem ndimensional lattice   path predecessor nodes   number sequences aligned          legal path predecessor nodes assigned     number nodes lattice ln  aver•     infinite cost prevent expanded   age length sequences grows polynomially      legal path   length sequences exponentially num•         make possible reconstruct solution path   ber sequences dynamic programming          end search dcfs modifies nodes way   traditional method solving problem       each node past midpoint search stores in•  shown outperform using admissible heuristic     formation node path halfway be•  limit number nodes lattice need ex•   tween start goal node search com•  amined optimal alignment ikeda imai      pleted dcfs knows middle node optimal solution   lermen reinert  given large number       path reconstruct solution path divideand  nodes usually examined memory bottleneck   conquer approach using search algorithm recur•  techniques solving problem reduced memory      sively solves subproblems finding optimal path   helpful                                           start node middle node middle                                                                  node goal node recursive method solution re•   divideandconquer frontier search                         construction essentially divideandconqucr idea   divideandconquer bidirectional search proposed hirschberg    dcbs korf  divideandconquer frontier   search dcfs korf zhang  use               limitations   strategy reducing memory requirements difference      korf zhang  show dcfs effec•  dcbs uses bidirectional search dcfs uses           tive problem spaces grow polynomially prob•  unidirectional search korf zhang          lem size contain large numbers short cycles includ•  unidirectional search results better performance    ing pathplanning twodimensional grids multiple se•  refer dcfs rest paper                    quence alignment assuming small number sequences      dcfs reduces memory requirements storing        acknowledge search algorithm ef•  frontier nodes search interior nodes  fective exponential problem space branching   using open list closed list does factor case explain open   use closed list dcfs use method avoid    list larger closed list storing   duplicate node expansions extract optimal solution   closed list doesnt save fact multiple sequence   path end search problem avoiding dupli•  alignment problem exponential problem space np  cate node expansions particularly important case  complete just  number sequences     multiple sequence alignment combinatori     aligned bounded branching factor —    ally paths start node node     number sequences size open list   reason linearspace search algorithms test dwarf size closed list aligning   duplicates ida pitiful results words sequences problem wellknown moti•  korf  used multiple sequence alignment    vated development techniques reducing size   boundedmemory search algorithms detect         open list using align multiple sequences   duplicates reported perform poorly    include use upper bound prune open nodes can•  problem yoshizumi et ai                        lead optimal solution ikeda imai      avoid duplicate node expansions dcfs uses fol•       use partial node expansions yoshizumi et al    lowing techniques prevent search leaking      turns difficult combine dcfs tech•  closed region prevent closed nodes  niques reducing size open list creating   regenerated stores each node list for• inefficiencies leaks closed region   bidden operators list includes operator each     possible combine dcfs partial expansion   neighbor predecessor successor node al•  technique reducing size open list allowing   ready generated node later selected     partially expanded nodes yoshizumi et al                                                                                                                    search beneficial cases allowing nodes partially   expanded effect reducing number nodes   closed turn reduces memorysaving effect   dcfs reducing number nodes eligible re•  moved memory experimental results show      approach reducing size open list   prune open nodes cost greater up•  bound optimal cost enhanced ikeda   imai  technique does reduce   number closed nodes idea combining dcfs   appears promising introduces dif•  ficulties recall dcfs generates predecessors   node expanded path  figure  illustration relationships kernel   predecessors nodes pruned open       boundary search interior search frontier   list path extra nodes  entire state space   open list cluttered useless nodes   removed directed graphs special prop•  erty set successors each node disjoint key difference dcfs algorithm does   set predecessors search graph multiple  entirely eliminate closed list instead propose   sequence alignment problem inefficiency neg• sparse representation closed list allows   ative effect pruning open list directed graphs  closed nodes removed memory   share property undirected graphs explain approach note search interior set   pruning nodes open list result leaks    closed nodes partitioned disjoint subsets   closed region follows time node set boundary nodes kernel   generated guarantee best path search interior   pruned using upper bound   definition  let set search interior nodes   later regenerated better path nodes lowestcost paths kernel   forbidden operators associated node   denoted defined follows   generated lost pruned node   previously closed regenerated      difficulty combining dcfs techniques re•    predk denotes set predecessor nodes ofk   ducing size open list significant limitation  set nodes make transition node   potential limitation worth mentioning over•     underlying graph directed undirected   head storing list forbidden operators each node                                                                  basically kernel set nodes predecessor   problems small branchingfactor overhead                                                                  nodes interior closed nodes   slight multiple sequence alignment problem   overhead grows number sequences grows recall        definition  set boundary nodes search interior   number operators branching factor   denoted bi defined nonkernel nodes   multiple sequence alignment dcfs stores in•  coming outgoing edges list forbidden op•  erators total number edges incident node way describing boundary node say                              korf zhang       predecessor nodes interior node   claim space complexity dcfs multiple se•       mathematically   quence alignment compared space   complexity claim rests assumption   node takes constant storage increases storage re•   figure  illustrates relationship kernel   quired list forbidden operators increases exponen•  boundary search interior note nodes bound•  tially fact space complexity dcfs mulitple     ary enter kernel node kernel   sequence alignment advantage               remains nodes kernel eligible re•        space complexity disappears                   moval memory needed prevent                                                                  duplicate search effort    sparsememory search algorithm                                 intuitive meaning boundary explained                                                                  follows closed node reachable   algorithm rest paper adopts     start node set closed nodes considered vol•  strategy reducedmemory search similar    ume underlying graph encompasses starting   strategy used dcfs implements strategy    node nodes outside volume reach nodes inside   simpler way compatible techniques   volume passing through node bound•  reducing size open list does require storing ary storing boundary nodes closed list   lists forbidden operators nodes                         effective storing entire volume respect       search                                                                                                               preventing search leaking closed re•  gion perspective say dcfs adds   nodes open list  search frontier  order   ensure frontier forms boundary treats   closed list kernel removed memory      addition keeping boundary nodes closed   list sparsememory approach keeps non  boundary nodes allow solution reconstruction   method solution reconstruction different   used dcfs recall dcfs stores each node infor•  mation middle node path through node   goal approach each node search graph   maintains pointer predecessor node best path   node earlier ancestral node   path case sparse solution path       node sparse solution path pointer an•  cestral node instead pointer predecessor   ancestral node relay node indicate skips   nodes original dense solution path   consider start node backward pointer re•  lay node relay nodes created used solution   reconstruction explained simply note   relay nodes removed closed list   needed solution reconstruction sparse   representation closed list includes boundary nodes   relay nodes nodes fall category   removed memory      wellknown viewed dijkstras al•  gorithm applied transformed graph set   nodes edges modified edge costs given   equation                cost edge untransformed   transformed graph cost esti•  mate lowestcost path node goal   node present sparsememory algorithm   modification dijkstras algorithm note de•  scription applies sparsememory approach   requires assumptions transformed untrans•  formed graph contain negativecost edges   means heuristic used consistent with•  assumption impossible algorithm   heuristic search algorithm accurately identify interior   search dcfs makes assumption sec•  ond assume algorithm knows indegree   underlying graph node visits comparison   dcfs assumes knows predecessor under•  lying graph node visits second assumption figure  pseudocode smgs sparsememory graph   weaker dcfs                             search procedure expandnode assumes directed                                                                 graph figure  pseudocode expandnode       pointers require memory state information undirected graphs   midpoint node memory required store pointers   plus relay nodes memory required copy state   information midpoint node nodes                                                                                                                  search  pruning closed list   search algorithm able efficiently distinguish   kernel boundary search interior   order prune nodes kernel recall node   kernel predecessors closed identify   nodes introduce technique keeping track   number unexpanded predecessors each generatedand  stored node number value node   initially set number predecessors indegree   node underlying graph minus account   predecessor generated updated during   node expansion each successor node considered   open closed lists   value decremented lines    procedure   expandnode figure  requires negligible time   space overhead given kernelmembership   node determined constant time checking    figure  pseudocode expandnode undirected graphs   closed node zero      advantage sparsememory approach       new start goal nodes order dense solution path   does immediately remove closed nodes memory un•      added tail dsp line    like dcfs sparsememory version dijkstras algorithm       difference dcfs worth noting   acts exactly like dijkstras algorithm   dcfs divides problem subproblems each level   senses memory exhausted      recursion sparsememory approach divide   does invoke procedure pruneclosedlist figure  re•    problem subproblems extra flexibility   cover memory procedure prunes nodes closed      possible sparsememory approach uses relay   list steps updates ancestral pointer nodes ancestral pointers dcfs stores infor•  boundary node predecessor pruned lines   mation middle node each node problem     necessary allow solution reconstruction  divided subproblems subproblems   requires finding relay node closest boundary   smaller easier solve solution reconstruction   node solution path lines  updating an• faster fact relay nodes spaced half intervals   cestral pointer accordingly line  makes boundary onethird intervals interval allow tradeoff   node relay node prevent pruned  sparseness search interior speed   future set toline  step kernel         solution reconstruction   nodes pruned unless start node relay node   created previous pruning step lines  updating   pruning open list   ancestral pointers nodes followed pruning creates   sparse solution path complete dense solu•   consider easily sparsememory approach   tion path reconstructed search terminates    pruning closed list combined techniques                                                                  pruning open list pruning nodes open list                                                                  cost greater upper bound optimal    solution path reconstruction                                                                  cost creates difficulties dcfs discussed earlier   fact closed list pruned unless memory   advantage sparsememory approach does   close exhausted means overhead solution   create difficulties solving problems   reconstruction avoided memory resources ade•     set predecessors node disjoint set succes•  quate case sparsememory algorithm acts exactly  sors multiple sequence alignment problem   like dijkstras algorithm optimal solution path advantage illustrated experimental results   extracted conventional way                            directed graphs directed graphs      closed list pruned optimal solution     node predecessor succes•  path reconstructed invoking sparsememory graph      sor node dcfs allows leaks closed   search algorithm smgs figure  recursively     region open list pruned sparsememory ap•  sparse solution path ssp extracted line  con•  proach does advantage unfortunately   ventional way tracing pointers backward goal      sparsememory approach problem graphs   corresponding dense solution path dsp re•        best path node   constructed follows each pair consecutive nodes     generated pruned regenerated later                           ssp starting start    better path erased node   node algorithm checks pre•                pruned nodes decremented   decessor line  nodeis added                  zero result sparsememory algorithm   tail dsp line  search algorithm recover memory closed list   calls recursively                       experimental results suggest inefficiency minor       search                                                                                                               
