                                                                                           constructing called safe                                                                                       accepts informal software specification input                                                                                      produces formal operational equivalent  example                    metaevaluation tool                                     transformation accomplished automatically                                                                                      techniques described paper interaction                         program understanding                                                                                      specifier required resolve particular                                                                                      informal constructs insufficient context exists                robert balzer neil goldman david wile                                                                                              consists three phases da linguistic                         information sciences institute                                                                                      phase acquires model domain  identifies                       university southern california                                                                                      individual actions performed  planning phase                               admiralty way                                                                                      creates control structure actions                        marina del rey california                                                                                       metaevaluation phase focus paper                                    abstract                                                                                              purpose metaevaluation process            formal program specifications difficult write                     simulate runtime environment program provide   constructed informal precursor                         context disambiguating informal constructs contained                                                                                      program description provide three separate   exploring technology required aid                                                                                      capabilities  ability simulate state program   construction formal specification informal                                                                                      executed  ability form ordered set   version                                                                                      hypotheses intended meaning informal                                                                                      construct  ability test hypotheses            informal specification differs formal                                                                                      criteria second capabilities represents    information writer believes reader                                                                                      theory informality resolution program specification    infer context supressed                                                                                      provides operational theory wellformed programs   specification resolution supressed information                                                                                      eliminates hypothesis satisfy rules   depends information contained parts                                                                                      theory provides data testing   specification knowledge makes                                                                                      wellformedness rules   specification wellformed ability model parts    specification interacting                                                                                              combination three capabilities provides                                                                                      mechanism effectively applying theories informality            paper describes technology used running    embodies theories program wellformedness                         resolution program specifications program    informality resolution context established                      wellformedness task understanding informal program    symbolically executing program systematically discover                     specifications following sections major    intended meaning each informal construct                         features each capabilities followed    informal specification                                                           example illustrating interaction                                                                                      informal program specification metaevaluated    keywords metaevaluation symbolic execution informal    specification program specification understanding systems                              describing capabilities    informality resolution program wellformedness                                   consider language program                                                                                      disambiguated expressed types informality                                                                                      allowed                                  introduction             producing good specification recognized                                              program model   critical precursor producing acceptable software   implementation considerable effort expended                                   mentioned metaevaluation process   produce better formalisms software specification                           final phase larger  deals   believe difficulty lies formalisms                       wide range informal constructs program specifications   aid creating formalisms                     starts parsed version natural language   better formalism required                                              program specification acquires augments                                                                                      description relevant domain specified           software specifications created                  program operate regard similar   informal language converted external                           simons understand  determines objects   formalism aided                      exist domain relate objects   conversion process informal formal significantly                   constraints satisfy   aid specifier                                                                 manipulated program specified                                                                                                work described      note research supported defense advanced                        concerned acquired domain represented       research projects agency darpa contract                                specified program expressed informal       dahc   arpa order  program                             constructs remain unresolved       codes                                                                                              begin model program       acknowledgement deedly indebted professor      herbert simon comments work                          feel central success      deepened understanding sharpened perception                         model derived desire minimize translation      relation pioneering work professor newell                    informal natural language specification avoid      understanding illformed problems                                           issues representation optimization colored                                                                  auto pro bal                                                                                 program models semantics                      statement pattern statement statement   programs simple possible programs                          causes statement executed pattern matched   understood composed                                            statement executed iterative                                                                                     statement tor pattern statement causes           program model largely derived                       statement repeatedly executed each portion   concerns simplifying systems task resolving informal                   data base matches pattern placemarkers   program specifications strongly believe program                     pattern bound named objects matched portion   model suitable syntactic sugar appropriate                     data base demonic statement   people express formal unambiguous operational program                           pattern statementd causes statement   specifications                                                                   executed relation added data base                                                                                     enables patten matched           avoid issues data representation uniform   representation known closely mirrors                                    finally prevent intrusion representation   original parsed natural language specification selected                      considerations associative relational data base supports   representation fully associative relational data base                    inference distinction explicit implicit   used hold data manipulated program                        computed data ignored   object data base thought named point   space meaning defined totally objects                                order programming model represents   points connected relations lines                              integration data handling fully associative                                                                                      relational data base control aspects conventional           actions changes allowed data base                   programming language believe combination   creation destruction named objects making                       provides particularly simple basis stating analyzing   breaking relations addition                               unoptimized operational program specifications   information extracted data base                               provides solid foundation work informality   sideeffect free manner extraction mechanism does                       resolution   change data base patternmatch language   language enables associativity data base                                              program simulator   used access object connected named object   appropriate relation object accessed bound                                  purpose program simulator simulate   placemarker used access                          runtime environment exist each step   objects placemarkers bound                                   execution program provide data resolve   patternmatch rebound merely                                informalities program complexity capability   indirect reference named object                           arises desire simulate runtime environment   bound                                                                             typical execution particular set                                                                                      input data essence wish represent runtime           placemarkers completely replaced variables                    environment function prototypal state   programming model contains variables   assignment statements semantics particularly                               technique symbolic execution    simple bound patternmatch named                        developed symbolically express output function   object data base bound rebound                    inputs technique generally applied   provide means focusing attention                       numeric problems known simplifications   portion data base accessing information                     theorems exist prevent resulting expression   associated referenced named object                                      overly complex                                                                                     simplifications complexity output expression           exception rebinding rule inside                   individual paths through program normally   loop takes form tor pattern                              explored time   statement placemarkers bound iteration pattern   rebound each successive iteration different                              nonnumeric problems simplification techniques   named object named objects unbound                            developed expressions describing   placemarker appears iteration pattern accessed                     state computation complex particularly   manipulated loop body                                                 difficult loops conditional statements loops require                                                                                     use universal quantification loop predicate           data manipulated programming model                        condition controls application loop body   patterns composed relations operations                        conditional statements require splitting computation   each relation arguments                          state cases controlling branch conditional   named object function evaluates named object                    executed   placemarker placemarker bound   named object unbound unbound placemarker                                     alternatives dealing complexity   occurs pattern retrieved data base                   quite clear mastered avoided   pattern successfully matched portion                      majority researchers field pursued   data base placemarker bound corresponding                          alternative working theorem provers   named object match unsuccessful                              simplification systems better able cope   placemarker remains unbound                                                      complexities compiler writers hand                                                                                     avoided complexity techniques data flow           control statements available subroutine                 analysis recognizing purposes   sequence statements conditional statement iterative                     important know exact circumstances   statement demonic statement conditional                               particular data accessed exist                                                              auto prop ralzer                                                                                unknown circumstances accessed                                    metaevaluation proceeds   particular needs allow weaker form analysis                        input data program created accessed   symbolic execution applied program avoiding                     program does exist   complexity                                                                    named objects data base symbolic                                                                                      identity unknown manipulated program just           similar way use analysis                         like actual data data accessed program   program outputs function                        placemarkers bound symbolic data   input resolve informalities program                  program creates new relations involving objects andor   reason weaker form program interpretation                          deletes old ones   metaevaluation adequate technique   avoids complexity executing each loop                                    occasionally constraints data base   informalities loop make sense during                     particular relation singlevalued enable identity   execution picking arbitrary branch conditional                       symbolic object equivalence different   statements execution informalities following conditional                    symbolic objects determined occurs   statement make sense matter branch                               metaevaluation process state data base   executed                                                                         restored point symbolic object                                                                                      used process resumed using discovered identity           addition representing state   computation simple compound expression represent                               rules data base access during   running program program model set                      metaevaluation update data base caused   relations associative data base metaevaluation                      assert delete statements remainder   proceeds control passes statement statement                         metaevaluation process pertains individual types   program data base altered reflect additions                    program statements   deletions specified program data base   reflect state runtime data base program   control reaches each statement program                               subroutine actual parameters   simulation runtime data base enables each statement                             substituted formals subroutine   metaevaluated appropriate environment                                      simulated routine informal   provides context resolve informalities                                   specification metaevaluation process   statement test program wellformedness                                     recursively applied routine                                                                                              simulated assuming preconditions           simulating data base execution proceeds through                            asserting postconditions pre   program quite simple particular set                                postconditions provide way summarizing   input data selected data base                                     requirements results routine   represent programs behavior arbitrary input data                                  actually executing provided   symbolic data created data base                                 library routines program invokes   expressed terms symbolic data                                                  simulated during metaevaluation             recognize input data program                         sequence statements each statement   expressed program model consists relations                              sequence metaevaluated turn   data base accesses having previously   created representation symbolic data data base                        loops loop predicate matches existing   quite simple program simulation started                              relations metaevaluation data base   data base program attempts access                                   loop body metaevaluated each match   data base predicate conditional                                    placemarkers bound matched named   statement following rules applied accessed                                objects match exists symbolic data   pattern matches data existing data base                               created single match loop predicate   pattern match proceeds normally binding placemarkers                               succeed loop body   pattern corresponding named objects data                               metaevaluated newly created matched     base ift hand pattern does match                                     pattern pattern initially   existing data new symbolic data created assumed                               matched normally wont single   input data program                                    new symbolic relation satisfying pattern    pattern match succeed                                                                 created loop body executed each                                                                                               known relation satisfying loop predicate            rationale creating new data match                                   way representing    accessed pattern program assumed                                 universal quantification quantification    data exists unconditionally accessing                            operationally applied data base    unless data does exist program                                   resulting state consistent universal    operate correctly enable program                                       quantification    simulation proceed suitable data created satisfy    accessed pattern existence named                              conditional statement predicate    objects particular identity inferred                         statement assumed false deleted    arguments pattern specified unbound placemarkers                               data base clause    new symbolic instances appropriate type                             metaevaluated data base restored    object created assumed relation                                       state metaevaluating statement                                                                                              predicate assumed true asserted                                                                                              data base clause                                                                  auto proft ralzer                                                                                         metaevaluated present implementation                            placemarker replaced program placemarker           incapable simultaneously representing effects                      previously bound symbolic object equating           clauses separate                                  references different parts program pattern           alternatives branch—the clause—is                           match descriptive reference fails new symbolic           chosen effects reflected                      objects created match succeed           data base metaevaluation succeeding                           reference placemarker bound appropriate symbolic           statements choice based fact                         object left unaltered program treated           clause usually fully developed                      separate placemarker bound actual named           clause normally                            object runtime reference           expected case—the normal path through                                 placemarkers literals program           program                                                                                             pronouns replaced reference type                   theory informality resolution                                  required argument typed references                                                                                     explicitly occur input           previous section described programs                            message ordered set possibilities constructed   behavior simulated statement statement                             possibilities drawn current context   symbolic data purpose simulation provide                       degree closeness typed reference according   context resolving informalities program                      following categories relating type reference   resolution composed parts  hypothesizing                     type placemarker context equals   particular interpretation informality set                   subtype   possible interpretations  testing hypotheses                       connected path single valued relations                                                                                     supertype category placemarkers           types informalities occur                  ordered use program scope placemarkers   program specification  informalities                           placemarkers bound statement predicate loop     correspond way suppression                            predicate parameerst remaining previously bound   explicit information each informality expressed use                   placemarkers   partial construct place intended complete construct   each partial construct algorithms generate                              completely omitted references treated exactly like   ordered set possible completions alternatives                      pronoun case literal instances required   tested wellformedness criteria explained                      type added possibilities supertype ones   section generation algorithms represents theory                       furthermore literal instance selected accepted   informality resolution                                                           binding literal instances acceptable                                                                                     omitted reference treated dontcare situation           types informality handled   safe consider                                    remaining kind informal reference remainsa   resolved during metaevaluation process                                      reference inappropriate type descriptive                                                                                     reference explicit type reference specified type           informalities arise natural                              compatible type required action   communication usage object labeled                     relation reference occurred difficulty   reused later references object instead                         resolved creating new placemarker required type   references tend include little required                        determining ordered set possible conversions   reference objects current context simply                     specified type required type   pronoun type message                      following list subtype   partial description red completely omitted                      connected path single valued relations   reference desired object                          subtype   context reference sufficient   unambiguously select desired object data base                            each kind informality explicit ordered set   simply type desired object associated                    possible interpretations created   object context used references                      possibilities explored simple backtracking search   description incomplete                               process integrated metaevaluation program   ambiguities resolved context established                        informal construct encountered during   running program context input                              metaevaluation possible interpretation selected   description context set objects bound                     metaevaluation continues program   accessible program block includes                            completely metaevaluated program   parameters program embedding iteration placemarkers                       illformed described section   placemarkers bound preceding statements                                   case metaevaluation process state                                                                                     simulated program restored state point           descriptive references resolved pattern matching                   recent informality interpretation selection   simulated runtime data base pattern                        remaining untried possibilities exist untried   match succeeds reference placemarker bound                         possible interpretation informal construct selected   matched object literal                           metaevaluation process resumed   asserted relation previously produced program   previously created symbolic object                                 process terminate finding set   categories objects exist simulated data                      interpretations documentation capabilities   base literal matched placemarker                          yields wellformed formal program   replaced program literal                             determining informal specification unintelligible   previously created symbolic object matched                              wellformed program discovered                                                                 auto pror              ralzor                                                                                                program wellformedness rules                                        expectations fulfilled informal                                                                                             specifications normally include descriptions           section rules                               certain actions performed help create   provide basis rejecting current selected set                               context people understand process   interpretations producing illformed program programs                              cjescribed statements create expectation   highly constrained objects reason hard                               process behave used   construct constraints provide means                                     constraint process behavior   rejecting interpretations informality dont make sense                   specific rules—uncovers implicit informality specifies                                                                                      resolve           rules divided categories  general   ones resolved backtracking through current                           each typed reference nonempty set   set selected interpretations  specific ones                            possible interpretations—if reference   particular fixes program known general ones                                resolved current context   pertain incorrect interpretations informalities                                solution assume verify resolved   explicitly appear program set                                    caller current routine make   alternative interpretations generated explained                             parameter current routine add   previous section specific ones hand                                omitted reference calls routine   pertain implicit informalities program   specific wellformedness rule violated known                         parameters directly referenced   exist unknowingly particular interpretation                              routine—if indirectly referenced   chosen considering alternatives                                 components parameter directly   chosen alternative caused specific formedness rule                             referenced replace unreferenced object   violated alternatives                                 parameters routine   tried                                                                                         statements outside conditional           general rulesresolved backtracking through                                unconditionally consume results produced   explicit informalities                                                                    branch conditional—either make                                                                                              consuming statement producing branch      error occur during metaevaluationin                                  condition execution predicate           program model errors occur violating                                   conditional corresponds informality           constraints data base constraints                                natural language end conditional           particular domain discovered during                               statement normally explicitly signaled           domain acquisition process involve           single relation requiring single                          nonproduced goal specialization           valued combinations relations                                general expectation ruleif statement invoked           boss person work company                                    expected produce result           person                                                                  produces portion goal goal does                                                                                              contain unbound placemarkers outside      predicate conditional statements                                   portion produced assert goal using           determined during metaevaluation—if                               produced portion corresponds           predicate independent input data                                 informality passive construct specifying           branch conditional                                      desired effect action actually indicates                                                                                              desired effect created results           executed program illformed                                                                                              action     each demon procedure specified invoked           bother                                                              conclusion      placcmarkcr loop predicate mut                                    techniques described paper           referenced loop bodyotherwre                         beginning technology understanding informal program           loop body independent loop predicate                        specifications based theories informality resolution           explicitly ruling counting loops                           program wellformedness acting context established           simply determine number objects                               metaevaluation program each areas requires           satisfy criteria                                                    development started experiment                                                                                      interactions prototype     action invoked produces                            successfully transformed small approximately page           redundant results doesnt chance data                           informal program specifications formal operational           base—the invocation produced effect lither                         equivalents examples carefully extracted           invoked invoked different                            actual functional specification manuals prototype           arguments previous action                          accommodated needs example           invoked invoked different arguments                          developing areas expect                                                                                      example driven growth continue     produced relations data base mut                                time theories metaevaluation technology           consumed readaccessed program                          mature complete unfortunately           output—otherwise existence                      unable far represent theories           data base effect                                                   procedural manner growth modification adhoc                                                                                      quite intertwined metaevaluation process                                                                  auto pror ralzer                                                                                
