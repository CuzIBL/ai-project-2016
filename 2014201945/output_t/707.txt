                              dual lookups pattern databases              ariel felner                      uzi zahavi        jonathan schaeffer     robert holte       department information          science dept        computing science department          systems engineering                barilan university             university alberta         bengurion university            ramatgan israel         edmonton tg canada        beersheva israel          emailzahavicsbiuacil      emailjonathancsualbertaca        email felnerbguacil                                           emailholtecsualbertaca                        abstract      pattern database pdb heuristic function stored      lookup table symmetries state space      used enable multiple values looked      pdb given state paper introduces addi      tional pdb lookup called dual pdb lookup dual      pdb lookup admissible return inconsis      tent values paper presents extension      wellknown pathmax method inconsistencies      heuristic values propagated directions child      toparent parenttochild search tree exper      iments show addition dual lookups bidi      rectional pathmax propagation reduce number      nodes generated ida order magnitude  figure  example regular dual lookups      topspin puzzle rubik’s cube      factor sliding tile puzzles                                                          paper concerned ﬁrst step mapping                                                        state pattern looked given pdb    introduction                                       standard mapping called regular pdb lookup  heuristic search algorithms ida guided paper illustrated figure puzzle  cost function fn  gn  hn gn patterns created ignoring tiles    actual distance initial state state hn   each pattern contains tiles     unique  heuristic function estimating cost goal state combination positions resulting pdb  hs “admissible” lower bound tains unique entry each pattern distance  algorithms guaranteed ﬁnd optimal paths       pattern goal pattern shown lower    pattern databases heuristics form lookup ta figure figure depicts regular lookup  bles proven useful deﬁning heuristics pdb estimating distance given state goal  combinatorial puzzles problems culberson figure state mapped  pattern ig  schaeffer  edelkamp  korf felner  noring tiles     pat    domain search space set constants used tern’s distance goal pattern looked pdb  representing states subproblem abstraction speciﬁc pdb represented dimensional  original problem deﬁned replacing constants array db array indexes locations  “don’t care” symbol pattern state subprob tiles     respectively regular lookup state  lem pattern space given subproblem state space db tile  location  tile   containing different patterns connected location  value retrieved regular pdb  using operators connect states original lookup state lower bound serves ad  problem pattern database pdb stores distance missible heuristic distance goal state  each pattern goal pattern typically pdb built original space  searching backwards breadthﬁrst goal pattern common practice exploit special properties  til pattern space spanned given state state space enable additional lookups  original space heuristic value hs computed pdb cullberson schaeffer  al  ing pdb steps mapped pattern ternative lookups pdb based  pattern looked pdb corresponding physical symmetries puzzle exam  distance returned value hs           ple symmetry main diagonal thepdb built goal pattern figure pdb based tiles     available  used estimate number moves required tiles costs puzzle symmetric indepen      current positions state dent exact tiles involved dual question  goal locations simply reﬂect tiles swered using pdb shown figure  positions main diagonal use  replaces names tiles      pdb  retrieving symmetric values idea tile goal location each currently occupy  ﬂecting domain main diagonal having  goal pattern figure turns  set pdbs used korf felner   pattern looked   felner et al  solving   tile puzzles pdb particular dual lookup retrieve value  additive pdbs figure               db state tile  tile ’s goal    valid alternative pdb lookups provide lower location tile  tile ’s goal location  bounds distance state goal maximum example dual looukups nktopspin  taken value hs course trade puzzle tokens arranged ring set  doing this—each pdb lookup increases time consecutive tokens reversed rotated  degrees  takes compute hs additional lookups provide physical puzzle encoding puzzle op  diminishing returns terms reduction number erators each possible reversalrotation figure shows  nodes generated best use possible goal state topspin puzzle figure shows  pdb lookups cullberson schaeffer  number result reversing tokens locations  figure  methods exist reducing time needed compute hs shows result reversing tokens locations   making inferences values actu figure  ally looking pdb holte et al     main contribution paper new alternative                                                                    pdb lookup based properties physical goal state spin goal pattern   symmetries dual pdb lookup dual lookup  admissible unlike previously considered pdb                                                                     lookups return values search inconsis locations − reversed regular lookup state  tent second contribution simple useful extension  wellknown pathmax method inconsistencies                                                                        heuristic values propagated directions child locations −  reversed dual lookup state  toparent parenttochild search tree ﬁnal  contribution dual lookups bidirectional pathmax      figure  topspin states  propagation produce stateoftheart performance three  standard test applications                             suppose patterns topspin deﬁned ignoring                                                        kens  resulting pdb provides distances goal                                                        pattern shown figure reachable patterns    dual lookups pattern databases                  consider figure regular pdb lookup state  states problems sliding tile puzzles based pattern figure obtained  rubik’s cube towers hanoi deﬁned assigning mapping tokens  “” tokens  locations  objects tiles cubies disks locations          respectively regular lookup    explain dual pdb lookup consider  db dual lookup note  pdb puzzle deﬁned regular pdb goal locations tiles  state occupied  lookup asks question cost getting tiles  kens      dual lookup db gives     current locations goal locations cost moving tiles goal locations  general regular lookup focuses ﬁxed set objects lookup corresponds pattern shown figure  ones deﬁne patterns bases lookup dual pdb lookups possible symmetry  current locations vary state state objects locations domain sense    dual pdb lookup roles locations objects each object located location each location occu  switched dual pdb lookup focuses ﬁxed set pies object example domains true  locations – goal locations objects pattern topspin puzzle section  rubik’s cube section   – bases lookup objects occupy posi counter example towers hanoi  tions vary state state particular dual symmetry locations objects  puzzle  pdb lookup figure  asks question cost main difﬁcult blank handled  moving tiles currently goal location differently tiles  tiles     home locations state seemingly asymmetric domain pdbs constructed  figure example dual pdb lookup asks way enable dual symmetry section   cost getting tiles     current  locations goal locations tiles     goal  bidirectional pathmax bpmx  locations figure                           regular pdb lookups produce consistent heuristic values    dual question answered directly during search holte et al  dual lookups admissible necessarily consistent topspin example heuristic     nodes         time    bpmx  let hd result dual lookup pdb fig rd                 ure tokens  goal locations rd              hdb   figure obtained single rdc         dual lookup state uses pattern rd                 figure moves away goal pattern rdc           hdc   inconsistent hdb   rdc                               rd                          mero  described methods propagating     rdc                  heuristic values state children advan rd               tage inconsistencies let state ci children rdc             distp ci cost reaching ci  mero’s rdc              ﬁrst propagation method known pathmax propagates rdc                          heuristic values children hp  − distp ci  lower bound distc  goal used                                                            table  solutions  topspin puzzle  instead hci larger mero’s second method prop  agates heuristic values upwards children   path goal pass through child position implementation numbers        minhci  distp ci lower bound divided  values pdb smaller  distp goal used instead hp  larger  each entry needs  bits pdb needs mb    previous work failed notice operators pdb  tokens actually  different ways choos  vertible costs symmetric pathmax allows values ing tokens included pdb tokens       propagated directions applicable undi used pdb            rected graphs produce useful childrento appropriate mapping tokens single pdb gives  parent propagation mero’s second method          regular heuristics  dual heuristics search                                                        using ida duplicate states avoided                                                      forcing unrelated operators applied successively                                                        order example operator reverses lo                                                    cations     related operator reverses                                                        locations     operator ordering decreased  figure  propagation values inconsistent heuristics number generated nodes order magnitude                                                          table  presents data different heuristics combi                                                        nations each value table average set    bidirectional pathmax method bpmx illustrated                                                         random permutations average solution length  figure  left side ﬁgure shows inconsistent                                                        test set  experiments reported paper  heuristic values node children                                                        run ghz pentium  pc gb memory  left child generated heuristic   propagate                                                          table columns number regular ‘r’  parent right child                                                        dual ‘d’ lookups used presence bpmx cutoff ‘c’  preserve admissibility each propagation reduces cost                                                        number generated nodes nodes ratio  traversing path  example results                                                        number lookups onlyr result time seconds     root   right child                                                        ratio number times bpmx cutoff occurred  using ida bidirectional propagation cause                                                          results show single dual lookup outperforms  nodes pruned expanded                                                        regular lookup factor  generated nodes   example suppose current ida threshold                                                         running time dual lookup frequently  propagation left child root node                                                        “jumps” different areas pdb larger diver          right child                                                           sity different heuristic values explained       expanded using propagation just                                                        section  bpmx cutoff improves factor  described left child improve parent’s value                                                         nodes  time bpmx cutoff appli   resulting cutoff generating right child                                                        cable  times pruning  nodes averaging                                                         nodes instance cutoff performance gains    topspin                                            achieved using additional storage just looking  implemented ideas topspin pdb different ways  puzzle domain    ×  states gen table shows results using lookups  erated pdb leftmost  tokens pattern space taking maximum compared regular pdb   ×     ×    ×  puzzle cyclic lookups dual lookups bpmx fold  assume token number  leftmost duction nodes result better combining                                                        regular dual lookup lookups used    true directed graph undirected graph dualonly lookup solution better regular  shortest path goal pass through parent  lookup solution diminishing returns       heuristic           nodes       time             korf ’s original  rubik’s cube experiments         rd                   repeated time dual pdb lookups korf used         rd                    three pdbs domain pdb  corner cubies         rdc                  pdbs sets  edge cubies legal         rd                    domain moves  cubies way com         rdc                   bine  pdbs taking maximum note         rdc                    corner cubies  used corner         rd                     pdb performing dual lookup particular pdb         rdc                   irrelevant entire space corner cubies         rdc                   database lookups result         rdc                               results set  random instances used         rdc                           korf  obtained results korf’s set                                                            pdbs improved modest adding                                                        dual lookups edge pdbs  billion nodes   table  solutions rubik’s cube edges pdb  billion increasing edges pdb   cubies                                                        using dd  setting reduced search   lookups lookups provide diver billion nodes – improvement factor  korf’s  sity heuristic values improvement initial setting improvements adding dual lookups  factor additional lookup dual regular decreases  edges pdbs modest time    note fastest implementation uses  regular  corner pdb maximum value pdb larger  dual lookups took  seconds –  times faster sin contains cubies  edge pdbs  gle regular lookup using  regular  dual lookups measured rates  million random instances  produces smallest search tree  generated      setting corner pdb  nodes – factor  single regular lookup maximum value  cases    used fastest implementation rdc solve lookups edges cubies maximum   larger versions topspin topspin    ×  times cases rest cases tie numbers  larger   variant solved  instances changed   respectively    topspin   average solution length   mil    setting  lion nodes generated search takes  seconds  topspin    times larger tested ﬁve prob  slidingtile puzzles      lems average solution length  problems                                                                ¢ ¢       ¤ ¤       ¦ ¦                                                                            £ £       ¥ ¥       § §         ¡ ¡                                                                ¢ ¢       ¤ ¤       ¦ ¦                                                                            £ £       ¥ ¥       § §         ¡ ¡                                                                ¢ ¢       ¤ ¤       ¦ ¦                                                                            £ £       ¥ ¥       § §         ¡ ¡                                                                ¢ ¢       ¤ ¤       ¦ ¦                                                                            £ £       ¥ ¥       § §           ¡      averaged  billion nodes took  seconds                                        ¡                                                                ¢ ¢       ¤ ¤       ¦ ¦                                                                            £ £       ¥ ¥       § §         ¡ ¡                                                                                                                                                                             rubik’s cube                                                                                  korf  solved  ×  ×  rubik’s cube contain                                          ing roughly  ×  different reachable states   movable subcubes cubies divided figure  partitionings reﬂections tile puzzles  corner cubies three faces each edge  cubies faces each ﬁrst experiment built implemented new ideas slidingtile  edgecubies pdb largest stored gb puzzles puzzle used  −  partition  memory  possible permutations ing korf felner  figure  pdbs   edge cubies  bits entry mb needed constructed heuristic values added felner  pdb topspin symmetries domain mean et al  preserve admissibility pdbs  multiple possible regular dual lookups reﬂected diagonal obtaining set    table  presents results number possible combina  −  heuristics shown figure   tions setting table headings mean dual lookups domain obvious  ing table  start states used “easy”—  similar locations  tiles similar  different states obtained  random moves goal  real tiles blank given location blank  conﬁguration average solution length       horizontal line symmetric vertical line    results similar topspin experience albeit middle puzzle divides regions  locations  slightly lower dual lookup bpmx cutoffs region  locations occupied  sult large reductions search effort  real tiles region  locations  puzzle time hit lookups diminishing returns occupied  real tiles blank performing dual  taken advantage dual dissipated lookup region tile pdb identical  best implementations reduced number nodes gen topspin rubik’s cube  erated rdc factor  time rdc dual lookup complicated blank figure   factor  possible just edge shows possible blank locations horizontal par  cubies pdb stored memory                          titioning locations blank vertical                                                        heuristic        av        nodes       time                                                                                                                                            rr                                                                                                                                                               dc                                                                                       ddc                                                                   rrddc                     ac                                                          general                                                table  results  puzzle                                                                                            pdbs                      nodes    time   memory     figure  different dual tile pattern databases rr                                                                    rrddc          partitioning regions easily transformed   conﬁgurations reﬂection consider          table   puzzle results  regular tile pdb tiles      corresponds   real tiles region figure pdb average solution instances  ﬁrst  swers question real tiles column indicates heuristic used ‘r’ ‘d’ repre  possible conﬁguration goal conﬁguration dual senting reﬂected regular dual pdb lookups ﬁrst  lookup answer question moves row presents results regular pdb used  takes distribute tiles currently located lo second row took maximum regular  cations      goal conﬁguration tiles reﬂected pdbs note rows  real tiles blank corner getting sults obtained korf felner  current  data regular pdb machine three rows present results different ver  blank corner cases figure  sions dual lookup note domain bpmx  tiles occupying locations      blank cutoff yielded reduction nodes  single  answer dual lookup regular tile pdb dual lookup finally row presents maximum  count moves blank real tile corner pdb combinations using dual lookups reduces  ignored lose admissibility       number generated nodes factor     possible ways solve problem eliminated execution time compared  ﬁrst artiﬁcially blank tile nearest corner best results korf felner  line  table   effect means reducing pdb value knowledge using regulardual normalreﬂected  account extra blank moves preserve admissibility pdb lookups gives best existing heuristic puzzle  use regular tile pdb dual lookup historical note number generated nodes  cost weaker heuristic additional search nearly  times smaller ida ﬁrst solved    better idea add three tile pdbs puzzle using manhattan distance korf   tal four—one each cases figure  each similar experiments performed using puzzle  blank scenario build regular tile pdb assuming original  partitioning korf felner  blank located relevant location example  figure  needed storage tile pdbs  region figure build pdb tiles  ×  rectangles symmetric         assume tile  blank tile need additional pdbs handle blank use  tile  pdb consulted regular pdb assume pdbs  ×  rectangles duals  tile  blank partitioning need  tile pdbs irregular shape left  region corresponds case perform dual corner figure  each tile pdb needs mb  lookup pdb retrieve correct value tiles new needs  times memory  currently located locations        korf felner   random instances   reﬂections similarly blank locations puzzle solved table  presents average results    frame left figure  indicates relevant pdb  easiest problems set  fewest  dual lookup each possible blank location nodes generated average solution length set  locations pdbs given right label  moves using regular dual lookups  dicates pdb use horizontal partition left reﬂections reduces number generated nodes factor  corresponds vertical partition memory  time factor  compared  needed kb tile pdb kb tile results korf felner  ﬁrst line table   pdb total memory needs tile  tile  pdbs kb three extra pdbs needed handle  dual cases correctly represent small increase memory  discussion    table  presents results different heuristics averaged dual pdb lookups double number possible pdb   instances used korf felner  lookups effective domains studied
