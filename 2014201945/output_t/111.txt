                                tractable temporal reasoning            ∗                                clare dixon michael fisher boris konev                         department science university liverpool                                          liverpool bx uk                            claremichaelkonevcsclivacuk                          abstract                          particular models concurrency synchrony asyn                                                        chrony particular coordination cooperation actions      temporal reasoning widely used                                                          paper consider new fragment ptl incor      science ai underly                                                        porates use xor operators denoted ⊕q ⊕⊕qn      ing complexity temporal proof discrete tempo                                                        meaning exactly qi holds  ≤ ≤ nsince      ral logics led use simpliﬁed formalisms                                                        complexity unsatisﬁability xor clauses classi      techniques temporal interval algebras                                                        cal propositional logic low schaefer       model checking paper show                                                        potential carry temporal case      tractable subclasses propositional linear tem                                                          paper provide results      poral logic developed based use                                                        troduce ptl fragment considered called tlx      xor fragments logic show                                                        show complete clausal resolution frag      fragments decided tractably                                                        ment allows split underlying set propositions      clausal temporal resolution show ben                                                        distinct subsets each subset represents      eﬁts combining multiple xor fragments                                                        set propositions exactly proposition hold      combinations establish completeness                                                        termed xor sets remaining set constraints      complexity resolution method                                                        show deciding unsatisﬁability speciﬁcations      temporal language                                                        logic tractable      used application areas example veriﬁca      tion multiagent systems new approach      temporal reasoning provides framework     xor temporal logic      tractable temporal logics engineered logic consider called “tlx” syntax se      telligently combining appropriate xor fragments  mantics essentially follow ptl gabbay et al                                                         models isomorphic natural numbers nofthe                                                                    introduction                                       form σ    tttt each state tiisasetof                                                        proposition symbols representing propositions  temporal logics used wide variety aresatisﬁedintheith moment time notation σ   systems science artiﬁcial intelli denotes truth formula model  gence basic idea proof propositional discrete σ state index ∈ leads semantic rules                                                                   temporal logics intuitive appealing σ  iff σ   complexity satisﬁability logics high σ  ♦a iff ∃k ∈  σ   example complexity satisﬁability propositional σ  iff ∀j ∈  σ   linear time temporal logic ptl pspacecomplete sistla                                                                                                  ∈  clarke  consequently model checking clarke et formula model σ state index                                                                                al  received attention allows users σ holds σ does hold denoted                                                                                             check temporal property holds underlying σ aifthereissomeσ σ  athen                                                                                      model                                  said satisﬁableif σ  models σ                                                                                             temporal problems involve underlying structure said valid written  automaton key property au main novelty tlx parameterised                                                                                               tomaton exactly state each moment xorsets      formulae tlx    problems frequently involve process agents each constructed restrictions exactly propo                                                                           underlying automatonlike structures inter sition set true state example                                                                                           ested properties relating agents progress consider just set propositions wehave    ∗                                                              ⊕ ⊕ ⊕ pn pi ∈p     work authors partially supported  eprsc grant number grs “dynamic ontologies furthermore assume exists set proposi  framework service descriptions”                  tions addition deﬁned parameters                                                    ijcai                                                     propositions unconstrained normal tlx srespk involve xor resolution note ap  essentially standard propositional linear temporal logic ply iresa sresa clauses complementary  tlxpqr temporal logic containing nonxor literals right hand side apply                p∪q∪r                            propositions               pppl   irespk srespk rules clauses dis                                                 ∨    ∨        qqqm       rrrn     junct ∨ right hand side conclusion          disjoint satisfying             equivalent true    p⊕p⊕⊕pl ∧q⊕q⊕⊕qm  ∧r⊕r⊕⊕rn                                                           soundness completeness    normal form                                      similarly fisher et al  degtyarev et al   assume   sets xor   propositions     show parent clauses satisﬁable                                    ppn   pn  pnpnnn  set ad resolvent rules initialandstep res                                  ditional propositions aana  following olution follow pattern ﬁrst prove classical      ∧ −    •  denotes conjunction negated xor propositions propositional counterpart completeness theorem       ij                                               use prove completeness temporal resolution      set pi                                                        consider following classical set resolution rules      ∨     • pij denotes disjunction positive xor proposi sisting rule resa                                                             ∨      ∨     ∨        ∨       ∨    ∨      tions set pi                                 ∨  ∨ ∨  ∨  ∨ ∨¬a      ∧                                                                                   • ai denotes conjunction nonxor literals               ∨     ∨   ∨      ∨   ∨    ∨                                                                  ∨ ∨  ∨  ∨ ∨      ∨                                                                            • ai denotes disjunction nonxor literals                   ∈                                                               therulerespk   normal form tlx form ci each                 ∨     ∨      ∨                                                                      ∨  ∨  ∨  ci initial step clause respectively fol                                                                                      ∨     ∨      ∨  lows                                                              ∨ pk ∨ pn ∨                          ∨         ∨    ∨                ∨    ∨           ∨  ∨          ∨    ∨    ∨    ∨                                                        ∨  ∨ comp     ∨ ∨  ∨  ∨ ∨                 start ⇒  pi ∨ ∨ pni ∨ ai                                                 ∧ −     ∧ −   ∧       ∨        ∨   ∨    pj ∧ pnj ∧ aj ⇒    pj ∨ ∨ pnj ∨ aj                            ∨          ∨    ∨           lemma    set classical propositional clauses unsat                     ⇒   ♦   ∨    ∨    ∨                    true       pk    pnk   ak         isﬁable unsatisﬁability established rules                                                                                ×    ×···×     × na   note semantics xor clauses   resa respk     nn        time               pji ∧ pjk ≡ false    ¬pji ∨¬pjk ≡ true     proof  show unsatisﬁable set clauses                                                                     nj                     nj                 does contain nonxor literals unsatisﬁability             ¬pji ≡ false            pji ≡ true    established rules respk  note set                                                                                                      ≤                                 i              clauses unsatisﬁable            ≡           ¬     ¬   ≡                     set propositions ppplwherepi ∈    pji             pjk   pji            pjk                                                                                          pitheset ppl clauses  contain               pjk∈pj ki          pjk∈pj ki                                                        pl nonempty clause  allow maintain positive xor propositions right contains propositions pplsomaking  hand sides clauses negated xor propositions ppl true satisﬁes  left hand side clauses                              assume clauses consist propositions                                                         pk originally  show rule    resolution rules                                                                                c                                                        respk  obtain unsatisﬁable set clauses  decide validity formulae tlx using form clauses consist propositions pk−  clausal temporal resolution fisher et al thereso  lution rules split three types initial resolution step arbitrary propositions ∈ ∈ pk− ∈                                                                                         ∈c  resolution temporal resolution presented pk− arbitrary clauses pppk−pk   fig  initial resolution resolves constraints holding  ∈cppp ∈cppp                                                                   k−          k− knk ap    initial moment time step resolution involves resolving plying rule respk cnk obtain clause                                                            step clauses deriving additional constraints contra consisting propositions pk−                                                                                                         diction moment derived temporal resolution does contain ppk−thesetc  resolves clause constraint ensures formed clauses c possible combinations  right hand side clause occur      ∈ ∈ ppk− ∈ pk− clearly                                             ∨  ∨         ≤    conclusion resolution rules compij  pik  set propositions ppplwhere                                              ∨                                                                                                       pi ∈ pithesetc pp nonempty unsatisﬁ  denotes disjunction propositions                                                                pij       able applying reasoning times obtain  ∨   pik false propositions common clause  example comp ∨ pp ∨ pp                       consider set clauses contain non    observe iresa sresa apply classical resolution xor literals arbitrary ∈ ppn ∈ pn                                                              right hand side parent clauses irespk sider ppn  similarly previous case                                                    ijcai                                                      initial resolution                                               ∨      ∨   ∨                                    start ⇒   ∨ pn ∨ ∨                                               ∨      ∨   ∨                          iresa     start ⇒   ∨ pn ∨ ∨¬a                                               ∨      ∨   ∨      ∨   ∨    ∨                                    start ⇒   ∨ pn ∨ ∨ pn ∨ ∨   ∈n rule                                         ∨       ∨      ∨   ∨                            start ⇒   ∨ ∨ pk ∨ pn ∨                                       ∨        ∨       ∨    ∨                 ires             ⇒    ∨ ∨  ∨  ∨                      pk     start                                                            ∨   ∨            ∨  ∨        ∨   ∨    ∨   ∨                            start ⇒   ∨ ∨ ∨ compk pk ∨ ∨ pn ∨ pn ∨ ∨   step resolution                                       ∧   ∧−      ∧−        ∨      ∨   ∨                                       ∧ ∧ pn ⇒    ∨ pn ∨ ∨                                       ∧   ∧−      ∧−        ∨      ∨   ∨          sresa                        ∧ ∧ pn ⇒    ∨ pn ∨ ∨¬a                      ∧   ∧   ∧−      ∧−   ∧−      ∧−        ∨      ∨   ∨      ∨   ∨    ∨                     ∧ ∧ ∧ pn ∧ ∧ pn ⇒  ∨ pn ∨ ∨ pn ∨ ∨   ∈n rule                         ∧   ∧−      ∧−        ∨       ∨        ∨                        ∧ ∧ pn ⇒     ∨ ∨ pk ∨ ∨ pn ∨                         ∧   ∧       ∧           ∨        ∨       ∨        sres             ∧ − ∧ − ⇒    gp  ∨ ∨  ∨  ∨              pk                                                  ∧    ∧   ∧−      ∧−   ∧−      ∧−        ∨   ∨            ∨  ∨        ∨   ∨       ∧ ∧ ∧ pn ∧ ∧ pn ⇒  ∨ ∨ ∨ compk pk ∨ ∨ pn ∨ pn ∨ ∨                                          ∧   ∧−      ∧−                                              ∧  ∧    ⇒     false                conv                                                                 ∧−     ∧−       ∧−                 ∧−    ∧−       ∧−                          start ⇒ ¬a ∨¬p ∨ ¬pn     true ⇒  ¬a ∨¬p  ∨ ¬pn   temporal resolution                                                          ∨         ∨                                               ⇒      ¬p ∧ ∧¬pn ∧¬a                            tres                        ∨        ∨                                            true ⇒   ♦p ∨ ∨ pn ∨                                                                                                  start ⇒¬l      true ⇒   ¬l                                   figure  resolution rules xor fragment                                                  cppn nonempty consider set cppn set step clauses  clauses obtained deleting xorpropositions clauses                             clauses cppn everycppn unsatisﬁable given set clauses set propositional symbols                                                       construct ﬁnite directed graph follows  extending satisfying assignment cp                                                     nodes interpretations set propositions  ppn satisfy clauses clas  sical binary resolution able prove unsatisﬁability satisfy xor constraints xor subsets notice                                                       xorconstraints exactly proposi  cppn  applying resa “in way”                                                        tion each set xor propositions pi subset  obtain clause c does contain nonxor                                                       propositions true means  literals ppnthesetc  formed clauses                   na                                                       ×n ×···×nn  ×   nodes behaviour graph   possible combinations ∈ ∈                                                            ∈                                                each node construct edge node  pk−   pk− unsatisﬁable set clauses following condition satisﬁed  taining nonxor literals                                                                                                                    • step clause ⇒ ∈tifi      finally possible implement                                              na               described procedure × ×···×nn ×   time                                                       node designated initial node  ithe                                                        behaviour graph set clauses maximal sub  sketch proof completeness temporal resolu graph given set nodes reachable initial                                           tion obtained combining ideas fisher et al nodes   degtyarev et al  lemma                                                         set unsatisﬁable case    deﬁnition  behaviour graph split set tempo exist derivation iresa irespk described                                                                                                ral clauses three groups let denote initial clauses lemma  × ×···×nn ×   time                                                    ijcai                                                                                                          start ⇒ st      think                    sb bid                                                                  st   ⇒   st ∨ sb     start                                                                                                                                       sb   ⇒    sw                                                                                                                    sa   ⇒    st                                                                                                                    sw   ⇒    sw ∨ sa                                                             ⇒ ♦¬                                                        true      st                           tr                                                       start ⇒ ts                                                                                            receiving                                                     ts   ⇒   tr                                                                                                                   tr   ⇒   tr ∨ tf      assess                   sw wait                                                                  tf  ⇒    ts          finish tf                    figure  automata agents  corresponding clauses normal form                                                                                                         suppose let node rule time polynomial × ×···×nn ×                                   successors let pi ⇒  qi set  step clauses  pithen∧qi unsatisﬁable proof ﬁnd sufﬁces ﬁnd strongly  using lemma  show step resolution proves nected component behaviour graph set of clauses                                                                                                   ¬  ∧pi ⇒    false set clauses extended node component   conclusion conv rule ∨¬pi node deleted simplest bruteforce algorithm analyse pairs                                                                            ×   ×···×    ×na   graph                                       nodes     nn        pairs    case nodes successor efﬁciently step resolution  contradiction derived help tempo degtyarev et al                      ral resolution rule tres note impose restric                                                        theorem   set temporal clauses unsatisﬁable tem  tion rule coincides temporal resolution                                                        poral resolution deduce contradiction time polyno  rule general calculi presented fisher et al                                                                           mial × ×···×nn  ×    degtyarev et al  proof completeness  different published fisher et al   degtyarev et al                                  example                                                        having described underlying approach  complexity                                           sider example makes use aspects  consider initial step resolution ﬁrst  particular multiple xor fragments                                                        standard propositions unconstrained xor clauses  lemma   using rules initial step resolution example use simpliﬁcation abstraction  possible reduce set temporal clauses agent negotiation protocols example ballarini et  behaviour graph does nodes   successors al  case agents exchange                                 × ×···×nn   ×      time                 information order come agreement each agent                                                        essentially simple control cycle repre  proof consider following resolution strategy sented ﬁnite state machine fact simpliﬁed  set propositions ∈ ppn ∈ pn ∈ consider sample basic control cycles given  set stepclauses                           fig  agents         ∧    ∧ −     ∧ −    ∨      ∨    ∨             aim  use automata models       ∧   ∧  ⇒     ∨   ∨                                              agents formalise logic importantly            ∧   ∧ −       ∧ −  ppn contain    add additional clauses propositions characteris                                                   ppn × ×···×nn ×  ing agreements concurrency ﬁnally show  sets clauses try establishing unsatisﬁabil resolution method used carry veriﬁcation  ity conjunction righthand sides begin characterising each agent separately set  universal clauses step resolution lemma  shows clauses logic achieve use set                                             × ×··· × nn ×   time propositions each agent automaton describing  nodes successors deleted agent characterised through propositions form sa  behaviour graph new nodes emerge af sb automaton describing agent charac                          ter × ×···×nn ×  repetitions obtain graph terised using propositions tr ts sets  node successor                 xor sets exactly sa sb  exactly                                                        tr ts  true moment time  lemma   given set of temporal clauses possible set clauses characterising automata  ﬁnd ⇒     ¬qk required tres given fig  regarding automaton s’s description note                                                      clause  ensures automaton inﬁnitely                                                    ijcai                                                                     start ⇒   st                                                                                                                                       ¬ts ∧¬tr  ⇒     ts       ¬sb ∧¬sw  ∧¬sa   ⇒     st ∨ sb                                                                              true  ⇒   ♦agree       ¬st ∧¬sw  ∧¬sa   ⇒     sw                                                                                                           agree ∧¬st ∧¬sb ∧¬sa  ∧¬ts ∧¬tf   ⇒     sa       ¬st ∧¬sb ∧¬sw    ⇒     st                                                                                                           agree ∧¬st ∧¬sb ∧¬sa  ∧¬ts ∧¬tf   ⇒     tf        ¬st ∧¬sb ∧¬sa   ⇒     sw ∨ sa                                                                                                                ¬agree ∧¬st ∧¬sb ∧¬sa   ⇒     sw                  true  ⇒   ♦sb ∨ sw ∨ sa                                                                                                                 ¬agree ∧¬ts ∧¬tf   ⇒     tr                  start ⇒   ts                                                                                                                   agree ∧¬st ∧¬sb ∧¬sa ∧¬tr   ⇒     sw             ¬tr ∧¬tf   ⇒     tr                                                                                                                      agree ∧¬sw ∧¬ts ∧¬tf   ⇒     tr             ¬ts ∧¬tf   ⇒     tr ∨ tf                                                                                          true  ⇒     sb ∨ sw ∨ sa ∨ tr ∨ tf                                                                   ¬st ∧¬sb ∧¬sw  ∧¬ts ∧¬tr   ⇒     false                             sresp                                                                                                                                      true  ⇒     st ∨ sb ∨ sw ∨ ts ∨ trconv                                                           agree ∧¬st ∧¬sb ∧¬sa  ∧¬ts ∧¬tf   ⇒     false                             sresp                                                                                                                                       true  ⇒     ¬agree ∨ st ∨ sb ∨ sa ∨ ts ∨ tf conv                                                          ¬agree ∧¬st ∧¬sb ∧¬sa  ∧¬ts ∧¬tf   ⇒     ¬agree                            sresp                                                                                                                                       true  ⇒     agree ∨ st ∨ sb ∨ sa ∨ ts ∨ tf     tres                                                                                         true  ⇒     st ∨ sb ∨ sa ∨ ts ∨ tf        sresa                                                                             ¬st ∧¬sw ∧¬sa   ⇒     ts ∨ tf                       sresp                                                                                                   ¬agree ∧¬st ∧¬sw  ∧¬sa  ∧¬ts ∧¬tf   ⇒     false                            sresp                                                                                                                                    true  ⇒     agree ∨ st ∨ sw ∨ sa ∨ ts ∨ tf conv                                                           agree ∧¬st ∧¬sw ∧¬sa  ∧¬ts ∧¬tf   ⇒     false                            sresp                                                                                                                                    true  ⇒     ¬agree ∨ st ∨ sw ∨ sa ∨ ts ∨ tf conv                                                                                         true  ⇒     st ∨ sw ∨ sa ∨ ts ∨ tf        sresa                                                                              ¬sb ∧¬sw  ∧¬sa   ⇒     st ∨ ts ∨ tf                  sresp                                                                                                   ¬agree ∧¬sb ∧¬sw  ∧¬sa  ∧¬ts ∧¬tf   ⇒     st                               sresp                                                                                                      agree ∧¬sb ∧¬sw ∧¬sa  ∧¬ts ∧¬tf   ⇒     st                               sresp                                                                                                                                    true  ⇒     sb ∨ sw ∨ sa ∨ ts ∨ tf           tres                                                         ¬agree ∧¬st ∧¬sb  ∧¬sw  ∧¬ts ∧¬tf   ⇒     false                             sresp                                                                                                                                      true  ⇒     agree ∨ st ∨ sb ∨ sw ∨ ts ∨ tf conv                                                          agree ∧¬st ∧¬sb  ∧¬sw  ∧¬ts ∧¬tf   ⇒     false                             sresp                                                                                                                                      true  ⇒     ¬agree ∨ st ∨ sb ∨ sw ∨ ts ∨ tf conv                                                                                         true  ⇒     st ∨ sb ∨ sw ∨ ts ∨ tf        sresa                                             ⇒     ∨                              sres                                          true         ts  tf                                      pk                                  ¬   ∧¬     ⇒                                    sres                                       tr   tf        false                                   pk                                      start ⇒   tr ∨ tf                           conv                                             ⇒                                      ires                                          start     false                                     pk                                figure  resolution proof automata agents example    state st ensuring automaton future clause  clauses   capture exact  main state st forever                             synchronisation agreement occurs automaton    characterise computations each state sw automaton tr automata make  automaton relate begin assume simple syn transitions forward states sa tf respectively finally  chronous concurrent model automata make clauses – ensure synchronised agreement  transition time section  variations possible automata remain relevant states  add key aspect negotiation protocols clauses represent speciﬁcation simple  description happens agreement example resolution used  reached example characterised synchro wish verify simultaneously states  nised communication act logically use proposition st ts eventually verify add negation  agree denote add following clauses  property characterised clause          true ⇒ ♦agree                                                                                                             true ⇒   ¬st ∨¬ts         agree ∧ sw ∧ tr ⇒ sa                                       agree ∧ sw ∧ tr ⇒ tf                                                                                                                        derive contradiction clauses –         ¬agree ∧ sw ⇒  sw                                                      know negated property valid speciﬁcation         ¬agree ∧ tr ⇒  tr                                                      ﬁrst rewrite clauses – correct format         sw ∧ agree ∧¬tr ⇒  sw                                                      normal form refutation given figure          ¬sw ∧ agree ∧ tr ⇒ tr                       example essentially captures activity  say agreements occur inﬁnitely synchronous truly concurrent wish                                                    ijcai                                                     
