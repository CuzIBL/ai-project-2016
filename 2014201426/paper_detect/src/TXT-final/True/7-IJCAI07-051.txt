
recent research in nonmonotonic logic programming under the answer-set semantics focuses on different notions of program equivalence. however  previous results do not address the important classes of stratified programs and its subclass of acyclic  i.e.  recursion-free  programs  although they are recognized as important tools for knowledge representation and reasoning. in this paper  we consider such programs  possibly augmented with constraints. our results show that in the propositional setting  where reasoning is wellknown to be polynomial  deciding strong and uniform equivalence is as hard as for arbitrary normal logic programs  and thus conp-complete   but is polynomial in some restricted cases. non-ground programs behave similarly. however  exponential lower bounds already hold for small programs  i.e.  with constantly many rules . in particular  uniform equivalence is undecidable even for small horn programs plus a single negative constraint.
1 introduction
in recent years  a large body of work in answer-set programming  asp  has been devoted to obtain semantical and computational characterizations of different notions of equivalence between nonmonotonic logic programs. these investigations were mainly concerned with strong equivalence  lifschitz et al.  1   which facilitates a replacement property under nonmonotonicity akin  e.g.  to the familiar one which holds for classical logic  and weaker notions such as uniform equivalence  eiter and fink  1; pearce and valverde  1 . while the general case and certain fragments like positive programs are well-understood  eiter et al.  1b   the picture remains unclear for many other fragments.
모two important such fragments are stratified programs and its subclass of acyclic  i.e.  recursion-free  programs  which are widely used in knowledge representation  cf.  e.g. 
baral    and also play  for instance  an important role in deductive databases. the attractive features of such programs are their unambiguous semantics as well as their  in the propositional case  polynomial complexity.
모in asp  programs often contain stratified subprograms which serve  in a generate-and-test methodology  gelfond and leone  1; niemela몮  1; baral  1   for checking whether a candidate is in fact a solution to the problem at hand. for example  in the program
bad 뫹not ok ok 뫹choose x  choose x  뫹option x  not omit x  omit x  뫹option x  not choose x  the first two statements check whether at least one option was chosen  and output  bad  if this is not the case. typically  to eliminate such unwanted models  a constraint 뫹 bad is added. this remains true if bad is deleted from the head of the first rule. in fact  the sets of rules p = {뫹 bad; bad 뫹 not ok; ok 뫹 choose x } and q = { 뫹 bad; 뫹 not ok; ok 뫹 choose x } are strongly equivalent and thus p can be replaced by q  and vice versa  within an arbitrary program. if no rules in it define bad  then we can also safely drop the constraint 뫹 bad. we note that  as in this example  checking parts are often acyclic. however  recursion may occur  e.g.  in computing the transitive closure for reachability in a graph; we remind that the capability of expressing transitive closure is one of the assets of logic programming.
모given their importance in practice  in this paper  we consider testing the equivalence of stratified programs which are possibly augmented with constraints. our contributions can be briefly summarized as follows.
모 1  we provide a detailed picture of the computational complexity of deciding strong and uniform equivalence between stratified respectively acyclic logic programs in the propositional case. as we show  these problems are conpcomplete already in very simple cases  and thus as hard as in the general case of normal logic programs. this contrasts with the non-ground case  where syntactic restrictions make strong equivalence testing  which is co-nexptimetime complete in general  easier in some cases.
모 1  we elucidate the role of constraints in this context. without constraints  in some cases testing strong equivalence becomes tractable and thus easier than testing uniform equivalence  which remains intractable. there is a similar picture in the non-ground case. a noticeable result which we establish is that uniform equivalence of two programs p and q is undecidableas soon as both p and q are permitted to contain  besides horn rules  a single negative constraint 뫹 not w  where w is a propositional atom. if it is removed in only one of them  then we have decidability  also in the presence of arbitrary positive constraints .
모 1  we discuss the effect of some restrictions which are important in practice including  small  programs  where the number of rules is bounded by a constant. while strong and uniform equivalence become unsurprisingly tractable in the propositional case  both remain intractable  at least exponential  in the non-ground case. in fact  uniform equivalence remains undecidable.
모our results fill a gap in the knowledgeaboutthe complexity of testing equivalencefor stratified programswith constraints  and complement previous results. they show that  somewhat surprisingly  already for simple propositional programs  testing strong respectively uniform equivalence is intractable. recall that deciding ordinary equivalence of such programs  i.e.  whether they have the same answer set  is polynomial  in fact  feasible in linear time . furthermore  our results show that also under some restrictions relevant in practice the problems remain intractable  i.e.  have exponential lower bounds  or remain even undecidable.
1 background
we use a languagecontaining the following  possibly infinite  sets: a set a of predicate symbols  a set v of variables  and a set c of constants  called the domain . an atom is an expression of form p t1 ... tn   where p 뫍 a has arity 붸 p  = n and ti 뫍 c 뫋 v  for 1 뫞 i 뫞 n.
a rule  r  is of the form a 뫹 b1 ... bk  not bk+1 ...  not bm 
where a is an atom or empty  b1 ... bm are atoms  m 뫟 k 뫟 1   and  not   denotes default negation. if a is empty  r is a constraint; if m = 1  r is a fact; and if m = k  r is horn. the head of r is given by h r  = a  and the body of r by b r  = {b1 ... bk  not bk+1 ...  not bm}. we also use b+ r  = {b1 ... bk} and b  r  = {bk+1 ... bm}. moreover  we assume that all rules are safe  i.e.  each variable in h r  뫋 b  r  also occurs in b+ r .
모a program is a finite set of rules. the set of variables occurring in an expression e  atom  rule  program  etc.  is denoted by ve  and the set of constants  resp.  predicates  occurring in e by ce  resp.  ae . expression e is ground iff ve =  .
모a predicate p 뫍 ap is called extensional  in p  iff there is no r 뫍 p with h r  = p  otherwise it is intensional  in p . the herbrand base  ba c  is the set of all ground atoms over predicates a and constants c. bp = bap cp is the herbrand base of a program p.
모given a rule r and a set of constants c   c  we define gr r c  as the set of all rules obtained from r by all possible substitutions of vr by elements from c. for any program p  the grounding of p with respect to c is given by gr p c  =
. in particular  gr p  stands for gr p cp   referred to simply as the grounding of p  where cp = {c} if no constant appears in p.
모a program is constraint-free  if no constraint occurs in it  and horn  if all rules are horn. constraint-free horn programs are also called definite. a program p is called acyclic  resp.  stratified  iff there is a function f : a 뫸 n such that  for each r 뫍 p with h r  = h being nonempty   i  f ab    f ah   for each b 뫍 b  r   and  ii  f ab    f ah   resp.  f ab  뫞 f ah    for each b 뫍 b+ r .
모by an interpretation  i  we understand a set of ground atoms. a ground rule r is satisfied by i  symbolically i |= r  iff whenever b+ r    i and b  r 뫌i =    then h r  뫍 i. i satisfies a ground program p  denoted by i |= p  iff each r 뫍 p is satisfied by i. a set i   bp is an answer set of p iff i is a subset-minimal set satisfying the gelfond-lifschitz reduct pi  gelfond and lifschitz  1  of gr p  with respect to i  given by
pi = {h r  뫹 b+ r  | r 뫍 gr p   i 뫌 b  r  =  }.
the set of all answer sets of p is denoted by as p . as well known  every stratified program p has at most one answer set  which in case that p is acyclic can be defined by the completion of p  ben-eliyahu and dechter  1 .
모we consider the following notions of equivalence between two programs p and q:
  ordinary equivalence  p 뫖o q: as p  = as q ;
  uniform equivalence  p 뫖u q: for each finite set f of facts  as p 뫋 f  = as q 뫋 f ; and
  strong equivalence  p 뫖s q: for each program s  as p 뫋 s  = as q 뫋 s .
모we remark that the difficulty to deal with uniform or strong equivalence in the non-ground case has its origin in the extended programs which naturally enlarge the active domain  and thus the original herbrand bases of the programs are not useful anymore  eiter et al.  1a .
1 the propositional case
in this section  programsare assumed to be propositional i.e.  all predicates have arity 1  and normal unless specified otherwise. the following proposition collects results by eiter et al.  1b  and some known properties.
proposition 1 deciding p 뫖e q for normal programs p and q  where e 뫍 {s u o}  is in conp  and if both programs are
horn  the problem is in p. for stratified programs  deciding p 뫖o q is in p.
모we start proving a p-hardness result for the simplest class of programs considered.
lemma 1 deciding p 뫖e q for acyclic definite horn programs is p-hard  for e 뫍 {o u s}.
proof. we reduce the p-complete problem of monotone circuit value  goldschlager  1  to the equivalence problems in question. such a circuit is given by a directed acyclic graph  v e   where v = {1 ... n} and each  i j  뫍 e satisfies i   j. elements of v are so-called gates of specific sorts  viz.
. gates of the former two sorts have in-degree 1  the others have in-degree 1. all gates except n have outgoing edges; n itself is called the output gate. their semantics is defined straightforwardly by induction for each gate j as follows: we have v j  = 1  resp.  v j  = 1   if j is of sort    resp.  뫐 . in the other cases  we have exactly two edges  i1 j    i1 j  in e and define v j  = v i1  몫 v i1  in case j is of sort 뫇 and as v j  = 1 iff v i1  + v i1  뫟 1 in case j is of sort 뫈. deciding whether v n  = 1 for the output gate n is the problem of monotone circuit value.
모given  v e   we define a program p as follows: for each gate  there is a fact pj in p; for each gate j of sort 뫈 having  i1 j    i1 j  in e  we have rules pj 뫹 pi1 and pj 뫹 pi1 in p; for each gate j of sort 뫇 having  i1 j    i1 j  in e  we have the rule pj 뫹 pi1 pi1 in p. now  given output gate n  we compare the programs p 뫋 {o 뫹} and p 뫋 {o 뫹 pn}. obviously both programs are acyclic horn without constraints and can be constructed from the given circuit  v e  in polynomial time using logarithmic space.
모as easily verified  we have p 뫋 {o 뫹} 뫖o p 뫋 {o 뫹 pn} iff v n  = 1 holds in  v e . moreover  by monotonicity this correspondence extends to 뫖u and 뫖s. 
next  we establish a further p-membership result.
lemma 1 deciding p 뫖s q between a normal program p and a horn program q is in p  if at least one of the programs is constraint-free.
proof  sketch . since p or q is constraint-free  the interpretation i = ap뫋q has to be a model of both pi and q as a necessary condition for strong equivalence to hold. this test is in p. however  this can only hold if the horn program q is constraint-free. that is  the test amounts to check whether p is strongly equivalent to a definite horn program  and to test whether pi 뫖s q  which are both in p. 
모let us now turn to acyclic normal programs. for acyclic programs with constraints  we obtain the following result:
lemma 1 deciding p 뫖s q is conp-hard for acyclic programs  with constraints   even if q is horn.
proof. we use an embedding of the conp-complete exact hitting set problem  given by an instance  c s   where c is a family of subsets of a finite set s. the problem is to decide whether there exists a subsetsuch that
  for each . any such s is an exact hitting set  ehs  for c. for conp-hardness  it is sufficient to consider c containing sets of cardinality 1. so  let
c = {{c1 c1 c1} ... {cn 1 cn 1 cn 1}}. we construct the acyclic program p consisting of the constraints
	뫹 ci 1 ci 1 	뫹 ci 1 ci 1 	뫹 ci 1 ci 1 	 1 
모모모모뫹 not ci 1 not ci 1 not ci 1   1  for 1 뫞 i 뫞 n. furthermore  consider q = {a 뫹; 뫹 a}  which is also acyclic and horn. we show that there exists an ehs for c p 뫖 . clearly  this equivalence problem is constructible in polynomial time in the size of  c s .
모suppose that. then  there exists a classical model m of p. by the constraints  1   the model is nonempty and |{ci 1 ci 1 ci 1} 뫌 m|   1  for each 1 뫞 i 뫞 n. furthermore  in view of constraints  1   |{ci 1 ci 1 ci 1} 뫌 m| 뫞 1 has to hold for each 1 뫞 i 뫞 n. but then m is an ehs.
모for the only-if direction  one easily shows that any ehs s of  c s  is a classical model of p. thus  the existence of an
ehs implies.	
뫖s / 뫖unormalconstr.-freehorndefinitedefinitep / conpp / conppphornconpp / conppconstr.-freeconpconpnormalconptable 1: complexity landscape for propositional programs.
모disallowing constraints yields conp-hardness only if both programs use negation.
lemma 1 deciding p 뫖s q is conp-hard for constraintfree acyclic programs.
proof  sketch . take the exact hitting set problem  c s  from the proof of lemma 1  and define
;
a 뫹 not ci 1 not ci 1 not ci 1; b 뫹 ci 1 ci 1; b 뫹 ci 1 ci 1; b 뫹 ci 1 ci 1;
b 뫹 not ci 1 not ci 1 not ci 1} 
p = r 뫋 {b 뫹 not a}  and q = r 뫋 {a 뫹 not b}.
both p and q are acyclic and constructible in polynomial time from  c s . it can be shown  that there exists an ehs for .	
모in case of checking uniform equivalence  this task is conphard as soon as negation is involved:
lemma 1 deciding p 뫖u q is conp-hard for acyclic constraint-free programs  even if q is horn.
모proof. again  take  c s  from the proof of lemma 1. define now program p as containing  for any 1 뫞 i 뫞 n 
a 뫹 ci 1 ci 1 	a 뫹 ci 1 ci 1 	a 뫹 ci 1 ci 1 	 1  a 뫹 not ci 1 not ci 1 not ci 1.	 1 
we show that there exists an ehs for  c s  iff.
suppose there is a set f of facts such that
{f 뫋 {a}}. hence  a /뫍 f  and thus  without loss of generality  we can assume f   s. since a is not derived in p 뫋 f  we must have  for each 1 뫞 i 뫞 n  |{ci 1 ci 1 ci 1} 뫌 f| 뫞 1  by rules  1   and |{ci 1 ci 1 ci 1} 뫌 f|   1  by rules  1  . but then  f is an ehs.
   for the only-if direction  one shows that adding any ehs  yields an answer set. since a does not occur in c  we have. but in turn hasas its only answer set. thus 
equivalent to  hence.	
모since all established hardness results carry overto stratified programs  we eventually obtain a full picture of the complexity of deciding p 뫖e q for e 뫍 {u s} between programs of the considered classes. note that restrictions to stratified and even to acyclic programs did not lower the complexity.
theorem 1 the complexity of deciding strong  resp.  uniform  equivalence between normal propositional programs is summarized in table 1. all entries are completeness results  which hold also for stratified and acyclic normal programs.
모we complement these results by giving complexity bounds for ordinary equivalence.
theorem 1 deciding ordinary equivalence between normal stratified programs is p-complete. hardness holds already for acyclic definite horn programs. moreover  if one of the programs is arbitrary normal  the problem is conp-complete.
structure-preserving notions of equivalence an important observation in case of strong equivalenceis that the added rules may destroy syntactical properties of the programs under comparison  which may be unwanted. given two acyclic  resp.  stratified  programs p and q  it is natural to compare the two programs under any admissible extension  that is to say  only under programs which do not introduce cycles  resp.  cycles involving at least one negation  when joined with p or q. to the best of our knowledge  equivalence notions which are sensitive to the compared programs have not been introduced so far  with the notable exception of strong equivalence between prioritized logic programs  faber and konczak  1 .
definition 1 programs p and q are acyclicity-preserving
 resp.  stratification-preserving  strongly equivalent  denoted p 뫖aps q  resp.  p 뫖sps q   iff  for each program r such that both p 뫋 r and q 뫋 r are acyclic  resp.  stratified   p 뫋 r and q 뫋 r possess the same answer sets.
모for programs without negations  p 뫖sps q is clearly the same as p 뫖s q. moreover  from known results  we already have that in this case p 뫖s q equals p 뫖u q. thus  also p 뫖aps q collapses to uniform and strong equivalence for positive programs. indeed  since strong and uniform equivalence coincide is witnessed by some set f of facts. however  f does not create cycles if added to p and q.
모in general  the relation 뫖sps differs from strong equivalence  as illustrated by the following example: consider
.
we have. however  p 뫖s q holds since every counterexample for p 뫖s q destroys the structure of at least one of the programs.
theorem 1 deciding p 뫖aps q  resp.  p 뫖sps q  is conphard for constraint-freeprogramsp and q  even if q is horn.
proof  sketch . we use the same construction as in the proof of lemma 1  i.e.  an exact hitting set problem  c s  and the corresponding program p. one can show that there exists an
ehs for .	
1 results for the general non-ground case
in this section  we first review known results for the nonground case  and then provide new results revealing the following insights:  i  contrary to the propositional case  we prove that for non-ground programs the complexity of deciding strong and uniform equivalence decreases for acyclic programs in certain cases; and  ii  we show a new undecidability result for uniform equivalence  strengthening an earlier result  eiter et al.  1a  given for disjunctive programs to the case of normal programs.
let us first review the complexity of ordinary equivalence.
as follows from dantsin et al.   deciding p 뫖o q is
  exptime-complete for horn programs p  q; and
  co-nexptime-complete for normal programs p  q.
모furthermore  it is well known that the program complexity for acyclic horn programs  without constraints  is pspacecomplete  cf.  e.g.  again dantsin et al.  . hence  deciding ordinary equivalence between acyclic horn programs can easily be shown to be pspace-complete.
strong equivalence note that for  acyclic  horn programs it is known that strong and uniform equivalence coincide with classical equivalence  which is refutable in nondeterministic polynomial time using an oracle for the ordinary equivalence of  acyclic  horn programs  and thus feasible in exptime  resp.  in pspace for acyclic programs . in turn  classical equivalence is also hard for these classes  as shown by a reduction of deciding inference of an atom from a program.
theorem 1 deciding p 뫖e q  where e 뫍 {o u s}  is exptime-complete given that p q are horn  and pspacecomplete given that p q are acyclic and horn. moreover  in each case  hardness already holds for definite programs.
모let us now consider normal programs. for arbitrary such programs  deciding strong equivalence is in co-nexptime  lin  1  as well as co-nexptime-hard  eiter et al.  1a . by suitable modifications  the hardness proof can be strengthened to acyclic programs. we therefore obtain:
theorem 1 deciding p 뫖s q is co-nexptime-complete for acyclic  stratified  normal programs p q. hardness even holds for constraint-free programs.
uniform equivalence as shown next  uniform equivalence between normal programs is undecidable. the proof reduces query equivalence between horn programs shmueli  1  to uniform equivalence. query equivalence  with respect to a predicate q  is the problem of deciding  given horn programs p and q over extensional predicates e and intensional predicates i  whether for any finite database  i.e.  set of facts  d for e  it holds that p 뫋d and q뫋d derive the same facts for q. we use linear programs here  i.e.  programs with at most one intensional predicate in the rule bodies  for which query equivalence remains undecidable  feder and saraiya  1   and adapt a construction due to eiter et al.  1a .
모first  we reduce query equivalence to program equivalence  i.e.  to the test whether p 뫋 d and q 뫋 d have the same answer sets for every finite database d  as follows: define
and
 
where q results from q by replacing each intensional predicate symbol is a fresh predicate which refers to the query predicate p. then  p and q are query equivalent with respect to p iff p  and q  are program equivalent.
모we now map the problem of program equivalence between  linear  horn programs to uniform equivalence between normal programs. the basic idea is that the computation of minimal models of programs is transformed to the computation of certain maximal models of program reducts  viz. so-called ue-models  characterizing uniform equivalence  eiter et al.  1a .
모in what follows  given a linear horn program p over extensional predicates ep and intensional predicates ip  let d be a new unary predicate  w be a new propositional atom  and  for each rule r 뫍 p  denote by
  er the list of atoms in b r  having a predicate from ep 
  dr the list d x1  ... d xm   where vir    vh r  뫋 ver  = {x1 ... xm}  and
  ir the intensional predicate in b r   if one exists  otherwise let ir = w.
let now  where e몬p = {e몬 | e 뫍 ep} are new predicate symbols  and define as follows:

{w 뫹 e x1 ... xn  e몬 x1 ... xn  | e 뫍 ep} 뫋	 1 
{ 뫹 not w}.	 1 
observe that is normal and contains a single negation. the forthcoming result relies on the observation that two horn programs p and q over the same domain  i.e.  such that cp = cq  are program equivalent iff. together with the result of feder and saraiya   we thus obtain:
theorem 1 deciding p 뫖u q between normal programs p and q is undecidable. this holds already for definite horn programs augmented by a single negative constraint.
모we remark that the problem becomes decidable if one of the programs  say q  is negation-free and the other has negation only in negative constraints  possibly augmented with  domain predicates  for guaranteeing safety . intuitively  by monotonicity of q  we can then disregard all the negative constraints in p if q is not inconsistent  while otherwise  if q is inconsistent  we obtain.
1 restricted cases
finally  we consider results for equivalence checking in case some parameter associated with the compared programs is fixed by a constant. due to space reasons  the discussion here is rather succinct and informal. a detailed formal account of the results will be given in the full version of the paper.
few predicates in the propositional case  a fixed number of atoms clearly makes all considered equivalence problems tractable. for the non-ground case  the traditional technique for rewriting arbitrary programs to programs over a single predicate can be shown to be faithful with respect to strong equivalence. hence  all the hardness  and undecidability  results for the non-ground case carry over to programs over a few predicate symbols.
small programs for small programs  i.e.  programs with a constant bound on the number of rules  again the propositional case shows decreasing complexity  i.e.  given a fixed integer k  deciding p 뫖e q between programs with at most k rules  for e 뫍 {o s u}  is feasible in polynomial time.
모the result in the non-ground setting is obtained from the programs proving the undecidability of query equivalence between definite linear horn programs  feder and saraiya  1 . while these programs  say p and q  have only three rules  the number of predicates and constants is not bounded.
thus  the programs  used to prove theorem 1  are not small yet. while the number of predicate symbols in the original programs is easily bound  which in turn bounds the number of rules in sets  1  and  1    sets  1  and  1  still introduce an unbounded number of rules. however  both sets can be fixed to have just three rules using the following argument rotation technique: replace  1  by the three rules
 
 where c1 ... ck are all constants occurring in p. for each  be a new predicate and replace  1  in by
 
where n is the arity of p. with theses modifications  undecidability can be shown as before.
theorem 1 p 뫖u q is undecidablefor small programs p q.
모another method to restrict the number of rules is due to gottlob and papadimitriou   who show how horn programs can be faithfully transformed into single-rule programs. they also prove that logical implication between two single horn rules is exptime-hard. from this result and the above argument rotation technique  we can derive:
theorem 1 deciding p 뫖e q  where e 뫍 {s u o}  is exptime-complete for small horn programs p q.
bounded predicates arities finally  we briefly discuss bounding the predicate arities by a constant. checking strong and ordinary equivalence then become significantly easier. note that checking answer-set existence is -complete in this setting  eiter et al.  1a . indeed  the size of the herbrand base bp of a program p is polynomial in the size of p  and classical model checking  i.e.  deciding i |= p given p and i   bp  is in conp  note that the grounding of p can still be exponential . for strong equivalence  it is sufficient to consider an extended herbrand base bap c  where c augments cp by polynomially many new constant symbols  this readily follows from proofs given by eiter et al.  1a  .
모in case of strong equivalence and ordinary equivalence  we thus obtain that equivalence checking between normal programs is on the second level of the polynomial hierarchy. for uniform equivalence  a similar restriction of the domain seems not possible. in fact  in case of disjunctive programs  uniform equivalence of stratified programs with constraints remains undecidable even under bounded predicate arities  which follows from the proof given by eiter et al.  1a  . a complete picture with respect to different classes of programs in this setting is subject of future work.
few negations a further topic for future work is concerned with programs having a fixed number of negations. we expect that all considered equivalence notions are tractable in the propositional case  while for the non-ground setting  theorem 1  for instance  shows that adding a single negation to horn programs makes uniform equivalence undecidable.
1 conclusion
we presented a number of complexity results about equivalence testing for the important classes of stratified and acyclic programs  which have not been studied so far  in the possible presence of constraints. we have also considered the effect of various syntactic restrictions on programs relevant in practice. the results reveal that  already in the propositional case  deciding strong or uniform equivalence is intractable for simple programs. similarly  in the non-ground case  the problems are as difficult as for arbitrary normal logic programs  and uniform equivalence is undecidable with a single negative constraint. however  they become  much  easier under certain restrictions. therefore  our results provide useful insights for the development of algorithms and implementations of equivalence checkers and for program optimization.
모while the picture is complete for the propositional case  in the non-ground case several issues remain open. one is the question of  un decidability of uniform equivalence between stratified programsin the absence of constraints. while decidability for monadic programs follows from results by halevy et al.  and is known for programs with joint stratification  levy and sagiv  1   the generalcase is open. similarly  the effect of bounded predicate arities remains to be clarified. finally  the study of further notions of equivalence  such as relativized versions of equivalence  eiter et al.  1b   is subject to future work. clearly  relativized equivalence is undecidable for very limited fragments  as follows from results on program equivalence. nevertheless  our results provide lower complexity bounds and may help to derive characterizations for relativized equivalence in the nonground case  which have not been formulated so far.
references
 baral  1  c. baral. knowledge representation  reasoning and declarative problem solving. cup  1.
 ben-eliyahu and dechter  1  r. ben-eliyahu and r. dechter. propositional semantics for disjunctive logic programs. amai  1-1  1.
 dantsin et al.  1  e. dantsin  t. eiter  g. gottlob  and a. voronkov. complexity and expressive power of logic programming. acm csur  1 :1  1.
 eiter and fink  1  t. eiter and m. fink. uniform equivalence of logic programs under the stable model semantics. in proc. iclp 1  pp. 1  lncs 1.
 eiter et al.  1a  t. eiter  w. faber  m. fink  g. pfeifer  and s. woltran. complexity of answer set checking and bounded predicate arities for non-ground answer set programming. in proc. kr 1  pp. 1  1.
 eiter et al.  1a  t. eiter  m. fink  h. tompits  and s. woltran. strong and uniform equivalence in answerset programming: characterizations and complexity results for the non-ground case. in proc. aaai 1  pp. 1.
 eiter et al.  1b  t. eiter  m. fink  and s. woltran. semantical characterizations and complexity of equivalences in stable logic programming. acm tocl. forthcoming.
 faber and konczak  1  w. faber and k. konczak. strong equivalence for logic programs with p