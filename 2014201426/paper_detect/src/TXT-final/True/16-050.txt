 
　　a recursive cellular representation for configuration space is presented  along with an algorithm for searching that space for collision free paths. the details of the algorithm are presented for polygonal obstacles and a moving object with two translational and one rotational degrees of freedom. 
i. introduction 
in this paper we present an algorithm for finding collision free paths for a rigid polygonal object moving through space that is cluttered with obstacle polygons. the paths can include rotations of the object. the algorithm will find a path from a given initial position and orientation to a goal position and orientation if such a path exists  subject only to a user-specified resolution limit on displacements. 
　　the problem addressed here is an instance of the problem known as the find path or mover's problem in robotics. the problem arises when planning the motion of a robot manipulator or mobile robot in an environment with known obstacles. for related approaches to the find path problem  see brooks   lozano-perez  1  1a   lozano-perez and wesley   
moravec   schwartz and sharir  1  1   and udupa . a survey of the. different approaches to findpath and a discussion of its role in robot task planning can be found in lozano-perez  1b . 
　　the algorithm described here is based on the configuration space approach described by lozano-pcrcz  1  1a . the configuration of a rigid object is a set of independent parameters that characterize the. position of every point in the object. we associate a local coordinate frame with a rigid object  such as a planar polygon. the configuration of the polygon can be specified by the x y position of the origin of the local coordinate frame  known as the reference point and a 1 value indicating the rotation of the local frame relative to the global frame. the space of all possible configurations of an object is its configuration space. a point in the configuration space  a configuration point  represents a particular position of the ob-
ject's reference point and an orientation of the object's axes. 
　　the configuration space for planar polygons is threedimensional while that of solid polyhedra is six-dimensional: three translational and three rotational dimensions. due to 
this report describes research done at the artificial intelligence laboratory of the massachusetts institute of technology. 
support for the laboratory's artificial intelligence research is provided in part by the office of naval research under office of naval research contract n1-k-1 and in part by the advanced research projects agency under office of naval research contracts n1 c 1 and n1k-1. 
the presence of the immovable obstacles some regions of the configuration space are not reachable; these regions are the configuration obstacles. hence  in the configuration space  the moving object is shrunk to a configuration point while the immovable obstacles are expanded to fill all space where the presence of the configuration point would imply a collision of the object with obstacles. the findpath problem of finding a path for the object through the original space while avoiding obstacles is thus transformed to finding a path for the configuration point through the configuration space while avoiding the configuration obstacles. 
　　the. fundamental structure of the algorithm is extremely simple. configuration space is first divided into rectangloids with edges parallel to the axes of the space. each rectangloid is labeled as  1  empty if the interior of the rectangloid nowhere intersects a configuration obstacle   1  full if the interior of the rectangloid everywhere intersects the configuration obstacles or  1  mixed if there are interior points both inside and outside of configuration obstacles. a free path is found by first finding a connected set of empty rectangloid cells that  include the initial and goal configurations and constructing a piecewise linear path through those empty cells. if such an empty cell path cannot be found in the initial subdivision of configuration space then a 
　　path that includes mixed cells is found. mixed cells on the path are subdivided  by cutting them with a single plane normal to a coordinate axis  and each resulting cell is appropriately labeled as empty  full  or mixed. another search for an empty-cell path is initiated  and so on iteratively until success is achieved. if at any time no path can be found through won-full cells of greater than some preset minimum size  then the problem as posed is insoluble  i.e.  no collision free path exists given the resolution limit . 
　　the conceptual and practical problems that must be solved to implement this algorithm are as follows: 
　　 a  what is an efficient algorithm for labeling the newly cut cells as empty  full or mixed  
　　 b  how should configuration space be initially divided into rectangloids  
　　 c  where should a mixed cell be cut when it is subdivided  
　　 d  what additional information should be kept with mixed cells describing the configuration space obstacles they intersect   e  how should the iterative search be controlled  
     h. representation of configuration space obstacles for a convex polygonal moving object a and a convex polygonal obstacle b we write the configurations forbidden for a as coa b . figure 1 shows such a configuration obstacle for polygons a and b where their relative orientation is fixed. lozano perez  1a  showed that coa b   for fixed relative orientations of convex a and b  is also a convex polygon. a 
　　
 b1	m
figure 1. non-convex moving objects can be decomposed into a union the path for object a can be found through the obstacle litof convex objects sharing a common reference point and reference tered space by finding a path for the configuration point through orientation. configuration space filled with the union of the c o a b j ' s or 
　　
r. brooks and t. lozano-perez 1 
hence  for arbitrary obstacle and moving object 
　　
polygons  we first decompose them into the unions of convex polygons; then  for all pairs of obstacle and object polygons we compute the configuration space obstacles. these new obstacles are all embedded in the same configuration space  and a collision- free path is found through it for the reference point of the object to be moved. 
　　in what follows we will represenet an obstacle embedded in configuration space as a union of finite rectangloid boxes each with edges parallel to the: coordinate axes. the boxes will each have associated with them a conjunction of inequalities which will allow us to determine the subset of the configuration space obstacle that intersects that box. we then embed these boxes into configuration space by cutting it into rectangloids. 
　　the way in which the set of boxes bounding a particular configuration space  obstacle is chosen is discussed in section hb. 
a. representation of configuration space 
the inequalities derived above are referred to as constraints. 
each one has the form j  x    1  where x is the configuration point for the moving object. a point x is inside such a constraint if f x    1  outside if } x    1 and on the constraint if f x  = 1. a point is contained in a configuration obstacle if it is not outside any of its defining constraints. a point x is on the surface of an obstacle if it is on some constraint. 
　　if two obstacles are embedded in the same space and two of their bounding boxes intersect then the two can be decomposed into a union of boxes. each resulting box has associated with it a disjunction of the conjunctions representing the original two obstacles. of course  the sub boxes that only overlapped a single configuration space obstacle have just the original conjunction. 
　　more formally  we represent configuration obstacles as follows. configuration space is subdivided into rectangloid cells in order to represent the embedding of many configuration obstacles. each cell is a closed rectangloid with edges parallel to the coordinate axes. the union of all cells is the whole space and no point is in the interior of two cells. associated with each cell is a sentence of constraints of the form 

each conjunction of constraints in a sentence will be referred to as a clause and each clause is made up of terms  i.e.  each constraint will be referred to as a term. 
　　a point is said to be inside sentence .1 if for some clause of the disjunction it is not outside any of the constraints. a point is said to be outside sentence s if it is outside some constraint in every clause. a cell c with associated sentence s is labeled as 
 1  empty if no point of c is inside s   1  full if no point of c is outside 1  
 1  mixed otherwise. 
the labeling is done as a by-product of trying to simplify sentence s; see below. 
b. simplification of constraint sentences 
both while constructing the original representation of configuration space and when subdividing cells during search it is necessary to associate a constraint sentence s with a cell c. it may be the case that the cell is completely outside or completely inside some constraints in 1. the procedure below both figure 1. slice projections into the x-y plane of type a and 
type b surfaces from configuration obstacles. these projections divide the plane into three regions: inside  mixed  and outside. the cell compare procedure must determine where the projection of a cell lies relative to these regions. 
simplifies s by removing such   constraints and  as a by product  labels the cell empty  full  or mixed. 
procedure simplifyandlabel  c  s ; begin 
foreach clause in s do 
begin 
foreach term in clause do 
begin 
case cellcompare  c  term  of 
insido: remove term from clause; 
outside: begin remove clause from s; goto next clause; end; 
   cut: ; endcase; 
end; 
if clause is nil 
then begin label c with full set s to nil; exit from simplifyandlabel; 
end; 
end; 
if s is nil 
then label c with empty else label c with mixed; 
end; 
figure 1 illustrates the behavior of the algorithm. 
　　a sub-procedure cellcompare is ubed to compare a cell c with a single constraint  e say. it returns one of: 
　　
 1  outside if no point of c is inside e   1  inside if no point of c is outside e  
 1  cut otherwise. 
　　the formulation of cellcomparc depends on the form of constraints to be considered. note also that in general the surface of a constraint  i.e.  those points on the constraint  is of lower dimension than the configuration space in which it is embedded. thus a constraint fills only a subset of measure zero of a cell. 
c. comparing a cell to a single constraint 
the idea of treating the spatial and rotational components of configuration space uniformly breaks down when comparing a cell to a constraint. this is because the constraint surfaces are  in some sense   wel! behaved  with respect to x and y  but  poorly behaved  with respect to 1 - the surfaces can creep into  and out of a cell along an edge in the 1 direction  while the vertices at both ends are on the same side of the constraint. 
　　for a fixed 1o both type a and type b constraint surfaces become a single  infinite  straight line. type a and b constraints are  therefore  ruled surfaces  which are valid over some range  1 - consider the projections into the x-y plane of the portions of these surfaces in the range  1   slice projections in the terminology of lozano-pcrez  1  1a  . points outside the projection must support columns in the 1 direction that are either completely inside or completely outside the constraint. furthermore  there will be two disjoint regions outside the projection that correspond to these types of columns. figure 1 illustrates the projection of both a type a and a type b constraint. 
　　thus the procedure cellcompare has been reduced to two more primitive operations; projection of the constraint surface into the x-y plane  and comparison of a rectangle to the two regions of the plane outside of that projection. if those regions are convex then the comparison is simple  as a convex polygon is contained in a convex set if and only if all its vertices are contained in the region. 
a type b constraint projects into a strip with parallel sides. 
on one side is a half plane corresponding to points inside the constraint  and on the other a half plane corresponding to points on the outside. the comparison computation it trivial. 
　　type a constraints are considerably more difficult to deal with  as the orientation of the ruled line on the constraint surface rotates with changing 1. consider figure 1. note that again both the inside and outside regions are convex  so a projected cell vertex test suffices. a point is in the outside region if it is outside both of the straight lines. it is inside if it is inside both of the straight lines and not in the small area between the circle and the point of intersection of the two lines. such points have distance from bj greater than the radius of the circle  and are on the opposite side of the chord  joining the two intersections of the circle with the straight lines  as point bj 
　　full details can be found in a longer version of this paper: . 
d. bounding configuration obstacles 
in this section we describe how the set of bounding cells for each configuration obstacle is chosen. as 1 varies  the x and y bounds on the crosb section of coea b  normal to the 1 axis varies considerably. hence it is best to bound co1a b  by a  stack  of cells in the 1 direction; see figure g. the cells are obtained by  first  determining a number of sub-intervals of the 

e. constructing an initial representation 
we are now in a position to construct an initial representation of configuration space. there are two operations.  1  cut space into rectangloid cells.  1  build a connectivity graph between the cells which are empty or mixed. by combining the second operation with the first it is possible to reduce its complexity to linear in the final number of cells. full details can be found in a longer version of this paper: . the computation  as distinct from the actual algortihm  uses all the extreme x  say  values of bounding boxes to cut configuration space into strips and intersects all the boxes with those strips  cutting them when necessary. then each strip is cut with all the extreme y values of boxes which lie within that strip. the process is repeated for each axis of configuration space. 
　　figure 1 shows a configuration space for polygons without rotation cut into rectangular cells. a cell is represented by a rectangloid  a constraint sentence in constraints that cut it  a label from among full  empty  and mixed  and pointers to neighboring cells. the neighbors are grouped according to their direction  e.g. +x  -x  +y and -y for two dimensional configuration space. figure 1 shows its corresponding connectivity graph. 
　　an important refinement to the simple connectivity graph is possible. two neighboring cell c1 and c1 intersect in a rectangloid cell c one dimension lower than the original cells. both constraint sentences s1  from c   and s1  from c1  apply to the intersection cell. if either simplifyandlabel c  s1  or simplifyandlabel c  s1  label c as full then the configuration point cannot move directly from cell c  to c1 hence  although spatially neighbors  none of their empty interior points are connected by a path for the moving object's configuration point. thus their neighbor relation can be omitted from the connectivity graph. for this reason  link a of figure 1 can be deleted. 
　　

figure 1. given two intersection points of a constraint and boundary edges  the cell is cut at the intersection point closest to the center of the boundary edges. the two cases that are illustrated here show that this produces the simpler cell with maximal volume. 
r. brooks and t. lozano-perez 1 
this refinement significantly cuts down the number of links in realistic connectivity graphs  greatly increasing efficiency. 
　　a major drawback to cellular representations as above is that a number of small obstacles localized in one part of space can have significant global effects on the representation of space elsewhere  e.g.  the effect of x bounds in figure 1. this can become a significant problem in three -dimensional configuration space. 
　　this problem is solved by first boxing the stack of 1 slices for a single configuration obstacle into a single cell that extends over the range  -pie pie  in the 1 direction. such cells are embedded into the configuration space that is sliced in the x and y directions. then  within each cell  the cutting procedure is used all over again  first cutting normal to the 1-axis then normal to each of x and y. 
　　the efficiency of the algorithm can be further enhanced by arranging for the second stage of cutting to be carried out only when it first becomes a candidate path cell as found by the a search algorithm. 
itt. search 
the representation described above for configuration space is useful only if some efficient way can be found to search it for collision free paths. our algorithm uses the a*  nilsson   algorithm as its primary search engine to search the cell connectivity graph  both for paths through purely empty cells and for paths that include mixed cells. 
　　once a set of empty cells linking the initial point to the goal has been found  an actual point path through those cells must be chosen. again the a* search procedure is used  but this time using a selected set of points in the cells along the solution path. 
　　if no path through empty cells is available  then the representation of configuration space must be refined through cell division. it is necessary  however  to decide where the space should be refined  and how much effort should be expended in subdivision  before a new search is initiated. the point path search mentioned above is used to direct the refinement of configuration space as well as to produce a final solution path for the problem. 
　　the efficiency of the overall search can be greatly improved by using the divide and conquer paradigm. there are some complications in this application  however  as each subproblem is capable of changing the global data base by refining the representation of space within its area of search. this turns out to be a significant problem and some care must be taken to minimize its adverse effects. there is an additional problem with divide and conquer in this application. the division of a problem into subproblems cannot guarantee that if the original problem is solvable then so are all the subproblems. a form of resource limited computation is used to back out of problem subdivisions that do not look promising. 
a. deciding where to cut a cell 
during search  the representations of mixed cells that lie on the candidate path are refined. a cell c with sentence s is cut into two cells  c  and c1  by splitting along one of its coordinates. then  each sub-cell is labeled by calling simplifyandlabel c1  for i = 1. 
　　the cutting operation can help the search converge on a  path through empty cells but only if it makes it easier to deduce if at least one of the c1's is full or empty. this will be the 
　　
case if the number of constraints appearing in at least one sentence s1 is reduced from the number that appeared in s. such simplification can be achieved if one of the new cells lies wholly inside or outside a constraint. we refer to it as the simpler sub-cell. 
　　two heuristic principles have also been used in the implemented algorithms described here. first  it is desirable that the new cell with simpler constraint sentence should have the maximal volume possible. this offers the possibility of finding that a large volume is either empty or full. in one case it makes the search for a free path easier and in the other eliminates a large volume from further consideration. the second heuristic principle is that large amounts of computation in choosing the place to cut a cell  would be better spent in cutting the cell into more  less well chosen  pieces  as more cuts result in greater likelihood of actually finding empty or full sub-cells. 
　　thus there are three problems;  1  find cuts that lead to simpler s1 and s1;  1  choose the one that gives the simpler cell a large volume;  1  compute  1  and  1  quickly. here we show how to choose a good cut according to these criteria. the method is stated in more generality than necessary so that it can easily be extended to the higher dimensional cases later in the paper. 
　　the basic approach is as follows. consideration is given to cutting the cell in each direction  x  y and 1 in this case  at some number of points for each constraint in the cell's constraint sentence. candidate cuts are chosen wherever a constraint surface will go through a vertex of one of the new cells. a score is assigned to each such plausible cut  and the cut with minimal score is chosen as best. 
　　it remains now to define the scoring function. if the length of the cell in the x direction is scaled to 1 then the score of a cut is its distance in those units from the center in the x direction. note that this score is a proportion of the volume of the original cell that is added or subtracted from half its volume to get the volumes of the two new cells. thus the scale of this measure is independent of the constraint or the direction of cut. the same scoring function is used in the y and 1 directions. 
　　if a given constraint and direction of cut produces two candidate cuts then in configuration space without rotations the one with lowest score is the one that produces a simpler cell with maximal volume  helping in the achievement of  1  . this can be shown by considering two cases  illustrated in figure 1. it does this without analysis of the constraint other than where it cuts the edges of the cell. 
　　in our implementation we choose the cut by picking the candidate with the lowest score from among all cutting directions and single constraints. this has the effect of choosing a cut that produces a simpler cell with volume closest to half the original cell volume. the chosen cell may not be the best possible choice in terms of condition  1   but it is certainly not a poor choice. if all possible simpler cells have volume less than half the original  then this algorithm will in fact choose the cut that results in the largest such cell. if there are cells bigger than half  then the biggest one might not be chosen; condition  1  is well satisfied  however. 
b. a* cost functions 
while searching for a path of connected cells  a candidate point path through each partial cell path is  constructed . each adjacent pair of cells intersect in a cell of one lower dimension. in the case of two dimensions without rotations  the interaction cell is a line segment and the centroid its midpoint  for example. the centroids of such interaction sub cells are used as the entry and exit points of the path through the cell  and a the path segment within a cell is the straight line joining them. 
　　the cost of an individual path segment is just its euclidean length within the configuration space  and the cost of a path is the sum of the segment costs. the lower bound heuristic estimate for reaching the goal point  is just the euclidean length from the last point on the path to the goal point. 
　　the running time of the search algorithm can be improved by making the cost of traversing a mixed cell greater than the cost of traversing an empty cell. the relative cost can be used to trade off running time of the search algorithm for length of the final path. with a large relative cost  the a* algorithm will strongly tend to concentrate on empty cells. hence  paths that require only a small amount of additional trail blazing through mixed cells will be chosen  even if they are very long. 
c. choosing a point path 
when a final cell path consisting of empty cells has been found it is still necessary to find a path for the configuration point of the moving object through configuration space. in general  the choice of final path should be based on domain specific considerations such as kinematic or dynamic characteristics  not on purely geometric criteria. in the absence of domainspecific considerations we suggest that a desirable property of the final path is that it be smooth  essentially nulling out the artificial effects of the tesselation of configuration space by the cell structure. our approach is to consider alternative paths going through a small set of candidate points in the interaction cell between adjacent cells in the chosen path  and to choose the one that minimizes the cost function by another a  search with the same cost function as detailed above. 
d. refining the search space 
after a search has found a sequence of empty and mixed cells  the mixed cells along the path should be cut into at least two sub cells and the search re-executed. this simple strategy leads to a very slowly converging search algorithm  however. the ratio of cutting to searching is too low. arbitrarily cutting cells can also be wasted effort  however  so it is better to find some selective method of determining places to make more cuts. we use the point path search to identify such places. 
　　the point path search of the previous section is used to find a point path through the empty and mixed cells. all points at the interface between cells on that path are then examined. it is easy to determine if a point is actually in free space by evaluating the constraint sentence associated with one of the containing cells. if the point is actually in free space  but its cell is mixed  then the cell is repeatedly divided until the point lies in a newly created empty cell.  this same procedure is used to cut the space representation about the initial and goal points to get empty initial and goal cells for the original search.  the effect of this is to create small islands of empty cells along the trajectory  which will be useful for defining recursive subproblems  see next section . 
　　initially there may be many large cells in the configuration space representation. if an arbitrary point on the interface between two adjacent cells were chosen as a center of refinement of the cell representation  it could well be that it is far from the optimal path. by only expanding points on a candidate optimal path  the overall search operation is not misled into grossly suboptimal areas of  easy pickings . 
e. divide and conquer 
the efficiency of the search for a free cell path can be greatly improved by hierarchically decomposing it into more localized and smaller problems. the search space is smaller for a localized problem  resulting in reduced time for the overall search. 
　　the problem is how to break up a global search into smaller ones when there is no a priori knowledge of what the smaller subproblems are. the approach taken here is to use the global search through mixed cells  and subsequent selection of a point path as a plan for the lower level subproblems. if there are points on the path that  after cell refinement as above  are in a known empty cell  then they are used as points at which the problem is broken up. the global problem then becomes a series of local ones  each from an initial point to a goal point where both are in empty cells. 
　　surprisingly  the order in which the subproblems are attempted is important. this is because each subproblem may require that the global data base  the cell connectivity graph  be altered  as mixed cells are cut. if the subproblems arc evaluated with the one closest to the global initial point first  and followed sequentially by those closer and closer to the goal point  then this cutting has adverse effects on search efficiency. 
　　consider the first subproblem in a sequence. in general  many cells near the goal point will have been refined by the time a sub path through empty cells has been found. now the second subproblem is attacked. its initial point is the goal point of the previous subproblem. when the a search starts at that point it finds many small empty cells from the recent search. these cells are in the wrong direction relative to the new goal  however; they are  nevertheless   attractive  to the search algorithm  because the evaluation function favors empty cells. in addition the empty cells are small and  therefore  many can be appended to partial paths near the new initial point without sharp increases in the heuristic estimate of remaining cost. the result is that the a* algorithm can spend inordinate amounts of time breadth first searching backwards over areas covered by the previous subproblem. 
　　fortunately  this wasted work can be avoided by solving the subproblems in the reverse order taking the one nearest to the global goal point first. 
　　another consideration in the use of divide and conquer is the possibility that a subproblem may be poorly chosen so that there is no very direct path between its initial and goal points. this can be the case even when the global problem is soluble. if unlimited effort is expended on solving the subproblem then it can happen that the final path  backs  out from the initial point  finds a path around the obstacles that block a more direct route from the initial to final position  then  backs  into the goal position. the two subproblems on cither side backtrack over those initial and final parts of the path. see figure 1 for an illustration of this effect. 
　　in such cases  after some effort has been expended to determine that the direct path is blocked  it is better to back up to the more global problem and look for a new path through mixed cells. this can be simply achieved by placing a path length limitation on subproblems. once it is exceeded the subproblem exits with failure  forcing a new search at a higher level. in the examples given in this paper the cost limitation for subproblems is 1 times the cost of the global path  or 1 times the best cost ever computed for the sub-path  whichever is smaller. 
r. brooks and t. lozano-perez 1 
iv. conclusion 
the algorithm described here has been implemented and tested on many randomly generated examples. figure 1 shows two difficult cases that the algorithm solves. we believe these to be among the most difficult findpath problems ever solved by a program. the running time of the algorithm on these examples is very high  however. the actual running times for these difficult problems are on the order of tens of minutes of  wall clock  time on a single- user mit lisp machine without floating point hardware; these times also include a very significant paging overhead. simple problems  of course  run much faster: on the order of tens of seconds to a few minutes. this should be. contrasted with running times on the order of less than a minute for problems of moderate complexity using the algorithm described in brooks . this latter algorithm cannot solve problems such as illustrated in figure 1  however. 
　　while the running times of the algorithm described here could be made significantly shorter by implementation changes  the fact remains that the complexity of the algorithm is high. informal timing experiments seem to indicate that the algorithm spends much of the running time in the a* search procedure  which is used at several points in the algorithm. if the number of cells to be searched could be reduced  the running time could be significantly reduced. one approach to doing this is to use an algorithm such as described by brooks  to identify a likely path  using a smaller and simpler moving object  and then apply the algorithm described here to verify and refine the path for the actual moving object. this would reduce the size of the search space for the algorithm. there are a number of conceptual and technical problems to be solved before this hybrid approach is practical. as of now  the algorithm described here can solve very complex problems  albeit slowly. 
　　the questions  a  through  e  posed in section 1 have been answered for the case of polygons with rotations. section ha addressed question  d   1ib and hc addressed  a   hd and he addressed  b   ha addressed  c   and hb  hc  hd and he addressed  e . in generalizations of the solved problem case it is necessary to further refine only a subset of these andsers. 
　　the approach followed in this algorithm can be directly applied to configuration spaces for three-dimensional polyhedra whose orientation is fixed. this case generates a threedimensional configuration space with linear constraints - all of section 1 applies in simplified form. we believe that the generalization to a four dimensional configuration space  such as for a polyhedra with a single rotational degree of freedom  will be straightforward. a new type of constraint surface must be dealt with  however  arising from the interaction of pairs of edges  lozano-perez  1a  . 
　　the approach could  in principle  also be generalized to configuration spaces of higher dimension  such as those for polyhedra that are allowed to rotate. the actual generalization presents a large number of problems  e.g.  the cellcompare operation is substantially more difficult  and the number of cells grows extremely fast. other algorithms suggested for this general case have the same drawback. the algorithm for the general findpath problem given by schwartz and sharir   for example  has a very high polynomial time complexity for a fixed number of degrees of freedom and is exponential in the degrees of freedom. our belief is that  in practice  the general six degree of freedom problem should be heuristically reduced to cases involving four or fewer degrees of freedom. 
　　
acknowledgements 
　　the presentation of this paper has benefitted greatly from  the detailed comments of john hollerbach and the ijcai referees. 
