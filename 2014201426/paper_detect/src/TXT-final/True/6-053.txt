 
current description logic reasoning systems provide only limited support for debugging logically erroneous knowledge bases. in this paper we propose new non-standard reasoning services which we designed and implemented to pinpoint logical contradictions when developing the medical terminology dice. we provide complete algorithms for unfoldable acc-tboxes based on minimisation of axioms using boolean methods for minimal unsatisfiability-presening sub-tboxes  and an incomplete bottom-up method for generalised incoherence-preserving terminologies. 
1 introduction 
our work was motivated by the development of the dice1 terminology. dice implements frame-based definitions of diagnostic information for the unambiguous and unified classification of patients in intensive care medicine. the representation of dice is currently being migrated to an expressive description logic  henceforth dl  to facilitate logical inferences. figure 1 shows an extract of the dice terminology. in  cornet and abu-hanna  1  the authors describe the migration process in more detail. the resulting dl terminology  usually called a  tbox   contains axioms such as the following  where classes  like bodypart  are translated as concepts  and slots  like region  as roles: 

　developing a coherent terminology is a time-consuming and error-prone process. dice defines more than 1 concepts and uses 1 relations. to illustrate some of the problems  take the definition of a  brain  which is incorrectly specified  among others  as a  central nervous-system  and  body-part  located in the head. this definition is contradictory as nervous-systems and body-parts are declared disjoint in dice. fortunately  current description logic reasoners  
   'dice stands for  diagnoses for intensive care evaluation . the development of the dice terminology has been supported by the nice foundation. 
ronald cornet 
academic medical center 
universiteit van amsterdam  netherlands r.cornet amc.uva.nl 
such as racer  haarslev and moller  1  or fact  ilorrocks  1   can detect this type of inconsistency and the knowledge engineer can identify the cause of the problem. unfortunately  many other concepts are defined based on the erroneous definition of  brain  forcing each of them to be erroneous as well. in practice  dl reasoners provide lists of hundreds of unsatisfiable concepts for the dice tbox and the debugging remains a jigsaw to be solved by human experts  with little additional explanation to support this process. 
　by debugging we understand the identification and elimination of modelling errors when detecting logical contradictions in a knowledge base. debugging requires an explanation for the logical incorrectness and  as a second step  its correction. in this paper we will focus on the former as the latter requires an understanding of the meaning of represented concepts. we define a number of new non-standard reasoning services to explain incoherences through pinpointing. 
　our experience with debugging dice provides some hands-on examples for the problem at hand: take the contradictory definition of brains in the dice anatomy specification. what information is useful for correcting the knowledge base  first  we have to identify the precise position of errors within a tbox; that is  we need a procedure to single out the axioms causing the contradiction. the axioms for brain and centralnenvussystem form such a minimal incoherent subset of the dice terminology. formally  we introduce minimal unsatisfiability-presening sub-tboxes  abbreviated mups  and minimal incoherence-presening sub-tboxes  mips  as the smallest subsets of axioms of an incoherent terminology preserving unsatisfiability of a particular  respectively of at least one unsatisfiable concept. secondly  we highlight the elements of these definitions containing the faulty specification. 
an axiom  e.g.  nervoussystem points to the core of the erroneously modelled knowledge. for this purpose we define generalised incoherence-preserving terminologies  git  as sets of incoherent axioms  which are syntacticly related to the original axioms  more general and have minimal structural complexity. 
　the remainder of this paper is organised as follows: section 1 introduces the relevant dl concepts to make the paper self-contained. in section 1 we introduce the new reasoning services and provide algorithms in section 1. the paper finishes with a discussion of the results we obtained with our new methods on the terminology dice. 

description logics 	1 


figure 1: an extract from the dice terminology  frame-based . 

1 	description logics 
we shall not give a formal introduction into description logics here  but point to the new handbook  baader et at.  1 . briefly  dls are set description languages with concepts  usually denoted by capital letters   interpreted as subsets of a domain  and roles which are binary relations  which we denote by small letters. in a terminological component t  called tbox  the interpretations of concepts can be restricted to the models of t by defining axioms of the form   based on this formal model-theoretic semantics  a tbox can be checked for incoherence  i.e.  whether there are unsatisfiable concepts: concepts which are necessarily interpreted as the empty set in all models of the tbox. other standard reasoning services include subsumption of two concepts c and d  a subset relation w.r.t. all models of t . subsumption without reference to a tbox is called concept subsumption and we write . recently  a number of non-standard reasoning services have been defined  such as the least common subsumer of concepts or the minimal rewriting of concepts  see  kiisters  1  for an overview . 
　acc is a simple yet relatively expressive dl with conjunct i o n d i s j u n c t i o n n e g a t i o n and universal and existential quantification . a tbox is called unfoldable if the left-hand sides of the axioms  the defined concepts  are atomic  and if the right-hand sides  the definitions  contain no direct or indirect reference to the defined concept  nebel  1 . 
1 	explaining logical incoherences 
in this section we study ways of explaining incoherences in dl terminologies. we propose to simplify a terminology t in order to reduce the available information to the root of the incoherence. more concretely we first exclude axioms which are irrelevant to the incoherence and then provide simplified definitions highlighting the exact position of a contradiction within the axioms of this reduced tbox. we will call the former axiom pinpointing  the latter concept pinpointing. 
　in this section we will formally introduce axiom and concept pinpointing for a general tbox without restrictions on the underlying representation language. in section 1 we will give algorithms for the case of unfoldable acc-tboxes. 
1 	axiom pinpointing 
axiom pinpointing means identifying debugging-relevant axioms  where an axiom is relevant if a contradictory tbox becomes coherent once the axiom is removed or if  at least  a particular  previously unsatisfiable concept turns satisfiable. 
we will not consider assertional components in this paper. 
consider the following  incoherent  tbox 1  where a b and c are primitive and a  ...  a1 defined concept names: 

the set of unsatisfiable concept names as returned by a dl reasoner is {a1 a1 a1 a1}. although this is still of manageable size  it hides crucial information  e.g.  that unsatisfiability of a1 depends on unsatisfiability of a1  which is incoherent because of the contradictions between a1 and a1. we will use this example to explain our debugging methods. 
minimal unsatisfiability-preserv ing sub-tboxes  mups  unsatisfiability-prcserving sub-tboxes of a tbox t and an unsatisfiable concept a are subsets of t in which a is unsatisfiable. in general there are several of these sub-tboxes and we select the minimal ones  i.e.  those containing only axioms that are necessary to preserve unsatisfiability. definition 1 let a be a concept which is unsatisfiable in a tbox t. a set t'  t is a minimal unsatisfiability-
preserving sub-tbox  mups  of t if a is unsatisfiable in 
1~  and a is satisfiable in every sub-tbox t   v  
we will abbreviate the set of mups of t and a by mups t  a . mups for our example tbox t1 and its unsatisfiable concepts are: 

mups arc useful for relating unsatisfiability to sets of axioms but we will also use them in section 1 to calculate mips. 
minimal incoherence-preserving sub-tboxes  mips  mips are the smallest subsets of an original tbox preserving unsatisfiability of at least one atomic concept. 
definition 1 let t be an incoherent tbox. 
t is a minimal incoherence-preserving sub-tbox  mips  of t if t' is incoherent  and every sub-tbox  is coherent. 
we will abbreviate the set of mips of t by mips{t . for 1 we get three mips: 

it can easily be checked that each of the three incoherent tboxes in mips ti  is indeed a mips as taking away a single axiom renders each of the three coherent. the first one signifies  for example  that the first two axioms are already contradictory without reference to any other axiom  which suggests a modelling error already in these two axioms. 

cores 
minimal incoherence-preserving sub-tboxes identify smallest sets of tbox axioms causing the original tbox to be incoherent. in terminologies such as dice  which are created through migration from other representation formalisms  there are several such sub-tboxes  each corresponding to a particular contradictory terminology. cores are now sets of axioms occurring in several of these incoherent tboxes. the more mips such a core belongs to  the more likely its axioms will be the cause of contradictions. 
definition 1 let t be a tbox. a non-empty intersection of n different mips in rnips t   with n  1  is called a mlps-core ofarity n  or simply n-ary core  for t. 
livery set containing precisely one mips is  at least  a 1-ary core. the most interesting cores of a tbox  t  are those with axioms that are present in as many mips of t as possible  i.e.  having maximal arity. on the other hand  the size of a 
core is also significant  as a bigger size points to clusters of axioms causing contradictions in combination only. 
in our running example  axiom ax1 occurs both in 
  which makes  a core 
of arity 1 for t1  which is the core of maximal arity in this example. 
1 	concept pinpointing 
the next step in the debugging process is to simplify the definitions in order to obtain more concise descriptions of errors within an incoherent tbox. 
generalised terminologies 
incoherence of a tbox can be regarded as an overspecification of one or more concepts in the relevant definitions. generalised terminologies are terminologies where some of the definitions have been generalised.1 furthermore  we require generalised definitions to be syntactically related to the original axioms. for different representation languages and types of knowledge bases we will have to formally specify what we consider to be syntactically related concepts. for the time being let us keep the definition abstract and assume that there is such a relation rel  c  c'  denoting that two concepts c and c' are related. formally  a concept c  is then a syntactic generalisation of a concept c if rel{c  c  and 
  independent of t . note that we have to take care of the case when c is unsatisfiable w.r.t. t. then c is equivalent to  and everything is more general. therefore we generalise c without referencing to the original terminology t  i.e.  we check for simple concept subsumption  only. 
　now  generalised incoherence-preserving terminologies  gits  are tboxes where the defining concepts of the axioms are maximally generalised without losing incoherence. 
definition 1 	l
is a generalised incoherence-preserving terminolo f t if  and only if  
  each d1 is a syntactic generalisation of 
　　1 to simplify matters we generalise the right-hand side of axioms only as we are currently working with unfoldable tboxes anyway. 
  every tbox t  = with a syntactic generalisation d  of dt where di di and is coherent. 
we abbreviate the set of generalised incoherence-preserving terminologies of a tbox t by git t . note that the set of gits of a tbox t is equivalent to the union of gits for the mips of t. take a simple syntactic relation relating a concept with the syntactic sub-concepts of its unfolded version with the same polarity and quantifier depth.1 as this particular definition of a syntactic relation depends on unfolding the related concepts  all but one axiom per git can be trivially generalised to . of all possible gits we conjecture that the simplest ones  e.g.  those with syntactically minimal generalisations  are most likely to be useful for the identification of errors. in our experiments we use two alternative formalisations  the first with respect to minimal size of axioms  the second with respect to the number of concept names occurring in the git. three minimal sized gits exist for our example tbox 1  where we only show the non-trivial axioms: 

1 	debugging unfoldable alc-tboxes 
practical experience has shown that applying our methods on a simplified version of dice can already provide valuable debugging information. we will therefore only provide algorithms for unfoldable  alc-tboxes  nebel  1  as this significantly improves both the computational properties and the readability of the algorithm. 
1 	algorithms for axiom pointing 
the calculation of mips depends on the mups only  and we will provide an algorithm to calculate these minimal unsatisfiability-preserving sub-tboxes based on boolean minimisation of terminological axioms needed to close a standard tableau   baader et al.  1  chapter 1 . 
　usually  unsatisfiability of a concept is detected with a 
　fully saturated tableau  expanded with rules similar to those in figure 1  where all branches contain a contradiction  or close  as we say . the information which axioms are relevant for the closure is contained in a simple label which is added to each formula in a branch. a labelled formula has the form  a : c x where a is an individual name  c a concept and x a set of axioms  which we will refer to as label. a labelled branch is a set of labelled formulas and a tableau is a set of labelled branches. a formula can occur with different labels on the same branch. a branch is closed if it contains a clash  i.e. if there is at least one pair of formulas with contradictory atoms on the same individual. the notions of open branch and closed and open tableau are defined as usual and do not depend on the labels. we will always assume that any 
description logics 	1 　　1 thc polarity of a concept name a specifies whether a occurs within odd or even numbers of negations  the quantifier depth is the sequence of roles over which the concept is quantified. such a relation will formally be defined for unfoldable acc-tboxes in definition 1. 
formula is in negation normal form  nnf  and newly created formulas are immediately transformed. we usually omit the prefix  labelled . 
　to calculate a minimal unsatisfiability-preserving tbox for a concept name a w.r.t. an unfoldable tbox t we construct a tableau from a branch b initially containing only  for a new individual name a  by applying the rules in figure 1 as long as possible. the rules are standard alc-tableau rules with lazy unfolding  and have to be read as follows: assume that there is a tableau t = {b  b 1  ...  bn  with n+1 branches. application of one of the rules on b yields the 
t a	and {ax rule  
　once no more rules can be applied  we know which atoms are needed to close a saturated branch and can construct a minimisation function for a and t according to the rules in figure 1. a propositional formula  is called a minimisation function for a and t if a is unsatisfiable in every subset of t containing the axioms which are true in an assignment making true. in our case axioms are used as propositional variables in . as we can identify unsatisfiability of a w.r.t. a set s of axioms with a closed tableau using only the axioms in s for unfolding  branching on a disjunctive rule implies that we need to join the functions of the appropriate sub-branches conjunctively. if an existential rule has been applied  the new branch b' might not necessarily be closed on formulas for both individuals. assume that b' closes on the individual a but not on b. in this case min-function a  b t  =  which means that the related disjunct does not influence the calculation of the minimal incoherent tbox. 
based on the minimisation function minfunction a  { a : 
　　　　 let us call it which we calculated using the rules in figure 1 we can now calculate the mups for a w.r.t. t. the idea is to use prime implicants of  a prime implicant is the smallest conjunction of literals1 implying  quine  1 . as is a minimisation function every implicant of must be a minimisation function as well and therefore also the prime implicant. but this implies that the concept a must be unsatisfiable w.r.t. the set of axioms is the smallest implicant must be minimal  i.e. a mups. theorem 1 captures this result formally. 
1 note that in our case all literals are non-negated axioms. 
theorem 1 let a be a concept name  which is unsatisfiable w.r.t. an unfoldable acc-tbox t. the set of prime im-
plicants of the minimisation function minjunction a { a 	: 
  t  is the set mups t  a  of minimal unsatisfiabilitypreserving sub-tboxes of a and t. 
proof: we first prove the claim that the propositional formula 
 := min function  t  is indeed a minimisation function for the mups problem w.r.t. an unsatisfiablc concept a and a tbox t. we show that a tableau starting on a single branch  closes on all branches by 
unfolding axioms only  that are evaluated as true in an assignment making true. this saturated tableau tab* is a particular sub-tableau of the original saturated tableau tab which we used to calculate min-function   t   and it is this connection that we make use of to prove our first claim. every branch in the new tableau is a subset of a branch occurring in the original one and we define visible formulas as those labelled formulas occurring in both tableaux. by induction over the rules applied to saturate tab we can then show that each branch in the original tableau closes on at least one pair of visible formulas. if a is unsatisfiable w.r.t. t  the tableau starting with the branch  closes w.r.t. t. as we have shown that this tableau closes w.r.t. t on visible formulas  it follows that tab* is closed on all branches  which proves the first claim. by another induction over the application of the rules in figure 1 we can prove that is a maximal minimisation function  which means that for every minimisation function  this proves the first part of the proof; the first claim  and the argument from above  implies that every implicant of a minimisation function identifies an unsatisfiability-preserving tbox  and maximality implies that prime implicants identify the minimal ones. to show that the conjunction of every mups 
is a prime implicant of 	is 
trivial as is a minimisation function by definition. but as we know that minjunction a  is maximal we know that 
         which implies that 	must be prime as otherwise 	would not be minimal. 	＊ 
satisfiability in acc is pspace-complete  and calculating mups does not increase the complexity as we can construct the minimisation function in a depth-first way  allowing us to keep only one single branch in memory at a time. however  

we calculate prime implicants of a minimisation function the size of which can be exponential in the number of axioms in the tbox. therefore  approximation methods have to be considered in practice avoiding the construction of fully saturated tableaux in order to reduce the size of the minimisation functions. 
   from mups we can easily calculate mips  but we need an additional operation on sets of tboxes  called subsetreduction. let m = { t 1   . . .   tm  be a set of tboxes. the subset-reduction of m is the smallest subset sr m   m such that for all t  m there is a set v sr m  such that 
'v  t. a simple algorithm for the calculation of mips for t now simply follows from theorem 1  which is a direct consequence of the definitions of mips and mups. 
theorem 1 	let t be an incoherent tbox with unsatisfiable concepts 
　checking elements of mips t  for cores of maximal arity requires exponentially many checks in the size of mips t . in practice  we therefore apply a bottom-up method searching for maximal cores of increasing size stopping once the arity of the cores is smaller than 1. 
1 	algorithms for concept pinpointing 
calculating gits depends on the definition of rel c  c . in our case we will define this syntactic relation described in footnote 1 including quantifier depth and polarity. 
definition 1 let t be an unfoldable  alc-t1ox. a concept c  is syntactically related to a concept c  notation: rcl c  c'   if c  ' - c   where the set of qualified subconcepts  qsr{c   is defined inductively: 

note that we include terminological information from unfolded tbox axioms in the definition of syntactic relatedness. this choice allows us to create smaller and more concise gits but is non-essential. as the tbox is finite and cyclefree  and as the concept size decreases in every recursion step   is finite. therefore there is only a finite set of concepts related to any axiom . a simple algorithm to calculate gits for an incoherent unfoldable alc-tbox t is therefore: 
for all mips m  mips{t   with |rmp* t | = m  
1. let t' be the tbox where all axioms in t have been replaced by 
1. calculate different tboxes t  where an arbitrary number of axioms      have been replaced in t' by generalised axioms   i.e.  where and for some 
1. return those incoherent tboxes t  with minimal syntactic generalisations according to the subsumption relation  and the size or number of concept names. 
　the algorithm described above is a naive algorithm which might not terminate in reasonable time on large terminologies with complex definitions as the number of syntactically related concepts for a given concept c is exponential in the size of c. a more efficient algorithm to calculate gits is based on the fact that the syntactically related concepts can be created ordered by size starting with atomic concepts. to find gits of minimal size we therefore apply a bottom-up strategy checking more and more complex terminologies for coherence in step 1 stopping once we find an incoherent one. 
1 	evaluation 
the algorithms for axiom pinpointing have been implemented in java using racer  which provides the set of unsatisfiable concepts. we evaluated the methods on both the anatomy fragment of dice and the full dice terminology. the fragment defines 1 concept names  1 of which were unsatisfiable at first.*' there arc 1 mips containing 1 axioms each  but no axiom occurs in all mips. however  there is a core of arity 1 and size 1: the axiom defining  central nervous system  as a  nervous system . note that the definition of  nervous system  is not contradictory but that its use is erroneous  e.g.  the concept brain should be defined as a  part of  and not as a subconcept of the concept nervous system. for each of the 1 mips minimal size gits have been calculated  and they point to the exact position of the logical incorrectness. for the mips related to the error described 
     1 thc high number of unsatisfiable concepts is due to the fact that the dl terminology for dice has been created by migration from a 
   frame-based terminological system. in order to make the semantics as explicit as possible a very restrictive translation has been chosen to highlight as many ambiguities as possible. moreover  many concepts were defined as sub-concepts of unsatisfiable concepts. see  cornet and abu-hanna  1  for details. 

description logics 	1 

in the introduction the minimal size git is simply brain nervoussystem bodypart which  with the information that bodypart and nervoussystem are disjoint concepts  identifies the erroneous specification. 
　the full dice terminology defines more than 1 concepts  of which more than 1 were unsatisfiablc given the chosen migration method. our implemented algorithms found the mups for all but 1 unsatisfiable concepts. in these seven cases the algorithm failed on the calculation of the prime implicants as we use a naive method in our current implementation. based on the correctly calculated mups we approximated the set of mips which contained more than 1 tboxes. we implemented an iterative approach  calculating the core max of size 1 with maximal arity for mips tdicv   then the same for the remaining tboxes in mips tdice  max and so on. this way we identified 1 cores of size 1 with an arity of 1 to 1  covering almost half of the errors. for some of these cores we calculated gits  by hand  which lead to the identification of a number of modelling errors. even though the developed reasoning services are not yet fully integrated into the knowledge modelling environment  they are useful to pinpoint to the core of the logical contradiction  which is then investigated and eliminated by a domain expert. 
　although the theoretical complexity of the mups problem is exponential in the size of the tbox the calculation of most mups for dice was not problematic due to the relatively simple structure of the tableaux for the unsatisfiability proofs. runtime analysis suggests that most cpu-time is spent by racer identifying the unsatisfiable concepts  whereas computing mups usually takes less than 1 percent of the overall runtime1. 
1 	conclusion & further work 
explanation has been a research topic right from the first days of research in artificial intelligence  e.g.  introducing tms  doyle  1  or diagnosis  reiter  1   and theorem proving  recently  fiedler  1  . despite a significant interest in explanation of dl reasoning recently shown in the dl community  as  dig  1  suggests  relatively lit-
tle work has been published on the subject. one exception is  mcguinness  1  where the author provides explanation for subsumption and non-subsumption. her approach  based on explanation as proof fragments  uses structural subsumption for classic and has been extended to alc-tableau reasoning in  borgida et al  1 . in contrast to this approach  our non-standard reasoning services for axiom and concept pinpointing focus on the reduction of information  and are independent of particular calculi or implementations. 
　we have introduced non-standard reasoning services facilitating the debugging of logically incoherent dl terminologies and algorithms to calculate them. whereas the ideas for axiom pinpointing are more evolved and efficiently implemented  only a relatively naive algorithm for concept pinpointing has been developed as yet. we are currently working on more efficient methods and alternative debugging services  and tests are under way on the dice terminology. 
   1 for the full dice terminology the overall runtime to calculate mips is currently about 1 minutes on a pc with a 1 ghz pentium. 
　as our methods are developed for the particular application of the dice terminology some restrictions apply  most importantly to use acc and to consider unfoldable tboxes  only. neither is essential  and we conjecture that it is not too hard to extend our algorithms to find mips and gits both for more expressive languages and for general tboxes. both issues will be addressed in future investigations. further work must also extend the application domain to other terminologies as we believe that the success we have with debugging dice is not tied to the structure of this particular representation. of particular interest should be applications related to the semantic web effort as our methods are particularly geared to support the debugging of existing terminologies and logical contradictions caused by migration or merging of terminologies. 
