 
the benefits of modular representations arc well known from many areas of computer science. in this paper  we concentrate on the benefits of modular ontologies with respect to local containment of terminological reasoning. we define an architecture for modular ontologies that supports local reasoning by compiling implied subsumption relations. we further address the problem of guaranteeing the integrity of a modular ontology in the presence of local changes. we propose a strategy for analyzing changes and guiding the process of updating compiled information. 
1 introduction 
currently  research in the area of the semantic web is in a state where ontologies are ready to be applied in real applications such as semantic web portals  information retrieval or information integration. in order to lower the effort of building ontology-based applications  there is a clear need for a representational and computational infrastructure in terms of general purpose tools for building  storing and accessing ontologies. a number of such tools have been developed  i.e. ontology editors  reasoning systems and more recently storage and query systems.1 most of these tools  however  treat ontologies as monolithic entities and provide little support for specifying  storing and accessing ontologies in a modular manner. 
1 why modularization   
there are many reasons for thinking about ontology modularization. our work is mainly driven by three arguments. these also bias the solution we propose  as it is aimed at improving the current situation with respect to the following aspects. 
distributed systems: in highly distributed systems such as the semantic web  modularity naturally exists in terms of physical location. providing interfaces and mechanisms 
　'an extensive overview is provided in the onto web deliverable  available at http: //www.ontoweb.org/download/ deliverables/d1 vl-1.zip. 
for connecting these natural modules is a prerequisite for easy maintenance  heflin and hendler  1 . 
large ontologies: modularization also helps to manage very large ontologies we find for example in medicine or biology. here modularity helps to maintain and reuse parts of the ontology as smaller modules are easier to handle than the complete ontology  rector  1 . 
efficient reasoning: a specific problem that occurs in the case of distributed and large models is the problem of efficient reasoning. the introduction of modules with local semantics and clear interfaces will help to develop efficient reasoning methods  mcllraith and amir  1 . 
1 requirements 
there are a couple of requirements a modular ontology architecture has to fulfill in order to improve ontology maintenance and reasoning in the way suggested above. the requirements will be the main guidelines for the design of our solution proposed in this work. 
loose coupling: in general  we cannot assume that two ontology modules have anything in common. this refers to the conceptualization as well as the specific logical language used for the interpretation of objects  concepts or relations. 
self-containment: in order to facilitate the reuse of individual modules we have to make sure that modules are selfcontained. in especially  the result of certain reasoning tasks such as subsumption or query answering within a single module should be possible without having to access other modules. 
integrity: having self-contained ontology modules may lead to inconsistencies that arise from changes in other ontology modules. we have to provide mechanisms for checking whether relevant knowledge in other systems has changed and for updating our modules accordingly. 
1 our approach 
in the following  we describe our approach to ontology modularization on an abstract level. we emphasize the main design decisions and motivate them on the basis of the requirements defined above. the technical details of the approach will be given in the following sections. 

view-based mappings: we adopt the approach of viewbased information integration. in particular  ontology modules are connected by conjunctive queries. this way of connecting modules is more expressive than simple one-to-one mappings between concept names but less expressive than the logical language used to describe concepts. we decide to sacrifice a higher expressiveness for the sake of conceptual simplicity and desirable semantic properties such as independence of the ontology langauge used. 
compilation of implied knowledge: in order to make local reasoning independent from other modules  we use a knowledge compilation approach. the idea is to compute the result of each mapping query off-line and add the result as an axiom to the ontology module using the result. during reasoning  these axioms replace the query thus enabling local reasoning. 
change detection and automatic update: once a query has been compiled  the correctness of reasoning can only be guaranteed as long as the concept hierarchy of the queried ontology module does not change. in order to decide whether the compiled axiom is still valid  we propose a change detection mechanism that is based on a taxonomy of ontological changes and their impact of the concept hierarchy. 
　the rest of the work is organized as follows. in section 1 we provide a definition of ontology modules based on a minimal notion of ontologies that fixes important properties we will use later on while leaving as much freedom for specific implementations as possible. section 1 introduces our approach to self-containment in terms of compiled knowledge. the remainder of the paper is devoted to the problem of detecting changes and preserving integrity amongst modules in a system. 
1 modular ontologies 
before we start investigating the problem of change and integrity  we define the notion of modular ontology we will use as a basis for our technical results. 
1 	modules and queries 
a number of languages for encoding ontologies on the web have been proposed  see  gomez-perez and corcho  1  for an overview . in order to get a general notion of ontological knowledge  we define the general structure of an ontological module and its instantiation independent of a concrete language. 
definition 1  ontology module  a module is a triple m - where c is set of concept definitions  1 is a set of 
relation definitions and is a set of object definitions. further  we define the signature of a module to be a triple  where cm is the set of all names of 
concepts defined in c  tim the set of all relation names in r and rthe set of all object names occurring in 
　queries over ontological knowledge are defined as conjunctive queries  where the conjuncts are predicates that cor-
respond to concepts and relations of an ontology. further  
ontologies and foundations 
variables in a query may only be instantiated objects in that ontology. 

　the fact that all conjuncts relate to elements of the ontology allows us to determine the answer to ontology-based queries in terms of instantiations of the query that are logical consequences of the knowledge base. 
1 internal and external definitions the notion of module and query given above is a quite standard ones. what makes up a modular ontology now  is the possibility to use ontology-based queries in order to define concepts in one module in terms of a query over another module. for this purpose  we divide the set of concepts in a module into internally defined concepts c1 and externally defined concepts ce resulting into the following definition of c: 
		 1  
　internally defined concepts are specified by using concept expressions in the spirit of description logics  baader et ai  1 . we do not require a particular logic to be used. 
definition 1  internal concept definition  an internal concept definition is an axiom of one of the following forms 
　　　　　　　　where 	and d is concept expression of the form 	where the terms are either concept names or concept expressions and is an n-ary concept building operator 
　besides this standard way of defining concepts  we consider externally defined concepts that are assumed to be equivalent to the result of a query posed to another module in the modular ontology. this way of connecting modules is very much in spirit of view-based information integration which is standard technique in the area of database systems  halevy  1 . the choice of conjunctive queries for connecting different modules is motivated by the trade-off between expressiveness of the mapping and conceptual as well as computational simplicity. our approach is more expressive than simple one-to-one mappings; having more complex mappings would contradict the principle of loose coupling of different modules. 
definition 1  external concept definition  an external concept definition is an axiom of the form: c = m : where m is a module and is an ontology-based query over the signature of m. 
　a modular ontology is now simply defined as a set of modules that arc connected by external concept definitions. in 
particular we require that all external definitions are contained in the modular system. 
     1note that this may include data-type expressions as the type itself is can be considered to be a concept  the actual value a member of that concept and the comparison operator a special relation. 
definition 1  modular ontology  a 	modular ontology is a set of modules such that for each externally 	defined 	concept 	is also member ofm. 
　we will use this notion of a modular ontology in the following to investigate the problem of integrity of logical reasoning across modules. 
1 semantics and logical consequence we define a model-based semantics for modular ontologies using the notion of a distributed interpretation proposed by  borgida and scrafini  1  in the context of distributed description logics: 
definition 1  distributed interpretation  a distributed in-
terpretation 	of modular ontology 
consists of interpretations for the individual module m1 over domains such that: 
　the assumption of disjoint interpretation domains again reflects the principle of loose coupling underlying our approach. based on the notion of a distributed interpretation we can define a model of a modular ontology as an interpretation that satisfies the constraints imposed by internal and external concept definitions. in contrast to  borgida and scrafini  1   we do not introduce special operators for defining the relations between different domains  we rather interpret external concept definitions as constraints on the relation between the domains: 
definition 1  logical consequence  a distributed interpretation is a model for modular ontology   if for every module mt we have for every concept definition c in m1 where is defined as follows. 
here 	denotes the interpretation of the set of answers to query 	an axiom a logically follows from a set of axioms 
s if s implies a for every model we denote this fact by s a. 
　the actual definitions of concepts impose further constraints on the interpretation of a modular ontology. for the case of internally defined concepts  these constraints are provided by the definition of concept building operators of description logics. for the case of externally defined concepts  the situation is more complicated and will be discussed in more details in the next section. 
1 compilation and local reasoning 
using the notion of logical consequence defined above  we now turn our attention to the issue of reasoning in modular ontologies. for the sake of simplicity  we only consider the interaction between two modules in order to clarify the basic 
principles. further  we assume that only one of the two modules contains externally defined concepts in terms of queries to the other module. 
1 	implied subsumption 
as mentioned in the introduction  we are interested in the possibility of performing local reasoning. for the case of ontological reasoning  we focus on the task of deriving implied subsumption relations between concepts within a single module. for the case of internally defined concepts this can be done using well established reasoning methods  donini et al.  1 . externally defined concepts  however  cause problems: being defined in terms of a query to the other module  a local reasoning procedure will often fail to recognize an implied subsumption relation between these concepts. consequently  subsumption between externally defined concepts requires reasoning in the external module as the following theorem shows. 
theorem 1  implied subsumption  let e1 and e1 be two concepts in module mt that are externally defined in module by queries 
　the result presented above implies the necessity to decide subsumption between conjunctive queries in order to identify implied subsumption relations between externally defined concepts. in order to decide subsumption between queries  we translate them into internally defined concepts in the module they refer to. a corresponding sound and complete translation is described in  horrocks and tessaris  1 . using the resulting concept definition  to which we refer as query concepts  we can decide subsumption between externally defined concepts by local reasoning in the external ontology. 
1 	compilation and integrity 
we can avoid the need to perform reasoning in external modules each time we perform reasoning in a local module using the idea of knowledge compilation  cadoli and donini  1 . the idea of compilation is to perform the external reasoning once and add the derived subsumption relations as axioms to the local module. these new axioms can then be used for reasoning instead of the external definitions of concepts. this set of additional axioms can be computed using algorithm 1. 
　if we want to use the compiled axioms instead of external definitions  we have to make sure that this will not invalidate the correctness of reasoning results. we call this situation  where the compiled results are correct as integrity. we formally define integrity as follows: 

definition 1  integrity  we consider integrity of two ontology modules to be present i f w h e r e 
mc is the result of replacing the set of external concept definitions in m by compile 
　at the time of applying the compilation this is guaranteed by theorem 1  however  integrity cannot be guaranteed over the complete life-cycle of the modular ontology. the problem is  that changes to the external ontology module can invalidate the compiled subsumption relationships. in this case  we have to perform an update of the compiled knowledge. 
1 change robustness 
in principle  testing integrity might be very costly as it requires reasoning within the external ontology. in order to avoid this  we propose a heuristic change detection procedure that analyzes changes with respect to their impact on compiled subsumption relations. work on determining the impact of changes on a whole ontology is reported in  heflin and llcndler  1 . as our goal is to determine whether changes in the external ontology invalidates compiled knowledge  we have to analyze the actual impact of changes on individual concept definitions. we want to classify these changes as either harmless or harmful with respect to compiled knowledge. 
1 determining harmless changes as compiled knowledge reflects subsumption relations between query concepts  a harmless change is a set of modifications to an ontology that does not change these subsumption relations. finding harmless changes is therefore a matter of deciding whether the modifications affect the subsumption relation between query concepts. we first look at the effect of a set of modifications on individual concepts: 
　assuming that c represents the concept under consideration before and the concept after the change there are four ways in which the old version c may relate to the new version 

1. the meaning of concept is not changed:  e.g. because the change was in another part of the ontology  or because it was only syntactical ; 
1. the meaning of a concept is changed in such a way that concept becomes more general: 
1. the meaning of a concept is changed in such a way that concept becomes more specific: 
1. the meaning of a concept is changed in such a way that there is no subsumption relationship between c and 
ontologies and foundations 
　the same observations can be made for a relation before and after a change  denoted as r and r! respectively. the next question is how these different types of changes influences the interpretation of query concepts. we take advantage of the fact that there is a very tight relation between changes in concepts of the external ontology and implied changes to 
the query concepts using these concepts: 
proof 1  sketch  the idea of the proof is the following: 
queries contain conjuncts of the form conjuncts of the first form are interpreted as it directly follows that changing the interpretation of the concept c referred to in a conjunct of this type leads to the same change on the interpretation of the conjunct and because con-
junction is interpreted as set intersection the whole query. 
conjuncts of the second type are interpreted as 
             the variable can be further constraint by a conjunct of the first type. again changes in the interpretation of the concept that further restricts y have the same effect on possible interpretations of and therefore also on the interpretation of conjuncts of the second type. using the same argument  we see that making r more general/specific  allowing more/less tuples in the relation  makes conjuncts of the second form more general/specific. using these basic conclusions  we can proof the lemma by induction over the lengths of the path in the dependency graph of the query where nodes represent conjuncts and arcs co-occurrence of variables. 
　we can exploit this relation between the interpretation of concepts and queries in order to identify the effect of changes in the external ontology on the subsumption relations between different query concepts. first of all the above result directly generalizes to multiple changes with the same effect  i.e. a query becomes more general specific  or stays the same if none of the elements in become more specific gencral . further  the subsumption relation between two query concepts does not change if the more general specific  query becomes even more general specific  or stay the same. combining these two observations  we derive the following characterization of harmless change. 


　the theorem provides us with a correct but incomplete method for deciding whether a change is harmless. this basic method can be refined by analyzing the overlap of and in combination with the relations they restrict. this more accurate method is not topic of this paper  but it relies on the same idea as the theorem given above. 
1 	characterizing changes 
now we are able to determine the consequence of changes in the concept hierarchy on the integrity of the mapping  we still need to know what the effect of specific modifications on the interpretation of a concepts is  i.e. whether it becomes more general or more specific . as our goal is to determine the integrity of mappings without having to do classification  we describe what theoretically could happen to a concept as result of a modification in the ontology. to to so  we have listed all possible change operations to an ontology according to the owl-lite1 knowledge model in the same style as done in ibanerjce et al  1 . the list of operations is extendable to other knowledge models; we have chosen the owllite model because of its simplicity and its expected important role on the semantic web. apart from atomic change operations to an ontology - like add range restriction or delete subclass relation - the list also contains some com-
plex change operations  which consist of multiple atomic operations and/or incorporate some additional knowledge. the complex changes are often more useful to specify effects than the basic changes. for example  for operations like concept moved up  or domain enlarged  we can specify the effect more accurately than for the atomic operations subclass relation changed and domain modified1. atomic changes can be detected without using the knowledge in the ontology itself  only using the knowledge of the knowledge model  i.e. the language. these changes are detected at a structural level. to identify complex changes  we also need to use the content of the ontology itself. we are currently working on rules and heuristics to distill complex changes from sets of atomic changes  klein and noy  1 . table 1 contains some examples of operations and their effect on the classification of concepts. the table only shows a few examples  although our full ontology of change operations contains around 1 operations. this number is still growing as new complex changes arc defined. a snapshot of the change ontology can be found online.1 the specification of effects is not complete  in the sense that it describes  worst case  scenario's  and that for some operations the effect is  unknown   i.e. unpredictable . in contrast to  franconi et al.  1  who provides complete semantics of changes we prefer to use heuristics in order to avoid expensive reasoning about the impact of changes. 
  operation 
attach a relation to concept c | effect 
c: specialized complex. change the superclass of concept c to a concept lower in the hierarchy c: specialized complex. restnct the range of a relation r  efleet on all c that have a restriction on r  r: specialized  c: specialized remove a superclass relation of a concept c c. generalized change the concept definition of c from primitive to defined c: generalized add a concept definition a c: unknown 1 complex add a  not further specified  subclass a of c c: no effect define a relation r as functional 	/ : specialized 
table 1: some modification to an ontology and their effects on the classification of concepts in the hierarchy. 
1 	update management 
with the elements that we described in this section  we now have a complete procedure to determine whether compiled knowledge in other modules is still valid when the external ontology is changed. the complete procedure is as follows: 
1. create a list of concepts and relations that are part of the  subsuming  query of any compiled axiom; 
1. create another list of concepts and relations that are part of the  subsumed  query of any compiled axiom; 
1. achieve the modifications that are performed in the external ontology; 
1. use the modifications to determine the effect on the interpretation of the concept and relations. 
1. check whether there arc concepts or relations in the first   subsuming   list that became more specific  or concepts or relations in the second   subsumed   list that became more general  or concepts or relations in any of the lists with an unknown effect; if not  the integrity of the mapping is preserved. 
algorithm 1 update 
require: ontology module m 
require: ontology module 
for all compiled axioms   do for all x 	do 
if effect on c is 'generalized' or 'unknown' then 
end if 
end for 
for all x do 
if effect on x is 'specialized' or 'unknown' then 

　end if end for 
end for 
　we describe the procedure in a more structured way in algorithm 1. the algorithm triggers a  re- compilation step only if it is require in order to resume integrity. otherwise 

no action is taken  because the previously compiled knowledge is still valid. all the steps can be automated. a tool that 
                                     1 lutein et at.  1 . this tool will compare two versions of an ontology and derive the list of change operations that is necessary to transform the one into the other. it will also be able to detect some of the complex operations. the tool will also annotate the definitions in an ontology with the effect that the change has on its place in the hierarchy. 
1 conclusions 
there is a growing need for applying the principle of modularity to representations of ontological knowledge in order to facilitate the creation  maintenance and re-use of knowledge. this paper contributes to the development of a theory of modular ontologies  focussing on the issue of reasoning in modular ontologies that change over time. the contributions of this paper is three-fold: 
1. we propose an architecture for modular ontologies and analyze the role of mappings in logical reasoning across modules. 
1. we describe a knowledge compilation approach that makes local reasoning within modules possible and define the notion of integrity. 
1. we develop an update strategy that preserves integrity by identifying changes in ontology modules and deciding whether the compiled knowledge has to be updated or not. 
　we think that the approach described meets the practical needs of creating and using ontologies without missing a formal underpinning. it uses well-established representations of ontological knowledge and a rather simple and intuitive representation of mappings. further  all of the supporting methods described can be automated in order to assist ontology engineers and developers of ontology-based systems. we deliberately chose to make some simplifications in order to be able to develop concise methods. first of all  these simplifications concern the restriction to a system of only two modules and the use of a rather weak heuristic for determining the effect of changes on compiled knowledge. in future work  we will investigate the impact of these simplifications and try to develop a more complete theory of the interaction in complex systems of modules and of the impact of changes on derived knowledge. further one can as well imagine an external definition of relations using conjunctive queries with more than one free variable and reducing implied subsumption to the general problem of query containment under constraints  calvanese et al.  1 . 
