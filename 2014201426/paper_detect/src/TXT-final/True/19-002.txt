 
　　logic programming has been an attempt to bridge the gap betwen specification and programming language and thus to simplify the software development process. even though the only difference between a specification and a program in a logic programming framework is that of efficiency  there is still some conceptual distance to be covered between a naive  intuitively correct specification and an efficiently executable version of it and even though some mechanical tools have been developed to assist in covering this distance  no fully automatic system for this purpose is yet known. in this paper v/t present a general class of first-order logic relations  which is a subset of the extended horn clause subset of logic  for which we give mechanical means for deriving horn logic programs  which are guaranteed to be correct and complete with respect to the initial specifications. 
i. introduction 
a* logic program derivation* 
　　logic programming is an attempt to bridge the gap between specification and programming language requirements. by making a clear separation between logic and control  it makes it possible for the programmer to deal initially with the logic of his problem and then derive more efficient  still logically equivalent  versions of it by altering the control accordingly. the apparently simple operational semantics of horn-clausal logic and its various efficient implementations  mainly in the form of prolog interpreters and compilers  makes it quite appealing as a programming language. 
　　of course  even though it has been shown that any problem expressed in first oider predicate logic can be reformulated using only horn clauses  expressing problems in horn clauses is certainly not claimed to be very natural. various attempts have been made -  bowen 
1    murray 1    stickel 1  - to implement full first-order logic as a programming language but  apart from efficiency considerations  the lack of intuitively clear operational semantics for full first-onier logic makes them unusable. 
on the other hand   clark & sickel 1    hannson 
* research supported by the greek slate scholarships foundation. 
	dayantis 	1 


ordering 	relation 
	dayantis 	1 


	dayantis 	1 

formally by induction - that a logic program can be ultimately deduced 

　　the identification and synthesis process for the err class of relations described in the above theorem has been implemented in prolog  thus providing with an automatic tool for synthesising  naive  programs for such relations. 
i i i . concluding remarks 
　　we have identified a subset of the extended horn clause subset of logic  for which we proved that it can be reexpressed in horn clausal form. thus  for relations that are defined with clauses belonging to this subset we gave mechanical means for obtaining a directly executable  by standard prolog interpreters  program. 
　　the significance of this transformation largely depends on two factors. 
the first is the generality of this class: how many relations are naturally expressed in this way  in  kowalski 1  it is argued that the extended horn clause subset of bgic has great expressive power and many examples  as the ones presented above  can be found that fall within this class. moreover our subset is still general enough; the only requirement is that the antecedent of the universally quantified horn clause is recursively defined with an ultimate direct instantiation of the universally quantified variables. such a case is very common when dealing with recursively defined domains as indicated by the examples presented. 
　　the second is whether the recursive horn clausal form  which is the end product of this transformation is really more efficiently executable than the initial specification. as it is pointed out in  kowalski 1  one can build interpreters that encompass the extended horn clause subset of logic:  by translating the universal quantifier into double negation and interpreting negation by failure such clauses can be executed both correctly and efficiently  though incompletely . the source of incompleteness is the introduction of negation  which means that we cannot get all possible answers to a query. for example in the case of the 'subset' example this method will work only for queries with both arguments instantiated - to test if the relation holds between two known sets - while execution won't terminate in any other use. this  of course  is a severe limitation  given our expectations from a logic programming language that is supposed to offer input-output nondeterminism  and it can be overcome using the recursive programs. 
furthermore  it is argued that such an iterative execution - effectively generating every instance of the universally quantified variables that satisfies the antecedent and checking if it also satisfies the consequent - is more efficient than a recursive one  since it does not require a stack- given that there are efficient ways of implementing recursion - tail-recursion in particular can be turned into iteration - we argue that the recursive programs that result from our transformation are in general more efficient than the corresponding iterative execution of the initial specifications. additionally they do not require any extra sophistication from the bgic interpreter for their execution. 
　　in the light of the above discussion a link between iteration and recursion should become apparent furthermore  it should be realised that the above result depends very much upon the nature of recursion and it is unlikely that similar results can be obtained for more general subsets of logic. obviously  additional domainspecific knowledge and intelligent manipulation is necessary for the derivation of efficient horn clause programs from arbitrary first-order logic specifications. 
