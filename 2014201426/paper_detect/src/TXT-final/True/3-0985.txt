
a certificate of satisfiability for a quantified boolean formula is a compact representation of one of its models which is used to provide solverindependent evidence of satisfiability. in addition  it can be inspected to gather explicit information about the semantics of the formula. due to the intrinsic nature of quantified formulas  such certificates demand much care to be efficiently extracted  compactly represented  and easily queried. we show how to solve all these problems.
1	introduction
the term  certificate  has a fairly general meaning  originating in language recognition and complexity theory. once verified  a certificate proves that the string it refers to actually belongs to a language of interest. applied to logic  the term denotes any means of providing evidence of  un satisfiability for a given statement  other than a refutationally-compete deductive approach. in essence  we verify that a given logical formula belongs to the language of  un satisfiable statements.
¡¡the most natural certificate of satisfiability  sat-certificate  for a formula is an explicit representation of some of its models. a formula is indeed satisfiable if and only if some model makes it evaluate to true. the validity of a certificate can be verified by whoever is knowledgeable about the evaluation apparatus of the logic  deductive capabilities are unnecessary   independently of how it was obtained.
¡¡in this paper  we focus on sat-certificates for quantified boolean formulas  qbfs . such certificates have never been proposed or used so far for a number of reasons. first  the intrinsic nature of a qbf confers a tree-shaped structure to its models  whose explicit representation may become unaffordable. second  theoretical arguments exist that make it unlikely to find polynomial-time verification procedures  qbf satisfiability is pspace-complete  stockmeyer and meyer  1  . finally  present qbf solvers find it either impractical or not straightforward to collect all the information needed to construct a model. as a consequence  qbf models feature no

 
¡¡¡¡this work is supported by pat  provincia autonoma di trento  italy   under grant n. 1.commonly accepted representation  if any at all   and all the current solvers return a little more than a sat/unsat answer.
¡¡despite these issues  sat-certificates for qbfs are extremely desirable thank to their potential benefits on applications and solvers. for example  a certificate is a conclusive means to judge conflicting answers given by different solvers on the very same instance. clearly  this event reveals no finer problem than a bug in the implementation  which we might think is not worth considering. this happens fairly often though  and as long as we treat solvers as black boxes  a proof-of-satisfiability approach is the only realistic way to tell the truth. we quote  le berre et al.  1 :
the question of how to check the answer of the qbf solvers in an effective way is still unanswered  ...  the question of what is a good certificate of satisfiability/unsatisfiability  ...  remains open. this point is not only an issue for the qbf evaluation  but also for the implementation:  ...  we had soundness problems with 1 qbf solvers.  ... 
yet  a certificate is much more than a way to ensure satisfiability: it can be inspected to gather semantics from the underlying formula. this is of paramount importance in applications  where certificates add valuable information to a mere sat/unsat answer. for example  a sat answer to the propositional  prop  encoding of  the negation of  a desired property over a logic circuit means that the circuit is faulty w.r.t. that property. but  it takes a certificate to outline a definite scenario in which the fault shows up. as opposed to qbf certificates  such prop certificates are easy to represent and verify  hence they have had a wide application.
¡¡the relevance of certificates enlarges with the scope of application of the underlying logic. in this respect  qbf is a notable case with plenty of applications. every problem that can be stated as a two-player finite game can be modeled in qbf. an insightful example is obtained by considering the famous game  connect-1 . it is known that the player who moves first can always win. the rules of the game and the existence of a winning strategy can be encoded into a qbf instance  gent and rowley  1   expected to be sat. which is the winning strategy  a certificate would disclose such information: the first player would prevail by just inspecting the certificate at each move  whatever the opponent does.
¡¡the interesting point here is that many real-world applications can be modeled as two-player games: unbounded model checking for finite-state systems  rintanen  1  and conformant planning  rintanen  1 -just to name two relevant examples-have handy qbf formulations.
¡¡in the rest of this paper  after a brief introduction to qbfs and their models  section 1   we present a solver-independent representation for qbf sat-certificates  section 1 . as expected  we are able to describe how to verify them  section 1  before the more complex task of their extraction is addressed  section 1 . we conclude by discussing the implementation of our approach and the future work  section 1 .
1	qbfs and their models
with no loss of generality  we consider qbfs in prenex conjunctive normal form  cnf . they consist in a prefix exhibiting an arbitrary number of alternations of existentially and universally quantified variables  followed by a matrix  i.e. a conjunction of clauses. for example:
 a b c d e f.  b¡Åe¡Åf  ¡Ä  a¡Åc¡Åf  ¡Ä  a¡Åd¡Åe ¡Ä
  a¡Å b¡Å d¡Åe  ¡Ä   a¡Åb¡Å c  ¡Ä   a¡Å c¡Å f ¡Ä	 1   a¡Å d¡Å e  ¡Ä   a¡Åd¡Å e  ¡Ä  a¡Å e¡Å f 
given a qbf f  we denote by fe its matrix  by var  f 
 var  f   the set of existentially  universally  quantified variables in f  and by var  f e    var  f  the set of universal variables preceding  or. dominating  e ¡Ê var  f  in the prefix  we pose ¦Ä e  = |var  f e | . given a cnf matrix fe  the formula fe   l is the cnf obtained by assigning the literal l  i.e. by removing from f each  l literal and each clause containing . this notation is readily extended to sets of literals. a matrix f is satisfied by a set of literals m  written m |= fe  when fe   m is the empty formula.
¡¡the alternations of quantifiers in the prefix guide us to extending this notion of satisfiability from matrixes to qbfs. for example  the satisfiability problem on  1  asks whether for each possible  consistent  combination of literals on a and b there exists a way to choose a literal on c such that for both possible literals over d  two literals on e and f exist such that the resulting set satisfies the matrix. hence  a qbf model is a set of |var  f | functions  each one specifying the literal d e to be chosen  if any  on the existential variable e as a function
¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡ d of the choices on all the universal variables dominating e. to represent all these functions at once we can use a labeled tree  such as the one aside  depicting a model for  1 . if we call universal hypothesis every consistent set of universal literals  or  equivalently  every assignment  u1 = ¦×1 ... un = ¦×n  to the universal variables  with ¦×i ¡Ê b = {1}   we may say  informally  that a tree structure like the one above is a model for a qbf with matrix
fe iff for every universal hypothesis u the set of existential literals collected along the branch individuated by u satisfies fe   u  see  buning and zhao  1¡§   for details .
1	certificate representation
a qbf model can be represented explicitly by employing data structures such as trees or truth tables. or  we may pursue compactness at the expense of managing an implicit representation1 requiring computation to yield values.
¡¡an ideal certificate should be compact  easy to manage  and explicit  easy to verify and query . a successful tradeoff is obtained by employing binary decision diagrams  bryant  1 . we consider their reduced ordered version  robdds  or just bdds henceforth  with complemented arcs. a bdd e representing a total function f u1 u1 ... un  from bn to b is a directed acyclic graph with one root  labeled by f  and one sink node  labeled by  1  . each internal node is labeled by one variable in u = {u1 u1 ...un}  and always has two children  one attached to the outcoming then-arc  the other to the else-arc. the else-arc may or may not be complemented. a unique path from the root to the sink is identified by assigning a value to each variable in u: the then-arc is chosen for variables assigned to 1  the else-arc is followed otherwise. the function f represented by e evaluates to 1 on h¦×1 ¦×1 ... ¦×ni ¡Ê bn iff an even number of complemented arcs is encountered along the path defined by ¦×1 ¦×1 ... ¦×n.
as an example  let us consider the bdd aside  where solid arrows denote then-arcs  while dashed  dotted  arcs are used for regular  complemented  else-arcs. it represents a binary function f a b c  of three binary variables a  b and c. it is  for example  f 1 1  = 1 and f 1 1  = 1. the represented function may be written as f = b ¡Ä  a ¡Å c  ¡Ä   a ¡Å  c . in a set-oriented interpretation  this bdd represents the one-set of f  i.e. the set having f as characteristic function. in our case  it stands for the set {h1 1i h1 1i} where f evaluates to 1.
¡¡the bdds we utilize are ordered and reduced: the same variable ordering is followed along each path  and no two nodes representing the same set exist  so that each function has only one canonic representation. furthermore  the ver-

sion with complemented arcs is such that the set s is denoted by the same node as s  referred to with a complemented arc . the bdd way of representing sets is regarded as symbolic in that it avoids the explicit enumeration of sets' elements in favor of a more abstract  diagram-based way of computing characteristic functions. such representations may be exponentially more succinct than explicit ones  see  wegener  1    and all the operations on the sets/functions they represent  union/disjunction  intersection/conjunction  etc.  can be performed by manipulating the involved bdds  bryant  1 . with a small abuse of notation  we treat bdds as if they were the sets they represent. for example  x ¡Ê e is an element in the subset of bn individuated by e.
¡¡when we manage collections of bdds  canonicity spans over their set of nodes as a whole. this allows the sharing of structural information among diagrams. a bdd in such a set of interconnected diagrams-called a forest-is identified by a  complemented  arc pointing to its root node.
definition 1  qbf sat-certificate  validity  a sat-certificate for a qbf f with var  f ={e1 ... em}  var  f = {u1 ... un}  and ¦Äi=¦Ä ei  is a forest of bdds containing two roots hei+ ei i for each i in  1 m . both ei+ and ei  are defined over var  f ei ={u1 ... u¦Äi}. the certificate

is consistent when  i ¡Ê  1 m  it is ei+ ¡Éei  =  . it is valid for f when for any h¦×1 ... ¦×ni ¡Ê bn the formula
fe u1=¦×1 ... un=¦×n  is satisfied by {ei=s i  ¦×1 ... ¦×¦Äi  i ¡Ê  1 m }  where the functions s i  : b¦Äi ¡ú b are defined as

in essence  a sat-certificate is a compact but explicit representation of the dependencies that have to exist between existential  dependent  and universal  independent  variables in order to satisfy the matrix whichever the universal hypothesis.
lemma 1 if c f  is valid for a qbf f  then f is satisfiable. every satisfiable qbf has at least one valid certificate.
proof sketch. a qbf is satisfiable iff it has at least one model  i.e. iff we find at least one tree-like structure  like the one introduced in section 1   such that for every assignment u =  u1=¦×1 ... un=¦×n  to the universal variables the set of existential literals collected along the branch individuated by u satisfies fe   u. given a consistent certificate c for f  we insert the literal ei into the label of the node reached following the u1 = ¦×1 ... u¦Äi = ¦×¦Äi path iff  and  dually   ei appears in the label iff . by construction  if the certificate is valid according to the notion of validity given in definition 1  the tree-like structure obtained is a model.  a valid sat-certificate for  1  is depicted in figure 1.
1	certificate verification
the first thing we wish to do with a consistent certificate c for f is to verify its validity. we check that by choosing the truth values of the existential variables according to what the certificate suggests  we always satisfy the matrix.
function checkvalidity qbf f  certificate c let var  f  be {e1 ... em}; let var  f  be {u1 ... un};
let	; forall ¦£ ¡Ê f do
 ui =¦×1 ... ui =¦×h 
h
return true;
figure 1: a bdd-based sat-certificate for the qbf  1 .
¡¡an easy but impractical way of checking a certificate would be to check that m produces a satisfying assignment under all the possible universal hypotheses. fortunately  the symbolic nature of the certificate helps us to perform a much more efficient  clause by clause  bdd-based verification. let us use the exclusive or     to construct literals out of variables    v means v when   = 1  and  v when   = 1 .
lemma 1 the algorithm checkvalidity answers true on hf ci if and only if c is a valid certificate for f.
let us consider  for example  the clause  u1 ¡Å e1 ¡Å u1 ¡Å  e1 ¡Å e1 under the prefix  u1 e1 u1 e1 e1. the only relevant universal hypotheses for this clause are those assigning both u1 and u1: all the others immediately satisfy the clause via one of its universal literals. so  it remains to verify that under the assignment  u1 u1  at least one of the three remaining literals in the clause is true  i.e. that every universal hypothesis containing u1 = 1  u1 = 1 falls within the one-set of at least one out of   and . this is a two-step check: first  we collect the universal hypotheses under which the clause is satisfied by some existential literal. then  we check

that all the hypotheses e  in which no existential literal satisfies the clause  assign either u1 = 1  or u1 = 1  or both  so that the clause is satisfied by a universal literal.
¡¡the meaning of a successful verification is twofold: we are ensured that the formula is sat  and that the certificate encodes a model. conversely  the verification fails when either the certificate is invalid or the formula is unsat  we cannot tell right away which circumstance has occurred . validity check is a conp-complete problem  buning and zhao  1¡§  .
1	certificate extraction
for certificate extraction to be symbolic in the same sense as our certificate is  we want it to work on a bdd-based representation of the problem. we describe one such representation  section 1   and show how it relates to certificates  section 1 . then  a two-step procedure is discussed to  a  evaluate the instance  section 1   and  b  construct a certificate on the basis of the steps taken in the evaluation  section 1 .
1	symbolic formulas via skolemization
the skolem theorem shows how to transform any given first order logic  fol  statement f into a skolemized formula sk f  that has two properties:  1  sk f  contains no existential quantifier  and  1  sk f  is satisfiable iff f is satisfiable. existential quantifiers are eliminated by replacing the variables they bind with skolem functions whose definition domains are appositely chosen to preserve satisfiability. in the outer form of skolemization  the function introduced for e ¡Ê var  f  depends on the universal variables var  f e  that have e in their scope  for prenex formulas: all the universal variables to the left of e in the prefix .
¡¡skolemization-based solvers replace the original formula f with the satisfiability-equivalent instance sk f . such instance is no longer propositional. nevertheless  we are able to capture its semantics without exceeding the expressive power of propositional logic  by explicitly managing the truth values of the  interpretation of  skolem terms in each point of their definition domains  as shown in  benedetti  1 .
¡¡the duty we pay is a  possibly  exponential blowup in the size of the problem. bdds come out to be precious in keeping this space explosion problem under control: what we actually manage is a symbolic formula  i.e. a compact bdd-based representation of a propositional instance representing the definability of the set of skolem terms introduced in sk f .
let as denote by ¦·|k the k-bit long prefix of ¦· ¡Ê bn n ¡Ý
k. the notion is extended to sets: i|k = {¦·|k.¦· ¡Ê i}.
definition 1  symbolic formula  a symbolic formula f is a bdd-based representation of a cnf instance. it consists of a symbolic prefix  e1 ¦Ä1 ... em ¦Äm on the variables var f  = {e1 ... em}  with 1 ¡Ü ¦Ä1 ¡Ü ¡¤¡¤¡¤ ¡Ü ¦Äm  followed by a symbolic matrix fe  i.e. a conjunction of symbolic clauses. a symbolic clause ¦£i is made up by a consistent set ¦£ =   1   ei1 ...  h   eih  of literals on var f   and a  bdd represented  subset i of b¦Ä ¦£   ¦Ä ¦£  =. maxl¡Ê¦£ ¦Ä l . the cnf represented by f is called propositional expansion of f. it has variables  and is
.
defined as prop f  = ¡Ä¦£i¡Êfprop ¦£i   where

symbolic formulas inherit the semantics of their propositional expansions  which we also call ground counterparts . noticeably  a consistent set m = { l1 i1  ...   lm im} of symbolic literals satisfies f  m |= f  iff its expansion prop m =¡È l j¡Êmprop  l j   satisfies prop f .
definition 1  symbolic skolemization  the symbolic skolemization symbsk f  of a qbf f with var  f  =
{e1 ... em} is a symbolic formula with prefix  e1 ¦Ä ei  ¡¤¡¤¡¤  em ¦Ä em   having one symbolic clause  l1 ... lh i for each clause ¦« ¡Ê f  where {l1 ... lh} are the existential literals in ¦«  { 1 ei1  ...   h eih} are the universal literals in ¦«  and i = {h¦×i ... ¦×ki ¡Ê bk | j.¦×ij 1=  j}  k = ¦Ä ¦« .
as an example  the symbolic skolemization of  1  is given in figure 1. in essence  a symbolic skolemization f = symbsk f  is a compact representations for a purely existential instance prop f  having the following key property.
theorem 1 for any qbf.
proof sketch. by applying outer skolemization as described in  benedetti  1  we turn the qbf instance f into a sat-equivalent purely universal formula: we substitute every existential variable v dominated by {u1 u1 ... un}   var  f  with a skolem function. for example  the instance  1  with matrix n  is sat-equivalent to
	 a b d. ne sc a b /c  se a b d /e  sf a b d /f 	 1 
then  we propositionally encode the definability of the skolem terms introduced  leveraging a noteworthy feature: they all map bn onto b  for some n ¡Ý 1   hence they are fully specified by 1n boolean parameters  and have a direct cnf representation. for example  if we denote by {sc¦Á¦Â h¦Á ¦Âi ¡Ê b1} the four boolean parameters representing the truth value of sc over hx yi  we obtain for sc a b  the following propositional skolemization sk sc  ¡Ô sc a b :

by replacing each v¡Êvar  f  with sk sv  we obtain sk f 
 sc se sf a b d. ne sk sc /c  sk sd   sk se /e 
where  sc stands for  and similarly for the other functions. this formula is easily turned-clause by clause-into a cnf. by distributing the connectives  removing clauses with complementary literals  and eliminating literals over universal quantifiers  we obtain 1¦Ä ¦£  m clauses out of a qbf clause ¦£ with m universal literals. for example  we obtain 1=1 clauses from the clause a¡Åc¡Åf in  1 :

all the clauses coming out of a given qbf clause mention the same skolem functions. what makes one differ from another are the subscripted indexes. this allows us to write them compactly by representing function names apart from indexes. for example  the four clauses above may be succinctly represented as ¦£i =  c f {1 1}  where i   b¦Ä ¦£  contains one element per clause  and the i-th component of each ¦· ¡Ê i refers to the universal variable ui: once ¦· ¡Ê i is selected  each literal l obtains its own subscript by projecting ¦· onto the subspace related to the first ¦Ä l  components  written ¦·|¦Ä l  . for example  given
¦·=1 it is ¦·|¦Ä c =¦·|1 and ¦·|¦Ä f =¦·|1  hence
. this property allows us to recover the ground meaning of a factored clause through the prop function. the factored representation becomes symbolic as soon as we represent and manipulate sets of indexes via bdds over var  f   thus obtaining the  linear-size  representation
symbsk f .	
¡¡for example  the propositional expansion of the formula in figure 1 yields a cnf instance equivalent to  1 .
1	from symbolic models to certificates
the connection between a symbolic model and a certificate is so close that the former is smoothly turned into the latter. let
.
i m l =¡È l i¡Êmi be the indexes on the literal l mentioned in a symbolic model m.
theorem 1 if m |= symbsk f   then the certificate

with ce+ = i m e   and ce  = i m  e  is valid for f.
 e  f {}¡Ä e {}¡Ä  c {}¡Ä c  f {}¡Ä  c  f {}¡Ä  e  f {}¡Ä  e {}¡Ä  e {}¡Ä e {}

figure 1: symbolic propositional skolemization for  1 .
proof.	the propositional variable
symbsk f  represents  for each i ¡Ê  1 m  and each ¦· = h¦×1 ... ¦×ki ¡Ê bk  k=¦Ä ei   the value the skolem function s i  u1 ... uk   introduced to skolemize ei ¡Ê var  f   assumes under the universal hypothesis  u1=¦×1 ... uk=¦×k . by construction  f embodies the definability of the skolem terms  i.e. all the mutual constraints among  interpretation of  terms that have to be obeyed to always satisfy the matrix. a model m for f is a way to comply with all these constraints at once: s i  ¦×1 ... ¦×k  has to evaluate to 1 if
  and is uncon-
strained otherwise. by comparing the resulting functions
	  1	if h¦×1 ... ¦×ki ¡Ê ce+
¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡ 	otherwise with definition 1  valid certificates  the thesis follows. 
1	evaluating symbolic formulas
we devote our attention to solution-based procedures  biere  1; pan and vardi  1; benedetti  1   as they may be lifted to extract models symbolically. we consider a solver that manipulates symbolic clauses through rules designed to achieve at once on ¦£i the same result ground rules would obtain if applied separately to each clause in prop ¦£i .
  resolution: given two resolving clauses containing the same variable e in opposite polarities  we construct a necessary consequence-called resolvent clause-made up by all the literals from both originating clauses apart from e and  e. for the symbolic version to produce at most one symbolic resolvent per step  we only resolve on variables with the same universal depth as all the clauses in which they appear. the resolvent of ¦£i and ¦£1 on e  with e¡Ê¦£   e¡Ê¦£1  ¦Ä ¦£ =¦Ä ¦£1 =¦Ä e   is1.
	 ¦£   {e} ¡È ¦£1   { e} i¡Éi1	 1 
if either i ¡É i1 =   or ¦£ and ¦£1 share further couples of complementary literals other than e and  e  the resolvent represents an empty set of clauses and is removed.
  subsumption: ¦£i is subsumed by  when all the ground clauses in ¦£i are subsumed by some clause in ¦£1  i.e. when ¦£1   ¦£ and i   i1. under this condition  ¦£i can be removed. in partial subsumption  ¦£1   ¦£ but i 1  i1  the subsumed clause is replaced by ¦£i¡Éi1.
  substitution: we write  l/a j   ¦Ä l  ¡Ü ¦Ä a   to denote the substitution of l¦·|¦Ä ¦Õ  for a¦· for each ¦· ¡Ê j :
	¦£i l/a j =  ¦£ l/a  i¡Éj ¡Ä ¦£i¡Éj	 1 
the rules above establish primitive manipulation capabilities for the solver. it arranges these components into the following higher-level  satisfiability-preserving transformations.
assignment. when  l j is realized to be a consequence of f  i.e.: for all ¦· ¡Ê j   it is prop f  ` l¦·   the formula is simplified to f   l j by assigning  l j   i.e. resolving against   l j and subsuming against  l j .
equivalence reasoning. if the solver discovers a proof that
j
 a   l   i.e.:  ¦·¡Êj   prop f  ` a¦·|¦Ä a  l¦·   it is entitled to simplify f by applying the substitution  l/a j .
redundancy removal. subsumption is applied to eliminate subsumed clauses. this may heavily reduce the burden on the solver  while logical equivalence is preserved.
variable elimination. the clauses containing a variable d are replaced by the set of resolvents of every clause containing d against each clause containing  d  figure 1 . symbolic elimination rules out one symbolic variable  hence all the related ground variables at once.
as far as we are concerned  a solution-based evaluation procedure is an algorithm that produces a  memory and time affordable  sequence of instantiations of the above rules  and guarantees to end up with the empty formula on sat instances  and with a contradiction  an empty clause  on unsat formulas. each step is a back-chaining reduction from a problem f1 to a problem f. hence  a model for the original instance is not directly extracted. rather  satisfiability equivalence guarantees that at each step  should f have a model  than a model for f1 could be  easily  derived.
¡¡this apparent drawback suddenly turns into an advantage. it indeed allows to decouple evaluation from model reconstruction  with almost no overhead for the former and a clear semantics for the latter. the two meshes of the chain are connected through an inference log  produced by the solver  and subsequently read by a model reconstructor.
definition 1  inference log and trace  an inference log is a list of entries  each one describing an instantiation of one of the above sat-preserving transformations. it contains:
  hassign l ji  for an assignment  l j .
  hsubst a l j gi  for a substitution  l/a j   where g is the set of clauses containing {a  l} or { a l}.
  helim d g+ g i  for the elimination of d  where g+ and g  are the sets of clauses containing d and  d.
let us denote with i f op  the formula obtained by applying to f the transformation described by the entry op. an inference log l =  op1 op1 ... opt  induces an inference trace  f1 f1 ... ft  where fi = i fi 1 opi   with f1 = f. a log such that ft is empty is called sat-log for f.
clearly  a sat-log for f exists iff f is sat. for example  the reader may verify that figure  1  depicts a sat-log for  1 .

figure 1: moving from f1 to f by eliminating the variable d.
1	inductive model reconstruction
once a sat-log is known  the reconstructor comes into play. it trusts the solver about the log being a sat-log  and parses it backward  reasoning by induction on the number of entries:
base case. at the end of the inference trace we find the empty formula ft  satisfied by an empty model mt.
inductive case. given a model mi for fi  the reconstructor computes a model mi 1 = r mi opi  for fi 1 by reasoning on how opi turned fi 1 into fi.
this leads to a model m1 for f  hence to a certificate for f  once the function r has been properly defined. let us denote
       . by i f =¡È¦£i¡Êfi the set of indexes mentioned in f.
theorem 1 when applied to any sat-log for f  the inductive model reconstruction procedure defined by the following function r computes a model m1 for f1 = f.
opr m op hassign l iim ¡È { l i}hsubst e l i giexts m ¡È { e i¡Éi m l    e i¡Éi m  l }helim e g+ g ime ¡È { e i g+ me    e i g  me } 
where ext
s m =. m ¡È  e i g m   and me=. exte m   with
 ext m¡È v i  if  h¦£i ¦£1i ¡Ê g+ m¡Ág  m
	  	i	
exte m =	with e1=v v¡Ê¦£¡É¦£1  i ¡É i1= 
  m  otherwise
proof. for each op we show that r m op  |= f1  working under the inductive hypothesis of knowing a model m for  is the empty formula .
¡¡assignment. f  m =  f1   l i  m = f1   { l i}¡Èm  is empty  hence { l i}¡Èm satisfies f1.
¡¡equivalence. let  where no clause in mentions e  all the clauses in mention e but not l   l; all the clauses in contain both e and l  or  e and  l   and the clauses in f1  contain e and  l  or  e and l . m satisfies  hence it satisfies with no modification. it also satisfies provided we mirror on e the assignments collected so far over l  by adding  e i¡Éi m l  and   e i¡Éi m  l . in general  the resulting model m+ = m ¡È { e i¡Éi m l    e i¡Éi m  l } satisfies all the clauses in f1 but some in: by construction  such clauses failed to pass to f because is empty  clauses satisfied by complementary e/ l literals . to satisfy the  possibly  nonempty remaining set g   m+ of
#1#1#1#1#1hsubstitute f  e {1} { e f {1 1} 
             e  f {1 1}}i hassign  e {1 1}i hresolve f { f {1}  c f {1}  e f {1}} 
           {  c  f {1 1}   e  f {1}}i hassign e {1}i hresolve c { c {1}} {  c {1}}i
figure 1: a sat-log that solves the qbf  1 .
clauses  we extend m+ by applying the exts function: it adds an arbitrary truth assignment to all  and only  the indexes for e mentioned in g   m+  i.e. it adds  e i g m+ .
¡¡variable elimination. we focus on the insightful groundcase proof  see figure 1 . the extension to the symbolic case is a matter of notation. suppose that the model m for f satisfies at least one clause of each h¦£+i  ¦£ j i couple  i ¡Ê  1 n  j ¡Ê  1 m . this implies that it either satisfies the whole set   or the whole   or both.
 hence  we are free to choose a literal on d in such a way to satisfy f1: m ¡È{a} satisfies f1 whenis non-empty  is non-empty  while m itself suffices when both sets are empty. now  we show that every model m for f either satisfies at least one clause in eachcouple  or can be extended to a model exte m  that fulfills this property. the former case happens  at least  when no resolvent clause has been satisfied by complementary literals during variable elimination. in this case  f contains exactly m n resolvents  one for each couple in g+d ¡Ág d . every model of a resolvent is valid for at least one of its resolving clauses  hence the thesis. now  suppose that the couple h¦£+i  ¦£ j i is not satisfied by m. it follows that m doesn't model the resolvent of ¦£+i and ¦£ j   hence such resolvent failed to pass to f: it was satisfied by complementary literals on some still unassigned variable v 1= d. a literal on v can be arbitrarily added to the model under construction to satisfy either ¦£+i or ¦£ j  no conflict arises: v would have not appeared as unassigned if involved in any past-w.r.t. the solver's standpoint-inference step . this extension of m to exte m  is repeated until no unsatisfied couple is left.	
¡¡examples: m1 = {a  b c} is a model for f1 =   a¡Åc ¡Ä  a¡Åb¡Å c  ¡Ä   a¡Å b  because m = {a  b} is a model for f = f1  c =  a¡Åb ¡Ä  a¡Å b . m1 = { a b c} is a model for f1 =   a¡Åc ¡Ä a¡Åb¡Å c ¡Ä  a¡Å b  because m = {b c} is a model for f1  c/a  = c¡Ä b¡Å c ¡Ä c¡Å b . in figure 1  the assignment m1 ={a b c} satisfies f and also f1: d is left unassigned. the model m1={a  b} satisfies g+d but not g d   hence m1=m1 ¡È { d} is constructed to satisfy f1. the couple is untouched by m1={a}  so no truth value for d helps. but the resolvent of  and  was satisfied by complementary literals on b  so we construct exte m1 = m1 ¡È {b}  then satisfy f1 with m1 = exte m1  ¡È { d} = {a b  d}. as a complete example  the reader may verify that by performing inductive model reconstruction according to the rules given in theorem 1 over the sat-log in figure 1 for the symbsk f  in figure 1  a model is extracted which through theorem 1 produces the sat-certificate in figure 1.
1	discussion and conclusions
we presented a solution to an open question on qbfs  namely the problem of representing  verifying and extracting their sat-certificates. the importance of such solution is twofold: it gives means of conveying solver-independent evidence of satisfiability  and enables the extraction of precious information from certified formulas. the former feature can be used  for example  to effectively test the decisions of qbf solvers. the latter contribution is valuable to applications  in that a certificate is needed to exemplify a definite scenario in which qbf-encoded problems reveal their satisfiability. for example  a sat-answer suffices to know that at least one winning strategy exists in a qbf-encoded two-player game  but it takes a certificate to exhibit an actual strategy.
¡¡stand-alone certificates convey no self-contained semantics  as the meaning of each variable is a piece of information held by the  encoders . to allow semantics' owners to interrogate their own qbf models  we have implemented a solver/verifier suite  benedetti  1b; 1a  to produce  verify  dump to file  in open formats   and query certificates.
¡¡this implementation is helping to shed light on further open questions on qbfs. for example: is qbf certification impractical  let us define the certification of f  impractical  when it is affordable to solve f while it is not feasible to memorize and/or verify any certificate c f . our approach suggests that impracticality is not an issue. for instance  the certificates in table 1 are well within the manipulation capabilities of current machines  while the formulas they certify are hard for present solvers1. another crucial question we are enabled to address is the following: given a certificate c for f  how much in practice the trio hf c verifyi improves on the couple hf decidei as a means to prove that f is sat  metrics such as the time ¡¤ space product will be used to precisely compare the two strategies. our results already suggest that the improvement is quite large  as exemplified in table 1. we observed a surprising phenomenon: the time taken to reconstruct a model may overcome the time needed to solve the instance. this is rather unusual when compared  for example  with search-based sat reasoning  where a model is extracted with no overhead on the satisfiability decision. conversely  we have not yet observed an expected phenomenon: checkvalidity would operate in polynomial time should we employ a constant-time bdd oracle. the non-polynomiality of verification stems from the size of the forest of bdds  which should grow exponentially for some parametrically scalable family of instances. this unfavorable phenomenon doesn't show up in table 1: certificates scale up polynomially with instance size. these effects and upper bounds on the certificate size will be further investigated.
¡¡we showed how to extract certificates using a particular class of qbf solvers  the skolemization-based ones . however  the bdd-based representation we employ is solverindependent. it comes out that not only the mere representation but also the technique for constructing certificates can be lifted to work with other families of qbf-solvers. the
instance	 	 	ts	tr	tv	|l|	|c|
adder-11.1.1.11 ¡¤ 1adder-11.1.1.11 ¡¤ 1adder-11.1.1.11 ¡¤ 1adder-11.1.1.11 ¡¤ 1adder-11.1.1.11 ¡¤ 1table 1: a family of qbf encodings with      alternation. we report: the number of existential     and universal     variables  the time taken to solve/reconstruct/verify  ts tr tv   the size of the log  |l|  number of steps  and of the certificate  |c|  number of nodes .
key ingredient stays the same: inductive model reconstruction detached from instance evaluation  with an inference log in between. what changes is the kind of information recorded in the log  and the way it is to be interpreted .
¡¡we are extending our technique towards solvers based on  1  non-symbolic q-resolution   1  sat reasoning  and  1  symbolic/non-symbolic dpll-like branching reasoning. the ultimate goal is to build a qbf model reconstructor able to extract certificates by interpreting generic qbf inference logs1  whichever the evaluation strategy adopted to solve the instance  including hybrid strategies such as the one leveraged by the qbf solver skizzo  benedetti  1b  .
acknowledgments
we thank amedeo cesta and gigina aiello for their comments on how to improve the organization of the paper  marco cadoli for helpful discussions on technical issues  and the anonymous referees for their precious remarks. 