ion hierarchy to represent the set of disease types and finding types  with information and procedures attached at different levels of generality. 
  the use of krl-o triggers to implement the conceptual  triggering  of potential diagnoses on the basis of having relevant symptoms described 
  the use of signals to provide run-time monitoring of what the system was doing as it generated new hypotheses and evaluated them 
  a direct encoding of the declarative  slices  of rubin's version into the declarative forms of krl-o. this included extensive use of the  using  descriptor  a declarative conditional  to explicitly represent the decision trees in the units for diagnosing different conditions 
there were four major kinds of representational objects in the system. 
   elementary hypotheses  which corresponded to the  slices  of rubin's thesis; these were named after the disease  c.g glomerulitis or renal infarction  the data structure was intended to represent. elementary hypotheses had descriptions in slots to indicate such things as likely symptoms  links to other elementary hypotheses that might be related  and how to evaluate how well the patients symptoms would be accounted for by a diagnosis of this disease. 
   elementary hypothesis instances  were data structures created for each diagnosis the system decided might account for the presented symptoms; these contained pointers to the findings that suggested the diagnosis  and a pointer to the elementary hypothesis representing 
the disease of the diagnosis. it also contained values for how well the diagnosis accounted for the s mplomsf obtained by applying the evaluation information represented in the elemental'  hypothesis to the specific details of the elementary hypothesis instance. 
   findings  were units for specific symptoms  facts  hisloiical inhumation  phvstcal examination data  or lab data  e.g.. /¡ö'ever  hcnutinriii  or liinpsy   a finding was mostly a hook on which to hang pioccdura  information about what to do when the patient exhibited soinel.hin  abnormal with respect to the particular kind of finding. 
  finding instances were the input to the system  having a structure similar to that rubin suggested in her thesis  having slots for such things as finding  duration  severity  and normality. there were also further specified finding instances such as symptom instance. 
the system worked essentially as follows. a unit might be described by: 
 a symplomlnstance with main concept = hematuria presence =  present  severity =  yross  time -  a titmtoint with direction z  past  magnitude =  a quantity with 
unit -  days  number = 1    
a 	whenknown 	trigger 	on 	the 	presence 	slot 	of 	the 
symptom instance prototype would be set off; examination of the specific description caused this entity to be described also as:  ii symptoinhistancc with normality =  abnormal   further triggers and traps might result in the creation of new elementary hypothesis instances  according to the information found in the description. after all the information propagation activity  each of the currently active elementary hypothesis instances would be evaluated based on information found in the corresponding elementary hypotheses. based on the evaluation  the status of the elementary hypothesis instances might be changed to reflect possible dispositions of the hypothesis such as acceptance  rejection  or alteration. 
the indexing facility was used to facilitate operations such as obtaining a list of all the hypotheses activated by a finding. funclionals and tomatch triggers on prototypes were defined to handle special time-related matches to enable the system to tell  for example  that  1 days ago  is more recent than  1 year ago  or that  1 hours  is the same as  1 days . signal tables were used locally to govern the handling of error-like occurrences and globally to effect trace and printout; different degrees of detail were specified by use of several signal tables  and it was thus quite simple to change modes by pushing or popping a table. the agenda was used for organizing the flow of control in a manner similar to that described for the cryptarilhmalic program. the built-in triggering mechanisms provided the means for a very natuial modeling of the kind of medical reasoning discussed in rubin's thesis. 
1. 	the problems 
as we had hoped  these projects pointed out many ways in which krl-o was deficient or awkward. people were able to complete the programs  but at times they were forced into ad hoc solutions to problems which the language should have dealt with. the problems can be grouped as: 

knowledge repr.-1: robrow 1 

  basic representation problems -- ways in which it was difficult to express intuitions about the semantic and logical structure of the domain 
  difficulties in manipulating descriptions explicitly 
  shortcomings in the matcher 
  the awkwardness of the t.isr-krl. interface 
  facilities which should have been available as standardised packages 
  infelicitous syntax 
  cramped address space 
due to the embedding of krl.-o in in'm-.rl.isi'  none of these problems were fatal  e'ven with the difficulties  we found it possible to write complex programs rapidly  and to experiment with interesting representation and processing strategies. this list also does not include the social and organizational problems which are bound to infect any effort of this nature. everyone on the project exhibited heroism and stoicism  persisting in their programming without a manual and in a rapidly evolving language which kept slipping out from under the programs almost as fast as they could be modified. 
basic representation problems 
kri.-o embodied a number of commitments as to how the world should be represented. some of these seemed intuitively justifiable  but did not work out in practice. others weie too vague to implement in a way which seemed satisfactory. 
the categorization of units: 	lach unit had a category lype 
 as described in bohrow and winograd  l  1  pp 1-j1   of individual  manifestation  basic  specialization  or abstract 
category. this was based on a number of intuitions and experiments about human reasoning  and on the belief that it would facilitate mechanisms such as the quick rejection of a match if there was a basic category disagreement. in practice  these distinctions turned out to be too limiting. in many of the hierarchies for speciali/ed domains  such as medicine  there was no obvious way to assign basic. specialization  and abstract. in dealing with units describing events  the notion of manifestation  va  not precise enough lo be useful. it was generally felt that although the concepts involved were useful  they had been embedded at too low a level in the language. 
viewpoints: one of the major issues in developing kkl was the desire to have facilities for  chunking  knowledge into relevant units. this proved to work out well in most cases  but there was an additional dimension of organization which was lacking. for many purposes  it is useful to combine in a single unit information which will be used in several contexts  and to associate with each piece of the description some identifier of the context  or viewpoint  in which it will be used. in the natural language programs  it seemed natural to classify descriptions associated with words and phrases according to whether they related to the structure of syntactic phrases  or to meaning. in the physiology sketch  there were clear places where different viewpoints  e.g. looking at the form of an organ or looking at its function  called for using different information. there were two primitive mechanisms for doing this factoring in kri.-o -- attaching features to descriptors  and embedding information in contingencies. 
both were used  but proved clumsy and felt ad hoc. 
the relation between prototype and concept: krl is built on the assumption that most of the information a system has about classes of objects is stored in the form of  prototypes  rather than in quantified formulas. in general  this proved to be a useful organizational principle. however  there were cases of complex interactions between instance and prototype. in the medical domain  for example  a disease such as acuterenallailure could be thought of as an instance of the prototype for disease but could also be thought of as a prototype for specific cases of this disease. there are a 
number of issues which arise in trying to represent these connections  and although kkl.-o did not make obviously wrong choices  it also did not make obviously right ones. in general  we seem to have been hoping that too many consequences would just naturally fall out of the notation  when in fact they take more explicit mechanisms. 
further specification hierarchies: in simple network or frame systems  see  for example goldstein and roberts  1  there is a natural notion of hierarchy  in which each descendant inherits all of the slots  or cases  from its parent. thus  if a  give is a fuither specified act then it has a slot for actor as well as its own slots for object and recipient. in a system based on multiple description  the inheritance of slots is not as suaighlfoiward. tins is especially tine when there is an attempt to do merlin-like reasoning and use perspectives to  view an x as a y . the basic inheritance mechanism in kki.-o does not include automatic inheritance of slots. this is vital for cases in which there are multiple descriptions using the same prototype units. however  it makes it awkward  though possible  to prog.ram the cases where the slots are to be inherited simply. therefore  we included a mechanism for  further specification  which allowed a unit to inherit slots  along with their attached procedures  from a single parent. this was not fully implemented into the system  and was a dangling end in the implementation. 
the factoring of context-dependent descriptions: one major design decision in krl was the use of an object-factored data base  rather than a context-factored one. the unit for a 
particular object contained all of the different contingencies representing the facts about it in different worlds. this proved quite successful; however  when combined with the kind of descriptions provided by mappings  another issue arises. using the example of the cryptarithmetic units given earlier  consider the problem of representing what is known about a column in the addition problem if worlds are used to represent hypothetical assignments. imagine that we know that in the unmarked global world  column i is an instance of column  with values for toplettcr  bottonilcttcr  etc. if in a hypothetical world 1  in which some value is assumed for a letter  we infer that its sum is 1  we want to add a contingent descriptor. this could be done in two ways: 
 columni uni i individual 
 sclf | 	 a column with topleter= 	a 
..  
 during world i then  a column w i t h sum = 1  }   j 
  column i unit individual 
 sclf {  a column with topl.cllor s a sum =  during world i then 1  ... } ! 
these are equivalent at the semantic level  and the first was chosen in the initial implementation -- all factoring into contexts was done at the top level of slots. however this proved to be tremendously clumsy in practice  since it meant 

knowledge rfepr.-1: robrow 

that much of the information was duplicated  especially in cases of recursive embedding. this was exacerbated by the fact that features  see bobrow and winograd  p. 1  demanded factoring as well  and were used for a variety of purposes  such as the viewpoints mentioned above. there was a reimplementation midway in the life of krl -    in which the basic data structures were changed to make it possible to merge as much of the shared informal ion as possible. there are a number of difficult tradeoffs between storage redundancy  running efficiency  and readability when debugging  and we never found a fully satisfactory solution within kki.-o. 
data structure manipulation 
kkl-o was not a fully declaralively recursive language in the sense that machine language and pure i isi  are. it was not possible to write krl-o descriptions of the krl-o structures  e.g. units  slots  descriptions  themselves  and use the descriptive mechanisms to operate on them. instead  there were a number of lisp primitives which accessed the data structures directly. people ran into a number of problems which could be solved by explicit surgery  i.e. using the lisp functions for accessing kkl data structures  and rplaca and rplacd  but which gave the programs a laint of ad hoccry and overeomplexity. as an exercise in using krl representational structures  brian smith tried to describe the krl data structures themselves in krl-o. a brief sketch was completed  and in doing it we were made much more aware of the ways in which the language was inconsistent and irregular. this initial sketch was the basis for much of the 
development in krl-1. 
deletion of information: 	one of the consequences of seeing 
kki-structures as descriptions  rather than uninterpreted relational structures was a bias against removing or replacing structures. descriptions are by nature partial  and can be expanded  but the most natural style is to think of them as always applicable. thus  for example  if  a slot was to contain a list  say  the list of digits known to have been assigned in a cryptarithmetic problem   the descriptor used in an instance was the items descriptor  which is interpreted as enumerating some  but not necessarily all  items in a set. if the description of some object changed over time  then it was most naturally expressed explicitly as being a time-dependent value  using the contingency descriptor. there are some deep representational issues at stake  and the intuition of thinking of descriptions as additive was  and still is  important. however  it led to an implementation which made it impossible to delete descriptions  or remove items from lists  without dropping to the level of lisp manipulations on the descriptor forms. this caused problems both in cases where values changed over time  and in cases where the programmer wanted the program to delete unnecessary or redundant descriptors in order to gain efficiency. although deletion and replacement were doable  and often done   they went outside 
of the krl semantics in a rather unstructured way. 
explicit manipulation of descriptions: for some of the programs  it was useful to have parts of the code which dealt with the descriptions themselves as objects. for example  in the cryptarithmetic program  the set of descriptions being added to the value slot of an individual digit could be thought of as a set of  constraints   and used in reasoning. one might ask  what unused digits match all of the descriptors accumulated for the value of the letter a . this is quite different from asking  which unused digits match the description 'the value of letter a' . similarly  in the implementation of winston's program  the descriptions themselves needed to be thought of and manipulated as relational networks. the ability to use descriptions in this 
style gave power in writing the programs  but it had to be done through lisp access of the descriptor forms  rather than through the standard match and seek mechanisms. 
problems with the matcher 
specifying the match strategies: the matcher in krl-1 took a krl-o description as a pattern  and matched it against another description viewed as a datum. for each potential descriptor form in the pattern  there were a set of strategies for finding potentially matching descriptions in the datum. the ordering of these named strategies  and the interposition of special user-defined strategies was controlled by use of the signal mechanism. this was designed to give complete flexibility in how the match was carried out  and succeeded in doing so. many specialized match proceses were designed for the different projects. however  the level at which they had to be constructed was too detailed  and made it difficult to write strategies which handled wide ranges of cases. the strategies were mostly reflections of the possible structures in the datum  and did not deal directly with the meaning of the descriptors. this led to having to consider all of' the possible combinations of forms  and to programs which did not function as expected when the descriptions contained different  even though semantically equivalent  forms from those anticipated. 

control of circularities: in using matching as a control structure for reasoning  it is often useful to expand the match by looking at the descriptions contained in the units being compared. consider the units: 
 give unit basic 
 self  a receive with received*  ihe given  receiver =  the receiver  river    the giver    
 giver  a person   
 receiver  a l*erson   
 given  a physicalobject    
 receive unit basic 
 sclf  a give with given*  the received  receiver =  the receiver  giver *  the giver    
 giver  a person   
 rcccivcr  a person   
 received  a physic ioi jcct    
 event 1 unit individual 
 seir  a give with giver = jane receiver = joan 
given =  a hummer    
if asked whether the pattern  a receive with received =  a hammer   matches lvent1  the rnatchcr needs to look in the unit for give in order to see that every  give is indeed a receive  and to match up the slots appropriately. however  this can lead to problems since descriptions in units could 

knwledge repr    1 : 	bohrow 
1 

easily be self-referential  and mutually cross-referential. in a slightly more complex case  the matcher could try to match a  ;ive by looking at its definition as a receive  and then transform that to a give  and so on. some of the early match strategies we developed fell into this trap and looped. the simple solution that was adopted to limit such circular expansion was to adopt a depth first expansion policy  and to limit the total depth of expansion  recursion through definition . this obviously works both in this case  and to limit arbitrarily large non-circular searches. in the limited data bases we used  it never caused a match to be missed when the programmer expected it to be found. but it is a crude device which docs not provide adequate control over search. 
inefficiencies due to generality: since the matcher was designed to allow a wide range of stiallies  a fairly large amount of processing was invoked tor each call. often  the programmer wanted to check for the direct presence of a certain descriptor  and to avoid the overhead  dived into lisp. thus  instead of writing: 
 match .'i vent 1 
' a dive with giver - junr  
                 simple strusture match table it was possible to write: 
 f.q jane 
 gctlfem   .elfillcr 'giver 
 get perspective 'give 
 getslot 'self event 1      
given that the simplestructurematchtable caused the matcher to look only at direct structural matches  the two forms were equivalent  and the second avoided much of the overhead. many problems arose  however  in cases where later decisions caused the description form to be different  for example  embedded in a contingency  but to reflect equivalent information. 
problems in the interface between kkl and i.isp 
one of the major design decisions in krl-1 was the use of ! isp for writing procedures  rather than having a krl programming language. this was viewed as a temporary measure  allowing us to quickly build the first version  and work out more of the declarative aspects before trying to formulate a complete procedural language in the following versions. a number of awkward constructs resulted from the need to interface lisp procedures and variables to the krl environment. 
limited procedural attachment modes: only the simplest forms of procedural attachment were implemented. thus  for example  there was no direct way to state that a procedure should be invoked when some combination of slots was filled into an instance. procedures had to be associated with a single condition on a single slot. it was possible to build more complex forms out of this by having a trigger establish further triggers and traps  there are examples of this in the unit for column given above   but this led to some rather baroque programming. 
communication of context: when a trap or trigger was invoked  the code associated with it needed to make use of contextual information about what units were involved in the invocation and what state the interpreter was in  for example in the use of hypothetical worlds . this was done simply by adopting a set of i isp free variables which were accessible by any piece of code  and were set to appropriate values by the interpreter when procedures were invoked. this approach was adequate in power  but v/eak in slrucluie  and a number of the detailed problems which arose in the projects grew out of insufficient documentation and stability of what the variables were  and what they were expected to contain when. 
unstructuredness of procedure directories: the notion of having a  signal table  containing procedural variables was a first step towards breaking out of the normal hierarchical definition scheme of lisp. the intention in developing a kri. procedural language is to develop a set of structured control notions which make it unnecessary for the programmer to fill in the detailed responses to each possible invocation. in the absence of this  krl-o signal tables had much the flavor of machine code. a clever programmer could do some striking things with them  as in their use in sam for controlling language analysis and generation   but in general they were hard to manage and understand. 
underdeveloped facilities 
the krl overall design  see bobrow and winograd  p. 1  involved a series of  layers  beginning with the primilive underlying system and working out towards more knowledge-specific domains. part of the ability to implement and lest the language so quickly came from deferring a number of problems to higher layers  and letting users build their own specialized versions of pieces of these layers as they needed them. in most cases this worked well  but there were some areas in which a certain amount of effort was wasted  and people felt hampered by not having more general facilities. 
sets and sequences: krl-o provided only three primitive descriptors  items  allltems  and sequence  for representing sets and sequences. notions such as subset  position in sequence  member of set  etc. all had to be built by the user out of the primitives  everyone needed some of them  and it became clear that a well thought out layer of standard units and procedures would have greatly simplified the use of the language. 
indexing schemes: the index mechanism built into krl-o was based on simple collections of key words. it was assumed from the beginning that this was to be viewed not as a theory of memory access  but as a minimal primilive for building realistic access schemes. one of the projects  i-low  attacked this directly  but the rest stuck to simple uses of indexing  and did not explore its potential in the way they might have if a more developed set of facilities had been provided initially. 
scheduler regimes: as with indexing  the scheduler mechanism of krl-o was intended primarily as a primitive with which to build interesting control structures which explored uses of parallelism  asynchronous multi-processing  etc. the only structuring was provided by the use of a 
multi-layer queue like the category types discussed above  it was an attempt to embed some much more specific representation decisions into a system which in most places tried for generality. it was not restrictive  since the system made it possible to ignore it totally  allowing for arbitrary manipulation of agenda items. however  because it  and no other scheme  was built in  it tended to be used for problems where other regimes would have been interesting to explore. notation 
the krl-o notation was strongly lisp-based  using parenthesization as the primary means of marking structure. 

knowledge repr.-1: bobrow 1 

this made it easy to parse and manipulate  but led to forms which were at times cumbersome. this was especially true because of the use of different bracketing characters         {}         for descriptors  descriptions and slots. at times a unit would end with a sequence such as  } } }   . there was one simplification made during the course of the implementation  allowing the description brackets   { }   to be omitted around a description containing a single descriptor. the examples in this paper use this convention. in addition  better notations were needed for expressing sets and 
sequences  and were explored in the kinship project. 
limited address space 
one of the shortcomings which most strongly limited the projects was in the implementation  not the basic design. intp.ri isp is a paged system  based on a virtual memory which uses the full 1 bits of the pdp-1 address space. the philosophy has always been that  with some care to separate working sets  system facilities could grow to large sizes without placing extra overhead on the running of the program when they were not being used. this has led to the wealth of user aids and facilities which differentiate iniirusp from 
other t isp systems. 
as a result  more than hall of the address space is used by the in ii rl isp system itself. the kpl o system added another quarter to this  so only a quarter of the space was available for user programs  including program storage  data structure storage  and working space . both of the extended systems  sam and medical  quickly reached this limit. this resulted in cutting back the goals  in terms of the number of stories and questions handled by nam  and the amount of the sample diagnosis protocol handled by medical   and also led the programmes to put a good deal of effort into squeezing out maximal use of their dwindling space. some designs were 
sketched for providing a separate virtual memory space for krl data structures  but their implementation was put off for later versions  since the lessons learned in using kp.l -o within i he space limitation were quite sufficient to give us direction for kri.-i. 
1. current directions 
the projects described above were completed by the end of summer 1. since that time  we have been primarily engaged in the design of kkl-i  and as of this writing  june 1  1  are in the midst of implementing it. the development has involved a substantial shift of emphasis towards semantic regularity in the language  and a formal understanding of the kinds of reasoning processes which were described at an intuitive level in the earlier paper. much of this has been the result of collaboration with brian smith at m.i.t  who is developing a semantic theory  called krs for knowledge representation semantics  which grew out of attempts to systematize and understand the principles underlying systems like krl 
the new aspects of krl-l include: 
  a uniform notion of meta-description which uses the descriptive forms of krl-l to represent a number of things which were in different ad hoc forms in krl-o. the old notions which are covered include features  traps and triggers  index terms  and a variety of other detailed mechanisms. the emphasis has been on providing a clear and systematic notion of how one description can describe another  and how its meaning can be used by the interpreter. a number of the problems related to the manipulation of description forms are solved by this approach. 
  a more structured notion of the access and inference steps done by the interpreter. the interpreter is written in a style which involves operating on the meaning of the forms  rather than the details of the forms themselves. this makes possible a more uniform framework for describing matching and searching procedures  and the results they produce. it allows the language to be described in terms of a clear semantics  see hayes  1 for a discussion of why this is important . we expect it to make the development of 
complex match and seek processes much easier. 
  a notion of data compaction which makes it possible to use simple data record structures to stand for complex 
descriptor structures  according to a set of declarations about how they are to be interpreted. this enables the system to encode all of the internal structures  e.g. the structure which represents a unit  in a form which can be manipulated as though it were a full-fledged description. 
  a compiler which converts simple match  seek  and describe expressions into corresponding intlriisp record structure manipulations  reducing the overhead on those instances of these processes in which only simple operations are to be done  tins should make it possible to preserve efficiency while writing much more uniform code  with no need to use explicit i.isp manipulations of the structures use of the notions of compiling and compaction allows the conceptually correct but notaiionally expensive use of uniform metadescription to be supported without excessive running cost in the common cases. 
  a uniform notion of system events which allows more general kinds of procedural attachment  and includes traps  triggers  and signals. also  by including much of the lntfrlisp interface in description form  it has become more uniform and understandable as well. 
  a simplified syntax  in which indentation is used to express bracketing  eliminating the need for most parentheses. it also uses  footnotes  for attaching meta-descriptions  and has simple set and sequence notations. 
  simplified notions of categories  inheritance chains  and agendas  which avoid some of the specific commitments made in kri.-o. 
  expanded facilities for sets  sequences  scheduling  time-dependent values  category hierarchies  matching information and multiple-worlds. these are all built up out of the simpler  uniform facilities provided in the kernel  but they represent a substantial body of standardized facilities available to the user. 
we are currently exploring a number of different solutions to the address space problem. until lisp systems with a larger address space are available  some sort of swapping mechanism will be necessary  but we see this as a temporary rather than long-term problem. 
knowlph e repr  	ro.brow 
1 the cycle of testing on krl-l will be similar to the one described in this paper  but with an emphasis on a smaller number of larger systems  instead of the multiple mini-projects described above. we feel that with krl-t  we explored a number of important representation issues  but were unable to deal with the emergent problems of large systems. issues such as associative indexing  viewpoints  concurrent processing  and large-scale factoring of knowledge can only be explored in systems large enough to frustrate simplistic solutions. several programs will be whiten in krl.-i  on the order of magnitude of a doctoral dissertation project. current possibilities include: a system for comprehension of narratives; a system which reasons about the dynamic slate of a complex nuilti-process program  and interacts with the user about that slate; and a travel arrangement system related to  it's  bobrow et. al.  1 . current plans include much more extensive description and documentation of the system than was the case with kri.-o. 
we do not view krl.-i as the final step  or even the next-to-last step in our project. in bobrow and winograd  1  pp. 1    we discussed the importance of being able to describe procedures in kki. structures. ouri plan at that time was to design a comprehensive programming formalism as part of krl.-l. in light of the shift of emphasis towards better understanding the aspects which we had already implemented  we have postponed this effort for later versions  still considering it one of the major foundations needed for a full kkl system. there remains the large and only vaguely understood task of dealing in a coherent descriptive way with programs and processes. it is likely that to develop this aspect will take at least two more cycles of experience  and as we learned so well with kri-o  there is always much much more to be done. 
