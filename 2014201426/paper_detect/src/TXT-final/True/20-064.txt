 
     agents who operate in complex environments must often construct plans on the basis of incomplete knowledge. in such situations  the successful agent must incorporate into his plans actions which obtain information. these plans are intrinsically sketchy to begin with and become more specified as the agent proceeds through his plan. a theory which allows for such flexible planning will have to provide solutions to two problems:  1  how can an agent reason that he knows how to perform an action   knowledge preconditions problem for actions  and  1  if an agent must construct an underspecified plan due to incomplete knowledge  when can we say that he can successfully execute his plan   knowledge preconditions problem for plans  
this paper provides solutions to both these problems. 
we develop a robust and highly expressive theory of action and planning which allows for actions of varying granularity  primitive as well as complex acts  multi-agent plans  and partially specified plans. we demonstrate that this theory lends itself in a natural manner to solutions to the knowledge preconditions problems. 
1. introduction 
     an agent who operates in a complex environment must often construct plans on the basis of incomplete knowledge. agents frequently don't know detailed procedures for the tasks they set out to accomplish. they likewise generally fail to keep up with a piece of information that is constantly changing  such as the location of a moving object. these gaps in knowledge mean that an agent may not have enough information to do the task that he wishes to perform  or to draw up completely detailed plans as he starts the planning process. consider  for example  an agent who enters a chemistry lab for the first time and is asked to neutralize an acid. it is likely that he will not be able to perform the task. 
moreover  he cannot even completely specify a simple plan such as: 
1  ask a friend to tell him the procedure p 
1  friend tells him p 
1  perform p  that is  neutralize the acid. 
both 1  and 1  will be unspecified at the start of the plan  since the agent doesn't know p. in particular 1  will remain unspecified until it is completed. 
     agents who function well in complex environments must be able to construct and execute plans despite their lack of knowledge. in particular  they should be able to successfully plan to get the information that they need to perform specific actions. an intelligent agent  for example  should realize that the above plan for neutralizing the acid is a rea-
sonable one  while a plan such as 
1  swim the english channel 1  neutralize the acid makes no sense at all. 
     a theory that allows for such flexible planning will have to provide solutions to at least two problems. firstly  it must explain under what circumstances an agent knows how to perform an action. we call this the knowledge preconditions problem for actions. secondly  even if an agent does not know how to perform an action  it must explain how he can execute a plan that gets the action done. we call this the knowledge preconditions problem for plans. 
     in this paper  we develop a flexible and expressive theory of action and planning  and present solutions to these two problems. 
1. previous work 
     most ai planners have ignored both of the knowledge preconditions problems. this is true both of classic plannine programs such as ops  ernst and newell 1  and strips  fikes and nilsson 1  as well as more recent planners such as noah  sacerdoti 1   non-lin  tate 1   and tweak  chapman 1 . the theories underlying these planners have all implicitly assumed that agents always have complete knowledge; planning thus reduces to some sort of search through a pre-packaged list of action operators  pre-conditions  and post-conditions. 
     mccarthy and hayes  were the first to argue that an agent does in fact reason about his ability to perform an action  thus addressing themselves to the first of the knowledge preconditions problems. they suggested writing down explicit knowledge precondition axioms for each action  so that a planning program could reason that it knew how to do an action if the relevant knowledge precondition axioms were true. this proposal however  fails on at least two counts:  1  it leads to an explosion of axioms  a large search space  and thus unacceptably slow proofs  and  1  it provides no explanation as to why or how agents come to know how to perform actions. 
     in  moore 1   moore presented an elegant solution to the first knowledge preconditions problem lor a limited class of actions. moore used the modal logic of knowledge s1 with possible worlds semantics and the simple situation calculus model of actions  in which actions are regarded as functions on situations. central to moore's argument were two concepts from possible worlds theory: that of the rigid designator  an entity such as a name or number denoting the same object across possible worlds  and that of the rigid function  a function on rigd designators. moore argued mat all actions were  axiomatically composed out of  rigid functions. furthermore  all agents knew all axioms and knew how to perform actions as long as they knew rigid designators for the actions. an agent thus knew how to perform an action if he knew rigid designators for the parameters of the action. 
	morgenstern 	1 

　　unfortunately  moore's system is insufficiently general for the following reasons:  1  the s1 model entails that all agents know all axioms and that they thus have the same procedural knowledge; this reduces the entire knowledge preconditions problem to a toy problem   1  the first order modal logic that moore uses is severely inexpressive  and does not allow us to express an agent's partial knowledge   1  the mccarthy-hayes situation calculus that moore uses is too rigid to serve as the basis for a flexible theory of planning. 
　　since the first two objections follow from moore's use of a modal logic of knowledge  and the third objection follows from moore's use of the mccarthy-hayes model of action  it makes sense to develop a theory which avoids both. we will build our theory upon a first order logic of knowledge  in which knowledge is represented as a relation on strings  and integrate it with an expressive  set-theoretic model of action. the resulting theory will lend itself in a natural manner to solutions to both of the knowledge preconditions problems. 
　　this paper extends the work of  morgenstem 1a  in which we first addressed the problem of constructing a first order logic of knowledge and action. there  we focussed upon developing a first-order logic of knowledge which avoids paradox and obeys the classical inference rules  and which could be integrated with various models of action. in this paper  we construct a detailed theory of action and planning and present our solution to the knowledge preconditions problems within that context 
1. the logical language 
　　we will be using a language l  which is an instance of the first order predicate calculus. v s symbols consist of the logical symbols  such as v   - i   and 1   constants  variables  predicates  and functions. we will feel free to substitute the english equivalents for logical symbols when it improves legibility. constants are numbers or begin with an upper case letter. predicates begin with upper case; functions and variables begin with lower case. predicates and constants  functions and variables  will be disambiguated by context in our axioms and definitions  variables will be assumed to be universally quantified unless otherwise specified. 
　　our logic is sorted; sorts are distinguished by their first letters . some of the more commonly used sorts are s  ranging over situations  i  ranging over intervals  a  ranging over agents  act  ranging over actions  str  ranging over strings. other sorts will be introduced as needed  and will be understood from context 
　　the quotation construct is an important feature of l. we assume a meta-function of l  g  which maps distinct expressions of l into distinct numbers. g is invemble; the analogue of g-1 in l is g-1. in the proper context  a number of l is said to 'stand for' the expression of l which maps into it when used in this way  numbers are known as strings. a string is written as the expression it represents  surrounded by quotation marks. for example  the string 
	'at john nyc s1 ' 	represents 	the 	expression 
at john nyc s1 . strings thus provide us with a way of talking about expression of l within l. 
　　various predicates of l take strings as their arguments; the most important of these are the predicates true and know. know takes three arguments: an agent  a string representing a sentence  and a situation. for example  to say that john knows something that bill doesn't know  we write: 
　　1 p  know john p s1  & -i know bill p s1   note that by using strings  we are effectively quantifying over sentences while remaining in a first order language; we 
1 	reasoning 
can use this trick to 'quantify' over functions and predicates by quantifying over strings which represent them. note also the ease with which we can express partial knowledge. 
　　achieving full expressivity in languages with quotation can be complicated since the quoted constructs are opaque. for example to state the principle of positive introspection  that if an agent knows something  he knows that he knows it  we cannot simply say: 
　　v a p s know a p s  ＊  know a 'know a p s ' s  this would mean that all agents always know the string 
'know a p s '. if we try to substitute values for a p  and s  we will not be able to substitute the values within the quoted context: a string is a constant to solve this problem  we introduce some syntactic abbreviations: a name-of-operator     where   applied to an object yields the name of that object  ! !  where ! ! applied to a string variable yields the string the variable stands for  and * *  where * * applied to a string variable yields the string the variable stands for  stripped of surrounding quotes.  *  as an example of their use  we now write the principle of positive introspection correctly: 
　　v a p s know a p s     know a 'know  a !p!  s ' s  our axioms on know correspond closely to the standard s1 axiomatization of knowledge. we assume veridicality  positive introspection  and consequential closure. we do not  however  assume necessitation: agents are required to know all logical axioms and axioms on knowledge  but not all axioms about the world. 
1. theory of action 
1. requirements 
　　underlying every theory of action is an explicit or implicit ontology of action. the ontology of action that we choose will be determined by the set of requirements that are placed upon the theory. these requirements  in turn  are determined by the problems that our theory seeks to solve. below  we briefly list the more salient requirements which we place upon our theory: 
 fidelity of temporal representation: a theory of action must be able to talk about both instants of time and intervals of time. actions take place over intervals of time; facts may be true over instants or intervals. instants are necessary so that we can describe what it true at a particular moment time intervals are necessary so that we can describe how the world changes over time. 
 1j granularity: the theory should be able to view actions with varying degrees of granularity. that is  the term 'action' should encompass broadly general as well as detailed descriptions of actions. for example  both driving a car and driving a red alfa romeo with the roof down on a hot summer's day should be considered actions. this is especially important for the purposes of planning. at the start of the planning process  agents often think in general terms  about coarse-grained actions. however  these coarse-grained actions may become transformed into increasingly finer grained actions as the planning process continues and plan refinement occurs. 
 interval dependent actions: there are many actions whose very descriptions depend on the time during which 
 *  these operators are defined in terms of standard features of l such as concat for further details  see  morgenstem 1b . 

they take place  such as going to the top of the tallest building in new york. the values of descriptions such as 'the tallest building in new york' change with time. we wish to have a theory which allows us to describe actions in this manner. 
 composability: most actions are formed by composing simpler actions in various ways. for example  the action of making blackberry jam can be thought of as a sequence of the action of crushing blackberries  mixing with sugar and pectin  bringing to a hard boil  and pouring into mason jars. our theory should provide a mechanism for composing simple actions to form complex actions  using the standard operators of a concurrent programming language  such as sequences  conditionals  while loops  and concurrency.  multiple agents: many of the actions we are interested in  such as communicative actions  are interagent actions  which involve at least two agents. our theory must therefore be flexible enough to describe how multiple agents act and interact. in particular  we should be able to talk about agents acting simultaneously. we should also be able to talk about individual plans which are constructed out of actions done by many agents. 
1. choosing an ontology 
　　there are two major questions which must be addressed when choosing an ontology: 1  what arc actions  and 1  how can we describe actions  
　　mainstream ai research has provided us with two answers for each of these two questions. 
1  actions have been regarded as 
a  functions on states  or 
b  sets of intervals. 
1  actions have been described using 
c  functional descriptions such as put-on a b   or 
d  set theoretic descriptions of the form  i i   i  } where  k1 is a well formed formula free only in i. 
　　it is important to realize that these approaches can be combined in a variety of ways. three of the four possible combinations are coherent and have in fact been incorporated into ai theories. mccarthy and hayes  have regarded actions as functions on states and have used functions to describe these actions. both mcdermott  and allen  have argued that actions are sets of intervals. however  allen uses functional descriptions  while mcdermott makes use of the set theoretic description of actions. 
　　these approaches can be contrasted in different ways. there is a clear advantage to approach b  over approach a  : that of oncological realism. there are many actions  such as running around the block or waiting on the corner  which do not seem to involve a state change  and which are not the null action. 
　　each of approaches c  and d   however  has some advantage over its rival. it is clear that d  is more expressive than c . there are many actions  such as our example of driving a red alfa romeo with the roof down which cannot be described in any natural manner using functional descriptions. however  it is easy to describe such an action using a set theoretic description: 
{i 1 a c alfa-romeo c  and red c  and down roof c i  and drives a c i   
if an action cannot be described using function descriptions  we say that it is composite. 
in point of fact  however  no researcher using approach d  has utilized its expressive potential in any systematic manner. moreover  approach c  has an important advantage over approach d : it is less cumbersome and easier to use for those actions which are functionally describable  such as driving a car  drive c   or putting one block on another  puton x y  . 
　　we aim to construct a theory which maximizes ontological realism  expressivity  and ease of use. with these ends in mind  we will regard actions as sets of intervals. to achieve expressivity  we will describe actions using set theoretic descriptions. we will show in a systematic manner how we can exploit the notation's expressive potential. to maximize ease of use  we will identify those classes of actions which are functionally describable  and use functional descriptions for these actions whenever possible. 
1. presentation of theory 
　　we now present a theory of action which satisfies the requirements discussed in section 1. the basic building block of our theory is the situation or state. states are ordered by the   relation  indicating precedence in time.  *  an interval is defined as a set of contiguous instants  all of which are linearly ordered. it is determined by its beginning and end points; these points name the interval. thus  the interval starting at sll and ending at s1 is denoted  si 1 s1 . intervals in general are closed. 
　　we define actions and events as sets of intervals  intuitively those in which the action or event takes place. actions are those events in which the performing agent is not specified. 
　　we place in l a set of action functions  such as puton bll bl1   dial x  and drive c . these functions map their arguments onto sets of intervals  or actions. we can associate in a natural manner an n+1-place predicate with each nplace action function. the extra arguments are used for the agent performing the action  and the interval during which the action is performed. for example  we associate with the action functions above the predicates: puts-on a bll bl1 i   dials a x i  and drives a c i . we call these predicates action predicates. 
　　actions are introduced using these action predicates. since an action is a class  it must be of the form {i i     i }  where $ is a wff free only in i. if act   {i i ty  i }  we call  |  the descriptive wff of act.  |  i  must contain an action predicate. 
　　we can achieve our second requirement  varying granularity of action  by expanding or restricting  |  in a systematic manner. we give some examples of this below: 
 1  {i i 1 a puts-on a bll b1 i } - the act of putting block bll on block b1 
 1  {i i 1 a bll bl1 puts-on a bll bl1 i } - the act of putting one block on another 
 1   i i 1 a bll bl1 red bll  and puts-on a bll bl1 i } - the act of putting a red block on some other block 
 1   i i 1 a bll bl1 equal bll favorite-block mary   and equal bl1 favorite-block jane   and 
     puts-on a bll bl1 i } - the act of putting mary's favorite block on jane's favorite block. 
　　it will be noted that only some of these actions are functionally describable.  1    1   and  1  are: their func-
 *  if this order is total  we have linear time; if it is partial  we have branching time. neither assumption is crucial for the work done in this paper. 
	morgenstem 	1 
tional descriptions arc  respectively: put-on bll b1   puton bl 1  bl1  and put-on favorite-block mary  favoriteblock jane  . there is  however  no way to produce a functional description for  1   unless we are willing to create functions such as put-red-block-on on the fly. 
     in general  we can show that an action act is functionally describable if  t  i  is one of the following forms: 
 contains no quantified variables  other than the variable representing the performing agent s . 
 contains quantified variables; these are all existentially quantified. furthermore  does not contain any predicates involving these variables other than the action predicate s  or the predicate equal. 
     functionally describable actions can further be subdivided into deterministic and non-deterministic actions. an action is said to be deterministic if all the arguments of its functional description evaluate to constants; otherwise it is non-deterministic.  1  and  1  are deterministic;  1  is not. we furthermore say that all composite actions are nondeterministic. 
     we close this section by giving two more examples of actions: 
 1   smallest-block biu  and largestblock bl1  and puts-on a bil bl1 i   - the act of placing the smallest block on the largest block 
note that this is an example of an interval dependent action. 
 1  {i} - the set of all intervals. we will call this the null action  null. 
     we can easily define such programming language operators as sequence actl act1   cond p actl act1   while p act  and concurrent actl act1  using standard set theoretic notation. in particular  we can recursively define while loops in terms of sequences  conditionals  and the null act: while p act  = cond p sequence act while p act   null .  see  moore 1 .  we say that sequence  cond  while  and concurrent are action functions. 
1. events 
     events are sets of intervals; intuitively  those intervals in which some agent performs an action. every action is an event; thus  examples  1  -  1  above are all events. however  the following are also events: 
i-
the event of a child placing one block on another 

the event of bill placing one block on another 
these are not actions because the performing agent is in some way restricted. 
     if the performing agent in deterministically specified  we can express an event as do a act   where a is the performing agent  act is the action  and do is the function mapping agents and actions onto events. for example   1  can be expressed as do bill put-on bll bl1  . 
we introduce the predicates on events r and occur. if 
ev is an event r ev sl s1  is true if s1 is the result of evl's occurrence in si. occur ev sl s1  is true if ev occurs between si and s1. the two predicates are equivalent in a model of linear time. note that the predicate r  while superficially similar to the result predicate of the situation calculus  can in fact be defined in terms of our interval based ontology: 
1 	reasoning 
def. 
in a model of branching time  in which only some states are actualized  or real states  we define: 
def. 
1. solution to the knowledge preconditions problem for 
actions 
     our solution is based upon five general observations about actions  the agents who perform them  and the knowledge these agents possess: 
 agents need to have explicit procedural knowledge for the actions they perform. agents often don't have the knowledge they need  and thus are not able to perform the actions. if an agent does not know the explicit procedure for making a souffle  he will not be able to do it 
 all agents in a community know how to perform some basic actions. this assumption is a necessary precondition for meaningful teaching to occur. 
 an agent needs more than procedural knowledge in order to perform an action. he also needs to know definite descriptions for the parameters of the action he is performing. for example  even if an agent knows how to dial a phone number  he will not be able to perform the action dial tclno mary   if he doesn't know what mary's number is. this observation has been the major focus of moore's research on the knowledge preconditions problem for actions. 
 action descriptions make a difference. the same action can be described in a number of different ways; an agent may be able to reason that he knows how to perform the action in only one of its guises. for example  an agent might know how to perform sequence beat-cggs fry-eggs   but not how to perform make-omelette; he might know how to perform 
dial 1  but not dial telno courant  . 
 an agent knows how to compose his knowledge. if an agent knows how to perform two actions  for example  he will generally know how to perform a sequence of those actions. 
     our solution to the knowledge preconditions problem for actions will synthesize and formalize these notions. we present our solution in two stages  first giving the solution for functionally describable actions  and then giving the solution for composite actions. 
1. solution for functionally describable actions 
1.1. deterministic actions 
1.1. primitive actions: 
     we begin by designating a class of action functions as primitive. this class will include such simple action types as move  put-on and dial. in general  an action is primitive if it cannot be further decomposed into simpler actions. the intuitive idea is that all agents know the basic procedures for these simple  non-decomposable acts. 
     as mentioned  an agent needs to know more than the basic procedure in order to do an action; he must also know definite descriptions for the parameters of the action functions. we say that an agent knows a definite description for a parameter if he knows some standard identifier e.g.  a constant  for the parameter. so  if f argl...argn  is an action  f is primitive  and an agent knows standard identifiers for each of argl...argn  he knows how to perform those actions. this 
principle is expressed in axiom 1. note that stidstr is a predicate that ranges over strings; it is true of a string iff the string is the quoted form of a standard identifier of l. 
arinm 1: 

for example  if put-on is a primitive action  then a knows how to perform put-on favorite-block mary  favoriteblock jane   if he knows standard identifiers for those blocks. 
　　note that the argument to the knows-how-to-perform predicate is the string representing the action description in question. this is important so that the predicate can be opaque with respect to action descriptions: otherwise the predicate would be true or false of all action descriptions which evaluated to the same action. if an agent knows how to perform an action description actl  and actl and act1 designate the same action  he will be able to perform act1 only if he knows they designate the same action. 
axiom 1: 
1.1. complex actions 
　　actions that are composed out of simple actions using our four composition operators are designated as complex actions. the knowledge preconditions for complex acts depend in a straightforward manner on the knowledge preconditions for simpler actions. 
   sequence: an agent knows how to perform a sequence of two actions if he knows how to perform the first  and knows that as a result of performing the first  he will know how to perform the second. 
axiom 1: 
　　concurrency: an agent who knows how to perform concurrent actl act1  must know how to perform each of actl and act1. in addition  the intersection of the two actions must be feasible  and the agent must have sufficient resources for both actions. 
axiom 1: 

the predicates feasible and resource-compatible are discussed in  morgenstern 1 . 
1.1. 	non-deterministic 	functionally 	describable actions 
   a non-deterministic functionally describable action is always of the form f argl...argn  where at least one of the argj does not evaluate to a constant. an example is puton bll bl1 . intuitively  an agent knows how to perform an action of this sort if he knows how to perform at least one deterministic instantiation of the action. so  for example  if b1 and b1 are blocks  and an agent knows how to perform put-on b1 b1   he also knows how to perform puton bll bl1 . the same is true if he knows how to perform put-on b1 favorite-block jane  . this intuition is justified by the set theoretic structure of non-deterministic functionallv describable actions  which  we will remember  is  i 1 a act-pred a argl ... argn i j. the 'existen-
tial generalization' is true as long as we can find some values to satisfy it. 
　　to formalize this rule  we need only add axiom!: 
assume one of argl... argn does not evaluate to a definite description. suppose further that 1 ... xn  such that each xi is a deterministic instantiation of are 1... aren. and that 

if an action is of this form  we say it is an req  restricted existentially quantified  action. thus  for instance  example 
 1  of section 1 and the action of driving a red alfa romeo with the roof down  section 1  are both examples of req actions. 
　　intuitively  an agent a knows how to perform an req action if there exist some constants ci ... cn satisfying the restriction  for which he knows how to perform the associated action . suppose  for example  that 
act is example  1  of section 1: 

if there is some constant value for ml  say b1  such that 
 i red b1 and 
	 ii  	k n o w s - h o w - t o - p e r f o r m   a   p u t s -
on a1 bl1 }    we say that a knows-how-to-perform act as well. we formalize this notion in the following axiom: 
axiom 1: 
let act be of the form described in      an req action. suppose that there exist n strings  strl... strn  such that stidstr strl  and... and stidstr strn . suppose further that p i t   g ' s t r   for each i in a through n; that is  that for each i  the predicate pi of      is true of the constant denoted by the standard identifier stri. 
then  if knows-how-to-oerform 

     we defer for the present those composite actions which contain universal quantifiers. these cases will be considered in future research. 
1. solution to the knowledge preconditions problem for plana 
1. the concept of a plan 
standard ai planning research  fikes and nilsson 1  
sacerdoti 1  has regarded plans as sequences of actions that are performed by a single agent  *  this planning paradigm  while adequate for simple single-agent toy domains like the blocks world  is nonetheless inadequate for more robust planning systems for at least two reasons: 
      1  planning may involve interactions between two or more agents. consider even a simple plan such as my petting to the airport: it consists of my hailing a taxi  the driver driving to the airport  and my paying the taxi. the taxi driver s action is an essential part of my plan. 
      1  constructs other than sequence  such as concurrency  are widely used in real life plans. an army general s plan to attack a city might consist of his attacking the city's eastern front  while his colonel attacks the city's western front 

 *  it is a common misconception that noah allows for concurrent and multi-agent plans. in fact  noah simply allows for the representation of unordered actions during the intermediate stages of planning. this is not the same as representing concurrency: the final output of no ah is always an ordered sequence of actions. moreover  noah has no explicit representation for the actions of other agents  although this could conceivably be built in . since in any case  noah cannot handle concurrency  general multi-agent planning is clearly impossible. 
1 	reasoning 
　　these observations lead us to define a plan as any structure of events constructed with our standard event operators of sequence  conditionals  while loops  and concurrency. for example  we can express the general's plan  above  as: 

note that this notation permits a particularly flexible kind of plan construction in which the planner need not even fully specify all the agents who will be performing the actions. for example  if the general is simply planning for one of his colonels to attack the city's western front  he might construct his plan as: 

　　we introduce the function actors  which applied to a plan  yields the set of actors involved in the plan  and the function actions  which applied to a plan  yields the set of actions involved in the plan. 
1. plan execution 
　　to solve the second of the knowledge precondition problems  we must explain under what circumstances an agent can successfully execute a plan. intuitively  an agent can execute a plan if he can in some sense 'make sure' that all the events in the plan get done. more precisely  we can say that an agent can execute a plan if he knows that he will be able to perform all the actions in the plan for which he is the actor  and he can predict that the other events in the plan will take place at their proper time. in the taxi plan above  for example  i can successfully execute the plan if i know that i will be able to perform the actions of hailing a taxi and paying the driver  and i can predict that the taxi driver will indeed drive me to the airport 
　　this section is devoted to formalizing this seemingly simple concept we will begin by examining how agents can execute simple single-agent plans and subsequendy extend our analysis to more complex plans. 
　　we first define the concept of a simple plan. we introduce the predicate simple-plan  which is true of plans consisting of events done by a single agent thus  for example  simple-plan do adrive car  do a park car    is true; simple-plan do adrive car   do b park car    is false. a plan that is a simple plan can always be re-written as a single event if pin is a simple plan  we write ev pln  to denote the single event associated with this plan. note that for simple plans  the function actors evaluates to a singleton. 
　　if p is a simple plan  and a is the performing agent in this plan  a can execute p if he knows he is able to perform the action construct associated with p. we say that an agent is able to perform an act if he knows how to perform it and if the physical preconditions are satisfied.  ++  


 *+  in our full theory  morgenstem 1  we say that an agent is able to perform an action if he knows how to perform it  if the physical preconditions are satisfied  and if certain social protocols are satisfied. these protocols are an important part of our theory of communication. we omit this condition here for simplicity. 
axiom 1: 

can-execute-dlan a.dln.s  iff 

if a is not the performing agent for a simple plan  we say that a can execute the plan if he can predict its occurrence. 
axiom 1: 

1.1. complex plans 
     if a plan is not simple  we say that it is complex. a 
     complex plan must always be constructed via our four compositional operators. the knowledge preconditions for complex plans turn out to be considerably more difficult to state than the knowledge preconditions for complex actions. 
     sequences: our first attempt at a knowledge precondition axiom for plan sequences might parallel the axiom for action sequences: 
 wrong axiom:  

this axiom  however  places overly strong demands on the knowledge of the executing agent. suppose jones  a dying man  constructs the plan sequence do  jones  sequence write will  die    do smith execute will    
jones can conceivably execute the plan if he knows he can write a will  knows he will die  and can trust his attorney smith. however  if we accept the above axiom attempt  jones will not be able to execute the plan because once he is dead he does not know that smith will execute the will. clearly  what is important here is that jones know what is going on at the beginning of the plan. once he leaves the picture  we do not care what he knows.  *  
     it turns out to be impossible to formalize the canexecute-plan axiom for plan sequences in terms of the canexecute-plan axioms for simple plans. we must in fact introduce a level of indirection  via the predicate control. an agent is said to control a plan if he can perform the action s  associated with it  or if the plan will occur.  **  the axioms on control are self-explanatory: 

 *  the slightly unusual case of a dying man is only one of the more salient examples of a basic truth: agents often lose information after they construct a plan; they arc nonetheless capable of executing the plan. consider  for example  a busy executive who plans a conference in detail  convinces herself that the plan will work  delegates the plan to a secretary  and then proceeds to forget the details of the plan. at the time she delegates the plan  it makes sense to say that she can execute the plan. 
 **  this use of control is unintuitive in some cases; for example  i control the plan in which humans land on mars  if it will occur. 
controls a pln s  if 

controls a sequence plnl pln1  sl  iff controls a plnl s  and 

controls a while p pln  s  iff 
controls a  cond p sequence p pln while p pln   null  s  
controls a concurrent plnl pln1  s  iff 
controls a plnl s  and controls a pln1 s  
     we now say that an agent can execute a sequence of two plans if he knows that he can control the first and he knows that as a result of the first plan he will control the second. 
axiom 1: 

in the jones-smith example  above  jones can execute his plan because at the beginning he knows that smith will execute his will. 
     conditionals: as with sequences  it is easy to overstate the knowledge preconditions for conditional plans. we might say that an agent can execute cond p plnl pln1  if he knows p and can-execute plnl or he knows that p is false and can execute pln1. it turns out  however  that an agent can often successfully execute a plan without knowledge of the crucial condition. consider smith's plan to play the stock market by listening to the advice of his stockbroker brown. smith knows that brown is watching out for the earnings report of ibm. smith can construct the following plan: 
cond favorable eamings-rept ibm    sequence do brown tell smith 'buy'    do smith buy-shares ibm     
sequence do brown tell smith 'sell    do smith sell-shares ibm     
smith can execute this plan even though he doesn't at the start know anything about ibm's earnings. intuitively  this is true because he is not involved in the first part of the plan. it is brown who must know ibm's earnings. more precisely  smith's actions at the beginning of the plan  here null  are not affected by the conditions of the plan. 
     we thus say that an agent executing a conditional plan is required to know the condition only if his actions at the beginning of the plan would be affected by the condition. we introduce the function first-action a pln  which returns the actions done by a during the first part of pin. 
axiom 1: 

	morgenstern 	1 

     while loops: since while loops are defined in terms of sequence and conditionals  our axiom for while loops is sim-
ply: 
axiom 1: 
can-execute-plan a while p pln  s  iff 
can-execute-plan 
 a cond p sequence pln while p pln   null  s  
     concurrency: we say that an agent can execute a plan consisting of two concurrent plans if he can execute each plan. in addition  he must know that they are physically feasible  and that there are sufficient resources available. 
axiom 1: 

1. example 
we now demonstrate how our theory works in practice. 
we consider again the case introduced in section 1. an agent a  entering a chemistry lab for the first time  is asked to neutralize an acid; he has no idea how to perform the procedure. we assume that a knows that some agent b knows how to neutralize the acid  and that a and b are cooperative agents. for the purposes of this brief paper  we furthermore assume that the following is true of our planning domain: 
1  all communicative acts are primitive 
1  friendly agents wish to do what they're asked to do 1  if an agent wishes to do an act and he can  then he will 1  friendly agents are constrained to tell the truth. finally  we assume that the physical preconditions for the actions here are satisfied.  these assumptions are dropped in  morgenstern 1   where an isomorphic problem is worked out in detail.  we can then show that a can successfully execute the following plan. the actions introduced below should be self-explanatory. 
the plan consists of a sequence of three steps: 

equivalently  do a neutralize acid  
     since communicative acts are primitive  a knows that he automatically knows enough to ask b to perform the requested action. in addition  the physical preconditions for this action are satisfied. thus  a knows mat he is able to perform the action of the first step in this plan. moreover  since a and b are friendly  a knows that b will perform the favor that he has requested  telling him how to neutralize the acid  if b possibly can. in point of fact  since b knows how to neutralize the acid  he can tell a how to perform the 
1 	reasoning 
action. thus  a can predict the occurrence of the second step. once b tells a the procedure  a will know what the procedure is. so a can predict that he will be able to perform the act of neutralizing the acid. a can thus reason that he can successfully execute the plan consisting of the sequence of stepl  step1  and step1. 
1. conclusion 
　　we have constructed a highly flexible model of action and planning  and have demonstrated that it is well suited for partially specified plans and for multi-aaent interactions. we have presented solutions to both of the knowledge 
preconditions problems within that context  explaining how agents can reason about their ability to perform actions and execute plans. 
　　this paper represents the second stage of a three-stage research effort to develop a robust logic of knowledge  action  and communication. in a future paper  we present a logic of communication based upon an austinian model of speech acts  austin 1   and discuss how we can integrate this theory with our solutions to the knowledge preconditions problems. 
acknowledgements: this research was supported in part by 
nsf grant dcr-1. thanks to ernie davis for many helpful ideas  suggestions  and discussions. 
bibliography 
allen  james: toward a general theory of action and time'  artificial intelligence  vol. 1  no.1 
austin  j.l.: how to do things with words  harvard university press  cambridge  1 
chapman  david: planning for conjunctive goals  mit tr 
1 1 
ernst  g. and newell  allan: gps: a case study in generality and problem solving  academic press  new york  1 
fikes  r.e. and nils nilsson: 'strips: a new approach to the application of theorem proving to problem solving ' 
artificial intelligence  vol 1 
mccarthy  john and patrick hayes: 'some philosophical problems from the standpoint of artificial intelligence' in bernard meltzer  ed: machine intelligence 1 
mcdennott  drew: 'a temporal logic for reasoning about processes and plans ' cognitive science  1 
moore  robert: reasoning about knowledge and action  sri technical note 1 
morgenstern  leora: 'a first order theory of planning  
knowledge  and action'  proceedings of the conference on 
theoretical aspects of reasoning about knowledge  morgan kaufmann  los altos  1 
morgenstern  leora: foundations of a logic of 
knowledge  action  and communication  forthcoming nyu phd. thesis  1 
morgenstern  leora: 'preliminary studies for a first order logic of knowledge and action; nyu technical report 
1; 1 
sacerdoti  earl: a structure for plans and behavior  american elsevier  new york 1 
tate  austin: 'generating project networks'  proceedings  
fifth international conference on artificial intelligence  
1 
