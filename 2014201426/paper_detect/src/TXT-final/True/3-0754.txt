
the quantified constraint satisfaction problem  qcsp  is a generalization of the csp in which some variables are universally quantified. it has been shown that a solver based on an encoding of qcsp into qbf can outperform the existing direct qcsp approaches by several orders of magnitude. in this paper we introduce an efficient qcsp solver. we show how knowledge learned from the successful encoding of qcsp into qbf can be utilized to enhance the existing qcsp techniques and speed up search by orders of magnitude. we also show how the performance of the solver can be further enhanced by incorporating advanced lookback techniques such as cbj and solution-directed pruning. experiments demonstrate that our solver is several orders of magnitude faster than existing direct approaches to qcsp solving  and significantly outperforms approaches based on encoding qcsps as qbfs.
1 introduction
the constraint satisfaction problem  csp  is a very successful paradigm that can be used to model and solve many realworld problems. the csp has been extended in many ways to deal with problems that contain uncertainty. the quantified constraint satisfaction problem  qcsp  is an extension in which some of the variables may be universally quantified. for each possible value of such variables  we have to find values for the remaining  existentially quantified  variables so that all the constraints in the problem are satisfied. the qcsp can be used to model pspace-complete decision problems from areas such as planning under uncertainty  adversary game playing  and model checking. for example  in game playing we may want to find a winning strategy for all possible moves of the opponent. in a manufacturing problem it may be required that a configuration must be possible for all possible sequences of user choices. finally  when planning in a safety critical environment  such as a nuclear station  we require that an action is possible for every eventuality.
　interest in qcsps is growing  following the development of numerous efficient solvers in the closely related area of quantified boolean formulae  qbf or qsat . however  the existing direct approaches to solving qcsps with discrete finite domains  i.e. approaches based on extending csp techniques  are at an early stage  bordeaux and monfroy  1; mamoulis and stergiou  1 . as shown in  gent et al.  1   such approaches are significantly outperformed by a qbf solver applied on an encoding of qcsps into qbfs. note that  in contrast to qcsps with finite domains  there is a significant body of work on quantified problems with continuous domains  e.g.  benhamou and goualard  1; ratschan  1  .
　in this paper we introduce an efficient qcsp solver  which we call qcsp-solve. to develop the solver we first implemented extensions of standard csp algorithms  fc and mac  and gradually enhanced them with new capabilities. we started by repeating and analyzing the experiments of  gent et al.  1  to discover the features of the qbf solver that account for its effectiveness compared to existing direct approaches. this lead us to identify the pure literal rule used by the qbf solver as the main factor contributing to its efficiency. we devised the qcsp analogue of the pure literal rule and incorporated into our basic solver. as a result we achieved a speed-up of several orders of magnitude. we then continued the development of qcsp-solve by adding intelligent look-back techniques such as conflict-based backjumping and solution-directed pruning which also offer a significant speed-up. finally  we implemented a symmetry breaking method based on value interchangeability.
　the experimental evaluation of algorithms for qcsps is difficult for two reasons: first  due to the young age of the area  there is a lack of benchmarks; and second  the generalization of known random generation models from related areas  csp and qbf  can lead to flawed models. for example in  gent et al.  1  it was noted that the generation method used in  mamoulis and stergiou  1  suffers from a flaw that makes all generated instances insoluble even for small problems sizes. this flaw is also present in other random generation methods. we propose a random generation model that  while creating hard instances  can be used to control the probability of the flaw discovered in  gent et al.  1 . for certain parameter settings all generated instances are guaranteed to be unflawed. on problems created using this model  qcsp-solve is several orders of magnitude faster than the existing qcsp algorithms  and also significantly outperforms the qbf encoding based method of  gent et al.  1 .
1 preliminaries
in standard csps all variables are existentially quantified. qcsps are more expressive than csps in that they allow universally quantified variables. they enable the formulation of problems where all contingencies must be allowed for. we now give a formal definition.
definition 1 a quantified constraint satisfaction problem  qcsp  is a formula of the form qc where q is a sequence of quantifiers q1 ...qnxn  where each qi quantifies    or    a variable xi and each variable occurs exactly once in the sequence. c is a conjunction of constraints  c1 … ... … cm  where each ci involves some variables among x1 ... xn.
　the semantics of a qcsp qc can be defined recursively as follows. if c is empty then the problem is true. if q is of the form  x1x1 ...qnxn then qc is true iff there exists some value a （ d x1  such that q1 ...qnxnc  x1 a  1is true. if q is of the form  x1x1 ...qnxn then qc is true iff for each value a （ d x1   q1...qnxnc  x1 a   is true. in this paper we restrict our attention to binary qcsps1. in a binary qcsp  each constraint  denoted by cij  involves two variables  xi and xj  which may be universally or existentially quantified.
　as an example consider the following qcsp where q is a sequence of 1 quantified variables  and c is a conjunction of 1 constraints. this problem will be used in section 1 to demonstrate the various features of qcsp-solve.
example 1
 x1 x1 x1 x1 x1 x1 x1 x1= x1 …x1= x1 …x1= x1 … x1= x1…x1   x1…x1= x1…x1= x1…x1 =1 x1…x1   x1 
　a special case of a qcsp is quantified boolean formula  qbf . a qbf is of the form qc where q is defined as above  however in this case the domain of each variable is 1 . c is a boolean formula in conjunctive normal form  cnf   a conjunction of clauses where each clause is a disjunction of literals. each literal is a variable and a sign. the literal is said to be negative if negated and positive otherwise. the semantic definition is the same as for qcsps. note that binary qcsps  unlike 1-qbf  i.e. qbf problems with at most two literals per clause   are not trivial. despite the restriction to binary constraints  binary qcsps are still pspace-complete  boerner et al.  1 .
　in the rest of the paper we assume that for any constraint cij  variable xi is before xj in the quantification sequence  unless explicitly specified otherwise. we will sometimes refer to universally and existentially quantified variables as universals and existentials respectively.
1 description of qcsp-solve
in this section we describe the basic features of qcsp-solve. first we discuss preprocessing. then we analyze the lookahead and look-back capabilities of qcsp-solve. in standard csps look-ahead techniques try to detect dead-ends early by pruning values from future variables  while look-back techniques try to deal with dead-ends in an intelligent way by recording and exploiting the reasons for failures. note that some of the techniques we will describe may delete values from the domains of universal variables because they may discover that  under the current assignments  these values will definitely lead to a solution. this pruning is different than standard pruning in csps.
1 preprocessing
arc consistency  ac  has been extended to qcsps in  bordeaux and monfroy  1  and  mamoulis and stergiou  1 . qcsp-solve always applies ac as a preprocessing step. apart from reducing the problem size by deleting values from the domains of existentials  ac removes from the problem all constraints of the form   xi  xj cij and   xi  xj cij. for the former kind  ac deletes every value of d xi  that is not supported by all values of d xj . if d xi  becomes empty then the algorithm determines insolubility. for the latter kind  if there is a value of d xi  that is not supported by all values of d xj  then the algorithm determines that the problem is insoluble. after ac has been applied  all such constraints can be safely removed from the problem since they cannot have any further effect. a consequence of this removal is that any universals after the last existential can be ignored  since they participate in no constraints.
1 look-ahead
in qcsp-solve we have implemented two basic forms of look-ahead; forward checking  fc  and maintaining arc consistency  mac . fc  called fc1 in  mamoulis and stergiou  1  and hereafter  is an extension of standard fc to qcsps. fc1 is a backtracking-based algorithm that can discover dead-ends early by forward checking the current variable assignment  of an existential or universal  against values of future existentials constrained with the current variable. by slightly modifying the forward checking phase of fc we get an algorithm  called fc1 in  mamoulis and stergiou  1   which can discover dead-ends earlier than fc1. fc1 has exactly the same behavior as fc1 when the current variable is an existential. if the current variable xi is a universal then fc1 forward checks each value of xi against all future variables before assigning a specific value to it. if one of xi's values causes a domain wipe-out then fc1 backtracks to the last existential. otherwise  it proceeds by instantiating the next available value a of d xi  and removing all values of future variables that are inconsistent with the assignment  xi a . in this way fc1 can discover dead-ends earlier and avoid fruitless exploration of search tree branches.
　the mac algorithm is also an extension of standard mac to qcsps. after each variable assignment  mac applies ac in the problem using the ac algorithm of  mamoulis and stergiou  1 . mac has also been modified in the same way as fc to yield mac1  an algorithm analogous to fc1. that is  when the current variable xi is a universal mac1 applies ac for each instantiation  xi aj   j （ {1 ... d} before committing to a particular instantiation. if one of the instantiations causes a domain wipe-out then the algorithm backtracks. otherwise  it commits to one of the values and proceeds with the next variable.
　in the rest of the paper we will describe how various lookahead and look-back techniques are combined with an fcbased look-ahead. most of these techniques can be combined with a mac-based look-ahead in a very similar way.
the pure value rule
in sat and qbf a literal l is called pure  or monotone  if its complementary literal does not appear in any clause. such literals are important because they can immediately be assigned a value without any need for branching  cadoli et al.  1 . this is what the pure literal rule does. for example  if an existential literal l only occurs positively  the pure literal rule will set it to true. by repeating and analyzing the experiments of  gent et al.  1  we discovered that the pure literal rule has a profound impact on the search effort. when switching it off  the search process was slowed down by orders of magnitude. this immediately gave rise to the following questions: what does the pure literal rule correspond to in qcsps  and how can we exploit it to prune the search space  to answer these questions  we use the notion of a pure value.
definition 1 a value a （ d xi  of a qcsp qc is pure iff  qjxj （ q  where xj 1= xi and  b （ d xj   the assignments  xi a  and  xj b  are compatible.
in a way analogous to the pure literal rule in qbf  we have devised and implemented a look-ahead technique  which we call the pure value  pv  rule  that detects and exploits pure values to prune the search space. the actions taken are dual for existential and universal pure values. an existential variable with a pure value can be set to that value  while a pure value is removed from the domain of a universal variable. this duality reflects the dual semantics of existential and universal variables. note that values can become pure dynamically during search because of constraint propagation  see example 1 in section 1 . therefore  the pv rule is applied both as a preprocessing technique and as a dynamic look-ahead technique during search. the pv rule works as follows.
  if a pure value a of an existential xi is discovered during preprocessing  search   then the assignment  xi a  is made and all other values of xi are permanently  temporarily  removed from d xi . to check  during search  if a value a of an existential xi is pure  we only need to check if the assignment  xi a  is compatible with all values of future variables. fc  or mac  guarantee that  xi a  is compatible with the values  i.e. the instantiations  of the previous variables.
  if a pure value a of a universal xi is discovered during preprocessing  search   then a is permanently  temporarily  removed from d xi . to check if a value of a universal is pure  we only need to check against future variables since preprocessing with ac guarantees that there are no constraints between a universal and a previous variable. note that if all the values of a universal are pure then we can ignore this variable.
symmetry breaking
qcsp-solve utilizes a technique for symmetry breaking based on neighborhood interchangeability. a value a of a
variable xi is fully interchangeable with a value b of xi  iff every solution which contains the assignment  xi a  remains a solution if we substitute b for a  and vice versa  freuder  1 . a value a （ d xi  is neighborhood interchangeable  ni  with a value b （ d xi   iff for each j  such that cij （ c  a and b are compatible with exactly the same values of d xj . qcsp-solve exploits ni to break some symmetries by pruning the domains of universal variables. that is  for each set of ni values we keep one representative and remove the others  either permanently before search  or temporarily during search 1. if the algorithm proves that the representative is consistent  i.e. satisfies the qcsp  then so are the rest.
1 look-back
various look-back schemes have been developed for csps. one of the most successful is conflict-based backjumping  prosser  1 . this algorithm has been successfully combined with fc in csps  prosser  1   and a dll-based procedure in qbf  giunchiglia et al.  1 . we describe how cbj interacts with the fc-based look-ahead of qcsp-solve.
　as in standard csps  for each variable xi we keep a conflict set  denoted by conf set xi   which holds the past variables that are responsible for the deletion of values from d xi . initially all conflict sets are empty. when encountering a dead-end  cbj exploits information kept in conflict sets to backjump to a variable that is  partly  responsible for the dead-end. conflict sets are updated as follows. if the current variable xi is existentially quantified and  during forward checking  a value of a future variable xj is found to be incompatible with the assignment of xi then xi is added to conf set xj . if the domain of a future variable xj is wiped out then the variables in conf set xj  are added to conflict set of the current variable  existential or universal . backjumping can occur in either of the following two cases:
  if the current variable xi is existential and there are no more values to be tried for it then qcsp-solve backjumps to the rightmost variable xk in q that belongs to confset xi . at the same time all variables in conf set xi   except xk  are copied to conf set xk  so that no information about conflicts is lost.
  if the current variable xi is universal and a value is deleted from its domain  because its forward checking results in a domain wipeout  then qcsp-solve backjumps to the rightmost variable xk in q that belongs to conf set xi . again all variables in conf set xi   except xk  are copied to conf set xk .
solution-directed pruning
 giunchiglia et al.  1  introduced solution-directed backjumping for qbf. this allows backjumps over universally quantified literals once reaching a leaf node that is a solution. inspired by this idea  we have implemented a technique that can prune values from universal variables when reaching a solution  i.e. a consistent leaf node . we call this solution directed pruning  sdp . sdp is based on the following idea: assume that xi is the last universal in q and q = {xi+1 ...xn}   q is the sequence of existentials to the right of xi. also  assume that the assignment  xi ai  leads to a solution  i.e. is part of a path to a consistent leaf node  and { xi+1 ai+1 ... xn an } are the assignments of vari-
ables {xi+1 ...xn} along this path. then any value of xi that is compatible with all these assignments will definitely also lead to a solution. such values can be pruned  i.e. ignored  by the search algorithm. based on this  sdp first computes the values of the last universal xi that have the above property. all such values are temporarily removed from d xi . now if there are no available values in d xi   sdp proceeds with the universal immediately before xi in q  say xj  and checks if its remaining values are compatible with the assignments of all existentials after xj. this is repeated recursively until a universal is found which has available values left in its
domain after sdp has been applied. the algorithm then backtracks to this universal. in this way it is possible to perform solution-directed backjumps.
1 the algorithm of qcsp-solve
a high level description of qcsp-solve's algorithm is shown in figure 1. it takes a qcsp qc and returns true if the problem is satisfiable  and false otherwise1. the version of qcsp-solve shown in figure 1 is based on fc. a mac-
based version with all the features  except cbj for the time being  is also currently available. in figure 1 
  c var is the current variable.
  preprocess   is a function that preprocesses the problem by applying ac  and computing pure and ni values.
  compute pv    computes the pure values of c var during search. if cvar is existential and one of its values  say a  is pure then compute pv  c var  sets c var to a and temporarily removes the rest of d c var 's values. if c var is universal then compute pv  c var  temporarily removes all the pure values from d c var . whenever the algorithm backtracks  all values removed by compute pv    are restored.
  fc1   implements the fc1-type look-ahead. it is called after the current variable  existential or universal  is assigned and forward checks this assignment against all future variables constrained with c var. if a value of a future variable xi is deleted then c var is added to conf set xi . if d xi  is wiped out then  xj xj （ conf set xi   xj is added to conf set c var .
  fc1   implements the fc1-type look-ahead. it is called before cvar is assigned  if it is a universal  and for-
ward checks all of d cvar 's valid values against the future variables constrained with c var. if the domain of a future variable xi is wiped out then  xj xj （
conf set xi   xj is added to conf set c var .
  sdp   implements solution directed pruning. sdp   prunes values from universals according to the rule described in section 1 and returns the universal that has values left in its domain after sdp has been applied.
boolean qcsp-solve  q c 
1: preprocess q c 
1: cvar ○ leftmost variable in the quantification formula
1: while there is no backtrack from the first existential or universal
1:	compute pv  c var 
1:	if c var is existential
1:	if no more values in d cvar 
1:	c var ○ rightmost variable in confset c var 
1:	else
1:	assign c var with next valid value a （ d c var 
1:	dwo○ fc c var a 
1:	if dwo = false
1:	if there are no more unassigned variables
1:	if there are no universals in q return true
1:	else
1:	c var ○ sdp q 
1:	restore values removed by all variables after cvar
1:	else cvar ○ next unassigned variable
1:	else restore values removed by cvar
1: else //c var is universal//
1:	if no more values in d cvar 
1:	if c var is the first universal return true
1:	else cvar ○ last assigned universal variable
1:	else
1:	dwo = false
1:	if no assignment to c var has been tried
1:	dwo○ fc1 cvar 
1:	if dwo = false
1:	assign c var with next available value a （ d c var 
1:	fc c var a 
1:	c var ○ next unassigned variable
1:	else
1:	c var ○ rightmost variable in confset c var 
1:	restore removed values by all variables after cvar
1: if there is a backtrack from the first existential return false
1: return true
figure 1: the algorithm of qcsp-solve.
　qcsp-solve works as follows. it takes as input a qcsp qc and  after preprocessing the problem  line 1   it proceeds by checking assignments of values to variables until the truth of the qcsp is proved or disproved. before assigning a value to c var  qcsp-solve calls compute pv  c var  to compute the pure values of c var  line 1 . if cvar is existential and a dead-end occurs then the algorithm backtracks to the rightmost variable in conf set c var   lines 1 . otherwise  the next valid value of c var is forward checked against
future variables  lines 1 . if there is no domain wipe-out  dwo  and the algorithm has reached a consistent leaf node  i.e. cvar is the last variable in q  then it calls sdp   to perform solution-directed pruning  line 1 . if qcsp-solve is not at a leaf node  it proceeds by moving to the next variable  line 1 . if there is a dwo  the next value of cvar will be tried in the next iteration of the while loop.
　if c var is universal and all of its values have been proved to be consistent  according to the current assignments   then there are two cases. if c var is the first universal  qcspsolve terminates successfully  line 1 . otherwise  it backtracks to the last universal  line 1 . before assigning any value to a universal variable  qcsp-solve calls fc1 c var  to perform fc1-type look-ahead  lines 1 . if there is a dwo  the algorithm backtracks to the rightmost variable in conf set c var   line 1 . if there is no dwo  or fc1 c var  has already been called at this level  cvar is assigned with its next available value  line 1   the assignment is forward checked against future variables  line 1   and qcsp-solve proceeds with the next variable  line 1 .
　to better understand how the algorithm of qcsp-solve works  consider the following example.
example 1 assume that the domains of the variables in the problem of example 1 are as follows: d x1  = {1}  d x1  = {1 1}  d x1  = {1}  d x1  = {1 1}  d x1  = {1}  d x1  = {1 1}  d x1  = {1 1}. let us trace the execution of qcsp-solve for a few steps.
　1  preprocessing is applied. there are no arc inconsistent or pure values  so no pruning is performed.1  the assignment  x1  is made. fc reduces d x1  and d x1  to {1 1} and {1 1} respectively. we now have conf set x1  = confset x1  = {x1}. 1  now  value 1 of x1 becomes pure because it is supported by all values in future variables. the pv rule will immediately make the assignment  x1 . 1  fc1 does not wipe out any future domain  so the assignment  x1  will be made. fc reduces d x1  and d x1  to {1} and {1} respectively. 1  value 1 of x1 is pure. therefore  it is removed and the assignment  x1  is made. fc reduces d x1  to {1}. 1  fc1 does not wipe out any future domain  so the assignment  x1  will be made. fc reduces d x1  to {1}. 1  x1 and x1 are assigned their only available values and a solution is found. 1  now function sdp   is called  line 1 . sdp   discovers that value 1 of the last universal  x1  is compatible with the assignments of all the existentials after x1. therefore  this value is removed from d x1  and a solution-directed backjump to x1 is performed. 1  the assignment  x1  is made. fc reduces d x1  and d x1  to {1} and {1} respectively. 1  fc1 applied at x1 wipes out d x1   value 1 of x1 is incompatible with the only value in d x1  . therefore  we have a dead-end. confset x1  will be added to confset x1  and the algorithm will backjump to the rightmost variable in conf set x1   which is x1.
　figure 1 shows part of the search tree generated by qcspsolve and illustrates how subtrees are pruned.
1 experiments
 gent et al.  1  showed that the model for random generation of qcsps used in  mamoulis and stergiou  1  can suffer from a local flaw that makes almost all of the generated instances false. in this model there are k alternating quantifiers applied to disjoint sets of variables  with the innermost quantifier being existential. let us briefly describe the flaw. suppose we have a series of k universals x1 ... xk assigned to values a1 ... ak respectively. if there is an existential xi later in q than the k universals and each one of its values is in conflict with one of the values assigned to the universals then the assignment of values a1 ... ak to variables x1 ... xk is

figure 1: search tree of example 1. dark nodes are pruned by qcsp-solve. such nodes together with the feature responsible for their pruning are included in dashed ovals.
inconsistent. this assignment will remain inconsistent irrespective of the assignments to other universals or existentials  and therefore the problem is unsatisfiable. we now propose a generator that can be used to control the probability of flaws.
　variables are quantified in three blocks  a block of existentials followed by a block of universals then another block of existentials.the generator takes 1 parameters:   n n  npos d p q   q     where n is the total number of variables  n  is the number of universals  npos is the position of the first universal in q  d is the uniform domain size  and p is the number of binary constraints as a fraction of all possible constraints. q   is the number of goods in   xi  xj cij constraints as a fraction of all possible tuples  and q   is a similar quantity for   xi  xj cij constraints  described further below. the other two types of constraints that can be removed by preprocessing are not generated.
　since the flaw is a characteristic of   xi  xj cij constraints  we restrict these in the following way: we generate a random total bijection from one domain to the other. all tuples not in the bijection are goods. now q   is the fraction of goods from the d tuples in the bijection.
　to control the probability pf of the flaw  we write down an expression for pf  approximating proportions p q   q   as probabilities. n  is the number of universal variables  and n  is the number of inner existential variables. for each existential assignment  xi a   the probability that it is covered by a universal is p 1   q   . if the variable xi is flawed  then all its values are in conflict with some value of some universal variable. however  each universal variable can only cover one value  since we use a bijection . therefore  representing existential values using integers  the probability that variable xi is flawed is given by the following.
	p xi flaw  = p 1 p 1 p 1 … 1 ...	 1 
　the probability that value a is flawed  given that the previous a   1 values are flawed  is given by formula 1. p a|1...a   1  = 1    1   p1   q    n  a 1	 1 
　substituting equation  1  into equation  1  gives the probability of one variable being flawed.
d 1
p xi flaw  = y 1    1   p1   q    n  i  1 
i=1
　the probability that no existential variables are flawed is given below. this formula is undefined when d   n . in this case  pf = 1.
	pf =  1   p xi flaw  n 	 1 
experimental results
figure 1 presents a comparison of algorithms fc1  fc1+pv  mac1+pv  and full qcsp-solve on problems generated according to the model described above. all algorithms apply ac  and ni preprocessing. for each value of q   shown in the figures  1 problem instances were generated and we use the mean average. we include fc1+pv and mac1+pv in the comparison to illustrate the power of the pv rule. in the problems of figure 1 the execution of fc1 was stopped at the cut-off limit of 1 hours in more than 1% of the instances. as we can see  qcsp-solve is many orders of magnitude faster than fc1. the speed-up obtained is largely due to the application of the pv rule. similar results were obtained with various parameter settings.
　having established that qcsp-solve is considerably faster than existing direct approaches  we compared it with the state-of-the-art approach of  gent et al.  1   using the adapted log encoding with the csbj qbf solver. figure 1 presents indicative results of this comparison. in this case  we used the median because of high outliers. as we can see  qcsp-solve is significantly faster than csbj  more than one order of magnitude   except for very high values of q  .
1 conclusion
we introduced qcsp-solve  an efficient solver for qcsps. qcsp-solve incorporates a variety of techniques that are either extensions of techniques used in csps and qbf  or are specifically designed for qcsps. to our knowledge  this is the first time these techniques have been devised and implemented in qcsps. we also proposed a random generation model that can be used to create instances that are free from the flaw discovered in  gent et al.  1 . experiments showed that qcsp-solve is several orders of magnitude faster than the existing state-of-the-art direct algorithms for qcsps  and also significantly outperforms approaches based on encoding qcsps into qbfs. current and future work includes extending the solver to handle constraints of any arity  and incorporating other advanced techniques  such as learning.
