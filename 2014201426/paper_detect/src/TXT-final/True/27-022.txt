 
work on game playing in ai has typically ignored games of imperfect information such as poker in this paper we present a framework for dealing with such games we point out several important issues that arise only in the context of imperfect information games particularly the insufficiency ot a simple game tree model to represent  he players information state and the need for randomization in the players optimal strategics we describe gala an implemented system that provides the user with a very natural and expressive language for describing games from a game description gala creates an augmented game tree with information sets which can be used by various algorithms in order to find optimal strategies for that game in particular gala implements the first practical algorithm for finding optimal randomized strategies in two player imper fect information competitive games  koller el al 1  the running time of this algorithm is palvno mial in the size ot the game tree whereas previous algorithms were exponential we present experimental results showing that this algorithm is also 
efficient in practice and can therefore form the basis for a game playing system 
1 	introduction 
the idea of getting a computer to play a game has been around since the earliest days of computing the fundamental idea is as follows when it is ihe computer s turn lo move u creates some part of the game tree starting at the current position evaluates the leaves of this partial tree using a heuristic evaluation function and then does a minimax search of this tree lo determine the optimal move al ihc root this same simple idea is still the core of most game-playing programs this paradigm has been successfully applied lo a large class of games in particular chess checkers othello backgammon andgotrussellandnorvig 1 ch 1  there have been far fewer successful programs that play games such as poker or bridge we claim that this is not an accident these games fall into two fundamentally different classes and the techniques thai apply to one do not usually apply to the other 
　the essential difference lies in the information that is avail able to the players in games such as chess or even backgam mon  the current state of the game is fully accessible to both 
avi pfeffer 
university of california berkeley  ca 1 ap cs berkeley edu 
players the only uncertainty is about future moves in games such as poker  he players have imperfect information they have only partial knowledge about the current state of the game this can result in complex chains of reasoning such as since i have two aces showing but she raised men she is either bluffing or she has a good hand but then if i raise a lot she may realize that 1 have al least a third ace  so she might fold so mavbc i should underbid bul it should be fairly obvious that the standard techniques are inadequate lor solving such games no variant of the minimax algorithm duplicates the type of complex reasoning we just described 
　in game theory  von neumann and morgenslern 1  on the other hand virtually all of the work has focused on games with imperfect information game theory is mostly intended lo deal with games derived from real life  and particularly from economic applications in real life one rarely has perfect information the insights developed hy game theorists for such games also apply to the imperfect information games encountered in ai applications 
　it is well known in game theory lhal the notion of a strai eg  is necessarily different for games with imperfect mforma lion in pcrlccl inlormalion games the optimal move for each player is clearly defined al every stage there is a right move thai is di feast as good as any other move but in imperfect information games the situation is not as straightforward in the simple game of scissors paper stone any deterministic strategy is a losing one as soon as it is revealed lo the olher players intuitively in games where there is an information gap it is usually lo my advantage lo keep my opponent in the dark the only way to do thai is by using randomized strategies once randomized strategics are allowed ihe exis lence of optimal strategies in imperfect information games can be proved in particular this means lhal ihcrc exists an optimal randomized strategy lor poker in much the same way as there exists an optimal deterministic strategy for chess kuhn   1* 1l has shown for a simplified poker game lhal the optimal strategy does indeed use randomization 
　the optimahly of a strategy has two consequences the player cannot do better than this strategy if playing against a good opponent and lurlhermore the player docs not do worse even if his strategy is revealed io his opponent i c ihe opponent gains no advantage irom figuring out the player s strategy this last feature is particularly important in the context of game-playing programs since they arc vulnerable lo ihis form of aitack sometimes the code is accessible and in general since they always play the same way thei rstrategy 
	koller and pfeffer 	1 
can be deduced by intensive testing given these important benefits of randomized strategies in imperfect information games u is somewhat surprising that none of the ai papers that deal wim these games  e g  blair era/ 1 gordon 1 smith and nau 1   utilize such strategics 
　in this work we attempt to solve the computational problem associated with imperfect information games given a concise description of a game compute optimal strategies for thai game two issues in particular must be addressed first how do we specify imperfect information games' describing the dynamics of the players information states in a concise fashion is a nontnvial knowledge representation task second given a game tree with the appropriate structure how do we find optimal strategies for it  
　we present an implemented system called gala that ad dresses both these computational issues gala consists of four components the first is a knowledge representation language that allows a clear and concise specification of imperfect in formation games as our examples show the description of a game in gala is very similar to and not much longer than a natural language description of the rules of the game the second component of the system generates game trees from a game description in the language these game trees are aug menled with information tefv a standard concept irom game theory thai captures the information slates of the players 
　the third component of the system addresses the issue of finding good strategies for such games obviously the stan dard minimax type algorithms cannot produce randomized strategies the game theoretic paradigm for solving games is based on taking the entire game tree and transforming it into a matrix  called the normal or strategic form of the game  various techniques such as linear programming can then be applied lo this matrix in order lo construct optimal strategies unfortunately this matrix is typically exponential in the size of the game tree making the entire approach impractical for most games 
　in recent work koller  megiddo and von stengel  present an alternative approach lo dealing with imperfect in formation games they deline a new representation called the sequence form whose size is linear in the size of the game tree they show that many of the standard algorithms can be adapted to find optimal strategies using this representation this results in exponentially faster algorithms for solving a large class of games in particular they present an effective polynomial time algorithm for solving two player fullv com pctilivc games  such as poker  we have implemented this algorithm as part of the gala system and tesled it on large examples of several games the results arc encouraging suggesting that in practice ihe running lime of the algorithm is a small polynomial in the size of the game tree 
　the final component of galapresenls theoplimal strategics in a way thai is comprehensible lo the user for any decision point in the game it lells the user which actions should be played with which probability the system also provides other information such as one player s beliefs about the stale of anolher agent or the expected value of a branch in the tree this functionality makes gala a useful tool lor game theory researchers and educators as well as for users who wish lo use gala as a game-theory based decision support system finally gala can also play the game according lo the computed strategy making il a basis for a computer game-
1 
playing system for imperfecl information games 
1 some basic game theory 
game ihcory is ihe strategic analysis of interactive situations several aspects of a situation are modeled explicitly the players involved the alternative actions that can be taken by each player at various limes  the dynamics of the situation ihe information available to players and die outcomes at the end given such a model game theory provides the tools to formally analyze the strategic interaction and recommend rational strategies to the players 
　the standard representation of a game in computer science is a tree in which each node is a possible stale of the game  and each edge is an action available to a player that takes the game to new stale at each node there is a single player whose turn it is to choose an action the set of edges leading out of a node arc the choices available lo that player the player may be chance or nature in which case the edges represent random events the leaves of the tree specify a payoff for each player this representation is inadequate for games with imperfect inlormation because it docs not specify the information states ol the players a player cannol distinguish between states of the game in which she has ihe same information thus any decision taken by the player must be the same at all such nodes to encode ihis constraint the game tree is augmented with information sets an information sel contains a set of nodes that arc indistinguishable lo a player at the time she has lomakc a decision 
　figure 1 presents part of the game tree for a simplified variant of poker described by kuhn  the game has two players and a deck containing the ihree cards 1 and 1 each player antes one dollar and is dealt one card the figure shows the part of the game tree corresponding lo the deals  1   1  and  i 1  the game has three rounds in ihe first round the first player can either bet an additional dollar or pass alter hearing the first player s bet the second player decides whether to bet or pass if player 1 passes and player 1 bets player 1 gets one more opportunity lo decide whclhcr or nol to bel if both bet or both pass the player with the highest card takes the pot if one player bets and the other passes then the betting player wins one dollar lei  t d  denote the hands dealt lo the two players initially  player 1 only knows his own card so for each possible c he has one information set 1e containing two nodes  each node corresponds to the two possibilities for player 1 s hand in her turn player 1 knows d as well as player 1 s action at the first round hence she has iwo information sets for each d- % and ld-corresponding lo player 1 s previous action finally player 1 has an information set u'c at the third round 
　given a game tree augmented with information sets  one can define the notion of strategy a deterministic strategy like a conditional plan in ai is a very explicit 'how-to-play manual that tells the player what to do at every possible point in the game in the poker example  such a manual for player 1 would contain an entry if i hold a 1 and i passed on the first round  and my opponent bets then bet 1   in general a deterministic strategy for player specifies a move at each of her information sets since the player cannot distinguish between nodes in die same information set the strategy cannot dictate different actions at those nodes 
　

figure i a partial game tree for simphlified poker  containing three of the six possible deals a move to the left corresponds to a pass a move to the right to a be   the information sets are drawn as ellipses some of them extend into other parts of the tree 
　
　deterministic strategies arc adequate for games with perfect information where the players always know the current stale of the game in those games the information sets of both players are always single nodes and a deterministic strategy s  for player   is a function from those nodes at which n is her turn to move to possible moves al that node the fact that deterministic strategics suffice for such games is the basis for the standard mint max algorithm  and us variants  used for games such ai chess in such games called zero sum games there arc two players whose payoffs always sum to zero so that one player wins precisely what the other loses as shown by zermelo  the strategies produced by the mimmax algorithm are optimal in a verv strong sense player i can not do better than to play the resulting strategy if the other player is rational furthermore she can publicly announce her intention to do so without adversely affecting her pay offs a generalized version of the minimax algorithm shows the existence of optimal deterministic strategics for general games of perfect information the resulting strategy com bination  ai s   has the important property of being in equilibrium for any j player i cannot pick a better strategy than 1  if the other players arc all playing their strategy s; this is a minimal property lhal wc want of a solution to a game without it we are drawn back into the web of second guessing that characterizes imperfect information games  if she plays the orthodox strategy then i should do y but she will figure out that this is better for me so she ii actually do 
i 	but then 	  
　it should be fairly obvious lhal deterministic strategies will in general not have dicse properties in games with imperfect 
information deterministic strategies are predictable and pre dictable play gives the opponent information the opponent can then find a strategy calculated to take advantage of this information thereby making the original strategy suboptimal unpredictable play on the other hand  maintains lhe informa uon gap therefore players in imperteci information games should use mndonuzed strategies 
　randomized strategies are a natural extension of delcrmin istic strategies where a deterministic strategy chooses a move at each information set a randomized strategy  formally called a behavior strategy  specifies a probability distribution over lhe moves at each information set in our poker example a randomized strategy m1 lor player 1 can be described by defining the probability of betting al each information set l'e and a combination of randomized strategies fi  one for each player induces a probability distn bulion on the leaves of the tree thereby allowing us to define 
the 	exptdidpu off for each player i 
　in his nobel prize winning theorem nash showed that the use of randomized strategies allows us to duplicate the sue cessful behavior that we gel from deterministic strategies in the perfect information case in general games there is always a combination  of randomized strategies that is in equilibrium for any i and any strategy fi   

that is no player gains an advantage by diverging from the equilibrium solution so long as lhe other players stick  o ll 
　just as in lhe case of perfect information games the equilibrium strategies arc particularly compelling when the game is zero-sum then as shown by von neumann f von neumann and morgenstern 1 any equilibrium strategy is optimal against a rational player more precisely the equilibrium p a i r s a r e precisely those where fi  is lhe strategy that maximizes max and ftj is the strategy that maximizes max  which since hi = -/i  is precisely min intuitively  fi  is the optimal defensive strategy tor player 1 k provides the best worst-case nayotf it is these strategies that we will be most conceded with finding 
1 gala a game description language 
as we mentioned lhe first component of gala is a knowledge representation language for describing games this is a prolog based language  thai uses the power of a declarative representation to allow clear and concise specification of games the idea of a declarative language to specify games was proposed by pell 1  who utilizes it to specify 
	kollerandpfeffer 	1 
　
symmetric chess like games-a class of iwo-playcr perfeclinformation board games our language is much more gen eral and can be used lo represenl a very wide class of games in particular one-player two-player ajid multi player games games where the outcomes arc arbitrary payoffs and game*  with either perfect or imperfect information as we will show the expressive power of gala allows for clear and concise game descriptions that arc generally of similar length to natural language representations of the rules of the game 
　to illustrate some of the features of gala figure 1 presents an example of a complete description for blind tic lac-loe an imperfect information version of standard tic-tac toe the player*  lake turns placing marks in squares  but in his turn a player can choose to mark either an x or an o he reveals lo his opponent the square in which he makes the mark but nol the type of mark used as usual ihe goal is to complete a line of three squares with the same mark 
　a game description in gala is a list of features each one describing some asped of the game for example players  a b  indicates that the game is to be played between two players named a and b 
　the gala language has several layers the lower ones pro vide basic primitives while the higher layers use those primi lives to provide more complex functionality the lowesl layer provides the fundamental primitives for defining the structure of a game the choose  p layer mo je constraint  primitive describes the possible moves available lo player at a given point in the game it allows player lo make any move move satisfying constraint this last argument can be an arbitrary segment of prolog code in our example move consists of a square specified by its coordinates x and y and a mark mark constraint requires lhat the square be empty and that mark be either x or o the first argumenl lo choose can also be nature in which case one of a number of events is chosen at random by default these random events have uniform probability but a different probability distribution may be specified the outcome primitive describes the outcome of the game at the end of a particular sequence of moves this will often be a list of payoffs one for each player but as the example demonstrates gala allows other possibilities the reveal  player 
fact  primitive describes the dynamics of the players information stales it adds fact lo player s information state the information added can be simple or an arbitrary prolog ex pression in blind tic tac-loe a player chooses both a square and a mark but reveals to his opponent only the mark 
　at a somewhat higher level the flow feature describes the course of the game the game can be divided into phases some may lake place just once while others can be repeated 
1 
　in order to allow a natural specification of the game  gala provides a separate representation for the game state where relevant information about the current state of the game is stored in blind tic-tac-loe the game state contains the currenl board position this information is accessed  for example  by choose in order lo determine which moves are possible only those squares that are empty are legal moves the game state is maintained by modifying it appropriately e g   by the place operation when the players make their moves much of the functionality in the higher levels of the gala language is devoted lo accessing and manipulating the game state 
　the intermediate levels of gala provide a shorthand for concepts that occur ubiquitously in games these include lo cations and their contents pieces and their movement patterns and resources that change hands such as money in blind tic lac toe the statements that deal with the contents of squares are an instance of locations and their contents other examples of functionality supported by this level are move queen white  
 d 1  	 d b   and pay gambler pot 	bet  
　on a more abstract level we have observed lhat certain structures and combinations appear in virtually all games while ihese are usually sets of one sort or another they come in many flavors for example  a flush in poker is a set of five cards sharing a common property a straight on the other hand is a sequence of cards in which successive elements bear a relation to one another a full house is a partition into equivalence classes based on rank in which the classes are of a specific size a word in scrabble and a 1 in blackjack are another type of combination a collection of objects bearing no particular relationship lo each other but forming an interesting group in totality 
　the prolog language provides a few predicates that describe sets and subsets we have supplemented these with various predicates thai make it easy to describe many of the combinations occunng in games for example  chain predicate set  determines whether sat is a sequence in which succes sive elements are related by predicate partition  relation set classes  partitions set into equivalence classes based on relation for a more elaborate example  consider the fol lowingcode which concisely tests for all types of poker hand except flushes and straights 
detailed partition match ran   	hand 	classes 	ranks 	sizes  
associate  sizes type 
	     1 	1  	four of a kind  	   1 	1  	full houae  
	  1 	1 	1  	three o♀ a kind  	  1 	1 	1  	two pairs  
	  1 	1 	1 	1 	one pair  	    1 1 1   	nothing    
　the predicate detailed partition takes two inputs a set- in this case hand-and an equivalence relation-in this case match-rank  which relates two cards if they have the same rank it partitions the set into equivalence classes and produces three outputs a list ciassed of the equivalence classes 
　
in decreasing order of size a corresponding list of the defin ing property of the equivalence classes in this case the ranks present in the hand and a list sizes of the sizes of the different classes 
1   t h e n classes w o u l d be | ranks would be  1  and sizes would be  1  in poker  sizes 
contains the relevant structure of the hand and it is used to classify the hand using an association list the above hand for example is immediately classified as a full house 
　the high level modules of gala build on the intermediate levels to provide more specifie functionality thai is common to a certain class of games such as boards that form a grid playmgcards dice and so on in the blind tic-tac toe example we declare a grid-board object this makes a whole range of predicates available that depend on the board being rectilinear the straight line predicate is an example it tests for a straight line of three squares containing the same mark this predicate is defined in terms of chain in general high level predicates 
are typically very easy to define in terms of the intermediate level concepts so that adding a module for a new class of games requires little effort 
　a useful feature of gala is that it allows some parameters of the game to be left unspecified in the game description and provided when the game is played in blind tic-lac toe the board size is such a parameter this makes it very easy to encode a large class of games in a singlt program these parameters can actually be code-containing features thus  it is possible to provide the movement patterns of pieces in a game at runtime this allows a simple interface between gala and pell s metagame program  pell 1  which generates symmetric chess like games randomly 
　given a description of a game in the gala language gala generates the corresponding game tree with information sets as described in section 1 the tree is defined by the choose reveal and outcome primitives the gala interpreter plays the game and constructs the game tree as it encounters these operations when it encounters a choose primitive a node is added lo the tree and an edge is added for every option available to the player the interpreter then explores each branch of the tree corresponding to each ol the options if the first argument lo choose is a player  the system also adds the node to the appropriate information set of that player the one that contains all the nodes where the player has the same information slate the information slate consists of all facts revealed lo the player by the reveal primitive the list of choices available to the player and all decisions previously taken by the player if the first argument to choose is random  then the node is marked as a chance node and the probability of each random choice is recorded when the interpreter encounters the outcome primitive it adds a leaf to the tree and 
backtracks to explore other branches 
1 solving imperfect information games 
how do we find equilibrium strategies in imperfect informa tion games  this is in general a very difficult problem consider the poker example from section 1 there we specified a strategy for each of the players using six numbers when trying to solve a game we need lo find an appropriate set of numbers that satisfies the properties we want that is we want to treat the parameters of the strategy as variables and solve for them the general computational problem is maximizex min y h x  y  subject lo x represents a strategy for player 1  *  y represents a strategy for player 1 
where h x y  denotes the expected payoff to player 1 if the strategies corresponding to x y arc played 
　it turns out that the heart of the problem is finding an appropriate set of variables for representing the strategy the first atlempl is lo use the move probabilities in the behavior strategy in the poker example we would then have x = representing player 1 s strategy  and representing player 1 s strategy the problem is that this payoff is a nonlinear function of the x s and y s in order to avoid this problem which would force us louse nonlinear optimization techniques the standard solution algorithms in game theory do not use game trees and behavior strategics as their primary representation rather they operate on an alternative representation called the normal form in the two player case the normal form is a matrix a whose rows are all the deterministic strategics of the first player and whose columns are all the deterministic strategies of the second the entry in the zth row and jth column is the expected payoff lo the players when player 1 plays strategy s'| and player 1 plays strategy  a randomized strategy can now be viewed as a probability distribution over all the deterministic strategies hence x is simply a probability distribution over rows it has a variable t  for each row such that  for all i and  if player 1 plays aand player 1 plays y then lhe expected payoff of the game is simply ay under this representation of strategies takes aparticularly simple form it is then fairly easy lo show that that appropriate vectors s and y can be found from a using standard linear programming methods 
　for non zero-sum games the normal form also forms the basis lor essentially all solution algorithms gala provides access to the normal form algorithms using an interface to the gambit system developed by mckelvey and turocy  mck eclvey  1  gambit provides a toolkit for solving various classes of games including games with more than two players and games where the interests of the players arc not strictly opposing since gala allows a clear and compact specifi cation of such games the combined system provides both a represenlation language and solution algorithms for games describing multi agent interactions 
　unfortunately the normal form algorithms arc practical only for very small games the reason is that the normal form is typically exponential in the size of the game tree this is easy lo see a determinitic strategy must specify an action at each information set the total number of possible strategies is therefore exponential in the number of information sets which is usually closely related to the size of lhe game tree consider our poker example generalized lo a deck with k cards for each card c player 1 must decide whether to pass or bet and if he has the option whether lo pass or bet at the third round there are three courses of action for each c so the total number of possible strategies is 1k player 1 on the other hand  must decide on her action for each card d and each of the two actions possible for the first player in the first round the number of different decisions is therefore 1k so the total number of deterministic strategies is  since the normal form has a row for each strategy of one player and a column for each strategy of the other it is also exponential 
	koller and pfeffer 	1 
in k while the size of the game tree is only 1k + 1 in general the normal form conversion is typically exponential in terms of both time and space 
　this problem makes the standard solution algorithms an unrealistic option for many games due to the large branching factor in many games even the approach of incrementally solving subtrees would not suffice to solve this problem  this approach also encounters other difficulties in the context of imperfect information games see section 1   recently a new approach to solving imperfect information games was developed by koller megiddo and von stengel  this approach uses a conversion to an alternative form called the se quence form  which allows it to avoid the exponential blowup associated with the normal form we will describe the main ideas briefly here for more details see  koller et al 1  
　the sequence form is based on a different representation of the strategic variables rather than representing proba bilities of individual moves  as in the non linear representa lion above  or probabilities ol full deterministic strategies  as in the normal form  the variables represent the realiza tion weight of different sequences of moves essentially a sequence for a player corresponds to a path down the tree but it isolates the moves under that player's direct control ignoring chance moves and the decisions of the other players in our poker game for example player 1 would have 1k + 1 sequences in addition to the empty sequence  which corre sponds to the root of the game  he has four sequences for each card c  bet on c   in which case there is no third round   pass on c    pass on c  bet in the last round  and  pass on c pass in the last round  player 1 also has 1k + 1 sequences the empty sequence and for each card d the four sequences  bet on d alter seeing a pass   pass on d after seeing a pass   bet on d after seeing a bet   bet on d after seeing a bet  given a randomized strategy the realization weight of a sequence for a player is the producl of the probabilities of the player s moves encoded in the sequence essentially the realization weight of the sequence corresponding to a path down the tree is a 
　conditional probability the probability that this path is taken given that the other players and nature all cooperate to make this possible the probability that a path is actually taken in a game is therefore the product oi the realization weights of all the players sequences on that path times the probability ot all the chance moves on the path 
　the sequence form of a two player game consists ol a payoff matrix a and a linear system ol constraints for each player in a two player game the zth row ot a corresponds to a se quence a  lor player i and the jth column to a sequence cr  for player 1 the entry atj is the weighted sum of the payoff al the leaves that are reached by this pair of sequences  they are weighted by the probabilities of the chance moves on the path  if a pair of sequences is not consistent with any path to a leaf the malnx entry is zero so lor example the matrix entry for the pair of sequences  bet on 1  and  pass on 1 after seeing a bet  is 1 the matrix entry for the pair  bet on 1  and  pass on 1 after seeing a pass  is 1  since this pair is not consistent with any leaf 
　we now solve  *  using realization weights as our strategic variables we will have a variable x 1 | for each sequence a  of player 1  and a variable y 1 for each sequence a1 of player 1 using the analysis above we can show that the expected payoff of the game h x  y  is xt ay this is pre 
1 
usely analogous to the expression we obtained for the norma  form it remains only to specify constraints on x and y guaranteeing that they represent strategies for the norma  form these constraints simply asserted that these vectors represent probability distributions in this case  the constraints are de nved from the following fact if is the sequence for player: leading to an information set al which player i has to move ' and m    m* are the possible moves at that information set then we must have that  the only other constraints are that the realization weight of the empty sequence is 1  because the root of the game is reached in any play of the game  and that for all r 
　note that the sequence form is at most linear in the size of the game tree since there is at most one sequence for each node in the game tree  and one constraint for each information set furthermore  it can be generated very easily by a single pass over the game tree the format of the sequence form resembles that of the normal form jn many ways and it appears thai many normal form solution algorithms can be converted to work for the sequence form the work of  koller et al 1  focuses on the two playercase they provide sequence form variants for ihe best normal form algorithms for solving both zero-sum and general two player games the resull which is of most interest lo us is the following 
theorem 1 the optimal strategies of a two player zero sum game are the solutions of a linear program each of whose 
dimensions is linear in the size of the game tree 
　the matrix of the linear program mentioned in the theorem is essentially the sequence form the resulting matrix can then be solved bv any standard linear programming algorithm such as the simplex: algorithm which is known to work well in practice we can also use a different linear programming algorithm whose worst-case running time is guaranteed lo be polynomial hence this theorem is the basis for an efficient polynomial time algorithm for finding optimal solutions lo two player zero sum games 
1 experimental results 
the sequence-form algorithm for two-player zero sum games has been fully implemented as part of the gala system the system generates the sequence form creates the appropriate linear program and solves it using the standard optimization librarv of cplex we compared this algorithm to the tradi tional normal form algorithm by using gambit lo convert the game trees generated by gala to the normal form  and cplex lo solve the resulting linear program we experimented with two games the simplified poker game described in section 1 increasing the number of cards in the deck and an inspection game which has received significant attention in the game theory community as a model of on site inspections for arms control treaties lavenhaus et al 1  the resulting running times are shown in figure 1 they are as one would expect in a comparison between a polynomial and exponential algorithm 
　these results arc continued for the sequence form in figure 1  it was impossible to obtain normal-form results for the larger games   there we also show the division of time be iween generating the sequence form and solving the resul ting 
　　this formulauon requires that the players never forget their own moves or information they once had this implies that there is at most one sequence o leading lo this information set 
　

figure 1 normal form vs sequence form running time 

figure 1 time for generating and solving the sequence form 
　
linear program tor the poker games we can see that generating the sequence form lakes the bulk of the time solving even the largest of these games lakes less than 1 seconds tins leads us to believe lhal these techniques can be made to run considerably faster by optimizing the sequence form generator finally note that the algorithm is much faster for poker games than for the inspection games in the lull paper we explain these results and define certain characteristics of a game lhal lend to have a significant effect on the running time of the sequence-form algorithm 
　as we remarked above the final component of the gala system reads in the strategies computed by this algorithm and interprets them in a way that is meaningful with respect to the game in particular it allows the strategies to be ex amined by the user who can then use them as part of ihe decision making process we have discovered that examin ing these strategies often yields interesting insights about the game figure 1 shows the strategies for both players in an eight card simplified poker consider the probability that the gambler bets in ihe first round n is fairly high on a 1 somewhat lower on a 1 on the middle cards and then goes up for the high cards the behavior for the low cards corresponds to bluffing a characteristic lhal one lends to associate with the psychological makeup of human players similarly after seeing a pass in the first round the dealer bets on low cards with very high probability psychologically we interpret this as an attempt lo discourage the gambler from changing his mind and belling on the final round in more complex games we sec other examples where human behavior  eg underbidding  is game-theoretically optimal 
1 	discussion 
as in the case of perfect information games game trees for full-fledged games are often enormous although we expect to solve games with hundreds of thousands of nodes in the near future full-scale poker is much larger than thai and it is unlikely we will be able to solve it completely of course chess-playing programs are very successful in spite of the fact lhat we currently cannot solve full-scale chess can we apply the standard game-playing techniques to imperfect information games' we believe that the answer is yes but the issue is noninvial even the concepl of a subtree' is not well defined in such games for one thing the program cannot simply crcalc the subtree starting at the current state since it does not know precisely which node of the game tree is the actual slate ol the game it knows only that the node is one of those in a certain information set in addition information sets belonging to other players may cross the subtree boundary' as was the case in figure 1 it is not obvious how to deal with these problems we hope lo address this issue in future work another approach that may well prove fruitful is based on the observation that there is a lot of regularity in the strategies 
	koller and pfeffer 	1 
　

figure 1 strategies for 1 card poker 
　
for small poker garnes the player often behaves the same tor a variety of different hands this suggests thai in order lo solve large games we could abstract away some features of the game  and solve the resulting simplified game completely for the game ot poker we could abstract by partitioning the set of possible deals into clusters and then solve the abstracted game our experimental results indicate that the resulting strategies would be very close to optimal 
　most of the techniques we discussed in this paper also apply to more general classes of games gala prov ;des the functionalily for specifying arbitrary multi-player games currently these can only be solved using the traditional  normal-form  algorithms accessed through our gambit interface and these are practical only for small games however the sequence form can be used to represent any perfect recall game and the results of ikoiler et al 1  indicate that many of the stan dard techniques could carry over from the normal form to the sequence form we hope lo use the sequence form approach for more general games and show that the resulting expo nenlial reduction in complexity indeed occurs in practice if so the resulting system may allow an analysis of multi-player games a class of games that have been largely overlooked perhaps more importantly the system could also be used to solve games that model multi-agent interactions in real life 
　we believe that the gala system facilitates future research into these and other questions its ability to easily specify games of different types and lo generate many variants of each game allows any new approach lo be extensively tested we intend lo make this system available through a www sile  http ''www cs berkeley edu'  daphne gala'  in the hope that it will provide the foundation for other work on imperfect information games 
acknowledgements 
we are deeply grateful to richard mckelvey and ted turocy for going out of their way to ensure that thegamblt functionality we needed for our experiments was ready on time we also thank the international computer science institute at berkeley for providing us access lo the cplex system we also wish to thank nimrod megiddo barney pell stuart russell john tomlin and bernhard von stengel for useful discussions 
1 	learning 
