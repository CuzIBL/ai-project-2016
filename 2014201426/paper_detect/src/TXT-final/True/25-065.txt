 
we introduce a logic-based system which improves the performance of intelligent help systems by supplying them with plan generation and plan recognition components. both components work in close mutual cooperation there are two modes of cross-talk between them  one where plan recognition is done on the basis of abstract plans provided by the planner and the other where optimal plans are generated based on recognition results the exam pies which are presented are taken from an operating system domain  namely from the unix mail domain 
1 	introduction 
intelligent help systems aim at providing advanced active help to the users of complex software systems  cf. 
 breuker  1; thies and berger  1; norvig et al.  1    the performance of these help systems can inconsiderably improved if they are supplied with plan recognition and plan generation capabilities observing a user and recognizing his goals enables the system to help by taking into account the current state of the system as well as the users level of education and current behavior moreover  if a planning capability is available user-specific support can be given by proposing appropriate plans which exactly is what the phi system aims to achieve1 
   phi  cf. the figure below  is a tool for intelligent help systems. it provides both a plan recognizer and a planning component and one of its main characteristics consists in the close mutual cooperation between the two components 
   there are several cross-talk modes. the first one is devoted to realizing plan recognition on the basis of abstract plans produced by the planner abstract plans are those which represent a variety of 'concrete  observable action sequences by admitting several degrees of freedom like variables  abstracting from the objects m volved   abstract commands  abstracting from the names 
   *this work w;ts supported by the german ministry for research and technology  bmft  under contract itw 1 as part of the phi project. 
1 	intelligent tutoring systems 
of actions which have the same effects   or temporal abstraction  abstracting from the point in time at which an action occurs . 
   the generation of plans is based on standard assumptions concerning goals that typically occur or are specific to a certain user. abstract plans are generated from these formal plan specifications in doing so  the planner not only performs planning from first principles but is able to recuse already existing plans which are stored in a library  planning from second principles . the plans provided serve as plan hypotheses in the recognition process. taking abstract plans instead of concrete ones keeps the hypothesis space of manageable size the plan hypotheses are passed to the recognition component  where they are provided with numerical values which reflect the probabilities of their being confirmed by the subsequent observations. these a priori probabilities mirror a specific users behavior  and are taken from the user model. having observed the user's actions step by step the plan recognizer consequently tries to confirm the plan hypotheses by proving that the action sequence observed up to now is an admissible  instance . hypotheses which are not confirmed are rejected and with that the probability distribution of the hypothesis space changes dynamically. 
   in the first cross-talk mode the plan recognizer is able to determine the most  likely plan a user follows by carrying out appropriate 'instantiations'1 on valid plan hypotheses thus  services like semantic plan completion can be offered at any time during the observation process. 
　the second cross-talk mode is devoted to providing the user with optimal plans whenever suboptimal behavior has been recognized or aid has explicitly been sought. 
   the system is completely logic-based. it requires a proper axiomatization of the basic commands of the application system and certain domain constraints. the logic llp which we have developed for that purpose combines features of both traditional programming and temporal logics the plan generation and recognition components are special purpose inference procedures. plan generation is done deductively using a sequent calculus for llp  whereas plan recognition follows an abductive principle. 
　the application domain  from which we present examples  is a subset of the operating system unix  namely its 



	bauer et al. 	1 


is obtained as a result in a plan recognition example  cf. section 1  this plan can then serve as one of the plan hypotheses. 
1 plan generation 
the planning system  cf.  biundo et al.  1   works by using techniques of planning from both first and second principles. planning from first principles begins with a plan specification. the plan is generated on the basis of the domain knowledge provided. planning from second principles adds the ability to incorporate previously generated plans and the problem solving knowledge obtained thereby. in the first cross-talk mode  abstract plans are generated in order to provide the plan recognizer with plan hypotheses. to generate these hypotheses  the planner works from second principles by reusing formerly generated plans 
1 	planning from first principles 
by using a sequent calculus for llp  cf.  biundo and dengler  1   the plan generator tries to find a constructive proof for the plan specification formula so that an instantiation for the plan metavariable can be obtained. we thus have a plan the execution of which is sufficient to reach the goals specified  i.e.  a plan which meets the specification following the paradigm of tactical theorem proving  cf  constable  1    lleisel et al.  1    paulson  1   the proof is guided by special planning tactics written in a metalogical tactic language. as for plan specification  1   the proof is carried out by dividing the specification formula into subformulas  i.e.  those representing single subgoals which the plan has to reach we can simultaneously introduce a structure into the plan metavariable plan  which states that. plan should consist of at least two suhplans: 
let us now consider the generation of a plan for p1 
the corresponding subgoal reads 

usually subgoals of tins type are proven by using nonlogical axioms which describe basic actions. thereby  the plan metavariable is instantiated by a basic plan formula the instance of the type axiom below is selected because it can reach the desired goal of setting 
　the preconditions of this action however must hold in order to make the axiom applicable. one of these preconditions is missing from the subgoal above. following a deductive version of the means-ends analysis  cf  fikes 
1 	intelligent tutoring systems 
and nilsson  1l    nilsson  1   we therefore introduce an additional subplan which produces the missing precondition. thus  p1 becomes the composition of a one-armed conditional and a subplan p1  respectively: 

the new subgoal obtained is: 

to properly instantiate p1 an instance of the undelete action axiom can be used; this tells us that the execution of undelete x  m  makes  true in the next state  should it not have held before. in a similar way p1 can now be instantiated by using the type action axiom. the overall plan which results after the proof tree has been completed and all plan metavariables have been instantiated  is the plan given by formula  1  above. it clearly meets the specification in  1 . 
　in addition to subgoals whose proof leads to instantiations of the plan metavariables  as in the above examples  
so-called plan assertions must also be proven. these represent certain properties which are required by the plan to be generated. a typical example in our case is the fact that the formula of  m  = t-which acts as a precondition to the whole plan does survive the execution of subplan p1. this fact is proven by regression where we generate the weakest preconditions of of m  = t 
w.r.t. all basic actions occurring in p1. in our system  planning from first principles is  like several other approaches to deductive planning  cf.  green  1    bibel  1    manna and waldinger  1   closely related to work done on deductive program synthesis where programs are generated by proofs  cf.  manna and waldin-
ger  1   heisel et al  1    biundo  1  . 
1 	planning from second principles 
the ability of a planner to modify a plan is considered as a valuable tool for improving the efficiency of planning by avoiding the repetition of the same planning effort because instead of generating a plan from scratch  plan reuse tries to exploit knowledge stored in previously generated plans. 
　the reuser first takes the current specification and searches in a plan library for a plan which can be reused as its solution since we concentrate on plan modification in this paper  we suppose that the search in the plan library terminates successfully with a plan specification and describe how the reuser verifies whether the plan belonging to it provides a solution to the current planning problem. the verification is carried out by a formal proof in which the prover verifies that at least the preconditions the plan requires hold in the current situation and that at most the goals achieved by the plan are required as current goals. 
　if the proof succeeds  the plan provides a provably sound solution to the current planning problem; if it fails  the plan has to be modified. 
　the modification tactics analyze the failed proof and modify the plan using information from the generation process that lead to this plan. 
　let us assume  for example  that specification  1  is given to the planner in the first cross-talk mode. planning from second principle starts and tries to reuse plan 
　comparing it with specification  1  it is obvious that more preconditions are given  but even more goals are required in  1 . in this case  the prover reports a failure because more goals are required in specification  1  than are achieved by the plan. the modification tactic identifies the missing subgoal  for which a 
subplan has to be generated from first principles furthermore  it has to inspect the temporal structure of the plan to be reused in order to determine the point in time at which this subplan has to be inserted. for this purpose  explicit representations of the temporal models of both specifications are constructed and compared during the proof. 
　a plan is a solution if it achieves at least all the goals that are required in the current specification  i.e.  if the plan achieves some additional subgoals it is still considered to be a solution in some applications however  plans have to be minimal in the sense of achieving exactly the goals required. the plan reuse component is able to perform the necessary optimizations in these cases 
　in the example  the reuser detects that the case analysis in the reused plan is superfluous because the condition on which it depends is explicitly given in the specification. therefore  the conditional can be deleted from the plan the result of the modification process is a plan skeleton for a sequential plan 

containing the reusable subplan identified during the proof and a meta variable plan1 as a  placeholder'' for the completing subplan which has to be generated in order to reach the additional goal. 
　the generator uses the plan skeleton as a partial instantiation of the plan metavariable plan in specification  1 . this simplifies the constructive proof of the specification: the partial proof tree for which an instantiation of the metavariable is already known can be easily expanded without further search effort. to replace the metavariable plan1 occurring in the skeleton  the generator has to plan from first principles leading to the instantiation  the interleaving 
of proof tree reconstruction and generation ensures that the modified plan provides a provably sound solution to the current plan specification that can be sent to the plan recognizer as a plan hypothesis. 
　the approach we follow investigates plan reuse in the general context of deductive planning and has been described in more detail in  biundo et a/.  1; koehler  1 . other current approaches investigate plan reuse and modification in the framework of classical stripslike planners  e.g.  the hierarchical planner and modification system priar  kambhampati and hendler  1   or in the framework of case-based reasoning  e.g.  the systems spa  hanks and weld  1  or chef  hammond  1 . the experiments reported by some of the authors give evidence that plan reuse might indeed be more efficient than planning from scratch. how far these results generalize is studied in a complexity-theoretic analysis of plan modification vs. plan generation by nebel and koehler  cf. these proceedings . in contrast to practical experiences it turned out that plan modification is not uniformly as easy as planning from scratch. 
1 	generating optimal plans 
the second cross-talk mode is concerned with the generation of optimal and user-satisfactory plans. the generator receives a plan specification which either belongs to a plan recognized as suboptimal by the plan recognition component or is derived from a request for passive help. 
　planning in this mode is based on a dynamically changing adjustment of the generation process triggered by plan quality criteria derived from the user model. the generator considers  e.g.  the user's p