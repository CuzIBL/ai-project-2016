 
abstract 
this paper presents an improved method of explaining prolog-based expert systems. the key idea is to make explicit failures during the computation. this allows the integrated explanation in a single interpreter of both successful and failed computations. it also allows rules containing cuts to be effectively explained. furthermore  the explanation system is interactive  and allows full explanation of both successful and failed partial computations. we discuss in some detail a two-layer meta-interpreter which is at the heart of the system. 
1 	constructs for explanation 
in recent years  several systems have been developed for explaining the execution of prolog. applications of these systems have ranged from teaching prolog  brayshaw and eisenstadt  1   debugging prolog  pereira  1  shapiro  1   to presenting the results of prologbased expert systems   clark and mccabe  1  hammond  1  niblett  1  sterling and lalee  1  walker et a/.  1  yalqinalp and sterling  1 . in each case  extra mechanisms were added to make explicit the relevant features of prolog's backward chaining behavior. 
　for example  the following constructs are needed to give mycin-like explanations of expert systems written as collections of simple prolog clauses. proof trees represent successful branches of the search tree which is implicitly generated and traversed during a prolog computation. after completion of the computation  a proof tree is presented in a suitable format to answer questions about how a solution is computed. history lists represent the current branch of the search tree being traversed and are implemented as a stack of successive goals investigated up to the current goal. whenever the user is consulted for information  for example to find a missing fact  which might be used to prove or refute the particular goal in question  she is allowed to inquire why 
   *this research was supported under nsf grant no. 1-1  and equipment grant no. dmc 1. 
she is being consulted. more detailed information about these constructs can be found in  sterling and shapiro  1 . 
　failure trees represent failure branches of the search tree that have been traversed during the computation. a variety of techniques have been used to selectively collect such failure branches  all of which are based on separate interpreters for successes and failures  bruffaerts and henin  1  hammond  1  sterling and lalee  1  
walker et a/.  1 . failure trees are used to answer whynot questions. 
　these constructs can be added directly to each clause in the prolog program  clark and mccabe  1 . a better approach is to write an enhanced inetainterpreter with the appropriate functionality. most of the work cited above uses the standard four clause metainterpreter at the clause reduction level  sterling and shapiro  1 . 
　two classes of explanations based on these constructs can be differentiated. how and whynot explanations are provided after the computation. why explanations  on the other hand  are given during the computation. 
　this paper addresses two major limitations with current explanation systems based on the variants of the meta-interpreter at the clause reduction level. the first is their inability to explain adequately extra-logical prolog predicates  such as negation and cut. we don't accept the solution adopted in  bruffaerts and henin  1  sterling and lalee  1  for explaining negation using a totally separate program. limitations arise from the way the control flow is being modelled by the metainterpreter. the abstraction of the computation in the systems above does not allow the failure mechanism of prolog to be properly represented and controlled during this computation. 
　the second limitation arises from the difference between the view of the computation presented to the user during the computation and that after the computation. specifically  when answering a why question  the user only sees the sequence of rules/clauses currently being investigated  but not completed or failed portions of the computation in different parts of the search tree. in other words  the user is not presented with a global picture. in contrast  how and whynot explanations present a complete computation. 
in this paper  we describe a two-layer meta-interpreter with a different abstraction of the control flow than the standard meta-interpreter. the new meta-interpreter allows proper explanations of extra-logical predicates such as the cut. further  by introducing the concept of partial proof trees  it treats explanations given both during and after the computation uniformly  and faithfully to prolog's computation model. 
1 	a two-layer meta-interpreter 
a good explanation depends on a good representation of the computation at an appropriate level of abstraction. the major limitation of current explanations of prologbased systems stems from handling failure too implicitly. failure in prolog is composed of two different events. first  a failure occurs when a particular goal fails to unify with any of the existing clauses in the program. this failure causes backtracking to generate alternative solutions. second  if all backtracking efforts result in failure for all clause definitions of a goal  prolog answers  no . 
　the inability to unify  and the exhaustion of alternatives for a goal are implicitly used in most reported work  but not explicitly represented. the standard meta-interpreter can be augmented with a result variable to make it fail-safe  levi and sardu  1  sterling and lakhotia  1 . this makes fail ure information available but changes the behaviour of prolog. 
　prolog's behaviour can be kept while maintaining explicit failures by building a meta-interpreter in two layers. we call the first layer of the interpreter the goal layer  while the second layer is called the branch layer. the goal layer uses the predicate solve branch to generate each possible computation of the goal being solved. the result of the computation  either yes or no  is returned by the second argument of solve.branch. note that the solve  branch layer is fail-safe. this result is then filtered by the goal layer to recover prolog's behaviour. its essence is captured in the predicate  solve.goal  defined as follows. 
solve goal goal result   - sol ve branch  goal  result   filter failure result . solve goal goal no . 
filter failure yes . filter failure no   - fail. 
　the branch layer is similar to the standard metainterpreter at the clause reduction level. the complete code for the two-layer interpreter is given in figure 1. the scope of the interpreter is given by the clauses for solve branch. in particular  it covers conjunctive goals  system goals  negated goals  single goals  namely rules   conditionals  set predicates  such as findall and askable goals. 
　note that the two events involved in prolog's failure mechanism have been made explicit. failure to unify is indicated by a solve branch clause  which returns a  no . this occurs when none of the clauses in the database are unifiable with the current goal. this is recognized by using the negation of the built-in clause goal body  in prolog. backtracking is initiated by the failure of filter  failure. this explicit representation of failure will be used in extending the interpreter later. 
　this two-layer interpreter follows the computation model of prolog faithfully. failure can be controlled and used to represent the result of a computation. further  all computation is handled by a single interpreter. there is no reason to wait for the result of computation for a goal to detect failures  as in other systems  bruffaerts and henin  1  sterling and lalee  1 . the computation  as in prolog  is performed only once  which allows the interpreter to correctly handle programs with side-effects. 
　the presence of two layers makes it straightforward to handle negation-as-failure correctly  as follows: 
solve branch not goal result   - solve goal goal result-not   !  invert result not result . 
invert yes.no . invert no.yes . 
　we next demonstrate how the two layer approach facilitates the handling of cuts. a third result is used  namely commit  which represents a special type of failure due to 
commitment in the body of a clause. in the branch layer  prolog's clause ordering is exploited to achieve the desired result. 
solve branch ! yes . solve branch ! commit   - !. 
　obtaining a commit result at a branch can affect the program in two ways  depending on the type of the goal. 
  for a series of conjunctive goals   - p1  p1 ...  pi  ...  pn  a cut can be any of these goals in the body. we retain the value of the computation  namely commit  as a failure occuring due to a commitment for the entire conjunction and inform the parent goal. if the cut is the final goal  pn  then the result of the computation will be commil by the solve.branch clause above. if this goal is pi and the result of the computation of pi+1 ...  pn is  no   then the result of the computation in the branch layer is commit. this is then handled in the goal layer of the interpreter  as seen in figure 1. 
  for a single goal  a commitment at the branches means an immediate failure as it is the parent goal. that means a commit result for a branch of the single goal actually indicates a no result in the goal layer  and the goal should no longer investigate other possibilities via different clause definitions in the branch layer. 
handling cuts correctly is achieved by modifying fil-
----failure and solve.goal now  filter failure acts as another  port  for indicating overall failure upon commitment by returning a ''no  result for a single goal. solve goal is altered to make the interpreter actually commit itself by placing a cut in the goal layer. this prevents backtracking of the interpreter back to the branches wliich generate alternative solutions. the modified goal layer is represented in figure 1. 
	sterling and 	yalcinalp 	1 

% goal layer 

figure 1: the layered interpreter 

　to handle the effect of cuts on instantiating variables correctly  a copy of the goal is needed. since the commitment would instantiate the actual goal  the bindings will be propagated within the tree. in order to be faithful to the execution process  the actual goal should be uninstantiated upon failure. to have a uniform structure  the copy of the actual goal is used for creating the branches and explicit unification with this goal happens upon success. 
   other control predicates can be handled in our framework. for example  the extension for the if-then-else construct  p -  q r  is immediate. the interpeter uses the result of the goal defining the conditional part  if  to define and control the result of the branch defining the the construct. it is shown in the full interpreter in figure 1. 
1 explanations generated by the layered meta-interpreter 
an extra argument  proof  is used for collecting proofs in the branch layer of the interpreter. this is a standard technique discussed in  sterling and shapiro  1  and used in  bruitaerts and henin  1  sterling and lalee  1  yalcinalp and sterling  1   etc. the proofs  both of successes and failures  arc transmitted to the goal layer at this layer's exit points. 
　the exit points of the goal layer are filter .failure  upon success or failure due to commitment  and the second clause of solve .goal upon ultimate failure of the goal. since this interpreter does not know in advance whether a goal will ultimately fail or not  the proof is kept by the goal layer when a  no  result occurs in the branch layer. if there is no commitment  the alternative solutions are generated by imposing failure. upon generating a success  a  yes  result by the branch layer  all the previously encountered failures are discarded since they are not relevant. however a failure  which occurs by commitment or ultimate failure of all branches  enables the interpreter to collect the proofs of all the failure brandies that are previously stored. the method is shown below: 
solve goal goal result proof   - 
copy goal.copy   solve branch  copy  bresuit  b proof    bresult = commit -  !;true   filter failure brcsult  result  copy.goal.bproof  proof   
solve goal goai no fail goal failures    - 
get proof  goal  failures . 
filter failure yes yes  copy  goal  proof  proof   - get proof  goal  failures   goal = copy. 
filter failure no   copy   bproof     - 
store copy bproof   !  fail. 
filter failure commit commit  copy  goal  proof  proof   - 
non singular goal  !. 
filter failure  commit  no  copy  goal  proof  
fail  goal  failures  *- 
% for single goals get proof goal  prev.failures   append prev failures commit  copy  proof   failures . 
there are two reasons for using a copy of the goal. 
first  we are interested in keeping the actual uninstantiated goal and instantiate it as necessary. this is to handle the effect of cut on committing to bindings as explained above. second  for failures  the structure fail goal  failures  is used to collect the proofs of failures for the actual goal goal  where failures is a list of failures of this goal. later  during explanation  the actual goal in this structure is used to resolve the variable differences in the tree by the scope information in the proofs of failure. 
　the non singular predicate checks whether the given goal is a construct  such as a disjunction  conjunction  ifthen-else or the cut  in fact any tiling other than a single goal defined as a set of clauses in the program. since commitment is propagated in prolog in these constructs  the interpreter must also adopt this behaviour. upon checking the goal  filter failure either propagates commitment or decides that a single goal ultimately fails and collects all the failures. 
　as mentioned earlier  generation of explanations actually depends on a good representation of the computation. with an appropriate representation such as a proof tree  stilted english statements can be formed using straightforward techniques  described for example in  sterling and shapiro  1 . similar techniques are used to make the proofs of computation collected by the two-layer interpreter more understandable. 
　instead of providing a full  trace  of the entire program  any of the subgoals within the body of the currently investigated clause can be chosen for further explanation. this method allows the user to navigate the tree as desired and the explanation for each clause is given upon demand. in addition  it is possible in our explanation system to reinvestigate the computation process by starting from the top goal at any point  or go back to the previous rule which has been investigated. 
　let us illustrate the form of explanation generated with an example. consider the simple program below that defines hypothetical rules for ph.d. candidacy. a student is required either to take the qualifying test and pass  or to take advanced courses and achieve a sufficiently high grade point average. 
candidacy x   - 
phd student x   qualified in math x . 
qualified in math x   - has taken test x math  !  passed test x math . 
qualified in math x   - has advanced courses x y   !  satisfies gpa x y . 
has taken.test person subject   - exam  person subject  date . 
passed test person subject   - result person subject  date pass . 
phd student jim . exam jim math jan 1 . 
resultjjim.math jan l1 fail . 
	sterling and yalcinalp 	1 
the query  ~candidacy jim  gives a  no  answer. the explanation provided from the system is as below. user responses are italicized. 
candidacyjim  fails because in the clause definition 
1. phclstudent jim  succeeds. 
1. qualified in math jim  fails. 
    1. 
qualified in math jim  fails because in the clause definition 
1. has taken test jim math  succeeds. 
1. passed test jim math  fails. 
and the goal qualified in.math jim  is committed to this clause because there is a cut after has taken test.     applicable jrules. 
1 rules in the database match the current goal. 
the computation is committed to the 1st  current clause . 
therefore  the clause below is not reachable: qualified in math jim   - has advanced courses jim y   !  satisfies gpa jim y . 
    1. 
passecltest jim math  fails because in the clause definition 1. result jim math date pass  fails. 
    1. 
this goal does not match with the clause s  of result/1. 
there is 1 fact in the database for result/1: 
result jim  math jan 1  fail .     quit. 
as can be seen from the example  the user can further investigate the reasons of success or failure for each goal. it is possible to request further explanation regarding which clauses for the goal qualified in math jim  are not considered as alternative choices due to the presence of the cut. further meta-knowledge about facts  such as result/1 will enhance the explanation capabilities. 
　the interpreter has been extended to generate detailed explanations for arbitrary prolog programs. other features can be easily integrated to this shell  as in a previous version  yalcinalp and sterling  1   to provide history and depth information. 
1 	explaining partial computations 
the answer a user provides to a request for information may depend on what has transpired in the computation so far. alternatively  as in an expert system for motor selection being developed at case western reserve university  discenzo et a/.  1   the user may demand to see the history of the computation when answering a why question. in either case  a  global picture  of the computation must be provided. 
　recall that a full description of the computation after it terminates is contained in a proof tree. a fully instantiated proof tree is not available for explanations during the computation. however  a partially instantiated tree which has full branches for completed portions of the computation and uninstantiated nodes for incomplete portions can be made available. we call this structure a partial proof tree. it is similar to the partially specified tree described in  pereira and shieber  1  for representing dcg parse trees during the parsing process. 
a partial proof tree is easily generated by adding two extra arguments to the interpreter in figure 1. the first argument represents the partial proof tree. it is different from the proof argument described in the previous section and used in  sterling and lalee  1  yalcinalp and sterling  1  because it can be accessed at any time during the computation. the branches are generated as a structure by using the second argument which shows the current node of the partial proof tree. the tree is instantiated at its leaves  when computation finitely succeeds or fails. in the beginning of the computation  these two additional arguments represent the same entity  the uninstantiated tree  by the query : 
 - solve goal goal  tree  tree  result . 
　the nodes are generated in the branch layer during the computation by the second extra argument and the full partial proof tree is passed to all layers of the computation. for example  the partial proof tree is generated as follows for a conjunctive goal in the branch layer: 
solve branch  a b  tree  pa pb  result  - !  solve goal a tree pa ra   solve branch and ra a  result  b.tree.pb . 
　when additional information is required by the interpreter  the user interacts with the system during the computation  by the last clause of solve.branch that represents askable goals. a how explanation of the partial proof tree can be presented during the computation. this is handled by passing the argument that represents the partial proof tree to investigate .goal which provides the how explanation. however  the explanation incorporates the partial instantiations for clauses and informs the user which goals which have not yet been solved. 
1 	conclusions 
the expressive power of the two-layer interpreter has been illustrated in the previous sections. the execution 
of the interpreter is faithful to prolog's execution  allowing the collection of information about the reasons for failure  including branchies having been pruned due to cuts. the execution does not require prior knowledge of success and failure as in  bruffaerts and henin  1  sterling and lalee  1  and all the computation is handled by a single interpreter. we have also shown the utility of generating partial proof trees. this allows explanations to the user about the full computation both during and at the termination of computation. 
　the two-layer interpreter can be modified  we believe  to handle debugging systems in the style of shapiro's algorithmic debugging  shapiro  1  as well as explanation systems. at the moment  the clauses that are not defined in the database are reported to the user as well as the clauses defined but do not match with the current goal. in addition  inaccesible clauses due to commitment are also noted. hence  deguggers can benefit from this knowledge. 
　our work can further be extended to explain prolog programming cliches which have primarily a procedural reading. for example  a failure-driven loop  defined as follows  is a common construct. 
p- p 1   p 1   - f a i l -
p. 
　the success of the last clause is meaningful only in relation to the repeated failure of the previous clause. by recognizing this construct as a special case  the proof tree kept for explaining the final clause will also contain information about the previous failures. other cliches in this category are repeat loops  and cut-fail combinations. more generally  we plan to investigate the interaction between programming style and explanation generation. a good way of using prolog to construct expert systems is to design and implement an embedded language. explanations should be in terms of the constructs of the embedded language rather than prolog structures. however prolog constructs cannot be ignored entirely. 
　we conclude with a brief discussion of the significance of our work to meta-level programming. certain aspects of the object level computation are explicitly represented in a meta-interpreter while others are kept implicit. those explicit aspects are said to be reified while the implicit ones are absorbed. reification and absorption were originally discussed for the lisp community by smith  des rivieres and smith  1   and have been used informally in logic programming by ken kahn and ehud shapiro. standard prolog meta-interpreters reify clause reduction and absorb unification  except for the decomposition of constructs  such as conjunction and disjunction. failure is also absorbed in the standard fourclause meta-interpreters hence we have no access to when it occurs or how backtracking affects the computation. in contrast  our layered abstraction reifies prolog's control flow  where the communication between the goals and the state of the computation  namely success  failure or commitment  is explicit. prolog's unification mechanism is absorbed in our model. 
　other research in meta-level programming has pondered the issue of reflection. we believe our work can be discussed within this terminology  but to do so is beyond the scope of this paper. for an overview of current meta-level programming and applications  see  maes and nardi  1  lloyd  1 . 
