 
　　　this paper describes d-script  a language for representing knowledge in a r t i f i c i a l intelligence programs. d-script contains a powerful formalism for descriptions  which permits the representation of statements that are problematical for other systems. particular attention is paid to problems of opaque contexts  time contexts  and knowledge about knowledge. the design of a deductive system for this language is also considered. 
	1. 	int roduction 
1 ways of representing; knowledge 
　　　methods advocated for representing knowledge in artificiall intelligence programs have included logical statements  mccarthy  sandewall   semantic networks  quillian  
schank   and procedures  hewitt  sussman and mcdermott   all these approaches shpre one fundamental concept  the notion of predication. that is  the basic data structure in each system is some representation of a predicate applied to objects. in this respect  the various systems are more or less equivalent. but this basic idea must be extended to handle problems of 
quantification and knowledge about knowledge. mere the systems do d i f f e r . we w i l l argue  though  that these differences result from the descriptive apparatus used in the particular systems being compared  rather than from an inherent advantage of  say  procedures over 
declaratives or vice versa. 
　　　advocates of planner  e.g. winograd  p. 1 have argued that the predicate calculus cannot represent how a piece of knowledge should be used. but this is true only of the first-order predicate calculus. in a higherorder or non-ordered declarative language  statements could be made which would t e l l a theorem prover how other statements are to be used. planner  on the other hand  has no way of directly stating an existential quantification  but this does not mean that procedural languages are necessarily incapable 
of handling that problem. 
　　　our belief  then. 	is that the type of system used to represent knowledge is unimportant  so long as it has sufficient expressive power. 	this paper presents an attempt at such a system  the language d-
script. 	as the name implies  the most 
interesting feature of d-script is its powerful formalism for descriptions  which enables it to represent statements that are problematical in other systems. no position w i l l be taken as to what kind of language dscript is. since it is intended to answer questions by making deductions from a data base  it can be thought of as a theorem prover. since it operates by comparing 
expressions like the data-base languages of planner and conniver  it can be thought of as a pattern-matching language. and since it is turing universal and. in fact  includes the lambda calculus. it can be thought of as a programming language. 
1 problems in representing knowledge 
　　　before presenting the details of dscript  we w i l l try to give some idea of the type of problem it is designed to solve. a 
classic problem is that of representing opaque contexts. an opaque context is one which does not allow substitution of referentially equivalent expressions or does not allow existential quantification. for example the verb  want  creates an opaque context: 
 1  john wants to marry the prettiest g i r l . 
this sentence is ambiguous. 	it 	can mean either: 
 1  john wants to merry a specific g i r l who also happens to bp the prettiest. 
or: 
 1  john wants to marry whoever is the prettiest g i r l   although he may not know who that is. 
under the f i r s t interpretation we can substitute any phrase which refers to the same person for  the prettiest g i r l   . that is  if the prettiest girl is named  sally sunshine   from  1  we can infer: 
u.i*  john wants to marry a specific g i r l who also happens to be named sally sunshine. 
we cannot make the corresponding inference from  1 . it w i l l not be true that: 
 1  john wants to marry whoever is named sally sunshine  although he may not know who that is. 
because of this property   1  is called the transparent reading of  1  and  1  is called the opaque reading. it is almost always the case that sentences having an opaque reading are ambiguous with the other reading being transparent. 
　　　to i l l u s t r a t e blocking of existential quantification  consider: 
 1  john wants to marry a blonde. 
again the sentence is ambiguous  meaning either: 
 1  john wants to marry a specific g i r l   who also happens to be a blonde. 
or: 
 1  john has no particular g i r l in mind  but he wants whoever he does marry to be a blonde. 
we can existentially quantify over the f i r s t reading but not the second. we can infer: 
1  1  there exists someone whom john wants to marry. 
from  1   but not from   i . 1   . 
　　　another problem is the occurrence of descriptive phrases in sentences i nvolvlng time reference. in the sentence: 
 1  the president has been married since 1. 
the phrase  the president  refers to an individual. 	in the sentence: 
 1  the president has lived in the white mouse since 1. 
 the president  refers to each president in turn. 
　　　another type of sentence where the reference of a phrase depends on time is illustrated by: 
 1  john met the president in 1. 
this sentence is ambiguous  but unlike  1   each interpretation refers to only one person. the ambiguity is whether  the president  refers to the president at the time  1  is 
asserted  or the president in 1. 
representing knowledge about knowledge 
raises some interesting issues. 	for instance  in: 
 1  john knows b i l l ' s phone numher. 
how is john's knowledge to be represented  	in john's mind it might be something l i k e : 
 1   phone-num 	bill 	1 1  
so   1  might be: 
 1   knows john  phomf-num bill 1   
the trouble with  1  is that it includes too much information. not only does it say 
what  1  says  it also says what the number la- the d i f f i c u l t y is to refer to a piece of information without stating i t . 
　　　for all these types of sentences  dscript provides representations which allow the correct deductions to be made. further  it provides separate representations for each meaning of the ambiguous sentences  and these representations are related in a way that explains the ambiguity. 
1. the d-script language 
1 p-script expressions 
　　　d-script contains the following types of expressions: 
1. constants 
1. variables 
1. forms 
1. l i s t s 
a constant is any alpha-numeric   i . e . only letters or numbers  character string  e.g.  f1    bl1ck1  . a variable is any alphanumeric character string prefixed by      e.g.   x  . a form is any sequence of expressions enclosed in angle-brackets  e.g.   x y  z   . a l i s t is any sequence of expressions enclosed in parentheses  e.g.   f1 a  bar b c    . 
　　　d-script observes the convention that all functions  predicates  and operators evaluate their arguments. the rules for evaluating expressions are largely adapted from lisp. in fact  d-script variables and forms are treated just like lisp atoms and l i s t s   respectively. rather than introducing  quote   however  we use constants and l i s t s to represent predefined items. to state our rules formally: 
1. a constant evaluates to i t s e l f . 
1. a variable evaluates to the expression which it has been assigned. 
1. the value of a form is the result of applying its f i r s t element to the values of its remaining elements. this w i l l not be defined in general  but only for those expressions which represent meaningful operations in d-script. one such case is that of lambda-expressions. a lambdaexpression is represented in d-script by a form containing the constant  lambda   followed by a l i s t of variables  followed by an expression  e.g.   lambda   x  y   times  x  y    . a form whose f i r s t element is a lambda-expression is evaluated in the same way as a corresponding lisp 
expression. the result is the value of the body of the lambda-expression  with the values of the arguments assigned to the corresponding variab les. for instance  assuming  +  has the usual meaning     lambda   x   + 1  x   1   has the same value as   + 1    which is   1   . we w i l l 
introduce other types of forms whose value is defined when we explain the representation of statements. 
1. a l i s t evaluates to a form with identical structure  except that free variables are replaced by their values. if   x  has 
previously been assigned the value  a   then   lambda   y  cfoo  x  y   w i l l evaluate to   lambda c y  cfoo a  y   . 
　　　it is worth noting that the way lambdaexpressions and l i s t s are defined makes it 
very easy to write functions which construct complex forms. for example  consider   lambda c x   f1  bar  gritch  x     . the result of applying this to  z  is   f1  bar  gritcii z    . a comparable lisp function would have to be built up with  c1ms  's to achieve this 
result. 
1 representing knowledge in d-script 
　　　the most basic statements are those which express simple predication. a statement of this kind is represented in d-script by a form whose f i r s t element is a constant representing 
the predicate and whose other elements are 
constants representing the objects of the predicate. for example: 
 1  the sun is a star. c1  blocka is on blockb. could be represented as: 
 1   star sun  
 1.it   1n blocka bl1ckb  
1 a simple statement about a statement  such as: 
 1  john believes the sun is a s t a r . would be: 
 1   bel1eve john  star sun   
the 	important t h i n g to n o t i c e about 	 1  	is that 	the embedded statement 	is represented by a l i s t . 	this is because we need an expression whose value 	is 	 1  	to be consistent w i t h the convention 	that 	predicates 	  i n t h i s case    b e l i e v e     	evaluate 	t h e i r 	arguments. 
　　　to represent more complex statements/ 	two types of extensions are needed. 	the simpler 
of 	these 	is 	the a d d i t i o n of 	logical connectives. 	d-scr1pt uses  or    and    not   	and  impufs  to stand for the obvious l o g i c a l o p e r a t i o n s . 	as in  1  the embedded statements are expressed as l i s t s . 	so: 
 1  	if the sun is a s t a r   	then blocka is on 
blockb. 
would be represented by: 
 1  	  impufs  star sun   on blocka bl1ckb   
this n o t a t i o n r e f l e c t s the fact that in dscp.tpt  l o g i c a l connectives operate on the statements themselves rather than on t h e i r t r u t h - v a l u e s .  implies   then  is not computed as a boolean f u n c t i o n   but rather is computed by a s s e r t i n g that i t s f i r s t argument is t r u e   and attempting to prove i t s second argument. 
       the other extension required f o r complex statements  and the one that is most important to our t h e o r y   is the use of d e s c r i p t i o n s . there are t h r e e types of d e s c r i p t i o n s in dscript; e x i s t e n t i a l d e s c r i p t i o n s   universal d e s c r i p t i o n s and d e f i n i t e d e s c r i p t i o n s . a d e s c r i p t i o n is a form whose f i r s t element is  some    e x i s t e n t i a l      every    u n i v e r s a l     or  the    d e f i n i t e   ; whose second element is a l i s t c o n t a i n i n g a v a r i a b l e ; and whose t h i r d 
       element is an expression whose value is a statement. d e s c r i p t i o n s represent the corresponding types of natural language d e s c r i p t i v e phrases: 
 1  a block  s1me   x   clock  x   every number  fvfry   y   hum  y   the table  tiif   x   table  x     
some examples of sentences c o n t a i n i n g d e s c r i p t i v e phrases and t h e i r representations a r e : 
 1  	the king 	is f a t . 
	 fat  the   x  	 king  xl   
 1  	john owns a dog. 
 1wn john  s1me   x   dog  x    
 1  	every boy l i k e s santa claus. 
 like  every   x   boy  x   santa  
notice that when d e s c r i p t i o n s appear 	in statements  	they are l e f t as forms. 	this is because  	u n l i k e embedded statements  we are t a l k i n g about 	the o b j e c t s 	to which 	the d e s c r i p t i o n s 	r e f e r 	  i . e . 	t h e i r values  	rather than 	the d e s c r i p t i o n s 	themselves. 
       the n o t a t i o n we have used so f a r is not s u f f i c i e n t 	to express 	statements 	c o n t a i n i n g more than one occurrence of the same d e s c r i p t i o n . 	in the sentence: 
 1  every boy e i t h e r loves santa claus or hates him. 
the phrase  every boy  	is the subject of both   l o v e s   and   h a t e s   . 	we cannot use the f o l l o w i n g 	representation 	though: 
 1  	 or  love  every   x   boy 1x   santa  
　　　　　　　 hate  fvery   x   boy  x   santa   because t h i s means: 
 1  	either every boy 	loves santa claus or every boy hates santa claus. 
which  of course  	is q u i t e d i f f e r e n t . 	we can overcome t h i s d i f f i c u l t y by using lambdaexpressions. 	we w i l l 	represent  1  by: 
 1  	  lambda   x   or  love  x santa  
 hate  x santa    
	 fvfry   y  	cboy  y    
this can be read as something l i k e  the predicate x is true of every boy   where the predicate x is  loves santa claus or hates h i m .   
　　　vie have a s i m i l a r s i t u a t i o n w i t h respect to the scope of q u a n t i f i e r s . 	it 	is not clear 
whether: 
 1  	 grfater  s1me   x   num  x   
 every   y   num  y    
represents: 
 1&  	for every number there 	is some larger number. 
o r : 
 1  there is some number which is larger than every number. 
we w i l l have to a r b i t r a r i l y choose a r u l e to disambiguate   1   1     but by using lambdaexpressions we can avoid the d i f f i c u l t y .  1  can be represented by: 
 1  	  lambda   x  
　　　　　　　 crfater  s1me   y   mum  y    x    fvery   z   hum  z    and  1  can be represented by: 
 1  	  lambda   x  
 greater  x  every   y   mum  y     
	 s1me   z  	 num 	 z    
analyzing these expressions in the same way as  1c  w i l l show that they have the c o r r e c t meanlng. 
       it should be apparent that e x i s t e n t i a l and universal d e s c r i p t i o n s in d-script serve e x a c t l y the same f u n c t i o n as the q u a n t i f i e r s of the predicate c a l c u l u s . in view of t h i s . it may be asked why we have used a d i f f e r e n t n o t a t i o n   one reason is that our n o t a t i o n makes it possible to w r i t e expressions v/hose s t r u c t u r e more c t o s e l y resembles the sentences they represent. hopefully t h i s makes them 
more i n t e l l i g i b l e . the more important reason  though  is that having a s i n g l e expression for 
a d e s c r i p t i o n makes 	it easier for an i n t e r p r e t e r 	t o manipulate 	i t . 
1 formal semantics of p-script 
　　　the previous two sections outlined the syntax and informal semantics of d-script. this section attempts to show how a program could be written that would interpret d-script statements in accord with their intuitive meaning. the details of this will be somewhat 
sketchy. one reason for this is that choosing proof strategies and using heuristic information are complicated problems that we cannot claim to have solved. secondly  creating a theorem prover is not our main goal. what we are trying to do is to show the sort of descriptive system necessary to represent the information contained in natural language statements. the purpose of this 
section is to establish that our notation for that system is  well-founded . 
　　　the program we have in mind would take a statement as its input and determine from its data base whether the statement is true. for statements which are simple predications/ the program looks for another statement in the data base which matches the f i r s t statement. the statement whose truth is being determined w i l l be called the  test statement ; the statement in the data base to which it is being compared w i l l be called the  tarret statement . to prove a complex statement  the program would break it down into its components and process them according to the semantics of the operators involved. similarly  a complex target statenent must be broken down to its components for processing  but the rules are different. so  in explaining the semantics of complex expressions  analyses w i l l be given for their use both in test statements and in target statements. 
　　　two basic statements match if their corresponding elements match. in general  expressions whtch are not statements match whenever their values are identical  a 
variable which has not been assigned a value matches any expression  and is assigned that expression's value. these rules apply to both test statements and target statements. as an 
example  suppose  1  has been assigned to   x     y  is unassigned  and  +  has its usual meaning. then   fod 1  y   w i l l match   f1  x  + 1    and  1  w i l l be assigned to   y . 
　　　we w i l l not give a complete deductive procedure for logical connectives. it is a 
well understood problem and is not of primary importance in the phenomena we wish to explain. but to suggest the kind of procedure we have in mind  consider  and  and  implies . in handling these expressions the distinction between test statements and target statements comes through. to prove   and x y  both x and x must be proved; but in matchin something against   amd x y    the match succeeds if either x or v matches.   mplies 
x y   is true if in a hypothetical state where x is asserted  y can be proved. a test statement w i l l match a target statement   implies x y   if the test statement matches x and x can be proved.  or  and  not  are somewhat more complicated but can be handled in much the same way. 
　　　the really important part of our deductive procedure is the treatment of descriptions. definite descriptions are the simplest.   the   x   ... x...    evaluates to the constant which when assigned to   x  makes     . . .   x . . .     true. if there is not such a constant or if there is more than one  the value of the description is undefined. for example. if  less  means  arithmetically less than   then   f1   matches: 
 1   f1  the   x   and  less  x 1  
 less 1  x     
this rule for evaluating definite descriptions applies to both test statements and target statements. 
　　　for existential and universal descriptions  there is again a difference between test statements and target statements. in a test statement  an existential description matches anything that makes the body of the description true. that i s     fo1  s1me   x   bar  x     matches   f1 a   if   bar  x   is true when   x  is assigned  a . for the case of a target statement  the evaluation is more d i f f i c u l t . if we know that  some bar is foo   we could simply give it a name and continue. but giving a name would imply that we know which bar is foo  which is 
not true. instead we can create a name and say that if the new name were the name of the object that is asserted to exist  then anything which we can prove about the new name is true of the object. we do this by creating a hypothetical state of the data base in which. if the new name is  g1   we assert   bar g1  . the target statement then becomes   f1 g1  . another way of putting this is that   some   x   bar  x    evaluates to  g1   with the side effect of creating a 
hypothetical state of the data base in which   bar 1   is asserted. when the hypothesis is discharged  the new name becomes undefined  
and we are not in danger of supposing that we know v/hat the name of the object is. 
　　　the treatment of universal descriptions is the exact dual of that for existential descriptions. in a test statement  we know that whatever we can prove about an a r b i t r a r i l y selected member of a class is true of every member of the class. so just as we did for existential target statements  we set up a hypothetjcal state  produce an arbitrary unique name  and assert that it is a member of the class. analogously to what we said 
before    every   x   foo  x    evaluates to  say   g1l  with the side effect of creating a hypothetical state in which   f1 g l l l     is asserted. also in duality with existential descriptions. in a target statement a universal description matches anything which makes its body true. for example    f1 a   matches   f1  every   x   bar  x     if   bar  x   is true when   x  is assigned  a . 
now we can see why lambda-expressions are 
important for representing information in 1script. evaluating existential and universal descriptions sometimes has the side effect of changing the data base. later we w i l l introduce other expressions which also do t h i s . if we have other descriptions in the statement  we need to be able to control 
whether they are evaluated in the old data base or the new. by  lambda-fylng  a statement we can bring one or another description to the outside and force it to be evaluated f i r s t . in this way we can control the order in which expressions are evaluated. a detailed example of this w i l l be given in section 1. 
in this brief summary  we have given the 
barest o u t l i n e s of a deductive procedure. 	we have not discussed any of the complex 
i n t e r a c t i o n s among these l o g i c a l o p e r a t o r s . but h o p e f u l l y we have l a i d a s u f f i c i e n t foundation to t a l k about the issues that are the real p o i n t of t h i s paper. 
1. s o l u t i o n to representation problems using d-script 
1 d e s c r i p t i o n s 	in opaque contex 1 
       in g e n e r a l   d e s c r i p t i v e phrases in opaque contexts are subject to more than one i n t e r p r e t a t i o n . furthermore  at least one of the i n t e r p r e t a t i o n s seems not to behave according to normal rules of l o g i c a l m a n i p u l a t i o n . looking more c l o s e l y   opaoue contexts p r i m a r i l y occur in the complement c o n s t r u c t i o n s of verbs l i k e  want     b e l i e v e      know   e t c . these verbs a l l have the p r o p e r t y of d e s c r i b i n g somebody's model of the w o r l d . when we say:   1 . 1   john wants to marry s a l l y . 
what we mean is that in john's model of the w o r l d   the s t a t e : 
 1  	john 	is 	married to s a l l y . 
is considered d e s i r a b l e . 	the ambiguity of d e s c r i p t i v e phrases arises from 	the question of whether 	the d e s c r i p t i v e phrase 	is to be evaluated 	in our model 	of the world or the 
model 	of the subject of the sentence. 	to i l l u s t r a t e 	t h i s   	r e c a l l 	the sentence: 
 1  	john wants to marry the p r e t t i e s t 	g i r l . 
in d-scr1pt  the opaque reading is represented by: 
  1 . 1    want john  marry john 
	 the 	  x  	 prettifst 	 x     
the 	reason t h a t there are r e s t r i c t i o n s on s u b s t i t u t i n g other expressions 	for   the 	  x   prettiest  x    	is 	t h a t the statement which a c t u a l l y contains 	t h i s 	d e s c r i p t i o n   	i . e . : 
 1  	 marry john  the   x   prettiest  x    
is part of john's world model. if in our program we represent john's world model by a separate data base  then the expressions which 
may be s u b s t i t u t e d are those which are e q u i v a l e n t 	in that data base  	not 	in the main data base which represents our world model. 
　　　to represent the transparent reading of   1 . 1     we must take the d e s c r i p t i o n outside the scope of john's model. we can do t h i s 
w i t h a lambda-expression: 
 1  	  lambda 	  x  
 want john  marry john  x    
	 the   y  	 prfttifst  y    
this says that the statement we get by e v a l u a t i n g the d e s c r i p t i o n 	in our model 	and s u b s t i t u t i n g t h a t value f o r 	  x  	i n : 
 1  	 marry john  x  
is marked as a d e s i r a b l e s t a t e in jolin's world model. 
	the a n a l y s i s 	is 	analogous for e x i s t e n t i a l 
d e s c r i p t i o n s . the two readings o f :  1  john wants to marry a blonde  can be represented by: 
 1  	 want john  marry john 
	 s1me   x  	 blonde  x     
for the opaque reading  and by: 
 1    lambda   x  
              want john  marry john  x     s1me   y   blonde  y    f o r the transparent reading.  1  means: 
 1  john  wants there to be a blonde that he m a r r i e s . 
and  1  means: 
 1  	there is a blonde that john wants to marry. 
so the reason we c a n ' t make a   t h e r e i s . . .   paraphrase of 	 1  	is that 	rather than being 
an e x i s t e n t i a l 	statement. 	it 	is an a s s e r t i o n abqut an e x i s t e n t i a l 	statement. 
1 descriptions 	in 	time contexts 
       in order to discuss the next set of examples  we need a way to represent time. the basic f a c t here is that any predicate can be made to vary w i t h time. even those t h a t we choose to consider eternal can be alleged to depend on time  e . g . : 
 1  	two used to be greater than t h r e e . 
to account f o r t h i s 	in 	f i r s t - o r d e r l o g i c   we would have 	to make time an e x p l i c i t parameter of every p r e d i c a t e symbol. 	instead  we w i l l represent 	time by a coptext-structured.c.tu.red data base  mcdermott . 	by t h i s we mean that the data base w i l l 	be broken down 	into a series of sub-data bases  	or c o n t e x t s   	each of which represents the s t a t e of 	the world at some p a r t i c u l a r time. 	this can be e f f i c i e n t l y 
implemented  as it is in conniver  sussman and mcdermott  by s p e c i f y i n g each context by recording the d i f f e r e n c e s between it and i t s predecessor. 
       to use t h i s kind of data base  we need a special p r e d i c a t e  t-a-t  which takes as i t s parameters a statement and the name of a time c o n t e x t .   t-a-t s t   means statement s. is true at time t. the formal semantics of  t-at  are that it attempts to deduce s  in the time context named by t.  we also need to be 
able to generate references to time c o n t e x t s . for instance  the phrase:  1  when washington was president would be represented by the d e s c r i p t i o n : 
 1  	 the   t  	 t-a-t  pres washington   t   
f i n a l l y we need the one-place p r e d i c a t e  time  to make q u a n t i f i e d statements about time. 	we 
would 	represent: 
 1  	three 	is always greater than two. 

1 

by: which means: 

c1   t-a-t  hrfatf.r 1  
	 fvfry 	  t  	 tit'f 	 t    
       given t h i s n o t a t i o n f o r time  we can solve the associated problems which wo raised e a r l i e r . as in the case of opaque c o n t e x t s   
the s o l u t i o n depends on whether a d e s c r i p t i o n is evaluated in the context in which a statement is made or the context which the statement is about. r e c a l l i n g the previous examples: 
 1  	the president has been married since 1. 
is 	represented by: 
 1  	  lambda   x  	 t-a-t  married  x  
	 every   t  	 after  t 1     
 the c y   pres  y    
in  1  	the use of 	the 	lambda-expression puts the d e s c r i p t i o n   tnif   y  	 pres 	 y    o u t s i d e the time c o n s t r u c t i o n   	so 	it 	is evaluated 	in the context 	in which 	the statement is made. 	on 	the other hand: 
 1  the president has l i v e d in the white mouse since 1. i s represented by: 
 1  	 t-a-t 
	  l i v e - i f  tme   x  	 pres  x   w-h  
	 every   t  	 after  t 1    
here the d e s c r i p t i o n is inside the time c o n s t r u c t i o n and is not evaluated u n t i l the time d e s c r i p t i o n has been i n s t a n t i a t e d . the a n a l y s i s is the. same f o r :  1  john met the president in 1. 
except 	that 	in 	t h i s case the time 	reference 	is d e f i n i t e . 	one 	i n t e r p r e t a t i o n 	is given by: 
c1   t-a-t  meet john  t1e   x  	 pres  x   1  and the other 	is given by: 
 1d  	  lahdda   x  	 t-a-t  meet john  x  
                           1    the   y   pres  y   
1 	knowledge about knowledge 
       one of the questions we raised in the beginning was how to represent: 
 1  	john knows d i l i ' s phone number. 
if we knew the number we could represent  1  by: 
 1g   know john  phone-num bill xxx   
where xxx is the number. 	we do know one d e s c r i p t i o n of 	the number  	namely   c i u ' s phone number . 	if we s u b s t i t u t e t h i s 	into   1 . 1     	however  we pet a t r i v i a l 	statement: 
 1   kn1w john  phome-num bill 
	 tiie   x  	 phonf-num bill  x     
 1  	john knows that b i l l ' s phone number 	is b i l l ' s 	phone 	number. 
what we need to do is to remove the occurrence of the d e s c r i p t i o n from john's world model  into our world model. once again  we can do t h i s w i t h a lambda-expression: 
 1  	  lambda   x  
 know john  phone-num bill  x    
 t!if   x   phone-num bill  x    
this says that 	if we were to evaluate the d e s c r i p t i o n   b i l l ' s phone number  and s t i c k the r e s u l t 	in   1 . 1     we would c o r r e c t l y 
describe john's 	knowledge. 
	to see the d i f f e r e n c e between 	 1  	and 
  1 . 1     suppose we know that b i l l has a phone number  and we know that john knows that b i l l has a phone number. these f a c t s are represented by: 
 1  	 ph1me-mum bill  s1me   x   mum  x    
 1  	 kn1w john  phone-num bill 
 some   x   num  x     
given t h i s   we can prove  1  	from i t s e l f . 
notice that in d-script t h i s is n o n - t r v i a l . complex statements are never proved by simply looking to see if they are in the late base. rather  they arc broken down to t h e i r basic components and these components are processed according to the semantics of the operators combining then. in the case of  kmow  the semantics are to s h i f t the proof to the data base of the person doing the knowing. so even to prove a statement from i t s e l f   the semantics r e a l l y have to work. 
	tn t r y i n g 	to prove 	 1  	the lambda-
expression makes us f i r s t evaluate   the   x   phone-num dill  x   . we do t h i s by t r y i n g to f i n d a match for   phone -num bill  x  . if 
we d o n ' t know b i l l ' s phone number wc c a n ' t do t h i s d i r e c t l y .   1 . 1     however  e n t i t l e s us to create a h y p o t h e t i c a l s t a t e in which some 
a r b i t r a r y c o n s t a n t   say  1  is asserted to be d i l l ' s number. so to prove   1 . 1     wc attempt to prove: 
 1   kn1w john  phone-num bill g1   w i t h the hypothesis: 
 1   pi!1ne-num bill g1  
to prove  1  from  1  we process  1  much the same as before. this t i m e   however  
we already have  1  	in the data base; 	so 
  the   x   phone-n'um bill  x    evaluates to  1  d i r e c t l y . 	our proof then reduces 	to proving 	 1  	from 	i t s e l f   	which 	reduces again to proving 	 1  	from 	i t s e l f 	in 	the data base which 	represents john's world model. 
 1  is a basic statement  so it can be i n f e r r e d from i t s e l f immediately  and the e n t i r e proof succeeds. 
       now suppose instead that we were t r y i n g to prove  1  from   1 . 1   . the proof would be the same down to the point where we generated the subgoal of proving   1 . 1   . to prove t h i s from   1 . 1     we have to prove  1  from: 

a r t i f i c i a l 	i n t e l l i g e n c e . 	v o l . 	1  1   pp. 	1. 
schank  r  c. 	 a conceptual dependency representation 	for a computer-oriented semantics   memo a l - 1   	stanford a . l . p r o j e c t   	1. 
sussman  g. j. and d. v. mcdermott   from planner to conniver - a genetic approach   proc. fjcc 1  1   pp. 1. 
winograd  t.  	 procedures as a representation for data 	in a program for understandinp; n a t u r a l language   report al tr-1  m . l . t . a . i . laboratory  	1. 
- 1. future work 
       in t h i s paper we have presented a formal language f o r the representation of knowl edge. we have shown how information which is d i f f i c u l t to express in other formalisms can be expressed in our language. and we have 
suggested how a deductive program could be 
designed to answer questions 	in our 	language. c l e a r l y   	the next step 	in this 	research 	is 	to b u i l d t h a t deductive program. 
       there arc several reasons why t h i s would be a worthwhile p r o j e c t . for one  a . i . deductive systems seen to f e l l into two extreme c a t e g o r i e s . on the one hand  p r e d i c a t e - c a l c u l u s theorem provers r e s t r i c t themselves to f i r s t order languages. procedural systems such as planner  on the other hand  use p a t t e r n matching schemes which are general enough to process higher order statements  but they are so general that they 
say nothing about the meaning of those statements. implementing d-script would 
create a system somewhere in between - one that would embody systematic knowledge about 
	some types of 	higher 	order statements. 
       beyond t h i s   	the p a r t i c u l a r types of knowledge we have discussed seem to be 
	e s p e c i a l l y 	important 	for a . i . 	there 	i s s t i l l 
	much work to be done  but 	if we can program a 
deductive system to t r e a t  t-a-t  and  know  in the way we have proposed  we w i l l have 
taken a f i r s t step towards c r e a t i n e programs which can t h i n k about t h i n k i n g . 
bibilography 
h e w i t t   	c   	  d e s c r i p t i o n and t h e o r e t i c a l analysis  using schemata  of planner: a language for 	proving theorems and manipulating models 	in a robot   report al tr-1b  m . l . t . a . i . laboratory  	1. 
mccarthy  j .    programs with common sense   in 
semantic information processing. marvin mlnsky  e d     pp. 1. cambridge  mass.: n. i .t. press  1 . 
	mcdermott  	d  v.  	  a s s i m i l a t i o n of flew 
	information by a natural 	languare-
understandlnn system   unpublished s.n.. t h e s i s   	m . i . t .   	1. 
quillian  	m. 	r.  	 semantic memory    in semantic 	information processing. 	on. 	1-
1. 
sandewall  f.   formal methods in the design of question-answering systems 1 
session 1 	formalisms for 
a r t i f i c i a l intelligence 
conversion of predicate-calculus axioms  viewed as 
non-deterministic programs  to corresponding deterministic programs 
	erik 	sandewall 
computer sciences department 
	uppsala 	u n i v e r s i t y 

abstract: the paper considers the problem of converting axioms in predicate calculus to deterministic programs  which are to be used as   r u l e s   by a gps-type supervisor. it is shown that t h i s can be done  but that the   o b j e c t s   must then contain procedure closures or  funarg-expressions  which are later a p p l i e d . 
keywords: deduction  theorem-proving  r e t r i e v a l   non-det e r m i n i s t i c   closure  funarc-expression. 
background- retrieval of i m p l i c i t information in a semantic data base is a kind of deduction. one approach to doing such r e t r i e v a l has been r e s o l u t i o n - s t y l e theoremproving; a later approach has been high-level programming languages such as planner1 and qa1  where non-det e r m i n i s t i c programs and p a t t e r n - d i r e c t e d invocation of procedures are a v a i l a b l e . the use of uniform proof procedures for t h i s purpose has been repeatedly c r i t i c i z e d   e . g . in 1. users of the high-level languages have also been worried because t h e i r systems are very expensive to use1 and because the non-determinism is d i f f i c u l t to control1. 
there is another approach  which has roots in a . 1 . research back to the general problem solver1  where one has a supervisor which administrates a   r e l a t i v e l y   f i xed set of operators  and a working set of active obj e c t s . in each cycle  the supervisor picks an object and an operator  using any h e u r i s t i c information that it may have   applies the operator to the o b j e c t   and 
obtains back a number of new objects  none  one  or more  which are put into the working set. this process is continued u n t i l some goal is achieved   e . g .   an ob-
j e c t is a given target set appears in the working s e t   . 
this approach has certain advantages from an e f f i c i e n c y standpoint  the operators are fixed programs  which can be compiled or otherwise transformed a l l the way to machine code l e v e l . the non-determinism is concentrated to the supervisor. s t i l l   there is room for p a t t e r n - d i rected invocation  by l e t t i n g the supervisor c l a s s i f y 
objects into a number of classes  and associating a subset of the operators with each class. there is also the non-determinism implied by the search. 
the major disadvantage  of course  is that t h i s scheme is more r i g i d . for example  since everything happens on 
one l e v e l   there is l i t t l e room for recursion. if one operator c a l l s a procedure  which c a l l s another  which wants to be non-deterministic  then there is no t r i v i a l way to map that non-determinism back up to the  search l e v e l   of the supervisor  while retaining the environ-
ment of function c a l l s   variable bindings  etc. that must be kept a v a i l a b l e in a l l branches. 
an interesting question is therefore: how harmful is t h i s r i g i d i t y   is it very awkward to  program around  the l i m i t a t i o n s of such a system  or is it easy  
in t h i s paper  we t r y to answer that question by studying those operators which correspond to axioms in pre-
dicate calculus. we assume that we have a data base  which is l i k e a large number of ground unit clauses  plus a number of operators  which should correspond to the non-ground axioms. we show that there are c e r t a i n problems in phrasing the l a t t e r as operators  but that there is a systematic way to handle those problems. we conclude that the search supervisor approach should be considered as a serious candidate for the deductive system associated w i t h a data base. 
basic idea. for the reader who might not want to read the whole paper  we disclose that the idea is to permit the   o b j e c t s   to contain procedure closures1  also called funarg-expressions  i.e. lambda-expressions t o gether with an environment of bindings for i t s free var i a b l e s . the lambda-expression is as fixed as the set 
of operators  and can therefore be compiled  e t c   but the environment is new for each o b j e c t . 
after thus having sketched the background and the general idea  l e t us go into the d e t a i l s of the predicatecalculus environment. 
simplest case. let us take a common-place axiom and convert it into a program-like operator. we choose the t r a n s i t i v i t y axiom  
   r x y  a r y z    r x z  which goes into a rule of the form 
on a sub-question with the r e l a t i o n r  use lambda x z  begin local y; determine y from r x y ; 
	return 	sub-question 	r y z  
end 
here   determine y from r   y   z     c a l l s for a look-up in the data base  and usually acts as a non-deterministic assignment to y.  return sub-question  specifies the information which is given back to the supervisor  con-
s i s t i n g of a r e l a t i o n  r  and an argument l i s t . the l a t t e r is a l i s t of the current values of x and yj it 
does not need to contain the names x and y  or t h e i r bindings to t h e i r current values. the supervisor w i l l then look up a l l operators  lambda-expressions  which are associated with r  and apply them to the given argument l i s t   of course at whatever time it chooses. 
this rule describes what has to be done when any data base search routine continues search according to the t r a n s i t i v i t y property of the r e l a t i o n s . it does not 
matter if the search is executed by a uniform theoremprover  a planner-type system  or by a hand-tailored proaram such as the lisp functions in the sir system1. however  in a higher-level system  the system has to   i n t e r p r e t   the axioms or r u l e s   i.e. f i n d out at runtime what is to be done. a resolution theorem-prover is extreme in t h i s respect. our concern in t h i s paper is to f i n d out before execution  with information only about the axiom or r u l e   not about the actual sub-question  what operations w i l l be necessary  so that we can 
w r i t e out the code for doing exactly t h a t   tn programming systems terms  we want to compile the axioms  and do as many decisions as possible at complle-time. 
if a resolution theorem-prover contains the above t r a n s i t i v i t y axiom  and the axiom 
   r a b  and i f i t asked the   q u e s t i o n       b . c     i t w i l l generate the sub-question m l   a   c   . this step can be c l e a r l y i l l u s t r a t e d if the t r a n s i t i v i t y axiom is rewritten as 



{*   construct a new operator where the statements are 

multiple controlled statements. it is easily seen that the above rule in four steps can be generalized to the cases where there are several controlled statements  and top-level search is performed for each of them. for example  in axiom 1 we might wish to make extensive search both in order to determine y from p x y   and in order to prove q x y . we must then have two nested remainder procedures. the resulting operator should have the form: 
on a sub-question with r1  use lambda  x  begin return sub-question p1 x   with remain-
der procedure 
lambda  y  begin return sub-question q x y  /a closed sub-question/ with the remainder prodedure lambda    return answer y 
end 
end 
we realize that  every answer  to a closed sub-question must be affirmative  i.e. as soon as it has proved q x y   the above operator returns y. 
chains of sub-guestions. the operators as formulated above return sub-questions consisting of a relation symbol  an argument l i s t   and a remainder function  but they only accept the f i r s t two items. this means that the supervisor is responsible for administrating the remainder procedures. however  in a programming system 
where procedures are permitted as arguments  to other procedures   the responsibility can easily be taken by the operators and the programming system. we shall now describe how this can be done. 
 in closed and open questions  we add one more argument 1  which is the remainder procedure. the resulting argument lists  x y g  for r   x g  for r1  etc.  are the objects which our supervisor shall handle. 
we then modify the examples so that g is introduced as an argument and applied to the returned answer. thus 
the definite version of the rule for axiom 1 ia: 
on a sub-question with r1  use lambda  x g  begin local y; determine y from p x.y ; 
return sub-question q1 y  function lambda  z  g f x z   
   
end 
the other rules are modified similarly. we notice that the sub-questions that this rule returns  contain two transfer variables: x and g. the bindings of these must 
be saved in the closure  and retained until the remainder procedure is used. 
let g' be the second argument of 1 in one particular use of the above operator. clearly g1 contains a reference to g  which itself pfesumably is a procedure closure  which was set up by a previous sub-question. as 
one sub-question generates another  a chain of closures is generated  where each one refers to its predecessor. when finally an answer is found to the last subquestion  the last procedure closure is applied in a return-answer statement; it calls its predecessor by using a procedure variable  as seen in the example  the predecessor calls its predecessor  and so on up the chain. in the original  top-level  qjestion  q is given as  return aeswer . 
discussion of applicability of the method. this procedure works in all cases where the non-determinlstic 
interrupt points  where another  parallel branch is permitted to attract attention  can be brought to the toplevel block of the  operators   and not be hidden deep-
er down in recursion  in principle  the trick is that the control stack  the stack of function calls  is only 
one element deep at the interrupt points  containing the call from the supervisor to the operator   and then the control stack information  plus the information of how far we have gotten  can be put in one additional transfer variable. with this method  we have no control stack environment  but merely a variable-binding environment at the interrupt points  and this is exactly 
what funarg  or procedure closures  can handle. 
we believe that this method is sufficiently powerful to handle e.g. all cases which may occur when pc axioms are mapped into rules  and probab 1y also a broader application. 
a questionable feature of this method is that one must in principle decide at  compile-time  which retrievals 
are to be done by  big  search  and which are to be done by  short  intermediate statement    non-controlled statement  search. in some applications this is ok  since some relations are only stored explicitly or almost exp l i c i t l y ; in others it may not be acceptable. 
requirements on the programming language. if the conversion from pc axiom to operator is to be done automatically  then the selected programming language must of course be able to generate and manipulate programs in the same language. lisp is then an obvious choice. however  during the execution of the search  our requirement is instead that we must be able to create a procedure closure  and send it around as data. some simulation languages  notably simula 1 have this f a c i l i t y   as well as pop-1 and ecl1. lisp1 systems  a-list systems  provide it through the funarg feature. later lisp systems  lisp 1  original bbn-lisp  do not provide i t 1 . a method for providing funarg in bbn-lisp'type systems without undue loss of efficiency has been proposed in 1 . 
it has been suggested that the notion of a  remainder procedure   as used in this paper  is rather closely connected with the notion of  continuation   which has recently proved helpful in discussing the denotational 
semantics of programming languages1. 
implementation. the author has participated in the development of a program  called pcdb  predicate calculus data base   which is organized according to the search supervisor principle. this program was described in reference 	1  and contains a compiler which accepts pc axioms and generates corresponding lisp programs. it a l so contains a simple supervisor  elaborate data base handling facilities  etc. which are needed. the present  1  version of pcdb lets the supervisor administrate the remainder procedures in an ad hoc and not completely general way. a new compiler is being written  which will administrate them with funarg expressions as indicated in this paper. we hope to have it working at the time of 
the conference. 
acknowledgements. the following people in uppsala have helped with the pcdb work: lennart drugge  anders haraldson  rene  reboh. 
sponsor: this research was supported by ibm svenska ab. 

references 
	1 . c 	hewitt 
description and t h e o r e t i c a l analysis  using schemata  of planner  a language for proving theorems and manipulating models in a robot 
ph.d. t h e s i s   dept. of mathematics  mit  cambridge  mass.  1  
1. j.f. 	rulifson et a l . 
qa1: a procedural basis for i n t u i t i v e reasoning 
	al 	center  stanford research 	i n s t i t u t e 	 1  
1. d.b. anderson and p.j. hayes the 	l o g i c i a n ' s 	f o l l y 
in 	the  european  alsb b u l l e t i n   b r i t i s h computer society  	1 
1. g.j. sussman 
why conniving is better than planning mit al l a b o r a t o r y   	1 
1. a. newell et a l . 
report on a general problem-solving program 
	proc. 	ifip congress 1  p. 1 
1. p.j. 	landin 
	the mechanical 	evaluation of expressions 
computer journal  vol. 1  1   pp. 1 
1. j. 	moses 
the function of function in lisp  or why the funarg problem should be called the environment problem acm sigsam b u l l e t i n no. 1  1  
1. b. raphe1 
sir: a computer program for semantic information r e t r i e v a l 
in minsky  e d . : semantic information processing mit press  1 
1. e. sandewall 
a proposed s o l u t i o n to the funarg problem acm sigsam b u l l e t i n no. 1  1  
1. ole-johan dahl et a t . 
common base language 
norwegian computing center  oslo  1 
1. r.m. burstall et a l . programming in pop-1 edlnburhg univ. press  1 
1. b. wegbreit et a l . 
ecl programmer's manual 
	harvard u n i v e r s i t y   cambridge  mass. 	1 
1. j. 	reynolds 
d e f i n i t i o n a l 	in terpr et ers for higher order programming languages 
proceedings of an acm conference  boston  mass. 1 
1. e. sandewall 
a programming tool 	for management of a predicatec a l c u l u s - o r i e n t e d data base 
	in proceedings of the second 	international 	j o i n t 
conference on a r t i f i c i a l 	i n t e l l i g e n c e   b r i t i s h computer society  london  	1 
1 
	a r t i f i c i a l 	intelligence 
a universal modular actor formalism for artificial intelligence 
carl hewitt 
peter bishop 
richard steiger 
abstract 
　　　　this paper proposes a modular actor architecture and definitional method for artificial intelligence that is conceptually based on a single kind of object: actors  or  if you will  
virtual processors  activation frames  or streams . 	the formalism makes no presuppositions about the representation of primitive data structures and control structures. 	such structures 
can be programmed  micro-coded  or hard wired 1n a uniform modular fashion. 	in fact it is 
impossible to determine whether a given object is  really  represented as a list  a vector  a hash table  a function  or a process. the architecture will efficiently run the coming 
generation of planner-like artificial intelligence languages including those requiring a high 
degree of parallelism. 	the efficiency is gained without loss of programming generality because 
it only makes certain actors more efficient; it does not change their behavioral 
characteristics. the architecture is general with respect to control structure and does not have or need goto  interrupt  or semaphore primitives. the formalism achieves the goals that 
the disallowed constructs are intended to achieve by other more structured methods. planner progress 
 programs should not only work  but they should appear to work as well.  
pdp-1x dogma 
　　　　the planner project is continuing research in natural and effective means for embedding knowledge in procedures. in the course of this work we have succeeded in unifying the 
formalism around one fundamental concept: the actor. 	intuitively  an actor is an active agent 
which plays a role on cue according to a script  we  use the actor metaphor to emphasize the inseparability of control and data flow in our model. data structures  functions  semaphores  
monitors  ports  descriptions  quillian nets  logical formulae  numbers  identifiers  demons  processes  contexts  and data bases can all be shown to be special cases of actors. all of the 
above are objects with certain useful modes of behavior. 	our formalism shows how all of the 
modes of behavior can be defined in terms of one kind of behavior: sending messages to actors. an actor is always invoked uniformly in exactly the same way regardless of whether 1t behaves as a recursive function  data structure  or process. 
 it is vain to multiply entities beyond need.  
william of occam 
 monotheism is the answer.  
　　　　the unification and simplification of the formalisms for the procedural embedding of knowledge has a great many benefits for us: 
　　　　foundations: the concept puts procedural semantics  the theory of how things operate  on a firmer basis. it will now be possible to do cleaner theoretical studies of the relation between procedural semantics and set-theoretic semantics such as model theories of the quantificational calculus and the lambda calculus. 
　　　　logical calculae: a procedural semantics is developed for the quantificational calculus. the logical constants for-all  there-exists  and  or  not  and implies 
are defined as actors. 
　　　　knowledge based programming is programming in an environment which has a substantial knowledge base in the application area for which the programs are intended. 
the actor formalism aids knowledge based programming in the following ways-. procedural embedding of knowledge  tracing behavioral dependencies  and substantiating that actors satisfy their intentions. 
　　　　intentions: 	furthermore the confirmation of properties of procedures is made easier and more uniform. 	every actor has an intention which checks that the prerequisites 
and the context of the actor being sent the message are satisfied. the intention is the contract that the actor has with the outside world. how an actor fullfllls its contract is its own business. by a simple bug we mean an actor which does not satisfy its intention. 
we would like to eliminate simptedebugging of actors by the meta-evaluation of actors to show that they satisfy their intentions. suppose that there is an external audience of actors e 
which satisfy the intentions of the actors to which they send messages. intuitively  the principle of actor induction states that the intentions of all actions caused by e are 
in turn satisfied provided that the following condition holds: if for each actor a the intention of a is satisfied =  that the intentions of all actors sent messages by a are satisfied. computational induction  manna   structural induction  burstall   and peano induction are all special cases of actor induction. 	actor based intentions have the following 
advantages: 	the intention is decoupled from the actors it describes. 	intentions of 
concurrent actions are more easily disentangled. we can more elegantly write intentions 
for dialogues between actors. 	the intentions are written 1n the same formalism as the 
procedures they describe. thus for example intentions can have intentions. because protection is an intrinsic property of actors  we hope to be able to deal with protection issues in the same straight forward manner as more conventional intentions. intentions 
of data structures are handled by the same machinery as for all other actors. 
	comparative schehatology: 	the theory of comparative power of control structures is 
1 
extended and unified. the following hierarchy of control structures can be explicated by 
incrementally increasing the power of the message sending primitive: 
iterative---recursive---backtrack---+determinate- --universal 
　　　　education: the model is sufficiently natural and simple that it can be made the conceptual basis of the model of computation for students. in particular it can be used as 
the conceptual model for a generalization of seymour papert's  little man  model of logo. the model becomes a cooperating society of  little men  each of whom can address others with whom it is acquainted and politely request that some task be performed. 
　　　　learning and modularity: actors also enable us to teach computers more easily because they make it possible to incrementally add knowledge to procedures without having 
	to rewrite all the knowledge which the computer already possesses. 	incremental extensions 
can be incorporated and interfaced in a natural flexible manner. protocol abstraction  hewitt 1; hart  nilsson  and fixes 1  can be generalized to actors so that procedures with an arbitrary control structure can be abstracted. 
extendability: 	the model provides for only one extension mechanism: 	creating new actors. 	however  this mechanism is sufficient to obtain any semantic extension that might 
be desired. 
　　　　privacf and protection: actors enable us to define effective and efficient protection schemes. 	ordinary protection falls out as an efficient intrinsic property of actors. 	the protection is based on the concept of  use . 	actors can be freely passed out since they will work only for actors which have the authority to use them. 	mutually suspicious  memoryless  subsystems are easily and efficiently implemented. 	actors are at least as powerful a protection mechanism as domains  schroeder  needham  etc.   access 
control lists  multics   objects  wulf 1   and capabilities  dennis  plummer  lampson . because actors are locally computationally universal and cannot be coerced there is reason to believe that they are a universal protection mechanism in the sense that all other protection mechanisms can be efficiently defined using actors. the most important issues in privacy and protection that remain unsolved are those involving intent and trust. we 
are currently considering ways in which our model can be further developed to address these problems. 
　　　　synchronization: 	it provides at least as powerful a synchronization mechanism as the multiple semaphore p operation with no busy waiting and guaranteed first in first out discipline on each resource. 	synchronization actors are easier to use and substantiate than semaphores since they are directly tied to the control-data flow. 
　　　　simultaneous goals: 	the synchronization problem is actually a special case of the simultaneous goal problem. 	each resource which is seized is the achievement and 
maintenance of one of a number of simultaneous goals. recently sussman has extended the previous theory of goal protection by making the protection guardians into a list of predicates which must be re-evaluated every time anything changes. we have generalized 
protection in our model by endowing each actor with a scheduler. we thus retain the advantages of local intentional semantics. a scheduler actor allows us to 
program excuses for violation in case of need and to allow negotiation and re-negotiation between the actor which seeks to seize another and its scheduler. richard waldinger has pointed out that the task of sorting three numbers is a very elegant simple example 
illustrating the utility of incorporating these kinds of excuses for violating protection. resource allocation: each actor has a banker who can keep track of the resources used by the actors that are financed by the banker. 
　　　　structuring: 	the actor point of view raises some interesting questions concerning the structure of programming. 
　　　　　　structured programs: we maintain that actor communication is well-structured. having no goto  interrupt  semphore  etc. constructs  they do not violate  the letter of the law.  some readers will probably feel that some actors exhibit  undisciplined  control flow. these distinctions can be formalized through the mathematical discipline of comparative schematology  patterson and hewitt . 
structured programming: some authors have advocated top down programming. we 
find that our own programming style can be more accurately described as  middle out . 
we typically start with specifications for a large task which we would like to program. we refine these specifications attempting to create a program as rapidly as possible. this initial attempt to meet the specifications has the effect of causing us to change the specifications in two ways: 
　　　　1: more specifications  features which we originally did not realize are important  are added to the definition of the task. 
　　　　1: the specifications are generalized and combined to produce a task that is easier to implement and more suited to our real needs. 
　　　　implementation: actors provide a very flexible implementation language. in fact we are carrying out the implementation entirely in the formalism itself. by so doing we obtain an implementation that is efficient and has an effective model of itself. the 
efficiency is gained by not having to incur the interpretive overhead of embedding the 
	implementation in some other formalism. 	the model enables the formalism to answer 
questions about itself and to draw conclusions as to the impact of proposed changes in the implementation. 
　　　　architecture: 	actors can be made the basis of the architecture of a computer which means that all the benefits listed above can be enforced and made efficient. programs 
	written for the machine are guaranteed to be syntactically properly nested. 	the basic unit 
of execution on an actor machine is sending a message in much the same way that the basic 
1 
	unit of execution on present day machines is an instruction. 	on a current generation 
machine in order to do an addition an add instruction must be executed; so on an actor machine a hardware actor must be sent the operands to be added. there are no goto  semaphore  interrupt  etc. instructions on an actor machine. an actor machine can be built using the current hardware technology that is competitive with current generation machines. 
	 now! now!  cried the queen. 	 faster! faster!  
lewis carroll 
　　　　current developments in hardware technology are making it economically attractive to run many physical processors in parallel. this leads to a  swarm of bees  style of programming. the actor formalism provides a coherent method for organizing and 
controlling all these processors. one way to build an actor machine is to put each actor on a chip and build a decoding network so that each actor chip can address all the others. in certain applications parallel processing can greatly speed up the processing. for example with sufficient parallelism  garbage collection can be done 1n a time which is 
proportional to the logarithm of the storage collected instead of a time proportional to the amount of storage collected which is the best that a serial processor can do. also the 
architecture looks very promising for parallel processing in the lower levels of computer 
audio and visual processing. 
 all the world's a stage  
and all the men and women merely actors. 
they have their exits and their entrances; and one man in his time plays many parts.  
 if it waddles like a duck  quacks like a duck  and otherwise behaves like a duck; then you can't tell that it isn't a duck.  
adding and reorganizing knowledge 
　　　　our aim is to build a firm procedural foundation for problem solving. the foundation attempts to be a matrix in which real world problem solving knowledge can be efficiently and 
naturally embedded. we envisage knowledge being embedded in a set of knowledge boxes with interfaces between the boxes. in constructing models we need the ability to embed more knowledge in the model without having to totally rewrite it. certain kinds of additions can be 
easily encompassed by declarative formalisms such as the quantificational calculus by simply adding more axioms. 	imperative formalisms such as actors do not automatically extend so easily. 	however  we are implementing mechanisms that allow a great deal of flexibility in adding new procedural knowledge. 	the mechanisms attempt to provide the following abilities; 
　　　　procedural embedding:. they provide the means by which knowledge can easily and naturally be embedded in processes so that it will be used as intended. 
　　　　conservative extension: they enable new knowledge boxes to be added and interfaced between knowledge  foxes. 
　　　　modular connectivity: they make it possible to reorganize the interfaces between knowledge boxes. 
　　　　modular equivalence: they guarantee that any box can be replaced by one which satisfies the previous interfaces. 
　　　　actors must provide interfaces so that the binding of interfaces between boxes can be controlled by knowledge of the domain of the problem. the right kind of interface promotes 
modularity because the procedures on the other side of the interface are not affected so long as the conventions of the interface are not changed. 	these interfaces aid in debugging since traps and checkpoints are conveniently placed there. 	more generally  formal conditions can be stated for the interfaces and confirmed once and for all. 
unification 
　　　　we claim that there is a common intellectual core to the following  now somewhat isolated  fields that can be characterized and investigated: 	digital circuit designers  data 
base designers  computer architecture designers  programming language designers  computer 
system architects. 
　　　　 our primary thesis is that there can and must exist a single language for software engineering which is usable at all stages of design from the initial conception through to the final stage in which the last bit 1s solidly 1n place on 
some hardware computing system.  
doug ross 
　　　　the time has come for the unification and integration of the facilities provided by the above designers into an intellectually coherent manageable whole. current systems which separate the following intellectual capabilities with arbitrary boundaries are now obsolete.  know thyself . 
we intend that our actors should have a useful working knowledge of themselves. 	that is  they should be able to answer reasonable questions about themselves and be able to trace the 
implications of proposed changes in their intentions. it might seem that having the implementation understand itself is a rather incestuous artificial intelligence domain but we 
	believe that it is a good one for several reasons. 	the implementation of actors on a 
	conventional computer is a relatively large complex useful program which is not a toy. 	the 
	implementation must adapt itself to a relatively unfavorable environment. 	creating a model of 
itself should aid in showing how to create useful models of other large knowledge based programs 
since the implementation addresses a large number of difficult semantic issues. 	we have a number of experts on the domain that are very interested 1n formalizing and extending their knowledge. 	these experts are good programmers and have the time  motivations  and ability to 
1 
embed their knowledge and intentions in the formalism. 
 the road to hell is paved with good intentions.  
once the experts put in some of their intentions they find that they have to put in a great deal more to convince the auditor of the consistency of their intentions and procedures. in this way we hope to make explicit all the behavioral assumptions that our implementation 1s 
relying upon. the domain is closed 1n the  sense  that the questions that can reasonably be 
asked do not lead to a vast body of other knowledge which would have to be formalized as well. the domain is limited in that 1t is possible to start with a small superficial model of actors and build up incrementally. any advance is immediately useful in aiding and motivating future advances. there 1s no hidden knowledge as the formalism is being entirely implemented in itself. the task is not complicated by unnecessary bad software engineering practices such as the use of gotos  interrupts  or semaphores. 
intrinsic computation 
　　　　we are approaching the problem from a behavioral  procedural  as opposed to an axiomatic approach. our view is that objects are defined by their actors rather than by axiomatizing the properties of the operations that can be performed on them.  ask not what you can do to some actor; but what the actor can  will   do for you.  
alan kay has called this the intrinsic as opposed to the extrinsic approach to defining objects. our model follows the following two fundamental principles of organizing behavior: 
control flow and data flow are inseparable. 
　　　　computation should be done intrinsically instead of extrinsically i.e.  every actor should act for himself or delegate the responsibility  pass the buck  to an actor 
who will.  
although the fundamental principles are very general they have definite concrete consequences. for example they rule out the goto construct on the grounds that it does not allow a message to be passed to the place where control is going. 	thus it violates the inseparability of control 
and data flow. also the goto defines a semantic object  the code following the tag  which is not properly syntactically delimited thus possibly leading to programs which are not properly syntactically nested. similarly the classical interrupt mechanism of present day machines 
violates the principle of intrinsic computation since it wrenches control away from whatever 
instruction is running when the interrupt strikes. 
hierarchies 
the model provides for the following orthogonal hierarchies: 
　　scheduling: every actor has a scheduler which determines when the actor actually acts after it 1s sent a message. the scheduler handles problems of synchronization. another job of the scheduler  rulifson  is to try to cause actors to 
act in an order such that their intentions will be satisfied. 
　　intentions: every actor has an intention which makes certain that the prerequisites and context of the actor being sent the message are satisfied. intentions provide a certain amount of redundancy in the specifications of what is supposed to happen. 
　　monitoring: every actor can have monitors which look over each message sent to the actor. 
　　binding: every actor can have a procedure for looking up the values of names that occur within 1t. 
　　resource management: every actor has a banker which monitors the use of space and time. 
note that every actor had all of the above abilities and that each is done via an 
actor! 
	 a slow sort of country!  said the queen. 	 now here  you see  it 
takes all the running you can do  to keep in the same place. 	if you want to get somewhere else  you must run at least twice as fast as that!  
lewis carroll 
　　　　the previous sentence may worry the reader a bit as she  he  might envisage an infinite chain of actions  such as banking  to be necessary in order to get anything done. we short circuit this by only requiring that it appear that each of the above activities 1s done each 
time an actor is sent a message. 
 there's no use trying   she said:  one can't believe impossible 
things.  
	 i daresay you haven't had much practice   said the queen. 	 when i 
	was your age  i always did it for half-an-hour a day. 	why  sometimes i've 
believed as many as six impossible things before breakfast.  
lewis carroll 
　　　　each of the activities is locally defined and executed at the point of invocation. this allows the maximum possible degree of parallelism. our model contrasts strongly with extrinsic quantlficatlonal calculus models which are forced into global noneffective statements 1n order to characterize the semantics. 
 global state considered harmful.  
　　　　we consider language definition techniques  such as those used with the vienna definition language  that require the semantics be defined in terms of the global computational state to be harmful. formal penalties  such as the frame problem and the definition of simultaneity  must be paid even if the definition only effectively modifies local parts of the 
state. 	local intrinsic models are better suited for our purposes. 
1 
hardware 
　　　　procedural embedding should be carried to its ultimate level: the architecture of the machine. conceptually  the only objects in the machine are actors. in practice the machine recognizes certain actors as special cases to save speed and storage. we can easily reserve a portion of the name space for actors implemented in hardware. 
syntactic sugar 
 what's the good of mercator's north poles and equators  
tropics  zones and meridian lines   
so the bellman would cry: and the crew would reply 
 they are merely conventional signs!  
lewis carroll 
　　　　thus far 1n our discussion we have discussed the semantic issues intuitively but vaguely. we would now like to proceed with more precision. 	unfortunately in order to do this it seems necessary to introduce a formal language. 	the precise nature of this language 1s completely unimportant so long as it 1s capable of expressing the semantic meanings we wish to convey. 	for some 
years we have been constructing a series of languages to express our evolving understanding of the above semantic issues. the latest of these is called planner-1. 
　　　　meta-syntactic variables will be underlined. we shall assume that the reader 1s familiar with advanced pattern matching languages such as sn1l1  convert  qa1  and planner-1. 
　　　　we shall use  %a m%  to indicate sending the message m to the actor a. we shall use  s1 s1 ... sn  to denote the finite sequence s1  s1   ... sn. ft sequence s is an actor where  %s  i%  is element i of the sequence s. for example  % a c b  1%  is c. we will use     to delimit the 
simultaneous synchronous transmission of more than one message so that  al a1...an  will be 
defined to be  %a1  a1 ... an % . the expression  %a1 a1 ... an%   read as   a  then a1 ... finally send back an   willi be evaluated by evaluating al  a1  .... and an in sequence and then sending back   returning   the value of an as the message. 
　　　　identifiers can be created by the prefix operator =. for example if the pattern = x 1s matched with y  then a new identifier is created and bound to v. 
　　 but 'glory' doesn't mean 'a nice knock-down argument   alice objected. 
 when i use a word   humpty dumpty said  in rather a scornful tone  
 it means just what i choose 1t to mean-neither more nor less.  
　　 the question is   said alice   whether you can make words mean so many different things.  
　　 the question is   said humpty dumpty   which is to be master-that's all.  
lewis carroll 
humpty dumpty propounds two criteria on the rules for names: 
each actor has complete control over the names he uses. 
all other actors must respect the meaning that an actor has chosen for a name. 
we are encouraged to note that in addition to satisfying the criteria of humpty dumpty  our names also satisfy those subsequently proposed by bill wulf and mary shaw: the default is not necessarily to 
extend the scope of a name to any other actor. the right to access a name is by mutual agreement between the creating actor and each accessing actor. an access right to an actor and one of its acquantances is decoupled. it is possible to distinguish different types of access. the definition of a 
name  access to a name  and allocation of storage are decoupled. 	the use of the prefix = does not imply 
the allocation of any storage. 
　　　　one of the simplest kinds of actors is a cell. a cell with initial contents v can be created by evaluating  cell v  . given a cell x  we can ask it to send back its contents by evaluating 
 contents xj which is an abbreviation for  x #contents . for example  contents cell 1   evaluates to 1. we can ask it to change its contents to v by evaluating  x-y  . for example if we let x be  cell 1  and evaluate  x--1   we will subsequently find  that  contents x  will evaluate to 1. 
　　　　the pattern  by-reference p  matches object e  1f the pattern pmatches  cell e  i.e. a  cell   see below  which contains e. thus matching the pattern  by-reference =x  against e 1s the same as binding x to  cell e  i.e. a new cell which contains the value of the expression e.we shall use =   read as  receive message   to mean an actor which is reminiscent of the actor lambda in the lambda calculus. for example  =  x body  1s like  lambda x body  where x 1s an identifier. an expression  =  pattern body  is an abbreviation for  receive { #message pattern } body  where receive 1s a more general actor that is capable of binding elements of the action in addition to the message. 
evaluating 
 % =  pattern body  the-messaqe%   i.e. sending 
　　　　 =  pattern body  the-message  will attempt to match the-message against pattern. if the-message is not of the form specified by pattern  then the actor is not applicable to the-message. if the-message 
matches pattern  then body 1s evaluated. 
　　　　evaluating  % cases  f1 f1     fn   arg%  will send fl  the message arg and if it is not applicable then it will send f1 the message arg ...  and send fn the message aro 
the following abbreviations will be used to improve readability: 
 rules object clauses  for 
  cases clauses object  
 let object pattern-for-message body  for 
 % =  pattern-for-message body  objects  
1 



message mechanisms of the current small talk machine of alan kay and the port mechanism of krutat and balzer. being free of side effects allows us a maximum of parallelism and allows an actor to be engaged in several conversations at the same time without becoming confused. 
　　　　1: sending a message to an actor makes no presupposition that the actor sent the message will ever send back a message to the continuation. the unidirectional nature of sending messages enables us to define iteration  monitors  coroutines  etc.straight forwardly  
　　　　1: the actor model is nojt an  environment-pointer  instruction-pointer  model such as the contour model. a'continuation is a full blown actor  with all the rights and privileges ; it is not a program counter. there are no instructions  in the sense of present day machines  in our model. instead of instructions  an actor machine has certain primitive actors built in hardware. 
logic 
 it is behavior  not meaning  that counts.  
　　　　we would like to show how actors represent formulas in the quantificational calculus and how the rules of natural deduction follow as special cases from the mechanism of extension 
worlds. we assume the existence of a function anonymous which generates a new name which has 
never before been encountered. consider a formula of the form  every phi  which means that for every x we have that  phi x  is the case. the formula has two important uses: it can be asserted and it can be proved. we shall use an actor  =   read as  accept request   with the syntax 
　　　　  =  pattern-for-request body  for procedures to be invoked by pattern directed invocation by a command which matches pattern-for-request. 
　　　　our behavioral definitions are reminiscent of classical natural deduction except that we have four introduction and elimination rules  prove  disprove  assert  and deny  to give us more flexibility in dealing with negation. 
 then logic would take you by the throat  and force you to do it!  
lewis carroll 
data bases 
　　　　data bases are actors which organize a set of actors for efficient retrieval. there are two primitive operations on data bases: put and get. a new virgin data base can be 
created by evaluating  virgin . if we evaluate  w +＊  virgin   then  contents w  will be a virgin world. we can put an actor  at john airport  in the world  contents w  by evaluating 
 put at john airport  { #world{contents w    . we could add further knowledge by evaluating  put  at airport boston  { #world  contents w     to record that the airport is at boston. 
　　　　 put {city boston  { #world  contents w     to record that boston is a city. if the constructor extension is passed a message then it will create a world which is an extension of its message. eor example 
 put 
  on john  flight 1   
　　　　 extension-world ＊*-  contents w     will set extension-world to a new world in which we have supposed that john is on flight #1. the world  contents w  is unaffected by this operation. on the other hand the extension world is affected if we do  put   hungry john   contents w   . extension worlds are very good for modeling the following: 
world directed invocation 
　　　　the extension world machinery provides a very powerful invocation and parameter passing mechanism for procedures. the idea is that to invoke a procedure  first grow an 
extension world; then do a world directed invocation on the extension world. this mechanism generalizes the previous pattern directed invocation of planner-1 several ways. pattern directed invocation is a special case in which there is just one assertion in the wish world. world directed invocation represents a formalization of the useful problem solving technique known as  wishful thinking  which is invocation on the basis of a 
fragment of a micro-world. terry winograd uses restriction lists for the same purpose in his thesis version of the blocks world. suppose that we want to find a bridge with a red top which is supported by its left-leg and its right-leg both of which are of the same 
color. 	in order to accomplish this we can call upon a genie with our wish as its message. the genie uses whatever domain dependent knowledge it has to try to realize the wish.  realize 
 utopia 
 top left-leg right-leg color-of-legs} 
; the variables in the uptopia are listed above  
{ 
 color top red  
 supported-by top left-leg  
'supported-by top right-leg  
;ieft-of left-leg right-leg   color left-leg color-of-legs  kcolor left-leg color-of-legs }   
logical hypotheticals are logically possible alternatives to a world. 
         by the normalization theorem for intuitionistic logic our actor definition of the logical constant implies is sufficient to mechanize logical implication. the rules of natural deduction are a special case of our rules for extension worlds and our procedural 
definition of the logical connectives. 
alternative worlds are physically possible alternatives to a world. 
	perceptual viewpoints can be mechanized as extension worlds. 	for example suppose 
1 
rattle-trap is the name of a world which describes my car. then  front rattle-trap  could be a world which describes my car from the front and  left rattle-trap  can be the description from the left side. we can also consider a future historian's view of the present by  vlew-from-1 world-of-1 . mlnsky  considers these possibilities from 
a somewhat different point of view. 
the following general principles hold for the use of extension worlds: 
　　　　　　each independent fact should be a separate assertion. 	for example to record that  the banana banl is under the table tabl  we would assert: 
 banana banl  table tabl  under banl tabl  
instead of conglomerating  mcdermott 1  them into one assertion: 
 at 
 the banl  1s banl banana   
 place 
 the tabl  is tabl table   under   
a person knowing a statement can be analyzed into the person believing the statement and the statement being true. so we might make the following definition of knowing: 
 know  = 
 =   = person = statement  
 and 
 believes person statement  
 true statement     
thus the statement  moore 1   john knows bill's phone number  can be represented by the assertion: 
　　　　 knows john  phone-number bill pn1   where pn1 is a new name and  phone-number bill pn1  is intended to mean that the 
phone number of bill 1s pn1. the assertion can be expanded as follows: 
 believes john  phone-number bill pn1   
 true  phone-number bill pn1   
however the expansion is optional since the two assertions are not independent of the original assertion. 
 whatever logic is good enough to tell me is worth writing down   said the tortoise.  so enter it in your book  please.  
lewis carroll 
　　　　each assertion should have justifications derivations  which are also assertions and which therefore ... 
　　　　extraneous factors such as time and causality should not  be conglomerated  mcdermott 1  into the extension world mechanism. facts about time and causality should also be separate assertions. in this way we can deal more naturally and uniformly with questions involving more than one time. for example we can answer the question  how many times were there at most two cannibals in the boat while the missionaries and cannibals 
were crossing the river   also we can check the consistency of two different narratives of overlapping events such as might be generated by two people who attended the same party. retreival of actors from data bases takes facts about time and causality into account 1n the retreival. thus we still effectively avoid most of the frame problem of mccarthy. the 
ability to do this is enhanced by the way we define data bases as actors. 
　　　　a context mechanism was invented for qa1 to generalize the property list structure of lisp. rulifson explained 1t by means of examples of its use to mechanize identifiers. by use of the functions push-context and popjontext and an epam discrimination net  feigenbaum and simon  the context mechanism can be used to mechanize a version of tree-structured worlds  the tree-structured worlds of planner-1 were invented to get around the problem of having only one 
global data base not realizing that a context mechanism could be used to implement something like that. the tree-structured worlds were defined directly in terms of the hash-coding 
mechanism of planner which had the advantage of decoupling them from the identifier structure of planner. in addition by not conceiving an extension world analogue of p1p c1ntext large gains in efficiency over the context mechanism are possible. 
　　　　worlds can ask the actors put in them to index themselves for rapid retreival.we also need to be able to retrieve actors from worlds. simple retrieval can be done using patterns. 
for example 
 locations +＊  get  at         { #world  contents w  }   will set locations to an actor which will retrieve all the actors stored in  contents w  which match the pattern  at     {   . now  next locations  will thus retrieve either  at airport boston  or  at john airport . actually* the above 1s an over simplification. we shall let $real1ty stand for the current world at any given point and $utopia stand for the world as we would like to see 1t. we do not want to have to explicity store every piece of knowledge which we have but would like to beable to derive conclusions from what is already known: we 
can distinguish several different classes of procedures for deriving conclusions. 
　　　 mccarthy 1s at the airport.   put  at mccarthy airport   if a person 1s at the airport  then the person might take a plane from the airport  
 put-at    
      put  at = person airport   
 put  might  take-plane-from person airport      
          mccarthy 1s not at the airport.   deny  at mccarthy airport   if a person is not at th airport then he can't take a plane from the airport. 
1 
　　　　 mccarthy is not at the airport.   deny  at mccarthy airport   if a person is not at the airport then he can't take a plane from the airport. 
 deny-at = 
  =   deny  at =person airport   
 put  can't  take-plane-from person airport       
　　　　 it is not known whether mccarthy is at the airport    erase  at mccarthy airport   if it is not known whether a person is at the airport then erase whatever depends on previous knowledge that the person is at the airport  
 erase-at  = 
  =   erase  at -person airport   
 find  depends-on =s  at person airport   
 erase s     
　　　　 get mccarthy to the airport.   achieve { at mccarthy airport  }  to achieve a person at a place: 
find the present location of the person. 
show that it is walkable from the present location to the car. 
show that 1t is drivable from the car to the place  
 achieve-at  = 
  =   achieve   at =person =place     
 achieve 
 find   at person -present-location   
	 show 	{ walkable present-location car } 
 show { drivable car place }       
　　　　 show that mccarthy is at the airport.   show { at mccarthy airport }  to show that a thing is at a place show that the thing is at some intermediate and the intermediate is at the 
place. 
 show-at  = 
  =   show { at =th1ng =place }  
 show { at thing 'intermediate } 
　　　　　　　　　　 show { at intermediate place }     the actor show-at is simply transitivity of at. l! anything really better than anything else  
　　　　conniver can easily be defined trtterms of plawr-1. we do this not because we believe that the procedures of conniver are particularly well designed. indeed we have given reasons above why these procedures are deficient. rather we formally define these procedures 
to show how our model applies even to rather baroque control structures. 
　　　　conniver is essentially the conglomeration of the following ideas: landin's nonhierarchical goto-1  the pattern directed construction  matching  retrieval  and invocation of planner  landin's streams  the context mechanism of qaa  and balzer's and krutar's ports. 
in most cases  two procedures in conniver do not talk directly to each other but instead are required to communicate through an intermediary which is called a possibilities list. 
the concept of a possibilities list is the major original contribution of conniver.  what are these 
so wild and withered in their attire  
that look not like the inhabitants 
　　　　1' the earth  and yet are on't   
macbeth: act 1  scene 1 
substitution  reduction  and meta-evaluation 
 one program's constant is another program's variable.  
alan perils 
 programming  or problem solving in general  is the judicious postponement of decisions and commitments!  
edsger w. dijkstra  
 programming languages should be designed to suppress what is constant and emphasize what is variable.  
alan perlis 
 each constant will eventually be a variable!  
corollary to murphy's law 
　　　　we never do unsubstitution  or if you wish decompilation  unsimpllfication  or unevaluation . we always save the higher level language and resubstltute. the metaphor of substitution followed by reduction gives us a macroscopic view of a large number of computational activities. we hope to show more precisely how all the following activities f i t within the general scheme of substitution followed by reduction: 
　　　　evaluation  church  mccarthy  lnadin  can be done by substituting the message into the code and reducing  execution . 
　　　　deduction  herbrand  godel  heyting. prawltz  robinson  hewitt  weyhrauch and milner  can be done by procedural embedding. in this paper we have extended our previous work by defining the logical constants to be certain actors thus providing a procedural semantics for the quantlficational calculus along the lines indicated by 
natural deduction. 
confirming the consistency of actors and their intentions  naur  floyd  hewitt 
1 
1  waldlnger  deutsch  can be done by substituting the code for the actors into their intentions and then meta-evaluating the code. 
　　　　automatic actor generation. an important corollary of the thesis of procedural embedding is that the fundamental technique of artificial intelligence is automatic programming and procedural knowledge base construction. it can be done by the 
following'  methods: 
　　parameterization  church  mccarthy  landin  mcintosh  manna and waldinger  hewitt  of canned procedure templates. 
　　compilation  lombardi  elcock  fikes  daniels  wulff  reynolds  and wegbreit  can be done by substituting the values of the free variables in the code and then reducing  optimizing . for examples we can enhance the behavior of the lists which were behaviorally defined above to vectors which will run 
more efficiently on current generation machines. 
　　abstract impossibilities removal can be done by binding the alternatives with the code and deleting those which can never succeed  what we 
have in mind are situations such as having simultaneous subgoals  on a b  and  on b c  where we can show by meta-evaluation that the order given above can never succeed. 	gerry sussman has designed a program which attempts to abstract this fact from running on concrete examples. 	we believe that in this case and 
many others it can be abstractly derived by meta-evaluation. 
　　example expansion  hart  nilsson  and fikes 1; sussman 1; hewitt 1  can be done by binding the high level goal oriented language to an example problem and then reducing  executing and expanding to the paths executed  using world directed invocation  or some generalization  to create linkages between the variablized special cases. 
　　protocol abstraction  hewitt 1  1  can be done by binding together the protocols  reducing the resulting protocol tree by identifying 
indistinguishable nodes. 
　　abstract case generation to distinguish the methods to achieve a goal can be done by determining the necessary pre-conditions for each method by reducing to a decision tree which distinguishes each method. 
acknowledgements 
 everything of importance has been said before by somebody who did not discover it.  
alfred north whitehead 
　　　　this research was sponsored by the mit artificial intelligence laboratory and project mac under a contract from the office of naval research. we would be very appreciative of any comments  criticisms  or suggestions that the reader might care to offer. please address them to: 
carl hewitt 
room 1 
1 technology square 
m.i.t. artificial intelligence laboratory 
cambridge  massachusetts 1 
　　　　the topics discussed in this paper have been under intense investigation by a large number of researchers for a decade. in this paper we have merely attempted to construct a coherent manageable formalism that embraces the ideas that are currently  in the air . 
　　　　we would like to acknowledge the help of the following colleagues: bill gosper who knew the truth all along:  a data structure is nothing but a stupid programming language.  alan kay whose flex and small talk machines have influenced our work. alan emphasized the crucial importance of using intentional definitions of data structures and of passing messages to them. this paper explores the consequences of generalizing the message mechanism of small talk and simula-1; the port mechanism of krutar  balzer  and mitchell; and the previous call statement of planner-1 to a universal communications mechanism. alan has been extremely helpful in discussions both of overall philosophy and technical details. nick pippenger for his very beautiful iterate statememt and for helping us to find a fast economical decoding net 
for our actor machine. john mccarthy for making the first circular definition of an effective problem solving formalism and for emphasizing the importance of the epistemological problem for artificial intelligence. seymour papert for his  little man  metaphor for computation. allen newell whose kernel approach to building software systems has here perhaps been carried to near its ultimate extreme along one dimension. david marr whose penetrating questions led us to 
further discoveries. rudy krutar  bob balzer  and jim mitchell who introduced the notion of a port which we have generalized into an actor. robin milner is tackling the problems of lvalues and processes from the point of view of the lambda calculus. he has enphasized the practical as well as the theoretical implications of fixed point operators. robin's puzzlement over the meaning of  equality  for processes led to our definition of behavior. edsger dijkstra 
	for a pleasant afternoon discussion. 	jim mitchell has patiently explained the systems 
	implementation language mps. 	jeff rulifson  bruce anderson  gregg pfister  and julian davies 
showed us how to clean up and generalize certain aspects of planner-1. peter landin and john reynolds for emphasizing the importance of continuations for defining control structures. warren teitleman who cleaned up and generalized the means of integrating editors and debuggers in higher level languages. peter landin  arthur evans  and john reynolds for emphasizing the 
	importance of  functional  data structures. 	danny bobrow and ben wegbreit who originated an 
implementation method that cuts down on some of the overhead. we have simplified their scheme 
1 
	by eliminating the reference counts and all of their primitives  	c. a. r. hoare 1s independently 
investigating  monitors  for data structures. jack dennis for sharing many of our same goals in his common base language and for his emphasis on logical clarity of language definition and the importance of parallelism. bill wulff for our  .  notation on the conventions of the values of cells and for being a strong advocate of exceptional cleanliness in language. pitts jarvis and richard greenblatt have given us valuable help and advice on systems aspects. todd matson  brian smith  irene grief  and henry baker are 
aiding us 1n the implementation. chris reeve  bruce daniels  terry winograd  jerry sussman  gene charniak  gordon benedict  gary peskin  and drew mcdermott for implementing previous generations of these ideas in addition to their own. j.c.r. licklider for emphasizing the importance of mediating procedure calls. butler lampson for the notion of a banker and for the question which led to our criteria for separating an actor from its base. richard weyhrauch for pointing out that logicians are also considering the possibility of 
procedural semantics for logic. he is doing some very interesting research in the much abused field of  computational logic.  terry winograd  donald eastlake  bob frankston  jerry sussman  ira goldstein  and others who made valuable suggestions at a seminar which we gave at m.l.t. john shockley for helping us to eradicate an infestation of bugs from this document. greg pfister  bruce daniels  seymour papert  bruce 
anderson  andee rubin  allen brown  terry winograd  dave waltz  nick horn  ken harrenstien  david marr  ellis cohen  ira goldstein  steve zilles  roger hale  and richard howell made valuable comments and suggestions on previous versions of this paper. 
bibliography 
balzer  r.m.   ports-a method for dynamic interprogram communication and job control the rand corp.  1. 
bishop  peter   data types for programming generality m.s. june 1. m.l.t. 
bobrow d.  and wegbreit ben.  a model and stack implementation of multiple environments.  march 1. 
davies  d.j.m.  popler: a p1p-1planner  mip-1. school of a.i. university of edinburgh. 
     deutsch l.p.  an interactive program verifier  phd. university of california at berkeley. june  1 forthcoming. 
     earley  jay.  toward an understanding of data structures  computer science department  university of california  berkeley. 
     elcock  e.w.; foster  j.m.; gray  p.m.d.; mcgregor  h.h.; and murray a.m. abset  a programming language based on sets: motivation and examples. machine intelligence 1. edinburgh  university press. 
fisher. d.a.  control structures for programming languages  phd. carnegie. 1 gentzen g.  collected papers of gerhard gentzen .north holland. 1. 
greif l.g.  induction in proofs about programs  project mac technical report 1. feb. 1. 
     hewitt  c. and patterson m.  comparative schematology  record of project mac conference on concurrent systems and parallel computation. june 1  1. available from acm. 
     hewitt  c.  bishop p.  and steiger r.  the democratic ethos or 'how a society of noncoercable actors can be incorporated into a structured system'  sigplan-sigops interface meeting  savannah  georgia. april  1. 
     hewitt  c  and greif i.  actor induction and meta-evaluation acm sigact-sigplan symposium on principles of programming languages. boston  mass- oct  1. forthcoming. 
hoare  c.a.r.  an axiomatic definition of the programming language pascal  feb. 1. 
kay  alan c. private communication. 
krutar  r.  conversational systems programming  or program plagiarism made easy   first usa-japan 
	computer conference. 	october 1  
lampson  b.  an overview of cal-tss . computer center  university of california  berkeley. 
liskov  b.h.  a design methodology for reliable software systems  the last fjcc. dec.1. pt. 1  1. mcdermott d.v.  assimilation of new information by a natural language-understanding system  m.s. mit. 
forthcoming 1. 
mcdermott  d.v. and sussman g.j.  the conniver reference manual  a.i. memo no. 1. 1. 
milner  r. private communication. 
minsky  marvin.  frame-systems: a theory for representation of knowledge  forthcoming 1. 
mitchell  j.g.  a unified sequential control structure model  nic 1. forthcoming. 
newell  a.  some problems of basic organization in problem-solving programs.  self-organizing systems. 1. 
papert s. and solomon c.  nim: a game-playing program  a.i. memo no. 1. 
     reynolds  j.c.  definitional interpreters for higher-order programming languages  proceedings of acm national convention 1. 
     rulifson johns f.  derksen j.a.  and waldinger r.j.  qa1: a procedural calculus for intuitive reasoning  phd. stanford. november 1. 
scott  d.  data types as lattices  notes. amsterdam  june 1. 
steiger  r.  actors . m.s. 1. forthcoming. 
sussman  g.j.  teaching of procedures-progress report  oct. 1. a.i. memo no. 1. 
waldinger r. private communication. 
wang a. and dahl 1.  coroutine sequencing in a block structured environment  bit 1-1. 
     weyhrauch  r. and milner r.  programming semantics and correctness in a mechanized logic.  first usa-japan computer conference. october 1. 
     winograd  t.  procedures as a representation for data 1n a computer program for understanding natural language  mac tr-b1. february 1. 
w1rth  n.  how to live without interrupts  or some such. vol. 1  no. 1  pp. 1. 
wulf w. and shaw m.  global variable considered harmful  carnegie-mellon university. pittsburgh  pa. 
sigplan bulletin. 1. 
1 
session 1 formalisms for 
artificial intelligence 
a model for control structures 
for artificial intelligence programming languages 
by 
daniel g. bobrow 
computer science division 
xerox palo alto research center palo alto  california 1 
ben wegbreit 
harvard university 
center for research in computing technology 
cambridge  massachusetts 1 

abstract 
　　newer programming languages for artificial intelligence extend the class of available control regimes beyond simple hierarchical control. in so doing  a key issue is using a model that clearly exhibits the relation between modules  processes  access environments  and control environments. this paper presents a model which is applicable to diverse languages and presents a set of control primitives which provide a concise basis on which one can define almost all known regimes of control. 
1. introduction 
　　newer programming languages! for artificial intelligence  e.g.  planner1  conniver 1 bbnllsp.ly qa1' 1 extend the nature of control regimes available to the user. in this paper  we present an information structure model1 which deals with control and access contexts in a programming language; it is based on consideration of the form of run-time data structures which represent program control and variable bindings. the model is designed to help clarify some relationships of hierarchical function calls  backtracking  co-routines  and multiprocess structure. we present the model and its small set of primitive operations  then define several control regimes in terms of the primitives  and then consider extensions to handle cooperating sequential processes. 
	1. 	the basic environment structure 
     in a language which has blocks and procedures  new nomenclature  named variables  can be introduced either by declarations in block heads or through named parameters to procedures. since both define access environments  we call the body of a procedure or block a uniform access module. upon entry to an access module  certain storage is allocated for those new named items which are defined at entry. we call this named allocated storage the basic frame of the module. in addition  certain additional storage for the module may be required for temporary intermediate results of computation; this additional allocated storage we call 
the frame extension. the total storage is called the total frame for the module  or usually just the module frame. 
     a  frame contains other information  in addition to named variables and temporaries. it is often useful to reference a frame by symbolic nomenclature. for this purpose  each frame has a framename  usually the procedure name . when a module is entered  its frame extension is initialized with two pointers  perhaps implicitly ; one  called a link  is a linked access pointer to the frame s  which contains the higher level free variable and parameter bindings accessible within this module. the other  called clink  is associated with control and is a generalized return which points to the calling frame. in algol  these are called the static and dynamic links  respectively. in lisph the two pointers usually reference the same frame  since bindings for variables free in a module are found by 
tracing up the call structure chain.  an exception is the use of functional arguments  and we illustrate that below.  
　　at the time of a call  entry to a lower module   the caller stores in his frame extension a continuation point for the computation. since the continuation point is stored in the caller  the generalized return is simply a pointer to the last active frame. 
     the size of a basic frame is fixed on module entry. it is just large enough to store the parameters and associated information. however  during one function activation  the required size of the frame extension can vary widely  with a computable maximum   since the amount of temporary storage used by this module before calling different lower modules is quite variable. therefore  the allocation of these two frame segments may sometimes  advantageously  be done separately and n on contiguously. this requires a link  blink  from the frame extension to the basic frame which contains the bindings. 
     when a frame is exited  either by a normal exit or by a non-local goto which skips the frame  e. g.   an error condition   it is often useful to perform clean-up action for the frame. examples include: close files opened by the frame which are no longer needed  restore the state of more global structures which have 
been temporarily modified by the frame  etc. terminal action for a frame is carried out by executing an exit function for the frame  passing it as argument the nominal value which the frame is returning as its 
result; the value returned by the exit function is the 
actual value of the frame. the variable values and the exit function are the only components of the frame which can be updated by the user; all the others are fixed at the time of frame allocation. figure 1 summarizes the contents of the frame. 
     figure 1a shows a sketch of an algorithm programmed in a block structure language such as algol 1 with contourslo drawn around access modules. bl has locals n and p  p has parameter n  and b1 locals q and l. figure 1b is a snapshot of the environment structure after the following sequence: bl is entered; p is called  just above p i   the program continuation point after this outer call ; b1 is entered; and f is called from within b1. for each access module there 
are two separate segments - one for the basic frame  denoted by the module name  and one for the frame extension  denoted by the module name* . note that the sequence of access links  shown with dotted lines  goes directly from p to b l * and is different from the control chain of calls. however  each points higher 

1 

 earlier  on the stack. 
     a point to note about an access module is that it has no knowledge of any module below it. if an appropriate value   i . e .   one whose type agrees with the stored return type  is provided  continuation in that 
access module can be achieved with only a pointer to the continued frame. no information stored outside this frame is necessary. 
     figure 1 shows two examples in which more than one independent environment structure is maintained. in figure 1a  two coroutines are shown which share common access and control environment a. note that 
the frame extension of a has been copied so that 
returns from b and q may go to different continuation points. 	this is a key point in the model; whenever a frame extension is required for conflicting purposes  a copy is made. 	since frame a is used by two processes  if either coroutine were deleted  the basic frame for a should not be deleted. 	however  one frame extension a* could be deleted in that case  since frame extensions are never referenced directly by more than one process. 	since the basic frame a is shared  either process can update the variable bindings in it; such changes are seen both by b and q  in figure 1b  coroutine q is shown calling a function d with external access chain through b  but with control to return to q. 
	1. 	primitive functions 
     in this model for access module activation  each frame is generally released upon exit of that module. only if a frame is still referenced is it retained. all non-chained references to a frame  and to the environment structure it heads  are made through a special protected data type called an environment descriptor  abbreviated ed. the heads of all environment chains are referenced only from this space of descriptors.  the one exception is the implicit ed for the currently active process.  the primitive functions create an ed for a specified frame and update the contents of an ed; create a new frame with specified contents  and allow execution of a computation in that context; and access and update the exit function for a frame. note that none of the primitives manipulate the links of existing frames; therefore  only well-formed frame chains exist   i . e .   no ring structures . 
1  environ pos  - creates an environment descriptor for the frame specified by pos. 
1  setenv olded  pos  -- changes the contents of an existing environment descriptor olded to point to the frame specified by pos. as a side effect  it releases storage referenced only through previous contents of olded. 
1  mkframe epos apos  epos bpos bcopflg  -- creates a new frame and returns an ed for that frame. the frame extension is copied from the frame specified by epos  and the alink and clink are specified by apos and epos  respectively. the blink points to the basic frame specified by bpos  or to a copy of the basic frame if bcopflg=true. in use  arguments may be omitted; bcopflg is defaulted to false; apos  bpos and epos are defaulted to the corresponding fields of the frame specified by epos. thus mkframe epos  creates a new frame extension identical to that specified by epos. 
1  enveval forra apos cpos  - creates a new frame and initiates a computation with this environment structure. alink and clink point to frames specified by apos and epos  respectively; and form specifies the code to be executed  or the expression to be evaluated in this new environment. if apos or cpos are omitted  they are defaulted to the alink or clink of this invocation of enveval. 
thus  enveval form  is the usual call 	to 	an interpreter  and has the same effect as if the value of form had appeared in place of the simple call to enveval. 
1  setexfn pos fn  - places a pointer to a user defined function in the exitfn field of the frame pos. if the system is using the exitfn  this will create a new function which is the composition of the user function  applied first  and the system function. on frame exit  the exitfn will be called with one argument  the value returned by the frame code; the value returned by fn will be the actual value r e turned to the frame specified by clink. 
1  getexfn pos  - gets the user set function stored in exitfn of frame pos. returns nil if none has been explicitly stored there. 
1  framenm pos  -- returns the framename of frame pos. 
a frame specification  i.e.   pos  apos  bpos  epos  epos above} is one of the following: 
1. an integer n: 
a. n=1 specifies the frame allocated on activation of the function environ  setenv  etc. in the case of environ  setenv and mkframe  the continuation point is set up so that a value returned to this frame  using enveval  is returned as a 
value of the original call to environ  setenv or mkframe. 
b. n 1 specifies the frame n links down the control 
link chain from the n=1 frame. 
c. n 1 specifies the frame ini links down the access link chain from the n=1 frame  
1. a list of two elements  f n  where f is a framename and n is an integer. this gives the nth frame with name f  where a positive  negative  
value for n specifies the control  access  chain 
environment. 
1. the distinguished constant nil. as an access-link specification  nil specifies that only global values are to be used free. a process which returns along a nil control-link will halt. doing a setenv ed nil  releases frame storage formerly referenced only through ed  without tying up any 
new storage. 
1. an ed  environment descriptor . when given an ed argument created by a prior call on environ  environ creates a new descriptor with the same contents as ed; setenv copies the contents of ed 
into olded. 
1. a list   ed   consisting of exactly one ed. the contents of the listed ed are used identically to 
that of an unlisted ed. however  after this value is used in any of the functions  setenv ed.nil  is done  thus releasing the frame storage formerly referenced only through ed. this has been com-
bined into an argument form rather than allowing the user to do a setenv explicitly because in the call to enveval the contents are needed  so it cannot be done before the call; it cannot be done explicitly after the enveval since control might never return to that point. 
	1. 	non-primitive control functions 
     to illustrate the use of these primitive control functions  we explain a number of control regimes which differ from the usual nested function call-return hierarchical structure  and define their control structure routines in terms of the primitives. we include stack jumps  function closure  and several multiprocessing disciplines. in programming examples  we 
use the syntax and semantics of a lisp-like system. in an ordinary hierarchical control structure 
system  if module f calls g  g calls h  and h calls j  it is impossible for j to return to f without going back through g and h. consider some program in which a search is implemented as a series of such nested function calls. suppose j discovered that the call to g was inappropriate and wanted to return to f with such a message. in a hierarchical control structure  h and g would both have to be prepared to pass such a message back. however  in general  the function j should not have to know how to force intermediaries; it should be able to pass control directly to the relevant module. two functions may be defined to allow such jumpbacks.  these are implemented in bbn-lisp;1 experience has shown them to be quite useful.  the first function  retfrom form pos   evaluates form in the current con-
text  and returns its value from the frame specified by pos to that frame's caller; in the above example  this returns a value to g's caller  i.e.  p  the second 
function  retevakform  pos   evaluates form in the context of the caller of pos and returns the  value of the form to that caller. these are easily defined in terms of enveval: 
retfrom form pos  = enveval{form 1 pos  retevalform  pos  = envevalform  pos  pos  
 the second argument to retfrom establishes that the current environment is to be used for the evaluation of 
form.  
　　as another example of the use of retfrom  consider an implementation of the lisp error protection mechanism. the programmer  wraps a form in errorset   i.e.  errorset form  which is defined as cons eval form  nil . this  wrapping  indicates to 
the system the programmer's intent that any errors which arise in the evaluation of form are to be handled by the function containing the errorset. since the value of errorset in the non-error case is always a list consisting of one element  the value of form   an error can be indicated by forcing errorset to return any non-list item. 	hence  the system function error can be defined as retfrom nil  errorset 1   where 
uppercase items are literal objects in lisp. this jumps back over all intermediary calls to return nil as the value of the most recent occurrence of errorset in the hierarchical calling sequence. 
　　in the following  we employ envapply which takes as arguments a function name and list of  already evaluated  arguments for that function. envapply simply 
creates the appropriate form for enveval. 
envapply fn args aframe  cframe  = enveval list apply   list quote  fn   list quote  args    aframe  cframe  
　　a central notion for control structures is a pairing of a function with an environment for its evaluation. following lisp  we call such an object a funarg. 
funargs are created by the procedure function  defined function fn =list funarg  fn  environ 1   
that is  in our implementation  a funarg is a list of three elements: the indicator funarg  a function  and an environment descriptor.  the argument to environ makes it reference the frame which called function.  a funarg list  being a globally valid data structure  can be passed as an argument  returned as a result  or assigned as the value of appropriately typed variables. when the language evaluator gets a form  fen arg1 arg1 ... argn  whose functional object fen is a funarg  i. e.   a list  funarg fn-name ed   it 
creates a list  args  of  the values of  argl  arg1  . . . . argn and does envapply second fcn  args third fcn   1  the environment in this case is used exactly like the original lisp a-list. moses 1 and weizenbaum1 have discussed the use of function for preserving binding contexts. figure 1 illustrates the environment structure where a functional has been passed down: the function foo with variables x and l has been called; foo called mapcar x function fie   and fie has been entered. note that along the access chain the first free l seen in fie is bound in foo  although there is a bound variable l in mapcar which occurs first in the control chain. since frames are retained  a funarg can be returned to higher contexts and still work.  burge1 gives examples of the use of funargs passed up as values.  
　　in the above description  the environment pointer is used only to save the access environment. 	in fact  however  the pointer records the state of a process at the instant of some call  having both access and 
control environments. hence  such an environment pointer serves as part of a process handle. it is convenient to additionally specify an action to take when the process is restarted and some information to be passed to that process from the one restarting it. the funarg can be reinterpreted to provide these features. the function component specifies the first module to be run in a restarted process  and the arguments  evaluated in the caller  provided to that function can be used to pass information. hence  a funarg can be used as a complete process handle. it proves convenient for a running process to be able to reference its own process handle. to make this simple  we adopt the convention that the global variable curproc is kept updated to the current running process. 
　　with this introduction  we now define the routines start and resume  which allow control to pass among a set of coordinated sequential processes  i.e.   coroutines  in which each maintains its own control and access environment  with perhaps some sharing . a coroutine system consists of n coroutines each of 
which has a funarg handle on those other coroutines to which it may transfer control. to initiate a process represented by the funarg fp  use start  we use 
brackets below to delimit comments : 
start fp.args  = curproc - fp; 
  curproc is a global variable set to the current process funarg   ; 
envapply second fp  args third fp  third fp   
once the variable curproc is initialized  and any coroutine started  resume will transfer control between 
n coroutines. the control point saved is just outside the resume  and the user specifies a function  backfn  to be called when control returns  i.e.  the process is resumed. this function is destructively inserted in 
the funarg list. the args to this function are specified by the coroutine transferring back to this point. 
resume fnarg args backfn  = second  curproc  - backfn; 
 save the specified backfn for a subsequent resume back here  
setenv third curproc   1 ; 
　　 environment saved is the caller of resume  curproc - fnarg; 
 set up curproc for the coroutine to be activated  
envapply second fnarg  args third fnarg   third  fnarg   
 activate the specified coroutine by applying its backfn to args  
　　we call a funarg used in this way a process funarg. the state of a  process  is updated by destructively modifying a list to change its continuation function  and similarly directly modifying its environment descriptor in the list. a pseudo-multiprocessing capability can be added to the system using these process funargs if each process takes responsibility for requesting additional time for processing from a supervisor or by explicitly passing control as in conniver 1 a more automatic multiprocessing control regime using interrupts is discussed later. 
     backtracking is a technique by which certain environments are saved before a function return  and later restored if needed. 	control is restored in a strictly last saved  first restored order. 	as an example of its use  consider a function which returns one  selected  value from a set of computed values but can effectively return an alternative selection if the 
first selection was inadequate. that is  the current process can fail back to a previously specified fail set point and then redo the computation with a new selection. a sequence of different selections can lead 
to a stack of failset points  and successive fails can restart at each in turn. backtracking thus provides a way of doing a depth-first search of a tree with return to previous branch points. 
     we define fail and failset below. we use push l a  which adds a to the front of l  and pop l  which removes one element and returns the first element of l. failist is the stack of failset points. as defined below  fail can reverse certain changes when returning to the previous failset point by explicit direction at the point of failure.  to automatically undo certain side effects and binding changes  we could define  undoable  functions which add to failist forms whose evaluation will reset appropriate cells. fail 
could then eval all forms through the next ed and then call enveval.  
failset{   = push failist environ 1   
        1 means environment outside failset  fail message  = enveval message list pop failist    
     the function select defined below returns the first element of its argument set when first called; upon subsequent fails back to select  successive elements from set are returned. if set is exhausted  failure is propagated back. the code uses the fact that the binding environment saved by failset shares the variable fig with the instance of select which calls failset. the test of fig is reached in two ways: after a call on failset  in which case fig is false  and after a failure  in 
which case fig is true . 
select set undolist  = progt  fig  s1: if null set  then fail undolist   leave here and 
undo as specified  
fig - false; failsetot 
 fig is true iff we have failed to this point; then 
set has been popped  
if fig then go sl ; fig - true; returntpop set  ; 
end 
floyd  1 hewitt 1 and golomb and baumert 1 have discussed uses for backtracking in problem solving. sussman l 1 has discussed a number of problems with backtracking. in general  it proves to be too simple a form of switching between environments. use of the multiple process feature described above provides much more flexibility. 
1. 	coordinated sequential processes and parallel processing 
     it should be noted that in the model above  control must be explicitly transferred from one active environment to another  by means of enveval or resume . we use the t e r m   coordinated sequential process  to describe such a control regime. there are situations in which a problem statement is simplified by taking a 
quite different point of view - assuming parallel  cooperating sequential  processes which synchronize only when required  e. g.   by means of dijkstra's 1 p and v operations . using our coordinated sequential processes with interrupts  we can define such a control regime. 
     in our model of environment structures  there is a tree formed by the control links  a dendrarchy  of frames. one terminal node is marked for activity by the current control bubble  the point where the language evaluator is operating . all other terminal nodes are referenced by environment descriptors or by an access link pointer of a frame in the tree. to extend the model to multiple parallel processes in a single processor system  k branches of the tree must 
be simultaneously marked active. then the control bubble of the processor must be switched from one active node to another according to some scheduling algorithm. 
     to implement cooperating sequential processes in our model  it is simplest to think of adjoining to the set of processes a distinguished process  ps  which 
acts as a supervisor or monitor. this monitor schedules processes for service and maintains several privileged data structures  e.g.   queues for semaphores and active processes .  a related technique is 
used by premier  1   
     the basic functions necessary to manipulate parallel processes allow process activation  stopping  continuing  synchronization and status querying. in a single processor coordinated sequential process model  these can all be defined by calls  through 
enveval  to the monitor ps. specifications for these functions are; 
1  process form  apos  cpos  -- this is similar to enveval except that it creates a new active process p' for the evaluation of form  and returns 
to the creating process a process descriptor  pd  which acts as a handle on p'. 
in this model  the pd could be a pointer to a list which has been placed on a  runnable  queue in ps  and which is interpreted by ps when the scheduler in ps gives this process a time quantum. one element of the process descriptor gives the status of the process  e.g.   running or stopped. process is defined using environ  to obtain an environment descriptor used as part of the pd  and enveval  to call ps   
1  stop pd  - halts the execution of the process specified by pd - ps removes the process from runnable queue. the value returned is an ed of the current environment of pd. 
1  continue pd  -- returns pd to the runnable queues. 
1  status pd  - value is an indication of status of pd. 
1  obtain semaphore  - this dijkstra p operator transfers control to ps  by enveval  which determines if a resource is available  i. e   semaphore count positive . ps either hands control back to pi  with enveval  having decremented the the semaphore count  or enters p1 on that semaphore's queue in ps's environment and switches control to a runnable process. 
1  release semaphore  -- this dijkstra v operator increments the semaphore count; if the count goes positive  one process is moved from the semaphore queue  if any exist  onto the runnable queue and the count is decremented. it then hands control back to the calling process. 
     we emphasize that these six functions can be defined in terms of the control primitives of section 1. 
     scheduling of runnable processes could be done by having each process by agreement ask for a time resource  i . e .   obtain time   at appropriate intervals. in this scheduling model  control never leaves a process without its knowledge  and the monitor simply acts as a bookkeeping mechanism. 	alternatively  ordinary time-sharing among processes on a time quantum basis could be implemented through a timer interrupt mechanism. 	interrupts are treated as forced 

calls to environ  to obtain an ed for the current state   and then an enveval to the monitor process. the only problem which must be handled by the system in forcing the call to environ is making sure the interrupted process is in a clean state; that is  one in which basic communication assumptions about states of pointers  queues  buffers  etc. are true  e.g.  no pointers in machine registers which should be traced during garbage collection . this can be ensured if asynchronous hardware interrupts perform only minimal necessary operations  and set a software interrupt flag. soft-
ware checks made before procedure calls  returns and backward jumps within program will ensure that a timely response in a clean state will occur. 
　　the ed of the interrupted process is sufficient to restart it  and can be saved on the runnable queue within a process descriptor. because timer interrupts are asynchronous with other processing in such a simulated multiprocessor system  evaluation of forms in the dynamic environment of another running process cannot be done consistently; however  the ed obtained from stopping a process provides a consistent environment. because of this interrupt asynchrony  in order to ensure system integrity  queue and semaphore management must be uninterruptible  e.g.  at 
the highest priority level. 
     obtaining a system of cooperating sequential processes as an extension of the primitives has a number of desirable attributes. most important  perhaps  it allows the scheduler to be defined by the user. when parallel processes are used to realize a breadth-first search of an or-graph  there is a significant issue of how the competing processes are to be allotted time. provision for a user supplied scheduler establishes a framework in which an intelligent allocation algorithm can be employed. 
　　once a multi-process supervisor is defined  a variety of additional control structures may be readily created. as an example  consider multiple parallel returns - the ability to return from a single activation of a module g several times with several  different  
values. for g to return to its caller with value given by val and still continue to run  g simply calls process val  1 . then the current g and the new process proceed in parallel. 
1. conclusion 
　　in providing linguistic facilities more complex than hierarchical control  a key problem is finding a model that clearly exhibits the relation between processes  access modules  and their environment. this paper has presented a model which is applicable to languages as diverse as lisp  apl and pl/i and can be used for the essential aspects of control and access in each. the control primitives provide a small basis on which one can define almost all known regimes of control. 
　　although not stressed in this paper  there is an implementation for the model which is perfectly general  yet for several subcases  e.g.  simple recursion and backtracking  this implementation is as efficient as existing special techniques. the main ideas of the implementation are as follows  cf.  for details . the basic frame and frame extension are 
treated as potentially discontiguous segments. when a frame extension is to be used for running  it is copied to an open stack end if not there already  so 
that ordinary nested calls can use simple stack discipline for storage management. reference counts are combined with a count propagation technique to ensure 
that only those frames are kept which are still in use. 
　　thus  the model provides both a linguistic framework for expressing control regimes  and a practical basis for an implementation. it is being incorporated intobbn-lisp.1 
1. acknowledgments 
this work was supported in part by the advanced 
research projects agency under contracts dahc 1 and f1-1  and by the u.s. air 
force electronics systems division under contract 
f1-c-1. daniel bobrow was at bolt beranek and newman  cambridge  massachusetts  when many of the ideas in this paper were first developed. 
