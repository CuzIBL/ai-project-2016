 	representation 
　　　
　　　the problem of reconstructing a procedure from traces of i t s behavior is considered. a representation for procedures  including backtracking procedures  is described and a d e f i n i t i o n of a trace or protocol is presented. algorithms f o r the construction of a procedure from a set of traces and for i t s correction using additional traces are described. 
introduction 
　　　if one is interested in developing systems whose c a p a b i l i t i e s increase  then it is clear that one must be concerned about the mechanics of how such a system might acquire procedures. this kind of problem is examined in sussman's hacker 
   1     a program whose c a p a b i l i t i e s increase as it solves problems and acquires procedures. hacker 
makes use of problem specific information and general procedural information to w r i t e a program and debug i t . 
　　　once a solution to a problem is found  one would expect a problem solver to generalize the solution in order to use the knowledge gained in solving that p a r t i c u l a r problem to solve others. the generalization could involve domain-specific knowledge  l i k e replacing one type of object by a more general type of object. on the other hand  if one views a solution  a sequence of steps  as a trace from some unknown procedure on some input  then the generalization might involve the i n t r o duction of variables and the formation of loops. 
　　　hewitt  1l discusses the formation of procedures from protocols - i n s t r u c t i o n traces. he is concerned with creating variables and generali z i n g protocols to recursive procedures. biermann  1d discusses the synthesis of a turing machine from traces of i t s behavior. he i l l u s t r a t e s how t h i s technique can be used to form loops. 
　　　we b u i l d upon and extend the ideas of these authors. we introduce a representation for procedures and an execution r u l e . based upon t h i s representation and the r u l e   we describe the class of protocols we shall consider. following biermann's ideas we describe an algorithm for cons t r u c t i n g a procedure from a set of protocols. the construction involves the formation of loops  replacement of constants by parameters and the resolution of variable renamings. 
　　　we continue by describing techniques for debugging a previously constructed procedure by using new protocols. the debugging process uses the constructed procedure and the new protocols; it does not require the retention of the previous traces. the debugging process cannot always be guaranteed to correct a constructed procedure  however  for many procedures  it works very w e l l . 
　　　we shall r e s t r i c t our discussion of procedures to function procedures  that i s   procedures which  if executed sucessfully  return a single value. the techniques we s h a l l describe are not r e s t r i c t e d to t h i s p a r t i c u l a r form of procedures  but t h i s r e s t r i c t i o n w i l l s i m p l i f y many of our d e s c r i p t i o n s .  a more complete treatment can be found in t i l .   
　　　we shall also be concerned with backtracking  p r i m a r i l y because of i t s importance  in some form  in recent work on problem solving  1 1. if the solutions we are t r y i n g to generalize involve backt r a c k i n g   then our model of procedures must have t h i s form of control as w e l l . thus  in a d d i t i o n to normal sequential c o n t r o l   our representation f o r procedures w i l l involve backtrack c o n t r o l . 
　　　our representation w i l l involve three  kinds  of instructions - assignment statements  tests and return statements. assignment statements have the form  where x is a variable and t is a 
constant  a variable or a function invocation. a 
function invocation i s   where f i s a function of n arguments and each a is a constant or v a r i a b l e . a function returns . single value if executed successfully. because of the p o s s i b i l i t y of backtracking  if a function is not executed successfully  but does h a l t   then we say that it f a i l s . 
　　　tests are i n s t r u c t i o n s of the form p   t   . .   t    where p is a predicate  a function returning true or false  and each ti is a constant  a v a r i a b l e or a function invocation. like functions  tests may f a i l as w e l l . 
　　　the remaining kind of i n s t r u c t i o n is return  a   where a is a constant  a v a r i a b l e . true or false. the execution of t h i s i n s t r u c t i o n means a successf u l execution of the procedure and the r e t u r n of the value of a. 
　　　our basic structure w i l l be a f i n i t e   rooted  labelled directed graph. each node is l a b e l l e d 
by an i n s t r u c t i o n and the successors of each node are ordered. a l i s t of d i s t i n c t variables from instructions l a b e l l i n g the nodes is designated as the l i s t of parameters. the directed graph and t h i s l i s t form a procedure. 
　　　the execution of a procedure begins when the parameters are given values  that i s   bound . the i n s t r u c t i o n l a b e l l i n g the root node is e v a l uated f i r s t . the execution proceeds depth f i r s t u n t i l reaching an assignment or test which f a i l s when evaluated or u n t i l reaching a test which evaluates to false. the execution then resumes at the last successfully node with an untried successor. the value of a l l variables are r e stored to the value they had a f t e r the execution of t h i s node. if a l l the successors of the root node are t r i e d unsuccessfully  then the procedure 
1 
　　　
f a i l s . 
　　　let us i l l u s t r a t e t h i s r u l e on a simple procedure. figure 1 represents a function pairs  l x  of two arguments  the root is underlined; successors are ordered l e f t to r i g h t   . the f i r s t argument  l  is a l i s t   possibly empty  containing n u l l l i s t s or pairs of atoms. the second argument  x  is an atom. pairs searches l looking for the f i r s t pair whose second element has the same value as x or whose second element is a '   ' . pairs then returns the f i r s t element. if l is n i l or if pairs f a i l s to f i n d a p a i r   it returns n i l . 

　　　now consider pairs    a '   '       '   '   . the root is labelled by y -nil; i t s evaluation makes y n i l . the f i r s t successor  null l  is evaluated - r e t u r n ing false. the execution then resumes at the next successor of y -nil  namely z -tl l  . the evaluation of t h i s i n s t r u c t i o n makes z n i l . i t s only successor  l -hd l   is evaluated making l  a '   '   . i t s f i r s t successor  null l   evaluates to false; the second successor assigns a to y. the next two i n s t r u c t i o n s assign ' ' to l. the f i r s t successor of l -hd l   namely l = x  evaluates to true. the return  y  is evaluated  returning 
a and s i g n i f y i n g the end of the execution of pairs. 
　　　this backtracking r u l e is naive  but it does provide a beginning f o r studying traces from procedures involving more complex backtracking control structures. 
　　　our next task is the description of a protocol let p x   . . .   x   be a procedure in our representa t i o n and l e t a 1   . . .   a be the input we wish to use to i l l u s t r a t e how p works. imagine that we have ''unwound  the directed graph of p to form an i n f i n i t e tree  or f i n i t e if p has no loops . using our execution r u l e   if we evaluate p a 1 ... a   and it halts  either returns a value or f a i l s     then the nodes of the i n f i n i t e tree evaluated during the execution form a f i n i t e subtree. replace each node of t h i s f i n i t e subtree by i t s label  instruction  - t h i s is our trace. we s h a l l c a l l t h i s trace a pure trace. 
　　　in our description of pairs  the pure trace produced by pairs  t a             ' '  would be that in figure 1. 

　　　unfortunately  traces are seldom pure. most traces are v a r i a t i o n s of pure traces - f o r example  using constants in the trace instead of v a r i a b l e s . we s h a l l only consider two v a r i a t i o n s of pure traces. the f i r s t involves replacing a parameter that occurs in the trace by the input constant t h a t was bound to i t . this can be done in two ways. f i r s t   if x is a parameter and c was the constant bound to i t   we may add the node x -c as the new root node of the trace.  one can think of t h i s as our syntactic version of   l e t ' s say x is c   prefacing a verbal description of some operations on x.  a l t e r n a t i v e l y   we may replace any occurrence of x by c along any number of branches from the root node. in t h i s case however  replacement is permitted in those i n s t r u c t ions along a branch occurring before a node of the form x -... occurs  with replacements of x occurr i n g on the r i g h t hand side permitted . 
　　　our second a l t e r a t i o n involves renaming v a r i ables. we may replace any variable by another as long as we replace a l l occurrences of a variable by a new one and never introduce a variable which already appears in the trace. 
　　　let us transform our protocol of pairs    a '   '       '    using these rules. let us f i r s t i n s e r t constants. replace l by   a '  '1 and x by '   ' . then l e t us rename variables as f o l l o w s : y becomes v  w becomes z and l becomes m. the r e s u l t i n g trace is  ignore numbers f o r the moment  : 

　　　we f e e l that these v a r i a t i o n s of pure traces permit us to talk about a class of traces which contain important c h a r a c t e r i s t i c s which we might expect of traces generated by a problem solver or presented by a person - use of constants and use of v a r i a b l e s . 
　　　
1 
　　　
　　　in the next section we shall be concerned with the construction and correction of procedures from pure traces and transformations of pure traces  henceforth we shall refer to both pure traces and transformations of pure traces as just ' t r a c e s ' or p r o t o c o l s   . 
construction 
　　　our f i r s t task concerns the construction of a procedure from a given set of protocols. suppose that in addition to the trace of figure 1 we also have the trace of figure 1. take these two as our set of given traces. 
   assume that we have no idea what procedure the traces came from  j u s t that they come from the same procedure and the transformations described e a r l i e r may or may not have been used. 	we s h a l l i l l u s t r a t e the workings of the algorithm on these examples and then b r i e f l y summarize the major steps 

　　　let us c a l l a set of similar nodes i d e n t i f i able if the sets of a l l f i r s t   second    successors from the nodes in the set are s i m i l a r . for example  { 1   1} is i d e n t i f i a b l e because the set of f i r s t successors  {1  1   and the set of second successors  1  1   are both s i m i l a r sets. the set {1  1  is not i d e n t i f i a b l e since the set of f i r s t successors  {1  1   is not s i m i l a r . 
　　　with these notions presented  we can now describe how the construction algorithm would generalize these protocols. 
　　　f i r s t l y   we know that nodes of the form var.-  const  might have been added  using the f i r s t transformation . we also know that nodes containing function invocations or tests or nodes which have multiple successors could not have been added. using these rules we proceed along the path from the root node u n t i l we reach a node we are sure has not been added. in our examples  these are nodes 1 and 1. 
　　　working backwards from these nodes  we can see if corresponding nodes in both traces are s i m i l a r . when we reach the root nodes or find non-similar corresponding nodes we stop. we conclude that nodes accepted during t h i s process must have been added - node 1 in our example. we delete these added nodes and s h a l l use them to help determine parameters. we shall c a l l t h i s process reduction. 
　　　we then begin to match the set of protocols with one another. the nodes match if they are s i m i l a r . the matching process proceeds from the root nodes  along corresponding paths  two paths from two nodes 'correspond' if they begin with the i successor of each node  say n1 and n   and one of n1   n1 has no successor or the paths from n1 and n1 correspond . matching provides a means of grouping nodes l i k e l y to be i d e n t i f i a b l e and finding substitutions. 
　　　the matching in our example proceeds as follows: nodes 1 and 1 match  i n d i c a t i n g that v and y are probably the same v a r i a b l e . matching 1 
　　　and 1 t e l l s us that l has been replaced by   a '   '     . matching 1 and 1 we see t h a t z and w are the same variable and that l has been replaced by   a '     l   again. this l a s t f a c t agrees with the previous information. if instead o f   t a '   '     
we had found   b '   '       then l would have had to be replaced by two constants. since t h i s event would be beyond explanation in terms of our t r a n s formations  and  in f a c t   indicate an error  we would terminate the attempt to construct a procedure . 
　　　matching 1 and 1 reveals t h a t l has been replaced by  la ' ' } and that l must represent the same variable as m - an apparent  c o n t r a d i c t i o n . this is not really a problem since variables can be replaced by constants and renamed as well  that i s   involved in both transformations . as long as 
we do not f i n d l replaced by two d i f f e r e n t constants or variables in the same t r a c e   we are s a t i s f i e d . 
　　　the results of the matching process are the following pairs of nodes:  1    1    1    1    1    1    1    1    1 . the following 'equivalences' are discovered as w e l l : v and y    a '   '   1   m and l and w and z. assuming that we use the variables in figure 1 as a basis  these equivalences suggest that the f o l lowing substitutions have occurred. v for y    a '   '     and m for l and w for 1. 
　　　the next step is to form sets of i d e n t i f i a b l e nodes and t r y to collapse the two traces together and form loops in the process. but which sets do we choose  since we are interested in constructing a general procedure  we choose sets of i d e n t i f i a b l e nodes which r e s u l t in the fewest number of sets containing a l l the nodes. however  we also make sure that nodes paired during the matching process remain together. 
　　　
1 
　　　
　　　the actual procedure used to f i n d such a set is s i m i l a r to the refinement procedure used to minimize the states in f i n i t e state machines t 1   . 
　　　now using the nodes omitted during the r e duction and the s u b s t i t u t i o n s discovered  it is easy to deduce that l was a parameter. since '   ' occurred in the parameter l i s t   we create a new v a r i a b l e   say x  and replace occurrences of '   ' by x. the r e s u l t i n g procedure appears in figure 1. 
modification 
　　　the procedure constructed is not the one we intended. of course  in the way we are b u i l d i n g procedures  one could not expect a correct procedure to be constructed from these two l i m i t e d 
　　　protocols. 
we then match our old procedure with our new 　　　our task  now  is to correct t h i s procedure  if possible  given new protocols. in t h i s case  such a correction is possible. let figure 1 be the new p r o t o c o l . 
　　　
1. given a chosen class of i d e n t i f i a b l e sets  f i n d the substitutions for the class which make the i n s t r u c t i o n s in each set i d e n t i c a l . if any of the substitutions produced contradict those found in matching  p a r t i t i o n the class by grouping nodes to avoid the contradictory substitutions and continue with step 1.  see example in the next section.  
1. replace constants in each parameter l i s t by the variables replacing them in the s u b s t i t u t i o n s . replace the constants remaining in the l i s t s by new v a r i a b l e s . 	the variables in the same p o s i t ion of the argument l i s t s of the protocols must be the same. 	this becomes the parameter l i s t of the 
procedure. 	f i n a l l y   	replace constants in the constructed procedure by variables in the parameter l i s t which replaced these constants. 
p r o t o c o l . we f i n d that 1 and b  1 and c  1 and d  1 and e  1 and f a l l match  but that 1 and g do not! this indicates that something is wrong. 
　　　consider the consequences of i d e n t i f y i n g two nodes to form a loop - we create a node which has more than two predecessors or a root node with one or more predecessors. we c a l l such nodes c r i t i c a l nodes. they w i l l form the basis of our correction process. the c r i t i c a l nodes in figure 
1 are: 1 - y -nil  1 - null l   1 - return  y    1 - l = x. 
　　　now  continuing at the point of our match where we found that 1 and g do not match  we proceed back along the matched path. we proceed u n t i l we reach a c r i t i c a l node; in t h i s case  node 1. 
1 if we reach the s t a r t node without encountering a 
c r i t i c a l node  then we f a i l . 
　　　we terminate our successful matches at the predecessor of the c r i t i c a l node and i t s corresponding node in the trace. we note which node in the trace and which node of the procedure cannot be p a i r e d . in our example  these are nodes 1 and f. 
pseudo-traces 
　　　if we had kept the previous traces  then we could just use the construction procedure with the new protocol and the previous ones. in practice we would not want to r e t a i n a l l protocols  so t h i s approach is not possible. however  we s t i l l have most of the information available - in the constructed procedure. a l l we need to do is extract it in some form to use with the construction prothis is the purpose of the pseudo-traces. 
　　　this implies that we have made an error in replacing a constant by a variable  which  of course  we d i d   . we know that x is a parameter in our constructed procedure  so t h i s analysis is reasonable. we note that b is also a parameter  and so '   ' must be a constant. as a r e s u l t   node 1 becomes l='   '. 
　　　we r e f i n e t h i s set into two others   1 p  and  1 q}  replace it by these two and add t h i s new class to our set of i d e n t i f i a b l e sets  d e l e t ing the old set  this is an example of   f i n d i n g the s u b s t i t u t i o n s   in step 1 of the construction algorithm as w e l l   . of course  this new set of sets w i l l eventually be chosen  since a l l other sets must also r e f i n e {1 1 p q} in a l i k e 
manner . 
1 
1. using the c r i t i c a l nodes and c r i t i c a l p r e decessors  back up the matched tree u n t i l we are sure our match is successful. record the set of language for proving theorems and manipulating models in a robot   ai-tr-1  a r t i f i c i a l i n t e l l i g e n c e laboratory  mit  a p r i l   1. nodes we are sure match and the s u b s t i t u t i o n s they imply. 
1. form the pseudo-traces of our procedure. 
1. carry out steps 1 through 1 of the construction procedure  	taking care to correct any para-
meters 	if 	necessary. 
conclusion 
　　　the protocol abstraction and correction process described are domain independent. the form of the protocols has been rather r i g i d . these c h a r a c t e r i s t i c s of the protocols are the r e s u l t s of the transformations we considered the f i r s t being a r e s u l t of considering only syntactic or s t r u c t u r a l transformations and the second r e s u l t i n g from the s i m p l i c i t y of the t r a n s formations. 
　　　the transformations may not seem a 'part' of the protocol abstraction problem and may seem an additional burden. however  we f e e l that they help to define the problem  that i s   they help specify what we mean by a protocol or trace and t e l l us what we mean by ' a b s t r a c t i o n ' - inversion of the transformations. 
　　　this approach can be extended to other synt a c t i c transformations  see   and we f e e l that it can be used to include semantic transformations as well - f o r example  omitting  obvious  steps in a c e r t a i n domain. these permit more v a r i e t y among protocols and allow a larger class of p r o t ocols. of course  the construction and c o r r e c t ion processes must become more complex and use 
more information about the domain - f o r example  use hypotheses about ' l i k e l y ' steps in the part i c u l a r domain. protocols in program synthesis  aay from a dialogue with a person  may be d i f f e r ent from those using traces formed from solutions by a problem solver. these differences may suggest d i f f e r e n t transformations and therefore d i f ferent abstraction processes. some of these problems  as well as work on seeking additional transformations y i e l d i n g broader classes of p r o t ocols and finding more general construction and correction algorithms  are c u r r e n t l y under invest-
i g a t i o n . 
