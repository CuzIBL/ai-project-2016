  
　　based on a set of design principles  automated visual presentation systems promise to simplify an application programmer's design tasks by automatically constructing appropriate visual explanations for different information. however  these automated presentation systems must be equipped with a powerful inference approach to suit practical applications. here  we present a planning-based  practical inference approach that can design a series of connected visual presentations in interactive environments. our emphasis here is on a set of important visual planning features and how they facilitate visual design. this set of features includes a knowledge-rich representation of visual planning variables and constraints  a novel object-decomposition model that can be used with action decomposition to simplify the visual synthesis process  and practical temporal and spatial reasoning capabilities to facilitate coherent visual design and presentation. in addition  we have implemented our visual planning approach in a visual planner called previse  as part of our automated presentation testbed system. a set of examples is also given to illustrate the necessity and utility of our visual planning approach. 
1 introduction 
　　automated visual presentation systems rely on a powerful inference engine to generate desired presentations efficiently. in this paper  we present a practical inference method that uses a planning approach to infer visual designs in interactive environments. 
　　a visual design ultimately appears in the form of a visual discourse that consists of sequences of temporally ordered visual actions  zhou  1 . visual actions are encoded visual techniques  which may render a collection of graphics objects on the screen  e.g.  action display   or animate a graphical transformation  e.g.  enlarge . since such a pattern is reminiscent of the result produced by ai planning  we model visual design as a planning problem. in particular  
t this work was conducted at columbia university  as part of the 
author's ph.d. thesis in the dept. of computer science. 
1 	knowledge-based applications 
the communicative goals are accomplished as planning goals  visual design guidelines are maintained as planning constraints  and visual actions are employed as planning operators to construct a visual plan  a visual discourse . 
　　the core of our visual planning is a least-commitment  top-down hierarchical decomposition partial-order planning approach  young et al.  1 . combined with a set of visual design heuristics  zhou and feiner  1   this approach helps minimize costly redesign  eases knowledge encoding by reusing visual actions  and ensures global and local design coherency. furthermore  we have equipped the core approach with an additional set of features. specifically  we provide a versatile visual planning representation formalism to express and manage progressively refined visual plans. to simplify visual object synthesis and knowledge management  we explicitly address object decomposition. we also augment visual planning with temporal and spatial reasoning capabilities to maintain temporal and spatial constraints  allen  1; freeman-benson  1 . in addition  we have implemented our approach in a visual planner called previse  planning in reactive visual environments   which is part of an automated presentation testbed system. 
　　in the rest of the paper  we focus on illustrating these important features of our visual planning approach. but first we briefly describe several related works  followed by an example that is planned by previse to illustrate the visual planning problem. we then describe four important visual planning features and explain how they facilitate automated visual design. finally  we present our conclusions and indicate some future research directions in visual planning. 
1 related work 
　　while most automated presentation systems employ simple search-based approaches  e.g.   seligmann and feiner  1    a few have used planning approaches  e.g.  
 andre and rist  1; karp and feiner  1; bares and lester  1  . however  systems using planning approaches either deal with static presentations i andre and rist  1  or focus on planning camera movements  karp and feiner  1; bares and lester  1 . furthermore  these systems usually handle premade graphics objects at a high level without worrying about low-level visual object composition  e.g.  composing a visual object using basic visual ele-

figure 1. present patient overview to nurse  annotated  
ments such as color and shape . 
　　aiming to create a coherent visual discourse from scratch  our work involves both visual composition and transformation. thus  we have designed a more sophisticated visual planning approach. this approach  implemented in previse  is based in part on two planning systems: dpocl 
 young etal.  1  and sipe iwilkins  1; wilkins et al.  1 . dpocl is the first system to explicitly address top-down action decomposition with partial-order planning  while sipe can plan in a reactive environment. from dpocl  previse inherits the top-down action-decomposition strategy and amplifies it to accommodate object-decomposition; and from sipe  previse partly adopts its plan and action representation formalisms  but further expands them to allow more knowledge rich representations. 
1 example 
　　we use one complex example  shown in figure 1 and figure 1  to illustrate the characteristics of visual planning. 
in this example  our task is to present a patient's information to a nurse after the patient's coronary artery bypass graft  cabg  operation. as the final presentation contains coordinated text  speech  and graphics  here we only concentrate on how the graphics presentations are planned. 
figure 1. present patient overview to nurse  annotated  
　　in this task  previse must accomplish two goals. the first goal is to create an overview of patient information  and the second is to elaborate the patient information details based on the created overview. to achieve the first goal  previse plans to construct a structure diagram  figure 1  that organizes various information  e.g.  iv lines  around a core component  e.g.  represented by the patient's body . this decision is made based on the fact that nurses prefer to see all information arranged relative to the patient's body. in a top-down design manner  previse first creates an  empty  structure diagram. this empty diagram is then defined through its individual components by recursively partitioning and encoding the patient information into different groups. as shown in figure 1  the patient's demographics information  including name  age  and gender as a group  is encoded as the heading of the diagram; the patient's physical body serves as the core  and the rest of the information is arranged around the core as diagram elements. to express the partial designs and their refinement  previse uses variables and constraints to represent the progressively refined diagram at different levels of detail. in addition  previse must formulate and satisfy a set of spatial constraints to determine the sizes and locations of various diagram components  figure 1 . 
	zhou 	1 

　　to accomplish the second goal  previse plans a series of visual actions to allow certain information to be reinforced or revealed based on the overview. figure 1 a-b  are created to reinforce the patient's demographics information and ivs using the visual action highlight  while figure 1 c-d  are planned to reveal the drip  intravenously administered drug  and lab report details. to introduce new information  e.g.  drip details  into an existing display  previse reasons about the spatial arrangement of existing objects and the placement of new objects. finally  previse ensures that all visual actions are temporally coordinated to produce a coherent presentation; for example  the highlighting on the demographics in figure 1 a  should be turned off before the ivs are highlighted in figure 1 b . 
1 visual planning 
　　in this section  we concentrate on illustrating four distinct visual planning features and explain how they aid visual design. 1b facilitate a flexible and efficient planning environment  we first present a knowledge-rich and object-oriented representation formalism for visual planning. using this representation  we describe how to explicitly employ object decomposition with action decomposition to simplify visual synthesis. to create both temporally and spatially coherent presentations  we address temporal and spatial reasoning issues in visual planning. 
1 visual planning representation formalism 
　　using a top-down design strategy  a visual planning process must deal with partially specified visual plans at multiple levels of abstraction. to capture and manage these complex partial plans  we have developed a knowledge-rich object-oriented representation formalism based on previous work  e.g.   krsl  1; wilkins and myers  1; tate  1j . specifically  our representation formalism permits the efficient usage of complex planning variables and constraints  and allows a rich expression of planning operators  visual actions . for illustration purpose  all examples given below are presented in a simplified frame-like representation formalism  where brackets     are added around symbols to indicate object instances. 
planning variables and constraints 
　　unlike any of other planning variables used in complex planning systems  e.g.   curric and tate  1; wilkins and myers  1    visual planning variables are first declared in s-expressions  and are then created and managed as object 

figure 1. variable declaraction and creation 
1 	knowledge-based applications 
instances. figure 1 shows how a previse variable may be declared with a symbolic id  a specific binding type  and a set of constraints. the symbolic id can either be in a form of  x or $ y to distinguish a single valued variable  x  from a multivalued one  y . when created  a variable instance is assigned a binding property to indicate how it should be managed  krsl  1 . for example  a required variable must be bound during planning  while an optional variable may not be bound at all through the entire planning process. a variable may be created with or without a binding  a set of bindingcandidates  or even a defaultbinding. moreover  this variable instance may refer to another variable instance or be referred by others during planning. 
　　having a separate variable declaration and creation eases both knowledge encoding and planning. in particular  variables are declared in s-expressions during knowledge encoding without dealing with the details of object creation and management. on the other hand  variables are easily handled as objects in planning without repeatedly processing complex symbolic representations. in addition  our visual planner can rely on various variable attributes described above  including variable property and references  to efficiently decide when and how to update variables. for example  using the variable reference information  if a variable binding is updated  so are all the variables that refer to this one. 
　　it is worth noting that we also allow a special type of dynamic variables in visual planning. during planning  these variables may be continuously updated by a numerical constraint solver called stm  gleicher  1 . hence we refer to them as to stm-var. unlike dynamic variables in other systems  e.g.   wilkins and myers  1    a stm-var is more flexible in use  e.g.  we do not need to explicitly specify its rebinding   and more efficient in representation. for example  a stm-var  used to represent a 1d bounding box  can be used to capture the changing geometry of a 1d object through five other variables  center  objcenter  width  height  and depth . 
　　in visual planning  a previse variable is usually accompanied by a set of constraints  which are also handled in the similar fashion as variables. in other words  visual planning constraints are specified initially in s-expressions  and are instantiated and managed as object instances during planning. to facilitate constraint management  we classify constraints based on their origination  e.g.  meta or sufficiency constraints in  tate  1   and duration  e.g.  one-time or always constraints in  krsl  1  . moreover  we assign constraints with strength  e.g.  required or preferred  and type  atomic or abstract  to organize them into a hierarchy  borning etal.  1 . this constraint hierarchy not only allows object relationships to be expressed at multiple levels of abstraction  but also allows for a more efficient constraint management  see sections 1 and 1 . 
visual action 
　　in visual planning  a visual action captures both the properties of a planning operator and a visual technique. as a visual technique  a visual action can be a formational action that creates a visual object from scratch  figure 1a   

designtablechart  is-a formation-action  	 a  
 operands   x  type domain-object    t  type table-chart    
 localparameters   heading  type visual-unity  
 property optional   ...  
 purposes encode i tabulate  
 effects  effectl  encode  x  t    effect1  table  t   ... 
move  is-a transformation-action  	 b  
 operands   v  type visual-object    
 localparameters   src  type vector     dest  type vector    
 purposes transform i reposition  
 preconditions  condl  existing  v    cond1  at  v  src  ...   effects  effectl  at  v  destination   ... 
figure 1. a visual action definition 
or a transformational action that modifies an existing visual object  figure 1b . since formational actions do not actually perform graphics rendering  they are not included in the final plan but their results might be. for example  the formational action  designtablechart  itself does not appear in the final plan  but its result-the created table chart may appear in the final plan with a display action. 
　　we also assign purposes to each visual action to summarize its functions at different levels of abstraction. for example  the purposes specified in the action move indicate that it can be used to transform a visual object in general  specifically to reposition a visual object  figure 1b . in addition  we use the purposes to index visual actions and create partitioned search space to reduce search time. this helps us cope with a large number of visual actions efficiently during planning. for example  when searching for a proper visual action to accomplish a transformation task  previse only searches among the visual actions that have transform as one of their purposes. otherwise  previse must examine the postconditions of all visual actions to find a match. 
　　much like a sipe operator  wilkins and myers  1   visual action arguments are represented as variables with constraints on their binding types or properties. for example  the variable  heading is optionally bound to a particular visual object  figure 1a . but unlike sipe  visual action arguments are separated into two groups: operands and local parameters. whereas operands provide the uniform interface to access an action  local parameters describe a set of attributes specific to that action. in particular  formational actions use operands to specify their input and output  e.g.   x is the input and  t is the output of designtablechart in figure 1a   and transformational actions use operands to indicate their recipients  e.g.   v of move in figure 1b . on the other hand  both formational and transformational actions use localparameters to record all needed parameters to complete the action  e.g.   heading of designtablechart  or  dest of move . separating the operands from local parameters simplifies the action instantiation process since previse needs to consider only the operands during this stage. this allows the instantiations of local parameters to be delayed; for example  previse is not concerned with local parameters  such as  dest  the destination of the movement  in move  at a high level of the design. 
　　to simplify the planning process  plan goals in previse are also specified similar to actions. for example  the communicative goal to create a summary of patient information  achieved in figure 1  is notated as a rhetorical act  summarize  patient-info . based on the domain-specific nurse preference rule  this general act is then refined to a visual goal structure  patient-info  that requires all information to be structured in a specific way. this visual goal is in fact an abstract visual act  which can be accomplished by other visual actions  e.g.  action designstructurediagram   zhou and feiner  1 . 
1 object decomposition 
　　as a planning operator  a visual action may be a primitive action that can be directly executed by a plan agent  or a composite action that contains a set of partially specified subplans and must be replaced by the subplans during planning  previse usually uses composite actions to sketch a design at a high level  and refines the vague parts of the design into more detailed ones using primitive visual actions. during such a design refinement  action and object decomposition may both be required. for example  a designtablechart action may be decomposed into a set of subactions that define individual table components. in the meantime  the input  the data  x  used to produce the table chart must also be decomposed into smaller units that can be used by the subactions. although in certain cases object decomposition could be implicitly handled by action decomposition  entangled action and object decomposition makes visual planning extremely difficult  e.g.  a data object may be decomposed into different subparts under different situations . thus  we explicitly introduce object decomposition in visual planning 
designtablechart  is-a formation-action  
 actiondecomschemata  actd1 ...  
 objdecomschemata  objd1   objd1   objd1 ...  
 objdecomppreferences 
 preference!  :condition  is-itemize  x    :prefer  objd1    
 preference1  :conditlon  is-overview  x    :prefer  ob|d1    
 always  objd1    
 actd1  of act-decomposition-schema 
 subactions  :loop  i  :range 1  n  :update  bind  i  + 1  i    
 subaction  i   :expr  designvisrep  x  i   t  i       
 objdl  of object-decomposition-schema 
 objld  x   numparts  n = : get-numoflndividual   
 subparts  :loop  i  :range 1  n   x  i  = : get-individual  i    
 objd1  of object-decomposition-schema 
 objld  x   numparts  n = : get-numofgroup   
 subparts  :loop  i  :range 1  n   x  i  = : get-group  i    
 ob|d1  of object-decomposition-schema 
 ob|ld  t  
 subparts  :loop  i  :range 1  n  
if  is-identifier  x  i    then  put-heading  t  t  i   else  put-cells  t  t  i     
figure 1. a visual action and its decomposition schemata 
	zhou 	1 

using a set of object decomposition schemata. 
　　an object decomposition schema uses objectld to identify the object to be decomposed  subparts to specify a set of components that the object is decomposed to  and numparts to indicate the total number of subparts  figure 1 . unlike action decomposition where only one decomposition schema can be used at one time  more than one object decomposition schemata may be applied simultaneously. for example  previse may use  objdl  in figure 1 to decompose the data  x  but always uses  objd1  to determine the structural relationships between the table chart itself   t  and its components   t  i  . to determine which and when an object decomposition schema should be used  previse uses preference constraints stored in objdecomppreferences. moreover  variables are used extensively in decomposition schemata to express partial plans and objects  or to represent unknown situations  e.g.   n . 
　　in general  two types of object decomposition occur in visual planning. in the first case  a completely specified object  e.g.  a piece of data to be conveyed  needs to be decomposed into smaller units to be manipulated  e.g.  decomposition schemata  objdl  and  objd1  in figure 1 . in the second case  a partially specified object  e.g.  a visual object to be defined  must be decomposed into subparts so it can be refined through the subparts  e.g.   objd1  . both types of object decomposition promote a simpler and more general knowledge encoding and management. 
　　using the first type of object decomposition  we can easily handle the uncertainty involved in action decomposition. for example  during knowledge encoding  the number of subactions in  actd1  may be unknown  depending on how the data   x  will be processed in the actual planning process. in this case  before instantiating subactions in  actd1   previse can establish the needed variables  e.g.   n  by selecting an object decomposition schema  e.g.   objdl   based on objdecomppreferences  e.g.  preference-! . this approach allows a simple and general representation of action decomposition  which only needs to specify the unknowns using variables 
 e.g.   n in  actdi  . 
　　the second type of object decomposition also helps generalize and simplify action decomposition. without the object decomposition schema  objd1   for example  we must replace the general action designvisrep with more specific subactions  such as designtableheading and designtablecell  to define various table constituents. in addition  we must consider all the possible combinations of these specific subactions to construct different subplans  e.g.  a subplan may require a subaction designtableheading  but another may not . this not only requires a number of different actions to be defined  but also increases the complexity of knowledge management. considering the case of defining a new action designbarchart  we need to introduce a set of new actions  e.g.  designaxes and designbar  for various bar chart constituents. we must also ensure that each subaction is supplied with the proper data components to guarantee the design correctness. for example  only quantitative data components may be involved in the subaction designbar. 
　　therefore  separating the object decomposition from the action decomposition allows simpler and more general rep-
1 	knowledge-based applications 
resentations for action decomposition. more importantly  these simpler and more general representations improve previse's applicability by easing its tasks of knowledge encoding and management. 
1 temporal reasoning 
　　during a visual presentation  visual actions can occur concurrently or over extended time intervals. to create a temporally coherent visual presentation  we have integrated temporal reasoning into previse to ensure that visual actions are temporally coordinated. compared to other systems  e.g.  
 tate etal.  1; wilkins and myers  1; andre and rist  1    previse uses multilevel topological and metric time constraints to describe actions at a finer granularity during planning generation. it also employs a novel scheduler to ensure that all temporal constraints are met during planning execution. 
temporal constraint specification 
previse deals with two types of temporal constraints: 
inter-action constraints specify temporal relations between two visual actions  and intra-action constraints describe temporal relations within a visual action. 
　　inter-action temporal constraints. previse uses topological constraints to represent temporal relationships between two visual actions qualitatively. these constraints can be represented as either time-point or time-interval constraints. in general  previse allows three types of time-point constraints: beforeat  afterat  and equatat; and permits time interval constraints  containing any subset of the thirteen basic temporal relations defined in  allen  1. when described in time-point constraints  visual actions may be considered instantaneous. in contrast  visual actions have distinct starting and finishing times when specified using time-interval constraints. 
　　allowing both time-point and time-interval constraints not only enables previse to represent different temporal relationships accurately  but also helps to handle temporal constraints efficiently by exploiting a multilevel constraint representation. usually  we can use concise time-point constraints to specify incomplete temporal relations at a high level  and employ time-interval constraints to express more refined temporal relationships at a low level. for example  previse can use a simple time-point constraint to assert that action a must start before b at a high level  without knowing their finishing times: 
 beforeat a b  
later  this constraint can be refined using one of the three more specific time-interval constraints based on their finishing times: 
1. a finishes before b:  overlap a b  
1. a finishes after b:  contain a b  
1. a and b finishes at the same time:  finishedby a b  
this multilevel temporal constraint representation helps avoid computationally complex temporal reasoning at a high level  hence improves planning efficiency. 
　　intra'action temporal constraints. in addition to temporal constraints between visual actions  we also describe 

temporal relationships within an action. unlike inter-action temporal relationships  these relations are described quantitatively using metric time constraints  usually in seconds . 
　　in general  a previse action has a starttime and an endtime to regulate when and how long the desired visual effects should appear on the screen. but we add subtime intervals in a transformational action to describe its animation subacts. in particular  animonduration controls the time taken to turn on the desired visual effects  e.g.  gradually changing the color of an object to highlight it   holdingduration specifies how long the current effect should remain on the screen  e.g.  holding the highlighting effect   and animoffduration limits the time taken to reverse the visual transformation  e.g.  turning off the highlighting . using these subintervals  we can describe and control a finer-grained visual action and its execution. moreover  we can specify an animation with its reverse without explicitly introducing a set of undo actions  e.g.  unhighlight . 
　　to facilitate temporal media coordination  e.g.  coordinating a graphics animation with speech  in a multimedia presentation  we also allow more flexible time-window constraints. for example  we may specify that a highlight action needs a minimum of 1s or maximum of 1s to turn on the highlight  and another 1s to 1s to hold the highlighting. to coordinate the highlighting with speech  a media coordinator can use the time window to compute a time interval acceptable for both graphics and speech. 
temporal constraint satisfaction 
　　we deal with temporal constraints in both plan generation and execution. in plan generation  we use a simple constraint solver to process qualitative time constraints based on transitive closures. conversely  we use a constraint solver based on metric/allen time system  mats   kautz  1  to process quantitative temporal constraints. 
　　execution scheduler. in plan execution  we have implemented a time queue to schedule visual actions. all visual actions are first entered in the time queue by their starting times. the scheduler then uses a global alarm clock to invoke actions when their starting times are reached. a local timer is also maintained within each visual action to signal its termination when its finishing time approaches. 
　　this approach works fine until this problem arises: two closely scheduled actions  e.g.  actions a and b in figure 1a  may overlap as the scheduler cannot guarantee a full stop in previous action  e.g.  a  when its local timer expires. this is because the local timer does not account for the time spent for executing various implicit finishing acts. for example  

action a may call an instantaneous undo act  animoffduration is 1s  when its local timer expires. thus  there is no guarantee that a's undo act will be finished before b starts. 
　　to fix this problem  each action is required to signal the scheduler when it is truly finished. in addition  we insert a dummy finishing act for each action in the time queue by its finishing time to ensure that the global clock be stopped if the previous action is not finished. as shown in figure 1 a   when the global clock reaches the dummy act aend  it would not be advanced to action b1tart until it receives a's finishing signal. 
　　the above approach only fixes half of our problem: it works for actions scheduled one after another  e.g.  a and b in figure 1a   but not for actions scheduled right next to each other  e.g.  b and c . in this case  the plan agent is expected to execute two tasks simultaneously: finishing the previous action  b  and starting a new action  c . since it is physically impossible for uniprocessor machines to process two tasks at the same time  the tasks will be executed in a nondeterministic order. this may result in undesirable visual effects. suppose b and c are both highlighting actions  and b must finish by removing its highlight before c starts to put on a new highlight. because of the nondeterministic execution order  c might be started before b finishes to cause an undesired visual effect: two objects highlighted at the same time instead of in sequence. 
　　to ensure desired visual effects  we add sub-order temporal constraints to serialize simultaneous actions using heuristics. for example  one heuristic rule in previse asserts that all dummy finishing acts precede any other action scheduled at the same time. in the above example  the plan agent will process bend before cstart  as if the time point t is expanded into a time interval  t  t+a   figure 1b . this ensures that all objects in action b are unhighlighted before any new object is highlighted in action c. 
1 spatial reasoning 
　　previse performs spatial reasoning in two situations. in spatial composition  previse regulates the size and placement of visual objects to ensure a valid visual composition. in spatial transformation  previse controls the spatial modification of existing visual objects and the integration of new visual objects to maintain a coherent visual transformation. 
spatial composition 
　　a visual composition is considered valid if all syntactic constraints are satisfied during visual object synthesis  zhou  1 . among these syntactic constraints  some regulate spatial relationships between visual objects. figure 1 is annotated to show a set of spatial constraints that must be satisfied in a structure diagram. moreover  these constraints are specified at different levels of abstraction to capture multi-level spatial relationships. for example  constraint 1 is an abstract spatial constraint  defined at a high level to describe vague spatial relationships between complex visual objects. in contrast  constraints 1 and 1 express more concrete visual relationships. to be evaluated  an abstract constraint  e.g.  constraint 1   must be replaced by a set of more concrete constraints  e.g.  constraints 1 and 1 . one 
	zhou 	1 

distinct advantage of using abstract constraints is to achieve planning efficiency by postponing overwhelming details involved in lower level constraints to a later time. 
　　by evaluating a set of constraints  previse can determine the size and placement of visual objects involved. for example  the locations or sizes of various texts in figure 1 can be determined. in previse  we model spatial constraints using mathematical equations and inequalities  which are eventually solved by stm using a numerical optimization method. since the optimization method requires a set of proper initial values  we must supply these values for stm to start with. for example  we need to supply the proper initial values for  line-length and  tab in constraints 1 and 1 
　　 figure 1 . currently  these values are obtained based on empirical analyses of many existing graphical representations  e.g.  hand-made or machine-made structure diagrams . for example  to best illustrate the spatial ratio between the patient body and the lines  we have learned that the length of various lines in the picture is usually at least 1 of the diagonal length of the body's bounding box. 
spatial transformation 
　　in addition to ensuring a valid visual composition  previse also uses spatial constraints to control the integration of new information into an existing presentation. in one approach  previse directly adds the new information to the existing scene as visual extensions of existing objects. for example  to reveal drip details  figure 1c   previse directly adds a pull-down menu as an extension of the drip button in the overview  figure 1 . to determine the size and the placement of new objects  e.g.  the pull-down menu  in relation to the existing objects  e.g.  the button   previse reasons about the spatial geometry of the existing scene  including the objects* size  orientation  and topology  by issuing queries. it then formulates constraints based on design heuristics. in our case  based on the current geometry of the drips button  previse formulates spatial constraints to regulate the size and position of the added pull-down menu. 
　　to avoid unnecessary spatial rearrangement  we also assert a set of spatial constraints in advance to prepare ibr potential visual changes. for example  a button is usually expected to bring up a pull-down menu when pressed. therefore  when a button is created  a spatial constraint is asserted to ensure that there is enough room reserved below the button for placing a pull-down menu  e.g.  the space below the drips button in figure 1 . 

　　in general  directly adding new objects to the existing scene is relatively simple since previse deals with a confined space with rigid spatial constraints  e.g.  placing a pulldown menu near a button . however  in many cases  previse may need to modify the existing scene dramatically for integrating new information. in this case  previse must determine how to make spatial changes for the new objects. for example  to produce figure 1 d   previse decides to keep the table chart at the top  e.g.  name  age  and gender  of figure 1 c  to provide the necessary context information  while replaces the rest of representation with the lab report. 
     previse currently deals with relatively simple spacemanagement cases. our approach assumes that all existing visual objects will be replaced except the objects that must be kept to provide necessary background or context information. once previse determines what to keep or to remove  it will plan the size and the placement of the new objects  e.g.  the table chart for lab report  using an iterative-adjustment algorithm. to utilize space efficiently and produce a balanced layout  the algorithm assumes that the kept objects usually reside in the shaded area to leave the middle area for the new objects  figure 1 . 
　　the shaded areas are initially defined by a set of threshold values to guarantee that at least 1 of the display area in the middle be reserved for the new visual objects. the algorithm then iteratively computes the bounding box for each object kept in the scene and determines the region containing this object. if the object falls in only one of the eight shaded regions  e.g.  objl and obj1 in figure 1   the algorithm adjusts the current boundaries by pushing them toward the center to define unoccupied space. for example  the initial top boundary is pushed down into line 1  and the initial left boundary becomes line 1 in figure 1. if the object does not completely fall in any of the eight regions  e.g.  obj1  and the threshold values arc adjustable  the algorithm recursively increases the current threshold values to recompute new boundaries. if the threshold values are not adjustable  the current existing objects may be modified to create enough room for new objects. eventually  the algorithm returns four boundaries to define the dimension and position of the area for placing the new objects. 
1 implementation 
　　previse is implemented using both clips  jsc1  1  and c++  currently running on sgis and pcs 

1 	knowledge-based applications 

under windows nt. the rendering component is written in c++ and open inventor  an object-oriented 1d interactive graphics toolkit  wernecke  1 . on a sgi indigo 1 with a 1 mhz r1 processor  it takes about 1 seconds to plan the overview of patient record shown in figure 1  and about 1 seconds to plan the entire detail view of patient record  partly shown in figure 1. 
1 conclusions & future work 
　　in this paper  we have presented a practical visual planning approach to automated visual presentation design. in particular  we model visual actions as planning operators  and visual design principles as planning constraints. on top 

of our core top-down hierarchical decomposition partialorder planning approach  we add a set of visual planning features. these features include a powerful visual planning representation  an explicit object decomposition method  and temporal and spatial reasoning capabilities. moreover  this approach is implemented in a planner  previse  as part of our automated visual presentation testbed system. 
　　currently  we are working in two areas to improve the visual planning approach. to allow user interaction during planning generation and execution  we are planning to incorporate reactive planning strategies  wilkins et al.  1 . for example  users may suggest changes to the design decisions made by previse  or interactively alter the course of the execution to selectively view the presentation  e.g.  executing visual actions out of sequence . thus  our current approach must be extended to recognize the inadequacy of a current plan  and correct it to meet the new conditions. 
　　to perform spatial analysis and management for more complicated situations  we would also like to enhance the spatial reasoning capability. for example  developing a general and efficient algorithm to query the spatial density of a scene so we can place new objects on the location where the spatial density is low to avoid possible object occlusions. 
acknowledgments 
　　1 would like to thank my thesis advisor  professor steven feiner  for his constant support on this work. i would also like to thank rahamad dawood for implementing the scheduler  blaine bell for porting the entire system to pcs  and bill yoshimi  keith houck  and po yu for proofreading this paper. this research was supported in part by darpa contract daal1-k-1  the columbia university center for advanced technology in high performance computing and communications in healthcare  funded by the new york state science and technology foundation   the columbia center for telecommunications research under nsf grant ecd-1  and onr contract n1-1. 
