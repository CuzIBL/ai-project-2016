 
 analysis of failed problem solving efforts enables people to guide subsequent problem solving to avoid similar failures. this kind of learning while doing is essential in complex domains. we define explanationbased learning from failure  elf   a technique for achieving such a capability  and describe its prototype implementation in failsafe  a prolog program that learns from failure while solving floor planning problems. 
1 introduction 
 explanation based generalization  ebg   mitchell et al 1  has been proposed as a method whereby problem-solvers can speed up with practice by learning from positive examples of problem-solving behavior  prieditis & mostow 1 . however  complex domains like design may require an unreasonable amount of brute-force search to find positive examples from which to learn.  mostow 1  suggests that in such domains the problem solver must do intelligent adaptive search to converge to a solution quickly. one way to do adaptive search is to find the properties that make a generated solution unacceptable and  in future  avoid proposing solutions with these properties. we call such unacceptable solutions failures. in this paper  we propose that a system can use ebg to explain its failures in order to get sufficient conditions for them. these sufficient conditions  when negated  give necessary conditions for success which  in turn  can be used as negative heuristics to prune the search. 
 as a test bed for exploring the approach  we have chosen a simplified floor planning task developed by prof. chris tong for an intermediate ai course. in this domain  a problem consists of fitting rectangular rooms into a rectangular area called 'house' of given integer length and width  subject to the following constraints: 
this work is supported by nsf under grant number 
dmc-1  by the rutgers center for computer aids to 
industrial productivity  and by darpa under contract number n1-k-1. 
  room length and width must be integers in the ranges given in the problem. 
  rooms must not overlap. 
  rooms must be inside the house. 
  the rooms must cover the entire house area. 
  every room must touch at least one side of the house. 
  in addition  a problem may require that a given room be adjacent to another along a specified direction  or to a specified side of the house. 
 this paper describes failsafe  a prototype floor planner implemented in prolog. failsafe uses explanation-based learning from failures  elf  to learn new operator preconditions. 
ii description of the technique 
　we now use an example to introduce elf. we shall assume that the reader is familiar with the ebg learning paradigm described in  mitchell et al 1 . 
　consider a generate-and-test  g&t  problem solver that generates floor plans using the operator 'locate r x y sx sy ' to place room 'r' with width 'sx'  length 'sy'  and front left corner at  x y   where the front left corner of the house is at  1 . an n room floor plan is generated by n applications of this operator. this plan is then passed to the tester module  which tests if all constraints of the problem are satisfied. initially  operator 'locate' has no knowledge about which placements of rooms would generate 'obviously wrong' floor plans and should be avoided. it has the following strips-style definition: 
operator: locate r x y sx sy  
preconditions: room r  a is  in  house x y  
a valid  width sx  a valid  length sy  
add list: located r x y sx sy  
	mostow and bhatnagar 	1 

suppose the floor planner has the domain knowledge 
here  failure  is a global 
assertion which the learning module tries to prove whenever the tester fails a generated solution. 
1 	knowledge acquisition 

notice that the condition being regressed back may operator 
in 
since 
1
1 
　in our example the problem solver will now try alternate sizes and locations for room 'r1' that do not overlap the room 'rl' 
	mostow and bhatnagar 	1 

i l l description of the architecture 
　in designing failsafe  we chose a very simple generate and test architecture  because it provides failures in abundance and is easy to implement. 
　failsafe's solution generator initially uses exhaustive search to place the rooms  starting from the front left corner of the house space and going left to right and front to back. after every application of the operator 'locate r x y sx sy  ' the generator adds the new fact 'located r x y sx y ' to the problem state. when all rooms are located  the solution is passed to the tester. 
　the tester checks if the generated floor plan meets all the problem constraints. if not  it rejects the solution. 
　the learning module uses elf to learn new preconditions for the operator 'locate'. it has a knowledge base of theorems about floor planning  some of which are shown in figure ii-1. whenever the tester rejects a floor plan  failsafe uses these theorems to try to prove the goal  failure  in the context of the failed plan. failsafe explains and generalizes the failure using a prolog implementation of tv results of the implementation 
　we now present the results of experiments carried out to measure faiisafe's performance  the effect of increasing problem complexity  and transfer of learning from one problem to another. 
a performance on three problems 
　to test the effectiveness of elf  we ran failsafe on three example problems of increasing complexity  shown in figure iv-1. 
we measured failsafe's performance by counting the number of prolog subgoals generated while solving each problem. we ran failsafe on these problems with learning switched off  while learning  and after learning. table iv-1 shows the results. 


ebg  kedar-cabelli & mccarty 1 . 
1 	knowledge acquisition 

　since no boundary-crossing happens to occur during the normal solution of p1  transfer is negative from p1 or p1 to rl: checking for crossed boundaries only slows things down. since accumulating control knowledge indiscriminately can degrade performance  it may be a good idea to store and test only those preconditions that are frequently violated. 
v open issues 
currently failsafe finesses several issues. 
a safety 
　elf is defined as safe whenever it does not prevent the problem-solver from finding a correct solution. elf uses a single failed path to reject an entire subtree without searching it exhaustively. while this strategy is crucial for efficient adaptive search of large spaces  it risks losing the ability to find a solution. elf's safety depends on the problem-solver's operators and the nature of the failed constraint. 
　a constraint is monotonically necessary if  once violated in a partial plan  it will remain violated in all extensions of this plan  mostow 1a . such constraints are safe to learn as preconditions  since no solutions are thereby rendered unreachable; we will call violations of them monotonic failures. for example  room overlap is a monotonic failure in failsafe  since it cannot be repaired by placing additional rooms. 
　if the effects of an operator can be reversed by other operators  there can be no monotonic failures  since every partial plan can be extended into a  possibly non-optimal  plan that leads to the goal state  assuming one exists. failsafe's single operator  'locate ' has no such inverse. 
　even if a condition is not monotonically necessary  it can be treated as such provided there are ways to solve the problem without violating it. such a condition can be called pseudo-monotonically necessary. for example  suppose failsafe had an operator for sliding an already-placed room from one location to another. non-overlap would be pseudo-monotonically necessary if every room could be placed without sliding. 
　some conditions are not even pseudo-monotonically necessary. for instance  the constraint that every point in the house be covered by some room can be made true by placing additional rooms. even such constraints can safely be learned as operator preconditions by restricting the circumstances under which they are tested. for example  if the covering condition is only applied to complete floor plans  we can learn that the last room to be placed must include the remaining uncovered points. 
　b the hopeless state problem 
　at an intermediate state in planning  decisions made during the placement of earlier rooms can make it impossible to satisfy the preconditions of 'locate' for the next room. we call such a state hopeless. an example of a hopeless state is shown in figure v-l. here room 'r1' is required to be adjacent to the left and front walls of the house  but room 'rl' has already been placed there  so 'r1' cannot be placed as required. 

	figure v-l: 	a hopeless state 
　learning to efficiently recognize hopeless states might enable failsafe to handle much larger problems. currently failsafe recognizes hopeless states only after exhaustive search fails to satisfy the preconditions of an operator. we plan to extend failsafe to invoke learning at this point; at present learning occurs only when a complete floor plan is rejected by the tester. 
　c the non-operational precondition problem 
to be operational in the sense defined in  mostow 
1  mostow 1b   an operator precondition must refer only to information available when the operator is selected  such as the operator's parameters and the steps used to get to the current state. the nonoperational precondition problem occurs when the learned precondition refers to parameters bound by operators selected later on. for example  when the non-overlap condition is regressed back through the 
sequence 
locate rl xl yl wl ll ;locate r1 x1 y1 w1 l1   the resulting condition refers not only to xi  yl  wl and li but also to x1  y1  w1 and l1. in fact  the regressed condition is a precondition for the twooperator macro  not for the first operator by itself. 
　one possible approach is to constrain xi  yl  wl  and ll to leave at least one acceptable assignment for x1  y1  w1  and l1. however  evaluating this condition involves searching for such an assignment  and is therefore liable to defeat the purpose of testing preconditions - enhancing efficiency. 
d detecting failures 
　to learn from its failures  a planner must first detect them. in general  detection of failures is difficult. failsafe gets around this difficulty because in its domain the length of the target plan is fixed and known: exactly n applications of the operator 
	mostow and bhatnagar 	1 
'locate' are required to complete an n room floorplan. failure detection requires other methods when the maximum length of the solution path is not known  such as noticing cycles  langley 1  minton & 
carbonell 1 . 
e which necessary conditions to test 
　explanation-based learning becomes counterproductive when so many macro operators are learned that testing their preconditions costs more than rediscovering them by search  minton 1 . elf is potentially subject to the same problem. 
　a system like failsafe could sample how often a given condition fails and  before trying an operator  test only those which fail more frequently than some threshold that reflects the relative costs of precondition testing and search. this threshold could be modified dynamically depending on the performance of the system. 
v i 	related 	w o r k 
　the usefulness of negative heuristics learned by analyzing problem-solving failures has been reported previously.  kibler & morris 1  reports four negative heuristics obtained by manually analyzing  stupid  actions taken by a blocks world planner. by guiding the planner to avoid such actions  these four heuristics reduce search to almost zero. 
　chef  hammond 1  uses domain knowledge to anticipate the failures that might occur while trying to satisfy a goal. when such failures occur  this knowledge is used to repair the plan instead of replanning from scratch. 
    siklossy & dowson 1  describes preprocessing of strips operators to discover conditions that cannot simultaneously hold in any legal state. such conditions become indicators of failures. for example  inspection of the operator definitions reveals that no state can satisfy holding x  and clear x  for the same block x  since operators that assert one delete the other. knowledge gained by preprocessing the operators is used to prune planning states that satisfy two or more  mutually inconsistent conditions. 
　foo  mostow 1a  refines a g&t search procedure into a heuristic search by using monotonically necessary conditions to prune partial paths  and by using monotonically sufficient conditions to reorder the search. while foo uses static analysis to refine the procedure without ever executing it  failsafe relies on executing the search to identify the conditions that actually lead to failure in practice. foo uses domain knowledge to split tests into monotonic components so it can move them  while failsafe lacks the ability to reformulate its tests  foo mechanically applies the 
1 	knowledge acquisition 
sequence of program transformations that modifies the search procedure  but relies on a user to select the sequence. unlike foo  failsafe is completely automatic. 
　prodigy learns search control knowledge from the failure of an entire subtree to produce a solution  minton & carbonell 1 . in contrast  elf learns from a single failed path  though the resulting 
control knowledge is over-general for non-monotonic 
failures  
　elf's technique for backtracking to the closest node where the failure might be repaired resembles the dependency directed backtracking method used in the el system  stallman 1 . however  unlike failsafe  el does not generalize. 
v i i 	conclusion 
　we have presented an implemented technique for learning useful search control knowledge from failures that occur during search. failsafe's performance improvement more than compensates for its learning overhead  even for small problems  and even when learning while doing. 
　we have shown how ebg can be used to learn from negative examples  not just positive ones. learning from failure while problem-solving makes it possible to solve problems too complex to solve otherwise. however  learning from success seems to create more powerful control knowledge  such as soar's chunks for achieving goals in one step. future research should compare and integrate methods for learning from success and failure. 
acknowledgments 
　we thank chris tong and prasad tadepalli for their excellent ideas during various stages of this work  smadar kedar-cabelli for her prolog implementation of ebg  lou steinberg for his continuing encouragement  and steve minton and an anonymous referee for their helpful comments. 

