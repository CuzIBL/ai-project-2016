
we propose a simple declarative language for specifying a wide range of counting and occurrence constraints. this specification language is executable since it immediately provides a polynomial propagation algorithm. to illustrate the capabilities of this language  we specify a dozen global constraints taken from the literature. we observe one of three outcomes: we achieve generalized arc-consistency; we do not achieve generalized arc-consistency but achieving generalized arcconsistency is np-hard; we do not achieve generalized arc-consistency  but specialized propagation algorithms can do so in polynomial time. experiments demonstrate that this specification language is both efficient and effective in practice.
1 introduction
global constraints are central to the success of constraint programming. global constraints allow users to specify patterns that occur in many problems  and to exploit efficient and effective propagation algorithms for pruning the search space. two common types of global constraints are counting and occurrence constraints. occurrence constraints place restrictions on the occurrences of particular values. for instance  we may wish to ensure that no value used by one set of variables occurs in a second set. counting constraints  on the other hand  restrict the number of values or variables meeting some condition. for example  we may want to limit the number of distinct values assigned to a set of variables. many different counting and occurrences constraints have been proposed to help model a wide range of problems  especially those involving resources  see  for example   re뫣gin  1; beldiceanu and contejean  1; re뫣gin  1; beldiceanu  1; beldiceanu et al.  1b  .
모we will show that many such constraints can be specified using a simple declarative language. this specification language is executable. it decomposes these constraints into some simple primitives for which there are polynomialpropagationalgorithms. in some cases  we show that this decomposition does not hinder propagation. in other cases  achieving generalized arc-consistency is np-hard and decomposition is one method to obtain a polynomial propagation algorithm. in the remaining cases  we show that the decomposition hinders propagation  and there exists some specialized and polynomial propagation algorithm. as not all global constraints are implemented and integrated into every solver  our language may still be attractive in this case. we provide a generic means for propagating counting and occurrence constraints in the absence of a specialized algorithm. our experiments demonstrate that this is an efficient and effective way to reason about counting and occurrence constraints in practice.
1 formal background
a constraint satisfaction problem consists of a set of variables  each with a finite domain of values  and a set of constraints specifying allowed combinationsof values for subsets of variables. we use capital letters for variables  e.g. x  y and s   and lower case for values  e.g. d and di . we write d x  for the domain of a variable x. a solution is an assignment of values to the variables satisfying the constraints. a variable is ground when it is assigned a value. we consider both integer and set variables. a constraint can be defined on only integer  or only set variables  or on both. a set variable s can be represented by its lower bound lb s  which contains the definite elements and an upper bound ub s  which contains the definite and potential elements. each set variable is equivalent to a sequence of 1 variables representing the characteristic function. a variable in such a sequence is 1 iff the corresponding element is in the set.
모given a constraint c  a bound support on c is a tuple that assigns to each integer variable a value between its minimum and maximum  and to each set variable a set between its lower and upper bounds which satisfies c. an hybrid support on c is a tuple that assigns to each integer variable a value in its domain  and to each set variable a set between its lower and upper bounds which satisfies c. if c involves only integer variables  a hybrid support is a support. a constraint c is bound consistent  bc  iff for each integer variable xi  its minimum and maximum values belong to a bound support  and for each set variable sj  the values in ub sj  belong to sj in at least one bound support and the values in lb sj  belong to sj in all bound supports. a constraint c is hybrid
consistent  hc  iff for each integer variable xi  every value in d xi  belongs to an hybrid support  and for each set variable sj  the values in ub sj  belong to sj in at least one hybrid support  and the values in lb sj  belong to sj in all hybrid supports. a constraint c involving only integer variables is generalized arc consistent  gac  iff for each variable xi  every value in d xi  belongs to a support.
모enforcing hybrid consistency on a constraint c is equivalent to enforcing gac if the set variables are represented by their characteristic function. if all variables in c are integer variables  hybrid consistency reduces to generalized arcconsistency  and if all variables in c are set variables  hybrid consistency reduces to bound consistency.
모we will compare local consistency properties applied to  sets of  logically equivalent constraints  c1 and c1. as in
 debruyne and bessie`re  1   a local consistency property 붯 on c1 is as strong as 붱 on c1 iff  given any domains  if 붯 holds on c1 then 붱 holds on c1; 붯 on c1 is stronger than 붱 on c1 iff 붯 on c1 is as strong as 붱 on c1 but not vice versa; 붯 on c1 is equivalent to 붱 on c1 iff 붯 on c1 is as strong as 붱 on c1 and vice versa; 붯 on c1 is incomparable to 붱 on c1 iff 붯 on c1 is not as strong as 붱 on c1 and vice versa.
모a total function f from a set s into a set t is denoted by f : s  뫸 t where s is the domain of f and t is the range of f. the set of all elements in the domain of f that have the same image j 뫍 t is f 1 j  = {i : f i  = j}. the image of a set s   s under f is f s  = si뫍s f i   whilst the domain of a set t   t under f is f 1 t  = sj뫍t f 1 j . throughout  we will view a set of variables  x1 to xn as a function i . that is  x i  is the value of xi.
1 specification language
we propose a simple declarative language in which we can specify many different counting and occurrence constraints. this specification language is executable. it permits us to decompose each global constraint into more primitive constraints  each of which has an associated polynomial propagation algorithm. in some cases  this decomposition does not hinder propagation. in other cases  enforcing local consistency on the global constraint is intractable  and decomposition is one method to obtain a polynomial propagation algorithm. the specification language consists of simple nonglobal constraints over integer variables  like x 뫞 m   simple non-global constraints over set variables  like s1   s1 or |s| = k  and two special global constraints acting on sequences of variables: roots and range.
모given a function x representing a set of variables  x1 to xn  the range constraint holds iff a set variable  t is the range of this function restricted to the indices belonging to a second set variable  s.
range  x1 .. xn  s t  iff x s  = t
모the roots constraint holdsiff s is the set of indices which map to an element in t.
roots  x1 .. xn  s t  iff s = x 1 t 
모roots and range are not exact inverses. a range constraint can hold  but the corresponding roots constraint may not  and vice versa. for instance  range  1  {1} {1}  holds but not roots  1  {1} {1}  since x  1  = {1}  and roots  1 1  {1 1} {1}  holds but not range  1 1  {1 1} {1}  as no xi is assigned to 1.
모in an associated report  we discuss how to propagate these two global constraints. enforcing hc on the range constraint is polynomial and give an o nd + n 몫 |lb t |1  algorithm where d is the maximum domain size of the xi. enforcingbc on the roots constraint is o nd . unfortunately  enforcing hc on the roots constraint is np-hard. nevertheless  all the cases needed here are polynomial. for example  if all xi are ground  or t is ground then enforcing hc on roots  x1 .. xn  s t  is o nd .
1 range constraints
in an associated report  we present a catalog containing over 1 global constraints from  beldiceanu  1  specified with this simple language. we have room here to present just a few of the more important constraints. in this and the subsequent three sections  we list some global constraints which can be specified using range constraints  using roots constraints  and using both range and roots constraints.
1 all different
the alldifferent constraint forces a sequence of variables to take different values from each other. such a constraint is useful in a wide range of problems  e.g. allocation of activities to different slots in a timetabling problem . it can be propagated efficiently  re뫣gin  1 . it can also be decomposed with a single range constraint:
alldifferent  x1 .. xn   iff
range  x1 .. xn  {1 .. n} t  뫇 |t| = n
모a special but nevertheless important case of this constraint is the permutation constraint. this is an alldifferent constraint where we additionally know r  the set of values to be taken. that is  the sequenceof variables is a permutationof the values in r where |r| = n. this also can be decomposed using a single range constraint:
permutation  x1 .. xn  r  iff range  x1 .. xn  {1 .. n} r 
모such a decompositionof the permutation constraint obviously does not hinder propagation. however  decomposition of alldifferent into a range constraint does. in addition  hc on the range decomposition is incomparable to ac on the decomposition of alldifferent which uses a clique of binary inequality constraints. thus  we may be able to obtain more pruning by using both decompositions.
theorem 1 gac on permutation is equivalent to hc on the decomposition with range. gac on alldifferent is stronger than hc on the decomposition with range. ac on the decomposition of alldifferent into binary inequalities is incomparable to hc on the decomposition with range.
proof: consider x1  x1 뫍 {1}  x1 뫍 {1 1}  and {1}   t   {1 1}. then range  x1 x1 x1  {1 1} t  and |t| = 1 are both hc  but alldifferent  x1 x1 x1   is not gac. consider x1  x1 뫍 {1}  x1 뫍 {1 1}  and t = {1 1}.
then x1 =1	x1  x1 =1	x1 and x1 =1 x1 are ac but
range  x1 x1 x1  {1 1} t  is not hc. consider x1 
x1 뫍 {1 1}  x1 뫍 {1}  and {1}   t   {1 1}.
thenandare
hc. but x1= x1 and x1= x1 are not ac. the other result holds immediately.	1
1 number of values
the nvalue constraint is useful in a wide range of problems involving resources since it counts the number of distinct values used by a sequence of variables  pachet and roy  1 . nvalue  x1 .. xn  n  holds iff n = |{xi | 1 뫞 i 뫞 n}|. the alldifferent constraint is a special case of the nvalue constraint in which n = n. unfortunately  it is np-hard in general to enforce gac on a nvalue constraint  bessiere et al.  1 . however  there is an o nlog n   algorithm to enforce a level of consistency similar to bc  beldiceanu  1 . an alternative and even simpler way to implement this constraint is with a range constraint:
nvalue  x1 .. xn  n  iff range  x1 .. xn  {1 .. n} t  뫇 |t| = n
모hc on this decomposition is incomparable to bc on the nvalue constraint.
theorem 1 bc on nvalue is incomparable to hc on the decomposition.
proof: consider x1 x1 뫍 {1}  x1 뫍 {1 1} 
n	뫍	{1} and {}	 	t	 	{1 1}.	then
range  x1 x1 x1  {1 1} t  and |t| = n are both hc. however  enforcing bc on nvalue  x1 x1 x1  n  prunes 1 and 1 from x1.
모consider x1 x1 x1 뫍 {1} and n 뫍 {1}. then nvalue  x1 x1 x1  n  is bc. however  enforcing hc on range  x1 x1 x1  {1 1} t  makes {} {1} which will cause |t| = 1 to fail.
1 uses
in  beldiceanu et al.  1b   propagation algorithms achieving gac and bc are proposed for the usedby constraint. usedby  x1 .. xn   y1 .. ym   holds iff the multiset of values assigned to y1 .. ym is a subset of the multiset of values assigned to x1 .. xn. we now introduce a variant of the usedby constraint called the uses constraint. uses  x1 .. xn   y1 .. ym   holds iff the set of values assigned to y1 .. ym is a subset of the set of values assigned to x1 .. xn. that is  usedby takes into account the number of times a value is used while uses does not. unlike the usedby constraint  enforcing gac on uses is np-hard.
theorem 1 enforcing gac on uses is np-hard.
proof: we reduce 1-sat to the problem of deciding if a
uses constraint has a solution. finding support is therefore np-hard. consider a formula   with n boolean variables and m clauses. for each boolean variable i  we introduce a variable xi 뫍 {i  i}. for each clause cj = x 뫈  y 뫈 z  we introduce yj 뫍 {x  y z}. then   has a model iff the uses constraint has a satisfying assignment  and i is true iff xi = i.
1
모one way to propagate a uses constraint is to decompose it using range constraints:
uses  x1 .. xn   y1 .. ym   iff range  x1 .. xn  {1 .. n} t  뫇 range  y1 .. ym  {1 .. m} t1  뫇 t1   t
모enforcing hc on this decomposition is polynomial. not surprisingly  this hinders propagation  otherwise we would have a polynomial algorithm for a np-hard problem .
theorem 1 gac on uses is stronger than hc on the decomposition.
proof: consider x1 뫍 {1 1}  x1 뫍 {1 1} 
x1 x1 뫍 {1 1}  y1 뫍 {1}  y1 뫍 {1}  and y1 뫍 {1}. the decompositionis hc while gac on uses prunes 1 from the domain of x1 and 1 from the domain of x1. 1
모thus  decomposition is a simple method to obtain a polynomial propagation algorithm.
1 roots constraints
range constraints are often useful to specify constraints on the values used by a sequence of variables. roots constraint  on the other hand  are useful to specify constraints on the variables taking particular values.
1 global cardinality
the global cardinality constraint introduced in  re뫣gin  1  constrains the number of times values are used. we consider a generalization in which the number of occurrences of a value may itself be an integer variable. that is  gcc  x1 .. xn   d1 .. dm   o1 .. om   holds iff |{i | xi = dj}| = oj for all j. such a gcc constraint can be decomposed into a set of roots constraints:
gcc  x1 .. xn   d1 .. dm   o1 .. om   iff  i . roots  x1 .. xn  si {di}  뫇 |si| = oi
모enforcing hc on these roots constraints is polynomial since the sets {di} are ground. enforcing gac on a generalized gcc constraint is np-hard  but we can enforce gac on the xi and bc on the oj in polynomial time using a specialized algorithm  quimper et al.  1 . this is more than is achieved by the decomposition.
theorem 1 gac on the xi and bc on the oj of a gcc constraint is stronger than hc on the decomposition using roots constraints.
proof: sets being represented by their bounds  hc on the decomposition cannot prune more on the oj than bc does on the gcc. to show strictness  consider x1 x1 뫍 {1}  x1 뫍 {1 1}  di = i and o1 o1 o1 뫍 {1}. the decomposition is hc  with {}   s1 s1   {1 1} and {}   s1   {1} . however  enforcing gac on the xi and bc on the oj of the gcc constraint will prune 1 and 1 from
x1 and 1 from o1  o1 and o1.	1 this example illustrates that  whilst many global constraints can be expressed in terms of roots and range  there are some global constraints like gcc for which it is worth developing specialized propagation algorithms. nevertheless  roots and range provide a means of propagation for such constraints in the absence of specialised algorithms.
1 among
the among constraint was introduced in chip to help model resource allocation problems like car sequencing  beldiceanu and contejean  1 . it counts the number of variables using values froma givenset. among  x1 .. xn    d1 .. dm  n  holds iff n = |{i | xi 뫍 {d1 .. dm}}|. one decomposition using the global cardinality constraint gcc introduced in  re뫣gin  1  is as follows:
among  x1 .. xn   d1 .. dm  n  iff
gcc  x1 .. xn   d1 .. dm   o1 .. om   뫇 xoi = n
unfortunately  this decomposition hinders propagation.
theorem 1 gac on among is stronger than gac on the decomposition using gcc.
proof: consider x1 x1 뫍 {1}  x1 뫍 {1 1}  d1 = 1  d1 = 1  and n 뫍 {1}. the decomposition is gac  but enforcing gac on among  x1 x1 x1   d1 d1  n  prunes 1 and 1 from x1 as well as 1 from n. 1
모an alternative way to propagate the among constraint is to decompose it using a roots constraint:
among  x1 .. xn   d1 .. dm  n  iff roots  x1 .. xn  s {d1 .. dm}  뫇 |s| = n
모it is polynomial to enforce hc on this case of the roots constraint since the target set is ground. this decomposition also does not hinder propagation. it is therefore a potentially attractive method to implement the among constraint.
theorem 1 gac on among is equivalent to hc on the decomposition using roots.
proof:  sketch  suppose the decomposition into roots  x1 .. xn  s {d1 .. dm}  and |s| = n is hc. the variables xi divide into three categories: those whose domain only contains elements from {d1 .. dm}  at most min n  such vars ; those whose domain do not contain any such elements  at most n   max n  such vars ; those whose domain contains both elements from this set and from outside. consider any value for a variable xi in the first such category. to construct support for this value  we assign the remaining variables in the first category with values from {d1 .. dm}. if the total number of assigned values is less than min n   we assign a sufficient number of variables from the second category with values from {d1 .. dm} to bring up the count to min n . we then assign all the remaining unassigned xj with values outside {d1 .. dm}. finally  we assign min n  to n. support can be constructed for variables in the other two categories in a similar way  as well as for any value of n between min n  and max n . 1
모the atmost and atleast constraints are closely related. the atmost constraint puts an upper bound on the number of variables using a particular value  whilst the atleast puts a lower bound. both can be decomposed using a roots constraint without hindering propagation.
1 range and roots constraints
some global constraints need both roots and range constraints in their specifications.
1 assign and nvalues
in bin packing and knapsack problems  we may wish to assign both a value and a bin to each item  and place constraints on the values appearing in each bin. for instance  in the steel mill slab design problem  prob1 in csplib   we assign colors and slabs to orders so that there are a limited number of colors on each slab.
assign&nvalues  x1 .. xn   y1 .. yn  n  holds iff |{yi | xi = j}| 뫞 n for each j  beldiceanu  1 . it can be decomposed into a set of roots and range constraints:
assign&nvalues  x1 .. xn   y1 .. yn  n  iff  j . roots  x1 .. xn  sj {j}  뫇 range  y1 .. yn  sj tj  뫇 |tj| 뫞 n
모decomposition hinders propagation as it considers the values separately. however  since this constraint generalizes nvalue  enforcing gac is np-hard. decomposition is thus one method to obtain a polynomial propagation algorithm.
1 common
a generalization of the among and alldifferent constraints introduced in  beldiceanu  1  is the common constraint. common n m  x1 .. xn   y1 .. ym   ensures n = |{i |  j xi = yj}| and m = |{j |  i xi = yj}|. that is  n variables in xi take values in common with yj and m variables in yj takes values in commonwith xi. we prove that we cannot expect to enforce gac on such a constraint as it is np-hard to do so in general.
theorem 1 enforcing gac on common is np-hard.
proof: we again use a transformation from 1-sat. consider a formula   with n boolean variables and m clauses. for each boolean variable i  we introduce a variable xi 뫍 {i  i}. for each clause cj = x 뫈  y 뫈 z  we introduce yj 뫍 {x  y z}. we let n 뫍 {1 .. n} and m = m.   has a model iff the common constraint has a solution in which the xi take the literals true in this model. 1 one way to propagate a common constraint is to decompose it into range and roots constraints:
common n m  x1 .. xn   y1 .. ym   iff range  y1 .. ym  {1 .. m} t  뫇 roots  x1 .. xn  s t  뫇 |s| = n 뫇 range  x1 .. xn  {1 .. n} v   뫇 roots  y1 .. ym  u v   뫇 |u| = m
모enforcing hc on this decomposition is polynomial. decomposition thus offers a simple and promising method to propagate a common constraint. not surprisingly  the decomposition hinders propagation.
theorem 1 gac on common is stronger than hc on the decomposition.
proof: consider n = m = 1  x1 y1 뫍 {1}  x1 y1 뫍 {1}  y1 뫍 {1}. hybrid consistency on the decomposition enforces {}   t v   {1 1}  and s = u = {} but no pruning on the xi and yj. however  enforcing gac on
common n m  x1 x1   y1 y1 y1   prunes 1 from x1 
1 from x1 and 1 from both y1 and y1.	1
1 symmetric all different
in certain domains  we may need to find symmetric solutions. for example  in sports scheduling problems  if one team is assigned to play another then the second team should also be assigned to play the first. symalldiff  x1 .. xn   ensures xi = j iff xj = i  re뫣gin  1 . it can be decomposed into a set of roots and range constraints:
symalldiff  x1 .. xn   iff
range  x1 .. xn  {1 .. n} {1 .. n}  뫇
 i. roots  x1 .. xn  si {i}  뫇 xi 뫍 si 뫇 |si| = 1
모it is polynomialto enforcehc on these cases of the roots constraint. however  as with the alldifferent constraint  it is more effective to use a specialized propagation algorithm like that in  re뫣gin  1 .
theorem 1 gac on symalldiff is stronger than hc on the decomposition.
proof: consider x1 뫍 {1}  x1 뫍 {1}  x1 뫍 {1}  {}   s1   {1}  {}   s1   {1}  and {}   s1   {1}. then the decomposition is hc. however  enforcing gac on
symalldiff  x1 x1 x1   will detect unsatisfiability. 1
모to our knowledge  this constraint has not been integrated into any constraint solver. thus  this decomposition provides a means of propagation for the symalldiff constraint.
1 beyond counting and occurrence
the range and roots constraints are useful for specifying a wide range of counting and occurence constraints. nevertheless  their expressive power permits their use to specify many other constraints.
모the element constraint introduced in  van hentenryck and carillon  1  indexes into an array with a variable.
more precisely  element i  x1 .. xn  j  holds iff xi = j. we can use such a constraint to look up the price of a component included in a configuration problem. the element constraint can be decomposed into a range constraint without hindering propagation:
element i  x1 .. xn  j  iff |s| = |t| = 1 뫇
i 뫍 s 뫇 j 뫍 t 뫇 range  x1 .. xn  s t 
모we may wish to channel between a variable and the sequence of 1 variables representing the possible values taken by the variable. the domain x  x1 .. xm   constraint introduced in  refalo  1  ensures x = i iff xi = 1. this can be decomposed into a roots constraint:
domain x  x1 .. xm   iff roots  x1 .. xm  s {1}  뫇 |s| = 1 뫇 x 뫍 s
enforcing hc on this decomposition is polynomial  {1} is ground  and it is equivalent to enforcing gac on the
domain constraint.
모the contiguity constraint ensures that  in a sequence of 1 variables  those taking the value 1 appear contiguously. this is a discrete form of convexity. the constraint was introduced in  maher  1  to model a hardware configuration problem. it can be decomposed into a roots constraint:
contiguity  x1 .. xn   iff
roots  x1 .. xn  s {1}  뫇 x = max s  뫇 y = min s  뫇 |s| = x   y + 1
again it is polynomial to enforce hc on this case of the
roots constraint. unfortunately  decomposition hinders propagation. consider x1 x1 뫍 {1}  x1 x1 뫍 {1}. hc on the decomposition will enforce {1}   s   {1 1}  x 뫍 {1}  y 뫍 {1} and |s| to be in {1} but no pruning will happen on the xi. however  enforcing gac on
contiguity  x1 .. xn   will prune 1 from x1.
모whilst roots and range can specify concepts quite distant from counting and occurrences like convexity and discrete derivatives  it seems that we may need other algorithmic ideas to propagate them effectively.
1 experiments
the last three sections demonstrate that many global constraints can be specified in terms of roots and range constraints. we also argued that these specifications are executable and in certain cases provide efficient and effective propagation algorithms. in this section  we support this argument by means of some experiments.
	1gcc+sum	gcc+roots	rootssizeft#sft#sft#s1111.1/1111111.1/1111111.1/1111111.1/1111111.1/1111111.1/111table 1: mystery shopper. instance are run with a 1 minutes time limit. #fails  f  and cpu time  t  are averaged on the #instances solved  #s  by each method.
모we used a model for the mystery shopper problem  cheng et al.  1  due to helmut simonis that appears in csplib. this model contains a gcc constraint and a number of
among constraints. ilog's solver contains the gcc but not the among constraint. we implement among either with a gcc and a sum constraint or directly with roots. this gives us two models  1gcc+sum and gcc+roots  resp. . we also consider the model  roots  which is a variation of gcc+roots where we decompose the gcc constraint using
roots. in order to generate a range of instances  we used the followingprotocol. the durationin weeks as well as the number of varieties of shoppers  visits per salelady and number of areas are all set to 1  as in the original problem . the number of saleladies takes its value in {1 1 1} and the number of shoppers is the next multiple of 1 that is not consecutive. all the possible ways of partitioning the saleladies into 1 areas  that do not trivially violate the constraints  are solved. as expected  the decomposition of the among constraint using roots is more efficient than the decomposition with a gcc and a sum constraint  see table 1 . surprisingly  however  the roots model is the most efficient strategy  see the '#s' column . this is because we were able to branch on the 'extra' set variables  which provedto be the most effective method. finally  the inference using gcc  1gcc+sum  is faster  better ratio t/f  than using its decomposition  roots . this suggests that it will be worth investing time and effort into optimizing this new roots constraint.
1 related work
beldiceanu has specified a wide range of global constraints using simple propertiesof suitably constructed graphs  beldiceanu  1 . there are several important differences between this approach and the frameworkpresented here. for instance  our specification language is executable. given a specification  we immediately have a polynomial propagation algorithm. this is not the case with beldiceanu's framework. on the other hand  beldiceanu's framework is more general since the roots and range constraints can easily be specified in terms of some simple graph properties.
모a number of researchers have specified global constraints over sequences of variables using automaton. beldiceanu et al. use an extended polynomial sized automaton  and show how to extract automatically a gac propagation algorithm  beldiceanu et al.  1a . pesant uses a deterministic finite automaton  and develops a gac propagation algorithm for membership of the corresponding regular language  pesant  1 . these approaches are complementary to the framework presented here. for example  automaton can easily specify constraints like the contiguity constraint and thus provide us with a gac propagation algorithm. this does not seem possible with just roots and range constraints. on the other hand  deterministic or extended automaton cannot specify a simple permutation constraint.
1 conclusions
we have proposed a simple declarative language for specifying a wide range of counting and occurrence constraints. the language uses just two global primitives: the range constraint which computes the range of values used by a set of variables  and the roots constraint which computes the variables in a set mapping onto particular values. this specification language is executable. it immediately provides a polynomial propagation algorithm for any constraint that can be specified. in some cases  this propagation algorithm achieves gac  e.g. the permutation and among constraints . in other cases  this propagation algorithm may not make the constraint gac  but achievinggac is np-hard e.g. the nvalue and common constraints . decomposition is then one method to obtain a polynomial algorithm. in the remaining cases  the propagation algorithm may not make the constraint gac  and specialized propagation algorithms can do so in polynomial time  e.g. the symalldiff constraint .
our method can still be attractive in this last case as it provides a generic means of propagation for counting and occurrence constraints in the absence of a specialized algorithm. experiments demonstrate that such propagation algorithms can be both efficient and effective in practice.
