 
the generic frame protocol  gfp  is an application program interface for accessing knowledge bases stored in frame knowledge representation systems  frss . gfp provides a uniform model of frss based on a common conceptualization of frames  slots  facets  and inheritance. gfp consists of a set of common lisp functions that provide a generic interface to underlying frss. this interface isolates an application from many of the idiosyncrasies of specific frs software and enables the development of generic tools  e.g.  graphical browsers  frame editors  that operate on many frss. to date  gfp has been used as an interface to loom  ontolingua  theo  and sipe-1. 
1 	introduction 
frame knowledge representation systems  frss  have a long history within the knowledge representation  kr  community. frss have been used as informationmanagement components for planners  expert systems  and natural-language understanding systems. a recent review identified more than 1 frss  including the klone family  with members such as loom and back   and the units family  with members such as cycl and theo  . 
　frss are in danger of extinction  however  because of several serious limitations. they do not scale to large knowledge bases  kb . they do not support multiuser access. most cannot provide networked  client-server operation. it is difficult to reuse the knowledge in a given frs across applications  and it is difficult to reuse highlevel knowledge base management utilities  such as kb browsers and editors  across a range of frss. in contrast  object-oriented databases do not suffer many of these limitations  and they duplicate many capabilities of frss. their growing popularity may end all hope that frss can have significant impact in the general computing community. 
　our groups at sri and stanford  and the ai knowledge-sharing community  are addressing these limitations. at sri  karp and paley are integrating database storage technology and multiuser access ca-
1 	knowledge base technology 
tom gruber 
knowledge systems laboratory 
stanford university 
　stanford  ca 1 gruber ksl.stanford.edu 
pabilities into frss . the knowledge-sharing community has undertaken a number of efforts aimed at supporting knowledge reuse  including development of shared portable ontologies in ontolingua   and development of well-defined languages for knowledge interchange such as kif . efforts such as ontolingua and kif provide knowledge reuse through a paradigm of specification-time translation. for example  given an ontology of bibliographic data encoded in ontolingua  translators convert the ontolingua encoding into the language of a specific frs. 
　just as knowledge reuse is extremely important  so is the ability to reuse  and to mix and match  the software components of a large ai system. for example  consider the knowledge-management utilities  kmus  that are often developed in conjunction with frss  such as graphical kb browsers and editors. typically  kmus are built from scratch for each frs  despite great overlap in the capabilities of kmus for different frss  the literature shows a pattern of many kb editors with similar capabilities . the result is a tremendous duplication of effort. when an frs falls into disuse  its kmus become worthless. the substantial investment involved in building a sophisticated kmu would generate a larger payoff if that kmu could operate with several frss. 
　the generic frame protocol  gfp  is a set of common lisp functions that constitute a generic applicationprogram interface to frss. a kmu  or other application program  can employ gfp operations to retrieve  update  and create information in an frs. gfp supports 
  access to knowledge from multiple frss using a single  uniform interface 
  portability with respect to frss  thus enabling switches from one frs to another with minimal effort 
  reuse of kmu software  such as editors and browsers 
  reuse of knowledge through a paradigm of runtime translation 
　by runtime translation  we mean that gfp translates knowledge from a given frs representation to a gfpcompatible form during the execution of an application. this approach contrasts with the specification-time approach to translation adopted by other knowledgesharing efforts. in effect  gfp treats a kb and its associated frs as a complete module that can be spliced into many applications  with translation occurring at runtime as required. 
　gfp has been designed as a procedural rather than a declarative interface to frss because procedural interfaces are more convenient in many cases  and can yield better performance  see section 1 . 
1 design goals 
several design objectives were defined for gfp: simplicity: the protocol should be simple and reasonably quick to implement for a particular frs  even if this means sacrificing theoretical considerations or support for idiosyncrasies of that frs. generality: the protocol should apply to many frss  and support the most common frs features. no legislation: the protocol should not require substantial changes to an frs for which the protocol is implemented. that is  the protocol should not legislate the operation of an underlying frs. performance: inserting the protocol between an application and an frs should not introduce a significant performance cost. consistency: the protocol should exhibit consistent behavior across implementations for different frss  that is  a given sequence of operations within the protocol should yield the same result over a range of frss. precision: the specification of the protocol should be as precise and unambiguous as possible. language independence: ideally  gfp should be programming-language-independent  but currently it has many common lisp dependencies. connecting gfp to an frs implemented in some other language should be straightforward using lisp foreign-function calls  but implementing a user-callable gfp implementation in a different language would require significant effort. 
　satisfying these objectives simultaneously is impossible because many of them conflict. put another way  the very essence of gfp involves compromise. different frss behave differently  and unless we legislate a minutely detailed behavioral model for kr systems  which no developers will subscribe to anyway   we cannot force these systems to behave the same. gfp is a study in the art of compromise because it requires a reference model that encompasses many frss and is detailed enough to be useful in practice  but is not so detailed as to exclude every frs from its model. an example of conflicts among our objectives is that to precisely specify the semantics of the gfp function that retrieves the values of a slot  we must specify the inheritance semantics to be used. however  different frss use different inheritance mechanisms . conformance with a specific semantics for inheritance would require either altering the inheritance mechanism of a given frs  violating the no-legislation goal   or emulating the desired inheritance mechanism within the implementation of the protocol  violating performance and generality  since the inheritance method used by that frs is inaccessible through the protocol . 
to address variations among key frs operations  gfp identifies a set of dimensions - called behaviors - along which frss differ. the gfp implementation for a given frs declares which behaviors it supports; an application program declares what behaviors are required for its correct execution. when the application attempts to access a given kb  gfp verifies that the behaviors required by the application are in fact supported by the gfp implementation for the desired frs. in addition  an application or a kmu can be conditionalized on the behaviors of different frss. for example  the display of a frame created by a kb editor can conditionally retrieve and display facets or not  depending on whether the frs in use supports facets or not. 
1 reference model 
a comprehensive survey of frss reveals a large variety of system designs . some of the differences among these systems are significant  while others are superficial. in defining the generic frame model that underlies gfp  we have attempted to identify those commonalities that are useful for a broad range of applications. because of the large number of frss in existence  researchers often use different terminology to mean the same thing. our reference model for gfp employs the terms knowledge base  frame  class  instance  slot  and facet  each of 
which is described below.1 the reference model is based on an axiomatic formalization of classes  relations  and functions for the frame ontology in ontolingua  but extends the ontology to include aspects relevant to operational applications  e.g.  kinds of inheritance  facets . 
1 	representational primitives 
frames 
a frame is an object with which facts are associated. each frame has a unique name. frames are of two kinds: classes and instances. a class frame represents a semantically related collection of entities in the world. each individual entity is represented by an instance frame. a frame can be an instance of many classes  which are called its types  and a class can be a type of many instances. a class can also be an instance  that is  an instance of a class of classes  a metaclass . the relation that holds between an instance and a class is primitive  akin to set membership.1 with this primitive we can define the sub relation that holds between classes: a class csub is a sub of class c1uper iff whenever i is an instance of csub then i is also an instance of c1uper. 
knowledge bases 
a knowledge base  or kb  is a collection of frames and their associated slots and values. multiple kbs may be in use simultaneously within an application  possibly serviced by different frss. frames in a given kb can reference frames in another kb  provided that both kbs are serviced by the same frs. 
　1  we use the following pairs of terms synonymously: class and concept  instance and individual  and slot and role. 
　1  but not as powerful  since not all sets can be described as classes in frss. 
karp  myers  and gruber 
slots 
information is associated with a frame via slots. a slot is a mapping from a frame and a slot name to a set of values. a slot value can be any lisp object  e.g.  symbol  list  number  string . slots can be viewed as binary relations; gfp does not support the explicit representation of relations of higher arity. 
　in some frss  slots are modeled as relations that cover all frames  and it is possible to define slot units  which are frames that specify kb-wide properties of slots  such as constraints . gfp supports slot units; alternatively  slot properties may be declared locally in gfp for each frame  see section 1 . 
facets 
facets provide information about slots. in gfp  facets are identified by a facet name  a slot name  and a frame. a facet has as its values a set of data objects. some facets pertain to the values of a slot; for example  a facet can be used to specify a constraint on slot values  see section 1  or a method for computing the value of a slot. other facets may describe properties of the slot itself  such as documentation. gfp supports only a single level of facets. 
1 	inference 
the gfp reference model includes three forms of inference  namely  subsumption reasoning  constraint checking  and inheritance. 
　the reference model assumes domain closure on instances; that is  an instance is defined for every object of interest in a given application domain. the model also assumes predicate closure on class and slot relations  that is  that the extensions of all such relations are fully specified in a given kb. 
subsumption 
subsumption reasoning is a key inferential capability in virtually all frss. for reasoning about subsumption relationships  gfp distinguishes direct from all relationships. we say that i is a direct-instance-of a class c if i is an instance of c and there is no other class c  present in the kb  that is a subclass of c such that i is an instance of c. all-instance-of is the transitive closure of direct-instance-of. similarly  a class a direct subclass of class ctuper if ctub is a subclass of csuper and there is no other class c of which csub is a subclass and which is  in turn  a subclass of csuper. the relations direct-super- of and all-super-of are the inverses of direct-sub-of and all-sub-of all-types-of is the inverse of all-instance-of  and direct-type-of is the inverse of direct-instance-of. 
　some frss require direct relationships to be specified when frames are created. in contrast  frss that perform automatic classification may infer the direct relationships by comparing class definitions. in gfp  direct relationships must be specified at frame creation time. gfp operations allow the user to interrogate any of these specified class-subclass and class-instance relationships  no matter how the relationships were derived. 
1 	knowledge base technology 
constraint checking 
a kb often must contain not only ground facts about instances  but also general rules that constrain the valid relationships among classes and instances. these constraints may be checked to assure that the kb remains logically consistent when changes are made. should a constraint be violated  a representation system may signal an error to the user or take steps to return the kb to a consistent state. most frss support a limited form of constraints  the most common of which are slot constraints. slot constraints constrain the possible values that a slot can be assigned. gfp supports two specific slot constraints: type and number restrictions on slot values. they are specified using common facet names that are included in the protocol  see section 1 for details . 
slot value inheritance 
a slot maps a particular frame to a set of values. for perspicuity  frss generally allow the user to describe a set of such mappings for all instances of a class. the instances are then said to inherit those slot values from the class. many frss further augment inheritance by allowing slots to specify default values; such values are to be inherited only when they do not conflict with local information available for a frame. 
　inheritance in gfp is based on the use of template and own slots. a template slot is associated with a class frame  but applies to all instances of that class. in many frss  template slots are presented as if they were actually slots. however  they are really a way of specifying  in one place  slots for all the instances of that class. for example  if we wanted to say that all instances of the class female-person have a slot called gender with the value female  we could define a template slot called gender for the female-person frame and give it value female. then if we created an instance of female-person called maxy  and we asked for the value of the slot gender on mary  we would be told that her gender is female. what would we get if we asked for the value of the gender slot of female-person  the question is ambiguous  because we could mean the template slot on the frame female-person viewed as a class  or the slot on the frame viewed as an instance  e.g.  of a class of classes . in the latter case  this slot is referred to as an own slot. gfp requires the user to declare a slot as either own or template. 
　inheritance in gfp can be characterized as follows. an own slot may have local values  which are asserted directly for that slot. the values for slot 1 of a frame / are determined by  combining  the local values and template values of c.s for any class c that is a superclass of /  provided those values do not  conflict . gfp allows the use of different semantics for  combining  and  conflict    to support a range of inheritance methods. selection of a specific inheritance mechanism is controlled through declarations for the behavior inheritance  as described in section 1. 
　currently  the protocol makes no commitment  either directly or through behaviors  regarding the inheritance of values for frames that have multiple direct super-

classes. thus  applications should not depend on a specific semantics for inheritance in such cases. 
1 	common names 
to insulate applications from meaningless variability among the names of frequently used objects in different frss  gfp specifies common names for certain frames  slots  and facets. implementations of the protocol must translate these names into the appropriate frs-specific objects. the common names for gfp are taken from the frame ontology  in which they are defined by a formal axiomatization   and the basic data types in kif . 
　for example  the common frame names include number  which has the frame integer as a subclass  and sequence  which has the frames list  string  and array as subclasses . the frame class is defined as the all-super-of all frames that denote a class. 
1 	behaviors 
although gfp necessarily imposes some common requirements on the organization of knowledge  kbs  frames  slots  facets  and semantics of some assertions  instance and subclass relationships  inherited slot values  slot constraints   it allows for some variety in the operation of underlying frss. this diversity is supported through behaviors  which provide explicit models of the frs properties that may vary. at the time of declaration  the protocol determines whether the behaviors required by the application can be supplied. those behaviors might already be present in the underlying frs  or the protocol itself might emulate them on behalf of the frs. in cases where one or more of the required behaviors cannot be supplied  the protocol issues warnings to this effect. the gfp behaviors have a second role  namely to configure the operation of an frs at runtime. for an frs that can provide more than one of several alternative functionalities  the behaviors allow the user to specify how the frs should operate at a given time. 
　here we describe the behaviors defined currently in gfp. we expect that additional behaviors will be supported in future versions of the protocol. it is important to note that an implementation of the protocol for a given frs might not provide every possible behavior because of both the variability among frss and the complexity of gfp. 
　the behavior : facets determines whether the frs supports facets  see section 1 . the behavior : class-slot-types is used to indicate the slot types for classes supported by a given frs  either template only or both template and own  see section 1 . testing the equality of slot and facet values is a common operation within frss  although the nature of the test used varies. for this reason  gfp supports a behavior idefault-test-fnfor specifying an frs-dependent function to be used for these value comparisons. 
　the behavior : inheritance can be used to specify the model of inheritance used by the frs. two possibilities are currently supported: 
override the presence of any local value in a given slot of a frame blocks inheritance of any values for that 
slot from superclasses of the frame.1 
incoherence a slot inherits from its superclasses all values that do not violate any constraint associated with the slot. 
imagine that slot color records all colors visible on the surface of an animal  and that the default at class elephant for color is gray. suppose that the elephant 
clyde has blue as a local value if color  to reflect the color of clyde's eyes. for the override inheritance semantics  the user-visible value of clyde. color would be blue  whereas for incoherence  clyde.color would be {blue gray}. in the first case  the local value blocks inheritance of the default value  whereas in the second case  inheritance is not blocked because no constraint specifies that gray and blue are inconsistent values. if we further specified that color is a single-valued slot using a cardinality slot constraint  then the user-visible value of the slot under incoherence would be blue. 
　we note that incoherence semantics makes no commitment in cases where inheritance from all superclasses of a given frame leads to inconsistency  but not from some subsets of those supers. this vagueness is intentional to enable more inheritance mechanisms to satisfy the incoherence semantics  with the caveat that the frss should not depend on inherited values for such cases. 
1 the generic frame protocol 
this section summarizes the operations that comprise the generic frame protocol  and describes the process of implementing the protocol for a new frs. 
1 	programmatic interface 
the generic frame protocol defines a programmatic interface of common operations that span the different object types in the reference model  namely  knowledge bases  frames  classes  instances  slots  and facets. there 
are three main categories of operations supported for each object type: retrieval operations  manipulator operations  and iterators. retrieval operations extract in-
formation about objects and object values. retrieval operations generally come in two forms: functional operations  which retrieve a value  and relational operations  which test whether a relation holds between an object and some value s . manipulator operations create  destroy  and modify objects. 
	gfp 	supports 	three 	kinds 	of 	it-
erators: do- object - reln   map- object - reln   and mapc- object - reln   where  object  ranges over the object types of the reference model  and  reln  specifies a class of objects related to  object  in some manner  e.g.  do-class-direct-subs iterates over the direct subs of a class  and mapcar-kb-classes maps over all classes in a kb . the iterators are included in gfp to support access to efficient iteration mechanisms that underlying frss may provide  rather than using the straightforward approach of first consing up a list of the objects to be iterated over  then iterating through the list. 
   1 this form of inheritance is sometimes referred to as specificity inheritance. 
karp  myers  and gruber 

operations on kbs 
new kbs are created in gfp through the create-kb operation. a parameter of this operation is a clos class corresponding to the underlying frs to be used for the new kb  such as the class loom-kb or theo-kb. create-kb returns a clos instance of that class - the kb descriptor. this descriptor is the handle for all subsequent access to the kb. 
　in gfp  there is a notion of a current kb. all gfp operations apply to the current kb by default  unless a different kb description is specified for an operation. additional kbs can be accessed; the notion of the current kb is one of convenience  as it defines a default context for gfp operations. 
　gfp provides functions for storing and retrieving kbs to and from secondary storage. its model of access allows kbs to reside on a variety of storage types  including traditional flat files and database systems on remote servers. 
operations on frames  classes  and instances 
gfp includes manipulator operations to create  copy  delete  rename  and print frames. retrieval operations retrieve the name and slots of a given frame and test the type of a frame  whether it is a class or an instance   the containment of a frame within a designated kb  and the coercion of a frame name to a frame object  possibly relative to a kb . 
　manipulators create classes and instances  and retrieval operations test all possible subsumption relationships between classes and instances  for both the direct and all relationships described in section 1. iterators are defined for all subsumption relationships  i.e.  direct-subs  all-subs  direct-supers  all-supers  direct-types  all-types  direct-instances  all-instances . additional operations test the equivalence  consistency  and disjointedness of classes  determine whether a given class is primitive  in the sense of classification   and determine the most specific/general classes from a list of classes. 
operations on slots and facets 
manipulation operations for slots add  remove  or replace a value  or replace the entire set of slot values. a complete slot value can be retrieved  or checks can be made to see whether the slot contains one particular value. iterators are provided for both the facets and values of a slot. another operation determines whether a frame has a slot with a given name. 
　for facets  the manipulation operations add  remove  or replace values. retrieval operations can obtain all values for a facet  or test for membership of a particular value for a facet. iteration over facet values is supported. gfp can also determine whether a frame has a facet with a given name. 
operations on behaviors 
retrieval operations obtain information about the behaviors supported by gfp in general  the behaviors that a given frs supports  and the behaviors that are enabled for a particular kb. 
1 	knowledge base technology 
1 	programmatic vs. declarative 
a variant of the procedural/declarative controversy  a long-standing issue in ai  arises in relation to interfaces for frss. many authors argue that declarative tell/ask style interfaces are preferable because of their simplicity and well-defined logical semantics; others believe that procedural interfaces provide more natural and efficient interactions and can be ascribed comparable semantics. 
　we believe that both kinds of interface are of value  depending on the situation at hand. declarative interfaces are useful in interactive settings and for formulating complex queries  whereas procedural interfaces are preferable when embedded within other software. our group employs both the procedural interface embodied by gfp  and a declarative  first-order query facility that is implemented on top of gfp  see section 1 . we have not built a declarative assertional facility  i.e.  no tell interface . 
　we view a programmatic interface as essential to an operational kr system for the following reasons:1  1  although the procedural and declarative approaches provide equivalent expressive power in principle  it is more convenient to represent certain constructs procedurally. for example  combining quoted and evaluated terms is trivial in a procedural system but awkward in a declarative system.1  1  kmu tools often need access to meta-information about knowledge; for instance  a kb browser may need to determine whether a slot on a frame has a value in order to determine how to display the frame. the gfp programmatic interface provides an explicit function slot-has-value-p for accessing this information. other useful metalevel relationships that are testable directly in the gfp programmatic interface include whether a given facet has a value; whether a name denotes a frame  class  instance  or facet; what slots exist for a given frame; and which values of a slot were inherited rather than asserted locally.  1  metalevel queries must execute fast for interactive applications  but are likely to be answered extremely slowly when proof techniques are used. furthermore  a query to distinguish inherited from local slot values would not be expressible in most tell/ask interfaces  but can be useful in understanding how various kb inferences were derived. 
1 	gfp implementation 
users access all gfp operations as either functions or macros. at the implementation level  most of the functions and macros call a generic function to do their work - an frs-specific method implements the operation. the extra level is introduced to allow default values for arguments to be supplied  and to allow keyword arguments  neither of which is provided by clos generic functions . every generic function dispatches on an argument called kb  which is a kb descriptor  a clos instance  that defaults to the current kb but can be over-
　1  it is interesting to note that loom users clamored for a programmatic interface to be added to the original declarative interface provided for that system. 
　1 indeed  tell/ask interfaces rarely provide the same range of capabilities as their procedural counterparts because of this awkwardness. 
ridden  as a keyword argument to the function wrapper around the generic function . 
　a set of frs-specific methods implement the gfp operations for each frs. therefore  to provide a gfp implementation for a new frs  we provide a new module of methods for that frs. this module need not provide a method for every gfp operation  only for operations in a small kernel of gfp. gfp provides default methods for all operations outside the kernel  which are defined in terms of operations inside the kernel. for example  the default method for slot-has-value-p calls the kernel operation get-slot-values. the kernel consists of roughly 1 operations. the default methods can of course be overridden to improve efficiency or for better integration with development environments. their purpose is to simplify the gfp implementation for new frss. two other connections must be made between 
gfp and a given frs  namely  the linking of common gfp object names with the appropriate frs objects  and the specification of the appropriate behaviors for the frs. 
1 	frss supported by gfp 
to date  there exist four frs-specific implementations of gfp for loom   theo   sipe-1   and ontolingua . table 1 summarizes the behaviors supported for each of these implementations. these frss cover a broad range of capabilities  from classification-based to nonclassificatory. 
loom fits the gfp model fairly closely  but we note two exceptions. first  loom instances do not differentiate local from inherited values. second  attributes of loom classes are specified through complex definition expressions. loom has no notion of incremental redefinition for a facet of a template slot in a class  instead requiring the user to issue an entire new definition when only a small change occurs  such as changing a default value . the gfp methods for loom translate between facets and definitions  submitting an entire new definition to loom when any facet changes. 
ontolingua is primarily a translation and analysis tool for ontologies  but its most recent version  1  includes a limited frame system. by using this embedded frs  it is possible to write portable kif ontologies and store or access them as knowledge bases using gfp. the ontolingua implementation supports the full range of gfp functionality. 
theo is a conceptual descendant of rll that fits the gfp model fairly closely; exceptions are a simplified multiple-kb system and the use of facets within facets to an arbitrary depth  not supported by gfp . 
sipe-1 the sipe-1 planner includes a simple framestyle knowledge representation system that corresponds to a restricted subset of the gfp model. for instance  it has no kb operations. 
　we expect that gfp interfaces to other frss  such as classic or back  would be no more difficult to implement than those we have described. 
1 	knowledge management utilities 
our group is building a collection of generic knowledge management utilities  kmus . because these tools are implemented on top of gfp  they can be used in con-
junction with any gfp-compatible frs. 
graphical kb browsers and editors we are developing a suite of graphical tools for interactive kb browsing and editing. the various tools provide different visualizations of the information within a kb and different editing operations. one tool presents the class/subclass/instance hierarchy as a graph  with incremental expansion of nodes to support exploration of large kbs. another tool graphs arbitrary relationships among frames as a semantic network. the third tool displays the slots and facets of an individual frame. a fourth tool shows selected slot values for a set of frames in tabular form. prototype implementations of the first three tools exist; their development is ongoing. see url http://www.ai.sri.com/ gkb/overview.html for more information. 
query processor gfp provides application programmers with an efficient procedural interface for accessing frame-based knowledge bases. as a complementary method  we have implemented a gfp-based query processor that provides a declarative interface for extracting information from a knowledge base. the query processor supports an extended first-order query language that constitutes a restricted version of kif. 
1 discussion 
1 	adequacy of the model 
the gfp reference model encompasses many but not all of the capabilities of current-generation frss. it does not provide rules or methods or contexts. it does not provide all operations required by classificatory frss; in particular  there is no explicit concept-definition language  although facets provide a means of building concept definitions in a structural way . the krss specification  is a good candidate upon which to base such a concept-definition language. the gfp model of kbs is simplistic because it has no notion of dependencies or imports between kbs. we welcome input from the kr community in addressing these issues  and we hope to see other groups adopt gfp for use in conjunction with other frss. 
karp  myers  and 1ruber 
1 	the price of generality 
our experimental evaluations indicate that the performance penalty for using gfp is reasonable. using a loom implementation of gfp  we compared the running times of key gfp kernel operations with their corresponding loom operations. the results showed the gfp operations to be 1% - 1% slower  depending on the operation . the high overhead costs resulted for operations without direct counterparts in loom. for example  gfp provides an operation for retrieving a frame when given an identifier; loom has no such operation  instead providing separate operations for instances and classes. the gfp operation must consider whether the name corresponds to a class or an instance in order to invoke the appropriate underlying loom operation. we note that on an absolute scale  the overhead is very small in this case  approximately .1 milliseconds . 
　for directly comparable operations  the upper-bound on overhead was 1%. much of the increased execution time results from activities common to all gfp operations. thus  the overhead is high on a percentage basis for fast operations such as slot value retrievals  1% for a .1 millisecond operation   but low for more expensive operations such as retrieving all instances of a class  1% for a 1 millisecond operation . 
1 	relation to knowledge-sharing efforts 
both gfp and kif  seek to provide a domainindependent medium that supports the portability of knowledge across applications. gfp is narrower in representative scope than kif; whereas kif is intended to be a comprehensive first-order representation formalism  gfp is focused on the representation of class hierarchies. ontolingua  is a set of tools for writing and analyzing kif knowledge bases along with translators for mapping kif kbs to specific frss. kif and ontolingua are declarative representation languages; gfp is a procedural interface for accessing representation structures. kif and ontolingua are designed for use in sharing a large corpus of knowledge at specification time  through the use of translators. gfp is designed for runtime access to and modification of existing kbs. gfp is similar to kqml  l  in that it provides a set of operations defining a functional interface for use by application programs. however  the gfp operations are grounded in knowledge representation structures  while kqml operations correspond to performatives for agent execution. 
1 	conclusions 
in addition to supporting the development of the kmus described in section 1  gfp is in use in two applications. the sipe-1 planning system can access static information about a planning domain via gfp; it has successfully solved military transportation planning problems for which the planning domain is defined in a loom kb. in addition  the ecocyc project at sri has constructed a large kb and associated graphical user interface of e. coli genes and biochemistry. all code for managing the theo ecocyc kb  and for accessing the kb from the graphical user-interface  employs gfp. 
1 	knowledge base technology 
　future work related to gfp proceeds in several directions. we are extending gfp to provide greater coverage of frs features. a second direction under way at stanford is to allow gfp calls to traverse a network. 
acknowledgements 
　we thank bob macgregor for comments on early versions of gfp  and for help with the loom implementation of gfp. fritz mueller  james rice  and suzanne paley contributed to the design and implementation of 
gfp. this work was supported by rome laboratory 
contract no. f1-c-1  and by grant r1-lm1a1 from the national institutes of health. the contents of this article are solely the responsibility of the authors and do not necessarily represent the official views of arpa nor of the nih. 
