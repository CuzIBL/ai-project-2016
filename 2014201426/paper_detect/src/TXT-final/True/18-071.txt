 
   a program is described which augments plans with synchronizing primitives to ensure appropriate conflict avoidance and co-operation the plans are particularly suitable for describing the activity of multiple agents which may interfere with each other the interpretation of a plan is given as a non deterministic finite automaton which exchanges messages with an environment for the commencement and conclusion of primitive actions which take place over a period of time the synchronized plan allows any and all execution sequences of the original plan which guarantee correct interaction 
1. introduction 
   all planning systems operate by combining actions or sub-plans in some way so that the total plan satisfies some constraint usually to achieve a goal state. knowledge of how actions interact with each other and the world is used to determine the appropriate combinations in noah  for example  consideration of interactions between sub-plans is explicit in the planning process a plan is a partial order of sub-plans the planning technique is to expand sub-plans into partial orderings of lower level sub-plans  and then look for and resolve ensuing conflicts the resolution may impose fixed orderings this can be unnecessarily restrictive  as in the case where two sub-plans may execute in any order but not at the same time. 
   this paper considers the use of synchronizing primitives to resolve conflicts and produce a plan which is as unrestrictive as possible the models of plan and action used are appropriate for simple agents or robots engaged in parallel and or repetitive tasks which may be described at a level not using sensory input to the agents. use could be made of this technique  for example  in automated assembly lines georgeff  has also done related work on planning for multiple agents 
1. underlying theory. 
   here we give an informal summary of a fully formalized theory of action and the world  which is described in . 
1. actions 
   an agent changes the world by executing actions when multiple agents are operating in parallel  it may be possible for two actions to be executing simultaneously  and so actions must have a beginning and an end. we consider an action to be decomposed into discrete transformations of the world  which are called event  . an event also has an associated correctness condition  which must be true at the moment it is executed an action will be a set of possible finite sequences of events. 
1. the environment 
   the state of the environment in which actions are executed consists of a world state  and a set of actions currently being executed. if an agent executes an action  one of the possible sequences of events for that action is selected non-deterministically and added to the environment state the environment may at any time take a currently executing action  pop the next event from the event sequence  check for event failure  and change the world state according to that event. 
   the environment defines a set of symbols called operators  and gives each operator an interpretation as a set of event sequences  action . these operators are the means of interaction between an agent and the environment  and are exchanged as messages 
1. agents 
   the execution of a plan corresponds to some sequence of messages between the environment and an agent. let a be the set of operators then a sequence of messages will be denoted by a string over the alphabet {begin end  x a. for any a€-1  {begin a  corresponds to the agent sending a to the environment to cause the associated action to be executed  and {end   corresponds to the environment sending a to the agent to indicate that the associated action has completed we refer simply to strings and assume them to be over this alphabet. 
   an agent is an acceptor for string*. the formal model for an agent is similar to a non-deterministic finite automaton. it has a set of nodes  agent states   and a set of arcs defining allowed state transitions with associated messages an agent deadlocks if it is in a state from which there are no possible state transitions involving a 
   {begin ¦Á  message  and the environment has finished executing all the operators sent by the agent 
   an agent defines a set of possible strings  and for any string  an environment defines some set of possible world state sequences. the planning problem is to take information about the environment  and find an agent which has some desired elfect on the world  such as the ultimate achieving of a goal world state  no matter what choices the environment makes we say two agents are equivalent if in any environment they induce the same set of possible sequences of world states. 
   an agent is bounded if there is a finite upper bound on the number of actions which the environment can be executing at a time. thus a bounded agent will suffice to represent the concurrent activity of a finite number of multiple real world agents 
1. plans 
   given three symbol sets a  m and s being operators  memory states and signals respectively  plans are defined recursively.   for any ¦Áe a : ¦Á is a plan for executing an single action 
  for any me m  s¡ês  set m    send s  and  guard m s  are synchronizing primitives. 
  if pl and p1 are two plans  then p1 is the plan to execute them in sequence  p1||p1 is to execute them in parallel  p1 p1 is to execute one or the other by non-deterministic selection  and p1 executes p  an arbitrary number of times 
1 	c.stuart 
   the semantics for plans is given as a mapping from plans to agents  which is described in | 1  intuitively  the agent for the simple 
plan ¦Á is an automaton accepting only the string { begin ¦Á   end ¦Á } the plan operators build automata in the conventional manner. the synchronizing primitives correspond to arcs in the automaton which have a side effect on plan execution without exchanging any messages with the environment set changes the memory statt of the plan  and guard and send can only be executed simultaneously  and then only when the memory is in the specified state and the signals match. this particular form of primitive is an adaptation of synchronization in the parallel programming language csp  which uses guards which may be a combination of an input/output operation and a normal conditional 
   the following two results  given without proof  assert that there is a one to one correspondence between plans and bounded agents.   any agent which is given as the semantics of a plan is bounded. 
  for any arbitrary bounded agent  there is a plan which has an interpretation equivalent to that agent. 
1. the interaction problem 
   the problem addressed here is that of ensuring that a plan does not deadlock  or allow any event to fail. correctness conditions on events or actions can be used to represent many types of plan correctness if a plan should achieve some goal state given some initial condition  this is ensured by beginning the plan with an action that  asserts the initial condition  and terminating it with an action that will always fail in the absence of the goal condition. a condition which must be maintained during a plan can be enforced with an action in parallel that will fail in the absence of the maintained condition. 
   a program has been developed which takes a plan and a description of an environment  and generates a revised plan which allows all and only the sequences of communication  acts of the first plan that cannot c ause failure  and also that will never deadlock 
1. preventing event failure 
   for this program we use a very simple form of event  corresponding to the operators of the strips planner|lj. the world is modeled as a set of propositions. events are constrained to add or delete propositions without reference to the current world state also  the correctness condition is a conjunction of propositions or negated propositions thus an event is four sets of propositions; a require true set  a require false set  an add set and a delete set 
   it turns out in this case that to prevent event failure an action is completely defined by five sets of atomic formulae  possibly negated propositions . the five properties are defined by considering the execution of the action in isolation from other actions an atomic formula is 
  asserted if it is inevitably true after the execution 
  retracted if it could possibly become false after the execution 
  conflicted if it could become false at some stage during the execution. 
  a precondition if it must be true immediately before the action begins to ensure that no event will fail. 
  a during condition if it must be true for some event in the action. 
   the necessary and sufficient rules for ensuring no event failure are: 
  an action which has a during condition may not run in parallel with an action that conflicts that during condition. 
  an action ¦Áp which has a precondition may not begin until some action ¦Ád which asserts that condition has completed  and also no action ¦Ár which retracts that condition may be running from when ¦Áa begins until ¦Áp ends. 
1. synchronising plant 
   we synchronize a plan by inserting send operations  and running it in parallel with a synchronization skeleton consisting only of guard and set operations the set of possible strings for the resulting plan is a subset of those for the original plan. manna and wolper describe an algorithm for generating such a skeleton from propositional temporal logic  ptl  formulae used to express constraints on execution sequences of a plan. 
   ptl is a logic for reasoning about sequences of states. the interpretation of a ptl formula is the set of sequences for which it is true. states give truth values to propositions and hence to non modal formulae  and the temporal connectives of ptl  always  eventually  until and next  have truth values depending on the 
successors of a state. we also use a regular expression operator equivalent in expressiveness to the grammar operators of wolper. 1j a regular expression with the basic elements being non modal formulae translates into a set of sequences of non modal formulae  and then to a set of sequences of states. 
1. the algorithm 
   the plan synchronizer has three phases first  ptl formulae are generated correctness constraints  being the two rules defined above  are expressed in standard ptl  using propositions to represent relevant stages in plan execution a regular expression formula corresponding to a simplification of the plan is used to express the constraints imposed by the plan syntax on the order of the relevant stages. the formulae are simplified or ignored depending on orderings already enforced by the plan syntax this reduces the time spent in the second phase without altering the interpretation of the conjunction of all the ptl formulae generated 
   second  a tableau method of theorem proving is applied formulae are decomposed into non modal constraints on the first state of a sequence  and general constraints on the remainder a graph is constructed  with arcs corresponding to states in plan execution  and nodes labeled with ptl formulae this graph is pruned to enforce eventuality constraints every interpretation for the original ptl formula is a path through the final graph  and every finite path is the prefix of an interpretation 
   finally  the graph is converted directly into a synchronization skeleton  and send operations are inserted into the plan for every proposition used the set of memory states used corresponds to the set of nodes in the graph  aud each arc is represented as a guarded command to alter the memory. the resulting plan allows all possible execution sequences of the original which do not permit an event to fail  and which always allow for plan termination 
   the current version of the program only handles restricted classes of plans and actions  no loops  no selection  and actions consisting of a single event sequence   but is being extended at the moment to include these 
1. an example 
   consider the problem of three robots all trying to pickup a block and move it clockwise to a location which another robot will clear as it moves  represented by the following unsynchroni/.ed plan 
   start  rl r1 r1    a x   by   c z    
 parallel    pickup rl ax   putdown rl a v   
   pickup r1 b v   putdown r1 bz   
   pickup r1 c z   putdown r1 c x     

 if  and  eq n 1   recv  end 1 1    then  setq n 1        
   the syntax is close to csp  and can be translated directly into plans as we have defined them a large section of the synchronization skeleton has been removed in the example  since it contains 1 guarded commands one for each arc in the model for the ptl formulae the final plan has the desired result of holding any putdown until the appropriate pickup has completed each pickup is followed by a send which indicates a block is clear  and each putdown is preceded by a send which is delayed until the appropriate destination block is clear. 
1. conclusion and future work 
   there are some optimizations possible in the general method by pruning the graph  which in the above example would have reduced the size of the synchronization skeleton  and removed redundant references to  degin 1 . it is also worthy of investigation to consider how synchronization primitives could be inserted in the main plan without adding a new parallel branch with the synchronization skeleton  or how the synchronization skeleton could be made more modular  with distinct components to handle particular constraints. 
   the definition of actions and environments given here enables very strong properties to be given to the synchronized plans: in particular that all and only the correct executions of the initial plan are permitted. this is in contrast to previous means of synchronizing plans which prohibit some execution sequences that would succeed. 
   by extending the definition of actions to include general state transformations in events  a similar algorithm could generate a plan which is still less restrictive than that produced by previous plan modifying techniques  but might still disallow certain correct 
	c.stuart 	1 
executions there is no simple action description capturing all the essential properties in the same way as can be done in the simple case with five sets of atomic formulae also  the ptl formulae might need to reference propositions reflecting world state as well as the stages of plan execution. this problem could be considered in more detail. 
   there is also the problem of types of non-determinism the current selection operator corresponds to the case where a plan may proceed in one of two directions  and the synchronizer is permitted to chose one over the other. this is angelic non-determinism however  it may be the case for some plans that the choice is critical  but made at execution time  in which ease the synchronizer must allow both cases or none at all this is demonic non-determinism  and implies some additional structure to a plan which restricts the ways in which it may be synchronized. for added complexity  the decision may be based on the state of the world model  and so the synchronizer can determine the choices it must leave open  depending on the possible world models it derives for the moment of choice 
   loops often have a termination condition which is a function of all the activity in the loop  and yet may not easily be derived from the given information. such a termination condition could be specified if a plan segment were treated as a single hierarchical action  and given properties similar to those for individual actions consider a loop of an action that removes a single item from a box until none are left to represent this in the formalism given here  the entire loop would be given an assert condition that the box become empty to guarantee termination  the entire loop could be given a during condition that no one places anything in the box. 
   a version of the program is being designed which will take as input an arbitrary plan as defined above  and will also handle both types of non-determinism  and conditions attached to sub-plans as hierarchical actions. the theoretical justification is being pursued concurrently. 
acknowledgements 
much of this investigation was conducted at the ai center at 
sri international  thanks are due to the center and especially to michael georgert for helpful discussion; and to monash university for financial assistance  and where the work is proceeding. 
