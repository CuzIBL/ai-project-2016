 
　　this paper is concerned primarily with  1  the procedure by which process-oriented specifications are obtained from goal-oriented requirement specifications and  1  computer-based tools for their construction. it first determines some attributes of a suitable process-oriented specification language  then examines the reasons why specifications would still be difficult to write in such a language. the key to overcoming these difficulties seems to be the careful introduction of informality based on partial  rather than complete  descriptions and the use of a computer-based tool that uses context extensively to complete these descriptions during the process of constructing a 
　　well-formed specification. some results obtained by a running prototype of such a computer-based tool on a few informal example specifications are presented and  finally  some of the techniques used by this phototype system are discussed. 
/. 	introduction 
　　a critical step in the development of a software system occurs when its goal-oriented requirements specification is transformed into a process-oriented form that specifies how the requirements are to be achieved. only after this transformation has occurred can the feasibility of the system be analyzed and the consistency of the process specification with the requirements be verified. the key to this transformation is expressing the process-oriented specification abstractly so that its functionality is completely determined while the class of possible implementations remains broad. 
　　we believe that such abstract process-oriented specifications are the key to rationalizing the software development process. such specifications are  in reality  programs written in a very high level abstract programming language. as such  they could provide an effective interface between the two major software concerns: functionality and efficiency. these concerns should be decoupled so that the functionality of a system can be addressed before its efficiency has been considered. once functionality has been accepted  it can be preserved while the system is optimized. thus  since the abstract process-oriented specification is a program  its consistency with the requirements could be formally verified  informally argued  or tested by actually executing the specification. furthermore  the end user could be given hands-on experience exercising the specification to see if it behaved as intended. deviations and/or inconsistencies could be corrected in the specification before any implementation occurred. 
　　once the system's functionality has been accepted by the user  the efficiency of the system in meeting its performance requirements remains an issue. such efficiency must be gained without altering the system's accepted functionality. we have argued elsewhere  that a computer-based tool can 
note: this research was supported by the defense advanced research projects agency  darpa  under contract no. 
dahc1 c 1  arpa order no. 1  program codes 1 and 1. 
be built which guarantees maintenance of functionality while a program is optimized without sacrificing the programmer's ingenuity or initiative in determining how best to achieve 
efficiency. 
　　in this paper we are concerned primarily with the procedure by which such process-oriented specifications are obtained and with computer-based tools for their construction. we will begin by determining some attributes of a suitable process-oriented specification language  then examine why specifications would still be difficult to write in such a language. we will argue that the key to overcoming these difficulties is the careful introduction of informality based on partial  rather than complete  descriptions and the use of a computer-based tool which utilizes context extensively to complete these descriptions during the process of constructing a well formed specification. we will then present some results obtained by a prototype of such a computer-based tool on a few informal example specifications. finally  we will discuss some of the techniques used by this prototype system. 
1. attributes of suitable process-oriented specification languages 
　　as stated above  a suitable process-oriented specification must completely define functionality  represent a broad class of possible implementations  and be executable. 
　　how can we obtain such a language  we begin by noting that a suitably abstract programming language is a 
　　specification language. several recent languages almost meet the above requirements for an executable specification language. they have arisen from two separate disciplines: 
　　1. specification languages. languages  such as rsl  psl  etc.  designed specifically for specification  describe a system in terms of data flows and processing units but do not functionally define the processing. such languages can provide a simulation of the described system down to some level of detail  but cannot describe or simulate its full functionality. 
　　1. abstract programming languages. spawned by dijkstra's notions of structuring  a generation of programming languages  clu  alphard  euclid  pearl  has bloomed which isolate the definition of data objects  and the operations allowed on them  from their use and manipulation in the program. the result is the ability to use abstract program entities which model those that occur in the application being programmed. these entities are defined in terms of more computer-science-oriented entities  which are  in turn  defined in terms of more primitive ones  until the primitive objects and operations of the language are reached. without the successive refinements of the abstract objects and operations  these languages would be suitable for specification  except that they would then lose their property of executability. their executability has been gained at the expense of complete specification of implementation  down to the base level of the language . 
what is clearly needed  then  is a language which can fully specify a system functionally without fully specifying its implementation. what are the required properties of such a language  
　　first  it must be able to define and manipulate application-oriented objects  as is done by the abstract programming languages . second  the description of these objects and operations must be in terms of some formalism that does not require successive refinement to gain functionality and that does not overly constrain the 
　　
auto. 	pror:. - 1 : 	r a l z e r 
1 
　　
implementation. this is the key issue that would enable specification and programming languages to be unified. 
　　three formalisms have been proposed for this role: sets  axiomatic specification  and relational data bases. 
　　one of the earliest efforts is jack schwartz's setl language. sets are the single abstract type allowed for which multiple implementations exist. all the operations on sets can deal with any of the implementations. thus  users need not be concerned with any of these implementations while specifying the manipulations to be performed on their sets. because functionality was completely captured by the setl definitions of sets  implementation did not have to be considered. however  such implementation-free functionality existed only for sets and was not extensible. 
　　more recently  guttag  horowitz  and musser  have discussed an axiomatic specification technique in which the functional behavior of new abstract objects are axiomatically defined by algebraic equations. these algebraic equations act as functional requirements which any implementation of the objects and operations upon them must satisfy. furthermore  they provide a way of executing programs using the operations directly without providing any implementation. whenever an operation is performed on an object  the  state  of that object is transformed by applying the algebraic equation for that operation to the existing  state.  the resulting state is just another expression in the algebra. as more and more operations are performed  these states become more complex. however  the states can be simplified by general rules of the algebra such as and a false - false  or by using the equations for the abstract objects as rewrite rules  such as for a stack  pop push a x  = a. such equivalence rules are part of the functional definition of the operations on the abstract objects. if the axiomatic functional definitions are complete  then specifications in this language can be directly executed while no implementation need be selected and the choice of possibilities has not been constrained. these axiomatic functional definitions provide a user the capability of adding arbitrary new abstract types to the language that can be manipulated in an implementation independent way. this extensible capability is exactly analogous to setl's built-in capability to manipulate sets in an implementation-independent way. 
　　finally  we have languages in which the  state  is represented by a series of assertions in a relational data base  rather than by an expression  and in which the effects of an action are expressed as a series of additions or deletions to the data base rather than as an equation to be applied to the  state.  the big difference between these two approaches is that in the axiomatic approach the functional definitions are expressed as interactions between the operations on a data type and hence do not rely on any more primitive notions. in the relational approach  as in setl  each operation is functionally defined in terms of how it affects a built-in primitive notion  the relational data base. 
　　the self-defining  or closed  property of axiomatic definitions would seem to favor that approach because each abstract object and its operations can be considered in isolation without relying on outside semantics and without specifying any constraints on the implementation. unfortunately  this property comes at the expense of expressing the behavior of objects entirely in terms of the operations upon them and the need to express this behavior in the form of algebraic equations so that the equivalence of alternative sequences of operations can be formed  e.g.  the pop push a x  - a equivalence cited earlier for stacks . 
　　in the relational approach  rather than stressing a closely knit set of types and operations on them  objects are perceived entirely in terms of their relationships with each other and a set of primitive operations which allow these relationships to be built and destroyed and to be extracted. non-primitive operations exist on the objects  but they merely alter the set of relationships that exist between the objects. this view allows incremental elaboration of objects  their relationships with each other  and operations upon them. most importantly  this approach enables objects and operations to be modeled almost exactly as they are conceived by the user in his application  as measured by how they are expressed in our most unconstrained form of communication-natural language . 
　　this latter property is the reason we have selected the relational approach: we feel it minimizes the difficulty that a user would have in constructing an operational specification. 
1. why 	operational specifications are hard to 
construct 
　　unfortunately  even when the user's difficulties in constructing operational specifications are minimized by the use of the relational approach  the task remains burdensome and error-prone  primarily because although a suitable language has been chosen  it is still formal. each reference to an object or action must be consistent and complete. the large number of interacting objects  actions  and relationships require the user to do a great deal of  error-prone  clerical bookkeeping which impedes his attention to the specification itself and reduces its reliability. 
　　suppose we constructed a computer aid which relieved the user of these clerical chores. how would the specification task be altered  we begin by considering how people specify software systems when unconstrained by computer formalisms. 
1. semantic constructs 	in natural language 
specification 
　　we studied many actual natural language software specifications. the main semantic difference between these specifications and their formal equivalent is that partial descriptions instead of complete descriptions are used. when such partial descriptions are understood it is because they can be completed from the surrounding context. the partial descriptions focus both the writer's and the reader's attention on the relevant issues and condense the specification. furthermore  the extensive use of context almost totally eliminates bookkeeping operations from the natural language specification. these are some of the properties we find so useful in natural language specifications and which we so sorely lack in formal specification languages. 
　　we have evidence  see sections 1 and 1   in the form of a running prototype system that these properties can be added to a previously formal specification language and that a computer tool can complete the partial description from the existing context. such a capability is not totally new; it already exists in limited form. 
a u t o . 	p r o r   - 1 : 	b a l z e r 
1 　　most programming languages use the context provided by declarations to complete partial descriptions of the operations to be performed on those objects  e.g.  add becomes either integer-add or floating-add  depending on the declared attributes of its operands . the codsyl dbdtg report  goes further in the use of context by completing partial references to an item by use of the  current  instance of that item as established by some other statement in the program. data base declarations are also used to determine how various program variables are to be used in completing partial descriptions of data base items. 
　　these uses of context in programming languages have been accepted  and even championed  because for each use  the context-providing mechanisms are well-defined  the completion rules are simple and direct  and only a single interpretation is valid. 
　　the context mechanisms we are proposing here are much more complex  the context generated much more diffuse  and a given partial description may produce zero  one  or several valid interpretations. zero valid interpretations means that the partial description is inconsistent with the existing context. a single valid interpretation means that the partial description can be unambiguously completed through use of the existing context. multiple valid interpretations indicate that sufficient context does not exist to complete the description and that interaction with the user is required to resolve the ambiguity. 
　　our work should be viewed as an effort to provide more general context mechanisms to resolve the ambiguity introduced in the specification by partial descriptions. if  as we believe  such mechanisms can be provided  would they be a beneficial addition to specification languages  
1. 	desirability 	of 	informality 
　　we recognize that our approach is controversial and apparently opposes the current trend to make program specifications more and more formal and to introduce such formalisms earlier in the development cycle. we believe closer examination will reveal that our approach is not only compatible with the desire for increased formalism  but a necessary adjunct to it. 
　　attention has been focused on formalisms for program specification to the exclusion of concern with the difficulty and reliability of creating such formal specifications and with maintaining them during the program life-cycle. our approach specifically addresses these issues. 
　　first  it should be recognized that informality will always exist during the formulation of a specification. the issue is whether the informal form is explicitly entered into the computer and transformed  with the user's help  into the formal specification  or whether it exists only outside the computer system in someone's head or written somewhere in unanalyzable form. we should consider  then  the feasibility and the desirability of a computer-based tool to aid in the transformation of an informal specification into a formal one. 
　　let us begin with the question of feasibility. while the results presented in the next section are preliminary and the examples chosen far smaller and simpler than real specifications  we are optimistic about continued progress and ultimate practicality of this approach. however  since these results are far from conclusive  we invite the reader to reach his own conclusions after considering the examples of the next section and the description of the prototype system which follows them. 
　　assuming for the moment that such a system is feasible  we consider its desirability. informal specifications have three obvious advantages. first  they are more concise than formal specifications and focus both the specifier's and the reader's attention. they are more concise because only part of the specification is explicit; the rest is implicit and must be extracted from context. attention is focused on the explicit information and  therefore  away from the implicit information  which increases both the readability and the understandability of the specification. 
　　the second advantage is that informal specifications which employ partial rather than complete descriptions are a familiar  in fact normal  mode of communication. this reduces the training requirements of users  permits a wider set of users  and reduces dependence on the judgment and accuracy of intermediaries. 
　　the final advantage deals with the maintainability of the system. since about 1. of the total life cycle costs of large systems are for maintenance  any improved capabilities in this area are very significant. as we have argued elsewhere   the main deterrent to maintainability is optimization. optimization spreads information throughout a program and increases its complexity through increased interactions among the parts. both of these optimization effects greatly impede the ability to alter the program. an obvious solution is to alter an unoptimized specification and then reoptimize the program. no cost-effective and reliable technology currently exists for such reoptimization  though one has been proposed en 
　　a similar situation exists between the informal and formal specifications. the creation of a formal specification involves spreading implicitly specified information throughout the specification and increasing the complexity by structuring the specification into parts and establishing the necessary interfaces between them. as before  both of these formalization effects greatly impede the ability to modify the specification. again  a solution is obvious: modify the informal specification and retransform it into a revised formal specification. under the assumed feasibility of our approach  this solution would be possible and would greatly simplify maintaining the formal specification of the system. 
　　we now consider three possible disadvantages of a computer-based tool to aid in transforming an informal specification into a formal one. the first possible disadvantage is that the informal constructs will be misunderstood by the computer tool. this is entirely possible  just as it is when a human intermediary interprets an informal specification. while the computer tool cannot match human performance in understanding the informal specification  it operates much more methodically. it can question the user when it detects that there are alternative interpretations of some statement. it can record and make explicit all assumptions it makes in transforming the formal specification. it can paraphrase the informal specification to verify that its interpretation is accurate  the current prototype system records its assumptions and interacts with the user to determine the correct interpretation of unresolved ambiguities  but does not yet contain any paraphrase capabilities . thus  feedback and interaction with the user can eliminate the problem of possible misinterpretation of the informal specification. 
　　the second possible disadvantage is that the computer-based tool will decrease the reliability of the transformation to a formal specification. if the informal specification exists only outside the computer system  then we must rely on the accuracy of the user or  more often  on some trained intermediary to accurately transform it into a formal specification. this transformation depends upon properly understanding the informal specification  see previous paragraph   then restating it in the required formalism. once the proper understanding has been obtained  the restatement involves moving information from one place to another and changing its form. history would indicate that such clerical bookkeeping transformations are error-prone and can always be done more reliably by a computer tool. hence  once the 
　　
a u t o . 	p r o r . - 1 : 	b a l z e r 
1 
　　
correct interpretation has been obtained through the use of context and interaction with the user  the restatement of the informal specification into the required formalism can be more reliably performed by the computer-based tool than by the user or his intermediary. therefore  reliability would be improved rather than reduced by such a tool once understanding was obtained. 
　　understanding  rather than reliability  thus emerges as the key feasibility issue. one way to improve understanding is to increase the interaction with the user. this leads to the third possible disadvantage: that the required volume of interaction will abrogate the advantage of informality. we do not expect this to be an issue with the current system or its successors  since we feel that its current performance level  as evidenced in the following section  indicates that the required interaction rate would be sufficiently small to prevent annoying or sidetracking the user. 
　　thus  we conclude that the availability of such a computer-based tool would be highly desirable because it would simplify the creation of a formal specification while increasing the reliability of the formulation process; improve the maintainability of the formal specification; reduce special training requirements; and expand the base of potential users. the question of feasibility  which remains as the paramount issue  rests clearly on the ability to correctly interpret an informal specification. we therefore now present some preliminary results obtained by the prototype system and describe its operation so that the reader can observe its performance level and judge for himself the generality of its context resolution mechanisms and therefore its feasibility. 
1. 	results 
　　this section presents two examples successfully handled by the prototype system. the examples were extracted from actual natural language specification manuals  and the results illustrate the power of the system's context mechanisms. however  our system is a prototype and  as such  it is far from complete. new examples currently expose new problems which are resolved by adding new capabilities to the system. therefore  until some measure of closure is obtained  it should not be assumed that the prototype will correctly process new examples of the same  complexity  as earlier examples. our goal is to add each new capability in as general a form as possible so that when it is used in new examples it will function correctly. in this way we expect to  grow  the system as more complex and varied examples are tried. 
　　for each of the examples  we present three figures: the actual parenthesized version of the informal input currently used by the system  to avoid syntactic parsing problems  ll   a manually marked version which indicates some of the informalities to be resolved by the system  and a stylized version of the formal output program produced by the system. 
　　the first example is a system which automatically distributes messages to offices on the basis of a keyword search of the text of the message. figure 1 gives the informal natural language description. figure 1 indicates some of the imprecisions contained in this example which must be resolved to obtain the system's formalization of this specification as an operational program  figure 1 . 
　　to give some measure of the amount of imprecision in this example and  therefore  the amount of aid provided by the system  we have compiled the following statistics: 
number of missing operands 	＊ 1 number of incomplete references 	＊ 1 number of implicit type conversions 	  1 number of terminology changes 	  1 number of refinements or elaborations - 1 number of implicit sequencing decisions - 1 actual input for message processing example 
   messages   received  from  the  autodin-asc      are processed  for  automatic distribution assignment   
   the message   is distributed  to  each   assigned   office   
   the number of  copies of  a message    distributed  to 
 an office      is   a function of  whether   the office   is assigned  for    action   or   information        
   the rules for   editing   messages     are   :   replace  
 all line-feeds  with  spaces     save   only  alphanumeric characters  and  spaces      eliminate   all redundant spaces     
    to edit   the text portion of  the message     is  
 necessary   
  then  the message   is searched  for  all keys   
  when   a key   is located  in  a message     perform   the action   associated  with  that type of  key       
   the action for  type-1 keys    is   :  if   no office   has been assigned  to  the message  for   action      the 
 action  office from  the key    is assigned  to  the message  for   action      if   there is  already  an 
 action  office for  the message      the  action  office from  the key    is treated  as  an  information  
office       label 1ffs1  all  information  offices from 
 the key     are assigned  to  the message   if   ref 1ffs1 
they  	 have 	 not  	 already  	been 	assigned  	for 
   action   or   information        
   the action for  type-1 keys    is   :  if   the key   is   the first type-1 key   found  in  the message     then 
  the key   is used  to   determine   the  action  office      otherwise  the key   is used  to   determine   only 
 information  offices      
figure 1 
　　to illustrate how context is used to complete the partial descriptions in the example  we consider a few cases: 
1. partial sequencing. distribution is never explicitly invoked in the informal specification. however  the first sentence indicates that assignment is performed to enable the distribution. hence  distribution should be explicitly invoked after assignment. 
1. missing operand. sentence two indicates that the message should be distributed to certain offices-those that are  assigned.  but  as can be determined from other usages in the informal specifications  offices can be  assigned  to either messages or keys. this missing operand can be resolved by remembering that assignment 
　　
auto. 	p r o r . - 1 : 	ral1 r 
1 
　　

was performed to enable distribution. hence  distribution must use some result of the assignment process. assignment  from the last two input sentences  assigns offices to the current message. hence  distribution must consume offices assigned to that message. 
   incomplete reference. sentence four says to replace all line feeds with spaces. first  replace requires a third operand  some set in which the replacement will occur. context indicates that this missing operand should be the text of the message parameter of edit. second  the use of a plural in the operand of an action which expects a singular operand  indicates an implicit loop. hence  we have   for all line feeds  replace the line feed by a space in the text of the message.  now  which line feeds are we concerned with  only those in the text of the message because they are the only ones which can be replaced. hence  completing the partial reference  we have  for all line feeds in the text of the message  replace the line feed by a space in the text of the message.  
　　it should be noted that of the approximately 1 decisions which had to be made for this example  all but one were resolved correctly by the prototype system. the message it distributed is the edited one  with all punctuation removed  rather than the original unedited one. the cause of the error is that the system does not understand the difference between an object being changed and its participating in relations with other objects; therefore  it has no concept of the original state of an object and hence does not consider this as a possible completion of any partial reference. 
program created by prototype system 
 whenever 	  r e c e i v e message fror autodin-asc by safe  
d1 odi t 	t e x t of message  
  s e a r c h text of message for  create the set of keys   
  d i s t r i b u t e - p r o c e s s f l 	message   
  d i s i r i b u t e - p r o c e s s # l 	 message  
 for all   o f f i c e s assigned to message for anything  
	  d i s t r t b u t e - p r o c e s s # 1 	message 	o f f i c e       
  d i s t r i b u t e - p r o c e s s # 1 	 message 	o f f i c e   
 1 	  f u n c t i o n a l 	 boolean 	 assigned o f f i c e to message for a c t i o n     
	 boolean 	 assigned o f f i c e to message for 	i n f o r m a t i o n       
tiries   d i s t r i b u t e a copy uh1ch is a copy of messago and located at s a f e from safe to l o c a t i o n of o f f i c e       
  e d i t 	  t e x t   
 for all 	i i n e - f e e d s 	in text 
	  r e p l a c e 	l i n e - f e e d in text by  create set of spaces    
 keep 	 union 	 create the set of alphanumberlc ch ara ct e r s in t e x t   
　 create the set of spaces in t e x t     from t e x t   
 for all spaces 	in text ano redundant 	in text 
 remove space from t e x t     
 whenever 	  l o c a t e a key in text of message at position anything  
do  case 	 type of key  
	  t y p e - 1 	  t y p e - 1 - a c t i o n message key   
	  t y p e - 1 	  t y p e - 1 - a c t i o n message k e y         
  t y p e - 1 - a c t i o n 	 message key  
 if 	 not 	 exists a c t i o n o f f i c e for message   
	then 	  a s s i g n the a c t i o n o f f i c e f l for key 
to message for a c t i o n   
else 	  t r e a t 	a c t i o n o f f i c e # 1 for key 
	as 	i n f o r m a t i o n o f f i c e # 1 for key 
	in 	 if 	 not 	 assigned o f f i c e # 1 to message 
	for a c t i o n or 	i n f o r m a t i o n     
	then 	 assign o f f i c e # 1 to message for i n f o r m a t i o n         
 for all 	  o f f t c e # 1 assigned to key for information  
	 if 	 not 	 assigned o f f i c e # 1 to message 
	for a c t i o n or 	i n f o r m a t i o n   
	then 	  a s s i g n o f f i c e # 1 to message for 	i n f o r m a t i o n         
  t y p e - 1 - a c t i o n 	 message key  
 if key - 	  k e y # i uh1ch is 	 search history for first 
  l o c a t e t y p e - 1 key#l in text of message at p o s i t i o n any    then  determine the a c t i o n o f f i c e for message 
	by 	  t y p e - 1 - a c t i o n message key   
	else 	 determine only the 	i n f o r m a t i o n o f f i c e for message 
	by 	 if 	 exists a c t i o n o f f i c e for message  
	then 	  t r e a t 	a c t i o n o f f i c e # l for key 
	as 	i n f o r m a t i o n o f f i c e # l for key 
	in 	 if 	 not 	 assigned o f f i c e #1 to message 
	for a c t i o n or 	i n f o r m a t i o n     
	then 	 assign o f f i c e ' l to message for 	i n f o r m a t i o n         
	 for all o f f i c e # 1 assigned to key for 	information  
 if  not  assigned o f f i c e # 1 to message for a c t i o n or i n f o r m a t i o n     
then  assign o f f i c e # 1 to message for i n f o r m a t i o n             
figure 1 
　　this capability can clearly be added to the system  but the important point is that interpretation errors will occur  just as they do when human intermediaries are used to produce the formal specification. it is therefore essential to provide extensive feedback and assumption-testing facilities so that such errors  when made  can be discovered and corrected by the user. 
　　the second example is from a system for scheduling a satellite communication channel by multiplexing it among several users  subscribers . it specifies the component of the system which receives a schedule  sol  from the controller of the satellite channel and extracts from it the portions of the 
　　
	auto. 	p r o * . - 1 : 	balzer 
1 
next transmission cycle which have been reserved for a particular subscriber and those portions available to any user  rats . this information is placed in a transmission schedule used by another component to actually utilize the channel during the allowed periods. figure 1 gives the informal natural language description. figure 1 indicates some of the imprecisions contained in this example which must be resolved to obtain the system's formalization of the specification as an operational program  figure 1 . in addition to the process description of figure 1  we have assumed that the formulas referenced and a structural description of the objects of the domain have been separately specified. 
　　the relevant portions of these specifications are that the sol is an ordered set of subscriber and rats entries. each subscriber entry has subscriber identifier and transmission length fields  while a rats entry has only the latter. the transmission schedule is a set of entries  each of which is composed of an absolute transmission time and a transmission length. one of these entries is the primary entry of the transmission schedule. finally  formulas 1 and 1 both take an sol entry as input and produce  respectively  a relative and an absolute transmission time. 
       using the same measures of imprecision as in the first example  we find that this example has about half as many 
imprecisions. 
number of missing operands 	  	1 number of incomplete references 	- 	1 
	number of implicit type conversion 	＊ 	1 
	number of terminology charges 	= 	1 
	number of refinement or elaboration 	- 	1 
	number of implicit sequencing decisions 	= 	1 
　　the example is interesting as a test of the generality of the mechanisms which worked on the first example  and because of the new issues it raises. we will examine each of these to illustrate the range of capabilities added to the prototype to enable it to correctly understand this example and produce the operational program of figure 1. 
 build-transmission-schedule  sol subscriber  
 create transmission-schedule  
 search sol for a subscriber-entry such that sid of subscriber equals sid of subscriber-entry  
 if  locate a subscriber-entry such that sid of subscriber equals sid 
of subscriber-entry in sol  
then 
 make  result-of  formula-1 subscriber-entry   be the relative-transmission-time of subscriber  
 make  result-of  formula-1 subscriber-entry   be the clock-transmission-time of subscriber   
 for all rats which are in sol 
do  make  result-of  formula-1 rats   
be the relative-transmission-time of rats  
 make  result-of  formula-1 rats   
　　　　　be the clock-transmission-time of rats    for all clock-transmission-time of rats 
do  make clock-transmission-time be the transmission-time of  create transmission-entry   
 add transmission-entry to transmission-schedule    
 whenever  make time be the clock-transmission-time 
of subscriber  
do  make time be the transmission-time 
of  create transmission-entry   
 add transmission-entry to transmission-schedule  
 make transmission-entry be the primary-entry 
of transmission-schedule   
figure 1 
auto. prog:.-1: balzer 
1 
　　
　　1. scope of conditional. in natural language communication the end of a conditional is almost never explicit. instead  context must be used to determine whether subsequent statements are part of the conditional. in sentence three of the example  the input to formula 1 is the sol entry found in the previous sentence. thus  sentence three is really part of the conditional statement. 
　　1. implicit formation of relations. in sentence two  the relative transmission time produced by formula 1 is supposed to be associated with the subscriber. since that association is not established elsewhere  it is implicitly being established here. hence this passive construct must be treated as an active one. 
　　1. implicit creation of outputs. in a similar fashion  various sentences establish associations with a transmission schedule  the output of this example  but an instance of one is never explicitly created. such usage indicated that an implicit creation of the output is required. 
　　a. expectation failure. in addition to process and structural statements  a specification normally contains expectations about the state of the computation at some point which provide context for people to explain why something is being done or some properties of its result. they also provide some redundancy against which an understanding of the specification can be checked. in the example  one of these expectations  that all of the components of the entries of the output have been produced  fails  which indicates either a misunderstanding of the specification or an inconsistency or incompleteness. in this case  both our example and the actual specification from which it was drawn are incomplete; they fail to describe how the length field of the entries of the transmission schedule are calculated from the inputs. 
1. description oe the prototype system 
　　the prototype system is structurally quite simple. it has three phases  linguistic  planning  and meta-evaluation  which are sequentially invoked to process the informal specification. each phase uses the results of the previous phases  but no capability currently exists to reinvoke an earlier phase if a difficulty is encountered. hence  either ambiguity must be resolved within a phase or the possibilities passed forward to the next phase for it to resolve. 
　　we will describe the prototype system by working backward from the goal through the phases  in reverse order  toward the input to expose the system design and provide context for understanding the operation of each phase. 
　　the goal of the system is to create a formal operational specification from the informal input  which means that it must complete each of the partial descriptions in the input to produce the output. in general  each partial description has several different possible completions  and a separate decision must be made for each partial description to select the proper 
completion for it. 
　　based on the partial description and the context in which it occurs  an a priori ordered set of possible completions is created for each partial description. but one decision cannot be made in isolation from the others; decisions must be 
consistent with one another and the resulting output specification must make sense as a whole. since the output is a program in the formal specification language  it must meet all the criteria for program well-formedness. fortunately  programs are highly constrained objects  one reason they are 
	a u t o . 	p r o * . -
1 
so hard to write   so there are many well-formedness criteria which must be satisfied. 
　　this provides a classical backtracking situation   since there are many interrelated individual decisions that in combination can be either accepted or rejected by some criteria  the well-formedness rules . in such situations  the decisions are made one at a time in some order. after each decision the object  program  formed by the current set of decisions is tested to see if it meets the criteria  well-formedness rules . if it does  then the next decision is made  and so on  until all the decisions have been made and the result accepted. if at any stage the partially formed result is rejected  then the next possibility at the most recent decision point is chosen instead and a new result formed and tested as before. if all possibilities have been tried and rejected for the most recent decision point  then the state of the decision-making process is backed up to that existing at the previous decision point and a new possibility chosen. this process will terminate either by finding an acceptable solution  formal specification  or by determining that none can be found. the resulting object  program  is an acceptable solution  formal specification  for the problem  informal specification . 
　　the order in which decisions  rather than the order of alternatives within a decision  are made should be chosen to maximize early rejection of infeasible combinations of decisions. this requires that the rejection criteria can be applied to partially determined objects. the preferred decision order is clearly dependent on the nature of the acceptance/rejection criteria. 
　　we now let the nature of the well-formedness criteria determine the structure of the prototype system so that the early rejection possibilities inherent in the criteria can be utilized. the criteria fall into three categories: dynamic state-of-computation criteria  global reference criteria  and static flow criteria. each of these categories must be handled differently. 
　　the dynamic state-of-computation criteria are based only on the current  state  of the program and its data base  e.g.   the constraints of a domain must not be violated  and  it must be possible to execute both branches of a condition  . they require that all decisions that affect the computation to that point  but not beyond  must be made before the criteria can be tested. thus  if decisions could be made as they are needed by the computation of the program and the program  state  examined at each stage of the computation  then the dynamic state-of-computation criteria could be used to obtain early rejection of infeasible decisions. 
　　this is exactly the strategy adopted in the design of the prototype system. however  since no actual input data is available for the program to be tested  and since the program must be well-formed for a variety inputs  symbolic inputs rather than actual inputs are used. instead of actual execution  the program is symbolically executed on the inputs  
which provides a much stronger test of well-formedness than would execution on any particular set of inputs. 
　　however  completely representing the state of the computation as a program is symbolically executed is very difficult  e.g.  determining the state after execution of a loop or a conditional statement  and more detailed than necessary for the well-formedness rules. therefore  the prototype system uses a weaker form of interpretation  called meta-evaluation  which only partially determines the program's state as computation proceeds  e.g.  loops are executed only once for 
1 : b a q l z e r 
some  generic  element  and the effects of then and else clauses are marked as possible  but are not conditioned by the predicate of the if . this meta-evaluation process is much easier to implement and still provides a wealth of run-time context used by the acceptance/rejection criteria to determine program well-formedness. 
　　the global referencing criteria  such as  parameters must be used in the body of a procedure   test the overall use of names within the program and thus cannot be tested until all decisions have been made. they are tested only after the meta-evaluation is complete. 
　　the final category of criteria  static flow  e.g.   items must be produced before being consumed  and  outputs must be produced somewhere    are more complex. the 
meta-evaluation process requires a program on which to operate  which may contain partial descriptions that the meta-evaluation process will attempt to complete by backtracking. this program  outline  is created from the informal input for the meta-evaluation process by the flow analysis  or planning  phase  which examines the individual process descriptions and the elaborations  refinements  and modifications of them in the input  then determines which pieces belong together and how the refinements  elaborations  and modifications interact. it performs a producer/consumer analysis of these operations to determine their relative sequencing and where in the sequence any unused and unsequenced operations should occur. this analysis enables the planning phase to determine the overall operation sequencing for the program outline from the partial sequencing information contained in the input. it uses the data flow well-formedness criteria and the heuristic that each described operation must be invoked somewhere in the resulting program  otherwise  why did the user bother to describe it   to complete the partial sequence descriptions. 
　　if the criteria are not sufficiently strong to produce a unique program outline  the ambiguity must be resolved either by interacting with the user or by including the alternatives in the program outline for the meta-evaluation phase to resolve as part of its decisionmaking process. in the prototype system  the meta-evaluation phase is prepared to deal with only minor sequencing alternatives such as the scope of conditional statements  if a statement following a conditional assumes a particular value of the predicate  it must be made part of one of the branches of the conditional.  and demons  are all situations which match the firing pattern of a demon intended to invoke it or only those which arise in some particular context  and if so what context  . major sequencing issues-such as whether one statement is a refinement of another or not-that cannot be resolved by the planning phase must be resolved by the user before the meta-evaluation phase. 
　　both the planning and meta-evaluation phases use a structural description of the application domain to provide context for their program execution  and inference rules which define relation inter-dependencies in the process domain. this structural base is the application-specific foundation upon which the planning and meta-evaluation phases rest  and must be provided before they are invoked. it contains all the application-specific contextual knowledge. it augments the system's built-in knowledge of data flow and program well-formedness and enables the system to be specialized to a particular application and to use this expertise in conjunction with its built-in program formation knowledge to formalize the input specification. 
　　the construction of a suitable application-specific structural base is itself an arduous  error-prone task. furthermore  our study of actual program specifications indicated that most of the structural information was already informally contained in the program specification. we therefore decided to allow partial descriptions in the specification of the structural base and to permit such descriptions to be intermixed with the program specification. 
　　since we are concerned only with the semantic issues raised by using partial descriptions in the program specification  the system uses a parenthesized version of the natural language specification as its actual input to avoid any syntactic parsing issues. this parenthesized input does not affect the semantic issues we have discussed. 
　　the first tasks  then  of the system are to separate the process descriptions from the structural descriptions  to convert both to internal form  and to complete any partial structural descriptions. these tasks comprise the system's linguistic phase  which precedes the other two. 
　　if a formal structural base already exists for some application  then  of course  it is loaded first and is augmented by and checked for consistency with any structural statements contained within the program specification. 
　　thus  in chronological order  rather than the reverse dependence order used above   the system's basic mode of operation consists of reading an input specification  separating it into structural and processing descriptions; completing the structural descriptions and integrating the result into any existing structural base; determining the gross program structure by producer/consumer analysis during the planning phase; and  finally determining the final program structure through meta-evaluation. 
