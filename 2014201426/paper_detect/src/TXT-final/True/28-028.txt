 
we address the problem of introducing preferences into default logic. two approaches are given  one a generalisation of the other. in the first approach  an ordered default theory consists of a set of default rules  a set of world knowledge  and a set of fixed preferences on the default rules. this theory is transformed into a second  standard default theory  where  via the naming of defaults  the given preference ordering on defaults is respected. in the second approach  we begin with a default theory where preference information is specified as part of an overall default theory. here one may specify preferences that hold by default  or give preferences among preferences. again  such a theory is translated into a standard default theory. the approach differs from previous work in that we obtain standard default theories  and do not rely on prioritised versions  as do other approaches. in practical terms this means we can immediately use existing default logic theorem provers for an implementation. from a theoretical point of view  this shows that the explicit representation of priorities adds nothing to the overall expressibility of default logic. 
1 	introduction 
in many situations in nonmonotonic reasoning the application of one default is preferred to another. perhaps the best known example is inheritance of properties  where an individual is assumed to have properties by default according to the most specific class es  to which it belongs. hence an individual that is a penguin  and so a bird  does not fly by default  since penguins typically don't fly  even though birds do typically fly. preferences are also found in decision making and in scheduling. for *previously at leria  universite d'angers  france. 
1 	automated reasoning 
torsten h. schaub* 
institut fur informatik 
universitat potsdam 
postfach 1 1  d-1 potsdam torsten cs. uni-potsdam. de 
example  in scheduling not all deadlines may be simultaneously satisfiable; preferences then may allow some compromise solution. in legal reasoning laws may apply by default  but the laws themselves may conflict; such conflicts may be adjudicated by higher-level principles. 
　our goal in this paper is to explore preference orderings in nonmonotonic reasoning  specifically in default logic  reiter  1 . in the next section we examine the general notion of preference orderings on defaults. we note that there is not a single way in which preferences should be applied. rather what we will call specificity orderings  as are used in property inheritance  can be distinguished from preference or priority orderings. these notions have frequently been conflated previously in the literature; here our concerns lie solely with preference orderings. 
　in considering how preference orderings may be enforced in default logic  we consider first where a default theory consists of world knowledge and a set of default rules  together with  external  preference information between default rules. we show how such a default theory can be translated into a second theory wherein preference information is now incorporated into the theory. so with this translation we obtain a theory in  standard  default logic  rather than requiring machinery external to default logic  as is found in previous approaches. we subsequently generalise this approach so that preferences may appear arbitrarily as part of a default theory and  specifically  preferences among default rules may  via the naming of default rules  themselves be part of a default rule. we again show how such a generalised default theory can be translated into a  standard  default theory where preference information is incorporated into the theory. 
　previous approaches have generally added machinery to an extant approach to nonmonotonic reasoning. we remain within the framework of standard default logic  rather than building a scheme on top of default logic  for several reasons. first  there exist theorem provers for default logic. consequently our approach can be im-

mediately incorporated in such a prover. second  it is easier to compare differing approaches to handling such orderings. third  by  compiling  preferences into default logic  and in using the standard machinery of default logic  we obtain insight into the notion of preference orderings. thus for example we implicitly show that explicit priorities provide no real increase in the expressibility of default logic. 
1 	preference orderings 
this section discusses preference orderings in general; while we employ default logic  the discussion is independent of any particular approach to nonmonotonic reasoning. we can use default rules1 to express that b follows by default from a by  then we can write  to express a preference between two defaults. assume that we have an ordered default theory. the exact details are given in the next section; for the time being assume that we have a triple  d  w      where d is a set of default rules  w a set of formulas  and   is a strict partial order on the default rules in d. 
　informally a higher-ranked default should be applied or considered before a lower-ranked default. but what exactly does this mean  consider for example the defaults concerning primary means of locomotion:  animals normally walk    birds normally fly    penguins normally swim : 

if we learn that some thing is penguin  and so a bird and animal   then we would want to apply the highest-ranked default  if possible  and only the highest-ranked default. significantly  if the penguins-swim default is blocked  say the penguin in question has a fear of water  we don't try to apply the next default to see if it might fly. this then is standard inheritance of default properties. 
　the situation is very different in the next example. we have the defaults that  canadians speak english by default     quebecois speak french by default    residents of the north of quebec speak cree by default : 

now if a resident of the north of quebec didn't speak cree  it would be reasonable to assume that that person spoke french  and if they didn't speak french  then english. 
assume that we have a chain of defaults 
　 informally  we have the following possibilities with respect to how the defaults may be applied. 
1  default logic is introduced shortly. 
pi for the maximum i for which si is applicable  and for j   1  no si+j is denied 1 apply si if possible.  no other default is considered. this is the situation in  1 . 
p1 apply sm if possible; apply sm-i if possible  continue in this fashion until no more than k  for fixed k where 1   k   m  defaults have been applied. this is the situation in  1  with k = 1. 
an example of a general instance of p1 is where a student wishes to take k = 1 computing courses  out of m = 1 possible courses  and so provides a list of preferences over the courses. there are two important subcases of p1 corresponding to k = 1 and ib = m. in the first case a maximum of one default is applied. in the second case one attempts to apply every default. 
　pi is essentially  default property  inheritance. the ordering on defaults reflects a relation of specificity; one attempts to apply the most specific default possible. in approaches such as  touretzky et a/.  1; pearl  1; geffner & pearl  1  specificity is determined implicitly  emerging as a property of the underlying system. 
 reiter & criscuolo  1; etherington & reiter  1; delgrande & schaub  1  have addressed adding specificity information in default logic. for incorporating preferences  as given in p1    boutilier  1; brewka  1a; baader & hollunder  1  consider adding preferences in default logic while  mccarthy  1; lifschitz  1; grosof  1  do the same in circumscription. we note however that some of these latter papers include examples best interpreted as dealing with specificity  as given in  1    and so would appear to conflate pi and p1. 
　our concerns in this paper are with specifying preferences and priorities  as given in p1. we assume only that we are given a set of defaults and a priority policy on defaults  along with other world knowledge. we observe that the framework as given in p1 is significantly more general that that of p i . for example it seems to be an intrinsic property of inheritance as given in p1 that the ordering on defaults is determined by relative specificity of the prerequisites. so if s1   s1 then the antecedent of s1 is less specific than the antecedent of s1. this is not the case for p1 though. consider a variation on  1  where in the north of quebec the first language is french  then english  then cree: the resulting preference ordering is as follows. 
	delgrande & schaub 	1 


1 	automated reasoning 

	delgrande & schaub 	1 

1 	automated reasoning 

　we note that theorem 1 and theorem 1 carry over to the general case except for theorem 1.1. we get instead 
in fact  ordered default theories are treated in the same way by our basic and general approach  except for different augmented languages: 
　given theorems 1 and 1  one would expect that ordered default theories would enjoy the same properties as standard default logic. this indeed is the case  but with one important exception: normal ordered default theories do not guarantee the existence of extensions. for example  the image of the ordered default theory 
 under our translation  
this preference by default only. second is to recognise that  1  is  buggy   in the same way that incorrect programs require modification. the lack of extension then indicates a problem in the specification of the original theory. 
　we conclude this section with the observation that our translation results in a manageable increase in the size of the default theory. for ordered theory  d  w   the 
we have presented a very general framework for incorporating preferences into default logic. via the naming of defaults we allow preferences to appear arbitrarily in d and w in a default theory. this allows preferences among preferences  preferences by default  preferences holding only in certain contexts  and so on. strictly speaking  such generality isn't required:  doyle k wellman  1   building on work by arrow  argue that in any preference-based default theory  for coherence  one requires a  dictator  to adjudicate preferences. that is  there must be  essentially  some way of determining a unique  complete  priority ordering. so in this sense  all one needs is what we have called the rigid approach of section 1. we provide the more general framework of section 1 for two reasons. first  it allows the more flexible specification of preferences  leaving it up to the user to ensure that there is no ambiguity in preferences. 
ically obtains multiple extensions. second  we feel that the general approach is of technical interest: arbitrary defaults may be  compiled  into standard default theories  and so in a certain sense the explicit representation of priorities adds nothing to the fundamental power or expressibility of default logic. 
　of other work in default logic treating preferences  we have argued that  reiter k criscuolo  1; etherington k reiter  1; delgrande k schaub  1  treat a separate problem  that of specificity orderings  as exemplified by  1 .  baader k hollunder  1  and  brewka  1a  present prioritised variants of default logic in which the iterative specification of an extension is modified. in brief  a default is only applicable at an iteration step  cf. definition 1  if no  -greater default is applicable.1 in contrast we translate priorities into standard default theories. there is insufficient space to fully compare approaches; see  delgrande k schaub  1  for a full discussion of these approaches with regard to how they address specificity in a theory. 
	delgrande & schaub 	1 

