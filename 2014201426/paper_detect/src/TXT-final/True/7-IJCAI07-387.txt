
thomsen's ¦Ë search and nagai's depth-first proofnumber  dfpn  search are two powerful but very different and/or tree search algorithms. lambda depth-first proof number search  ldfpn  is a novel algorithm that combines ideas from both algorithms. ¦Ë search can dramatically reduce a search space by finding different levels of threat sequences. dfpn employs the notion of proof and disproof numbers to expand nodes expected to be easiest to prove or disprove. the method was shown to be effective for many games. integrating ¦Ë order with proof and disproof numbers enables ldfpn to select moves more effectively  while preserving the efficiency of dfpn. ldfpn has been implemented for capturing problems in go and is shown to be more efficient than dfpn and more robust than an algorithm based on classical ¦Ë search.
1 introduction
many search methods have been developed to solve complex and/or trees  as occur in games. the direction of search can be controlled in an ad hoc manner by domainspecific knowledge. domain-independent best-first  nonuniform tree expansion techniques are a more principled approach. research in this area has produced two families of algorithms: in the first family of algorithms based on proof and disproof numbers  allis  1; nagai  1; kishimoto and mu¡§ller  1   search is controlled through the combined estimated difficulty of solving sets of frontier nodes that must be  dis- proven in order to  dis- prove the root. the second family of algorithms utilizes null  pass  moves  donninger  1  for finding threats to achieve a goal  thomsen  1; cazenave  1 . search proceeds in a statically determined fashion from simpler to more complex threats. both families of algorithms can be viewed as simplest-first search paradigms  for different definitions of what constitutes a simple search. however  neither notion of simplicity matches the ideal one  which is to find a  dis- proof as quickly as possible. for example  in the case of threat-based algorithms  a proof containing long series of simple threats is inferior to one with a small number of more complex threats. in the case of proof-number based algorithms  overestimation of proof and disproof numbers delays the search of nodes that look unpromising but can be easily solved.
¡¡this paper studies a combined approach  which utilizes proof numbers to control the effort put into search based on different threats. in this manner  the most promising threat types to use in different parts of a search tree can be selected at runtime. the contributions include:
  the lambda depth-first proof-number  ldfpn  search algorithm synthesizing depth-first proof-number search  nagai  1  and ¦Ë search  thomsen  1 .
  experimental results for capturing problems in the game of go demonstrating that ldfpn outperforms dfpn with state of the art enhancements and is more robust than classical ¦Ë search.
¡¡the rest of this paper is organized as follows: section 1 summarizes the rules of go. section 1 describes related work. section 1 introduces the ldfpn algorithm. section 1 discusses experimental results  and section 1 concludes and outlines further research directions.
1 the game of go
the game of go is a two person zero sum perfect information game. it originated in china and is most popular in east asia. players take turns to place stones on the intersections of a grid. the first player uses black stones and the second player uses white stones. a stone placed on the board stays in its position unless the opponent captures and removes it. the aim of the game is to surround more territory than the opponent. an example of a terminal position in go on a 1¡Á1 board is shown in the left of figure 1.
¡¡one of the few rules of go is about capturing stones. a set of directly connected stones of the same color is called a block. stones connect vertically and horizontally  not diagonally. empty intersections directly adjacent to a block are called liberties. a player can capture an opponent block by playing on its last liberty.
¡¡a capturing problem in go is the following decision problem: given a block b in a go position p and a player to play first  can b be captured assuming best play by both  the player owning b is called the defender  the opponent is the attacker.
¡¡a block with only one liberty is said to be in atari. a ladder is a special capturing problem where the attacker uses a sequence of ataris. a successful ladder is shown in the right of figure 1. for more information about go  please refer to http://www.usgo.org/

figure 1: example of a terminal position in go  and a ladder
1 related work
1 threats  threat-based search and ¦Ë search
threats can be used to direct and focusing search. a position with many threats is usually good for the attacker  while an absence of threats indicates that no quick success can be expected. if a player has a threat to win  it is worth investigating it with high priority. threats severely restrict the opponent's choice of replies to moves that can avert the threat  and often lead to further follow-up threats.
¡¡threats can be found by using null moves. intuitively  a threat is a move that  if ignored  leads to a quick win. in the ladder example in figure 1  each black move is a threat to capture  and white has only one possible move to avert that threat.
¡¡the threat-based approach of  allis et al.  1 was generalized to ¦Ë search  thomsen  1  and further by cazenave . while this paper concentrates on a comparison with ¦Ë search  its ideas should apply to threat-based methods in general.
¡¡the basic concept of ¦Ë search is the ¦Ë order  a measure of how fast a player can achieve a goal  or in other words  the directness of a threat. ¦Ë search creates ¦Ën-trees consisting of ¦Ën-moves  which are recursively defined as follows: a successful ¦Ë1-tree for the attacker  denoted by ¦Ë1 = 1  consists of a single attacker move that achieves the goal directly. a ¦Ë1-move is such a winning attacker move.
¡¡an attacker win by an order n threat is denoted by ¦Ën = 1  while ¦Ën = 1 indicates that the attacker cannot achieve the goal by order n threats. a ¦Ën-tree is a search tree which consists of ¦Ën-moves. if there is no ¦Ën-move for a node  that node is terminal and a loss for the player to move. the definition of ¦Ën-moves is as follows.
definition 1  thomsen  1  a ¦Ëna-move is an attacker move such that if the defender passes in reply  there exists a ¦Ëi-tree with ¦Ëi = 1  1 ¡Ü i ¡Ü n   1 . the attacker threatens to win within a ¦Ë order of less than n.
definition 1  thomsen  1  a ¦Ënd-move is a defender move such that after the move  there is no subsequent ¦Ëi-tree with ¦Ëi = 1  1 ¡Ü i ¡Ü n   1 . the defender move averts all lower order attacker threats.
¡¡for example  in the capturing problem  a ¦Ë1-move occupies the last liberty of the target block and captures it. attacker's moves are moves for capturing the target stones in a ladder or directly  while defender's ¦Ëd1 moves are moves preventing a direct capture. attacker's moves threaten to capture the target in a ladder or directly.
¡¡the underlying concept of ¦Ë search is that ¦Ën moves are defined by ¦Ën 1 searches  and the size of a ¦Ën 1 tree is expected to be far smaller than a ¦Ën tree. therefore ¦Ë search can prune moves according to the ¦Ë order with little effort. ¦Ë search is especially efficient for problems for which ¦Ë order is meaningful. capturing problems in go are an ideal case  because lower bounds on the ¦Ë order can be derived from game specific knowledge  the number of liberties of a block  thomsen  1 .
¡¡two simple dominance relations hold for the value of ¦Ë trees.
if	¦Ën = 1then	¦Ëi = 1	 n ¡Ü i  1 if¦Ën = 1	then¦Ëj = 1	 1 ¡Ü j ¡Ü n  1 ¡¡a positive result of a ¦Ë search  ¦Ën = 1  is correct provided that pass is allowed or zugzwang is not a motive in a game. a negative search result  ¦Ën = 1  means that either there is no solution  or a solution will be found at a higher order
1 proof-number search variants
in an and/or tree  let a proof be a win for the first player  corresponding to an or node  and a disproof a win for the opponent  represented by an and node .  allis et al.  1  introduced proof and disproof numbers as an estimate of the difficulty to find proofs and disproofs in a partially expanded and/or tree. the proofnumberof node n  pn n   is defined as the minimum number of leaf nodes that must be proven in orderto find a proofforn  while the disproofnumberdn n  is the minimum number of leaf nodes to disprove for a disproof for n. pn n  = 1 and dn n  = ¡Þ for a proven terminal node n  and pn n  = ¡Þ and dn n  = 1 for a disproven terminal node. pn n  = dn n  = 1 is assigned to any unproven leaf. let n1 ¡¤¡¤¡¤ nk be children of interior node n. proof and disproof numbers of an or node n are:
.
for an and node n proof and disproof numbers are:
.
figure 1 shows the calculation.
¡¡proof-number search  pns  is a best-first search algorithm that maintains proof and disproof numbers for each node. pns finds a leaf node from the root by selecting a child with smallest proof number at each or node and one with smallest

figure 1: calculation of proof/disproof numbers
disproof number at each and node. it then expands that leaf and updates all affected proof and disproof numbers along the path back to the root. this process continues until it finds either a proof or disproof for the root.
¡¡depth-first proof-number  dfpn  search  nagai  1  is a depth-first reformulation of pns which re-expands fewer interior nodes and can run in space limited by the size of the transposition table. thresholds for proof and disproof numbers are gradually incremented and used to limit a depth-first search  similar to recursive best-first search  korf  1 .
¡¡dfpn has been a very successful search method  and is used in the best tsume-shogi solver  nagai  1   the best tsume-go solver  kishimoto and mu¡§ller  1   and a backend prover for solving checkers  schaeffer et al.  1 . yoshizoe  presented a dfpn-based solver for the capturing problem in go to find an inversion  a set of points on which a move possibly changes the outcome of a search. the dual lambda search algorithm  soeda et al.  1  tracks threats by both players in the mutual king attack typical of shogi endgames.  soeda  1  develops a family of algorithms closely related to our work and applies them to the japanese game of shogi.
1 the ldfpn search algorithm
1 details of ldfpn
ldfpn is a proof number based ¦Ë search. proof/disproof numbers for and/or nodes are initialized and propagated as in dfpn. however  each attacker node is split into several pseudo nodes corresponding to different ¦Ë orders 1 ¡¤¡¤¡¤ l  and search dynamically selects the most promising ¦Ë order to pursue at each node.
¡¡an attacker node n is shown at the top of figure 1. it is divided into pseudo nodes of different ¦Ë orders up to a limit of l = 1 in the example. each pseudo node corresponds to a subtree with different ¦Ë order. let n be part of a ¦Ël tree  and c1 ¡¤¡¤¡¤ cl the pseudo nodes of n. the attacker wants to prove that ¦Ël = 1. by the dominance relation of equation  1   the attacker need only prove any one of the pseudo nodes. however  disproving any lower order ¦Ë tree is no help for disproving the ¦Ël tree as in equation  1 . therefore  the disproof number of attacker's node n is the same as for cl.
¡¡formally the proofand disproofnumbersof attacker's node n are calculated as follows:
.
¡¡a defender node n is shown in the bottom of figure 1. defender's aim is to disprove this node by showing ¦Ël = 1. by equation  1   proofs of lower order ¦Ë subtrees are irrelevant

figure 1: attacker's node and defender's node
for the proof of n. the proof of the highest ¦Ë order subtree is the only valid proof. however  a ¦Ël 1 subtree is searched for the exceptional case of a pass move. in the bottom of this figure  if the attacker cannot win by ¦Ë order1 after a defender pass  then the attacker was not threatening to win by ¦Ë order 1 and according to the definition cannot win by ¦Ë order 1. from the attacker's point of view  the purpose for searching this pseudo node cl 1 is to check if the attacker's previous move m  which lead to node n  was a  move or not. if ¦Ël 1 = 1 is proven  the search can immediately return to the parent of n. since a ¦Ël 1 subtree is typically smaller than a ¦Ël subtree  the search for cl 1 will often finish quickly.
¡¡the defender  looking for a disproof at and node n  can choose between the most promising move in the ¦Ël tree and a pass move that searches a ¦Ël 1-tree. therefore  the proof and disproof numbers of a defender node n are calculated by: pn n  = pn cl   dn n  = min dn cl 1  dn cl  .
¡¡like dfpn  ldfpn uses two thresholds for proof and disproof numbers. ldfpn selects the leaf node with the smallest proof/disproof number  regardless of the ¦Ë order.
¡¡the main advantage of ldfpn over classical ¦Ë search is the ability of ldfpn to seamlessly switch between different ¦Ë order child nodes. there is no need to wait for a proof or disproof of all lower ¦Ë order subtrees. since disproofs are often more difficult than proofs  this ability to skip a difficult disproof of a ¦Ën 1 subtree and start search of a ¦Ën subtree improves the search behavior.
1 search enhancements
heuristic initialization of proof and disproof numbers
the basic dfpn algorithm initializes proof and disproof numbers of an unproven leaf node to 1. as in  allis  1;

figure 1: sample test problem  black to play 
nagai  1   one way to enhance performance of ldfpn is to heuristically initialize these numbers. let hpn n  and hdn n  be evaluation functions to initialize the proof and disproof number of leaf n. in ldfpn  hpn n  and hdn n  are defined as functions of the ¦Ë order of n  to reflect the property that a node with lower ¦Ë order should be searched with a higher priority  see section 1 for details . dfpn with this enhancement is called dfpn+ in  nagai  1 .
ladder search
a ¦Ë1 search for capturing problems of go is the same as a ladder search  shown in figure 1. this search is exceptionally easy  since the number of move candidates is very small  1 or 1 in most cases . in the implementation reported here  a special purpose ladder search is 1 times faster in terms of nodes per second than ldfpn. it can be used as a subroutine by ldfpn.
simulation
kawano's simulation  kawano  1  saves search time by reusing the proof tree of similar board positions. if a board position a was  dis- proven  a similar board position b is likely to be  dis- proven by the same  dis- proof tree.
¡¡ldfpn uses simulation only for pass moves at and nodes. a pass move is searched at and nodes  and if it results in a loss  its sibling nodes are checked using the disproof tree of the pass move. in this way  irrelevant moves which do not help the player can be disproven quickly.
1 experimental results
1 setup of experiments
the test suite consists of 1 capturing problems  including 1 from  mas  1  and 1 modified ones. while the original problems all have a winning solution  the modified problems test the case where the first player loses. a typical example is shown in figure 1. the attacker black must capture the crucial white stones marked by triangles to save the black stones marked by squares. the correct answer is marked with a cross.
¡¡each problem was searched in two ways: first to capture the stones marked with triangles  and second to defend the stones marked with squares. some problems contained 1 blocks to be defended  and in some others  there were 1 blocks to be captured. counting these as separate problems yields a total of 1 test problems.
the following three algorithms were tested:
  ldfpn: the ldfpn algorithm described in section 1 with the highest ¦Ë order of 1. several methods for initializing proof and disproof numbers were tested to tune hpn and hdn. as a result  hpn and hdn for a node n with ¦Ë order ¦Ë are defined as follows:
	hpn n  = hdn n  = max 1¦Ë 1 	 1 ¡Ü ¦Ë ¡Ü 1 .
  dfpn+: the dfpn algorithm with heuristic initialization. hpn and hdn use go-specific knowledge  the distance to a target block. to allow a fair comparison  state of the art enhancements are incorporated into the implementation of the dfpn+ algorithm  such as techniques from  kishimoto and mu¡§ller  1; 1  and kawano's simulation  kawano  1 .
  pseudo ¦Ë search: thomsen's original ¦Ë search uses an alpha-beta framework. for better comparison with ldfpn  pseudo ¦Ë search uses ldfpn with special parameter settings that mimic the search strategy of ¦Ë search  which expands trees strictly in increasing order of ¦Ë. a similar effect is achieved in ldfpn by letting the heuristic initialization grow very quickly with ¦Ë:
	hpn n  = hdn n  = max 1¦Ë 1 	 1 ¡Ü ¦Ë ¡Ü 1 .
¡¡since the capturing problems tested are in open-ended areas  it is hard to restrict move generation and achieve provably correct results. in practice  most computer go programs heuristically limit moves for their capture search engines and regard a block with a large enough number of liberties as escaped. three types of move generators were tested: not only to generate all legal moves and also to accurately assess the life and death status.
  heuristic generator: generates moves on the liberties of surround blocks  thomsen  1   and of blocks near the target block. it also generates some more moves including the 1nd liberties of the target block.
  heuristic+ generator: generates moves by the heuristic generator plus on all their adjacent points.
  full board generator: all legal moves are generated.
¡¡for dfpn+  a liberty threshold to regard the block as escaped is passed as a parameter. ldfpn uses the failure of a search with the preset maximum ¦Ë order 1 to determine whether a target block has escaped. for dfpn+  the number of liberties of the target block was used as the threshold. ldfpn with maximum ¦Ë order of l evaluates a block with l+1 or more liberties as escaped. a liberty threshold of l+1 for dfpn+ is roughly comparable to a ldfpn search with maximum order l.
¡¡the parameters given to ldfpn are the target blocks to capture/defend  and the ¦Ë order.
¡¡a test case was considered solved  if the move returned was the solution given in  mas  1 .
¡¡experiments were performed on an opteron 1 at 1 ghz with a node limit of 1 million nodes per test position and a 1 mb transposition table.
-ldfpndfpn+pseudo ¦Ëheuristic: num solved11heuristic+: num solved11full board: num solved11table 1: number of problems solved by each move generator.
1 ldfpn versus dfpn+
table 1 summarizes the number of problems solved by ldfpn and dfpn+ with the three move generators. ldfpn solved more problems than dfpn+ in each case. the difference is largest for the full board move generator. this is not surprising  because threats based on the ¦Ë orders can drive ldfpn to focus on searching moves near the target block of the defender.
¡¡figure 1 compares the performanceof ldfpn and dfpn+ for each problem solved by both algorithms with the three move generators. in this figure  the execution time of ldfpn was plotted on the horizontal axis against dfpn+ on the vertical axis on logarithmic scales. a point above y = x indicates that ldfpn performed better. ldfpn outperforms dfpn+ for all three generators  with the largest differencefor the full board move generator  showing the clear advantage of ldfpn on pruning irrelevant moves.
¡¡the example shown on the left in figure 1 is solved faster by ldfpn. with the  heuristic  move generator  ldfpn searched 1 nodes to solve this problem in 1 seconds  while dfpn+ searched 1 nodes in 1 seconds. in this problem  black has to sacrifice 1 stones to win. if stones are captured  there are more empty points in a position  i.e. the points where the stones used to be placed   resulting in an increase in the number of legal moves. this increases the proof number of a node in dfpn+  which should have been easily proven. dfpn+ delays searching such a node with an apparently large proof number. ldfpn tends to search with a smaller set of moves based on the ¦Ë order  and this effect occurs less frequently and is less severe than with dfpn+.
¡¡one disadvantage of ldfpn is that it occasionally has to visit the same nodes in different ¦Ë orders. if the additional information of ¦Ë order is not effective  the advantageof ldfpn disappears. in particular  if the number of possible moves is small  dfpn+ works well.
¡¡the right position in figure 1 shows an example that dfpn+ solved more quickly than ldfpn. the answer is marked with a cross in this figure. with the  heuristic  move generator  ldfpn searched 1 nodes to solve the problem in 1 seconds  and dfpn+ searched 1 nodes in 1 seconds. this is a typical problem  in which ¦Ë order has a negative effect. both players have several suicidal moves with low ¦Ë orders. ldfpn therefore tends to search to disprove all suicidal moves before trying to prove the correct move. in dfpn+  the suicidal moves result in captures of non-target blocks  leading to larger proof numbers for these moves. dfpn+ therefore delays searching these suicidal moves and expands the correct move earlier.

	 1 1	 1	 1	 1	 1	 1
         ldfpn with sim h ladder  sec   a  heuristic generator

	 1 1	 1	 1	 1	 1	 1
¡¡¡¡¡¡¡¡¡¡ldfpn with sim h ladder  sec   b  heuristic+ generator

	 1 1	 1	 1	 1	 1	 1
ldfpn with sim h ladder  sec 
 c  full board generator
figure 1: ldfpn with ladder vs dfpn+

	ldfpn was faster	dfpn+ was faster
figure 1:	problems which ldfpn solved faster/slower.
 black to play 
1 ldfpn versus pseudo ¦Ë search
table 1 also compares the number of problems solved by ldfpn and pseudo ¦Ë search. for all types of move generators  ldfpn solved more problems than pseudo ¦Ë search.
¡¡this comparison shows that ldfpn is slightly more robust than pseudo ¦Ë search.
1 conclusions and future work
this paper investigated an approach to combine proof number based search and threat based search. results on applying ldfpn to the capturing problem are very promising. in particular  if the move generator generates a larger set of moves  ldfpn outperforms dfpn+ by a large margin with more robustness than the classical ¦Ë-search based approach. since using a larger set of moves can improve the accuracy of solving the capturing problem  ldfpn can be a good choice for solving tactical problems in go.
¡¡there are many topics to pursue for future work. first of all  the method should be explored for other domains  such as hex. hpn and hdn of ldfpn can clearly include domain dependent knowledge to enhance performance as in dfpn+. the right balance of domain-dependent knowledge and ¦Ë order in hpn and hdn must be investigated. additionally  since ldfpn can compute the ¦Ë-order of a goal  it can be applied to domains with more than one goal  in order to measure which of several goals can be achieved the fastest. work is in progress on a semeai solver in go  because this problem often involves multiple goals. finally  integrating ldfpn with a complete go-playing program will be an important topic to improve the strength of the programs.
acknowledgments
this research was supported by the natural sciences and engineering research council of canada  nserc  and alberta's informatics circle of research excellence  icore .
