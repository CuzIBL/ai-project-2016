
in finding all solutions to a constraint satisfaction problem  or proving that there are none  with a search algorithm that backtracks chronologically and forms k-way branches  the order in which the values are assigned is immaterial. however  we show that if the values of a variable are assigned instead via a sequence of binary choice points  and the removal of the value just tried from the domain of the variable is propagated before another value is selected  the value ordering can affect the search effort. we show that this depends on the problem constraints; for some types of constraints  we show that the savings in search effort can be significant  given a good value ordering.
1 introduction
it is well-known that the order in which variables are instantiated can make an enormous difference to the search effort in solving a constraint satisfaction problem  whether just one solution is required  or all solutions. however  value ordering is relatively neglected  partly because no cheap general-purpose value ordering heuristics are known  and partly because it has been accepted that value ordering is not important if all solutions are required  or there is no solution.
　frost and dechter  showed that  with backjumping  the value ordering can have an effect on the search for all solutions  but say:  with backtrackingthe order in which values are chosen makes no difference on problems which have no solution  or when searching for all solutions.  their argument is that when a node corresponding to a variable is created in the search tree  the children correspond to the values of that variable  and that the subtrees rooted at the children nodes are explored independently. to find all solutions  or to prove that there are none  every subtree must be explored  and the order makes no difference to the overall search.
　this argument assumes that the search tree is formed by k-way branching  mitchell  1   i.e. when a variable with k values in its domain is selected for instantiation  k branches are formed. constraint solvers such as ilog solver and eclipse by default use a search strategy similar to the mac algorithm  sabin and freuder  1   and in particular use 1-way  or binary  branching. when a variable x is selected for instantiation  its values are assigned via a sequence of binary choices. if the values are assigned in the order {v1 v1 ... vk}  the first choice point creates two alternatives . the first  the left branch  is explored; if that branch fails  or if all solutions are required  the search backtracks to the choice point  and the right branch is followed instead. crucially  the constraint is propagated  beforea second choice point is created between x = v1 and  and so on.  the mac algorithm also allows the possibility that on backtracking after trying x = v1  a different variable could be assigned next  not just a different value: that possibility is not considered here. 
　with binary branching  the subtrees resulting from successive assignments to a variableare not exploredindependently: propagatingthe removal of a value from the current variable's domain on the right branch can lead to further domain reductions. this propagation can affect the search when future values of the variable are considered: indeed  sometimes a future value can be removed from the domain. hence  the order in which the values are assigned can affect the search.
　 smith  1  gives an example of the value ordering affecting the search to find all solutions. here  we present a more extensive investigation and explain how value ordering can affect search effort. we show that  depending on the problem constraints  the saving in search effort over k-way branching can be around 1%  given a good value ordering.
1 search trees for a golomb ruler problem
first  we examine in detail the effect of the value ordering when findingall solutions  using a variantof the golombruler problem prob1in csplib . a golomb ruler with m marks may be defined as a set of m integers 1 = x1   x1   ...   xm 1  such that the＋ m   1  are distinct. the length of the ruler ism m   1 /1 differences xj   xxi m1 ＋1  i   j
and the objective is to find a minimum length ruler. modeling the problem is discussed in  smith et al.  1 .
to create a problem with no solution  we set  1  where minl is the minimum possible length. thexm 1 =
minl
model is chosen so that the search trees  using ilog solver's default binary branching  for one instance of the problem are small enough to display  while the value ordering makes a significant difference to the number of backtracks.
　the chosen model is not the quickest way to solve the problem  since it does expensive constraint propagation in order to reduce search. auxiliary variables represent the m m   1 /1 differences between the marks on the ruler  defined by di j = xj   xi  where i   j; generalized arc consistency  gac  is enforced on these ternary constraints using ilog solver's table constraints. we also enforce gac on the alldifferent constraint on the difference variables. since xi is the sum of i difference variables  its minimum value is set to be the sum of the first i integers. similarly  the length xm 1 i to xm 1 is at least the sum of the first i integers  and this reduces the maximum value of xm 1 i. we add the constraint d1   dm 1 m 1 to break the reflection symmetry.
　the search variables are x1 x1 ... xm 1  assigned in that order. we compare two value ordering heuristics; choosing either the smallest value in the domain  or the largest. choosing the largest value would not be a sensible strategy for finding a minimum length golomb ruler  since the length is not known in advance  but here it shows the effect on search of changing the value ordering.
　figure 1 shows the search trees resulting from proving that there is no 1-mark golomb ruler with length 1  with the two selected value orderings. the difference is striking  given the conventional view that the value ordering only reorders the search  and does not affect the overall search effort.
　the black circles show where a failure is detected and the search backtracks. when values are assigned in increasing order  on backtrackingto take the right branchthe domain of the variable can sometimes be reduced  or eliminated altogether. we examine a case in detail. initial constraint propagation reduces the domains of the search variables to x1 : 1; x1 : {1..1}; x1 : {1..1}; x1 : {1..1}; x1: {1..1}; x1 : 1. on backtracking from x1 = 1  the right branch has x1 （ {1..1}. constraint propagation reduces this to x1 = 1: there are 1 pairwise differences between the marks in this instance  excluding d1  which has already been assigned  and just 1 possible values for these differences  from 1 to 1. if  then x1 ＋ 1  because of the symmetry constraint. hence  the value 1 can only be assigned to the difference x1   x1  which means that x1 = 1. enforcing gac on the alldifferent constraint on the difference variables makes this inference  and the branch x1 （ {1..1} is not considered further. on the other hand  when values are assigned in decreasing order  the domain of x1 on the right branch always contains the value 1  and the alldifferent constraint is already gac.
increasingdecreasingk-waynorderorderbranching1111111 1 1 11111 1 1 1table 1: number of backtracks to prove that there is no golomb ruler with n marks of length minl  1  where minl is the minimum possible length  using binary branching with increasing or decreasing value ordering  or k-way branching.
table 1 gives the results for larger instances of the same

figure 1: search trees formed in proving that there is no golomb ruler with 1 marks of length 1  using  top  decreasing value order and  bottom  increasing value order.
problem  and also shows the effect of using an implementation of k-way branching in ilog solver. k-way branching nearly doubles the number of backtracks compared with binary branching using increasing value order. although decreasing order is much worse than increasing order  it still allows significantly less search than k-way branching for the larger instances.
　the runtimes for k-way branching are usually shorter than for binary branching with decreasing value ordering  even when the search tree is larger. for n = 1  k-way branching takes 1 sec.  on a 1mhz celeron pc   compared to 1 sec. for binary branching with decreasing value ordering. with increasing value ordering  binary branching is significantly faster  1 sec. .
　the explanation given earlier for the immediate failure of the right branch at the choice point between x1 = 1 and x1 （ {1..1} depends on the global alldifferent constraint.
however  even if the alldifferent constraint is treated as a clique of binary = constraints and the constraints di j = xj   xi are not made gac  choosing the smallest value in the domain requires fewer backtracks to prove insolubility than choosing the largest value. the crucial constraints ared1x 1 d m1x m1   ...  1  which is equivalent toxm 1 and the symmetry constraintx1   1   x1 in the example analysed. with monotonic binary constraints such as these  the removal of the largest or smallest value in the domain of one of the variables can reduce the domain of the other  and removing any other value has no effect  van hentenryck et al.  1 . given a constraint x   y with x assigned before y  trying the values of x in increasing order means that on backtracking  the smallest value in the domain of x is removed on the right branch and this removal in turn reduces the domain of y. since the variables are assigned in lexicographic order in this case  this explains why assigning the values in increasing order has the largest effect on the search.
1 graceful labeling of a graph
in this section  we considerfurtherthe effect of value ordering when there are monotonic constraints  and the interaction of the variable ordering and the value ordering.
　the problem is that of determining all graceful labelings of the graph shown in figure 1. a labeling f of the nodes of a graph with q edges is graceful if f assigns each node a unique label from {1 ... q} and when each edge xy is labeled with |f x    f y |  the edge labels are all different.
　a possible csp model has a variable for each node  x1 x1 ... xn  each with domain {1  ...  q} and a variable for each edge  d1 d1 ... dq  each with domain {1 ... q}. the constraints are: if edge k joins nodes i and j then dk = |xi   xj|; x1 x1 ... xn are all different  as are d1 d1 ... dq. since the edge variables must be assigned a permutation of the values 1 to q  it is worthwhile to enforce gac on the alldifferent constraint. the alldifferent constraint on the node variables is looser  1 variables and 1 possible values in the example of figure 1  and this is expressed by = constraints. the search variables are x1 x1 ... xn.

figure 1: a graph that can be gracefully labeled. the node numbers correspond to the variables of the csp.
　symmetrically equivalent solutions can be eliminated by adding constraints to the model  petrie and smith  1 .
  x1   1  to eliminate the complement symmetry  i.e. the symmetry that replaces every value v by q   v .
  x1   x1; x1   x1; x1   x1  to eliminate rotations and reflections in the cycle consisting of nodes 1  1  1  1 .
  x1   x1; x1   x1; x1   x1  to eliminate symmetry in the cycle consisting of nodes 1  1  1  1 .
  x1   x1  to prevent interchanging the two cycles .
what propagation can follow from the removal of a value from the domain of a variable in this case  the  binary  symmetry constraints are monotonic and so a value removal will propagate as in the golomb rulers problem. given a clique of = constraints  as on the node variables  removing a value from the domain of a variable does not affect the other variables. however  if there is a global alldifferent constraint  as on the edge variables  removing a value may affect other domains; for instance  if there are only as manyvalues as variables and a value occurs in the domain of only two variables  removing it from the domain of one means that it must be assigned to the other. however  the immediate effect on the search variables  the node variables  is limited  since gac is not maintained on the ternary constraints linking the edge and node variables.
　we have tried several differentvariableorders forthis problem. in each case  if binary branching is used with a value ordering that chooses a value from the middle of the domain  it takes the same number of backtracks to find all solutions as k-way branching. however  if the value chosen is either the smallest or the largest in the domain  binary branching takes fewer backtracks than k-way branching. this suggests that the reduction in search is mainly due to the symmetry constraints: any propagation due to the other constraints would not be restricted to the largest and smallest value in the domain.
　table 1 shows the results of solving this problem with different variable and value orders. as well as lexicographicand reverse lexicographic variable order  we use the orders that we found to be respectively best and worst  when assigning the values in increasing order  sturdy  1 .  incidentally  the comparison also demonstrates that the value order cannot compensate for a poor variable order in finding all solutions. 
　it is not necessary to use the same order  increasing or decreasing  for all variables. the rightmost columns in table 1 give the results for a heuristic that  for most variable orders  assigns the values of x1 and x1 in increasing order  and those of the other variables in decreasing order. however  if x1 comes after x1  x1 and x1 and before x1 in the variable ordering  it is assigned in decreasing order  and if x1 comes after x1 to x1 in the variable order  it is assigned in decreasing order.  hence  when the variables are assigned in reverse lexicographicorder  decreasing order for all variables is best.  table 1 shows that the heuristic is at least as good as the better of increasing or decreasing order in all cases  and this was true for the other variable orders that we tried.
variable orderk-wayincreasingdecreasingheuristicbranchingorderorderbt.sec.bt.sec.bt.sec.bt.sec.x1 x1 x1 x1 x1 x1 x1 x1 x111.111.1x1 x1 x1 x1 x1 x1 x1 x1 x111.111.1x1 x1 x1 x1 x1 x1 x1 x1 x111.111.1x1 x1 x1 x1 x1 x1 x1 x1 x111.111.1table 1: finding all graceful labelings of the graph in figure 1  with k-way branching or binary branching with different value orderings.　the heuristic was derived empirically by trying increasing or decreasing order for each variable  with a range of variable orders. we found that the effect of changing the value order for a single variable does not depend on the value order chosen for the other variables  so that the best order  for a given variable order  can be chosen independentlyfor each variable. the heuristic can be related to the binary symmetry-breaking constraints: unless x1 and x1 are late in the variable order  assigning their values in ascending order will lead to reducing the domains of other variables on backtracking. the variables assigned in decreasing order are those that appear mainly on the right of   constraints; on backtracking  the largest value in the domain will be removed  and again this will reduce the domains of other variables.
1 langford's problem
in the previous examples  assigning values in either increasing or decreasing order reduces the search effort considerably  in comparison with k-way branching  because of the monotonic binary constraints in the problem. in this section  a problem with no monotonic constraints is discussed.
　langford's problem  prob1 in csplib  can be stated as follows:  a sequence of n 〜 m integers consists of the integers 1 to m each appearing n times. there is one integer between consecutive occurrences of the integer 1  two integers between consecutive occurrences of the integer 1  and so on. find all possible such sequences. 
　modeling this problem as a csp is discussed in  hnich et al.  1 . a possible model has nm variables  one for each location in the sequence; its value represents the integer at this location. thus  the value i of dj  1 ＋ j ＋ nm  is an integer in the interval  1 nm   representing the fact that occurrence  i div n +1 of the integer i mod n occurs at location j. for example  in the  1  instance  i.e. n =1  m = 1  d1 = 1 d1 = 1 d1 = 1 represent the 1st  1nd and 1rd occurrences of the integer 1 appearing in positions 1  1 and 1 of the sequence. a dual model of the problem has a variable xi 1 ＋ i ＋ nm  for each occurrence of each integer: its value is the position in the sequence of this occurrence. the problem can be viewed as a permutation problem: any valid sequence assigns a permutation of the nm possible values to the variables d1 d1 ... dnm. to ensure that any solution is a permutation of the values  both sets of variables are included in the model  with channeling constraints between them  i.e. di = j iff xj = i. we also add constraints to break the symmetry: given any solution  another can be found by reversing the sequence. we assign values to d1 d1 ... dnm in turn.
　a value ordering heuristic for this problem can be devised by considering how removing a value from the domain of a
　variable dj on backtracking will affect other variables. the removal will also remove a value from the domain of n   1 other variables; for example  in the  1  instance  if  then and. however  the values 1 and 1 are only assigned as a consequence of assigning the value 1  and these deletions will not lead to further propagation. the other possible propagation is from the channeling constraints: as discussed in  hnich et al.  1   if a value appears in the domain of only one dj variable  it will be assigned to that variable. hence  if there is a value that appears in the domains of the current variable and only one other search variable  it should be chosen: on backtracking  propagation will assign the value to the other variable.
　in  smith  1   dualsdf ordering was used  which chooses the value appearing in fewest domains  i.e. corresponding to the dual variable with smallest domain. dualsdf was shown to give better results than increasing value order  for finding all solutions. it will always choose a value appearing in the domain of only one other search variable  if there is one; hence  we can now explain its good performance. its anti-heuristic  dualldf  chooses the value correspondingto the dual variable with largest domain  and will not choose a value appearing in only two domains unless there is no alternative. whereas dualsdf can be expected to give as much search reduction as possible in finding all solutions  dualldf will rarely be able to reduce the domains of other variables on the right branch and so should be nearly as bad as k-way branching for this problem. the results in table 1 confirm this.
instancedualsdfdualldfk-way branching 1 11 1 11 1 11table 1: number of backtracks to find all solutions to three instances of langford's problem  using binary branching with different value orders  or k-way branching.
　hence  dualsdf reduces the search effort to find all solutions compared with k-way branching  and its good performance can be explained in relation to to the problem constraints. however  the reduction in search is much less than in the previous examples  and does not make binary branching cost-effective in terms of run-time.
1 symmetry breaking during search
we have shown that the effect of the value order on the search for all solutions depends on propagating the removal of the value just tried  on the right branch at binary choice points. in symmetry breaking during search  gent and smith  1   constraints to avoid assignments symmetric to those already considered are added dynamically during search  on the right branch. these additional constraints can reinforce the effect of the value order on search. we demonstrate this in the nqueens problem  whose symmetries are described in  gent and smith  1 .
　the basic program  from the ilog solver user manual  has a variable xi i = 1 ... n for each row of the board  representing the queen on that row  with a value for each column. there are three alldifferent constraints  representing that the queens are on different columns and on different diagonals in each of the two possible directions. sbds requires a specification of the effect of each symmetry on the assignment of a value to a variable. for instance  in the n-queens problem  the reflectionin the top-left to bottom-rightdiagonal  symmetry d1  transforms the assignment xi = j to xj = i. the first assignments made are x1 = 1 and x1 = 1  the
variable ordering heuristic chooses the variable with smallest domain  using the smallest value as a tie-breaker . on backtracking to take the alternative choice  d1 is the only symmetry remaining  given the assignment x1 = 1. sbds adds the symmetric equivalent of  to the right branch. both constraints  i.e.  are propagated before choosing another value.
　when using sbds to eliminate the symmetry in the nqueens problem  we compare four value ordering heuristics. first  we select values in increasing order  as a basis for comparison. second  we use a heuristic which seems likely to give most scope for the sbds constraints to prune the domains of future variables. it is not obvious how best to do this  but the value that attacks the most unattacked squares will free these squares on backtracking: it seems plausible that this will increase the likelihoodthat the sbds constraints remove one. the opposite heuristic  choosing the value that attacks fewest unattacked squares  is similar to the promise heuristic introduced by geelen ; hence  we call these two heuristics anti-promise and promise respectively. finally  we use dualsdf  as in langford's problem  taking into account that x1 ... xn must be assigned a permutation of the values 1 to n; in a permutation problem  a global alldifferent constraint does at least as much domain pruning as channeling constraints would do  when a value is removed from the domain of one of the variables  hnich et al.  1 .
　we first compare the four heuristics if the symmetry is not eliminated: the results are given in table 1. the effect of the value ordering then depends on how the alldifferent constraints are treated. if they are treated as cliques of binary = constraints  the value ordering can have no effect on the search effort. table 1 gives the results for k-way branching only  since the four binary branching heuristics give the same number of backtracks  though a marginally longer runtime.
　on the other hand  if the alldifferent constraints are treated as global constraints  dualsdf requires less search than k-way branching  and least search of the binary branching heuristics. however  the reduction in search  in comparison with k-way branching  is not great. overall  if the symmetry is not eliminated  k-way branching and = constraints give the fastest runtime. maintaining gac on the alldifferent constraints is time-consuming  especially when gac has to be re-established after each individual value for a variable has been tried  as in binary branching.
　table 1 compares the four heuristics when the symmetry in the problem is eliminated using sbds. we cannot com-
	=	constraintsk-waygac on alldifferent constraints k-waybranchingdualsdfbranchingnbt.sec.bt.sec.bt.sec.111.11111.11111.11111.11111.111	11.1	1table 1: number of backtracks  bt.  and runtime  on a 1ghz pentium m pc  to find all solutions to the n-queens problem  if symmetry is not eliminated.
increasinganti-norderpromisepromisedualsdf111111111111111111table 1: number of backtracks to find all non-isomorphic solutions to the n-queens problem  using different value ordering heuristics.
pare the heuristics with k-way branching in this case  because sbds depends on binary branching. anti-promise  intended to allow propagation of the sbds constraints to reduce search  is indeed the best of the four heuristics. dualsdf is often a rather poor second best  suggesting that the sbds constraints are more significant than the alldifferent constraints in allowingdomain reductionson the right branch. the experience with this problem class shows that it is possible to design value ordering heuristics for finding all solutions by considering the propagation of the constraints added on the right branch during search  whether the removal of the value just tried or sbds constraints. the differences in search effort are relatively small  however  and the runtimes for promise  anti-promise and dualsdf are very similar; increasing order is fastest  being simplest to implement.
　the original promise heuristic  geelen  1  was designed to find a first solution quickly  and it is worth noting that our version is much better than anti-promise in this respect. for n ＋ 1  promise can usuallyfind a first solutionin just a few backtracks  whereas anti-promise becomes increasingly successful at avoiding solutions. for instance  when n = 1  promise finds a solution in 1 backtracks  whereas anti-promise takes more than 1 million. however  promise is slightly worse than anti-promise for finding all solutions.
1 conclusions
mitchell  showed that binary branching can do much less search than k-way branching  due to the possibility that on backtracking to a choice point  the next assignment tried need not be another value  if there is one  of the same variable. in practice  this is not provided by default in solvers such as eclipse and ilog solver  although the user can implement such a search strategy  and sabin and freuder  allowed it in their description of the mac algorithm.
　we have shown that even when the search always assigns another value of the current variable on backtracking  binary branching offers another potential advantage. before another value is assigned  the removal of the value just tried from the domain of the variable is propagated. this can lead to further domain reductions  which can in turn mean that a future value of the current variable is pruned  or that the search when a future value is assigned is reduced. as a result  given the same variable ordering  binary branching does no more search than k-way branching in finding all solutions  and may do considerably less  depending on the order in which values are tried.
　the reduction in search effort is much less than mitchell found  since if all the values of the current variable are tried in turn  the propagation of the removal of the value just tried will be subsumed by the propagationof the assignment of another value. nevertheless  we have shown that binary branching can result in a 1% reduction in backtracks over k-way branching  with a reduction of around 1% in runtime.
　we found the largest search savings in the problems with monotonic binary constraints  when assigning the values in increasing or decreasing order. a reasonable value ordering heuristic in that case seems to be that if a variable is constrained to be less than several other variables  and is assigned before them  its values should be tried in increasing order  and otherwise in decreasing order. in that way  on backtracking  removingthe value just tried means reducing the range of the variable  and this propagates to the variables it constrains. furthermore  propagating range reductions in monotonic binary constraints is cheap  so that the additional overhead in propagating the removal of a value before the assignment of the next is not large.
　in other cases  although it is possible to choose good value orderings by considering how the problem constraints would propagate the removal of a value from the domain of a variable  the reduction in search effort is much less  and k-way branching is faster. the experience with these problems suggests that constraint propagation must be cheap and further domain reductions must be very likely in order for binary branching to be worthwhile. for instance  enforcing gac on an alldifferent constraint fails on both counts: it is timeconsuming  and removinga value from the domain of a single variable only occasionally leads to further domain reductions. as shown in the n-queens problem  when finding all solutions without breaking symmetry  it is better to use k-way branching than binary branching  if using global alldifferent constraints  or better still to use k-way branching with = constraints.
　binary branching  with any value ordering  does no more search than k-way branching in finding all solutions  or proving that there are no solutions. however  even when binary branching does less search  k-way branching can be faster. propagating the effect of removing the value just tried from the domain of the current variable can be time-consuming  and may not give sufficient reduction in search to be worthwhile. our investigations have been concerned with finding all solutions; however  when the extra propagation done by binary branching is not worthwhile for finding all solutions  it is unlikely to be worthwhile for finding one solution either. although binary branching on successive values of the current variable is the default search strategy in some constraint solvers  k-way branching may often be a better choice.
acknowledgements
we thank gene freuder  deepak mehta  barry o'sullivan and nic wilson for their helpful comments  and peter van beek for providing k-way branching code. this work was supported in part by the science foundation ireland under grant no. 1/pi.1/c1.
