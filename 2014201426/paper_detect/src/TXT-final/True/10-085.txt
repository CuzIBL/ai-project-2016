ion hierarchy is used that allows arbitrarily many levels of both parents and descendants  with the problem of objects with several parents being handled by the technique of merging. there is no distinction between classes and instances. in smalltalk  the description of the way an object receives a message is stored only in procedural form; in other words  it is the list of statements that are evaluated to receive the message and generate a reply. in thinglab. however  an action such as show or print is implemented as an object in its own right. this allows the way in which an object shows or prints itself to be described in a declarative manner  and also allows an object with several parents to construct an appropriate action by merging the corresponding actions from its parents. 
thinglab objects 
each object has a table of properties indexed by names. each property is in turn another object. the properties of an object describe both its internal state and its protocol for sending and receiving messages. an object may have one or more parents  each of which is also another object 
an object receives a message in the following way. the object fetches the first token  which must be a property name  and looks it up in its table of properties. if the name is not found  the object asks its parents to look up the name. the parents may in turn ask their parents to look up the name  and so on. if the object has several parents  and more than one parent returns a property  a new property is constructed by merging the inherited properties  see below . after the property corresponding to the name has been found or constructed  the property is evaluated in the context of the object which received the original message  and the result of the evaluation is applied to the remainder of the message. 
this scheme requires that property names be used in a consistent way. for example  each property named show should be a descendant of picture  and each descendant of picture should know how to merge itself with another such descendant if the same property name is used coincidentally by two parents for quite different things  the two properties can't merge  and the user will be asked what to do. 
to allow one object to serve as a property of another  each object has associated with it a piece of code which is evaluated to receive a message for another object. for most objects  such as real numbers or points  this code just returns the object itself. for example  the resistance property of a resistor should be a descendant of realnumber. when a 
resistor receives the message resistance  it looks up that property in its message dictionary. the resistance property is then evaluated in the context of the resistor  and simply returns itself. on the other hand  when a resistor receives the message show  its show property is looked up and evaluated in the context of the resistor. the code associated with the show property finds the set of point arrays and lines that constitute the resistor's image  and displays them on the screen. 
normally the thinglab user will not describe an object by writing code  but rather will construct it incrementally by first making a descendant of a prototype  and then adding and editing properties. to start things off  there are a number of prototypical objects defined in the bare system. there are prototypes for mathematical objects such as real numbers  points  lines  and sets. also  there are prototypes for objects that implement actions such as showing  printing  merging  editing  and making descendants. for example  the object printer is a prototype for objects that can produce a 
printed representation of another object. the object thing is the parent of all other objects. it has defaults for properties such as show  print  merge  edit  and new  ensuring that every object will have some way of showing itself  of printing itself  and so on. 
constraints 
a constraint restricts the behavior of a set of objects  i.e.  it restricts their responses to messages. a constraint is itself an object  with two of its properties being the expressions error and tolerance. when the absolute value of the error is less than the tolerance  the constraint is satisfied. a constraint is applied by making it a property of some other object for example  to construct a prototypical object horizontal line  

p r o b l e m - s o l v i i n g - 	1 : 	borning 
1 

the user would make a descendant of line  and add as a property a constraint that the y values of the endpoints be equal. the error expression for this constraint would simply be point j y - point! y  and the tolerance would be 1  raster point . descendants of horizontal line inherit this constraint in the usual way. 
constraint satisfaction begins when the user adds a new constraint or edits an existing one. the system finds the set of constraints that might no longer be satisfied  sends messages to these constraints requesting methods for satisfying them  and chooses and sets up methods. the results of this planning are saved  since the same methods can often be used many times to satisfy a given set of constraints. 
if possible  a one-pass method is used. such a method orders the constraints and the objects to which they apply  so that each object in turn can be updated to satisfy its constraints  without the use of backtracking or successive approximations. for constraints involving conditionals  the method of assumed states is used with a simple depth-first tree search of the space of possible truth values of the conditions. finally  the relaxation method is employed in satisfying circular constraints on real numbers. 
the methods described above work nicely when the constraints can be satisfied in one pass. for example  when the user is moving a part of a line drawing with some constraints on it  the system can redraw the picture quickly enough to provide rapid feedback. however  relaxation and the method of assumed states as implemented are too slow for use with large problems. there are several steps which could be taken to improve the situation. one step would be to build into the system a much more powerful set of constraint satisfaction methods  such as symbolic manipulation routines and dependency-directed backtracking fsec for example staiiman & sussman 1 . also  better use should be made of the modularity of the object-oriented representation. consider a simulation of a complex circuit containing a linear amplifier. as far as the rest of the circuit is concerned  the amplifier should simply be an object with some input and output nodes  i.e.  it should be a black box. internally  the amplifier will have descriptions of all its parts and their constraints. however  when its input is within the linear region  the amplifier should use a simple constraint to find its output. only when the input is not in this region should it make use of the detailed descriptions of its parts. 
merging 
suppose that a new object c is to be constructed by merging the objects a and b. the way in which an object merges with another is described by its merge property. although idiosyncratic interpretations of merging are possible  at present nearly all objects use the merge property inherited from the primordial object thing. using this property  c would be constructed as follows. a can merge with b only if they both have the same code. the properties of c are formed recursively by merging the like-named properties from a and b. if a property name is found in only one of the original objects  then the corresponding property is simply copied. the set of parents of c is the union of the sets of parents of a and b. c has all the constraints that apply to either a or b. a few primitive objects have some additional interpretations of merging. for example  if a is a set  then b must also be a set  and the contents of the new set c is the union of the contents of a and b. 
merging is also used to specify connectivity. following the methods used in sketchpad  connectivity is represented by merged parts. for example  in an electrical circuit simulation  the terminals of components are descendants of node  just as the endpoints of a line are descendants of point. to connect one component to another  a node from one of the components is merged with a node from the other to form a new node. this new node is then substituted for the old ones. 
the properties of the new node are formed by merging the like-named properties from the two original nodes. two properties of nodes are currents/n  the set of currents flowing into the node  and voltage  the voltage at the node. the set of currents has a constraint that the sum of the currents be 1  kirchhoff's current law . the currentsln property of the new node is formed by merging the currents/n properties from the original nodes  and contains all the currents from both of the original sets. the sum of its elements must still be 1. similarly  the new voltage property has all the constraints applying to either of the original voltages. for example  if one of the components being connected was a resistor  the voltage at the resulting node would still be constrained by ohm's law. 
current status 
the system is being written in smalltalk-1. a version is running that implements all the features described here. so far  however  it has been tried only on small examples  and is still being actively expanded and modified. 
acknowledgements 
many people  both in lrg and elsewhere  have provided valuable advice on this project. in particular  i'd like to thank danny bobrow  adele goldberg  dan ingalls  ted kaehler. alan kay. dave robson  david shaw. rich steiger. 
steve weyer  and terry winograd. 	xerox palo alto research 
center has provided support and excellent facilities. this project is being done as a ph.d. thesis in computer science at stanford university. 
