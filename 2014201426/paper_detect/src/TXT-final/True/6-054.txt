 
this paper addresses the formal verification of diagnosis systems. we tackle the problem of diagnosability: given a partially observable dynamic system  and a diagnosis system observing its evolution over time  we discuss how to verify  at design time  if the diagnosis system will be able to infer  at runtime  the required information on the hidden part of the dynamic state. we tackle the problem by looking for pairs of scenarios that are observationally indistinguishable  but lead to situations that are required to be distinguished. we reduce the problem to a model checking problem. the finite state machine modeling the dynamic system is replicated to construct such pairs of scenarios; the diagnosability conditions are formally expressed in temporal logic; the check for diagnosability is carried out by solving a model checking problem. we focus on the practical applicability of the method. we show how the formalism is adequate to represent diagnosability problems arising from a significant  real-world application. symbolic model checking techniques are used to formally verify and incrementally refine the diagnosability conditions. 
1 introduction 
diagnosis is the process of inferring the  most plausible  causes for the behavior of a given system  given a set of observations. in many control applications  ranging from industrial plants  e.g. production  power  to transportation  e.g. railways  avionics  space   diagnosis needs to be carried out on-line  in parallel with the control process. this is needed to identify whether the controlled system is working correctly or not  and to provide the controller with information on the degraded conditions  e.g. what are the malfunctioning devices   so that the appropriate counter-measures can be taken. the ability to validate such diagnosis systems becomes very important  in particular in the case of applications operating in hazardous or inaccessible conditions and carrying out vital functions. 
in this paper  we focus on the key issue of diagnosability  
i.e. the possibility for an ideal diagnosis system to infer accurate and sufficient run-time information on the behavior of the observed system. we propose a new  practical approach to the verification of diagnosability  making the following contributions. first  we provide a formal characterization of diagnosability problem  using the idea of context  that explicitly takes into account the run-time conditions under which it should be possible to acquire certain information. 
　second  we show that a diagnosability condition for a given plant is violated if and only if a critical pair can be found. a critical pair is a pair of executions that are indistinguishable  i.e. share the same inputs and outputs   but hide conditions that should be distinguished  for instance  to prevent simple failures to stay undetected and degenerate into catastrophic events . we define the coupled twin model of the plant  and show that it can be used to search for critical pairs. 
　third  we recast the problem in the framework of model checking  clarke et al  1   a verification technique that is gaining increasing interest also in ai. with model checking  it is possible to exhaustively analyze the  possibly infinite  behaviors of  large sized  finite state machines  and to check if requirements expressed in terms of temporal logics  emerson  1  are met. we show how to represent a diagnosability problem in terms of temporal logic formulae  and how to reduce it to a model checking problem over the coupled twin model. 
　finally  we demonstrate the practical applicability within the livingstone framework  a model-based diagnosis system developed at nasa ames research center  williams and nayak  1 . we developed a platform able to generate formal models for the twin plant  starting from livingstone models. several diagnosability problems corresponding to interesting scenarios from real-world applications were tackled by means of the nusmv model checker  cimatti et al  1   an experimental analysis shows that the verification of diagnosability can be practical: large livingstone models of space transportation systems are automatically analyzed within seconds by means of sat-based symbolic model checking techniques. 
　the paper is organized as follows. in section 1  we state our working hypotheses. in section 1 we formalize the problem  while in section 1 we characterize our approach. in section 1  we discuss the application of model checking techniques. in section 1  we describe the experimental framework. finally  section 1 reviews similar work  and section 1 draws some conclusions and outlines future lines of activity. 
figure 1: architecture of a diagnosis system 
1 working hypotheses 
we consider a diagnosis system connected to a feedback control loop between a plant and its controller  figure 1 . the inputs of the plant are the commands issued by the controller; its outputs are measurements returned back to the controller. the role of the diagnosis system is to observe the inputs and the outputs to the plant  and to report a state estimation  tracking the evolution of the unobservable state of the plant. this task is substantially more complex than diagnosis for a combinatorial  memory-less system. an estimation consists of a set of possible states of the plant  in the following referred to as a belief state. although diagnosis might rank these states based on likelihood  as a first approach we ignore that aspect. we also disregard issues such as the correspondence between the model of the plant and the plant itself. we will focus on plants modeled as finite-state discrete systems. we assume that we have a model of the plant as a partially observable transition system  according to the following definition. 
definition 1 a  partially observable  plant is a structure  where x  1  y are finite sets  respectively called the state space  input space and output space  
x x u x x is the transition relation  and is the observation relation. 
we assume that a p l a n t i s given. we use to denote states of to denote inputs of p  y  y1  y1        to denote outputs of p. we write 
 the 
state is the  hidden  part of the plant: only the sequences of inputs and outputs are observable. p covers all types of behaviors that diagnosis is expected to handle - including faulty behaviors  with x containing faulty states. in general  p need not be deterministic. thus  the state after a transition may not be uniquely determined the state before the transition and by the input. observability is modeled by associating to each state a  non empty  set of possible outputs. it is therefore possible to model different forms of observation  e.g. when the information conveyed by the sensors is also uncertain. in this paper  we present the  input  state and output  spaces of a plant by means of assignment to  input  state and output  variables ranging over finite sets of values; the transition and observation relation can be compactly presented with boolean formulae.  notice however that the content of the paper is independent of the specific description used to present p.  
definition 1 a feasible execution of steps in p is a sequence 	such 
	and 	for 1 
as the set of all feasible execu-
tions of p. the observable trace of a feasible execution is 
such a a exists. 
the above definition defines the dynamics of a plant and its observable counterpart. notice that if an execution has k steps  then the corresponding t r a c e . the set of traces is in general a subset in the following we use  to denote a feasible execution  and w to denote the corresponding  observable  trace. for explanatory purposes  we consider the plant outlined in figure 1  that is a simplified segment of the real-world application described in section 1. a pneumatic valve  pv  controls the flow of a feeding line to the engine  and it is closed in its resting position  determined by the action of a spring . a solenoid valve  sv   when open  can open pv by directing the pneumatic flow against the spring. when sv is closed  the action of the spring is no longer contrasted and pv can close. sv can receive an input  open/close   but has no observables. pv has two sensors  each providing information on a position  e.g. whether it is open or not . both valves can become stuck in their current position. the position of the valves influences the pneumatic and engine flows. each of the valves has two unobservable variables: s t a t e   with values open and closed  and f a i l u r e mode  with values stuck and ok. the input variable can take the values no-cmd  open  and close. the effect of a command depends on the current status. failures can occur at any time  and are permanent. sensors of pv are also associated with a failure mode variable  that determines what information is conveyed. 
1 diagnosability 
run-time diagnosis starts from a  possibly partial  initial knowledge  observes the sequence of inputs and outputs  and tries to update a belief state that is an estimate of the possible states of the plant. for instance  if s v is commanded open  and the pv is not sensed open  then some problem should be diagnosed. it could be that sv or pv are stuck  or even that 

both pv sensors are not working correctly. ideally  a diagnosis function should return belief states that are as specific  i.e. as small  as possible  but include the actual state of the plant. 

the intuition behind correct diagnosis values is that they encompass all potential current states  so that they cannot miss the actual state. in the following  we restrict ourselves to correct diagnosis functions. 
　diagnosability aims at detecting if  parts of  the hidden state can be accurately tracked by looking at the observable traces. we use diagnosis conditions to specify which information on the state we are interested in distinguishing. 
definition 1 a diagnosis condition for a plant p is a pair of nonempty sets of states 
we can express fault detection  i.e. telling if any fault is 
present or fault separation  i.e. distinguishing between different faults  or fault classes    
faulty . intuitively  a diagnosis value is not satisfactory if it intersects with both sides of the condition. in the example  a fault separation condition is not satisfied if we have a belief state containing both a state where pv is faulty  and one where sv is faulty. 
however  it would be unrealistic to require that diagnosis provide correct and exact state estimations  instantaneously and under all circumstances. for instance  a stuck pv will stay unnoticed at least as long as sv is not operated. rather  we require a diagnosis system to be able to decide between alternative conditions on the state of the system in the context where the distinction becomes critical. 
intuitively  1 defines the initial conditions under which diagnosability is to be investigated  by inducing of a set of disjoint belief states. basically  the initial belief state xq must fall within one of the belief states induced by  the condition on  can be stated as   for example  can partition states according to the positions of pv and sv  to capture the assumption that we initially  only  know those positions.  characterizes pairs of relevant executions. for instance  we may want to express the fact that the controller commands sv to be open and closed at least one time. in the case of fault detection  we might want to state that the elements of  are pairs of traces  there the first are without faults  while the second ones have exactly one fault. 
notice that expressing  would be inadequate: for instance  in fault separation it would be impossible to constrain the two runs to have different failures. in the following we assume that a context  is given. the notion of diagnosability is precisely characterized as follows. 

figure 1: critical pair 

1 diagnosability as coupled reachability 
our approach to reasoning about diagnosability is based on refutation  i.e. we search for ways in which the diagnosability property can be violated. intuitively  we verify the diagnosability of  by checking that p does not have a critical pair  i.e. two executions with identical observable traces  one leading to c1  one leading to c1  see figure 1 . 
definition 1 a critical pair of a plant p  with trace w  for a diagnosis condition is a pair of feasible executions 
the absence of critical pairs for in a given context is a necessary and sufficient condition for to be diagnosable in that context. 
theorem 1 	is diagnosable over c in p  if and only 
if p has no critical pair for 
to prove the theorem  we introduce the notion of perfect diagnosis  written  i.e. the most specific correct diagnosis function that can be made assuming full knowledge of p. 
definition 1 the perfect diagnosis for a plant p is the diagnosis function 
given an initial belief state x and trace returns exactly all states that can be reached from x1 through w. it is easy to see that is correct  and that it is the most informative diagnosis function  i.e. for any correct 
 we observe that a condition is diagnosable in a plant p over a context c if and only if from 
definition 1  if 
c1. therefore  satisfies any diagnosable condition  since its diagnosis values are more specific than any other correct diagnosis function. 
proof of theorem 1 is not diagnosable in p over c; if and only if there exist x1 and w such that 


   in order to search for critical pairs in p  we build the coupled twin plant for p  written p   p  i.e. a  siamese twins** plant  made out of two copies of p  whose inputs and outputs are forced to be identical. 
　in the following  we assume that the coupled twin plant p   p of p is given. the importance of the coupled twin plant construction is shown by the following theorem. 
theorem 
feasible executions in p if and only if 
 x1  x1  is a feasible execution in p ＊ p. 
this is easily demonstrated by induction on the length k of 
from defini-
   x and the step case is proved by extend-
ing with a transition the executions of length k  for which the theorem holds. from definition 1  the transitions in p   p mimic the transitions in p. for the last observation  we reason as for the base case. 
1 diagnosability via model checking 
we work in the framework of model checking  clarke et al  1   a formal verification technique that is increasingly applied to the design of industrial digital systems  e.g. communication protocols  hardware design . model checking allows to verify if the  possibly infinite  behaviors of a system satisfy a given property. the system being analyzed is presented as a kripke structure  while properties are expressed in a temporal logic  emerson  1 . model checking algorithms are based on the exhaustive exploration of the kripke structure. the technique is completely automatic and  if a property is violated  it can produce a counterexample  i.e. a simulation witnessing the violation. symbolic model checking  mcmillan  1  is based on the manipulation of sets of states described by boolean formulae; efficient engines  such as binary decision diagrams  bdds   bryant  1  and sat solvers  moskewicz et al.  1    provide a basis for efficient representation and exploration of the search space. 
　our approach to diagnosability inherits several elements from model checking. the first is that a plant p can be associated with a kripke structure kp representing its behavior. this makes it possible for us to directly analyze a plant with model checking techniques. a kripke structure is basically a nondeterministic transition system  where transitions are not labeled  while information is associated with states  i.e. each state is associated with a valuation to the state variables of the structure . the mapping from plant to kripke structure is rather simple  and is based on the idea that the state  input and output spaces of the plant can be encoded into the state space of the kripke structure. the information on the inputs  labeling the transitions in p  simply becomes part of the state of kp  and is to be interpreted as  the input that will be processed in the next transition**. more formally  each state s in 
kp is associated with a valuation that characterizes a triple 
           p is in state x  output y is observed and input u is received. the dynamics of p directly induce the dynamics of kp. for each feasible execution in p of the form there is a corresponding 
path in kp  i.e. a sequence of s t a t e s w h e r e each s is associated with the triple the same 
mapping lifts to the coupled twin plant construction.  in the above description  we omit a few technical details  having to do in particular with the fact that a kripke structure is assumed to be total  i.e. every state has at least one successor. in this way  it is possible to assume that the analyzed paths are infinite. since inputs become part of the state  it is possible that the transition relation is no longer total. there are standard workarounds to this problem  routinely used in verification and in ai planning. see for instance  cimatti and roveri  
1 .  in the following  we assume that kripke structure kp.p corresponding to the coupled twin plant p ＊ p is given. 
　the second element from model checking is the symbolic representation. the state of kp.p is defined with a vector of variables  x 1  x 1  u y   respectively ranging over ar  x  u and y. we can use formulae to characterize sets of states. in kp.p we express atomic propositions over such variables. we can have equalities between variables and the corresponding values: p i . p v   i n p u t = close denotes the set of states where the first instance of pv receives the close command. variables of the same type can be equated: p i . sv. f ailure mode = p1 . sv. f a i l u r e mode describes the set of states where the two instances of sv in the twin plant have the same failure mode. any subset c of xxxxuxy can be described with a formula c x1 x1 y u . for instance  the formula expresses a state of the twin plant where the first instance is in 
c1 and the second is in c1. similarly   is a  propositional  formula expressing  in symbolic form  the equivalence relation 
　the third ingredient from model checking is the use of temporal logics to characterize behaviors of the system over time. we use ltl  linear temporal logic  emerson  1    where formulae are constructed starting by combining atomic 
propositions with boolean operators and temporal modalities. if and are ltl formulae  so are  sometimes in the future  always in the f u t u r e   s o m e t i m e s in 
the future and  until then   in the next time step an ltl formula holds on a path tt  written true in n at  step  1  written . if p is an atomic proposition  then iff p is true according to the assignment associated with the i-th state of boolean connectives have the standard interpretation and 
the interesting cases of temporal operators are as 
iff there exists 
module sv type  cmd in  
module pv type     
var pneumaticslineln : {abvthresh blwthresh}; 
var valvepositionvalue : {open closed}; 
var mode : {stuckopen nominal stuckclosed}; 
define  faultmodes := {stuckopen stuckclosed}; define  broken := mode in   faultmodes; 
define  brokencount :=  broken; 
define  brokenprob := case 
mode = stuckopen 	: 1; mode = stuckclosed : 1; else 	: 1; 
esac; 
module ex type  sv cmd in  	. . .   
sv : sv type sv cmd in ; pv : pv type   ; 
define  brokencount := sv.  broken + 
pv. broken + 
figure 1: the smv model for the example 

　a diagnosis condition with a context is represented with temporal logic formula such that holds iff there is a critical pair. we express reachability in p   p of a critical pair for a diagnosis condition with the formula: 
　　　　　　　　　model checking can be run on the problem . if the answer is true  
then we have a witness for the a critical pair. given the context we enforce the initial condition with 
the formula 	. the conjunction has the effect of restricting the analysis to the paths in kp.p starting from the states that satisfy  is taken into account assuming that a characterization of the sets of traces is described by an ltl formula . the 
model checking problem corresponding to diagnosability is 

in practice  several simplifications are possible. often can be expressed in terms of propositional that must hold on all the states 
of the execution; in such cases diagnosability in context c is basically represented by the ltl formula 
. notice that the 
formula holds if the path condition holds until the conditions c1 and c1 are reached. when the context does not constraint the executions  the above formula is equivalent to 

module main 
var sv cmd : { no cmd  open  close }; pi : ex type sv crnd  . . .   ; 
p1 : ex type sv cmd  . . .   ; 
invar 
 pi.pv.sense open = p1.pv.sense open  & . . . 
figure 1: the smv schema for the twin plant 
1 experimental evaluation 
we analyzed the practical applicability of our approach within the livingstone framework. livingstone is a modelbased health monitoring system developed at nasa ames  williams and nayak  1 . it uses a model of a physical system  such as a spacecraft  to infer its state and diagnose faults from observations. livingstone is one of the three parts of the remote agent  ra   an autonomous spacecraft controller developed by nasa ames research center jointly with the jet propulsion laboratory. ra was the first al software to control an operational spacecraft  muscettola et al  1 . livingstone has also been used in other applications such as the control of the in-situ propellant production system  1spp  for mars missions  clancy et al  1   the monitoring of a mobile robot  simmons et al.  1    and intelligent vehicle health management  ivhm  for experimental space transportation vehicles  bajwa and sweet  1 . 
　livingstone uses a qualitative relational model describing the evolution of observable and hidden variables. continuous physical domains are abstracted into discrete intervals such as {low  nominal  high}. each component has a mode variable identifying its nominal and fault modes. livingstone models are specified in a hierarchical  declarative formalism called jmpl  or using a graphical development environment. livingstone observes the commands issued to the plant and uses the model to predict the plant state. it then compares the predicted state against observations received from the actual sensors. if a discrepancy is found  livingstone performs a diagnosis by searching for the most likely configuration of component modes that are consistent with the observations. 
　livingstone models directly induce a synchronous transitions systems  very similar to a plant model. pecheur and simmons  pecheur and simmons  1  have developed a translator able to convert a livingstone model and a related set of specifications in the language of the smv model checker  mcmillan  1   and to convert back the diagnostic traces in terms of the livingstone model. figure 1 outlines the structure of the example plant in smv language. for each component type  there is a corresponding module. the first module statements define the model for the sv and the pv. for each of the components  a set of variables is defined  the dynamics of which is directly induced from the livingstone model. notice the  brokenprob variable  whose numerical value is the  negated  logarithm of the probability of failure for the component  e.g. 1 -1 . this enables for a  rough  analysis of failure probabilities. these modules are instantiated in the ex module  with a parameter representing the commands to pv. 

   in order to tackle diagnosability  we devised a systematic way of constructing the smv coupled twin plant of a livingstone model. the construction is outlined in figure 1. the ex plant is instantiated twice in the main  at top level  generating pi and p1. the same input variable  sv cmd  is given in input to both instances. then  the outputs of the two instances of the plant are constrained to exhibit the same behavior by means of an invar statement  i.e. a condition that must hold in all states. the smv language enables for the specification of context. the basic building blocks of the properties are propositional conditions over states  that can be expressed by means of the define construct. for instance  it is possible to express conditions on the number of failures  using the  brokencount variable defined in figure 1. for instance  p i .  brokencount   1 in the main module states that at most one failure can occur in the first instance of the circuit. 
   in the experimental analysis  we tackled several problems for the livingstone model of the main propulsion system for the x-1  a next-generation vehicle for the space shuttle  bajwa and sweet  1 . we interacted with the nasa experts of diagnosis  to check the representational adequacy of our formalism  and to characterize diagnosability problems of practical relevance. the problems were defined starting from simulation runs  that tested a specific fault in a specific context. we remark the impact of our approach is far beyond the one of testing  since it performs an exhaustive analysis  though at a higher abstraction level  within the cases captured by the context. the experimental evaluation was carried out by running different symbolic model checking tools on models described in smv language  such as the cmu smv  mcmillan  1   bwolen yang's version of smv  yang etal  1   and nusmv  cimatti et al  1 . while the former ones are based on binary decision diagrams  bdds   bryant  1   nusmv also enables the use of sat-based techniques  moskewicz et al  1 . this activity suggested several considerations. first  the experimental analysis was fundamental to tune the formalism. several improvements  e.g. the notion of context  were conceived while trying to encompass representational issues arising in practice. second  contexts are incrementally characterized. although the requirements for the diagnosis system can usually suggest an initial version for the context  it is seldom the case that the precise conditions for diagnosability are known  or can be precisely stated  in advance. the ability of the model checker to find critical pairs was very useful in the refinement  since it helped to explain why diagnosability fails  i.e. to understand whether the context is not strict enough  or because a problem was found. 
　in terms of performance  the critical factor was the size of the models to be analyzed. the most significant plant we analyzed has about 1 scalar variables. this number almost doubles in the case of the twin plant  and  after the elimination of equivalent variables  we are left with models having about 1 state variables. different versions of smv were used to tackle the resulting diagnosability problems. all the bdd-based verification engines were defeated by the size of models for coupled twin plants  i.e. no solution found after running for 1hs . this failure occurred despite the use of advanced techniques such as dynamic reordering  invariant discovery  and conjunctive partitioning. we remark that some of these bdd-based engines  most notably bwolen yang's smv  were able to tackle verification problems on single plants very efficiently. on the other hand  the use of model checking techniques based on sat solving  implemented in the nusmv system  cimatti etal  1   proved to be very effective on these problems. we used a combined approach  integrating bounded model checking  oriented to finding bugs  and inductive reasoning. the sat-based engine of nusmv was able to solve all the verification problems in less than two seconds. the analysis of the results shows that livingstone models tend to feature a huge state space but little depth; therefore  the symbolic processing provided by sat turns out to be very appropriate. it is worth mentioning that  while trying to refine a diagnosability property  we discovered an unexpected behavior in the model of the x-1. further analysis highlighted a missing statement in the description. this result is quite significant  since the model had been repeatedly tested. 
1 related work 
the idea of diagnosability has received a lot of attention in the framework of discrete event systems. in  sampath et al  1; 1   diagnosability is precisely defined and an algorithm for checking diagnosability is presented. the approach is limited to failures represented as reachability properties. jiang and kumar  jiang and kumar  1  generalize the approach to the case of failures described as formulae in linear temporal logics. the approach is based on a polynomial algorithm for testing the diagnosability  formulated with techniques from automata theory  jiang et al  1 . in particular  they define a self-product automaton similar to our twin plant. console  picardi and ribaudo  console et al  1  propose the use of a particular form of process algebras  pepa  for the formalization and the analysis of diagnosis and diagnosability problems. 
　our work is rather different from the works mentioned above  that are mostly oriented to the definition of the theoretical framework  and do not address the problems related to the practical application of the proposed techniques. our objective is the definition of an effective platform for the analysis of diagnosability  that can be practically applied in the development process of diagnosis systems. the  twin-models  approach allows us to directly reuse standard model checking tools  without having to reimplement a complex tableau construction described in  jiang et al  1 . furthermore  our approach preserves the semantics of the problem  thus making it possible to tune the decision procedure to the application domain. in terms of expressivity  our work shares several underlying assumptions with  sampath et al  1; 1   considering failures that can be represented as reachability conditions. compared to  jiang et al  1   we only tackle zero-delay diagnosability  although it seems that our framework could be extended in this respect. 
　our approach makes no hypothesis on the way the controller exploits the information provided by the diagnosis system. for this reason  we introduce the notion of context in 

order to qualify the conditions under which diagnosability should hold. in active diagnosis  sampath et al  1   the controller is designed taking into account the issues of diagnosability. similar problems are also tackled in planning under partial observability  where the planner can decide the most appropriate actions to diagnose the fault  e.g. by probing the system with actions that will provide suitable information  and recover from it  see for instance  bertoli et al  1  . 
1 conclusions 
in this paper  we have proposed a novel approach to the verification of diagnosability  with emphasis on its practical applicability. our work is based on a new conceptualization of the problem  with the twin plant construction and the use of temporal logic formulae to describe the context of a diagnosability problem. to the best of our knowledge  this is the first approach to diagnosability that enables the direct exploitation of symbolic model checking technology. we tackled significant diagnosability problems from a real-world application  discussed a practical methodology for the incremental refinement of diagnosis contexts  and were able to verify largesized problems. in the future  we will try to take into account the fact that diagnosis can propose several candidates  with different degrees of likelihood. a compositional approach to verification  exploiting the modular structure of the design  will be investigated. in the longer term  we plan to tightly integrate the approach within the livingston toolset  in order to allow livingstone application developers to use model checking to assist them in designing and correcting their models  as part of their usual development environment. 
