
we consider how to forget a set of atoms in a logic program. intuitively  when a set of atoms is forgotten from a logic program all atoms in the set should be eliminated from this program in some way  and other atoms related to them in the program might also be affected. we define notions of strong and weak forgettings in logic programs to capture such intuition and reveal their close connections to the notion of forgetting in classical propositional theories. based on these notions  we then propose a framework for conflict solving in logic programs  which is general enough to represent many important conflict solving problems. we also study some essential semantic and computational properties in relation to strong and weak forgettings and conflict solving in our framework.
1	introduction
one promising approach in the research of reasoning about knowledge dynamics is to represent agents' knowledge bases as logic programs on which necessary updates are conducted as a way to model agents' knowledge evolution. a key issue in this study is to solve various conflicts and inconsistencies in logic programs  e.g.  leite  1 .
¡¡while different logic program update approaches have been developed recently  we observe that some typical conflict solving problems in logic programs have yet to be thoroughly investigated in the literature. let us consider a scenario. john wants sue to help him to complete his assignment. he knows that sue will help him if she is not so busy. tom is a good friend of john and wants john to let him copy john's assignment. then john also learns that sue hates tom  and will not help him if he lets tom copy his assignment  which will be completed under sue's help. while john does not care whether sue hates tom or not  he has to consider sue's condition to offer him help. what is john going to do  we formalize this scenario in a logic programming setting. john's knowledge base ¦°j:
r1 : complete john assignment  ¡û
¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡help sue john   r1 : help sue john  ¡û notbusy sue   r1 : goodfriend john tom  ¡û  r1 : copy tom assignment  ¡û
goodfriend john tom  
complete john assignment  
and sue's knowledge base ¦°s:
r1: hate sue tom  ¡û  r1: ¡û help sue john  copy tom assignment .
¡¡in order to take sue's knowledge base into account  suppose john updates his knowledge base ¦°j in terms of sue's ¦°s. by applyingproperlogic programupdate approach john may obtain a solution: ¦°finalj = {r1 r1 r1 r1 r1} or its stable model  from which we know that sue will help john to complete the assignment and john will not let tom copy his assignment. although the conflict between ¦°j and ¦°s has been solved by updating  the result is somehow not always satisfactory. for instance  while john wants sue to help him  he may have no interest at all in integrating the information that sue hates tom into his new knowledge base.
¡¡as an alternative  john may just weaken his knowledge base by forgetting atom copy tom assignment  from ¦°j in order to accommodate sue's constraint. then john may have a new program ¦°finalj = {r1 r1 r1} - john remains a maximal knowledge subset which is consistent with sue's condition without being involved in sue's personal feeling about tom.
¡¡the formal notion of forgetting in propositional theories was initially considered by lin and reiter from a cognitive robotics perspective  lin and reiter  1  and has recently received a great attention in kr community. it has been shown that the theory of forgetting has important applications in solving knowledge base inconsistencies  belief update and merging  abductive reasoning  causal theories of actions  and reasoning about knowledge under various propositional  modal  logic frameworks  e.g.  lang and marquis  1; lang et al.  1; lin  1; su et al.  1 .
¡¡in this paper  we consider how to forget a set of atoms from a propositional normal logic program and how this idea can be used in general conflict solving under the context of logic programs. the rest of this paper is organized as follows. we present preliminary definitions and concepts in section 1. in section 1  we give formal definitions of strong and weak forgettings in logic programs. based on these notions  in section 1  we propose a framework called logic program contexts for general conflict solving in logic programs. in section 1  we investigate related semantic and computational properties. in section 1 we conclude the paper with some discussions.
1	preliminaries
we consider finite propositional normal logic programs in which each rule has the form:
¡¡¡¡¡¡¡¡a ¡û b1 ¡¤¡¤¡¤ bm notc1 ¡¤¡¤¡¤ notcn  1  where a is either a propositional atom or empty  and b1 ¡¤¡¤¡¤ bm  c1 ¡¤¡¤¡¤ cn are propositional atoms. when a is empty  rule  1  is called a constraint. given a rule r of the form  1   we denote head r  = {a}  pos r  = {b1 ¡¤¡¤¡¤ bm} and neg r  = {c1 ¡¤¡¤¡¤ cn}  and therefore  rule  1  may be represented as the form:
         head r  ¡û pos r  notneg r .  1  we also use atom r  to denote the set of all atoms occurring in rule r. for a program ¦°  we define notions head ¦°  = sr¡Ê¦° head r   pos ¦°  = sr¡Ê¦° pos r   neg ¦°  = sr¡Ê¦° neg r   atom ¦°  the set of all propositional atoms occurring in program ¦°. given sets of atoms p and q  we may use notion
r1 : head r  ¡û  pos r    p  not neg r    q 
to denote rule r1 obtained from r by removing all atoms occurringin p and q in the positive and negationas failure parts respectively.
¡¡the stable model of a program ¦° is defined as follows. firstly  we consider ¦° to be a program in which each rule does not contain negation as failure sign not. a finite set s of propositional atoms is called a stable model of ¦° if s is the smallest set such that for each rule a ¡û b1 ¡¤¡¤¡¤ bm from ¦°  if b1 ¡¤¡¤¡¤ bm ¡Ê s  then a ¡Ê s. now let ¦° be an arbitrary normal logic program. for any set s of atoms  program ¦°s is obtained from ¦° by deleting  1  each rule from ¦° that contains not c in the body and c ¡Ê s; and  1  all forms of not c in the bodies of the remaining rules. then s is a stable model of ¦° if and only if s is a stable model of ¦°s. a program may have one  more than one  or no stable models at all. a program is called consistent if it has a stable model. we say that an atom a is entailed from program ¦°  denoted as ¦° |= a if a is in every stable model of ¦°.
¡¡given two programs ¦°1 and ¦°1. ¦°1 and ¦°1 are equivalent if ¦°1 and ¦°1 have the same stable models. ¦°1 and ¦°1 are called strongly equivalent if for every program ¦°  ¦°1 ¡È ¦° and ¦°1 ¡È ¦° are equivalent  lifschitz et al.  1 .
observation: let ¦° be a logic program. if each rule r in ¦° is of one of the following two forms:  1  head r  1=   and head r    pos r   or  1  pos r  ¡É neg r  1=    then ¦° is strongly equivalent to the empty set.
¡¡for a later reference  we call the two types of rules mentioned above redundant rules.
¡¡let ¦° be a logic program. we use  ¦° c to denote the conjunctive normal form obtained from ¦° by translating each rule of the form  1  in ¦° in to the clause: a¡Å b1¡Å¡¤¡¤¡¤¡Å bm¡Å c1 ¡Å ¡¤¡¤¡¤ ¡Å cn. for instance  if ¦° = {a ¡û notb c ¡û a}  then we have  ¦° c =  a¡Åb ¡Ä c¡Å a . in general  we may write  ¦° c = {c1 ¡¤¡¤¡¤ cn} where each ci is a conjunct of  ¦° c.
if ci is a clause  we call any sub formula of ci a subclause of ci.
¡¡now we introduce the notion of forgetting in a classical propositional theory  lin and reiter  1; lin  1 . let t be propositional theory. we use t p/true   or t p/false   resp.  to denote the theory obtained from t by substituting all occurrencesof propositionalatom p with true  or false  resp. . for instance  if t = {p   q  q¡Är    s}  then t q/true  =
{r   s} and t q/false  = { p}. then we can define the notion of forgetting in terms of a propositional theory. for a given propositional theory t and a set of propositional atoms p  the result of forgetting p in t  denoted as forget t p   is defined inductively as follows:
forget t    = t 
forget t {p}  = t p/true  ¡Å t p/false   forget t p ¡È{p}  = forget forget t {p}  p .
¡¡it is easy to see that the ordering in which atoms in p are considereddoes not affect the final result of forgettingp from t. consider t = {p   q  q¡Är    s} again. from the above definition  we have forget t {q}  = { r   s  ¡Å  p}.
1	strong and weak forgettings in logic
programs
let us consider how to forget a set of atoms from a logic program. intuitively  we would expect that after forgetting a set of atoms  all occurrences of these atoms in the underlying program should be eliminated in some way  and moreover  other atoms having connections to them through rules in the programmight also be affected. we observe that the notion of forgetting in propositional theories is not applicable to logic programs since there is no disjunctive operation for logic programs. further  different ways of handling negation as failure in forgetting may also lead to different resulting programs. to formalize our idea of forgetting in logic programs  we first introduce a program transformation called reduction.
definition 1  program reduction  let ¦° be a program and p an atom. we define the reduction of ¦° with respect to p  denoted as reduct ¦° {p}   to be a program obtained from ¦° by  1  for each rule r with head r  = p and each rule r1 with p ¡Ê pos r1   replacing r1 with a new rule r1 : head r1  ¡û  pos r ¡Èpos r1  {p}  not neg r ¡Èneg r1  ;  1  if there is such rule r1 in ¦° and has been replaced by r1 in  1   then removing rule r from the remaining program. let p be a set of atoms. then the reduction of ¦° with respect to p is inductively defined as follows:
reduct ¦°    = ¦° 
reduct ¦° p ¡È {p}  = reduct reduct ¦° {p}  p .
¡¡note that in our program reduction definition  step  1  is the same as logic program unfolding  brass and dix  1 . while unfolding is to eliminate positive body occurrences of an atom in a logic program  the reduction  on other hand  is further to remove those rules with heads of this atom.
example 1 let ¦°1 = {a ¡û notb a ¡û d c ¡û a note} 
¦°1 = {a ¡û c notb c ¡û notd}  and ¦°1 = {a ¡û b b ¡û notd c ¡û a note}. then reduct ¦°1 {a}  = {c ¡û notb note c ¡û d note}  reduct ¦°1 {a}  = ¦°1  and reduct
definition 1  strong forgetting  let ¦° be a logic program  and p an atom. we define a program to be the result of strongly forgetting p in ¦°  denoted as sforgetlp ¦° {p}   if it is obtained from the following transformation:
1. ¦°1 = reduct ¦° {p} ;
1. ¦°1 = ¦°1   {r | r is a redundant rule};
1. ¦°1 = ¦°1   {r | head r  = p};
1. ¦°1 = ¦°1   {r | p ¡Ê pos r };
1. ¦°1 = ¦°1   {r | p ¡Ê neg r };
1. sforgetlp ¦° {p}  = ¦°1.
¡¡let us take a closer look at definition 1. step 1 is just to perform reduction on ¦° with respect to atom p. this is to replace those positive body occurrences of p in rules with other rules having p as the head. step 1 is to remove all redundant rules which may be introduced by the reduction of ¦° with respect to p. from observation in section 1  we know that this does not change anything in the program. steps 1 and 1 are to remove those rules which have p as the head or in the positive body. note that after steps 1 and 1  there does not exist any pair of rules r and r1 such that head r  = {p} and p ¡Ê pos r1 . then the intuitive meaning of steps 1 and 1 is that after forgetting p  any atom's information in rules having p as their heads or positive bodies will be lost because they are all relevant to p  i.e. these atoms either serve as a support for p or p is in part of the supports for these atoms. on the other hand  step 1 states that any rule containing p in its negation as failure part will be also removed. the consideration for this step is as follows. if we think neg r  is a part of support of head r   then when p ¡Ê neg r  is forgotten  head r 's entire support is lost as well. clearly  such treatment of negation as failure in forgetting is quite strong in the sense that more atoms may be lost together with notp. therefore we call this kind of forgetting strong forgetting.
¡¡with a different way of dealing with negation as failure  we have a weak version of forgetting. we define a program to be the result of weakly forgetting p in ¦°  denoted as wforgetlp ¦° {p}   exactly in the same way as in definition 1 except that step 1 is replaced by the following step:
¦° =     ¦° = :     ¡û pos r  not neg r    {p}  where r ¡Ê ¦° }.
¡¡suppose we have a rule like r : head r  ¡û pos r   notneg r  where p ¡Ê neg r . instead of viewing neg r  as part of the support of head r   we may treat it as a default evidence of head r   i.e. under the condition of pos r   if all atoms in neg r  are not presented  then head r  can be derived. therefore  forgetting p will result in the absence of p in any case. so r may be replaced by r1 : head r  ¡û pos r  not neg r    {p} .
¡¡strong and weak forgettings can be easily extended to the case of a set of atoms:
sforgetlp ¦°    = ¦° 
   sforgetlp ¦° p ¡È {p}  = sforgetlp sforgetlp ¦° {p}  p   and wforgetlp ¦° p  is defined accordingly. the following proposition ensures that our strong and weak forgettings in logic programs are well defined under strong equivalence.
proposition 1 let ¦° be a logic program and p q two propositional atoms. then
1. sforgetlp sforgetlp ¦° {p}  {q} 	is	strongly equivalent to sforgetlp sforgetlp ¦° {q}  {p} ;
1. wforgetlp wforgetlp ¦° {p}  {q}  is strongly equivalent to wforgetlp wforgetlp ¦° {q}  {p} .
example 1 let ¦° = {b ¡û a c  d ¡û nota  e ¡û notf}. then we have sforgetlp ¦° {a}  = {e ¡û notf}  and wforgetlp ¦° {a}  = {d ¡û  e ¡û notf}. now we consider forget  ¦° c {a}   which is logically equivalent to formula  b ¡Å  c ¡Å d  ¡Ä  f ¡Å e . then it is clear that
|= forget  ¦° c {a}     sforgetlp ¦° {a}  c  and
|=  wforgetlp ¦° {a}  c   forget. 
¡¡the above example motivates us to examine the deeper relationships between strong and weak forgettings in logic programs and forgetting in propositional theories. let ¦° be a program and l a clause  i.e. l = l1 ¡Å ¡¤¡¤¡¤ ¡Å lk where each li is a propositional literal. we say that l is ¦°coherent if there exists a subset ¦°1 of ¦° and a set of atoms p   atom ¦°   p could be empty  such that l is a subclause of  reduct ¦°1 p  c  i.e.  reduct ¦°1 p  c is a single clause . the intuition behind this notion is to specify those clauses that are parts of clauses generated from program ¦° through reduction. consider program ¦° = {a ¡û b d ¡û a notc e ¡û notd}. clause d ¡Å b is ¦°-coherent  where clause  d ¡Å e is not. obviously  for each rule r ¡Ê ¦°   {r} c is ¦°-coherent. the following proposition provides a semantic account for ¦°-coherent clauses. proposition 1 let ¦° be a program and l a ¦°-coherent clause. then either |=  ¦° c   l or |= l   ¦µ for some clause ¦µ where |=  ¦° c   ¦µ.
definition 1 let ¦° be a logic program      1 and  1 three propositional formulas where  1 and  1 are in conjunctive normal forms.
1.  1 is called a consequence of   with respect to ¦° if |=      1 and each conjunct of  1 is ¦°-coherent.  1 is a strongest consequence of   with respect to ¦° if  1 is a consequence of   with respect to ¦° and there does not exist another consequence with respect to ¦° such that.
1.  1 is called a premiss of   with respect to ¦° if |=  1     and each conjunct of  1 is ¦°-coherent.  1 is a weakest premiss of   with respect to ¦° if  1 is a premiss of   with respect to ¦° and there does not exist another premisswith respect to ¦° such that
|=  1    1
example 1  example 1 continued  it is easy to verify that  sforgetlp ¦° {a}  c is a strongest consequence of forget  ¦° c {a}  and  wforgetlp ¦° {a}  c is a weakest premiss of forget. in fact  the following theorem confirms that this is always true. 
theorem 1 let ¦° be a logic program and p a set of atoms. then  sforgetlp ¦° p  c is a strongest consequence of forget  ¦° c p  with respect to ¦° and  wforgetlp ¦° p  c is a weakest premiss of
forget  ¦° c p  with respect to ¦°.
¡¡theorem 1 actually provides a precise semantic characterization for strong and weak forgettings in logic programs in terms of the forgetting notion in the corresponding propositional theory.
1	solving conflicts in logic program
contexts
in this section  we define a general framework called logic program context to represent a knowledge system which consists of multiple agents' knowledge bases. we consider the issue of conflicts occurring in the reasoning within the underlying logic program context. as we will show  the notions of strong and weak forgettings provide an effective way to solve such conflicts.
definition 1  logicprogramcontext  a logic programcontext is a n-ary tuple ¦² =  ¦µ1 ¡¤¡¤¡¤ ¦µn   where each ¦µi is a triplet  ¦°i ci fi  - ¦°i and ci are two logic programs  and fi   atom ¦°i  is a set of atoms. we also call each ¦µi the ith component of ¦². ¦² is consistent if for each i  ¦°i ¡È ci is consistent. ¦² is conflict-free if for any i and j  ¦°i ¡È cj is consistent.
¡¡in the above definition  for a given logic program context ¦²  each component ¦µi represents agent i's local situation  where ¦°i is agent i's knowledgebase  ci is a set of constraints that agent i should comply and will not change in any case  and fi is a set of atoms that agent i may forget if necessary. to simplify our followingdiscussion  we assume that for each component ¦µi  the corresponding agent's knowledge base ¦°i does not contain constraints  i.e. rules with empty heads . alternatively such constraints will be contained in the constraint set ci though ci may also contain rules with nonempty heads. now the problem of conflict solving under this setting can be stated as follows: given a logic program context ¦² =  ¦µ1 ¡¤¡¤¡¤ ¦µn   which may not be consistent or conflictfree  how can we find an alternative logic program context  such that ¦²1 is conflict-free and is closest to the original ¦² in some sense 
definition 1  solution  let ¦² =  ¦µ1 ¡¤¡¤¡¤ ¦µn  be a logic program context  where each ¦µi =  ¦°i ci fi . we call a logic program context ¦²1 a solution that solves conflicts in ¦²  if ¦²1 satisfies the following conditions:
1. ¦²1 is conflict-free;
1.   where ¦µ1i =  ¦°1i ci fi   and ¦°1i =
sforgetlp ¦°i pi  or ¦°1i = wforgetlp ¦°i pi  for some pi   fi.
we denote the set of all solutions of ¦² as solution ¦² .
definition 1  ordering on solutions  let ¦²  ¦²1 and ¦²1 be three logic program contexts  where  solution ¦² . we say that ¦²1 is closer or as close to ¦² as ¦²1  denoted as  each
¦µ1i =  ¦°1i  ci fi  ¡Ê ¦²1  where ¦°1i = sforgetlp ¦°i pi  or ¦°1i = wforgetlp ¦°i pi  for some pi   fi  and ¦°1i = sforgetlp ¦°i qi  or ¦°1i = wforgetlp ¦°i qi  for some qi   fi respectively  we have pi   qi   fi. we denote .
definition 1  preferred solution  let ¦² and ¦²1 be two logic program contexts. we say that ¦²1 is a preferred solution of ¦²  if ¦²1 ¡Ê solution ¦²  and there does not exist another ¦²1 ¡Ê solution ¦²  such that ¦²1  ¦² ¦²1. example 1 let ¦² =  ¦µ1 ¦µ1   where
¦µ1:	¦µ1:
	¦°1: a ¡û 	¦°1: c ¡û 
	b ¡û a notc 	d ¡û note 
d ¡û a note  e ¡û c  f ¡û d 	f ¡û d 
	c1: ¡û d notf 	c1: ¡û b notc 
	¡û notd notf 	b ¡û c 
	f1: {a b c} 	f1: {a b c d e f}.
it is easy to see that ¦² is consistent but not conflict-free because neither ¦°1 ¡È c1 nor ¦°1 ¡È c1 is consistent. now consider two logic program contexts  and
  where
  sforgetlp ¦°1 {c}  c1 f1  
  wforgetlp ¦µ1 {e} c1 f1   and
¡¡¡¡  wforgetlp ¦°1 {a c}  c1 f1     wforgetlp ¦µ1 {e} c1 f1 . it can be verified that both ¦²1 and ¦²1 are solutions of ¦²  but only ¦²1 is a preferred solution. 
1	semantic and computational properties
in this section  we study some important semantic and computational properties in relation to strong and weak forgettings and conflict solving.
1	semantic characterizations
we observe that the consistency of program ¦° does not necessarily imply a consistent sforgetlp ¦° p  or wforgetlp ¦° p  for some set of atoms p  and vice versa. for example  consider program ¦° = {a ¡û b ¡û nota notb}  then weakly forgetting a in ¦° will result in an inconsistent program{b ¡û notb}. similarly  strongly forgetting a from an inconsistent program ¦° = {b ¡û nota c ¡û b notc} will get a consistent program {c ¡û b notc}.
¡¡to understand why this may happen  we first introduce some notions. given program ¦° and a set of atoms p  we specify two programs x and y . program x is a subset of ¦° containing three types of rules in ¦°:  1  for each p ¡Ê p  if p 1¡Ê head ¦°   then rule r ¡Ê ¦° with p ¡Ê pos r  is in x;  1  for each p ¡Ê p  if p 1¡Ê pos ¦°   then rule r ¡Ê ¦° with head r  = {p}   x; and  1  rule r ¡Ê ¦° with neg r  ¡É p 1=   but not of the types  1  and  1  is also in x. clearly  x contains those rules of ¦° satisfying atom r  ¡É p 1=   but will not be affected by reduct ¦° p . on the other hand  programy is obtained as follows: for each rule r in x of the type  1   a replacement of r of the form: r1 : head r  ¡û pos r  not neg r    p  is in y . it should be noted that both x and y can be obtained in linear time in terms of the sizes of ¦° and p.
theorem 1 let ¦° be a program and p a set of atoms. a subset s of atoms occurring in sforgetlp ¦° p   or in wforgetlp ¦° p   is a stable model of sforgetlp ¦° p   or wforgetlp ¦° p  resp.  iff program ¦°   x  or  ¦°   x  ¡È y resp.  has a stable model s1 such that s = s1   p. theorem 1 presents an interesting result: given program ¦° and set of atoms p  althoughcomputingsforgetlp ¦° p  or wforgetlp ¦° p  may need exponential time  see section 1   its stable models  however  can be computed through some program that is obtained from ¦° in linear time.
¡¡now we consider the existence of  preferred  solutions for logic program contexts in conflict solving. it is easy to see that not every logic program context has a preferred solution. for instance  ¦² =   {a ¡û nota}       has no solution  and hence has no preferred solution neither. the following result shows that the existence of a ¦²'s solution always implies the existence of ¦²'s preferred solution  and vice versa.
theorem 1 let ¦² be a logic program context. ¦² has a preferred solution iff solution ¦²  1=  .
¡¡although deciding whether a ¦² has a  preferred  solution is np-hard  see theorem 1 in section 1   we can identify a useful class of logic program contexts whose solutions always exist  we have showed in our full paper that all major logic program update approaches can be transformed into the following form of conflict solving context .
proposition 1 let ¦² =  ¦µ1 ¡¤¡¤¡¤ ¦µn  be a logic program context. if for each ¦µi =  ¦°i ci fi   ci is consistent  and for each r ¡Ê ¦°i  fi ¡Éatom r  1=    then solution ¦²  1=  .
proof:	we	show  	where
¦µ1i =    ci fi   1 ¡Ü i ¡Ü n  is a solution of ¦². since for each i  fi ¡É atom r  1=   for each r ¡Ê ¦°i  we have ¦°1i = sforgetlp ¦°i fi  =    note that this is because we already assumed that ¦°i does not contain any rules with empty heads. instead  this type of rule is contained in ci . this follows that ¦°1i ¡È cj = cj for all j = 1 ¡¤¡¤¡¤ n are consistent. so     c1 f1  ¡¤¡¤¡¤    cn fn   is a solution of ¦². 
1	representing logic program updates
one major advantageof the proposedframeworkof logic program contexts is that it can represent new conflict solving scenarios for which the traditional logic program update approaches may not handle properly  like the one discussed in section 1  or example 1 . in fact  our framework can also represent previous logic program update approaches. to illustrate this  we take sakama and inoue's update approach  sakama and inoue  1  as an example  note that we need to restrict their approach to a normal logic program setting .
definition 1  sakama and inoue  1  let ¦°1 and ¦°1 be two consistent logic programs. program ¦°1 is a si-result of a theory update of ¦°1 by ¦°1 if  1  ¦°1 is consistent   1  ¦°1   ¦°1   ¦°1 ¡È ¦°1  and  1  there is no other consistent program ¦°1 such that ¦°1   ¦°1   ¦°1 ¡È ¦°1.
¡¡now we transform sakama and inoue's theory update into a logic program context. first  for each rule r ¡Ê ¦°1  we introduce a new atom lr which does not occur in atom ¦°1 ¡È¦°1 .
then we define a program  each r ¡Ê ¦°1  rule r1 : head r  ¡û pos r  not. that is  for each r ¡Ê ¦°1  we simply extend its negative body with a unique atom lr. this will make each  be removable by strongly forgetting atom lr without influencing other rules. finally  we specify ¦²si =  ¦µ1 ¦µ1   where
	1  	lr	r	and	   1   .
¡¡for convenience  we also use ¦° to denote a program obtained from ¦° by removing all occurrences of atoms in p fromthe negativebodies of all rules in ¦°. for instance  if ¦° = {a ¡û b notc notd}  then ¦° not{c} = {a ¡û b notd}.
now we have the following characterization result.
theorem 1 let ¦°1 and ¦°1 be two consistent programs  and ¦²si as specified above. ¦°1 is a si-result of updating ¦°1 by ¦°1 iff ¦°1 = ¦° not{lr|r¡Ê¦°1} ¡È ¦°1  where ¦²1 =   ¦°   {lr | r ¡Ê ¦°1}     ¦°1     is a preferred solution of ¦²si.
¡¡in our full paper we have showed that other logic program update approaches such as eiter et al's causal rejection and dynamic logic programming  eiter et al.  1; leite  1  for dealing with sequence of programs can also be embedded into our framework. in this sense  the logic program context provides a unified framework for logic program updates.
1	complexity results
we assume that readers are familiar with the complexity classes of p  np  conp  ¦²p1 and . the class of
dp contains all languages l such that l = l1¡Él1 where l1 is in np and l1 is in conp. the class codp is the complement of class dp  readers refer to  papadimitriou  1  for further details .
¡¡we observe that the main computation of strong and weak forgettings relies on the procedure of reduction that further inherits the computation of program unfolding. hence  in general computing strong and weak forgetting may need exponentialsteps of rule substitutions in terms of the sizes of the input program and the set of forgotten atoms. however  the following result shows that the inference problem associated to strong and weak forgettings still remains in conp.
proposition 1 let ¦° be a logic program  p a set of atoms  and a an atom. then deciding whether sforgetlp ¦° p  |= a  or wforgetlp ¦° p  |= a  is conp-complete.
proof:  sketch  the hardness is followed by setting p =    and the membership can be proved by using theorem 1. 
¡¡now we consider the complexity of irrelevance in relation to strong and weak forgettings and conflict solving. from a semantic viewpoint  the irrelevance tells us whether a strong/weak forgetting or conflict solving procedure will affect some particular atoms occurring in the underlying programs. hence  studying its associated computational properties is important.
definition 1  irrelevance  let ¦° be a logic program  p a set of atoms  and a an atom. we say that a is irrelevant to p in ¦°  if either ¦° |= a iff sforgetlp ¦° p  |= a  or ¦° |= a iff wforgetlp ¦° p  |= a.
¡¡we generalize the notion of irrelevance to the logic program context. formally  let ¦² be a logic program context and a an atom  we say that a is derivable from ¦²'s ith component  denoted as ¦² |=i a  if ¦µi =  ¦°i ci fi  ¡Ê ¦² and ¦°i |= a.
definition 1  irrelevance wrt logic program contexts 
let ¦² and ¦²1 be two logic program contexts where ¦²1 ¡Ê solution ¦²   and a an atom. we say that a is irrelevant with respect to ¦² and ¦²1 on their ith components  or simply say that a is  ¦² ¦²1 i-irrelevant  if ¦² |=i a iff ¦²1 |=i a.
theorem 1 let ¦° be a logic program  p a set of atoms  a an atom  and ¦² and ¦²1 two logic program contexts where ¦²1 ¡Ê solution ¦² . the the following results hold:
1. deciding whether a is irrelevant to p in ¦° is codpcomplete;
1. deciding whether a is  ¦² ¦²1 i-irrelevant is codpcomplete.
proof:  sketch  we describe the main idea of proving the hardness part of result 1. a is irrelevant to p in ¦° if  1  ¦° |= a iff sforgetlp ¦° p  |= a  or  1  ¦° |= a iff wforgetlp ¦° p  |= a. here we consider case  1  and proof for case  1  is the same. let  ¦µ1 ¦µ1  be a pair of
cnfs  where   and each ci and cj1  1 ¡Ü i ¡Ü n  1 ¡Ü j ¡Ü n  are sets of propositional literals respectively. we also assume
atom ¦µ1  ¡É atom ¦µ1  =  . we know that deciding whether ¦µ1 is satisfiable or ¦µ1 is unsatisfiable is codpcomplete  papadimitriou  1 . we construct a program ¦° polynomially based on set atom ¦µ1  ¡È atom ¦µ1  ¡È x  ¡È
y  ¡È {l1 ¡¤¡¤¡¤ ln p a sat¦µ1 unsat¦µ1 unsat¦µ1}  where any two sets of atoms are disjoint and |x | = |atom ¦µ1 | and |y | = |atom ¦µ1 |. ¦° consists of four groups of rules where atom p only occurs in ¦°1:
¦°1: rules to generate all truth assignments of ¦µ1 and ¦µ1; ¦°1: rules to derive unsat¦µ1 and unsat¦µ1 if ¦µ1 and ¦µ1 are unsatisfiable respectively;
¦°1: rules to force a truth assignment of ¦µ1 making  ¦µ1 true if unsat¦µ1 is derivable from ¦°;
¦°1 contains 1 rules: sat¦µ1 ¡û notunsat¦µ1  a ¡û sat¦µ1  unsat¦µ1 ¡û nota  p ¡û.
then we can prove that ¦µ1 is satisfiable or ¦µ1 is unsatisfiable iff  ¦° |= a and sforgetlp ¦° {p}  |= a  or  ¦° 1|= a and sforgetlp ¦° {p}  1|= a . 
¡¡finally  the following theorem summarizes major complexity results of conflict solving in logic program contexts. theorem 1 let be two logic program contexts  where for each ¦µi =  ¦°i ci fi  ¡Ê ¦²  1 ¡Ü i ¡Ü n   ¦µ1i ¡Ê ¦²1 is of the form ¦µ1i =  ¦°1i ci fi   where ¦°1i = sforgetlp ¦°i pi  or ¦°1i = wforgetlp ¦°i pi  for some pi   fi.
1. deciding whether ¦² has a preferred solution is np-hard;
1. deciding whether ¦²1 is a solution of ¦² is np-complete; 1. deciding whether ¦²1 is a preferred solution of ¦² is in ¦°p1  if strong and weak forgettings in ¦² can be computed in polynomial time 1;
1. for a given atom a  deciding whether for each ¦²1 ¡Ê solution ¦²   ¦²1 |=i a is in ¦°p1  if strong and weak forgettings in ¦² can be computed in polynomial time.
1	conclusions
in this paper  we defined notions of strong and weak forgettings in logic programs  which may be viewed as an analogy of forgetting in propositional theories. based on these notions  we developed a general framework of logic program contexts for conflict solving and studied the related semantic and computational properties.
¡¡our work presented in this paper can be extendedin several directions. one interesting topic is to associate dynamic preferences to sets of forgettable atoms and components in logic program contexts  so that the extended framework is more flexible to handle task-dependent conflict solving. 