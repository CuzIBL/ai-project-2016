abduction with hypotheses confirmation 
marco alberti1  marco gavanelli1  evelina lamma1  paola mello1  and paolo torroni 1 endif - university of ferrara - via saragat  1 - 1 ferrara  italy.
{malberti|mgavanelli|elamma} ing.unife.it
1 deis - university of bologna - viale risorgimento  1 - 1 bologna  italy. {pmello|ptorroni} deis.unibo.it
모
1 introduction
abductive logic programming  alp  is an extension of logic programming to formalise hypothetical reasoning. it typically distinguishes between facts  defined within a static theory and known to be true or false  and potentially true  abducible atoms  hypotheses .
모however  in most applications  this distinction is not adequate to capture the dynamics of knowledge  as reasoning is confronted with an environment in evolution. it may turn out that some hypotheses gain or lose strength  as events happen in the world. for example  in the medical domain  where a kind of hypothetical reasoning is the diagnostic inference  we can model symptoms as observations and diseases as  not directly measurable  hypotheses: test results and new possibly upcoming symptoms  instead  are none of these  and should be interpreted as hypotheses confirmable by events.
모an abductive derivation verifies a goal by using deduction as in logic programming  but also by possibly assuming that some abducibles are true. in order to have this process converge to a meaningful explanation  an abductive theory normally comes together with a set of integrity constraints ic  and it is required that hypotheses be consistent with ic.
모in our extended framework  we distinguish between two classes of abducible literals: hypotheses  as classically understood  and expectations about events. expectations can be  positive   to be confirmed by certain events occurring   or  negative   to be confirmed by certain events not occurring .
모we propose a new language to define abductive logic programs with expectations  inspired to the iff proof procedure  fung and kowalski  1   and whose semantics extends those of classical alp. the language permits to express abducible hypotheses and expectations with variables and constraints. within this new framework we can model and reason about a number of concrete application scenaria. our framework permits  e.g.  to reason about deadlines  and to express and correctly handle expectations with universal quantification: this typically happens with negative expectations   the patient is expected not to show symptom q at all times  .

모모  this work is partially funded by the information society technologies programme of the european commission under the ist1 socs project  and by the miur cofin 1 projects sviluppo e verifica di sistemi multiagente basati sulla logica  and la gestione e la negoziazione automatica dei diritti sulle opere dell'ingegno digitali: aspetti giuridici e informatici.모the operational semantics is an abductive proof-procedure which builds on the iff and is proven sound for a relevant class of programs. it has been implemented using constraint handling rules and integrated in a java-based system for hypothetical reasoning  alberti et al.  1 .
1 dynamic alp
an alp  kakas et al.  1  is a tuple hkb ic ai where kb is a logic program  a is a set of predicates called abducibles not defined in kb  and ic is a set of formulae called integrity constraints. an abductive explanation for a goal g is a set     a s.t. kb뫋  |= g and kb뫋  |= ic.
모new dynamically upcoming events are encoded into atoms h descr  time   where descr is a ground term representing the event and time is an integer representing the time at which the event happened. such events are recorded into a set  called history  or hap  containing h atoms. a dynamic abductive logic program  dalp  is a sequence of alps  each grounded on a given history. we will write dalphap to indicate the abductive logic program obtained by grounding the dalp with the history hap. the history dynamically grows during the computation  as new events happen.1
모an instance dalphap of this framework can be queried with a goal g  that may contain both predicates defined in kb and abducibles. the abductive computation produces a set   of hypotheses  partitioned in two sets: general hypotheses   a  and expectations  exp   containing positive expectations  in the form of e descr  time   atoms   and negative expectations  en  descr  time    atoms .
모typically  expectations will contain variables  over which clp constraints can be imposed. variable quantification is existential in e expectations  and universal in en expectations  unless the same variable is used outside of such expectation . explicit negation can also be applied to expectations.1 constraints on universally quantified variables will be considered as quantifier restrictions. for instance  en p x   
x   1 has the semantics  x 1 en p x  .
모the declarative semantics for dalphap is based on its ground version  and considers clp-like constraints as defined predicates. first  an abductive explanation should entail the goal and satisfy the integrity constraints:
	comp kb 뫋  a 뫋 exp 뫋 hap  |= g	 1 
       comp kb 뫋  a 뫋 exp 뫋 hap  |= ic  1  where  as in the iff proof procedure  the symbol |= stands for three valued entailment and comp stands for completion.
모among the sets of expectations of an instance dalphap  we select the ones that are consistent with respect to expectations  i.e.  the same event should not be both expected to happen and not to happen   and that are confirmed:
definition 1 a set exp is e-consistent iff for each  ground  term p: {e p  en p } 1  exp.  1 
모given a history hap  a set of expectations exp is confirmed if and only if for each  ground  term p:
comp hap false	 1 
we write dalphap뫘 a뫋expg if equations  1  hold.
모the operational semantics is an extension of the iff. each state is defined by a tuple defining confirmed  disconfirmed  and pending expectations  along with the resolvent  the set of abduced literals that are not expectations  the constraint store  a set of partially solved integrity constraints  and hap.
모a derivation d is a sequence of nodes tj  where the initial node t1 contains the goal g as the initial resolvent  and the other nodes tj j   1  are obtained by applying one among a set of transitions  until quiescence.
definition 1 starting with an instance dalphapi there exists a successful derivation for a goal g iff the proof tree with root node t1 has at least one consistent leaf node tn  i.e.  there exists for tn a ground variable assignment such that all the constraints are satisfied . in that case  we write:
	dalphapi몲hap a뫋expf	g
모the transitions are those of the iff  enlarged with those of clp  and with specific transitions accommodating the concepts of hypotheses confirmation and evolving history.
모the clp fd  solver has been extended for dealing with universally quantified variables and quantifier restrictions. for instance  given two expectations  x 1en p x   and  y 1e p y     the solver is able to infer  y뫟1e p y   . to the best of our knowledge  this is the only proof-procedure able to abduce atoms containing universally quantified variables; moreover  it also handles constraints a la` clp on universally quantified variables.
we proved soundness for allowed dalps:1
theorem 1 given dalphapi and a ground goal g  if dalphapi몲hap  g then alphap뫘 g.
1 case study
we conclude with an example from the medical domain to show two main contributions of our work: the dynamic detection of new facts  and the confirmation of hypotheses by events. suppose a symptom s can be caused by one of three types of diseases. let disease d1 be an acceptable explanation for s if the patient is not also affected by d1  and in such a case the patient's temperature cannot go below 1oc. s may alternatively be caused by disease d1  and in this case red spots are expected to appear on the patient's skin within 1 days. finally  d1 may be the cause of s  provided that an exam r gives a positive result:
symptom s t1  뫹 disease d1 t1  뫇 not disease d1 t1  뫇en tem t  t1  뫇 t   1.
symptom s t1  뫹 disease d1 t1 뫇
모모e red spots t1  뫇 t1   t1 뫞 t1 +1. symptom s t1  뫹 disease d1 t1  뫇 e exam r +  t1 .
 the initial goal can be the observation symptom s 1 . we model disease as a classical abducible  whereas expectations are used to corroborate the explanations.
모notice the twofold use of expectations: both in the second and third clause  the expectation defines a further event that can support the diagnosis. but while e red spots t1  simply defines the expected course of illness  in order for the diagnosis to be corroborated   e exam r +  t1  can also be intended as a suggestion to the physician for a further exam to be done  or as a request of further information.
모the combinations of abducible literals can be refined by means of ics. for example  if the result of some exam r is positive  then we can assume that the patient is not affected by disease d1: h exam r +  t1  뫸 not disease d1 t1 . the dynamic occurrence of events can drive the generation and selection of abductive explanations. if the query is  e.g.  symptom s 1   there can be three alternative explanations:
{disease d1    t 1en tem t  1 }  {disease d1    1 t1뫞1e red spots t1 }  and {disease d1  e exam r +  1 }.
if event h tem 1  1  happens  the first set contains a disconfirmed expectation:  t 1 en tem t  1   so it can be ruled out. if  within the deadline t1 뫞 1  the event red spots does not happen  the second set is excluded as well  and only the third remains acceptable.
모finally  integrity constraints could suggest possible cures  or warn about consequences of not taking certain drugs:
disease d1 t1  뫸 e aspirin t1 
뫈e tem t  t1  뫇 t   1 뫇 t1   t1 +1.
1 conclusions
we presented sciff  an abductive proof-procedure able  beside proposing explanations  to infer expectations about the happening of events. expectations are abducibles  but more expressive: they can contain universally quantified variables  possibly with clp constraints. they can represent requests for information  or the expected evolution of a system. sciff is able to process dynamically incoming events to confirm the expectations  providing corroboration to abduced hypotheses. 