 lisp machine. 
     those are the current extreme points of architectural support; in the future even more architectural support is possible  such as direct execution of lisp. 
     the extreme points of philosophy derive from different values placed on the perceived efficiency versus the clarity of code  and the concomitant ease of writing it . implementing a large portion of the lisp system in assembly language or in microcode provides an excellent low-level programmer an opportunity to exploit the architecture completely. microcoded machines often allow type-checking to occur in parallel with other operations; this can allow type-checking in more circumstances without efficiency loss than might be possible in a stock-hardware implementation  and the microcoded implementation can be made 'safer.' 
　　with a lisp-in-lisp  the other philosophical extreme  efficiency is partially forfeited for ease of writing  ease of certification  and case of portability. the observation is that lisp programmers have already accepted the compiler as sufficiently efficient for their own code  and with a lisp-in-lisp they only sacrifice some interpreter and storage-allocation speed. as compiler technology advances this sacrifice may diminish. 
	iii 	our i m p l e m e n t a t i o n 
     our implementation is centered on three major tools; a compiler  an assembler and a cold-loader. all of these are written in a common subset of common lisp  our target lisp  and maclisp. 
　　the lisp system is created by compiling all of the functions that define it  assembling them  and constructing the binary image of an initial system on a disk file. 
     our compiler  brooks 1a  is a sophisticated optimizing compiler based on the rabbit compiler 
 steele 1  and on the bliss-1 compiler  wulf 1 . 
     since the kernel of the implementation manipulates data tags and generates pointers  the compiler must open-code special sub-primitives. for example  there are sub-primitives to perform arithmetic on 1bit quantities  and to set and retrieve tag and data fields-turning them into fixnums. 
　　the code generators in the compiler have no detailed knowledge of the computer's 1 addressing modes. an optimizing assembler takes care of such details; it performs branch/skip optimizations and outputs various literals that must be created upon loading. 
     the cold-loader builds an initial core image in a disk file. it first builds an internal data structure for a 
     skeleton core image which includes a stack with a stack frame for a start up function  a vector of initial register values  copies of special atoms such as nil and t  and a kernel of the tables needed for storage management. it writes the associated word values into the output core-image file. then it uses the same linking loader  compiled in maclisp  that is used in the target lisp environment  with file-output routines substituted for memory-writing routines  to load assembled lisp files into the initial core-image. the storage-allocation routines of the linking loader access the simulated data structure rather than the in-core tables they access when used in the target lisp. in this way the linking loader  a stream-based i/o system  a lexical interpreter  a reader  a printer  some debugging tools  and part of the storage-allocation system and garbagecollector interfaces and tables are loaded into the initial core-image disk file. 
	iv 	advantages 
　　there are two major advantages to lisp-in-lisp: the first concerns the ease of writing correct lisp code for the system; the second concerns portability. 
     with lisp-in-lisp  difficult pieces of code can easily be written correctly. typically the most difficult code to write and debug  or prove correct  is the garbage collector and storage-allocation routines. the garbage collector  since it operates on data not available to normal lisp code  has traditionally been written in assembly language. a lisp-in-lisp system defines a set of sub-primitives that operate on pointers directly  and the compiler open-codes them. 
　　implementing sub-primitives as compiler code generators has three advantages. first  the.template of code that is correctly supplied will be correctly applied in more situations than were anticipated by the writer of the code generator. the code-generator writer produces a template or an abstraction of the code sequence needed to perform the action; the compiler  and the register allocator in particular  can then supply the addressing modes and data transfers needed to correctly apply the abstract sequence of actions in any situation. 
     second  routines written in a high-level language can be proven and debugged more easily. relatively large-scale modifications can be made without worry about early commitment to storage layout or register assignments. 
　　third  code can be tested within an existing lisp environment using its programming tools and v/ith the knowledge that it is a correct language and environment. thus errors in the implementation design and code generators can be isolated from errors in the lisp code  the latter being eliminated while testing in the existing lisp system. 
　　there is a third spectrum in addition to the architectural support and philosophical outlook spectra mentioned above-the portability spectrum. along this spectrum we claim that the microcode-supported lisp systems and the large runtime-supported lisp systems occupy one end  the least portable end  and lispin-lisp systems occupy the other end  the most portable end . 
　　the task of writing microcode  is comparable to the task of writing a large runtime system; when portability is needed  a compiler that assumes code generators for sub-primitives can be more easily portable than one that produces code for a stack machine. for a compiler that produces code for a stack machine  each abstract-machine instruction emitted requires microcode or macrocode support  or else each such instruction must be expanded into native machine code  as cmacros in rsl are expanded . 
　　if each abstract-machine instruction is expanded as part of the last  code-producing pass of the compiler  then register-allocation decisions depend only on earlier register-allocation decisions. this renders high quality register-allocation and  hence  high performance difficult to achieve. 
　　in a lisp-in-lisp environment the large runtime system is written in lisp and only the components needed to piece that system together  the subprimitives  are hand-coded as simple code generators. therefore the portability of a lisp-in-lisp system is the highest- along this spectrum. 
　　portable standard lisp  psl   griss 1  is the closest to the s-i lisp in terms of being a true lisp-in-lisp. the s-l implementation has a more advanced compiler and is  therefore  of higher performance. interlisp-d  burton 1   moore 1  is a lisp-in-lisp system where the sub-primitives required are written in microcode. interlisp-vax uses the tnterlisp-d lisp-in-lisp code  but it demonstrates compiler/architecture mismatch  masinter 1   gabriel 1   gabriel 1 . 
　　t  rees 1  uses an early version of the s-l compiler  adapted to the vax. 
	v 	an e x a m p l e 
　　the s-l compiler's internal language is an expression language-a graph easily derived from the tree structure of the standard internal representation for lisp code. each node in the graph represents a lisp language construct  and backpointers to other nodes may be present to link interesting pairs of nodes  such as lambda-binding nodes and variable-reference nodes . there is no commitment to any particular architecture in this scheme. moreover  the register-allocation is table-driven  and no part of the compiler assumes any registers exist. 
　　the following function illustrates the advantages and style of li1p-in-lisp. it demonstrates the efficiency of the s-l compiler by comparing the output of the 
r. brooks et al. 1 
compiler for a common runtime function with a handcoding of that function. +& takes any number of fixnums and returns their sum. ignoring type-checking of arguments  the following code provides the definition for the interpreter: 
 defun + &  &rest numbers  
 do   nums numbers  cdr nums   
 sum 1  +& sum  car nums     
  null nums  sum    
where the use of +& in the function definition is opencoded. 
　　this code is easily seen to be correct whereas the assembly language coding of it may be difficult to do correctly  especially on an architecture as complex as the s-l. 
　　the compiler-produced code for this function comprises 1 instructions. one tests that the function was called properly; two instructions cons up the &rest argument into a list; two instructions move into registers the initial values for nums and sum; three instructions manage the loop and perform the computation; five instructions set the tag field for the return value and return from the function; and one instruction is a jump from the beginning of the code to the end test  which appears at the bottom of the loop code. 
　　a hand-coded version of this function displays one major optimization: it eliminates the call that listifies the &rest argument by taking the arguments off of the stack directly. we do not see an easy way that the compiler can perform this optimization in general  at the moment. 
	v i 	difficulties 
　　the key to the success of a lisp-in-lisp portable to a variety of machines is the existence of a portable compiler. with such a compiler the job of writing code generators and tables should be much less than the job of building or microcoding a computer on one hand  and much less than writing a large runtime system on the other. 
　　assembly language code may need to be written in addition to the lisp code. in s-l lisp the consing routines have been hand-coded for efficiency and are accessed through a simpler function-call than normal lisp functions. 
　　our approach demands an existing lisp implementation that is compatible with the one being developed. we use maclisp  moon 1 . 
　　in the absence of a portable compiler  a desirable component for a lisp-in-lisp implementation is a compiler that produces efficient code. one can start with a 

1 r. brooks et al. simple  but correct  lisp compiler and move to a highly optimizing compiler later. 
	vii 	statistics 
     our compiler understands 1 special forms and open-codes 1 lisp primitives  1 of which are subprimitives that user-level code would not normally use. the initial environment is 1 lines of assembly language code; 1 lines-about 1%-is hand-written. 
     we could have written the whole lisp system in lisp and written enough code generators to have every instruction generated by the compiler. we hand-coded certain portions in assembly language for three reasons: 
- efficiency. to avoid the overhead of a fully general lisp function-call for such common functions as cons  list  list*  and all of the number-consers  they must interact with the storage allocation data structures so they cannot be open-coded   a special  fast procedure-call mechanism is provided  and the consers themselves are carefully hand-optimized. the compiler compiles cons  for instance  as a fast procedure call. other  less common  consing functions  e.g. cons-in-area  are completely written in lisp. the consers account for 1 lines of code. 
- single use. certain primitive operations  most notably those that interface with the operating system i/o facilities  need only be referred to by one piece of lisp code. rather than write code generators for these primitives it is just as easy to write the code directly. these primitives open  close  and delete files; transfer ascii characters and quarter words to and from buffers and thence to and from files; and transfer ascii characters to and from the terminal. these account for 1 lines of code. trap handlers also fall under the single-use category and account for 1 lines of code. 
- long code sequences. certain common operations lead to identical and lengthy code sequences. the fast procedure-calling mechanism developed for the consers is used to replace these sequences by jumps to single copies of them. there are two classes of such code sequences. s-l lisp uses deep-binding with caching  gabriel 1 . 1 lines of code provide functions to lookup  bind and cache special variables on the stack. the functionreturn interface for multiple values requires vectors and lists to be unbundled onto the stack and into registers in a particular way; 1 lines of code provide these functions. 
	v f f l 	conclusions 
　　we have implemented a lisp-in-lisp on a complexinstruction-set computer. the bulk of development time has been put into the optimizing compiler  which has been written with a clean partition between the machine-independent and machine-dependent parts. the remainder of the lisp system required very few man-months to write and debug. 
     the speed of modern computers minimizes the need to squeeze every ounce of efficiency from them; the need to produce correct  understandable  and modifiable lisp implementations rapidly is increasing. as more architectures become available to the at community the methodology we have used in this project should become more widespread. 
	v i i 	