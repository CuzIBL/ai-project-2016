 

a introduction 
　our studies of how people design algorithms  1  reveal that symbolic execution is one of the principal design methods used in the absence of specific knowledge 1 and we believe that symbolic execution will play an equally important role in the automatic design of algorithms. when specific design knowledge indicating what to do next is available  it should of course be followed. in its absence  however  executing an incomplete design allows an assessment of the consequences of the current set of design decisions to help decide on a next step. this execution may be either on specific data such as {point e  point b}  on abstract symbols such as  point-set   or on combinations of specific and abstract objects. by symbolic execution we mean the process of describing outputs in terms of inputs that are primarily abstract rather than concrete symbols. however  a continuous range of evaluation from wholly symbolic to wholly concrete falls under this heading  and all variants make contributions to the design process. when all items are concrete data values  we refer to the evaluation process as test-case execution. 
symbolic execution  also called symbolic evaluation  has been studied as an independent software engineering tool for use after a program is written  but until recently little work has extended and integrated it into tho problem solving processes in design.1 in this paper  we focus on symbolic execution in design by describing our model of algorithm design  a system that implements that model  and illustrate the use of symbolic execution in a detailed example. 
　most of the early research on symbolic execution focused on execution or evaluation of complete programs to aid in testing  debugging  and verifying conventional languages. some more recent work considers evaluating  analyzing  and explaining higher level specification languages this related work is discussed in section e since our primary interest is automating algorithm design  we operated independently of these efforts  although similar concepts appear in our system. we developed a model of algorithm design based on the analysis of some fifteen protocols of subjects designing geometric algorithms. the model underlies the implementation of an automatic algorithm design system we call designer . symbolic execution in this model shares a number of concerns with traditional symbolic execution: serving as an inexpensive test process that effectively executes multiple inputs simultaneously; creating symbolic representations of outputs as functions on inputs  useful for generating invariants and formally verifying programs or algorithms ; describing the conditions for following each path to detect non-executable segments and to define subdomains of the input; indicating coverage of concrete test data and helping to generate additional tests. we are concerned also with symbolically executing procedures efficiently  not by macro substitution . the features of designer that differ from most other systems and modify symbolic execution for design purposes are: 
1. designer executes incomplete algorithms in a dataflow language rather than requiring a full program in a procedural language. 
1. failures in symbolic execution lead to the posting of difficulties. other problem-solving processes in the system use this information to correct errors in the design automatically. 
1. the data objects in designer may be arbitrarily complex structures  e.g. geometrical objects or sets . in contrast  most symbolic interpreters allow only variables subject to conjunctions of numerical constraints  which are inadequate to represent many algorithms.  however  there is no guarantee that 
　　the execution of program plans on concrete data for debugging during design was however suggested a decade ago the execution of plans in problem solving  which har  been more heavily researched  for example  1   is also related. 
1 	d. steier and e. kant 
these more complex structures can be reasoned about satisfactorily in all cases.  
1 designer represents the results of multiple execution paths as disjunctions of conditionals on a single object rathei than requiring the user to specify the execution path s  
1 execution is controlled by assertions and rules rather than by a fixed interpreter  so it can be customized to serve a variety of design goals. 
1 multiple options in symbolic execution address a variety of design goals such as determining the run time of an algorithm  checking for consistency between adjacent steps in a design  and verifying that an algorithm produces the desired output. 
　an initial implementation of symbolic execution embodying most of the principles described in this paper is operational in designer. algorithms are represented as collections of object instantiations in a object-based system with a few simple forms of inheritance; symbolic execution operators are implemented in lisp; and symbolic execution control rules are written in the production-system language opss . this implementation has symbolically executed algorithms in several task domains including geometric algorithms  such as finding the convex hull of a set of points   set operations  and numeric algorithms  such as fibonacci and recursive factorial . work continues on enlarging the set of geometric algorithms that can be represented and executed. 
b the design model 
　in refining our model  we have concentrated on the following areas: definition of a dataflow representation for partial algorithm descriptions  implementation of operators for altering and executing the descriptions  collection of algorithm design heuristics in a number of task domains  specification of a subsystem for reasoning with visual images in geometric algorithm design  and development of a problem solving architecture for handling non-hierarchical goals effectively. descriptions of this work have been published previously or will appear in future reports  so only the details needed to understand the role of symbolic execution are presented here. 
　one driving force in this research is the formulation of the problem spaces  in which the algorithm design activity takes place. this requires a precise definition of the representations for algorithm design and of the operations used to manipulate these representations. it also requires definition of the problem spaces for the task domains  not discussed in this paper . 
the major algorithm problem spaces are design and execution. 
the spaces share the same basic representation  but address different types of problems and make use of different operators. in the design space  the states are partial descriptions of algorithms. the current design state is elaborated by the application of design operators  that edit algorithm descriptions  until a satisfactory specification is obtained  satisfactory is defined dynamically by the design rules . the algorithm modification process is guided by rules that describe what operators to apply to change the partial algorithm description; the rules have conditions that determine their applicability to the current state. if the search control knowledge is not sufficient to select a design operator  the problem solver sets up a subgoal to obtain this knowledge. the subgoal is usually satisfied by problem solving in another space  often the execution space. 
　execution is an information-gathering strategy that executes the current description of the algorithm on symbolic or actual data objects to expose problems or opportunities for refinement. in the execution space  the partial description of an algorithm is fixed  and the data objects change in structure and position to yield the different states. if execution on symbolic data doesn't produce enough information for further refinement  or if a concrete validation of the algorithm is desired  then a concrete example is generated  actual data items are substituted for the symbols. symbolic execution is preferable to test-case execution in many cases. for example  it amasses more complete information for verification  and it may be better to use a description such as  integer less than 1  than actually to pick one  when the system is looking for a counter example or example and doesn't have all the constraints on an object yet. however  symbolic execution can be more expensive if considerable expression simplification is required. furthermore  discoveries caused by the combination of unexpected assertions and previous experience are more likely to result from working with concrete examples than from abstract reasoning based on the results of symbolic execution. 
c representing algorithms for design and execution 
　we have developed a language called al  algorithm language  for representing algorithms during the design process.1 some key features of this representation  which distinguish it from similar representations  such as the plan calculus of the programmer's apprentice  1  1  1    are its data-flow character  the fact that control flow can be defined implicitly by data-flow links rather than control-flow links  with a few exceptions   and the small number of initial built-in processes. also  in the programmer's apprentice  all loops must be expressed as recursive calls  while in al they can be expressed iteratively. in al. the spectrum of description levels  from kernel ideas to fully refined algorithms  is easily represented. a consequence of this representation is that concern with the representation of data objects is largely absent initially  except in algorithms that rely on special data structures  in favor of elaboration of the processes manipulating data objects. 
　in developing al  we tried to identify a set of algorithmic objects that correspond closely to the conceptual building blocks our subjects use. we call such blocks components. components are connected by links between ports  for input or output  of the components. a few basic component types are assumed  and the processing of a component may be modified by assertions on the component. new components may also be defined at any time in terms of other components and assertions. our assertional language is a variant of first-order predicate calculus that can express the state of computations over time. a collection of components  links  ports  and assertions grouped together forms a network called a configuration. configurations are the partial algorithm descriptions. 
　this framework is not the basis for a  pure  data-flow representation. our goal is to use objects that occur naturally as algorithmic steps  not a minimal set of primitive components. to avoid proliferation of object types  a design idea is initially represented as a component of approximately the right type with 
descriptive assertions. 	as design proceeds  any component 
   1 the level of detail in al approximates that which people use to describe algorithms to one another. we do not claim that al is an exact cognitive model for human algorithm design  only that the character of the language is useful for automated design. 

representing a complex process that does not correspond directly to a single primitive action may be refined into a complete configuration called a refinement configuration. this ability to refine components into sub-configurations along with the ability to define new concepts by adding assertions to simpler concepts provides a natural abstraction mechanism in al. 
 only a brief overview of al's type hierarchies of components  ports  links and assertions will be given here since a detailed language description is the subject of another report in preparation . 
  components: in al  active process components represent steps in algorithms: algorithms are generic procedures to be refined; applies create new data based on their inputs; selects extract an element from an input collection; recursive-calls apply a process recursively; tests conditionally alter the data flow; compares report the relationship between two items and generators produce individual items from a collection in any specified order. another type of component is the memory  which holds a representation of an object or collection. 
generators cause certain components to be repeatedly executed. as the algorithm design proceeds  it may be necessary to represent this repeated computation explicitly  which we do with a loop box we classify the computation in a loop into separate configurations by function  the initialization  the loop-body  the repetition and the termination. all parts of a loop-box are optional  although the absence of an essential part may lead to a 
semantically incorrect design  during refinement  it is expected that some of the paits will be empty. 
  ports. input ports and output ports represent data inputs and outputs of components  while signal ports serve control functions on specific component types  such as resetting a generator. 
  links: links usually connect components or configurations at the same level of the hierarchy. special kinds of links  vertical-input links and vertical-output links  connect components to their refinement subconfigurations. 
  assertions: assertions are classified in al by the domain of the operations they describe  for example numerical assertions and geometrical assertions. when used in a data-flow configuration  each assertion instance is assigned a role in accordance with its use. roles relevant to symbolic execution are operational assertion  to specify how a component's output is derived from its inputs; description  to describe a data item; precondition and postcondition  to assert that certain conditions hold before and after the execution of a component; and complexity  to state time or space required for the execution of a component. other assertions specify constraints on the order of execution the algorithm's components. some of these assertions are predefined as being relevant to execution of all instances of a given type; for example  all selects must have a composite object as one of their inputs. other assertions are added during the design phase to specific component instances; for example  a particular generator produces elements from its input collection in 
	d. steier and e. kant 	1 
increasing order  a particular test places its input numerical item on the true-exit port if the value of the item is greater than one. 
　configurations are executed  in the execution problem spaces  on items. items are data objects that are passed between components and stored on links. items have associated domains  such as geometry and arithmetic. several items may be grouped together into a collection  which correspond to mathematical sets or sequences . items may represent concrete objects or symbolic objects. 
　an example of a configuration representing a partially refined convex hull algorithm1 is given in figure 1. the specification given to the subject is to find the convex hull of a set of input points where a convex hull is defined as either a polygon made up of a subset of the input points that encloses all the input points or the set of points on that polygon. this ability to view the output as either a set of points or a polygon turns out to be important during the design. the inside predicate that defines enclosure is defined in the geometry space  it assumes that a point on the boundary of a polygon is inside the polygon  it is not necessary for the discovery that inside be defined by logical assertions as long as there is a domain space operator to recognize examples of enclosure. the assertion is written as follows: 

in the diagrams below this relation will be abbreviated to convex-hulloutput  input . 
　the configuration of figure 1 represents an intermediate state in an initial attempt to get a working algorithm without using sophisticated design principles. the derivation is similar to one followed in a protocol that we have studied closely. the kernel schema follows the transfer paradigm as described by barstow  in which the points in the input set are generated by the producer and built into an output set by the consumer. during the previous part of the design  not described here  this kernel schema was refined into a loop. in the graphic representation of our language  all configurations belonging to the same loop are enclosed in the same loop-box in a special format: initialization at the left side  termination at the right side  and repetition along the bottom. on each iteration of the loop  the algorithm arbitrarily selects a point  in select s1  from the set of input points that have not yet considered  stored in memory m1   adds the point to the set of points found to be on the hull so far  stored in memory m1   and then tests if the expanded set could be included in the hull  in test t1 . if the test returns false  then the point just added is selected  in select s1  and deleted from m1. symbolic execution of the kernel schema led to an expectation  recorded as an assertion  of an algorithm linear in the number of input points. the linear expectation arises because the producer is expected to be executed at most once for each input point to produce all the 
　　the convex hull algorithm discovered by this subject is not s particularly efficient one. many other convex hull algorithms have been developed  and the problem can be solved in n iog n time. 

1 	d. steier and e. kant 
points on the hull. the refinement has not yet been symbolically executed to analyze its run time  so the fact that this expectation is not fulfilled has not yet been discovered. we will continue this example in the next section. 
d symbolic execution in designer 
　one way to view the design process in our model is to consider each modification of a design as the imposition of a new constraint on the behavior of the algorithm. to usefully guide refinement  the constraints imposed by altering one part of the configuration must be propagated since typically refinement of algorithms is strongly locally driven. the propagation of a constraint imposed by one part of an algorithm serves to focus attention on potential problems in development of other parts of the algorithm and to bring together new combinations of facts that may lead to additional opportunities. this selective propagation of configuration-derived constraints is driven by execution. 
　symbolic execution manipulates assertions on symbolic items that arrive on the input ports of a component to produce appropriate assertions on items on the output ports. the assertions on the output items describe the results of applying operations defined by the component and its operational assertions to the input items. symbolic execution continually evaluates assertions and compares the results against expected values determined locally by the component being executed. if an expectation is violated  then a difficulty is posted to notify the rest of the system of the inconsistency. knowledge of the inconsistency combined with search-control knowledge in the design space should guide the problem solver in selection of the next operator to apply. this process allows detection of interactions between components in a uniform and efficient manner. a more detailed description of the symbolic execution process may be found in another paper . 
　here  we show how symbolic execution can be used to integrate a test predicate discovered in the domain space  geometry  into the current design and to notice that the algorithm is not linear  as was originally expected. details of the discovery of the test predicate have been described elsewhere   and so will not be repeated here. the original goal was to find a test to determine if a point is on the hull  but the discovered predicate tests if a segment is not on the hull  a segment is not on the convex hull of a 
　set of points if there are not points on both sides of the line segment . therefore the system must modify the design to make use of the predicate. as a first approximation  the test is initially represented as an assertion on test t1. 
operational-assertion  test predicate  on t1: points- both-sides{segment input  input  
　since this assertion has just been added to t1  t1 is symbolically executed to see if it is fully refined the first problem that is uncovered is that the inputs are not well defined  because the operational-assertion requires different input than is currently available first  there is only one input port  and there need to be two ports  so execution is suspended  and another port  we'll call the existing one p1 and the now one p1  is added. a link is attached to the new port and preconditions on inputs to the test are added to distinguish p1 and p1: 
precondition on t1: 

　using execution in this manner to uncover problems is an important part of designer. when a configuration can not be successfully executed  a problem called a difficulty is posted in the form of a goal or subproblem to be solved  not necessarily in the design space  if the initial assertions are correct and the inference mechanism is correct and adequate  the configuration 


assertions: 
operational assertion  selection criterion  on s1: 
operational-assertion  selection criterion  on s1; description on input: 
description on input  output: 
complexity on ch: 
description on m1: 
postcondition on m1: postcondition on t1: 
	figu re 	1: fragments of a dataflow configuration for generating a sequence of hull points. 

lat implements the specifications is causing the problem  so a ifficulty indicates that some element of the current configuration eeds to be altered or refined. the difficulties fall into a small umber of categories. since the design rules need only cover lese few categories of failure  a few rules and a relatively simple roblem-solving architecture allow designer to make progress in tost cases  regardless of the task domain. 
to continue the example  when symbolic execution of t1 is  tempted again  the precondition on the inputs to t1 are ompared to the descriptions of the input items. the clause in the recondition about p1 is not satisfied because the current link to 1 does not contain the entire input  only a subset of it. there is a esign rule that applies to this problem: 
   if a precondition is not satisfied by an input link in the current design  and there is another output in the current configuration that will satisfy this precondition  then detach the input link from its present source and connect it to the desired output. 
when this rule fires  the link feeding p1 will be detached from m1 nd connected to input. the other clause of the precondition is ill not satisfied though  since p1 is not connected to anything roducing a segment. the previous rule will not apply  since no sgment is present in the design. a new item must be created  hich means that a component with a useful operational-assertion 
lust be added to the configuration  but another rule does apply: 
   if a precondition is not satisfied by a link attached to a port in the current design  but it is known that an apply component with an appropriate operationalassertion can create a component with the required output  then add an apply to the configuration with the required assertion and connect its output to the port described by the unsatisfied pre-condition. 
in this case  the post condition required is that the output of the pply is a segment this knowledge is used to find the perational assertion for the apply by searching the domain knowledge base of the system for an assertion with an appropriate ost-condition. this search suggests a draw segment as an ssertion. so apply a1 is added with a draw-segment assertion hich takes a head point and a tail point and produces the 
egment connecting the two points. 
operational-assertion  apply action  on a1: draw-segment {point- input  paint-input  
in this example  since a1 has just been added  that component is symbolically executed to see if it is complete. symbolic execution gain points out the difficulty that ports and links are missing from e segment-constructing component and collects information bout the inputs. one point that is available is the point produced y s1  so a link is added from s1 to a1. unless directed otherwise   e same input should not be used twice for the same component since that may produce only degenerate cases of the desired utput  so another point is needed. the description of output ontains the fact that the output may be viewed as a polygon  so lat the process of finding a convex hull may be seen as building a olygon and possible polygon fragments may be constructed by repeated extension from the most recently added vertex  herefore  the other input to a1 is obtained by following the memory of the hull so far  m1  with a select component  s1  that ets the point most recently added. 
operational-assertion  selection criterion  on s1: select- most- recently-added  polygon- input  
	d. steier and e. kant 	1 
　execution of s1 and a1 proceeds correctly  but m1 must now be changed to a component that manipulates polygon fragments by adding and deleting segments rather than adding or deleting from a point set. this is done by changing the port types and description assertion on m1. 
　now m1. and t1 execute correctly  but designer notices that the output of the test t1 is a segment  and not a set of points as expected. but m1's delete-segment port requires a segment. this condition activates another design rule: 
   when the descriptions on some item satisfy all the preconditions on some input port of a component  then add a link  if there isn't one already  from the port producing the item to the input port with the satisfied preconditions. 
　so a link is added from tvs true-exit port to m1's deletesegment port. an  optimizing  rule now applies to this situation: 
   if data can flow through two different paths at one level of a configuration  but the paths produce symbolic items with equivalent descriptions  then one of the paths is redundant and the more complex one may be deleted from the configuration. 
in this case. s1 is no longer necessary  so it is removed. the configuration resulting from all the changes described is shown in figure 1 further design will focus on the details of the initialization and termination of the loop  which were not previously addressed in refinement of the loop-body  but we will not describe this here. 
　another important feature of symbolic execution is the use of the active goal to limit the constraints propagated during execution. this promotes simplicity and efficiency and also defines a simple criterion for deciding when execution of a configuration is complete. for example  if the goal is to guarantee that the algorithm is correct  then symbolic execution is tantamount to a full formal verification in the data-flow language  a complete propagation of all constraints. if the goal is to analyze the efficiency of the algorithm  then only those constraints relevant to the time and space usage of each component are propagated. since many of the constraints in the design are often irrelevant to the active goal  this selectivity limits the computation necessary for automated design.1 however  the development of a surprising assertion can change the active goal or modify the type of information collected during symbolic execution. unless interrupted by another process  execution generally proceeds by depth-first search of the graph formed by the configuration  restricted by the semantics of the data flows and bounded in depth when a component is sufficiently understood for present purposes  possibly from previous execution . symbolic execution terminates when an active goal is satisfied  a difficulty is encountered or if nothing remains to be executed. 
the design goals satisfiable through execution include: 
  checking the consistency of the design  including checking for missing inputs or specific errors such as data-type conflicts between components. 
  given actual test-case data for some or all of the input  applying the algorithm to the data to compare 
the resulting output items to expected values. 
   other advantages of explicitly considering design goals in automated systems are explained in mostow's survey of design research . 
1 	d. steier and e. kant 
  checking that the algorithm  or component  executed on symbolic data satisfies its specifications as indicated by its preconditions and postconditions and those of any subcomponents. in the extreme case this amounts to a full verification. 
  analyzing the time complexity of the algorithm. 
　we illustrate the use of execution for time complexity analysis using the convex hull example. analysis proceeds by propagating constraints about the number of different items that may occur on links that force re-execution of certain components. this is equivalent to determining the size of the set of items on a link as a function of the size of the input  when considering the set as a 
　temporal abstraction of all items that may flow on the link over the entire computation the repetition and termination parts of loops are especially important to this analysis. in this example  at a later point in the design  it is seen that m1 is reset h times  corresponding to the number of points on the hull  which means that the worst-case run time of this piece of the algorithm is  h h n t   where n is the number of points in input and 1  is the time to execute t1 for each segment. since the formulation of the test in the domain space requires comparing the input segment to each point in input  the test takes time proportional to a/  so the total time is  xhn1 . this violates the original expectation of linear time. however  the existing design rules suggest no way to remedy this problem without a complete change of algorithm. 
　currently  the flexibility needed to satisfy these goals in symbolic execution is provided by allowing a variety of processing options. more than one option may be active at a time. which options are activated depends on the reason for trying symbolic execution. 
　in addition to implementing these options  we are also currently examining the issues related to repeated computation  since the presence of repeated computation in an algorithm causes difficulties for all current symbolic execution systems  and indeed for human programmers as well. the problem is due to an undetermined  and hence potentially infinite  number of execution paths to be considered. one approach that has been taken  1  1  is to try to automatically derive and solve recurrence relations to express the behavior of loops without the need for repeated execution. people  on the other hand  usually recognize a correc* loop when a small number of test cases work  and we wish to capture this ability to recognize familiar patterns from the structure of the algorithm and from symbolic or test-case execution in our system. we are currently investigating an approach that shares some of the characteristics of temporal abstraction in the programmer's apprentice. if the number of iterations is not totally constrained as in symbolic execution  we execute each part of the loop once to check internal consistency and give the results to a set of rules that can recognize familiar configurations and results. such rules could perform the temporal abstraction necessary to determine the behavior of a loop in the general case. 
e related work on symbolic execution 

assertions: 

figure 1. : convex hull algorithm after changes  changed assertions in boldface  　previous work on symbolic execution has focused primarily on the goals of testing  generating test data and exercising program paths  and verification  although debugging  understanding  

explanation  and analysis also have been addressed. here  we list the work in this area that is most relevant to algorithm design; a longer summary can be found in . for a survey of the uses of symbolic execution for program testing specifically  see . 
effigy   select   dissect   the el1 evaluator 
 and attest  1  1  were some of the first systms to use symbolic execution for testing and verification symbolic execution  in conjunction with other techniques  has also been used to analyze the run-time performance of simple programs  1  more recent work considers symbolic evaluation of specifications  rather than program code  to help in the development process: the partition analysis method ; koko   which symbolically evaluates gist specifications and is used as the basis of an explanation system ; reason   a component of the programmer's apprentice system  in addition to other mit work on meta-evaluation in the context of the actors formalism  1  1  . finally  simulation  a process similar to symbolic execution  was identified  based on protocol analysis experiments  in a model of the human design process focusing on software systems rather than algorithms   
f discussion 
　we have described a system that makes explicit the role of symbolic execution in the design process. we claim that execution has more uses than the testing and debugging applications described thus far; namely  that in uncovering opportunities for the refinement of a data-flow algorithm representation  execution is the principal method guiding design in the absence of specific knowledge. a standard set of difficulties combined with appropriate search control knowledge allows the automated selection of design operators even if the algorithm is incompletely described. the power and flexibility of this approach is being validated by our current work on writing derivations of complex algorithms  such as convex hull ; the results of execution control the search in the design problem space. 
acknowledgements 
 we thank allen newell  brian milnes and andrew peterson for comments on earlier drafts of this paper  and mary-anne wolf for collecting many of the protocols. all of them have contributed in numerous ways to the ideas in and implementation of designer. 
