 by afternoon having changed to another state. 
     
     in many domains it is important to reason about processes that change over time. unfortunately  in many situations relevant data may not be available when the reasoning is done; there may be corrections to the data; or the state of the process may be changing. these problems are particularly evident in the reasoning involved in patient management. physicians tend to reason about the patient state as a series of states. therefore  a system attempting to capture their expertise must be able to find the appropriate time intervals in which to do the reasoning  handle incomplete data and handle changes to data even when the data relates to a state that has since changed. 
     we present a data-driven control structure for reasoning processes in a domain in which updating or changes can occur. this mechanism implements two abstractions for these processes: the abstraction of data from a continuous process and the abstraction of decision making in a static state context. we will illustrate the use of the system with an example from a medical expert system for patient assessment  but the techniques are also applicable to other domains such as business decision making with result tracking and sensor interpretation. 
introduction 
     decisions in an intensive care setting often have to be made quickly even though information from such sources as laboratory tests  taking hours to process  are not available. when those results are received  they may still be pertinent but they refer to a previous patient state possibly modified by therapy. 
     a second problem concerns modeling change over time. many processes  including many of those that provide patient data  evolve. each new state is dependent on the previous state and current inputs. 
the obvious way to model such evolution is as a continuous process  but people tend to think in terms of states. that is  people consider a parameter to be low or high even though it is continuously varying or composed of separate values at time points. if a change has special significance  it is given a name and used in reasoning as if it were a static state:  the patient's blood pressure dropped this morning.  these states are linked together by a more abstract notion of change. the key to such reasoning is picking the proper time intervals to divide a problem. this kind of behavior is reflected in a physician's summary of the patient's status. the patient is described as being in one state in the morning  but 
¡¡this research was supported in part by the national institutes of health grant no. 1 p1 lm 1 from the national library of medicine  in part by the whitaker health sciences fund  and in part by brsg s1 rr 1  awarded by the biomedical research support grant  division of research resources  national institutes of health. 
other work 
     the problem we address is different from those addressed so far in temporal reasoning. most recent research in that field has focused on reasoning about relationships between events occurring at different times 
 allen  1a; allen  1b; bruce  1; kahn and gorry  1; mcdermott  1  . the reasoning issues in domains where data arrives at different times has only been dealt with tangentially in export systems to date. 
to a limited extent mycin  shortliffe  1   and the digitalis 
advisor  swartout  1  have addressed this problem. mycin uses a complete recomputation strategy to correct previous information and the digitalis advisor uses a dependency directed updating strategy. in both cases  the changes are assumed to take place within one consultation session. interestingly both programs use a static state assumption for most of the input data. for example  the digitalis advisor asks for the serum potassium concentration as if there were only one. vm  fagan  1  is the closest in spirit to our work. it determines states from nearly continuous data  but is unable to update past assessments from newly received data about the past. instead  data that is not current is either used as current or ignored as too old depending on how fast the particular parameter can change. thus  the full problem of reasoning in a 
domain where data is received over time has not been addressed. 
system rationale 
     the motivation for this work is the need to take appropriate account of new data that pertains to past situations in which decisions have already been made. this often happens in the medical domain with laboratory data which takes hours to process  or when erroneous data is corrected. treating such data as new data when it becomes available is wrong. instead  we require that the program reexecute the reasoning in the time frame to which the data applies. backtracking and withdrawing conclusions and then reexecuting the reasoning modules as if the data were available also has shortcomings because recommendations for actions in the past cannot be changed. therefore  the reasoning routines must be able to distinguish between reasoning in the future  when both information  e.g.  conclusions and diagnoses  and actions  e.g.  drug therapy  can be changed and reasoning in the past  when only the information can be changed. 
     the recalculation and updating schemes discussed above are restricted to the current consultation. one reason is that they do not include any concept of now. now is of consequence when calculations can produce action recommendations  because a re-calculation in the past must deal with the actual action as a given  even if it is judged to be incorrect in light of the new data. 
     
thus  the control structure must: 
  be able to determine appropriate intervals for reasoning and have the system enforce the state abstraction. 
  be able to interpret the data as if interpreting a continuous process. 
  allow changes to data in the past and control the process of changing the conclusions and even the reasoning intervals when appropriate. 
  execute changes with a minimum of recalculation. 
  support the distinction between the past and the future. 
     the system will be described using a procedural implementation of the reasoning units the idea  however  is equally applicable to a rule or frame based system as long as there is a mechanism for processing raw data to determine appropriate intervals  explicitly representing data dependencies  and keeping a history of the data values. 
system description 
     the system has a relatively simple basic structure consisting of reasoning units  called modules  and the following kinds of variables: 
1. point variables represent the raw data for the program. they represent facts true at specific instants  e.g.  laboratory values at specific times or actions such as the injection of a drug . internally  a point variable is simply a list of data-time pairs. the part of this list pertinent to the time interval of interest is provided to the reasoning module during execution. 
1. interval variables support the state abstraction as such they represent an interpretation of raw data over a time interval for which a constant interpretation is appropriate. thus the values for an interval variable are represented as a set of non-overlapping time intervals with a single value for each interval. the system must be able to support both past and future values since programs are often called to reason about the future to do planning. 
1. continuation variables provide an interface between the continuous process abstraction and the state abstraction. they hold the process state information for continuous processes at specified time points. the problem they address is the breakdown of the continuous process abstraction when data is received out of chronological order. our answer is to segment the process  remembering the state of the process in the appropriate continuation variable at the end of each time segment. thus  the variable contains the information necessary to restart the process as if it were continuing from the previous interval. in this way a continuous process over a segment can be treated in the same way as other reasoning processes. in particular it can be reexecuted for any segment in which the input variable values have changed  including the state variable from the previous segment . 
     all system variables have associated with them the type  the history of values  and pointers to modules affecting them. 
     modules are declared with the inputs and outputs explicitly listed as shown in figures 1 and 1. the only restriction on input and output variables is that each variable can appear in at most one module's output list  thus uniquely specifying the source when a value is needed. for each module the system creates a list of processes corresponding to the execution of the module over a time interval. each process has an associated time interval to maintain the correspondence between the process and the variable values. 
	w. long and t. russ 	1 
an example 
     as an example of how such definitions could be constructed at both the data acquisition and reasoning levels  consider a  simplistic  pair of modules  one to interpret raw diastolic blood pressure data and one to evaluate blood pressure using interpreted diastolic and systolic values. in the example raw diastoi ic is a point variable; diastolic.cont is a continuation variable; diastolic  systolic  and bp eval are interval variables. the modules are called on the interval bounded by the system variables begin time and end time. with the current time set to now.  the distinguished values -infinity and infinity are the system's end points. the purpose of interpret d iastolic  figure 1  is to identify the interval over which the raw diastolic pressures are relatively constant and set the diastolic pressure for that interval to an appropriate value. evaluate bp  figure 1  uses the abstract diastolic and systolic pressures and evaluates the blood pressure. 
     the values of the input variables are supplied to the code in local variables of the same name. they assume the interval from beg in time to end t ime  except that the value of a continuation variable assumes the previous interval  unless times are explicitly stated. in this case interpret diastolic needs the raw data from beg in time to i n f i n i t y 
because changes or additions may cause the interval of stable values to be longer than before  f i rst t ime returns the time of the first data item  or infinity . first data returns the corresponding data part. matching t ime returns the time of the first datum accepted by the predicate. the predicate 1ignif diff decides whether the difference between two values is significant enough to start a new interval. since changes to the earlier values could have eliminated the difference between the previous interval and the current interval  the continuation variable is used to verify that a difference still exists. if not  the current execution is aborted with an explicit request to reexecute the module on the previous interval. when that is complete the module is executed again on the remaining part of this interval after execution  the values for the output variables and the end t ime of the interval are set from the local variables of the same name. 
     the algorithm used by interpret d iastolic identifies the points of significant change by making sure the change still holds at the beginning of the interval and by identifying the appropriate end of the interval using the same predicate. in this example the value for diastol ic is the first 

     
1 w. long and t. russ 

raw diastol ic value in the interval in a more demanding situation  the module might average the values  identify intervals over which the parameter is unstable  or provide information about the trend over an interval or between intervals. 
     the evaluate bp module operates in a static state. when a request for bp eval occurs in an interval for which the value does not exist  evaluate bp is called with begin t ime and end t ime set for that interval. the diastolic and systolic values for evaluate bp are provided by the system if they do not exist  the modules having them as output are called; e.g.  interpret d iastolic for the diastolic value. if the values are not constant over the desired interval  evaluate bp is called on each successive sub-interval for which they are constant. this continuation is handled by the same mechanism that initially called evaluate bp. if new data becomes available  the system would reexecute the module  changing the interval boundaries as necessary. 
     the result is reasoning code free from explicit handling of time dependencies. 
     figure 1 illustrates the interaction of the two example modules. from the raw diastolic data  interpret diastolic establishes two intervals  with pressures of 1 and 1 respectively. a similar modulo for interpreting the systolic pressure finds intervals with pressures 1 and 1  but the systolic pressure changes one data point before the diastolic. as a result  there are three intervals over which evaluate.bp is called. with a pressure of 1  bp eval is normal. with pressures of 1 and 1  bp.eval is abnormal. even though there are three processes for computing bp eval  only two intervals result. 
system control 
     the system control is data driven. processes to determine values are created when needed and values are propagated when the processes finish. if the value of a variable represents a change  the system reexecutes processes depending on the changed value  and so forth. this reexecution requires some care on the part of the control structure. the function that sets values must determine over what interval a new value actually constitutes a change. otherwise  reexecution would always propagate to the end of the time space. to cover situations where changes may be arbitrarily small  it is possible to associate a significant change predicate with a variable. in addition  a given variable may be an input for more than one module. when such variables change value  the modules that depend on the new value are queued to be executed if the output variables change  the attected processes are queued. the queue is emptied in time order and data dependency order  to the extent the order can be determined from the module declarations . even so  it is possible that a process will be executed more than once. 
     since the conclusions of the reasoning modules are not valid until all changes are propagated  only the last execution's results should be displayed to the user. the system provides an output queuing mechanism to support this. 
     the effect of this control mechanism is that changes are always propagated through the record of what has happened. it is as if the continuous process of evaluating the input over time were rolled back to the point where a change was made and restarted at that point  except that the reasoning procedures are aware of the fact that they can not recommend new actions during time in the past. only those modules are reexecuted that are needed to correct the execution history. 
conclusion 
     providing system support for the data point and state abstractions allows us to model time-dependent processes in a natural way while keeping the domain code as free from computer housekeeping chores as possible this simplification can be expected to ease the burden on knowledge engineers and enhance the reliability of expert systems. 
references 
 allen  j. f.  a general model of action and time  dept. of computer science  university of rochester tr 1  november 1. 
 allen  j. f.  maintaining knowledge about temporal intervals  dept. of computer science  university of rochester tr 1  january 1. 
 bruce  b. c   a model for temporal 