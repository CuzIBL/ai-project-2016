 
a set of rules  or facts  about program synthesis is presented. the rules are about the process of programming  and are sutficient for the synthesis of an insertion sort program. the use of the rules to write a short lisp program is described. taken together  the rules are an embodiment of a detailed theory which explains one small part of the programming process. the size of the set of rules suggests the complexity of the process of writing programs and indicates that much work will be required to codify significant amounts of programming knowledge as a step toward the development of program-understanding systems. 
introduction 
　　this paper may be viewed as a sequel to an earlier paper  1   in which we tried to exhibit the knowledge required by a computer system in order to synthesize a simple insertion sort program. in this paper  we present the results of an attempt to codify that knowledge in the form of an explicit system of rules. although there are other ways in which this knowledge might be available to a computer system  e.g.  derivable through some kind of inference applied to more general knowledge   the rules presented here seem to express the information used in the process of writing one simple program. as such  the rules constitute one detailed part of a theory of programming. a more complete theory could provide the basis for a 
　　knowledge-based program-understanding system. 
　　the rules presented here are about the process of programming  rather than about program semantics. thus one of the rules states that one method of generating all elements in a stored set is to first select a method for saving the state of the generator  then write the body  then the initializer  and so on. additional rules elaborate how to achieve each subgoal the subjects of this set of rules include the synthesis of transfer programs  in which the elements of one ordered set are transferred and possibly re-ordered into a new ordered set   generators of elements and positions in ordered sets  constructors of sets  search strategies  tests for correctness of a position  etc. also included are the lower-level programming rules  for the lisp language  that are necessary to actually code the program. the complete set of rules has in fact been used to synthesize the intended program in an implementation which is basically a rule-testing system. this implementation is described at the end of the paper. 
　　it may seem strange that so many rules are used for one simple program. the number and complexity of these rules has resulted from a desire to adequately reflect the amount of knowledge needed for this particular synthesis and from an effort to minimize the amount of remodeling required to add more knowledge 
　　despite our desires and intentions  however  there are several shortcomings of the rules and we would like to make some disclaimers. the most obvious limitation is the amount of higher-level programming knowledge which is not included  e.g.  more complex search strategies  such as binary chop   other state-saving schemes  such as the overwriting of elements   and other knowledge necessary for more efficient sort programs. the reader will usually find only one method explicated when many more come to rnind. we hope to correct these omissions by expanding this rule set in the future. a real likelihood with this  skeletal  approach is that the framework provided by this initial set of rules may well need remodeling to accommodate further programming knowledge. the only overall framework presented in this paper  that of an iterative transfer program  will perhaps not be the reader's  or the eventual user's  favorite way to view the synthesis of a sort program othor weaknesses are that the rules do not allow enough  planning  activity  resulting in a rather rigid sequence that must be followed   and that a few rules probably have too much specialized knowledge. it is also important to note that the rules are currently designed for synthesis and would require modification  or else a different set of rules  in order to analyse or modify existing programs. our omission of conventional inference ability is intentional  since we feel that the state of the art in the area is well ahead of the state of any theory about the process of programming. however  it is clear that in a more general program-under stanoing system inference plays a part in selecting applicable rules and in putting the pieces of a program together in any non-preconceived order. 
f 
n 
　　the program is basically a loop with three parts: a termination test which tests whether all of the elements in the input list have been generated; a selector which generates the next element in a first to last order and saves its computational state; and a constructor which finds the position in the output list for the element and then adds it at that position. thus  the program takes each of the elements from the input list  in first to last order  and builds up the output list by inserting these  one at a time  into their appropriate places. 
1 　　note that the program is basically iterative rather than recursive. this is primarily a reflection of our feeling that significant aspects of the algorithm are hidden by a recursive call. in many real applications  programmers must deal with the notion of generating elements sequentially  and of saving the state of a computation  so we have chosen to look at these explicitly. 
　　we will now give an overview ot how these rules would be used to synthesize this program  
1: as stated in the introduction  we will assume that the system has already decided to use a transfer program as the basic paradigm. a transfer program consists of two parts  the selector  which enumerates elements from the input set  and the constructor  which places these elements in the output set. this transfer program is an instance of a generate and process paradigm  in which the selector is the generator and the constructor is the process 
i: the system decides to write a insertion sort rather than an selection sorl program.  an insertion sort removes the elements from the input in first to last order and inserts each into its correct place in the output such that after each step the output set is ordered; by contrast  a selection sort removes the largest element from the input and adds it onto the front of the output; the rules presented here only consider the case of insertion sort programs.  
1: the selector for the transfer program is written. first a pointer into the input list is chosen as the method for saving the state of the selector between colls to it. then the selecter body  consisting of code to generate the element and code to increment the pointer  is synthesized finally the selector initializer and the selector pre -test  a test which the transfer program can apply to determine whether there are any more elements to be generated  are written. 
1: work on the output constructor is begun first it is decided that the new set will be built up by list insertion then  noticing that the elements arrive not necessarily in increasing  or decreasing  order  the system decides that it needs a somewhat complex constructor that must search for the position to insert each element it chooses a pair of pointers into the list to represent that position 
1: now the position finder is synthesized. this requires choosing a search strategy for finding the correct position  and a method for representing the state of the search. once these have been chosen  the loop which finds the correct position is written: this includes writing an initializer  a position tester  and an mcrenenfer 
1: now the element inserter is written it requires a special case for inserting at the front of the list the position finder and element inserter together constitute the constructor body. 
1: to complete the output constructor  the system writes the constructor initializer which initializes the output set to the empty list. 
the rule systems 
　　as an aid in understanding the rules  let us point out that they are grouped into structured systems of rules  each system dealing with a different aspect of the process of writing a transfer program. as will become apparent  there is a simple hierarchical structure to the rule systems. this  we feel  is a reflection of the nature of the task: some goals require other goals to be satisfied  hence some rules call others as sub-rules. however  a strict hierarchy is certainly unnecessaryfor example  in the process of writing a non-linear generator  the generator rule is called again  in order to write the code to generate the elements linearly for use in the comparison. 
　　we wish to point out that  in the rules presented here  wherever a choice is indicated  only one alternative is actually provided. when we have extended the rules to enable the synthesis of a large class of programs  most of these rules will contain several options. choices between them could be made either by using additional rules dealing with efficiency or by leaving such choices up to the user. but the important point here is that the notion of 
 understanding  seems to carry with it an awareness of possible alternatives 
t h e 	r u l e system 	f o r t r a n s f e r p r o g r a m 
there is one transfer program rule: 
tl: tn order to write a transfer program  the following lour sub-tasks must be achieved: 
　 1  select a transfer rt-oulning 
　 1  write a selector  which will include a body  initializer  and pre-test; 
　 1  write a constructor  which will include a body  and an initializer 
　 1  put the selector and constructor together into a grvaatr and process paradigm with the selector pre-test used as the termination test and applied just before the call to the selector body 
　　the meanings of most parts of this rule are relatively obvious  and we shall delay the detailed explanation of each of its sub-tasks until we discuss the rules for achieving those sub-task 
　　the first choice which must be made in the process of writing a transfer program is to choose the pattern of reordering to be used by the program. the input to the transfer program we wilt call the sou and the output we will call the target. as part of the transfer process  there will be some overall re-ordering from the positional ordering of the source  initial order  to the positional ordering of the target  final order . there is also an intermediate ordering: the temporal ordering of the elements as they are transferred  transfer order . corresponding to these three orderings  there are relationships between them we shall discuss these relationships as functions from one order to the next order  i.e. u-otlinings or permutations. the orderings and reorderings are shown in the diagram. 


1 

　　the transfer reordering is the main re-ordering accomplished by the transfer program. this re-ordering is part of the top-level specification of the program  presumably furnished by the user or a higher-level program an example of a transfer re-ordering specification for a  reverse  program is  final order is converse of initial order . in our paradigm  we factor this re-ordering into two re-ordenngs  the selection reordering and the construction re ordering. accordingly the transfer program is also factored into two sub-programs  the selector and the constructor which perform these re-orderings. 
the rules consider four possible re-ordering operations: 
1. same; makes a copy with the identical ordering. 
1. converse; reverses an ordered set. 
1. based on comparison predicate: the re-ordered set is such that one element precedes another if and only if the comparison predicate  supplied by the user  applied to these elements is true. the order of the re-ordered set is independent of the initial order  except in the case where two elements have equal keys  
1 based on evaluation function: the re-ordered set is such that one element precedes another if and only if the value of the first element is less than the the value of the second  where the values are the results of applying the evaluation function  supplied by the user . the order of the re-ordered set is independent of the initial order  although this is actually a special case of 1  we include it since people seem to use it frequently.  
　　it is convenient to classify the first two re-orderings as linear since the programs to accomplish these are simple and are treated as special cases 
　　in addition to the transfer program rule given above  there is a set of transfer re-ordering rules which guide the choice of selection re-orderings and construction reorderings. their effect is to constrain the choices for the two re-orderings to be such that their composition will yield the transfer re-ordering an example of such a rule is; if we are writing a  reverse  program and the selection re-ordering is same  then the construction re-ordering must be converse the normal case in a sort program is that either the selector or the constructor will do the bulk of the work of the total re-ordering  and that the other will perform only a simple  linear  re-ordering  either same or converse . the transfer re-ordering rules are straightforward but lengthy  so we shall not present them here. 
t h e r u l e system 	f o r selector 
　　in considering the rule system for a selector  we first observe that a selector is a special kind of generator. that is  a selector is required to generate exactly the elements of the source set  once and only once  and in a particular order  the order discussed earlier as the transfer order . perhaps the most important aspect of any generator is that  relative to the program which uses it  it is essentially a process or co-routine; that is  between calls to it  it must somehow  remember  which elements have been generated and which have not  in order to guarantee generating all elements one time each this  remembering  must be part of what is performed by the body of the generator  in addition to  generating  the next element 
　　also  there must be some way of determining when the generator is finished  that is  when each element in the source set has been generated and none remain. in the generators for which our rules are intended  this will be done by using a pretest which the calling program guarantees to apply before each call to the generator  for example  a test whether a pointer points to the empty list.  this is the test which the transfer program will use to decide when to stop transferring. finally  there must be some way of initializing the generator prior to its first call. from this discussion  we can see that the rule system for the selector  generator  must produce three separate sections of code: the main body  the pre-test  and the 
initializer 
　　it is also worth noting that the generator must know the manner in which the generated element should be given to the caller. in the case of our rules  we consider only the case of setting some global variable to a particular value  either the element itself or a pointer to the sublist beginning with that element 
si: in order to write a selector  one of the following sub-tasks must be achieved: 
       w r i t e a generator with the production older the same as the selection re-ordering  and constrain the generator to be total 
s1: in order to write a generator  the following four sub-tasks must be achieved. 
 !  select a state-saving scheme for the generator 
　 1  write the generator body  based on the statesaving scheme 
　 1  write the generator initializer  based on the statesaving scheme 
　 1  write the generator pretest  based on the statesaving scheme 
　　note that the first sub-task of this rule is the selection of a state-saving scheme for the generator this statesaving scheme will be essentially a specification of some plan about how to do the  remembering  discussed above. there are many possible schemes which will perform adequately   e g   bit strings  property list marks  hash table entries   but there are certain common characteristics. each scheme includes some way of looking at a particular description of the state of the generator and knowing  or deducing  which elements of the set have been generated. additionally  each scheme includes some way of incrementing the state after the appropriate element has been produced. also implicit in any such scheme must be some way of determining  from a state description  whether any elements remain to be generated. 
　　the choice of state-saving scheme depends upon the representation of the set  the order of enumeration  and whether destructive operations are allowed. for the case we are considering  the enumeration of the elements in a list requires only one variable  which points into the list. in this standard enumeration scheme  the pointer always points to the sublist beginning with the next element to be generated and is bumped by one more list cell each time a new element is required. we will refer to this scheme as pointer into source and to the pointer as pointer. the rule may be written as; 
gsl: in order to select a state-saving scheme for a 
generator: 
　 i  if a non-destructive state-saving scheme is desired  the source-set is represented as a linked list  and the production re-ordertng is same  then use 
pointer into source 
1 　　for a simple linked-list  forward scanning generator  the part of the program that finds the next element and the part of the program that increments the state communicate very simply through one pointer  the pointer used for the state representation with more complex state-saving schemes  additional variables may be required to communicate between these two subprograms. for example  with o destructive  element-deleting scheme  the state is represented by one pointer to the front of the list  but in addition another pointer  indicating which element is to be deleted  must be passed from the element finder  which finds the element  to the state incrementer  which deletes that element  the following rule is thus a minor simplification 
s1: in order to write the generator body  the following three sub-tasks must be achieved; 
　 1  write the part of the body which produces the element to be generated 
　 1  write the part of the body which increments the state of the generator 
　 1  put these two parts together into a sequential block 
　　two ways in which a generator can report an element to its caller are  1  by a pointer to the sublist beginning with that element and  1  by a pointer to the element itself. these two element tepresanations we call sublist and item respectively  actually  the transfer program rule  tl  needed to specify the item representation  so that the selector and constructor could communicate.  
s1: in order to write the part of the body which produces the element to be generated  the following two sub-tasks must be achieved; 
　 1  write an expression which has as its value the element to be generated 
　 1  write a statement which assigns this value to the variable which should hold the element to be generated 
s1: in order to write an expression which has as its value the element to be generated; 
　 1  if the generator state-saving scheme is pointer into source  then write an expression which has as its value the clement representation of the first element in the list pointed to by pointer 
s1: in order to write an expression which has as its value the element representation of the first element in a list: 
　 i  if the element representation is item  then write an expression which has as its value the first element of the list pointed to by pointer 
　　note that ss considers which element to produce and s1 considers how to represent it. 
s1: in order to write the part of the body which increments the state of the generator; 
　    if the generator state-saving scheme is pointer into source  then write a statement which increments pointer 
s1: in order to write the generator initializer: 
　 1  if the generator is constrained to be total  then write code which initializes the state to the entire source 
s1: in order to write code which initializes the state of the generator to the entire source; 
　 1  if the generator state-saving scheme is pointer into source  then write a statement which assigns the source to pointer 
s1: in order to write the generator pre-test: 
　 i  if the generator is constrained to be total  then write a statement which tests whether all of the elements have been generated 
s i l : in order to write a statement which tests whether all of the elements have been generated; 
　 1  if the generator state-saving scheme is pointer into source  then write a statement which tests whether pointer points to the end of a list 

　　although there are several ways to do this operation  our use of the term  list insertion  refers to the commonly used method in which the  cdr  of the list cell preceding the desired position is destructively modified to point to a newly created cell which is in turn linked back to the rest of the list. note that this technique requires saving a pointer to the list cell preceding the position and it also requires special treatment at the front of the list. 
　　we will classify list insertion as being nuhpnuii-nt  meaning that the code which finds the position where the new element belongs and the code which adds the new element at that position are independent and may be written as separate pieces of code.  if the construction method were  say  array shifting  then this independence would no longer hold  
c1: in order to write the constructor body; 
　 1  if the construction method has the property  independent   then achieve all of the following subtasks: 
　 1  select a method for representing the desired position 
　1  write the part of the body which finds the position in which the new element belongs 
　 1  write the part of the body which adds the new element at this position 
　 1  put these two parts together into a sequential block 
1 　　the position finder and the element adder both require that a method be specified for representing the position at which the new element will be added for example  in an array  the index of the correct position is an adequate representation. for lists  one or two pointers into the list are convenient position representations. 
　　the rule we shall use for selecting a position representation is: 
prl; in order to select a position representation; 
　 1  if the set being constructed is represented as a linked list and the construction method is list insertion  then use two pointers  which will point to the list cells before and after the point where the new cell will be added  
pictorially  this position representation looks like this; 

　　this representation has a special case for the front of a list: the  before  pointer will have as its value a unique string constant  say   front . for the end of the list  the  after  pointer will point to nil. we will refer to the two variables involved as before and after 
　　note that this position representation is more than adequate for the list insertion method used  since it maintains not only a pointer to the previous cell in the list  but also a pointer to the succeeding cell in the list. the second pointer will be used by the correctness test. this representation leads to a relatively simple algorithm. 
　　the selection of this rule and the corresponding construction method is pretty obviously a cheat  since the rules should first do some planning  i.e.  notice that later parts of the program would have profited from the twopointer representation an alternative to a planning technique would have been some later simplification or optimization of the program. 
c1: in order to write the part of the body which finds the position in which the new element belongs: 
　 1  if the construction order is not  linear   then write a position finder which guarantees success  discussed later before rule p1 ; it must find the desired position according to the construction order  and specify it accoiding to the position representation 
　　in a similar manner to the selector  a linear construction re-ordering would mean that the position is already implicit in the state  say an index moving linearly through an array  and need not be recomputed. in the remaining rules  rather than saying  an ordered set represented as a linked list   we will use the term  iist'. 
c1: in order to write the part of the body which adds the element at the position: 
　 1  if the position representation has a special case for the front of the list and the construction method has a special case for the front of the list  then achieve all of the following sub-tasks: 
　 1  write a statement which tests whether the position  which has already been found  occurs at the front of the list 
　 1  write a statement which adds the element onto the front of the list 
　 1  write a statement which inserts the element into the list at the position specified  assuming the position is not at the front  
　 1  put these three pieces together into a conditional expression 
c1: in order to write a statement which tests whether the position is at the front of the list: 
　 1  if the position representation is two pointers  then write a statement which tests whether before is equal to the special string constant  front  
c1: in order to write a statement which adds the element onto the front of the list; 
　 1  if the construction method is list insertion  then write a statement which destructively adds the element onto the front of the list 
c1: in order to write a statement which inserts the element into the middle of the list: 
　 j  if the construction method is list insertion  then write a statement which destructively inserts the element into the middle of the list 
c1: in order to write a statement which destructively inserts the element into the middle of the list; 
　 1  if the position representation is two pointers  then write a statement which destructively inserts the clement between two pointers 
c1: in order to write the constructor initializer: 
　 1  if the target is specified to be initially empty  then write code which initializes the target to an empty list 
c1: in order to write code which initializes the target to an empty list: 
　 1  if the construction method is list insertion  then write a statement which assigns the empty list to the target 
t h e r u l e system f o r position f i n d e r 
　　the postion finder looks through the available positions in the set being constructed and finds the correct position at which to insert the new element. the position finder can be thought of as a total generator that generates each position and tests whether the position is correct. a search strategy is required to determine the order of enumeration of positions a search-state saving scheme is used to remember the state of the search. a conectness test is synthesized to test whether the proposed position results in an ordered set. each position must be represented according to the earlier specified position representation  so some code may be required to translate from the search state representation into the position representation. 
　　the reader may wonder why the position finder rules do not call the high level generator rules discussed in the selector section instead a slightly different type of generator is effectively entailed by these position finder rules in other versions we have the position finder call the existing generator rules. for clarity we present separate rules here for the position finder  although we feel that it is conceptually better to combine the two into a unifying paradigm 
　　the position finder was constrained by the constructor to be one that guarantees success  i.e.  it must find a correct position or else the inductive constructor won't work structurally  this means there is no failure branch for the position finder 
pi: in order to write a position finder that guarantees success  the following five sub-tasks must be achieved: 
　 1  select a search strategy that guarantees success 
    1  select a search-state saving scheme for the position finder  based on the search strategy 
　 1  write the position finder body  based on the search strategy and the search-state saving scheme 
　 1  write the position finder initializer  based on the search strategy and the search-state saving scheme 
　 1  put the last two together into a sequential block 
1 　　the selection of a search strategy that guarantees success consists of lots of checking followed by the selection of a simple forward linear scan. 
ssi: to choose a search strategy that guarantees success  one technique is: 
 1  check that a correct position exists 
 1  select a total search strategy 
ss1: to check that a correct position exists  one technique is to check these conditions: 
　 1  if the correctness criteria is based on a comparison predicate  an ordering relation ; 
 1  the ordering relation is transitive 
 1  the set being scanned is ordered 
ss1: to select a total search strategy; 
　 1  if the search list is represented as a linked list  then use forward linear scan for the search strategy 
　　we will speak of this search strategy as being tndepenent   meaning that the part which finds the position and the part which tests it for correctness are independent of each other  as opposed to the case with a binary chop . 
　　the search for a position requires a state-saving mechanism  just as did the earlier kind of generator. the state-saving scheme given by our rule will be two pointers  pointing respectively before and after the current position. recall that this is the same as the position representation. the rule first checks some conditions to see if a two pointer scheme is adequate next it notes that since the position representation and the search state representation are the same  they will be combined and the state representation will be said to subsume the position representation. finally  the variables used for the position representation become the variables used for the search state representation 
sss1: 	to select a position finder search-state saving scheme: 
　 1  if a non-destructive scheme is all right  a  linear  strategy is being used  and the search list is represented as a linked list  then; 
　 1  a two pointer state representation will work 
　 1  note that the position representation is subsumed by the search state representation 
　 1  if the position representation includes a  before  pointer  then that is superceded by the state's  before  pointer 
　 1  if 	the 	position 	representation 	includes 	an 
 after  pointer  then that is superceded by the state's 
 after  pointer 
　　we note that this rule is something of a cheat in that  .again  some planning should be required to select such a good and optimizing state representation. this rule is a good example of trying to embody knowledge in a form too specific to a particular state or position representation. more reasonable would be a general rule giving a 
　　preference for using one variable instead of two when they would perform similar functions  
p1: in order to write the position finder body: 
　 1  if the search strategy is  independent   then achieve ail of the following sub-tasks; 
　 1  write the part of the body which translates from the representation of the state of the search into the representation of the current position 
　 1  write the part of the body which tests whether the determined position is correct according to the criteria for acceptance 
　 1  write the part of the body which increments the state of the search 
　 1  write the part of the body which tests whether there are no positions left  thus indicating failure to find the desired position 
　 1  put the pieces together into a loop 
1 
　　the fact that the position representation is subsumed by the search state means that at any point in the search  the next position to be tested is completely specified by the search-state representation  i.e.  absolutely no work must be done in order to specify the position to be tested  given the state of the search this is reflected in the next rule 
p1: in order to write the part of the body which translates from the representation of the state of the search into the current position: 
　 1  if the position representation is subsumed by the search-state scheme  then there is nothing left to do to determine the position to be tested 
　　the next five rules  pa through p1  represent a chain of simplifications of the test that the position is correct  i.e.  the new set is ordered. the chain proceeds from testing the new element against each other element to checking against only one. this situation may occur frequently enough that one special case rule should be used. 
p1: in order to write the part of the body which tests whether the determined position is correct according to the criteria for acceptance: 
    1  if the criteria is based upon a comparison predicate  then achieve all of the following sub-tasks: 
　 1  write a statement which tests the new element against all of the elements preceding the determined 
position 
　 1  write a statement which tests the new element against all of the elements following the determined 
position 
　 1  if either statement is vacuous  then return only the other; otherwise  combine the two tests into a conjunction 
p1: in order to write a statement which tests an element against all of the elements preceding the determined position: 
　 1  if the comparison predicate is transitive  and the search strategy is forward linear scan  then there is nothing left to do to test the element against all of the elements preceding the determined position 
p1: in order to write a statement which tests an element against all of the elements following the determined position  the following three sub-tasks must be achieved; 
　 1  write a statement which tests whether there are no more elements after the determined position 
　 1  write a statement which tests the new element against all of the elements following the determined position  assuming there is at least one such element 
　 1  combine 	these 	two 	tests 	into 	an 	ordered 
disjunction 
p1; in order to write a statement which tests whether there are no more elements after a position: 
　 1  if the position representation is two pointers  then write a statement which tests whether after points to the end of a list 
p1: in order to write a statement which tests an element against all of the elements following a position  assuming there is at least one: 
　 1  if the comparison predicate is transitive and the search list is ordered  then write a statement which tests the element against the immediately following 
element 

the rest of the rules are more or less self-explanatory  
p1: in order to write a statement which tests an element against the immediately following element  the following two sub-tasks must be achieved: 
　 1  write an expression which has as its value the first element after the position 
　 1  write a statement which applies the comparison predicate to the new element and the expression just written 
p1: in order to write a statement which has as its value the first element after a position; 
　 1  if the position representation is two pointers  then write a statement which has as its value the first element of the list pointed to by after 
p1: in order to write the part of the body which increments the state of the search: 
　1  if the search strategy is forward linear scan  then write a statement which increments the search state to the next following position 
p1: in order to write a statement which increments the search state to the next following position; 
　 1  if the search-state saving scheme is two pointers  then achieve all of the following sub-tasks; 
　 1  write a statement which assigns to before the value of after 
　 1  write a statement which increments after 
　 1  combine these two into a sequential block 
　　note that this incrementing technique works both for the special case where before has the special value  front  and for the general case where before points into the output list  
pi1: in order to write the part of the body which tests whether there are no positions left: 
　 1  if the position finder guarantees success  then this part is unnecessary 
pi1: in order to write the position finder initializer: 
　 1  if the search strategy is forward linear scan  then write a statement which initializes the search state to the first position in the search list 
pi1: in order to write a statement which initializes the search state to the first position in a list: 
　 1  if the search representation is two pointers  then achieve all of the following sub-tasks: 
　 1  write a statement which assigns to before the string constant  front  
　 1  write a statement which assigns to after the search list 
　 1  combine these into a sequential block 
t h e r u l e s f o r l i s p statements 
　　the rules given here are included only for completeness. they embody the lisp knowledge necessary for the insertion sort program. 
li: in order to write an expression which has as its value the first element of a list  return the list:  car h i s t name   
l1: in order to write a statement which assigns a value to a variable  return the list: 
	 setq  variable name  	 value   
1: in order to write a statement which increments a pointer  return the list: 
	 setq  pointer name  	 cdr  pointer name    
l1: in order to write a statement which tests whether a pointer points to the end of a list  return the list: 
 null  pointer name    
1: in order to write a statement which tests whether a variable is equal to a string constant  return the list: 
	 equal 	 variable name  	 string constant   
l1: in order to write a statement which destructively adds an element onto the front of a list  return the list: 
 setq   l i s t name  
	 cons  element name  	  l i s t name    
1:  n order to write a statement which destructively inserts an element between two pointers  return the list: 
 rflacp   before  pointer name  
	 cons 	 element name  	  after  pointer name    
1: in order to write a statement which assigns the empty list to a variable  return the list:  sftq  variable name  nil  
l1: in order to combine two tests into an ordered disjunction  return the list: 
	 or 	  f i r s t test  	isecond test   
lio: in order to apply a function to a list of arguments  return the list: 
	  function name  	. . . arguments ... 	  
an example 
　　wo now present an example of the use of the rules we will look in detail at steps l and 1 of the overview presented earlier 
　　let input be the name of the source list and let output be the name of the target list. let element be the variable name chosen to do the communicating between the selector and constructor. we will suppose that the final o r d e r is based on comparison predicate  with greaterp as the comparison predicate we assume that the system has already decided to write a transfer program. that is  rule 
tl has been invoked 
　　step 1 involved the choice of an insertion sort rather than a selection sort  if we consider what the possible legitimate combinations of selection re-ordenng and construction re-ordering are  we note that using same for the selection te-ordering implies that the constructor must 
do the bulk of the work  i.e.  an insertion sort . in fact  the construction re-ordering must then be the same as the final order: based on comparison predicate. 
　　step 1 involved writing the selector for the transfer program that is  rule si is invoked by tl this will result in each of the other selector rules being invoked at the appropriate times. the accompanying chart gives a structural diagram of the various rule invocations. 
1 


an implementation 
　　the rules given in this paper are an abstraction of some of the rules now operational in a system being developed. we have endeavored to separate out those aspects of the rules which are implementation independent from those aspects which are the results of idiosyncrasies in the implementation thus  the rules presented here are not precisely in correspondence to our implementation we include here a short discussion of our implementation for those who may be curious about it. 
the basic mode of operation is to invoke rules by name. 
each rule is responsible for determining which rules to invoke to accomplish its sub-goals. the user may be queried for a preference when alternative sub-goals are possible. the invocation by name has two major implications for the system. first  addition of knowledge is not strictly incremental  although the addition of  systems  of rules is generally fairly simple. second  the system has no sophisticated abilities above and beyond those stemming from the knowledge represented by the rules. in particular  the system has no inference capabilities apart from those implicit in the rules. as the system is primarily a rule-testing device  rather than a sophisticated useroriented system  these defects do not seem critical. 
remarks 
　　having looked at these rules  it is natural to wonder what they can do for us. in regard to their  understanding  ability  it seenic that they can quite adequately r plain the program that they produce one need merely look at the rule path which produced any part of the final program to understand the telationship of that part to the entire program. on the other hand  the rules are clearly unable to analyre or modrfy the program. it seems plausible that they could be extended to do some rudimentary analysis through 'jorne kind of parsing technique. since the rules presented here are incomplete  in the sense that they do not present various alternatives  they cannot be expected to allow modification when they have been extended to a broader class of programs  different specifications will yield different progi arns  and modification would seem to require only slight extensions this is  however  mere speculation; further experimentation is required before anything definite can be determined 
　　one of our original intentions was to determine a set of rules with a wide applicability we feel that we have done this. we are now in the process of extending these rules into a larger set  capable of synthesizing an entire class of sort programs if we are successful  then we will have an indication that these rules do indeed have some generality. but more than that  we expect the rules to be useful in many other programming tasks. set operations  such as intci section and union  seem to involve many of the concepts with which our rules already deal  e.g.  generating elements from an ordered set  another area of potential usefulness seems to be in various kinds of searching and table look-up operations. obviously the entire set of rules will not be applicable in any one situation  but it seems that for each situation some subset of these rules will be useful 
　　in regard to such generality  it seems to us that some of the rules may be overly specific to the one particular target program  in the sense that such rules  or equivalent knowledge  could be derived or inferred from more general principles during synthesis of the program. the choice between these two modes of operation seems to be largely a computational issue: some kind of trade-off between space and time considerations. 
　　at this point it is far too early to prefer one mode to any other  but having explicated the knowledge in some form  we may gauge the requirements of future knowledgo-based program-understanding systems. we have seen that about 1  rules  are needed for a system to  understand  what is involved in writing even one simple sort pi ogram. if we are to design knowledge-based pypgiam unlit-minuting systems  with the abilities of synthesis  
analysis  and modification  applicable to many different kinds of programs  then the body of programming knowledge which will be required is quite large. our current work indicates that well over a hundred rules will be required to enable the synthesis of a large class of sort programs. it is still too early to estimate the size of the body of programming knowledge which will be necessary for the establishment of reasonable knowledge-based program-understanding systems  but we can at least see that the task of codifying this knowledge is likely to be a long one. 
acknowledgements 
　　the authors gratefully acknowledge the diligence with which avra conn read the drafts of this paper  and the generosity with which the artificial intelligence center of the stanford research institute provided machine time for the research upon which this paper is based. 
