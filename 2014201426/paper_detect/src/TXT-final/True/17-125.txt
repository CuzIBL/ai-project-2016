 
   this paper presents a method of learning to solve design problems by generalizing examples. the technique has been developed in the domain of logic circuit design. it involves the use of domain knowledge to analyze examples and produce generalized circuit designs. the method utilizes proofs of design correctness to guide the process of generalization. our approach is illustrated by showing it can generalize a rotational shift register into a schema describing devices capable of computing arbitrary permutations. 
introduction 
   research in machine learning has identified two contrasting approaches to the problem of learning from examples. the traditional  empirical  approach is based on the idea that an intelligent system can learn from examples without having much prior knowledge of the domain of application. this approach has involved looking at a large number of examples in order to identify similar features. it usually relies on syntactic methods of matching instances and correlating the common features. examples of this approach include  winston 1 ;  michalski 1   among others. the alternative  analytical  approach takes a different point of view. it assumes that generalization requires a great deal of background knowledge of the domain under study. it typically relies on intensive analysis of a single example in order to generalize. the work reported in this paper takes the analytical approach. it has been applied to the problem of learning to design logic circuits. the method involves analyzing single examples of circuit designs and producing generalized designs. 
   in order to illustrate the technique  consider the circular shift register circuit shown in figure 1. this device is capable of four operations  rotate right  rotate left  load and no-operation. the operations are controlled by the two bit  select  line  figure 1 . the circuit has been designed using d-type flip-flops  labeled  dff   and multiplexers  labeled  mux . a human novice would be capable of generalizing from this example provided he understands the principle of operation behind the circuit. for example  he must know that a d-flip-flop can store one bit of information and that its output is equal to its input delayed by one time unit. the multiplexers are used to route one of four inputs to an output determined by values on their select lines. a novice who understands the operation of this circuit could probably produce similar designs which compute any permutation of 
*this research was supported in part by the defense 
advanced 	research 	projects 	agency 	under 	contract n1-c-1. 
four bits. this merely requires connecting the d-flip-flop outputs to the multiplexer inputs in a manner consistent with the chosen permutation. generalization from the single example is possible because all the other permutations can be implemented using the same principle of operation. 

	figure 1: 	control codes for circular shift register 
   this paper will describe a program that attempts to model the behavior of the human novice. the program is able to successfully generalize the shift register into a circuit schema capable of implementing any permutation. the system is given enough background knowledge about the operation of devices like multiplexers and d-flop-flops so that it can understand the operation of the shift register. this knowledge takes the form of rules which can be used to prove that the example design is correct. the original example is generalized into a schema describing all circuits that can be verified using the same proof of correctness. 
   this research is similar in spirit to previous work on analytical methods of generalization. these analytical approaches include  goal-directed learning   mitchell 1a    explanatory schema acquisition   dejong 1    derivational analogy   carbonell 1  and  learning from precedents   winston 1 . the research reported here is also related to the work on  circuit redesign  reported in  mitchell 1b . 

1 	t. ellman 
the approach taken there involves designing a new circus by analogy with a previously designed circuit. our work is different mainly in that it focuses on generalization  rather than analogy. the technique of explanatory schema acquisition reported in  dejong 1  is similar to ours  although the domain of application is quite different. our work also differs by focusing on design problems and generalising both designs and specifications. other related work includes  minton 1; mostow 1a; mostow 1b; 
salzberg 1; silver 1 . 
the learning task 
   our learning program is envisioned as a component of a complete system for designing circuits according to explicit specifications. the problem solving module for such a system would take circuit specifications as input and produce circuit designs as output. the learning module deals with both specifications and designs. it is intended to take as input a pair  s d  consisting of specifications and a design which correctly implements the specifications. the goal of the learning process is to produce a generalized design schema  s* d*  consisting of generalized specifications and a 
   generalized design. the learning system must generalize the original pair subject to the constraint that the general design correctly implements the general specifications. the entire process has the following four steps. 
1. a sample specification and design is input by a teacher. 
1. a correctness proof is built to verify the design. 
1. the proof is used to guide generalization of tne example. 
1. the generalized schema is used to solve new problems. 
we have chosen to focus on the third step which involves using the proof to facilitate generalization. there are several reasons for concentrating on the generalization step. a great deal remains unknown about precisely how causal reasoning may be used to enable generalization. 
furthermore  correctness proofs may take a variety of forms and the choice may impact on the extent to which the proofs are a useful aid for generalization. this reasoning suggests investigating the generalization process first and letting the proofs be designed to fit the requirements of generalization. our generalization program uses proofs built by hand as input. the task of automatically building explanations has not yet been implemented. the task of building proofs is similar to other understanding problems  and has been studied before. the critter system  kelly 1   is an example. 
the circular shift register example 
   the generalization program works by analyzing three pieces of information  s d pj. two of the inputs are the specifications s and the design d as described above. the third input  p  is a proof tree which verifies that the design correctly implements the specification. the specifications for the circular shift register are shown in figure 1. these specifications contain a list of inputs and outputs  as well as clauses describing the behavior of each of the four output lines. each clause specifies the value of an output line at time   t   as a function of the values on the input lines at an earlier time   t - 1 . the  case  statement is used to specify the circuit's behavior for each of four control states of the select lines. the design of the circular shift register is represented by the data in figure 1. this representation describes the electrical components and the wire connections between their ports. 

   proofs of correctness are represented as trees. figure 1 shows a proof tree that verifies a clause describing the behavior of one stage of the shift register. the leaves represent facts about the design and the root contains the specification to be verified. hence the tree represents a derivation of the specification taking the design statements as assumptions. this proof tree uses four derivation rules. two of them  the  dff-rule   and the  mux-rule  describe the behavior of components. the dff-rule asserts that a dflip-flop output signal at time  t  is equal to the d-flip-flop input signal at time  t - 1 . the mux-rule describes how a multiplexer can be used to implement a case statement. the  connect-rule  asserts that two connected wires have the same signal values at all times.  ignoring propagation delay.  finally  the  replace-rule  allows equal quantities to be substituted for each other in expressions. 
using the proof to generalize 
   our generalization procedure is intended to produce a 
   schema  s* d*  describing all circuit designs that can be proven correct using the original correctness proof. the 

	t. ellman 	1 
¡¡once the specifications have been generalized  they can be propagated down through the proof tree. this is achieved by having a procedure for each rule which computes the  pre-conditions  for that rule. given a  post-condition  on 

	figure 1: 	a portion of the correctness proof tree 
proof tree contains information which may be used to identify constraints that must be preserved as the example is generalized. for this purpose  the proof was designed to be processed in both  forward  and  reverse  directions. running in the forward direction  the tree takes a design at the leaves and produces a specification at the root. in the reverse direction  the proof starts with a specification and produces a design. this suggests that the proof tree could be used to do circuit design by analogy  although that is not the direction taken here.  see  carbonell 1 .  there are four major steps involved in this method of generalization: 
generalization procedure 
1. generalize the specification. 
1. propagate the generalized specification through the tree. 
1. obtain constraints on the design at the leaves. 
1. apply problem independent constraints to the design. 
the first step involves systematically removing information from the specification. this is done by changing constants appearing in the specification into variables. the result is shown in figure 1. the specification now has three types of free parameters. the indices associated with the output wires have been generalized. the boolean control codes and the time values have also been changed into variables. only on the right hand side of the equality have constants been generalized. the left side was left alone due to a requirement that all output lines have their behavior specified by some clause. after all four clauses have been generalized  the specifications can express arbitrary the result of a proof rule  the procedure finds  preconditions  on the antecedents of the rule which guarantee that the post-condition will be true. each of the proof rules must be written in forward and backward versions. for example  the  replace rule  involves eliminating variables when running in the forward direction  and introducing variables when running in the backward direction. this method of backward constraint propagation has been applied in other learning systems such as  utgoff 1; minton 1   and the method is formalized in  dijkstra 1 . after the specifications have propagated through the tree  constraints on the circuit design are obtained at each of the leaves. 
   the final step involves applying some problemindependent constraints to the design statements generated at the leaves of the proof tree. these constraints require that the circuit design meet some general requirements that apply to all designs. for instance  one constraint requires that no input wire be connected to more than one output from another device. 
the generalized design 
a portion of the final design schema is shown in figure 
1. one part of this schema is a list of constraints on the parameters of the generalized specifications. the schema in figure 1 lists constraints on the time variables   time-1   
  time-1     time-1   etc. these constraints assert that the general design can only implement a one unit time delay. when these variables were first introduced  they allowed the specifications to express arbitrary time delays. now it turns out that the original specifications were over generalized. the time values were constrained as they propagated through the proof tree. this is a consequence of 
1 t. ellman the fact that the proof tree does not represent a reasoning process sufficiently general for implementing arbitrary delays. 
   the schema in figure 1 also lists statements describing connections between inputs of a multiplexer and outputs of d-flip-flops. these connections are not specified exactly. they depend on the parameters   index-1     index-1   
  index-1     value-1     value-1   and   value-1  which appear in the generalised specifications.  the expression   number  value-1   represents the integer corresponding to the two bit vector   value-1 .  these variables fell through the proof tree without having their values constrained. therefore  the multiplexer inputs may be connected to any of the d-flip-flop outputs. these degrees of freedom allow the schema to implement an arbitrary permutation of the four bits  and an arbitrary choice of control codes. the  index  parameters determine which permutations can be computed. the  value  parameters determine the corresponding control codes. this design schema can also be used to implement data rearrangement operations other than permutations. 

	figure 1: 	a portion of the generalized design 
conclusion 
   it has been shown that domain knowledge can be used to enable an intelligent system to generalize from a single example. in the area of design problems  a proof of correctness is a useful vehicle for applying domain knowledge to the task of generalization. the proof enables the generalizer to capture a chain of reasoning used to understand the original design. the resulting generalization represents all designs which can be verified using the same proof of correctness. 
acknowledgement 
   this paper and the work it reports have benefited greatly from numerous discussions with michael lebowitz. 
