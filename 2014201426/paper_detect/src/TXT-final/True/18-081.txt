 
consecutively bounded depth-first search involves repeatedly performing exhaustive depth-first search with increasing depth bounds of 1  1  1  and so on. the effect is similar to that of breadth-first search  but  instead of retaining the results at level n - 1 for use in computing level n  earlier results are recomputed. consecutively bounded depth-first search is useful whenever a complete search strategy is needed and either it is desirable to minimize memory requirements or depth-first search can be implemented particularly efficiently. it is notably applicable to automated deduction  especially in logic-programming systems  such as prolog and eqlog  and their extensions. consecutively bounded depth-first search  unlike unbounded breadthfirst search  can perform cutoffs by using heuristic estimates of the minimum number of steps remaining on a solution path. even if the possibility of such cutoffs is disregarded  an analysis shows that  in general  consecutively bounded depth-first search requires only b/b-1 times as many operations as breadthfirst search  where 1 is the branching factor.1 
1 	i n t r o d u c t i o n 
in this paper  we investigate the properties of consecutively bounded depth-first search. in this method  exhaustive depth-first 
search is repeatedly performed with increasing depth bounds of 1  1  1  and so on. the effect is similar to that of breadth-first search  but  instead of retaining the results at level n - 1 for use in computing level n  earlier results are recomputed.1 
   although this may appear to be a naive and costly search method  it is not necessarily so. it is sometimes advantageous to perform consecutively bounded depth-first search instead of the breadth-first search it imitates. one reason for this is that depth-first search requires much less memory. 
   consecutively bounded depth-first search can also make use of heuristic information  in contrast to unbounded breadth- and depth-first search-the latter are uninformed search strategies that do not take into account heuristic estimates of the remaining distance to a solution. informed search strategies such as the a* algorithm use such heuristic information to order the 
'this research was supported by the defenie advanced research projects agency under contract n1-k-1 with the naval electronic systems command. the views and conclusions contained in this document are those of the authors and should not be interpreted as representative of the official policies  either expressed or implied  of the defense advanced research projects agency or the united states government. approved for public release. distribution unlimited. 
1 we assume a basic familiarity with standard breadth-first  depth-first  and a* search strategies  e.g.  see nilsson  . 
search space. consecutively bounded depth-first search does not do that  but can use an estimate of the minimum number of remaining steps to a solution to perform cutoffs if the estimate exceeds the number of levels left before the depth bound is reached. if the number of remaining levels is uniformly exceeded by these estimates by more than one level  then one or more levels can be skipped when the next depth bound is set. as with the a* algorithm  admissability the guarantee of finding a shortest solution path first is preserved provided the heuristic estimate never exceeds the actual number of remaining steps to a solution 
   another advantage of consecutively bounded depth-first search stems from the fact that  in some applications  depthfirst search can be implemented with much higher efficiency than breadth-first search; consecutively bounded depth-first search combines this efficiency with the completeness of breadth-first search. in these applications  the greater efficiency of depthfirst search more than compensates for the effort of recomputing 
earlier-level results in consecutively bounded depth-first search. a specific instance of this is prolog-style automated deduction. prolog's use of depth-first search contributes significantly to its performance. if depth-first search were not used  more than one derived clause would have to be represented simultaneously and variables would have more than a single value simultaneously  i.e.  different values in different clauses. this would imply the need for a more complex and less efficient representation for variable bindings than the one prolog currently uses. 
   one of our interests is in adapting prolog implementation technology to the design of high-performance general automateddeduction systems . for general deduction  prolog's depthfirst search is incomplete and of limited utility. but to adopt breadth-first search would result in losing the efficiency advantages of prolog's representation for variable bindings. performing bounded depth-first search would preserve the depthfirst character of the search while allowing exhaustive searching of the space to a specified level. 
   there is still the problem of selecting the depth bound. in an exponential search space  searching with a higher-than-necessary depth bound can waste an enormous amount of effort before the solution is found. this is because the cost of searching level tt in an exponential search space is generally large compared with the cost of searching earlier levels. 
   but this also makes it practical to perform consecutively bounded depth-first search. the depth bound is set successively at 1  1  '1  etc.  until a solution is found. if a uniform brandling factor 1 is assumed  this results in only about b/b-1t times as many operations as are necessary for breadth-first search to the same depth. 
another potential application in automated deduction and 

1 m. stickel and w tyson 


m. stickel and w. tyson 1 
   if the sum of the differences is positive  then the added efficiency in dealing with problems whose first solution is on an even level outweighs any extra overhead expended upon problems whose first solution is on an odd level. if that is so  evenly bounded depth-first search is clearly more efficient than consecutively bounded depth-first search. analysis reveals that evenly bounded depth-first search is always preferable for a branching factor of 1  or less   while consecutively bounded depth-first search is preferable for a branching factor of 1 or more for a branching factor of .1  the advantages of finding solutions on even levels are approximately equal to the disadvantages of finding 
solutions on odd levels. 
	1 	conclusion 
we have analyzed the behavior of consecutively bounded depthfirst search. this strategy is useful whenever a complete search strategy is needed  and either it is desirable to minimize memory requirements or depth-first search can be implemented particularly efficiently. moreover  consecutively bounded depth-first search  in contrast to the unbounded breadth-first search it almost emulates  can take advantage of heuristic estimates of the minimum number of steps remaining on a solution path to perform cutoffs if that number exceeds the number of levels left before the depth bound is reached. even if the possibility of such cutoffs is disregarded  we have found the performance penalty resulting from the use of consecutively bounded depth-first search to be small when compared with breadth-first search the former performs only b/b1 times as many operations as the latter  where b is the branching factor. 
