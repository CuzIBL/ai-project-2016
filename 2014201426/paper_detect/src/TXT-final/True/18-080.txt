 
　　　this work aims towards the automatic generation of advice to guide the solution of difficult constraintsatisfaction problems  csps . the advice is generated by consulting relaxed  easy models which are backtrackfree. 
　　　we identify a subset of csps whose syntactic and semantic properties make them easy to solve. the syntactic properties involve the structure of the constraint graph  while the semantic properties guarantee some local consistencies among the constraints. in particular  problems supported by tree-like constraint graphs  and some width-1 graphs  can be easily solved and are therefore chosen as the target model for the relaxation scheme. optimal algorithms for solving easy problems are presented and analyzed. finally  an efficient method is introduced for extracting advice from easy problems and using it to speedup the solution of hard problems. 
i introduction 
a. why study easy problems  
　　　an important component of human problemsolving expertise is the ability to use knowledge about solving easy problems to guide the solution of difficult ones. only a few works in a i -   - have attempted to equip machines with similar capabilities. gaschnig   guida et.al.   and pearl  suggested that knowledge about easy problems could be instrumental in the mechanical discovery of heuristics. accordingly  it should be possible to manipulate the representation of a difficult problem until it is transformed into an easy one  solve the easy problem  then use the solution to guide the search process in the original problem. 
　　　the implementation of this scheme requires three major steps: 1. simplification  1. solution  1. advice generation. additionally  to perform the simplification step  we must have a simple  a-priori criterion for deciding when a problem lends itself to easy solution. 
*this work was supported in part by the national science foundation  grant #mcs 1. 
this paper uses the domain of constraint-
satisfaction tasks to examine the feasibility of these three steps. it establishes criteria for recognizing classes of easy problems  it provides special procedures for solving them  and it introduces an efficient method of extracting advice from them. 
　　　constraint-satisfaction problems  csp  involve the assignment of values to variables subject to a set of constraints. understanding three-dimensional drawings  graph coloring  electronic circuit analysis  and truth maintenance systems are examples of csp problems. these are normally solved by some version of backtrack search which may require exponential search time  for example  the graph coloring problem is known to be npcomplete.  
　　　in general  a problem is considered easy when its representation permits a solution in polynomial time. however  since we are dealing mainly with backtrack algorithms  we will consider a csp easy if it can be solved by a backtrack-free procedure. normally  a backtracking algorithm instantiates variables in a predetermined order  and for each next variable it chooses one value that is consistent with all previous assignments. if it doesn't find one  it backtracks to the previous variable  tries a new assignment for it  and continues from there. the algorithm stops when all variables have been assigned values or when no new untried values are left for the first variable. a backtrack-free search is one in which the backtracking algorithm completes without backtracking  thus producing a solution in time linear with the number of variables. 
r. dechter and j. pearl 1 
targets for a problem simplification scheme; constraints 　　　most of our discussion is based on the concept of constraint-graphs  in which the nodes represent variables and the undirected arcs represent the existence of an explicit constraint between them. freuder  has identified sufficient conditions for a constraint graph to yield a backtrack-free csp  and has shown  for example  that tree-like constraint graphs can be made to satisfy these conditions  with a small amount of processing. our main purpose here is to further study classes of constraint graphs lending themselves to backtrack-free solutions and to devise efficient algorithms for solving them. once these classes are identified they can be chosen as can be selectively deleted from the original specification so as to transform the original problem into a backtrackfree one. the simplified problem can then provide advice on choices pending in the original problem. for example  we propose to use the  number of consistent solutions in the simplified problem  as a figure of merit to establish priority of value assignments in the backtracking search of the original problem. we show that this figure of merit can be computed in time comparable to that of finding a single solution to an easy problem.  for details regarding the process of constraint-deletion see .  
b. definitions and nomenclature 
definition 1   : an ordered constraint graph is a constraint graph in which the nodes are linearly ordered to reflect the sequence of variable assignments executed by the backtrack search algorithm. the width of a node is the number of arcs that leads from that node to previous nodes  the width of an ordering is the maximum width of all nodes  and the width of a graph is the minimum width of all the orderings of that graph. 

　　　figure 1 presents three possible orderings of a constraint graph. the width of node c in the first ordering  from the left  is 1  while in the second ordering it is 1. the width of the first ordering is 1 while that of the second is 1. the width of the constraint graph is  therefore  1. freuder provided an efficient algorithm for finding both the width of a graph and the ordering corresponding to this width. he further showed that a 
　　　constraint graph is a tree iff it is of width 1. 
　　　montanari  and mackworth  have introduced two kinds of local consistencies among constraints named arc consistency and path consistency. their definitions assume that the graph is directed  i.e.  each symmetric constraint is represented by two directed arcs. 


　　　a constraint graph is arc  path  consistent if each of its directed arcs  paths  is arc  path  consistent. achieving  arc-consistency  means deleting certain values from the domains of certain variables such that the resultant graph will be arc-consistent  while still representing the same overall set of solutions. to achieve pathconsistency  certain pairs of values that were initially allowed by the local constraints should be disallowed. montanari and mackworth have proposed polynomialtime algorithms for achieving arc-consistency and path consistency. in  it is shown that arc consistency can be achieved in 1 ek1  while path consistency can be achieved in o n1 . n is the number of variables  k is the number of possible values  and e is the number of edges. 
the following theorem is due to freuder. 
theorem 1  
 a  if the constraint graph has a width 1  i.e. the constraint graph is a tree  and if it is arc consistent then it admits backtrack-free solutions. 
 b  if the width of the constraint graph is 1 and it is also path consistent then it admits backtrack-free solutions. 
the above theorem suggests that tree-like csfs 
 csps whose constraint graphs are trees  can be solved by first achieving arc consistency and then instantiating the variables in an order which makes the graph have width 1. since this backtrack-free instantiation takes 1 ek  steps the whole problem can be solved in 1 nk1  and  therefore  tree-like csp's are easy. the test for this property is also easily verified; to check whether or not a given graph is a tree can be done by a regular o n1  spanning tree algorithm. 
　　　it is important to note that a given csp may have several equivalent representations  in the sense of admitting the same set of solutions. yet each representation may have a different constraint-graph  one of which may be a tree. however  testing whether a csp has an equivalent tree representation and finding such a representation might be a very difficult task. 
　　　the second part of the theorem tempts us to conclude that a width-1 constraint graph should admit a backtrack-free solution after passing through a path-

1 r. dechter and j. pearl 
consistency algorithm. in this case  however  the path consistency algorithm may add arcs to the graph and increase its width beyond 1. this often happens when the algorithm deletes value-pairs from a pair of variables that were initially related by the universal constraint  having no connecting arc between them   and it is often the case that passage through a path-consistency algorithm renders the constraint-graph complete. it may happen  therefore  that no advantage could be taken of the fact that a csp possesses a width-1 constraint graph if it is not already path consistent. we are not even sure whether width-1 suffices to preclude np-completeness. 
　　　in the following section we give weaker definitions of arc and path consistency which are also sufficient for guaranteeing backtrack-free solutions but have two advantages over those defined by montanari  and mackworth : 
1. they can be achieved more efficiently  and 
1. they add fewer arcs to the constraint-graph  thus preserving the graph width in a larger classes of problems. 
n algorithms for achieving directional consistency 
a. case of width-1 
　　　in constraint-graphs which are trees  full arcconsistency is more than what is actually required for enabling backtrack-free solutions. for example  if the constraint graph in figure 1 is ordered by  v1 v1 v1 v1   nothing is gained by making the directed arc  v v   consistent. 
to ensure backtrack-free assignment  we need only make sure that any value assigned to variable v  will have at least one consistent value in dy this can be achieved by making only the directed arc  v1 v1  consistent  regardless of whether iy v   is consistent. we therefore see that arc-consistency is required only w.r.t. a single direction  the one specified by the order in which the backtrack algorithm will later choose variables for instantiations. this motivates the following definitions. 
definition: given an order d on the constraint graph 

revise vj.vi . to destroy the consistency of  vjvi   some values should be deleted from the domain of v  during the continuation of the algorithm. however  according to the order by which revise is performed from this point on  only lower indexed variables may have their set of values updated. therefore  once a directed arc is made arc-consistent its consistency will not be violated. 
the algorithm ac-1  that achieves full arc-consistency is given for reference: 

the complexity of ac-1  achieving full arc-consistency  is 1 ek1 . by comparison  the directional arc-consistency algorithm takes ek1 steps since the revise algorithm  taking k1 tests  is applied to every arc exactly once. it is also optimal  because even to verify directional arcconsistency each arc should be inspected once  and that takes k1 tests. note that when the constraint graph is a tree  the complexity of the directional arc-consistency algorithm is 1 nk1 . 
theorem 1: 
a tree-like csp can be solved in o nk1  steps and this is optimal. proof: 
given that we know that the constraint graph is a tree  finding an order that will render it of width-1 takes 1 n  steps. a width-1 tree-csp can be made d-arc-consistent in n k1 steps  using the dac algorithm. the backtrackfree solution on the resultant tree is found in 1 nk . finding a solution to tree-like csps takes  therefore  
1 nk  + oink1  + 1 n  = oink1 . this complexity is also optimal since any algorithm for solving a tree-like problem must examine each constraint at least once  and each such examination may take in the worst case k1  especially when no solution exist and the constraints permit very few pairs of values . 
　　　interestingly  if we apply dac w.r.j. order d and then dac w.r.t. the reverse order we get a full arcconsistency for trees. we can  therefore  achieve full 
r. dechter and j. pearl 1 
arc-consistency on trees in 1 nk1 . algorithm ac-1  on the other hand  can be shown to have a worst case performance on trees of 1 nk1 . on general graphs  however  the  full  arc-consistency algorithm cannot be improved  and the ac-1 algorithm is optimal  see  . 
　　　returning to our primary aim of studying easy problems  we now show how advice can be generated for solving a difficult csp using a relaxed tree-like approximation. suppose that we want to solve an n variables csp using a backtrack procedure with v l v 1   . . .  vn as the order of instantiation. let v1 be the variable to instantiate next  with vn vl1  . . .  v# the possible candidate values. to minimize backtracking we should first try values which arc likely to lead to a consistent solution but  since this likelihood is not known in advance  we may estimate it  instead  by counting the number of consistent solutions that each candidate admits in some relaxed problem. we generate a relaxed tree-like problem by deleting some of the explicit constraints given  then count the number of consistent solutions containing each of the possible k assignments  and finally use these counts as a figure of merit for scheduling the various assignments. in the following we show how the counting of consistent solutions can be imbedded within the darc-consistency algorithm  dac  on trees. 
　　　any width-1 order  d  on a constraint tree determines a directed tree in which a parent always precedes its children in d  arcs are directed from the parent to its children . let n vjt  stands for the number of solutions in the subtree rooted at vj  consistent with the assignment of vj to vj. it can be shown that n .  satisfies the following recurrence: 

from this recurrence it is clear that the computation of n vu  may follow the exact same steps as in dac; simultaneously with testing that a given value vjn is consistent with each of its children nodes  we simply transfer from each child of vj to vjt the sum total of the counts computed for the child's values that are consistent with vjt . the overall value of n vjt  will be computed later on by multiplying together the summations obtained from each of the children. thus  counting the number of solutions in a tree with n variables takes 1 nk1   the same as establishing directional arc-consistency. 
b. caseofwidth-1 
　　　order information can also facilitate backtrackfree search on width-1 problems by making pathconsistency algorithms directional. 
　　　montanari had shown that if a network of constraints is consistent w.r.t. all paths of length 1  in the complete network  then it is path-consistent. similarly we will show that directional path-consistency w.r.t. length-1 

1 r. dechter and j. pearl 


　　　a ring constitutes an example of a regular width-1 graph. figure 1 shows an ordering of a ring's nodes and the graph resulting from applying the dpc algorithm to the ring. both graphs are of width-1. 
theorem 1: 
a regular width-1 csp can be solved in 1 n1 . 
proof: 
regular width-1 problem can be solved by first applying the dpc algorithm and then performing a backtrack-free search on the resulting graph. the first takes 1 n1  steps and the second 1 ek  steps. 
d 
　　　the main problem with the preceding approach is whether a regular width-1 csp can be recognized from the properties of its constraint graph. one promising approach is to identify nonseparable components of the graph and all its separation vertices . 
definition: a connected graph g v e  is said to have a separation vertex v if there exist vertices a and b  such that all the paths connecting a and b pass through v. a graph which has a separation vertex is called separable  and one which has none is called nonseparable. 
an 1{ e   algorithm for finding all the nonseparable components and the separation vertices is given in . it is also shown that the connectivity structure between the nonseparable components and the separation vertices  has a tree structure. 
the following points can be made: 
1. given any ordered constraint graph in which the separation vertices and the nonseparable components are identified  the directional pathconsistency algorithm adds arcs only within each component. 
1. let r be a graph and sr be the tree in which the nonseparable components c1  . . .  cr and the separating vertices v1         v1 are represented by nodes. a width-1 ordering of rs dictates a partial order on r d1 in which each separating vertex precede all the vertices in its children components of sr. it can be shown that if there exist a ds ordering on r such that each nonseparable component is rcgular-width-1 then the total ordering is regular width-1. 
as a corollary of these two points we conclude that a tree of simple rings is regular width-1. 
r. dechter and j. pearl 1 
id summary and conclusions 
　　　this paper examines the process of harnessing easy problems to help in the solution of complex constraint-satisfaction problems. of the three main steps involved in this process - simplification  solution  and advice generation - we concentrated on the following: 
1. the simplification part: we have devised criteria for recognizing easy problems based on their underlying constraint graphs. the characteristics that meet these criteria can be used as goals for simplifying complex problems by deleting some of their constraints. the introduction of directionality into the notions of arc and path consistency enable us to extend the class of recognizable easy problems beyond trees  to include regular width-1 problems. 
1. the solution part: using directionality we were able to devise improved algorithms for solving simplified problems and to demonstrate their optimality. in particular  it is shown that treestructured problems can be solved in o nk1  steps  and regular width-1 problems in 1 n1  steps. 
1. the advice generation part: we have demonstrated a simple method of extracting advice from easy problems to help a backtracking algorithm decide between pending options of value assignments. the method involves approximating the remaining part of a constraint-satisfaction task by a treestructured problem  and counting the number of solutions consistent with each pending assignment. these counts can be obtained efficiently and can be used as figures of merit to rate the promise offered by each option. 
　　　in experiments  fully reported in   we compared the performance of a regular backtrack algorithm  rbt  with advised backtrack  abt  on a set of randomly generated csp problems. initial results showed that the quality of the advice generated on the basis of a full spanning tree was sufficient to cut down substantially the number of backtrackings  typically from about 1 to 1. in many cases  however  the number of consistency checks required for generating this advice made the overall computational work higher then that of rbt. we interpreted this result to mean that the advice generated was too precise in the sense that further simplification should be attempted to cut down the work spent on advice generation. for that reason we experimented with advice generated by partially developed trees  namely  only a limited number  /  of nodes were spanned by the advising tree. the parameter / governs the strength of the advice  /=l ... n. figure 1 shows the performance of abt as a function of / on a typical problem. the two criteria by which performance was judged were the number of backtrackings performed and the number of 1 r. dechter and j. pearl 
consistency checks i.e the number of times any two values were tested for consistency w.r.t. some constraint. for comparison  the results for rbt are shown at the point /= 1  by triangle points . the numbers labeling points on the graph indicate the amount of backtrackings. typically the amount of backtracking was considerably smaller in abt then in rbt even for weak advice  however the total work invested in full advise  using all nodes in the tree  was not always worthwhile and a weaker advice was sufficient. the dip in the curve represents an optimal balance between the effort spent in generating advice and the amount of backtracking it saves. 

　　　although the primary discussion in this paper has focused on guiding the selection of values within a given variable  the properties of tree-structured networks can also be exploited to optimize the ordering of variables. one such scheme  which promises unusual possibilities  is based on the following observation: if  in the course of a backtrack search  we remove from the constraint graph the nodes corresponding to already instantiated variables and find that the remaining subgraph is a tree  then the rest of the search can be completed in linear time  e.g.  using the dac algorithm of section ii . consequently  the aim of ordering the variables should be to instantiate  as quickly as possible  a set of variables that cut all cycles in the network. indeed  if we identify m variables which form such a cycle-cutset  the entire csp can be solved in at most 1 itmnjt1  steps; we simply solve the trees resulting from each of the km possible instantiations of the variables in the cutset. thus  in networks where the ratio n/m is large  enormous savings can be realized using simple heuristics for selecting near-minimal cyclecutsets. 
