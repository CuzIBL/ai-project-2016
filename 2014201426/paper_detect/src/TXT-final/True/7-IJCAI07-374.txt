
we integrate a number of new and recent advances in heuristic search  and apply them to the fourpeg towers of hanoi problem. these include frontier search  disk-based search  parallel processing  multiple  compressed  disjoint  and additive pattern database heuristics  and breadth-first heuristic search. new ideas include pattern database heuristics based on multiple goal states  a method to reduce coordination among multiple parallel threads  and a method for reducing the number of heuristic calculations. we perform the first complete breadth-first searches of the 1 and 1-disc fourpeg towers of hanoi problems  and extend the verification of  presumed optimal solutions  to this problem from 1 to 1 discs. verification of the 1-disc problem is in progress.
1 towers of hanoi problems
the standard towers of hanoi problem consists of three pegs  and n different sized discs  initially stacked in decreasing order of size on one peg. the task is to transfer all the discs from the initial peg to a goal peg  by only moving one disc at any time  and never placing a larger disc on top of a smaller disc. to move the largest disc from the initial peg to the goal peg  none of the smaller discs can be on either peg  but must all be on the remaining auxiliary peg.1 this generates a subproblem of the same form as the original problem  allowing a simple recursive solution. it is easily proven that the shortest solution to this problem requires 1n 1 moves.
　the problem becomes more interesting if we add another peg  see figure 1 . while the four-peg towers of hanoi problem is 1 years old  hinz  1   the optimal solution length is not known in general. the difficulty is that moving the largest disc from the initial to the goal peg requires that the remaining discs be distributed over the two auxiliary pegs  but we don't know a priori how to distribute them in an optimal solution. in 1  a recursive strategy was proposed that constructs a valid solution  frame  1; stewart  1   and optimality proofs of this  presumed optimal solution  were offered  but they contained an unproven assumption  dunkel  1   and the conjecture remains unproven. absent a proof  the only way to verify optimality of this solution for a given number of discs is by a systematic search for shorter solutions. previously this had been done for up to 1 discs  korf  1   and we extend it here to 1 discs. the size of the problem space is 1n  where n is the number of discs  since each disc can be on any of four pegs  and the discs on any peg must be in sorted order. thus  each new disc multiplies the size of the problem space by four.

figure 1: four-peg towers of hanoi problem
1 prior work on four-peg towers of hanoi
the simplest searchis a brute-forcesearch  with no heuristics. complete breadth-first searches  generating all states from a given initial state  have previously been done for up to 1 discs  korf  1 .
　there are two different symmetries that can be used to speed up this search. the first is that transferring the discs from an initial peg to any of the other three pegs are equivalent problems. thus  given any state  we sort the three noninitial pegs in order of their largest disc  reducing the number of states by almost a factor of six  bode & hinz  1 . the reduction is slightly less than six because if two non-initial pegs are empty  permuting them has no effect.
　the other is a symmetry of the solution path  bode & hinz  1 . assume that we find a path to a middle state  where all discs but the largest are distributed over the two auxiliary pegs. we can then move the largest disc from the initial to the goal peg. if we then execute the moves made to reach the middle state in reverse order  we will return all but the largest disc to the initial peg. if  however  while executing these moves  we interchange the initial and goal pegs  we will move all but the largest disc to the goal peg  completing the solution. thus  once we reach a middle state  we can generate a complete solution  and a shortest path to a middle state generates a shortest solution path. in practice  this cuts the search depth in half  and we refer to this as a half-depth search.
　 korf  1  used both these symmetries in a brute-force half-depth search to verify the presumed optimal solution lengths for up to 1 discs. additional techniques he used  such as frontier search  storing nodes on magnetic disk1  and parallel processing  are discussed below.
　verifying the optimal solution length for more discs requires a heuristic search. previously  the largest four-peg towers of hanoi problem that had been solved optimally with heuristic search was 1 discs  zhou & hansen  1   compared to 1 discs for brute-force half-depth search. the reason is because the heuristic search was a full-depth search  computing the heuristic to the single goal state.
　the most important new idea in this paper is how to compute a heuristic that estimates the length of a shortest path to any of a number of goal states. this allows us to implement a heuristic half-depth search  by estimating the length of a shortest path to a middle state. the naive approach of computing a heuristic to each middle state  and taking the minimum of these values for each state of the search  is impractical with a large number of middle states. for the n-disc  four-peg problem  there are 1n 1 possible middle states  one for each way to distribute the n 1 smallest discs over the two auxiliary pegs. this can be reduced to 1n 1  by assigning the second-largest disk to one of the auxiliary pegs.
1 pattern database heuristics
pattern databases lookup tables stored in memory  culberson & schaeffer  1   and are the most effective heuristics known for many problems  including rubik's cube  korf  1  and the sliding-tile puzzles  korf & felner  1 . a pattern database for the towers of hanoi contains an entry for each possible configuration of a subset of the discs  the pattern discs. the value of each entry is the number of moves required to move the pattern discs from their given configuration to the goal peg  ignoring all other discs  felner  korf  & hanan  1 . given a problem instance  for each state in the search  we use the configuration of the pattern discs to compute an index into the database. the corresponding value is then used as a lower-bound estimate of the number of moves needed to move all the discs to the goal peg.
　the size of a pattern database depends on the number of pattern discs. we can represent any configuration of n discs by a unique index in the range 1 to 1n   1  by encoding the location of each disc with two bits  and using the resulting 1n-bit binary number as the index. thus  we only store the heuristic values and not the corresponding states in the database. if the values are less than 1  each value is stored in a single byte. thus  a pattern database of 1 discs requires 1 = 1 bytes  or a gigabyte of memory.
　to construct such a pattern database  we performa breadthfirst search starting with all 1 discs on the goal peg. as each new configuration of discs is first encountered  we store the corresponding search depth in the database. this search continues until all configurations have been generated. a pattern database is only constructed once  and can be used to solve any problem instances with the same goal state. note that any set of 1 different-sized discs generate exactly the same pattern database  regardless of their actual sizes.
1 multiple-goal pattern databases
our main new contribution is pattern databases for multiple goal states. rather than initializing the breadth-first search queue with one goal state  we seed it with all the goal states at depth zero. then  the depth of any state in the breadth-first search is the length of a shortest path to any goal state.
　for example  to construct a pattern database of the number of moves needed to transfer 1 discs to two auxiliary pegs  we initialize the search queue with all 1 states in which the 1 discs are distributed among the two auxiliary pegs  and assign each a value of zero in the database. the breadth-first search runs until all configurations of 1 discs have been generated  recording their depths in the database. thus  for any state  the database value is the minimum number of moves needed to move all the discs to the two auxiliary pegs.
　while this may appear obvious in hindsight  it escaped the attention of at least three groupsof researchersworking on the towers of hanoi.  felner  korf  & hanan  1  used heuristic search with additive pattern database heuristics to solve up to 1 discs.  felner et al.  1  used compressed pattern databases to solve up to 1 discs.  zhou & hansen  1  solved up to 1 discs  using breadth-first heuristic search with pattern databases. all of these were full-depth heuristic searches to a single goal state  using pattern database heuristics. at the same time  all of these researchers knew that brute-force half-depth searches to multiple goal states could solve larger problems  korf  1   but didn't see how to combine the two together.
　multiple-goal pattern databases also have real-world applications. consider a car navigation system that must quickly plan a route to the nearest hospital. we first run dijkstra's algorithm  dijkstra  1  in a preprocessing step  initially seeded with all hospital locations  storing with each map location the distance to the closest hospital. for this search  the direction of any one-way streets is reversed. then  when the user requests a route from his current location to the nearest hospital  a* will find an optimal path in linear time  since the heuristic is exact. as another application  suppose we want to label each address in a city with the identity of the closest fire station  to aid in dispatching fire trucks. we run dijkstra's algorithm  initially seeded with the location of all fire stations  but modified so that each node also includes the identity of the closest fire station  in addition to its distance. in this case  we don't reverse one-way streets  because we are traveling from the fire station to the address.
　in addition to multiple-goalpattern databases  verifyingthe presumed optimal solution of the 1-disc problem required integrating a number of additional recent and new research results in heuristic search  which we discuss below.
1 frontier search
the limiting resource for both breadth-first search to generate pattern databases  and heuristic search to verify optimal solutions  is storage for search nodes. linear-space depthfirst searches are completely impractical for this problem  because they generate too many duplicate nodes representing the same state. to reduce the number of stored nodes  we use frontier search  korf et al.  1 . for simplicity  we describe breadth-first frontier search. a standard breadth-first search stores all nodes generated in either a closed list of expanded nodes  or an open list of nodes generated but not yet expanded. frontier search saves only the open list  and not the closed list  reducing the nodes stored from the total number of nodes in the problem  to the maximum number of nodes at any depth  or the width of the problem. for example  the total number of states of of the 1-disc  four-peg towers of hanoi problem is 1 or 1 trillion  while the width of the problem is only 1 billion states  a savings of a factor of 1. it also saves with each node the operators used to generate it  to avoid regenerating the parent of a node as one of its children. additional work is required to generate the solution path. in our case  however  we don't need the solution path  but simply the depth of a given node  both to generate pattern databases  and to verify presumed optimal solutions.
1 storing nodes on disk
unfortunately  1 billion nodes is too many to store in memory. one solution is to store nodes on magnetic disk  korf  1; 1; korf & shultze  1 . the challenge is to design algorithms that rely on sequential access  since random access of a byte on disk takes about five milliseconds.
　the main reason to store nodes is to detect duplicates  which are nodes representing the same state  but reached via different paths. this is normally done with a hash table  which is randomly accessed whenever a node is generated. on disk  however  duplicates nodes are not checked for immediately  but merged later in a sequential pass through the disk. when this delayed duplicate detection is combined with frontier search in a problem such as the towers of hanoi  two levels of the search tree must be stored at once  korf  1 .
　the algorithm expands one level of the search space at a time. there are two types of files: expansion files that contain no duplicate nodes  and merge files that contain duplicates. all nodes in a file are at the same depth. when expansion files are expanded  their children are written to merge files at the next depth. for fault tolerance  and ease of interrupting and resuming the program  we save all expansion files at the current depth  until completing the iteration to the next depth. all nodes in the same file have their largest discs in the same positions. the nodes within a file specify the positions of the 1 smallest discs. the 1 bits needed to specify 1 discs  plus four used-operator bits  equals 1 bits or a single word. for example  the 1-disc problem requires storing the positions of 1 discs. the positions of the 1 smallest discs are stored with each node  and the positions of the remaining 1 discs are encoded in the file name  generating up to 1「 1 million file names.
　previous implementations of this algorithm  korf  1; 1; korf & shultze  1  have stored in memory an array entry for each possible file name  but this doesn'tscale to very large name spaces. instead  we maintain in memory a hash table with the names of the files that exist at any point in time. for each file name  we store whether a corresponding expansion file exists at the current and/or next depth  whether the former has been expanded  whether a merge file exists  and a list of the expansion file names that could contribute children to this merge file. to conserve disk space  we merge merge files as soon as all such expansion files have been expanded.
1 parallel processing
any i/o intensive algorithm must be parallelized to utilize the cpu s  while a process blocks waiting for i/o. furthermore  increasingly common multi-processor systems  and multiplecore cpus  offer further opportunities for parallelism. our algorithm is multi-threaded  with different threads expanding or merging different files in parallel. merging eligible files takes priority over file expansions.
　since all nodes in a given file have their largest discs in the same positions  any duplicate nodes are confined to the same file  and duplicate merging of different files can be done independently. when expanding nodes  however  any children generated by moving the large disks will be written to different merge files  and the expansion of two different files can send children to the same merge file. previous implementations of this algorithm  korf  1; 1; korf & shultze  1  have coordinated multiple threads so that files that can write children to the same merge file are not expanded at the same time. in our implementation  we remove this restriction. two different threads may independently write children to the same merge file  as long as the files are opened in append mode. this both simplifies the code and speeds it up  since it requires almost no coordination among multiple threads.
1 compressed pattern databases
a pattern database heuristic that includes more components of a problem is more accurate  since the database reflects interactions between the included components. in the case of the towers of hanoi  the more discs that are included  the more accurate the heuristic. the limitation is the memory to store the database. for example  a full pattern database based on the 1-disc four-peg problem would require 1 or about 1 trillion entries. we can  compress  such a pattern database into a smaller database that will fit in memory  however  with only a modest lost of accuracy  as follows.
　we generate the entire 1-disc problem space in about 1 days  using disk storage. as each state is generated  we use the configuration of say the 1 largest discs as an index into a pattern database  and store in that entry the shallowest depth at which that configuration of 1 discs occurs. that entry is the minimum number of moves required to move all 1 discs to their goal peg  where the minimization is over all possible configurations of the remaining seven smallest discs. the values in this pattern database are significantly larger than the corresponding entries in a simple 1-disc pattern database  because the latter values ignore any smaller discs. this is called a compressed pattern database  felner et al.  1   and occupies only a gigabyte of memory in this case.
　to use this compressed pattern database in a search of a problem with at least 1 discs  for each state we look up the position of the 1 largest discs  and use the corresponding table value as the heuristic for that state.
1 disjoint additive pattern databases
consider a towers of hanoi problem with 1 discs  a simple 1-disc pattern database  and an seven-disc pattern database. a move only moves a single disc. thus  given any configuration of the 1 discs  we can divide them into any two disjoint groups of 1 and seven discs each. we look up the configuration of the 1 discs in the 1-disc database  look up the configuration of the seven discs in the eightdisc database  and sum the resulting values to get an admissible heuristic for the 1-disc problem. this is called a disjoint additive pattern database  korf & felner  1; felner  korf  & hanan  1 . there is nothing special about this 1 split  but maximizing the size of the largest database gives the most accurate heuristic values.
　we can add values from a compressed database the same way. again assume a problem with 1 discs  a 1-disc pattern database compressed to the size of a 1-disc database  and a simple seven-disc database. given a state  we use the 1 largest discs to represent the 1 largest discs  and look up the corresponding entry in the compressed pattern database. we also look up the configuration of the seven smallest discs in the eight-disc database  and add these two heuristic values together  to get an admissible heuristic for all 1 discs.
1 multiple pattern databases
in order to sum the values from two different pattern databases  the corresponding sets of elements must be disjoint  and every movemust moveonly a single element. however  given any two admissible heuristic functions  their maximum is also admissible. furthermore  the maximum of several different pattern database heuristics is often more accurate than the value from a single pattern database of the same total size  and more than compensates for the overhead of the additional lookups  holte et al.  1 .
　continuing our example with 1 discs  we can construct two different admissible heuristics as follows: one divides the 1 discs into the 1 largest and seven smallest discs  adding their pattern database values  and the other divides them into the seven largest and 1 smallest discs  again adding their database values. finally  we take the maximum of these two values as the overall heuristic value. we can use the same two databases for both heuristics.
1 breadth-first heuristic search
frontier search with delayed duplicate detection can be combined with a best-first heuristic search such as a*  hart  nilsson  & raphael  1   but a best-first search frontier includes nodes at different depths  and is usually larger than a breadth-first search frontier  with all nodes at the same depth. a better solution to this problem is breadth-first heuristic search  bfhs   zhou & hansen  1 .  bfhs  is given a cost threshold  and searches for solutions whose cost does not exceed that threshold. the cost of a node n is f n  = g n +h n   where g n  is the cost from the initial state to node n  and h n  is the heuristic estimate of the cost of reaching the goal from node n. bfhs is a breadth-first search  but any node whose total cost exceeds the cost threshold is deleted. bfhs is also a form of frontier search  and only stores a few levels of the search at a time. thus  once a solution is found  additional work is required to construct the solution path. if the optimal solution cost is not known in advance  breadth-first iterative-deepening-a*  zhou & hansen  1  performs a series of iterations with successively increasing cost thresholds  until an optimal solution is found.
　bfhs is ideally suited to the towers of hanoi for several reasons. one is that to verify optimality of the presumed optimal solutions  we don't need to construct the solution paths  but simply show that no shorter solutions exist. if we were to find a shorter solution  however  we would need to generate it to verify its correctness. secondly  since we know the presumed optimal solution length in advance  we could set the cost threshold to one less than this value  and perform a single iteration  eliminating iterative deepening.
1 minimizing heuristic calculations
for many search problems  the time to compute heuristic evaluations is a significant fraction of the running time. this is particularly true of large pattern databases  since they are randomly accessed  resulting in poor cache performance.
　for pattern database heuristics  we can determine the maximum possible heuristic value from the maximum values in each database. for search algorithms such as bfhs or iterative-deepening-a*  ida*   korf  1   pruning occurs by comparison to a given cost threshold. we can speed up these searches by only computing heuristics for nodes that can possibly be pruned. in particular  if t is the cost threshold  and m is the maximumpossible heuristic value  then we don't compute heuristics for those nodes n for which g n +m ＋ t  since they can't possibly be pruned. we don't need to compute the heuristic at the shallowest possible depth that pruning could occur either  since the cost of additional node expansions may be compensated for by the faster speed of a brute-force search. since bfhs searches breadth-first  we don't even need to load the pattern databases until the depth at which we start computing heuristics  saving the memory for additional parallel threads.
1 brute-force search experiments
we first ran complete brute-force searches of the four-peg towers of hanoi  both to compute pattern databases  and for another reason as well. for the three-peg problem  a breadthfirst search to depth 1n 1  starting with all discs on one peg  will generate all states of the problem at least once. thus  1n 1 is the radius of the problem space from this initial state. for the three-peg problem  this radius is the same as the optimal solution length to move all discs from one peg to another.
　it was believed that this was true of the four-pegproblem as well. however   korf  1  showed that this is not true for the 1-disc and 1-disc four-peg problems. for the 1-disc problem  1 moves are needed to move all discs from one peg to another  but there exist 1 states that are 1 moves from the standard initial state. for the 1-disc problem  the optimal solution is 1 moves  but the radius of the problem from the standard initial state is 1 moves. what happens for larger problems was unknown.
　we ran the first complete breadth-first searches of the 1and 1-disc four-peg towers of hanoi problems  starting with all discs on one peg. the machine we used is an ibm intellistation a pro  with dual two gigahertz amd opteron processors  and two gigabytes of memory  running centos linux. we have three terabytes of disk storage available  consisting of four 1 gigabyte firewire external drives  and a 1 and two 1 gigabyte internal serial ata drives.
　table 1 shows our results. the first column shows the number of discs  the second column the optimal solution length to transfer all discs from one peg to another  the third column the radius of the problem space from the standard initial state  the fourth column the width of the problem space  which is the maximum number of unique states at any depth from the standard initial state  and the last column the running time in days:hours:minutes:seconds  running six parallel threads. note that for both problems  the radius from the standard initial state exceeds the optimal solution depth  and we conjecture that this is true for all problems with 1 or more discs.
doptimalradiuswidthtime11 1 1:1:111 11:1table 1: complete search results for towers of hanoi
1 heuristic search experiments
we next ran heuristic searches of the four-peg towers of hanoi. as explained above  there exists a solution strategy that moves all discs from one peg to another  and a conjecture that it is optimal  but the conjecture is unproven. prior to this work  the conjecture had been verified for up to 1 discs  korf  1 . we extended this verification to 1 discs.
　we first built a 1-disc pattern database  compressed to the size of a 1-disc database  or one gigabyte of memory. this was done with a complete breadth-first search of the 1-disc problem  seeded with all states in which all discs were distributed over two pegs. we used the 1-fold symmetry described above to generate the database  since all noninitial pegs are equivalent. the database itself did not use this symmetry  however  but contained an entry for all 1 possible configurations of the 1 largest discs  to make database lookups more efficient. it took almost 1 days to construct the pattern database  and required a maximum of 1 gigabytes of disk storage. the reason that this is longer than the time for the complete search of the 1-disc problem described above is that we had to access the pattern database for each node expanded and were only able to run five parallel threads instead of six. we also built simple pattern databases for up to seven discs  essentially instantaneously.
　we then ran breadth-first heuristic search  starting with all discs on the initial peg  searching for a middle state in which all but the largest disc are distributed over the two auxiliary pegs. for example  in the 1-disc problem  a middle state is one where the 1 smallest discs have moved off the initial peg to two auxiliary pegs. thus  the largest disc is not represented at all. this search also used the six-fold symmetry.
　if a middle state is found in k moves  then a complete solution of 1k +1 moves exists  utilizing the symmetry between the initial and goal states. breadth-first heuristic search was run with the cost threshold set to  p   1 /1  where p is the presumed optimal solution depth. it would be more efficient to set the cost threshold to one move less  checking only for the existence of shorter solutions. to increase our confidence in our results  however  we used the  p 1 /1 cost threshold  and checked that an actual solution was found. a search with a given cost threshold will find all solutions whose cost is less than or equal to that threshold.
　for each problem  we took the maximum of two heuristics. for the 1-disc problem  which only uses 1 discs  one value was the compressed pattern database value for the 1 largest discs  plus the complete pattern database value for the seven smallest discs  and the other was the compressed database value for the 1 smallest discs  plus the complete database value for the seven largest discs. for the smaller problems  we also used the 1-disc compressed database  and looked up the remaining discs in a complete pattern database.
　we implemented our parallel search algorithm using multiple threads. the number of threads is limited by the available memory  since each thread needs it own local storage. the pattern databases are shared  however  since they are readonly. in our experiments we ran five parallel threads on two processors. we used all seven disks  evenly dividing the files among the disks  to maximize i/1 parallelism.
　the results are shown in table 1  for all problems not previously verified. the first column gives the number of discs  the second columnthe length of the optimal solution  the third column the running time in days:hours:minutes:seconds  the fourth column the number of unique states expanded  and the last column the maximum amount of storage needed in megabytes. in all cases  the presumed optimal solution depth was verified. the 1-disc problem took over 1 days to run  generated a total of over 1 trillion unique nodes  and required a maximum of 1 gigabytes of disk storage. even with two processors  the limiting resource is cpu time.
dopt.timeunique statesspace111 1111 111:11 1111:1 1 1 11:1:1 1 1 11:1:1 1 11table 1: heuristic search results for towers of hanoi
a search of the 1-disc problemis in progress at press time.
it has been running for three months  and is expected to finish in a couple weeks. it required two terabytes of disk storage.
　for comparison purposes  we also ran a brute-force halfdepth search of the 1-disc problem using substantially the same program with no heuristics. this took 1 hours  compared with 1 minutes for the heuristic half-depth search.
1 future work: perimeter search
multiple-goal pattern databases also provide a way to significantly improve the efficiency of a technique called perimeter search  dillenburg & nelson  1; manzini  1 . the idea is to perform a small breadth-first search backward from the goal state  and store a perimeter of nodes surrounding the goal state at a fixed distance d. then  in the forward search  instead of computing a heuristic to the single goal state  we compute a heuristic to each of the perimeter states  and take the minimum of these distances  plus d  as the heuristic estimate of the cost to the goal state. the drawback of this technique is that it requires for each state as many heuristic calculations as there are perimeter nodes. if we use a pattern database heuristic  however  and seed the breadth-first search used to construct the pattern database with all the perimeter nodes  then a single database lookup gives us the minimum heuristic value to any of the perimeter nodes. if we add d to this value  we get the improved accuracy of the perimeterbased heuristic  with no additional overhead. integrating this technique with multiple and/or additive pattern databases is non-trivial  however  and the subject of future work.
1 conclusions
we show how to efficiently perform a heuristic search for a shortest path to any of a large number of explicit goal states  using a pattern database heuristic. it is constructed by initially seeding the breadth-first search queue with all the goal states at depth zero. multiple-goalpattern databases allow us to perform heuristic searches to any of a large number of  middle states  at half the solution depth in the towers of hanoi. this idea also has applications to real-world multiple-goal problems  such as   take me to the nearest hospital . we also integrated a large number of recent advances in heuristic search  including frontier search  parallel disk-based search  breadthfirst heuristic search  multiple pattern databases  disjoint additive pattern databases  and compressed pattern databases. additional new improvementswe introduceinclude simplifying and speeding up our parallel search algorithm by reducing coordination between different threads  and a method to eliminate many heuristic calculations  based on a maximum possible heuristic value. by combining all these techniques  we were able to verify the presumed optimal solution depth for the four-peg towers of hanoi problem with up to 1 discs  a problem 1 times larger than the 1-disc previous state of the art. a search of the 1-disc problem is still in progress at press time. we also performed the first complete breadthfirst searches of the 1 and 1-disc problems  showing that the radius of the problem space from the standard initial state exceeds the optimal solution length. we conjecture that this will be true of all larger problems as well.
1 acknowledgements
thanks to peter schultze for technical support  and to ibm for donating the intellistation. this research was supported by nsf grant no. eia-1 to richard korf  and by the israel science foundation grant no. 1 to ariel felner.
