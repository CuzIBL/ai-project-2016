constraint satisfaction  databases  and logic 
phokion g. kolaitis* 
computer science department 
university of california  santa cruz santa cruz  ca 1  u.s.a kolaitis cs.ucsc.edu 

1 introduction 
constraint satisfaction problems constitute a broad class of algorithmic problems that are ubiquitous in several different areas of artificial intelligence and computer science. in their full generality  constraint satisfaction problems are np-complete and  thus  presumed to be algorithmically intractable. to cope with the intractability of these problems  researchers have devoted considerable research efforts to both the design of heuristic algorithms for constraint satisfaction and the pursuit of  islands of tractability   that is  special cases of constraint satisfaction problems for which polynomial-time algorithms exist. 
　during the past decade  the pursuit of  islands of tractability  of constraint satisfaction has been intensified and has led to a number of discoveries that have also unveiled tight connections between constraint satisfaction  database theory  logic  and universal algebra. our goal in this paper is to present an overview of the current state of affairs in the study of the computational complexity of constraint satisfaction with emphasis on the connections of this area of research with database theory and logic. the paper is organized as follows: section 1 contains the precise definition of the con-
straint satisfaction problem and its reformulation as the homomorphism problem; section 1 contains some of the connections between constraint satisfaction problems and database theory; the remaining sections 1  1  and 1 contain a high-level account of some of the main results about the computational complexity of constraint satisfaction and the pursuit of tractable cases of this problem. 
1 the constraint satisfaction problem and the homomorphism problem 
constraint satisfaction problems were originally introduced by montanari  mon1l to model problems in computer vision. since that time  however  it has been realized that numerous important problems in artificial intelligence and computer science can be modeled as constraint satisfaction problems  see  dec1a; pj1 . an instance of the constraint 
satisfaction problem  csp  consists of a set of variables  a set of possible values for the variables  and a set of constraints on tuples of variables that restrict the combinations of values that the variables may take; the question 
* partially supported by nsf grant no. iis-1 
is to determine whether there is an assignment of values to the variables so that the constraints are satisfied. more precisely  a csp-instance is a triple  v   d c   where v of a finite set of variables  d is a finite domain of values for the variables  and c is a set constraints {t  r   where t is a tuple  of variables for some m and r is a rela-
tion on d of arity m. a solution is a mapping h : v -  d such that  for every constraint  t r  c  we have that 
　consider the boolean satisfiability problem 1-sat: given a 1cnf-formula with variables and clauses is satisfiable  such an instance of 1-sat can 
be thought of as the csp-instance in which the set of variables is v = ＊ }  the domain is d - {1}  and the constraints are determined by the clauses of for example  a clause of the form gives rise to the constraint 	in an analogous manner  1-colorability can be modeled as a constraint satisfaction problem. indeed  an instance h = {v e  of 1-colorability can be thought of as the csp-instance in which the set of variables is the set v of the nodes of the graph h  the domain is the set of three colors  and the constraints are the pairs   u  u   q   where e 
and 	is the inequality relation on d. 
　a vocabulary is a finite set of relational symbols ri ...   rm each of which has a fixed arity. a relational structure over some vocabulary is a tuple a =  such that a is a non-empty set  called the universe of a  and each ra is a relation on a having the same arity as the symbol rt. let a and b be two relational structures over the same vocabulary. a homomorphism h from a to b is a mapping h : a -  b from the universe a of a to the universe b of b such that  for every relation ra of a and every tuple we have that    . . .   f e d e r and vardi  fv1  
were the first to point out that the constraint satisfaction problem can be identified with the homomorphism 
invited speakers 	1 problem: given two relational structures a and b  is there a homomorphism h from a to  the intuition behind this identification is that the structure a represents the variables and the tuples of variables that occur in the constraints  while the structure b represents the domain of values and the tuples of values that these constrained tuples of variables are 
allowed to take. moreover  the homomorphisms from a to b are precisely the assignments of values to variables that satisfy the constraints. for instance  1-colorability is equivalent to the problem of deciding whether there is a homomorphism h from a given graph h to the complete graph with 1 
nodes. more generally  k-colorability  1  amounts to the existence of a homomorphism from a given graph h to the complete graph kk with a: nodes  also known as the k-clique . numerous other important np-complete problems can be viewed as special cases of the homomorphism 
problem  and  hence  also of the constraint satisfaction problem . for example  consider the clique problem: given a graph h and an integer k  does h contain a clique of size a;  a moment's reflection shows that this is equivalent to the question: given a complete graph kk and a 
graph h  is there a homomorphism from kk to h  
the conceptual insights gained from the identification of 
the constraint satisfaction problem with the h o momorphism problem have facilitated the use of techniques from universal algebra in the study of constraint satisfaction  jea1; fv1  . moreover  they have clarified the tight connections between constraint satisfaction and database theory. we discuss some of these connections in the next section. 
1 constraint satisfaction and relational databases 
the most frequently asked queries in relational database systems involve the computation of the join of two or more relations in a database. instead of spelling out the formal definition of the join operation  let us consider for concreteness a database relation r a  b  c  with a  b  c as attributes and a database relation s{b c d e  with b  c  d  e as attributes. then the join r s consists of all quintuples  such that r and  1. sev-
eral different researchers  including  bib1   have pointed out that computing the set of all solutions of a csp-instance can be viewed as a join evaluation problem. indeed  if  v  d  c  is a csp-instance  then  for every constraint 
in c  let 	be the relation r itself viewed as a 
database relation with attributes 
is the collection of all database relations obtained this way  then the join consists of all solutions to the csp-instance 
　join evaluation is a special case of conjunctive query evaluation. specifically  an n-ary conjunctive query q over a relational vocabulary is a query definable by a positive existential first-order formula of the e 
is a conjunction of atomic formu-
las. for example  the binary conjunctive query  there is a path of length 1 from x1 to x1  is definable by the formula 
 note that 
joins are precisely those conjunctive queries in which none of the variables in  is quantified. at other extreme  a 
boolean conjunctive query is a conjunctive query in which all variables of  have been quantified out. 
　every finite relational structure a gives rise to a canonical boolean conjunctive query the positive existential firstorder sentence defining asserts that there exist as many elements as the cardinality of the universe of a and states all atomic facts satisfied by tuples from the universe of a. for example  if a =  a  e  is the 1-cycle with a = {1 1} and 
e =
　the following basic result  due to chandra and merlin  cm1   establishes a strong connection between homomorphisms and conjunctive queries. 
theorem 1:  cm1 the following are equivalent for finite relational structures a and b. 

as an example  we saw earlier that a graph g =  v  e  is 1colorable if and only if there is a homomorphism from g to k1. consequently  theorem 1 implies that g is 1-colorable if and only if k1 satisfies the canonical query qg of g. 
in view of the identification of the constraint satis-
faction problem with the homomorphism problem  the preceding theorem 1 implies that the constraint satisfaction problem can also be identified with two fundamental problems in database theory: conjunctive query evaluation and conjunctive query implication  or containment . this fundamental connection between constraint satisfaction and database theory was brought to front stage and further investigated in  kvooal. 
1 computational complexity of constraint satisfaction 
the constraint satisfaction problem is npcomplete  because it is clearly in np and also contains np-hard problems as special cases  including 1-sat  1colorability  and clique. as explained in garey and johnson's classic monograph  gj1   one of the main ways to cope with np-completeness is to identify polynomialtime solvable cases of the problem at hand that are obtained by imposing restrictions on the possible inputs. for instance  horn 1-sat  the restriction of 1-sat to horn 1cnf-formulas  is solvable in polynomial-time using a unit-propagation algorithm. similarly  it is known that 1color ability restricted to graphs of bounded treewidth is solvable in polynomial time  see idf1  . in the case of constraint satisfaction  the pursuit of tractable cases has evolved over the years from the discovery of isolated cases to the discovery of large  islands of tractability  of constraint satisfaction. in what follows  we will give an account of some of the progress made in this area. we begin by introducing some terminology and notation that will enable us to formalize the concept of an  island of tractability  of constraint satisfaction using the fact that the constraint satisfaction problem can be identified with the homomorphism problem. 

1 	invited speakers 

   in general  an instance of the homomorphism problem consists of two arbitrary relational structures a and b. thus  all restricted cases of this problem can be obtained by imposing restrictions on the input structures a and b. 
definition 1: let a  b be two classes of relational structures. we write csp  .1 b  to denote the restriction of the homomorphism problem to input structures from a and 
b. in other words  
csp 
an island of tractability of constraint satisfaction is a pair 
 a  b  of classes of relational structures such that csp a  b  is in the complexity class p of all decision problems solvable in polynomial time. 
　the ultimate goal in the pursuit of islands of tractability of constraint satisfaction is to identify or somehow characterize all classes a and b of relational structures such that csp a  b  is in p. the basic starting point in this investigation is to consider the cases in which one of the two classes a  b is as small as possible  while the other is as large as possible. this amounts to considering the cases in which one of a  b is the class all of all relational structures over some arbitrary  but fixed  relational vocabulary  while the other is a singleton {b} consisting of some fixed structure b over that vocabulary. thus  the starting points of the investigation is to determine  for every relational structure b  the computational complexity of the decision problems csp {b}  all  and csp a// {b} . 
	clearly  	for each fixed b  	the decision problem 
csp {b}  1//  can be solved in polynomial time  because  given a structure a  the existence of a homomorphism from a to b can be checked by testing all functions h from the universe b of b to the universe a of a  the total number of such functions is  which is a polynomial number in the size of the structure a . at the other extreme  however  the situation is quite different  since the computational complexity of csp .1//  {b}  may very well depend on the particular structure b. indeed  csp  is np-complete  because it is the 1-colorability problem; in contrast  csp  is in p  because it is the 1-colorability problem. 
　for simplicity  in what follows  for every fixed structure b  we put 
	csp b  	= 	csp a// {b}  
and call this the non-uniform constraint satisfaction problem associated with b. thus  the first major goal in the study of the computational complexity of constraint satisfaction is to identify those structures b for which csp b  is in p. although this goal has yet to be realized  much progress has been made towards it. the next section contains a bird's-eye view of some of the main results obtained to date. 
1 the computational complexity of non-uniform constraint satisfaction 
the first major result in the study of non-uniform constraint satisfaction problems was obtained by schaefer  sch1   who  in effect  classified the computational complexity of all boolean non-uniform constraint satisfaction problems. a boolean structure is simply a relational structure with a 
1-element universe  that is  a structure of the form b = 
 a boolean non-uniform constraint 
satisfaction problem is a problem of the form csp b  with b a boolean structure. these problems are also known as 
generalized satisfiability problems  because they can be viewed as variants of boolean satisfiability problems in which the formulas are conjunctions of generalized connectives  gj1 . in particular  they contain the well known problems k-sat  k  1  1-in-1-sat  positive 1-in-1-
sat  not-all-equal 1-sat  and monotone 1-sat as special cases. for example  1-sat is csp b   where b =  and ri is the set of truth assign-
ments that satisfy a 1-clause in which the first i-literals are 
negated  	 thus  
similarly  monotone 1-sat is csp b   where b ' = 
　ladner  lad1  showed that if p np  then there are decision problems in np that are neither np-complete  nor they belong to p. consequently  it is conceivable that a given family of np-problems contains problems of such intermediate complexity. schaefer  sch1   however  showed that the family of all boolean non-uniform constraint satisfaction problems contains no problems of intermediate complexity. 
theorem 1:  schaefer's dichotomy theorem  sch1   
 is boolean structure  then 
either csp b  is in p or csp b  is np-complete. in a picture  

  moreover  there is a polynomial-time algorithm to de-cide  given a boolean structure b  whether csp b  is in p or it is np-complete. 
　schaefer  sch1  actually showed that there are exactly six types of boolean structures such that csp b  is in p  and provided explicit descriptions of them. specifically  he showed that csp b  is in p precisly when at least one of the following six conditions is satisfied: 
  every relation of b is o-valid  that is   contains the all-zeroes tuple 
  every relation 	of b is  -valid  that is  

  every relation of b is bijunctive  that is  .  is the set of truth assignments satisfying some 1cnf formula. 

invited speakers 	1 

  every relation  m  of b is horn  that is  
rbi is the set of truth assignments satisfying some horn formula. 
  every relation  m  of b is dual horn  that is  rbi is the set of truth assignments satisfying some dual horn formula. 
  every relation  of b is affine  that is  
rbt is the set of solutions to a system of linear equations over the two-element field. 
　schaefef's dichotomy theorem yields a complete classification of the complexity of csp b  for boolean structures b. at the same time  it raises the challenge of classifying the computational complexity of csp b  for arbitrary relational structures b. to this effect  feder and vardi  fv1  formulated the following important conjecture. 
conjecture 1:  feder-vardi dichotomy conjecture  
if b =  rbm  is an arbitrary relational structure  then either csp b  is in p or csp b  is np-complete. in a picture  

　the feder-vardi dichotomy conjecture inspired intensive research efforts that resulted into significant advances towards resolving it. in particular  quite recently bulatov confirmed two important cases of this conjecture that are described next. 
theorem 1:  be a relational structure. 
   bulatov  bul1a   /f b = {1 1}  then either csp b  is in p or csp b  is np-complete. 
   bulatov lbul  1l  if every non-empty subset of b is one of the relations rbi of b  then either csp b  is in p or csp b  is hp-complete. 
moreover  in both cases there is a polynomial-time algorithm to decide whether csp b  is in p or it is np-complete. 
　the second of the two cases above is known as conservative constraint satisfaction. in effect  it is the case in which all possible unary constraints on the domain are present. 
　in spite of the progress made  the feder-vardi dichotomy conjecture remains unresolved for csp b  with  1. 
the research efforts towards this conjecture  however  have also resulted into the discovery of broad sufficient conditions for tractability of non-uniform constraint satisfaction that have provided unifying explanations for numerous seemingly disparate tractability results and have also led to the discovery of new islands of tractability of csp b . these broad sufficient conditions for tractability of csp b  are based on concepts and techniques from two different areas: universal algebra and logic. the approach via universal algebra yields sufficient conditions for tractabilty of csp b  in terms of closure properties of the relations in b under certain functions on b. the approach via logic yields sufficient conditions for tractability in terms of expressibility of csp b  in datalog. in the remainder of this section  our primary focus is on the latter approach. 
　datalog is the main database query language used in deductive database systems  see ru1j . in a nutsfell  a datalog program is a negation-free and function-free logic program. more precisely  a datalog program is a finite set of rules of the form 

where t  s1 ...   sr are relation symbols. in effect  the righthand side of each rule  called the body of the rule  is a conjunctive query in which all variables not occurring in the lefthand side  called the head of the rule  are existentially quantified. datalog embodies recursion because relation symbols may occur both in the heads and the bodies of rules. those that do are the recursive or or intensional database predicates  idbs  of the program  while the remaining relation symbols are the extensional database predicates  edbs . one of the idb predicates is singled out as the goal of the program. 
　as a standard example  the transitive closure of the edge relation e of a graph h =  v  e  is defined by the following datalog program. 

　every datalog program can be evaluated  bottom-up  in a polynomial number of iterations on a given database. for example  the a:-th iteration of the above datalog program yields the set of all pairs of nodes of h that are connected via a path of length at most k; moreover  at most n iterations suffice to compute the transitive closure of e  where n is the number of nodes in v. it follows that each fixed datalog program can be evaluated in time polynomial in the size of a given relational structure. consequently  if a query q is definable by a datalog program  then q is in p. thus  expressibility in datalog is a sufficient condition for tractability. 
　another important feature of datalog is that queries definable by datalog programs are preserved under homomor-
phisms. this means that if a structure a satisfies the goal of a datalog program and there is a homomorphism from a to b  then also b satisfies the goal of the program. 
　let b =  be a relational structure. it is easy to see that  except for trivial situations  csp b  is not preserved under homomorphisms  which implies that csp b  is not expressible in datalog. thus  at first sight  it appears that there is no link between expressibility in datalog and tractability of non-uniform constraint satisfaction. a moment's reflection  however  reveals that the complement csp b  of csp b  is preserved under homomorphisms  where 
1 	invited speakers csp b  = {a : no homomorphism h : a -  b exists}. 
consequently  it is conceivable that  for some structures b  the non-uniform constraint satisfaction problem csp b  is in p because its complement  is expressible in datalog. feder and vardi ifv1  pursued this link in depth and demonstrated that expressibility of  in datalog is a unifying explanation for numerous tractability results about csp b . 
　as an important concrete example  consider 1colorability  which is the same problem as csp k1 . 
the following datalog program with q as its goal expresses 
non 1-colorability  since a graph is 1-colorable if and only if it contains no cycles of odd length. 

as two additional important examples  recall that if b =  is a boolean structure such that ev-
ery relation rbi is horn or every relation rbi is bijunctive  then csp b  is in p. it can be shown that in both these cases csp b  is expressible in datalog. 
　to gauge the broad spectrum of tractable cases covered by datalog  it is perhaps worth comparing tractability via datalog to tractability via closure properties  which  as mentioned earlier  is an approach to tractability based on universal algebra. for this  we need to first introduce some basic concepts from universal algebra. if r is an n-ary relation on a set b and / : bk  b is a function  then we say that r is dosed under f if for every k--tuples we have that the n -tuple 	is also in 
r. if is a relational structure  then a polymorphism of b is a function for some such that each relation is closed under /. we write pol b  for the set of all polymorphisms of b. as it turns out  the complexity of csp b  is intimately connected to the kinds of functions that pol b  contains. in particular  it has been shown that if pol b  contains functions that satisfy certain algebraic identities  then csp b  is in p. this connection has been investigated in depth and with much success by jeavons and his collaborators in a sequence of papers  including  jcg1; jcc1   and by bulatov |bul1b   but also feder and vardi 
 fv1  had results along these lines . the following are the presently known most general sufficient conditions for tractability of csp b  based on closure properties. 
theorem 1: let b =  b  rib ...   rbm  he a relational structure. 
  if pol b  contains a near-unanimity function  then csp b  is in p. 
  //pol b  contains a set function  then csp b  is in p. 
  if'pol b  contains a maltsev function  then csp b  is in . 
　a k-ary function / with  is a near unanimity function if f x1 ...   xk  = y  for every k-tuple  x1 ...   xk  such that at least k - 1 of the xis are equal to y. note that the ternary majority function on {1} is a near unanimity function. a k-ary function / with is a set function if for every k-tuple  x1 ...   xk   we have that f x1.....  xk  depends only on the set {x1 ...   xk}. note that the boolean binary functions a and v arc set functions. finally  a ternary function f x  y  z  is a maltsev function if  for every x and y  it satisfies the identities f y  y x  - f x y y  - x. note that the boolean function is a maltsev function. 
it should be pointed out that the preceding theorem 1 contains as special cases the non-trivial tractable cases in schaefer's dichotomy theorem 1. indeed  it is known that a boolean relation is bijunctive if and only if it is closed under the ternary majority operation; moreover  a boolean relation is horn  dual horn  if and only if it is closed under  respectively  v ; finally  a boolean relation is affine if and only if it is closed under 
　concerning the comparison between datalog and closure properties  it can be shown that if pol b  contains a nearunanimity function or a set function  then csp b  is expressible in datalog. thus  expressibility in datalog subsumes two of the three sufficient conditions for tractability based on closure properties. it also known  however  that there are structures b  in fact  even boolean structures  such that pol b  contains a maltsev function  but csp b  is not expressible in datalog. at the same time  there are structures b such that pol b  does not contain any near unanimity functions  set functions  or maltsev functions  yet csp b  is tractable because csp b  is expressible in datalog. 
　in what follows in this section  we will take a closer look at the connections between datalog and non-uniform constraint satisfaction. in particular  we will address the following question: when is csp b  expressible in datalog  as we will see  expressibility of csp b  in datalog can be characterized in terms of pebble games and also in terms of consistency properties. 
　combinatorial games are a versatile tool in analyzing the expressive power of logics. the most well known among these games are the ehrenfeucht-fraisse-games for first-order logic  see  efr1  . a different family of games  known as k-pebble games  has been used to study fixed-point logics and infinitary logics with finitely many variables  see  kv1. we now describe a variant of k--pebble games that are suitable for analyzing the expressive power of datalog  kv1 . 
definition 1: let  be a positive integer. the existential k-pebble game  or  in short  the -pebble game  is played between two players  the spoiler and the duplicator  on two relational structures a and b according to the following rules: each player has k pebbles labeled 1   . . .   k; on the i-th move of a round of the game  the spoiler places a pebble on an element a  of .1  and the duplicator responds by placing the pebble with the same label on an element bi of b. the spoiler wins the game at the end of that round  if the correspondence is not a homomorphim between the substructures of a and b with universes {a1 ...   ak} and  b1 ...  bk}  respectively. otherwise  the spoiler removes one or more pebbles  and a new round of the game begins. the duplicator wins the pebble game if he has a winning strategy  that is to say  a 

systematic way that allows him to sustain playing  forever   so that the spoiler can never win a round of the game. 
　to illustrate this game  let km be the complete undirected graph with in nodes. for every the duplicator wins the 
　　-pebble game on kk and k k + 1   but the spoiler wins the -pebble game on kk+1 and kk. as another example  let ls be the s-element linear order  if m   n  then the duplicator wins the -pebble game on lm and l n   but the spoiler wins the -pebble game on and 
　note that the above description of a winning strategy for the duplicator in the -pebble game is rather informal. the concept of a winning strategy can be made precise  however  in terms of families of partial homomorphisms with appropriate closure and extension properties  where a partial homomorphism from a to b is a homomorphism from a substructure of a to a substructure of b. 
definition 1: let k be a positive integer. a winning strategy for the duplicator in the existential k-pebble game on a and b is a nonempty family t of partial homomorphisms from a to b such that: 
1. for every the domain dom /  of / has at most k elements. 
1. f is closed under subfunctions  which means that if t and. 
1 . t has the k-forth property  which means that for every with |dom 	and every 	on which 
/ is undefined  there is a that extends / and is defined on a. 
　intuitively  the second condition provides the duplicator with a  good  move when the spoiler removes a pebble from an element a  while the third condition provides the duplicator with a  good  move when the spoiler places a pebble on an element of a. 
　for every positive integer k  let k-datalog be the collection of all datalog programs such that each rule has at most a: distinct variables. the next result describes the connection between -pebble games and k-datalog  and also gives some of the algorithmic properties of -pebble games. 
theorem 1:  kv1; kvooa  let k be a positive integer. 
  assume that q is a query definable by a k-datalog pro-gram. if a and b are two relational structures such that a satisfies q and the duplicator wins the -pebble game on a and b  then also b satisfies q. 
  there is a polynomial-time algorithm to decide whether  given two finite structures a and b  the spoiler or the duplicator wins the -pebble game on a and b. 
  for every finite relational structure b  there is a kdatalog program b that expresses the query: given a finite o -structure a  does the spoiler win the pebble game on a andb  
　the preceding theorem 1 can be used to characterize when csp b  is expressible in datalog. 
theorem 1:  kvooa  let k be a positive integer and b a finite relational structure. the following statements are equivalent. 
  csp b  is expressible in k-datalog 
  csp b  = {a : duplicator wins the 
-pebble game on a and b}. 
note that if a homomorphism from a to b exists  then the 
duplicator wins the -pebble game on a and b using the values of the homomorphism as his strategy. thus  theorem 1 asserts that csp b  is expressible in k-datalog if and only if the following property holds: whenever the duplicator wins the -pebble on a and b  a homomorphism from 
a to b exists. 
　a striking consequence of theorems 1 and 1 is that all non-uniform constraint satisfaction problems csp b  for which csp b  is expressible in fc-datalog can be solved in polynomial time using the same algorithm  namely  the polynomial-time algorithm for determining the winner in the  1  fc -pebble game. moreover  since expressibility in datalog subsumes the tractable cases in which pol b  contains a near unanimity function or a set function  it follows that the algorithm for determining the winner in the    fc -pebble game can also be used to solve csp b  in polynomial time in these two major tractable cases. 
　many heuristic algorithms for constraint satisfaction involve  constraint propagation   which can be intuitively described as the derivation of new constraints from the original ones. this process has been formalized using various consistency concepts that make explicit additional constraints implied by the original constraints. the strong k-consistency property is the most important one among them; in informal terms  this property holds when every partial solution on fewer than k variables can be extended to a solution on k variables ldec1bl. closely related to this is the process of establishing strong k-consistency  which is the question of whether additional constraints can be added to a given instance of the constraint satisfaction problem in such a way that the resulting instance is strongly k-consistent and has the same space of solutions as the original one  see  dec1b; kvoob  for the formal definitions . it turns out that the following tight connection exists between strong fc-consistency properties and -pebble games. 
theorem 1:  kvoob  the following are equivalent for a csp-instance v d c . 
  /t is possible to establish strong k-consistency for  v d c . 
  the duplicator wins the -pebble game on a and b  where a  b form the instance of the homomorphism problem associated with  v  d  c . 
　furthermore  when this happens  the set all winning configurations for the duplicator in the 
pebble game gives rise to the largest  and  hence  least con-
strained  csp-instance that establishes strong k-consistency for 
　the preceding theorem provides a different perspective on consistency properties and reinforces the usefulness of the 

1 	invited speakers 

-pebble games in the study of constraint satisfaction. in particular  theorem 1 implies that computing winning strategies for the duplicator in the -pebble game is the most general form of constraint propagation. moreover  as an immediate consequence of theorems 1 and 1  we obtain another characterization of when csp b  is expressible in k-datalog. 
corollary 1: let k be a positive integer and b be a fixed finite relational structure. then the following are equivalent. 
  csp b  is expressible in k-datalog 
  for every finite relational structure a  establishing strong k-consistency for a and b implies that there is a homomorphism from a to b. 
　the results presented in this section make a strong case for the importance of the property  csp b  in expressible in datalog  as a broad sufficient condition for tractability of csp b   since this property subsumes numerous tractable cases of non-uniform constraint satisfaction. in view of this  one would like to have an efficient algorith to test whether  given a relational structure b  we have that csp b  is expressible in datalog. such an algorithm could be used as a building block in heuristic algorithms for constraint satisfaction  where one first tests for expressibility in datalog before resorting to some other exhaustive search procedure. at present  however  no such efficient algorithm is known. in fact  it is not even known whether expressibility of csp b  in datalog is a decidable property. more precisely  the following problem  originally posed by feder and vardi  fv1   remains open. 
open problem: let  be a fixed positive integer. is there an algorithm to decide whether  given b  we have that csp b  is expressible in k-datalog  
1 uniform constraint satisfaction and bounded treewidth 
in section 1  we focused on the pursuit of islands of tractability of non-uniform constraint satisfaction  that is  islands of the form 
	csp b  	- 	csp all {b}   
where b is a fixed relational structure. in particular  we saw that substantial progress has been made towards obtaining a complete classification of all relational structures b for which csp b  is solvable in polynomial time. the state of affairs  however  is different for constraint satisfaction problems of the form csp a b   where neither a nor b is a singleton class. we call such problems uniform constraint satisfaction problems  because an instance of csp{a b  is a pair of structures and  unlike csp b   where an instance is just a structure a . 
　at present  we are far away from even coming close to a characterization of all classes a and b such that csp a  b  is solvable in polynomial time. nonetheless  significant progress has been made in the case in which b is the class all of all relational structures over an arbitrary  but fixed  vocabulary. in what follows  we present the main results concerning islands of tractability of uniform constraint satisfaction of the form csp{a  all . 
　as is well known  many algorithmic problems that are  hard  on arbitrary graphs become  easy  on trees. this motivated researchers to investigate whether the concept of a tree can be appropriately relaxed while maintaining good computational behavior. as part of their seminar work on graph minors  robertson and seymour introduced the concept of treewidth and showed that graphs of bounded treewidth are  tree-like  structures exhibiting such good behavior. the monograph by downey and fellows  df1 contains complete definitions and characterizations of these concepts. here  instead of giving the standard definition of treewidth in terms of tree compositions  we present an equivalent one in terms of partial k-trees. 
definition 1: let k be a positive integer. 
  a graph h is a k-tree if either h is a kk+1 -clique or there are a k-tree g  nodes  in g forming a  and a node b in h - g such that h is obtained from g by connecting b to each of the nodes a 1  ...   ak  thus  forming a -clique . 
  a graph is a partial k-tree if it is a subgraph  not necessarily induced  of a k-tree. 
  the treewidth of a graph h  denoted by tw h   is the smallest k such that h is a partial k-tree. 
  we write  to denote the class of all graphs h such that tw h    k. 
　clearly  if t is a tree  then tw t  = 1. similarly  if and cn is the n-element cycle  then tw c  = 1. at the other end of the scale   - 1  for every 
computing the treewidth of a graph is an intractable problem. 
specifically  the following problem is np-complete: given a graph h and an integer  nonetheless  
bodlaender  bod1  showed that for every fixed integer k   1  there is a linear-time algorithm such that  given a graph h  it determines whether or not 
the notion of treewidth can be defined for arbitrary finite 
relational structures a =  using the gaifi man graph ga of the structure a. specifically  tw a  = tw g a    where g a  =  a e  and 
	occur in a tuple of 	for some i. 
in what follows  will denote the class of all relational structures of treewidth less than k over a fixed relational vocabulary. 
　dechter and pearl  dp1 and freuder lfre1j showed that the classes of structures of bounded treewidth give rise to large islands of tractrability of uniform constraint satisfaction. 
theorem 1:  dp1; fre1l if  is a positive integer  then csp{t{k  all isinp. 
　the polynomial-time algorithm for csp t k   all  in the above theorem is often described as a bucket elimination algorithm  dec1 . it should be noted that it is not a constraint propagation algorithm. instead  this algorithm uses the bound on the treewidth to test if a solution to the constraint satisfaction problem exists by solving a join evaluation problem in which all intermediate relations are of bounded arity. 

kolaitis and vardi lkvoob   and dalmau  kolaitis and 
vardi  dkv1  investigated certain logical aspects of the treewidth of a relational structure and showed that this combinatorial concept is closely connected to the canonical conjunctive query of the structure being definable in a fragment of first-order logic with a fixed number of variables. this made it possible to show that the tractability of csp t k   all  can be explained in terms of expressibility in k-datalog. moreover  it led to the discovery of larger islands of tractability of uniform constraint satisfaction. 
definition 1: let be a positive integer. 
  fok is the collection of all first-order formulas with at most k distinct variables. 
  lk is the collection of all -formulas built using atomic formulas  conjunction  and existential first-order quantification only. 
　as an example  it is easy to see that if cn is the n-element cycle  then the canonical conjunctive query qcn is expressible in l1. for instance  is logically equivalent to 
as mentioned earlier  for every tw cn  = 1. the next result shows that this relationship between treewidth and number of variables needed to express the canonical conjunctive query is not an accident. 
theorem 1: 	 kvoob; dkv1  let  be a positive integer. 
  //  then the canonical conjunctive query qa is expressible in lk. 
  if b is an arbitrary  but fixed  structure  then  is expressible in k-datalog. 
  csp t k   all  can be solved in polynomial time by determining whether  given a structure and an arbitrary structure b  the spoiler or the duplicator wins the  1  k -pebble on a and b. 
as a consequence of the above theorem 1  we see that 
csp t a:   1//  can be solved in polynomial time using a constraint propagation algorithm that is quite different from the bucket elimination algorithm in theorem 1. 
definition 1: let a and b be two relational structures. 
  we say that a and b are homomorphically equivalent  denoted if there are homomorphisms h : 
b and h' : 
  we say that b is the core of a  and write core a  = b  if 
1. b is a substructure of a. 
1. there is no homomorphism h : b -  b' from b to a proper substructure b; of b. 
	clearly  core  and core 	moreover  
if if h is a 1-colorable graph  then core h  = it should be note that cores play an important role in database query processing and optimization  see  cm1  . the next result shows that they can also be used to characterize when the canonical conjunctive query is definable in lk. 
theorem 1: let  be a positive integer and a a relational structure. then the following statements are equiv-
alent. 
  qa is definable in lk. 
  there is a structure 
is the class of all relational structures over some fixed vocabulary that are homomorphically equivalent to a structure in t k . 
　equivalently   is the class of all relational structures a such that core a  has treewidth less than k. 
it should noted that t k  is properly contained in 
. indeed  it is known that there are 1-colorable graphs of arbitrarily large treewidth. in particular  grids are known to have these properties  see idf1 . yet  these graphs are members of  since their core is k1. 
theorem 1.&  dkv1  let  be a positive integer. 
  if b is an arbitrary  but fixed  structure  then csp h t k   {b}  is expressible in k-datalog. 
  csp {n t k    all  	is 	in 	p. 	moreover  cspxri t k   all  	can be solved in polynomial time by determining whether  	given a structure  and an arbitrary structure b  the spoiler 
or the duplicator wins the -pebble on a and b. 
　the preceding theorem 1 yields new islands of tractability for uniform constraint satisfaction that properly subsume the islands of tractability constituted by the classes of structures of bounded treewidth. however  this expansion of the tractability landscape comes at a certain price. specifically  as seen earlier  for every fixed k   1  there is a polynomialalgorithm for determining membership in t k   bod1 . in contrast  it has been shown that  for every fixed k   1  determining membership in h t k   is an np-complete problem  dkv1. thus  these new islands of tractability are not as easily accessible as the earlier ones. 
　since h{t{k   contains structures of arbitrarily large treewidth  the bucket elimination algorithm cannot be used to 
solve  all  in polynomial time. thus  theorem 1 also shows that determining the winner of the  1  k pebble is a polynomial time algorithm that applies to islands of tractability not covered by the bucket elimination algorithm. 
　it is now natural to ask whether there are classes a of relational structures over some fixed vocabulary such that they are larger than the classes  and csp  1  all  is solvable in polynomial time. a rather unexpected and remarkable new result by grohe  gro1  essentially shows that no such classes exist  provided a certain complexity-theoretic hypothesis is true. 
1 	invited speakers theorem 1:  gro1  assume that fpt  w l . if a is a recursively enumerable class of relational structures over some fixed vocabulary such that csp a all  is in p  then there is a positive integer k such that 
the hypothesis fpt  w l  is a statement in parametrized complexity that is analogous to the hypothesis p  np  and it is widely accepted as being true  see  df1  . in effect  grohe's theorem 1 is a converse to theorem 1. together  these two theorems yield a complete characterization of all islands of tractability of the form csp a  all . moreover  they reveal that all tractable cases of the form csp a  all  can be solved by the same polynomial-time algorithm  namely  the algorithm for determining the winner in the -pebble game. in other words  all tractable cases of constraint satifaction of the form csp a  all  can be solved in polynomial time using constraint propagation. 
