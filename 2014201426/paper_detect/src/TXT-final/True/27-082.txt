 
finding the lowest-cost path through a graph is central to many problems including route planning for a mobile robot if arc costs change during the traverse then the remainder of the path may need to be replanned this is the case for a sensor-equipped mobile robot with imperfect information about its environment as the robot acquires additional information via its sensors it can revise its plan to reduce the total cost of the traverse if the prior information is grossly incomplete the robot may discover useful information in every piece of sensor data. during replanning  the robot must either wait for the new path to be computed or move in lhe wrong direction therefore rapid replanning is essential the d* algorithm  dynamic a*  plans optimal traverses id real-time by incrementally repairing paths to the robot s state as new information is discovered this paper describes an extension to d* that focusses the repairs to significantly reduce the total time required for the initial path calculation and subsequent replanning operations this extension completes the development of the d* algorithm as a full generalizauon of a* for dynamic environments where arc costs can change during the traverse of the solution path 1 
1 introduction 
the problem of path planning can be stated as finding a sequence of state transitions through a graph from some initial slate 1 a goal state  or determining that no such sequence exists the path is optimal if the sum of the transition costs also called arc costs  is minimal across all possible sequences through the graph if during the ' traverse of the path  one or more arc costs in the graph is discovered to be 
1 this research was sponsored by arpa under contracts per cepuon for outdoor navigation'  contract number daca1 c 1 monitored by the us army tec  and unmanned ground vehicle system  contract number daae1-c r1 moni tored by tacom  
1 	planning incorrect the remaining portion of the path may need to be replanned to preserve optimality a traverse is optimal if every transiuon in the traverse is part of an optimal path to the goal assuming  at the time of each transition all known information about the arc costs is correct 
　　an important application for this problem  and the one that will serve as the central example throughout the paper  is the task of path planning for a mobile robot equipped with a sensor operating in a changing unknown or partially-known environment. the slates in the graph are robot locations and the arc values are the costs of moving between locations  based on some metric such as distance time  energy expended  nsk  etc the robot begins with an initial estimate of arc costs comprising its 'map   but since the environment is only partially-known or changing some of the arc costs are likely to be incorrect as the robot acquires sensor data  it can update its map and replan the optimal path from its current state to the goal it is important that this replanning be fast  since during this time the robot must either stop or continue to move along a suboptimal path 
　　a number of algorithms exist for producing optimal traverses given changing arc costs one algonthm plans an initial path with a*  nilsson 1  or the distance transform  jarvis  1j using the prior map information moves the robot along the path until either it reaches the goal or its sensor discovers a discrepancy between the map and the environment  updates the map  and  hen replans a new path from the robot s current stale to the goal  zelinsky 1  although this brute-force replanner is optimal it can be grossly inefficient  particularly in expansive environments where the goal is far away and little map information exists 
　　boult  maintains an optimal cost map from the goal to all states in the environment assuming the environment is bounded  finite  when discrepancies are discovered between the map and the environment  only lhe affected portion of the cost map is updated the map representation is limited to polygonal obstacles and free space trovato  and ramalingam and reps  extend this approach to handle graphs with arc costs ranging over a continuum the limitation of these algorithms is that the entire affected portion of the map must be repaired before the robot can resume moving and subsequently make additional corrections thus  the algorithms are inefficient when the robot is near the goal and the affected portions of the map have long  shadows' stentz  overcomes 

these limitations with d+  an incremental algorithm which maintains a partial  optimal cost map limited to those locations likely to be of use to the robot likewise repair of the cost map is generally partial and re-entrant  thus reducing computational costs and enabling real-time performance 
　　other algorithms exist for addressing the problem of path planning in unknown or dynamic environments  korf 1  lumelsky and stepanov  1  pirzadeh and snyder 1  but these algorithms emphasize fast operation and/or low memory usage at the expense of opomahry 
　　thus paper describes an extension to d* which focusses the cost updates to minimize slate expansions and further reduce computational costs the algorithm uses a heuristic function similar to a* to both propagate cost increases and focus cost reductions a biasing function is used to compensate for robot motion between replanning operations the net effect is a reduction in run-time by a factor of two to three the paper begins with the intuition behind the algorithm  describes the extension presents an example evaluates empirical comparisons  and draws conclusions 
1 intuition for algorithm 
consider how a* solves the following robot path planning problem figure 1 shows an eight-connected graph represenung a cartesian space of robot locations the states in the graph  depicted by arrows are robot locations and the arcs encode the cost of moving between states the white regions are locations known to be in free space the arc cost for moving between free states is a small value denoted by empty the grey regions are known obstacle locations  and arcs connected to these stales are assigned a prohibitively high value of obstacle the small black square is a closed gate believed to be open  i e   empty value  with out a loss of generality the robot is assumed to be point-size and occupies only one location at a tune a* can be used to compute optimal path costs from the goal g  to all states in the space given the initial set of arc costs  as shown in the figure the arrows indicate the optimal state transitions therefore  the optimal path for any slate can be recovered by following the arrows to the goal because the closed gate is assumed to be open. a* plans a path through it. 
　　the robot starts at some initial location and begins following the optimal path to the goal at location r the robot's sensor discovers the gate between the two large obstacles is closed this corresponds to an incorrect arc value m the graph rather than empty it has a much higher value of gate  representing the cost of first opening the gale and men moving through it all paths through this arc are  possibly  no longer optimal as indicated by the labelled region a* could be used to recompute the cost map  but this is inefficient if the environment is large and/or the goal is far away 
　　several characteristics of the problem motivate a better approach first  changes to the arc costs are likely to be in the vicinity of the robot  since it typically carries a sensor with a limited range this means that most plans need only be patched  locally  second the robot generally makes near-monotonic progress toward the goal most obstructions are small and simple padi deflections suffice  thus avoiding the high computational cost of backtracking third  only the remaming portion of the path must be replanned at a given location in the traverse which lends to get progressively shorter due to the second characteristic 

figure 1 invalidated states in the graph 
　　as described in stenlz  d* leverages on these characteristics to reduce run-time by a factor of 1 or more for large environments the paper proves that the algorithm produces correct results regardless-only the performance improvement is affected by the validity of the problem charactenstics 
　　like a*  d* maintains an open list of stales for expansion however these states consist of two types raise and lower raise states transmit path cost increases due to an increased arc value and lower stales reduce costs and re-direct arrows to compute new optimal paths the raise states propagate me arc cost increase through the invalidated slates by starting at the gate and sweepmg outward addmg the value of gate to all states in the region the raise states acuvate neighboring lower slates which sweep in behind to reduce costs and re direct pointers lower states compute new optimal paths to the slates that were previously raised 
　　states are placed on the open list by their key value k x  which for lower stales is the current path cost h x  
i e cosl from the state x to the goal  and for raise states the previous  unraised h x  value stales on the list are processed in order of increasing key value the intuition is thatl the previous optimal path costs of the raise slates define a lower bound on the path costs of lower states they can discover thus if the path costs of the lower states currently on the open list exceed the previous path costs of the raise states then it is worthwhile processing raise states to discover  possibly  a better lo wer slate 
the process can terminate when the lowest value on the 
open list equals or exceeds the robot's path cosl  since additional expansions cannot possibly find a better path to the goal  see figure 1  once a new optimal path is computed or the old one is determined to be valid  the robot can continue to move toward the goal note m the figure that 
1 

only part of the cost map has been repaired this is the efficiency of the d* algorithm 
　　the d* algondim described in stentz  propagates cost changes through the invalidated states without considering which expansions will benefit the robot at its current location like a* d* can use heuristics to focus the search in the direction of the robot and reduce the total number of state expansions let the focussing heuristic g{x r be the estimated path cost from the robot' location r to x define a new function  thee stimated robot path cost to be f x  r  = h x  + g x r  and sort all lower stales on the open list by increasing ft   value the function j{x r  is the estimated path cost from the state r through x to c provided that g ＜  satisfies the monotone restriction  then since h{x  is optimal when lo wer stale x is removed from the open list an optimal path will be computed to r  nilsson  1  the notation g{＜  is used 1 refer to a function independent of its domain 

　　in the case of raise stales the previous h ＜  value defines a lower bound on the h ＜  values of lower states they can discover therefore if the same focussing heuristic g{＜  is used for both types of states the previous ft   values of the raise stales define lower bounds on the /    values of the lower states they can discover thus if the/i   values of the lower states on the open list exceed the previous /h values of the raise states then it is worthwhile processing raise slates to discover better lower states based on this reasoning  the raise slates should be sorted on the open list by f x r  = k x  + g x r  but since k x  = h x  for lower states the raise state definmon for ft1  suffices for both kinds of slates to avoid cycles in the backpointers it should be noted that ties in ft＜  are sorted by increasing t ＜  on the open list  stentz 1  
the process can terminate when the lowest value on the 
open list equals or exceeds the robot's path cost  since the subsequent expansions cannot possibly find a lower state that 1  has a low enough path cost  and 1  is 'close enough to the robot to be able to reduce the robot's path cost when it 
1 	planning 
reaches it through subsequent expansions note that this is a more efficient cut-off than the previous one which considers only the first en tenon 
　　figure 1 shows the same example  except that a 
　　focussed search is used all states in the raise state wave front have roughly the same /h value the wave front is more  narrow  m the focussed case since the inclusion of the cost to return to the robot penalizes the wide flanks furthermore  the i ower states activated by the raise state wave front have swept in from the outer sides of the obstacles to compute a new optimal path to the robot note that the two wave fronts are narrow and focussed on the robot s location compare figure 1 to figure 1 note that both the raise and lower stale wave fronts have covered less ground for the focussed search than the unfocussed search m order to compute a new  optimal path to r therein 
is the efficiency of the focussed d* algorithm 
　　the problem with focussing the search is that once a new optimal path is computed to the robot s location the robot then moves to a new location if its sensor discovers another arc cost discrepancy the search should be focussed on the robot's new location but states already on the open list are focussed on the old locauon and have incorrect g ＜  and /t  values one solution is to recompute g{＜  and f ＜  for all stales on the open list every time the robot moves and new states are to be added basui on empirical evidence the cost of re-sorting the open list more than offsets the savings gamed by a focussed search 



1 


	1 	planning 

function modify-cost  x  y  cval 
li c xy  = cval 
l1 if t x  = closed then insert x h x   
l1 return min-val    
　　the function move-robot illustrates how to use process-state and modify-cost to move the robot from state 1 through die environment to g along an optimal traverse at lines li through l1 of move-robot r ＜  is set to new for all stales the accrued bias and focal point are initialized  h g  is set to zero  and g is placed on the open iisl process-statf is called repeatedly at lines l1 and l1 until either an initial path is computed to the robot's stale  1 e h.s  = closed  or it is determined that no path exists  1 e vat = no - val and t s  = new  the robot then proceeds to follow the backpointers until it either reaches the goal or discovers a discrepancy  line l l l   between the sensor measurement of an arc cost j ＜  and the stored arc cost c ＜   e g due to a 
　　detected obstacle  note that these discrepancies may occur anywhere not just on the path to the goal if the robot moved since the last tune discrepancies were discovered  then its stale r is saved as the new focal point  and the accrued bias dcurr  is updated  lines l1and l1  modify-cost is 
called to correct c ＜  and place affected slates on the open hstatlme l1 process-state is then called repeatedly at line l1 lo propagate costs and compute a new path to the goal the robot continues to follow the backpointers toward the goal the function returns goal-reached if the goal is lound and no -path if it is unreachable 

l1 	return goal - reached 
　　it should be noted that line l1 in move-robot only detects the condition thai no path exists from the robot s state to the goal if for example the graph is disconnected it does not detect the condition that all paths to the goal are obstructed by obstacles in order to provide for this capability  obstructed arcs can be assigned a large positive value of obsta cle and unobstructed arcs can be assigned a small positive value of empty obstacle should be chosen such thai it exceeds the longest possible path of 

1 example 
figure 1 shows a cluttered 1 x 1 state environment the robot starts al state s and moves to state g all of the obstacles shown in blade  are unknown before the robot starts its traverse  and the map contains only empty arcs the robot is point-size and is equipped with a 1-state radial geld-ofview sensor the figure shows the robot s traverse from s to g usmg the basic d* algoruhm the traverse is shown as a black curve with white arrows as the robot moves its sensor detects me unknown obstacles detected obstacles are shown in grey with black arrows obstacles that remain unknown after the traverse are shown in solid blade or black with white arrows the arrows show the final cost geld for all states examined during me traverse note that most of the states are examined at least once by the algorithm 

　　figure 1 shows the robot s traverse using the focussed d* algoruhm the number of new states examined is fewer man basic d* since the focussed d* algorithm focuses the initial path calculation and subsequent cost updates on the robot s location note that even for those stales examined by the algorithm fewer of them end up with optimal paths to the goal finally  note thatl the two trajectories are not fully equivalent this occurs because the lowest-cost traverse is not unique and the two algorithms break ties in the path costs arbitrarily 
1 


1 experimental results 
four algorithms were tested to verify optumality and to com pare run-time results the first algonthm the brute force replanner  bfr  initially plans a single path from the goal to the start state the robot proceeds to follow the path until its sensor detects an error in the map the robot updates the map  plans anew path from the goal to its current location using a focussed a* search and repeats until the goal is reached the focussing heuristic g x y   was chosen to be the minimum possible number of state transitions between y and x  assuming the lowest arc cost value for each 
the second and third algondims basic d*  bd*  and 
focussed d* with minimal initialization  fd*m   are descnbed in stentz  and section 1 respectively the fourth algonthm focussed d* with full initialization  fd*f   is the same as fd*m except thai the path costs are propagated to all states in the planning space  which is assumed to be finite  during the initial path calculation  rather than terminating when the path reaches the robot's start state 
　　the four algorithms were compared on planning problems of varying size each environment was square consisung of a start state in the center of the left wall and a goal state in center of the right wall each environment consisted of a mix of map obstacles known to the robot before the traverse and unknown obstacles measurable by the robot s sensor the sensor used was omnidirectional with a 1-staie radial field of view figure 1 shows an environment model with approximately 1 states the known obstacles are shown in grey and the unknown 
obstacles in black 
　　the results for environmenis of 1   l1  and 1 stales are shown in table 1 the reported times are cpu time for a sun microsystems sparc-1 processor for each environment size the four algonthms were compared on five randomly-gen era ted environments and the results were averaged the off-line ume is the cpu time required to 
1 	planning 
compute the initial path from the goal to the robot  or in the case of fd*fp from the goal lo all states in the environment this operation is 'off-line' since it could be performed in advance of robot motion if the initial map were available the on-line time is the total cpu time for all replanning operations needed to move the robot from the start to the goal 


　　the results for each algonthm are highly dependent on the complexity of the environment  including the number size  and placement of me obstacles  and the ratio of known lo unknown obstacles for the test cases examined all variations of d* outperformed bfr in on-line time  reaching a speedup factor of approximately 1 for large environments generally the performance gap mcreased as the size of the environment mcreased if the user wants lo minimize on-line time at the expense of off-line ume  then fd*f is the best algonithm in this algonthm  path costs to all states are computed initially and only the cost propagations are focussed note that fd*f resulted in lower on-line lanes and higher off-line times than bd* the fd*m algondim resulted in lower off-line times and higher on-line 

times than bd* focussing the search enables a rapid start due to fewer state expansions  but many of the unexplored states must be examined anyway during the replanning process resulting in a longer execution time thus. fd*m is the best algonthm if the user wants to minimize the total time that is  if the off-line time is considered to be on-line time as well 
　　thus  the focussed d* algonthm can be configured to outperform basic d* in either total time or the on-line portion of the operation  depending on the requirements of the task as a general strategy focussing the search is a good idea  the only issue is how me computational load should be distributed 
1 conclusions 
this paper presents the focussed d* algandnn for real-time path replanning the algondun computes an initial path from the goal state to the start state and then efficiently modifies this path during me traverse as arc costs change the algondun produces an optimal traverse meaning that an optimal path to the goal is followed at every slate in the traverse assuming all known lnformauon at each step is correct the focussed version of d* outperforms the basic version and it offers the user the option of distributing the computational load amongst the on- and off line portions of the operation depending on the task requirement the addition of a heu nstic focussing function to d* completes its development as a generalization of a* to dynamic environments--a* is the special case of d* where arc costs do not change dunng the traverse of the solution path 
acknowledgments 
the author thanks barry brumitt and jay gowdy for feedback on the use of the algorthm 
