
there are many systems and techniques that address stochastic scheduling problems  based on distinct and sometimes opposite approaches  especially in terms of how scheduling and schedule execution are combined  and if and when knowledge about the uncertainties are taken into account. in many real-life problems  it appears that all these approaches are needed and should be combined  which to our knowledge has never been done. hence it it first desirable to define a thorough classification of the techniques and systems  exhibiting relevant features: in this paper  we propose a tree-dimension typology that distinguishes between proactive  progressive  and revision techniques. then a theoretical representation model integrating those three distinct approaches is defined. this model serves as a general template within which parameters can be tuned to implement a system that will fit specific application needs: we briefly introduce in this paper our first experimental prototypes which validate our model.
1 introduction
many approaches to scheduling assume an execution environment without uncertainty. the problem there is to allocate resources and assign start times to a set of given activities  so that temporal and resource constraints are satisfied. the resulting predictive schedule is then sent to the execution controller. however  in practical applications  we have to schedule with incomplete  imprecise  and/or uncertain data: simply executing a strictly and completely determined predictive schedule is not a right answer anymore  as there is high chance that such a schedule will not fit the real situation that will arise. scheduling and schedule execution can then be reconsidered in many ways: for instance  setting activity start times of a sequence of activities can be postponed until execution  adding some flexibility to a schedule that will better adapt to observed events; the execution controller can be augmented by rescheduling capabilities in case a failure occurs; or schedule generation and execution can be interleaved so as to only predict in a short range  where uncertainty remains low enough. such approaches are very different from one another  and it is still unclear which one is the best answer in a given application context: in this paper  we will propose  in section 1  a thorough classification of techniques for scheduling under uncertainty  exhibiting their strengths and weaknesses. our conclusion is that in real-life applications  mixing those techniques within a single system appears to be highly desirable. for that purpose we will propose  in section 1  a conceptual theoretical model encompassing both the generation and the execution of the schedule and in which a large number of techniques for dealing with uncertainty can be concurrently implemented. section 1 will present experimental prototypes that partially validate our model.
1 background
a standard scheduling problem comprises a set of activities and resources. each activity has a duration  and each resource has a limited capacity. the objective is to assign resources and times to activities given temporal and resource constraints. in general  scheduling problems are optimization problems: typical optimization criteria are makespan  number of tardy activities  tardiness or allocation cost. if we assume an execution environment without uncertainty  we generate a predictive schedule offline that is then executed online without any problem. there are however many possible sources of uncertainty in scheduling; e.g.  some activity durations or some resource capacities are imprecise  as e.g. resources may break down .
　we now give some definitions to avoid ambiguity of terms commonly used by different communities.
definition 1  flexibility  a flexible schedule is a schedule that is not fully set: decisions have still to be made.
　decisions to make or to change can be of heterogeneous types; e.g.  allocation or sequencing decisions.
definition 1  conditional schedule  a conditional schedule is a special kind of flexible schedule in which distinct alternative subsets of partially ordered activities can be mod-
eled: the remaining decisions here are to choose between such alternatives at execution time.
definition 1  executable schedule  an executable schedule is a schedule that does not violate any constraint.
definition 1  adaptive scheduling system  an adaptive scheduling system is a system that is able to generate a new executable schedule whenever the current executing schedule is no longer executable.
definition 1  robustness  a robust schedule is a schedule whose quality  according to the optimization criterion  does not deviate too much during execution with respect to known online perturbations: the less deviation  the more robustness.
definition 1  stability  a stable schedule is a schedule in which no decision will be changed during execution.
1 classification
in this section  we concisely describe a taxonomy of scheduling systems or techniques that is independent of any specific representation model or reasoning technique. such classifications have already been done  especially in the operations research community  as in herroelen et al.    but none is totally satisfactory to our need since they only distinguish between offline and online techniques. we go beyond this distinction and consider more issues such as how and when decisions are made  optimality requirements  etc.
1 proactive techniques
a proactive technique takes into account uncertainty to produce schedules that are less sensitive to online perturbations.
　a first naive method for making a schedule insensitive to online perturbations is to produce offline a unique predictive  robust schedule by taking into account the worst scenario.
　another approach consists in introducing some flexibility in the schedule: only a subset of decisions are made offline with a search and the rest online without search; this is a kind of least commitment approach with respect to decisionmaking since we only make decisions when information is more precise  and/or more certain. morris et al.  for instance maintain a plan with uncertain activity durations in which start times are not set: they provide algorithms to guarantee the executability of such schedules whatever the actual durations will be. here we have an incomplete flexible schedule. another way is to build an undecided flexible schedule: everything is set but with alternative branches  leading to a conditional schedule.
　different uncertainty models  probability distributions  possibility theory  etc.  can be used in proactive techniques for the representation of the problem  and for solving it  e.g.  find the schedule that will have the highest probability that the makespan will not exceed a given value .
1 revision techniques
revision techniques consist in changing decisions during execution when it is necessary; e.g.  we change decisions when the current predictive schedule becomes inconsistent  when estimated quality deviates too much from the predicted one  or in a more opportunistic way when a positive event occurs  for example  an activity finishes earlier than expected . in other words  we need an execution-monitoringsystem able to react and indicate when it is relevant to change decisions of the current predictive schedule; e.g.  sadeh et al.  developed both simple rules to adapt a current schedule through e.g. activities shifting  and more elaborated local rescheduling techniques when the problem is more acute.
1 progressive techniques
the idea behind progressive techniques is to interleave scheduling and execution  by solving the whole problem piece by piece  where each piece corresponds to a time horizon slice. reasoning is done as a backgroundtask online; i.e.  we can afford more time to search  we incrementally commit to scheduling decisions periodically or when new information arrives  and no decisions are changed.
　one way of proceeding when using a progressive approach is to select and schedule new subsets of activities to extend the current executing schedule on a gliding time horizon; e.g.  vidal et al.  allocate container transfer activities in a harbor to robots only as long as temporal uncertainty remains low enough to be reasonably sure that the chosen robot will actually be the first available. a decision is made when uncertainty level of the used information is not too high  and/or when the anticipation horizon  the interval between the current time and the expected end time of the last scheduled activity  has become too small. one thus needs an executionmonitoring system able to react and indicate when  what  and what type of new decisions to make.1
1 discussion
we can compare the three families of techniques with respect to the following criteria: online memory need  online cpu need  schedule quality/robustness  and stability.
　revision techniques do not consume a lot of memory online since we only have to store one schedule. they may require a lot of cpu online  depending on the time spent on rescheduling. we can expect a very high schedule quality if we are able to reoptimize very often and globally revise the current schedule  but robustness is not guaranteed. stability may be very bad if we change a lot of decisions.
　online memory may vary for proactive techniques depending on whether we have to store one or more schedules: conditional schedules may require a lot of memory. in general  online computational power keeps low since we do not have to search for solutions with backtracking. we can expect a high schedule robustness or stability since we take into account what may occur online to make decisions.
　progressive techniques permit to limit our online memory need to the minimum since we only store a piece of schedule. the requirement in cpu online is limited since we only solve sub-problems. it is difficult to guarantee a very high schedule quality/robustness since decisions are made without taking into account knowledge about uncertainty to make scheduling decisions and with a more or less short-term/aggregated view. this family of techniques generates stable schedules.
　these features can help a decider to choose a technique in a specific application domain: if memory usage is limited  then conditional schedules are probably not the right answer. moreover  one can easily see that mixed techniques are necessary: for instance  in a highly stochastic world  the time spent on rescheduling can be reduced when a proactive or a progressive approach is used  but on the contrary a pure proactive technique is not realistic since there will always be unpredicted or unmodeled deviations that can only be dealt with by a revision technique. the combinatorial explosion of conditional schedules also suggests to develop only some of the branches and add more piece by piece in a progressive way. as a matter of conclusion  a decider should also be given a global system encompassing all of the three kinds of approaches  allowing her to tune the levels of proactivity  progression  and revision that will best fit her needs. a few mixed techniques have been proposed for making scheduling decisions in a stochastic environment  but as far as we know  no one has proposed a system or an approach that combines the three ways of scheduling.
1 representation model
this section describes a generic representation model for scheduling in a stochastic execution environment. this model integrates the three families of approaches presented in the previous section.
1 schedule
we are interested in extended scheduling problems with mutually exclusive subsets of activities  in a way similar to what was done in tsamardinos et al. . at the roots of our model  we need variables and constraints inspired by the constraint paradigm.
definition 1  variable  a variable is associated with a domain of values or symbols  and it is instantiated with one and only one of the values or symbols in this domain.
definition 1  constraint  a constraint is a function relating one  unary constraint   two  binary constraint  or more  k-ary constraint  variables that restrict the values that these variables can take.
　the domain of a variable is reduced when a decision is made or when a decision is propagated via constraints.
　we distinguish two types of variables in the problem: the controllable variables and the contingent variables.1
definition 1  controllable variable  a controllable variable is a variable instantiated by a decision agent.
　decisions may influence the state of the environment. one of the issues that depends on application domains is to decide when to instantiate controllable variables. for example  it is difficult to set activity start times in advance when activity durations are imprecise because of temporal constraints.
definition 1  contingent variable  a contingent variable is a variable instantiated by nature.
　moreover  a set of  probabilistic/possibilistic/etc.  distributions of possible values may be attached to each contingent variable. such distributions are updated during execution.
　we can now define the basic objects of a scheduling problem  namely resources and activities.
definition 1  resource  a resource r is associated with one or more variables  that represent its capacity  efficiency  and/or state. its capacity is the maximal amount that it can contain or accommodate at the same time. its efficiency describes how fast or how much it can do with respect to its available capacity. its state describes its physical condition. a resource capacity  efficiency  and state can all vary over time. these variables are either controllable or contingent. r states a global resource constraint ctr on all its variables and the variables of the activities that require it. the scheduling problem comprises a finite set of resources noted r.
　we can model the state of the execution environment as a set of state resources; e.g.  the outside temperature is modeled by a resource that can be in only one of three states depending on time: hot  mild  and cool.
 definition 1  activity  an activity  is defined by three vari-
ables: a start time variable startay  a duration variable day  and an end time variable enday. these variables are either controllable or contingent. ay may be associated with an optional set of resource constraints ct ay that involve the variables of the resources it requires.
　in a constraint-based model  to propagate the bounds of the variable domains  we usually post the following constraint for each activity: enday  startay − day. of course  constraints of any type between variables can be posted on our scheduling problem.
　our scheduling problem is composed of resources  activities  and constraints relating them  with possibly additional variables describing the state of execution environment.
　to fit the classification described in section 1  additional constraints may have to be posted by the schedule generation algorithm to  more or less  set resource allocations  make sequencing decisions  and set precise activity start times. hence we do not need to add anything to our model to achieve this.
　central to our model is the notion of conditions that are subsets of variables related by logical and/or mathematical relations: such conditions guide the branching within conditional schedules  the selection of new subsets of activities in a progressive technique  etc.
 definition 1  condition  a condition  is a logical and/or mathematical rela-
tion func in which at least one variable is involved. it may be associated with an optional active temporal window that is an interval atw =  st et  between two time-points st and et in the current schedule. if st = et  then it means the condition must be checked at a precise time-point in the schedule.
　a condition can involve characteristics of the distributions of contingent variables. a condition can be expressed with conjunctions and disjunctions of conditions.
　a typical example of a condition is what we will call a branching condition; i.e.  a branching condition is a condition that will be attached to one of mutually exclusive subsets of activities  see below . such a condition will be checked at a specific time-point that we will call a branching node.
　we propose the followingrecursivedefinition of a schedule to describe our model with respect to these particular mutually exclusive subsets of activities.1
definition 1  schedule  a schedule s is either
  void s =    or
is an activity ays partially ordered
via constraints in {ct s}  with respect to the activities of a schedule
 is a set of nbs mutu-
ally exclusive recipes rcps; i.e.  mutually exclusive recipes represent different ways of attaining the same goal  as defined below; such recipes follow a branching node bnds and lead to a converging node cnds. a node is a dummy activity aydum of null duration that does not require any resource:   with startdumay = enddumay .
definition 1  recipe  a recipe is a schedule s associated with an optional probability  possibility  or plausibility of being executed pyrcp and a branching condition bcrcp: it will be executed if and only if bcrcp is met.
　a recipe can describe one of several possibilities for performing an action; e.g.  a product can be made in different ways that are mutually exclusive. at execution  for each set of mutually exclusive recipes  only one will be executed.
　the first two ways of defining a schedule are just two alternatives to define recursively a classical partially ordered schedule without alternatives. the third introduces parts of a schedule that divide  at some given time-point  into mutually exclusive recipes: each recipe rcpi will be executed if a branching condition is met at that point.
　it should be noted that conditions must be designed such that they are actually mutually exclusive and cover all cases.
　the previous recursive definitions are actually constructive definitions that permit to build a schedule piece by piece  building subsets of partially ordered activities that are then composed into a set of mutually exclusive recipes  this set being in turn integrated into a subset of partially ordered activities that is in turn one of several mutually exclusive recipes  and so on: alternatives may be nested within alternatives.
　for tractability reasons  we assume there is no temporal constraint between two activities that do not belong to the same recipe. however  some precedence constraints can be added to constrain branching conditions to be checked before their related recipes would be executed.
1 generation and execution
we only defined a model that a proactive method could use to generate a more or less flexible schedule that would then be entirely sent to the execution controller. to make it possible to use revision and progressive techniques  we need to consider now a dynamic problem in which a solution is executed in a stochastic environment  thus requiring more scheduling decisions to be made while executing. hence we need to design a model interleaving schedule generation and execution: the resulting system must be able to react  to know what to do  e.g.  reschedule  schedule next subset  make new scheduling decisions  etc.   and to know how to do it.
　two types of algorithms will be needed: execution algorithms will be in charge of dealing with the current flexible schedule  as defined in previous section  and both making the scheduling decisions that remain and actually executingactivities; generation algorithms will be in charge of changing the current schedule  either because some part is not valid anymore and must be modified  revision approach   or because new activities must be added  progressive approach .
　the dynamic evolution of our model will be monitored via condition meeting: if such a condition is met  then we know we have to make or change decisions. the branching condition defined in the previous section is actually used by the execution algorithms  guiding them into the adequate alternative. we need to introduce here two new types of condition: an activation condition  when met  activates a new generation step through the generation algorithm; then a fire condition will actually enforce the global monitoring system to turn to this newly generatedschedule. such activation and fire conditions are needed both in revision and progressive approaches.
　typical examples of activation and fire conditions are violations of some constraints in the current schedule  arrivals of new activities to execute  critical resources no longer available  implying a revision mechanism   or more simply a condition stating that the anticipation horizon becomes too small and so we need to schedule a new subset of activities to anticipate execution  implying a progressive mechanism .
　the generation and execution model can be represented by an automaton whose states are called execution contexts.
 definition 1  execution context  an execution context  is composed of a schedule sect and an execution algorithm αect.
　an execution context is a schedule that is a solution of the whole scheduling problem or a part of it. in addition  an execution context may not contain all recipes starting from a branching node  but only those with the highest values py; another example of activation condition is hence that when the value py of a remaining recipe becomes high enough that recipe should be developed and included in the current schedule: we hence generate in a progressive way a new schedule which is the current one augmented with an additional recipe. αect makes decisions  start time setting  resource allocations  branchingon one recipe among several candidates  etc.  on the run  greedily: it cannot change decisions that are already made. in case of pure execution approach  such as dispatching  αect makes all decisions.
　our automaton also includes transitions for generating execution contexts and going from one execution context to another one.
definition 1  transition  a transition
 is composed of a source execution context ectsrctr   a target execution context ecttattr   an activation condition condacttr   a fire condition condfirtr  and a generation algorithm βtr.
　the default situation for the temporal windows of the activation and fire conditions of transition tr is the whole source execution context ectsrctr ; i.e.  their temporal windows equal the interval between the start point and the end point ofectsrctr .
　transition tr is activated when its activation condition is met. when tr is activated  generation algorithm βtr generates target execution context ecttattr from source execution context ectsrctr and the data of the problem model. execution algorithm αecttattr is set by βtr from a library of template execution algorithms. βtr may be run offline or online; it can decide or change a part of or all decisions  in particular it can select a subset of activities to include into ecttattr  progressive approach . transition tr is fired when its fire condition is met. when tr is fired  we change contexts: we go from source execution context ectsrctr to target execution context ecttattr . activation condition condacttr must be more general than or equal to fire condition condfirtr since condacttr must be met before or when condfirtr is met.
　template transitions are defined offline and each of them is an implicit description of many transitions that may be fired in an automaton model; e.g.  a template transition associated with a resource constraint rct1 may be fired each time one of the activities involved in rct1 is executing and allocated to the resource involved in rct1.
　the generation algorithm generating ecttrl and the execution algorithm associated with ecttrl are complementary: the former makes some decisions for a subset of activities  and the latter makes the remaining decisions for these activities; e.g.  the former makes allocation and sequencing decisions  and the latter sets activity start times.
　it should also be noted that all conditions are checked by execution algorithms. when a branching condition is met  we do not change contexts. when an activation condition is met  a new execution context is generated. when a fire condition is met  we change execution contexts.
　our first assumption is that uncertainty level decreases when executing a context. ergo  we leave some decisions to the execution algorithm to limit the computational effort that would be used to revise decisions  and the perturbations and instability due to such revision. decisions that can be made in advance because they concern variables with low uncertainty are taken by generation algorithms  while remaining decisions will be taken later either by generation or execution algorithms when their uncertainty will be lower.
　our second assumption is that dynamics of the underlying controlled physical system are low enough with respect to the time allotted to the reasoning system to search for schedules online. therefore one has enough time to find at least one schedule  if not the optimal one. generation algorithms should be anytime; i.e.  generation algorithms should be able to produce a schedule whose quality  robustness  or stability increases with search time. in principle  the decisions made by generation algorithms are better with respect to an optimization criterion than the decisions made by execution algorithms. the former have more time to reason and choose the best schedules among a set of executable schedules  whereas the latter are greedy and return the first executable they find.
　as a matter of conclusion  one can see any 'pure'technique can be easily instantiated with our model: a pure proactive technique will barely need a single context  generation being made once for all offline  the remaining decisions being taken by the sole execution algorithm; in a pure revision  resp. progressive  approach  contexts contain non-flexible predictive schedules with basic execution algorithms  and activation/fire conditions associated with failures or quality deviations in the current context  resp. to the horizon getting too small or the uncertainty level decreasing   and generation algorithms change the current schedule to fit the new situation  resp. add a new subset of activities . but the great strength of the model is that now all three kinds of approachescan be integrated and parameters can be tuned to put more or less flexibility  more or less revision capabilities  etc.  upon needs that are driven by the application.
1 experimental system
in this section  we simply recall a few software prototypes that we implemented  and we show how they are actually special cases of our global model and hence partly validate it. experimental results appear in the cited papers.
1 scheduling problem
the flexible job-shop scheduling problem  flexible jsp  is a scheduling problem where the set of activities ay is partitioned into jobs  and with each job is associated a total ordering over a subset of ay . each activity specifies a set of alternative resources on which it must execute without interruption. no activities that require the same resource can overlap their executions. we represent this formally by a partition of the set of ay into resource sets. a solution corresponds to allocating one resource to each activity and a total ordering on each resource set such that the union of the resource and job orderings is an acyclic relation on ay .
　for our experimental investigations  we focused on probabilistic flexible job-shop problems. random variables are fully independent and associated with probability distributions. we conducted experiments with two criteria to minimize: makespan  and sum of tardiness and allocation costs.
1 architecture
our experimental system is composed of the following modules: a solver  a controller and a world.1 the solver module is in charge of making decisions with a backtrack search  constraint propagation  and monte-carlo simulation. the decisions made by the solver module are sent to the controller module. the latter is responsible for choosing activity start times given decisions made by the solver module and what happens during execution  observations sent by the world module . the controller module monitors progression and revision conditions to start either a selection of new activities or a re-optimization  when it is relevant. the controller is also in charge of maintaining known and unknown probability distributions running monte-carlo simulation online.
1 revision approach
our experimental revision approach is parametrized by choosing a revision criterion and a sensitivity factor. a revision criterion is a condition that is monitored during execution; e.g.  we monitor the absolute difference between the expected quality  computed before execution  and the current expected quality  computed during execution based on what we observe and using simulation for the non-executed part of the schedule  and we compare this absolute difference with a reference value. if the revision criterion is met  then we reschedule. a sensitivity factor sets the sensitivity of the revision criterion with respect to perturbations that occur during execution. the sensitivity factor is set to indirectly choose the search effort that depends on the number of reschedulings that occur online  bidot et al.  1 .
1 proactive approach
our experimental proactive approach is set by two main parameters. the first parameter proactgene is used to generate a problem model without uncertainty from the stochastic problem model; i.e.  we choose a value for each random variable. the greater the values chosen  the more proactive the technique. a possibility is to choose and use the average values of distributions. the second parameter proactsimu is boolean and determines whether monte-carlo simulation is used or not during search. moreover  the number of simulation runs can be chosen  beck and wilson  1 .
1 progressive approach
our progressive approach is characterized by four parameters that can be set to choose indirectly the anticipation horizon and the size of each sub-problem: δtmin controls the anticipation horizon with respect to time  σtmin controls the anticipation horizon with respect to the uncertainty level  δtmax controls the size of each sub-problem with respect to time  and σtmax controls the size of each sub-problem with respect to the uncertainty level  bidot et al.  1 .
1 conclusion and future work
in this paper  we presented a general framework for scheduling when execution environment is stochastic. our representation model acts as a generic conceptual model that can integrate three general complementary families of techniques to cope with uncertainty: proactive techniques use information about uncertainty to generate and solve a problem model; revision techniques change decisions when it is relevant during execution; progressive techniques solve the problem piece by piece on a gliding time horizon. we showed this model can address diverse and complex scheduling problems; in particular  it is possible to handlemutually exclusivesubsets of activities. in addition  we described software prototypes directly instantiated from our representation model and controlled by several parameters. the prototypes can address a large range of probabilistic scheduling problems. this work paves the way to the development of a software toolbox gathering a large set of algorithms to manage scheduling and schedule execution in a stochastic environment. users of that toolbox would use the general architecture designed through our model but they would be able to design their own application by selecting relevant modules and correctly tuning parameters  e.g.  anticipation horizon  sensitivity factor  etc. . our future work is to implement such a complete toolbox and make additional experiments to check how parameter tuning will influence stability and robustness of the solutions that the system will generate.
