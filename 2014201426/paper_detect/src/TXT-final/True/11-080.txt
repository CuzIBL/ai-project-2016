 
	many 	of 	the 	recent 	expert 	rule-based 	systems 
 dendral  mycin  am  pecos  have architectures that differ significantly from the simple domainindependent architectures of  pure  production systems. the purpose of this paper is to explore  somewhat more systematically than has been done before  the various ways in which the simplicity constraints can be relaxed  and the benefits of doing so. the most significant benefits arise from three sources:  i  the grain size of a typical rule can be increased until it captures a unit of advice which is meaningful in that system's task domain   ii  the interpreter can become accessible to the rules and thus become dynamically modifiable  and  iii  meaningful permanent knowledge can be stored in data memories  not just within productions. although there are costs associated with relaxing the simplicity constraints  for many task domains the benefits outweigh the costs. 
1. introduction 
most ai programs employ  search  in some form. our earliest experiences  translation; chess  taught us the futility of unconstrained searching. since that time  ai researchers have experimented with various methodologies for limiting search. some of these  nilsson  1  have been externally imposed procedures: small programs that help to direct an otherwise-unconstrained search  e.g.  heuristic evaluation functions that guide the expansion of nodes in a search tree; alpha/beta cutoff detectors in an and/or game tree . another approach has been to scrap the search tree paradigm entirely and to program in such a way that search is inherently constrained. one such technique is to use a network of semantically related nodes  e.g.  woods' atn . another is to encode the program as a production system  ps . 
one of the earliest uses of production systems in ai was by newell . the architecture that he proposed and that has since been emulated by several researchers has 
this work was supported in parl by tht defense advanced research 
projects agency  f1-c-1  end monitored by tht air force 
office of scientific research the following familiar components:  i  a single production memory containing an indefinitely large number of productions  condition/action rules  in which all of the system's permanent knowledge is encoded;  ii  a single data memory  called working memory  containing assertions that are in the process of being assimilated or modified by the system; and  iii  an interpreter that repeatedly matches the conditions in each production against the assertions in data memory  selects from the set of satisfied productions one production to fire  and then executes the actions specified in that production. 
the basic appeal of production systems is that they constrain search in a context-dependent  one might say  natural   way. a production's conditions are satisfied if and only if its actions are likely to be relevant to the current state of the world  as represented in data memory . the interpreter  in order to select a production to fire  has only to search among pieces of knowledge that are possibly relevant at that moment. this is what we meant earlier when we indicated that pss do not follow the  exploring a search space  paradigm; rather  they carry out myriad small parallel searches  first for relevant pieces of knowledge  then for the most promising one of these to use. 
various constraints on the production system architecture  implicit in the description above  were imposed by experimenters in order to insure that it would be sufficiently general to enable a ps to able to behave in a reasonable fashion in any domain. much of the current work in ai is focused on the development of large  knowledge-based systems which are expert in one very sophisticated -- but also very specialized - task  e.g.  identification of mass spectrograms  anti-microbial therapy selection  speech understanding  etc. . one way of encoding knowledge in such systems is as a collection of pattern-invoked rules  and thus the production system architecture appears to be a viable candidate for supporting such systems. but is the domain-independent architecture described above the best production system architecture to use for such systems  
it has become obvious within the last few years  we think  that it is not. empirical justification for this conclusion is provided by the recent development of what have been 
languages & systems-1: lenat 1      historically  the constraints were imposed so that a production system would be able to simulate the cognitive behavior of humans - who  at least purportedly  are able to behave in a reasonable fashion in all domains. 
called rule-based inference systems  feigenbaum  1; buchanan  1; shortliffe  1; davis  1; lenat  1; mccracken  1; barstow  1; duda  1 . most of these systems are closely related to production systems: they divide the world into data and condition/action rules  and make use of an interpreter that repeatedly matches rules against data and then executes the actions of one or more of the rules whose conditions are satisfied. but because each of these systems was designed for a single  well-defined task  it was unnecessary for their designers to impose all of the constraints on the form of data memory  production memory  and the interpreter that are found in most domain-independent systems. the purpose of this paper is to explore  somewhat more systematically than has been done before  the ways in which these domain-independent constraints can be relaxed  and the implications of doing so1. 
1. data memories 
domain-independent architectures  though they limit the number of elements in data memory  dm   allow those elements to be arbitrarily complex. consequently  the amount of knowledge that can be stored in dm is theoretically unlimited. however  other constraints placed on these architectures make it very difficult to use dm as anything but an intermediate memory containing rather simple assertions. the memory is forced to be intermediate  ephemeral  temporary   working   because no data element can be linked directly to any other data element; their only relationship is that they have been deposited in dm by productions sensitive to the current context. the data elements are forced to be simple assertions because no operations on data sub-elements are permitted unless those sub-elements have been matched by the condition part of a production and because all of the operations performed on these structures must be indicated explicitly in productions  except for a few operations that are performed indiscriminately by the interpreter on all elements . 
these restrictions can be weakened by  i  permitting many separate dms to exist  each defined by a distinct set of primitive operations that can access and modify it  and  a  allowing some dms to contain statically interrelated elements. thus dms could be of two types. some could hold permanent knowledge and thus would have a significance similar to production memory  the set of productions   but their structure as well as their content could convey information. other dms could be working  intermediate  memories; that is  they would serve the same focusing function that the lone dm serves in domainindependent architectures. 
1
  for a discussion of how the nature of the  mathematical discovery  task influenced the design of am  see  lenat & harris 1 . 
¡¡¡¡for a discussion of the various dimensions along which existing production systems differ  see  davis & king 1 . 
the motivation for multiple dms is that certain tasks can be viewed most naturally as developing and enlarging a body of declarative knowledge. consider a ps that is to discover new mathematics  or one that is to do research in organic chemistry. such a system might have two dms  one containing highly inter-related domain-dependent facts  representing the existing theory   the other containing an ever-changing set of goals for augmenting the permanent knowledge stored in the first dm. there are at least two gains in using multiple dms. first  since each dm has its own set of proper operations  modifications to the data base can be specified at a higher  more natural level  and in some cases need not be specified at all . secondly  because the relationships among pieces of knowledge in dms correspond to relationships in the task domain  the system's dms are statically intelligible. 
there are  of course  some negative consequences that result from not storing all permanent knowledge within the production rules. in particular  knowledge within productions is directly pattern-invokable  while knowledge within a dm is not. hence  some processes will take longer  will involve inferencing  search  etc. in fact  there may be cases where relevant knowledge buried within the dm will simply not be successfully retrieved  due to the enormity of the search needed to find it. thus there are restrictions on when dms may appropriately be used to hold permanent knowledge. for tasks in which speed is crucial  or for tasks in which knowledge cannot be structured in a way that facilitates search  such a use will be inappropriate. as a final note  it should be pointed out that weakening the constraints on dm will affect the rules and interpreter design as well. additional rules may be needed just to manipulate knowledge in the dms  reorgani e it  reason about it  etc. 
1. production memories 
1. multiple production memories 
the reason that only a single production memory  pm  is allowed in domain-independent architectures is  as with dm  to insure that all relevant knowledge is always immediately accessible. but again  for some domains  fhis goal can be achieved even though the constraint is relaxed. multiple production memories could be used in two ways. each production memory could be paired with its own data memory. or production memories could be hierarchically ordered so that although all rules would be matched against the same data  not all rules would be matched on every cycle; rather  a subset of productions could be specified  e.g.  by an action  to be the ones to be matched against on the next cycle. 
languages & systems-1: lenat 1 the only justification for the use of multiple pms is that it allows the same set of conditions to be associated with several different sets of actions. for the most part  this is simply a programming convenience: if enough is known to distribute productions among many memories  then enough is known to add conditions to the productions so that only those productions that are actually appropriate will fire. 
this  convenience  may  nevertheless  be of considerable help since the amount of effort required to provide sufficiently discriminating conditions might be immense. in some cases  moreover  it may be impossible to provide the necessary conditions unless productions that attend to different aspects of the environment can never be satisfied on the same cycle. 
analogues of the dangers of multiple dms are present when multiple pms are allowed. relevant knowledge might not be retrieved  because it happens to be in a production inside a pm which is not currently active . thus there are restrictions on when multiple pms may appropriately be used. they are appropriate when enough is known about the task domain to make it clear when particular sets of productions can be safely  deactivated . 
1. productions treated as data 
if dms are allowed to hold permanent knowledge  then the distinction between pm and dm becomes less sharply defined. the demarcation can be further blurred by relaxing the restriction  imposed on the domainindependent architectures  that pm cannot be read 
pr 
directly. the reason for this restriction is somewhat difficult to infer. it appears to be due to a view of productions which holds that they are not themselves part of a system's knowledge  but only the vehicle of such knowledge. the obvious way to relax this restriction is simply to treat pms as full- fledged dms. 
the ability to read pm would be particularly useful in tasks that call for reasoning about the knowledge being employed to do the task. some math and natural science tasks are of this character. also  any ps which is designed to nontrivially team can make use of this ability. it could have a set of productions whose specialty is dealing with other productions; thus the system could inspect  modify  augment  correlate  compare  and delete productions in the course of adding new productions to its pm. 
1. complex rules 
many constraints are placed on the form of the condition and action sides of productions by the domain-independent architectures. again  these restrictions are imposed to insure that all relevant knowledge will always be available to the system. the main restriction that is placed on the condition side of productions is that condition elements be forms  templates   and that the match be nothing but a 
1 most domain-independent ps architectures have some form of this constraint  although many do allow rules to access other rules under certain conditions  e.g.  to access the rule fired on the previous cycle.  
1 the requirement makes sense for cognitive simulation: humans do not appear to have direct access to all of the rules that they have. 
simple membership test on a working memory of limited size. this restriction allows the match to be very efficient and thus insures that changes to working memory that indicate that some piece of knowledge has become relevant will be quickly noticed. alternatives to simple tests of set membership abound. the match can be performed against the data elements in several different data memories  some of which might have an extremely complex structure . the membership match can be extended to  almost member ; that is  partial matching may be allowed. or the testing functions may be extended to include arbitrarily complex tests on dms  and may even involve calling on a production subsystem to determine if a currently unsatisfied production can be satisfied  e.g.  see barstow  1 . 
the main restriction that is placed on the action side of productions is the restriction that action elements be unconditional. the requirement of unconditionally guarantees that only a few actions are performed on each cycle  since complex actions require tests  and thus that all decisions made by the system are made in a global context  i.e.  in the context of all possibly relevant information . if conditionally is allowed on the action part of a rule  then complex actions can be performed  including evoking production sub-systems . 
the basic effect of these condition-side and action-side relaxations would be to increase the  grain size  of each production. instead of a quickly locatable and quickly executable stimulus/response coupling  a production could represent a sophisticated  relatively self-sufficient chunk of domain-dependent knowledge  suitable for guiding an actor in a particular domain. consider  for example  one of am's 1 rules: 
if the current task is to find examples of concept 	x  and x is a predicate  and  1 items are known to be in domam x   and over 1 cpu sees  have been spent on this task  and there are no more relevant rules to fire  and x has returned  true  at least once  and x has returned  true  under 1% of the time  then consider the following as a future task: defining new predicates  similar to x  which are generalizations of x  because x is rarely satisfied  hence a slightly less restrictive concept may be more interesting than x. 
this rule embodies the piece of advice that a predicate should be generalized  weakened  if it returns  false  too often. am used this rule  for example  after  equality-ofsets  was found to be rarely satisfied  and one of the resulting generalizations was the valuable concept  samelength . 
languages & systems-1: lenat 1 many of us can understand and appreciate this rule  in its entirety  immediately upon seeing it. if it were split into a dozen tiny rules  heavily intercoupled  it would become much less understandable. for systems whose rules are to be formulated by experts from the task domain  e.g.  physicians formulating mycin rules  see shortliffe  1    a coarse level of granularity will be helpful. each production will be a meaningful unit and will be easy for other experts in that domain to understand . for some task domains  this heightened intelligibility will more than pay for any costs that the larger grain size introduces. 
one of these costs is the large amount of change that could occur  all at once  in the dms during a single uninterruptable cycle. this cost is surely unacceptable to a system that has to respond to changes in an environment that is not fully under its control. for a system that is in control  however  the problem becomes manageable. either cycle time is never a concern or it is of concern at particular  isolatable  times. in this latter case  the ps can be provided with sufficient knowledge to control the length of the cycle. this knowledge can be encoded directly in the productions  by making each appropriately complex  or it can be supplied by a dm. 
1. interpreters 
in domain-independent architectures the interpreter is a single program that sits above  out of reach of  the productions. it has its own memory  im  which cannot be read or written into by productions and in which it stores stale information. its three functions are  i  to search for satisfied productions by applying a pre-specified set of contextually independent matching rules   ii  to select one production to fire on the basis of a pre-specified set of 
conflict 	resolution 	rules 	that 	make 	use 	of 	the 	state 
1
information   and  ui  to execute the actions of the production selected. 
these constraints on the interpreter can be relaxed by  i  treating its memory as a dm that can be examined and modified by the system's productions  and  ii  treating the interpreter itself as a dm that can be examined and modified by the system's productions. by treating im as a dm  the selection of the set of productions to fire on a 
given cycle could be made more intelligently; that is  all of the system's knowledge could he used1. making the interpreter itself dynamically modifiable would allow its behavior to be governed by the current state of the world. different sets of matching rules could be used in different contexts: simple tests of class membership where that would be appropriate  or partial matching  or arbitrarily 
1
   understand  has three components in this case: the domain expert should find it easier to write such a largegrained rule  easier to comprehend it if shown it statically  and better able to follow the rule dynamically when the ps actually selects and executes it. 
1 for a discussion of the problems of conflict resolution in domain-independent systems  see  mcdermott & forgy  1 . 
1
  e.g.  am's  agenda  job-list is the im  the working memory for that program's scheduler. yet the agenda is maintained and replenished directly by the rules of that program. 
complex tests on data memories  including itself . different sets of conflict resolution rules could also he used: the interpreter could use rules appropriate to its current situation; its rules could be more or less selective: allowing one  several  or all satisfied productions to fire on a given cycle. 
this sort of relaxation of constraints is clearly in line with our avowed reason for using pss: to constrain search in helpful ways. by having the interpreter policies vary  the ps will spend more or less time constraining search  as it is or is not critical at that moment. there is also a certain symmetry which is open to us now: the interpreter can be viewed as containing domain-dependent wisdom at one level higher than  meta to  the knowledge contained in pm. tor example  a theorem-proving ps might have rules like 
  a and b  --  a   and might rely upon sophisticated rules in the interpreter to keep the execution from blowing up combinatorially. 
of course the price paid for this sophistication is the cost of dynamically reprogramming the interpreter at appropriate times. however  for a system whose task places only a limited number of different processing demands on its interpreter  the time spent in modifying the interpreter would be more than offset by the gain in flexibility which would allow different parts of the task to be accomplished as effectively as possible. 
1. concluding remarks 
since production systems constrain search in a context dependent way  they may prove to be a very valuable tool. we have attempted to show some of the alternatives open to a production system designer who wants to tailor the system he is designing to the requirements of the particular task domain within which his system will function. these alternatives consist primarily in relaxing constraints  imposed by the domain-independent ps designers  on the form of data memory  production memory  and the interpreter. if it is the case that different tasks make different kinds of representational demands  then it seems clear that such relaxations can have beneficial effects. of the benefits that we suggested above  three seem to us to be of particular note: those arising from giving productions a larger grain size; those arising from allowing productions to modify the interpreter; and those arising from allowing permanent knowledge to be stored in memories other than pm. 
systems whose task is to be  or become  expert in some particular domain so that they can be used in place of human experts  or so that a model of the knowledge necessary in some domain can be explored  can be constructed most easily if the grain size of the knowledge they store is the optimal grain size for that domain. presumably the most desirable grain size is displayed by human experts when they communicate with one another. but when experts in domains such as chemistry  medicine  or mathematics communicate  the rules that they formulate are very much more complex than the rules that can be encoded as single productions in domain-independent systems. 

languages & systems-1: lpnat 
1 

the second benefit arises from the  dynamically modifiable interpreter  idea. by viewing the interpreter as a data structure that can be read and written into by productions  and by viewing pm in the same way   opportunities are opened up for changing the performance of the system on the basis of the kind of subtask in which it is engaged. in any task domain  there are certain situations in which highly constrained search is appropriate and certain situations in which all relevant knowledge must be examined before any action can be taken. by making the interpreter dynamically modifiable  the search behavior could be tailored to the subtask. mycin provides something analogous to this by making meta-rules available  rules that can be used to select a subset of the set of satisfied productions to fire. however  a more general capability would provide more strength. since the capability of modifying the interpreter would give the system control over the amount of processing done on each cycle  for task domains in which short cycle time is sometimes important and sometimes not  the system could tailor its cycle time to the subtask. 
the third benefit arises from the fact that in some task domains  either cycle time is not an important concern or it can be controlled by varying the complexity of productions or by making the interpreter dynamically modifiable. in such cases  there may be a better way to store some knowledge than by means of autonomous rules. in some domains  a great deal is known about the structure  interconnectedness  of many of the concepts relevant to that domain. the availability of multiple data memories would allow this knowledge of the structure to be stored implicitly. note that there is no constraint that dm entries be declarative;  e.g.  a scientific theory may be best represented within a dm  even though much of it may be procedural.  
our final conclusion is that these benefits often far outweigh the costs. when nothing is known about the domain for which a ps is designed  one may opt for the domain-independent architecture. but when much is known about the domain  it is cost-effective to build some of this knowledge into the architecture. in the limit  when we are designing a system with one specific task in mind  relaxing the old simplicity constraints is clearly indicated. 
acknowledgments 
this research builds upon earlier work by the authors  some of it in conjunction with c. forgy and g. harris at cmu. to both of them go our sincere appreciation. we also wish to thank d. barstow  who contributed several excellent suggestions during the planning of this paper. 
