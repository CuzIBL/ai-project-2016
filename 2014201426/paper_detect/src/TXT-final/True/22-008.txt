 
platypus is a constraint-based reasoning engine for synthesis  diagnosis and other recognition tasks. while its target applications are similar to those of many rule-based expert system shells  the architecture of the underlying reasoning engine is not. platypus is part of our goal at tektronix of defining an architecture for smart instruments  in this architecture  a model-based knowledge representation provides rules for constructing object-centered descriptions from the input data. the descriptions produced make explicit the entities recognized in the task domain  their identifying parameters and the semantic constraints that exist among the entities. platypus is described using a synthesis task  the configuration of tektronix 1-series workstations. 
1 introduction 
platypus is a constraint-based reasoning system based on the thesis that many synthesis and diagnosis problems are best viewed as constraint-based recognition tasks. implemented as an extension to scheme  and compiling into scheme code  platypus provides a portable  efficient  coherent architecture  shell  for a large class of model-based expert systems. 
　　　platypus is motivated by our interest at tektronix in developing smart instruments: instrument systems that perform analysis of signals  not just measurement. smart instruments are active gatherers and analyzers of input  not just passive transducers. as such analysis is inherently domain and application-specific  we expect the software architecture of these instruments to be highly knowledge-based. while the analysis task is fundamentally diagnostic  engineering applications of expert systems include many synthesis  configuration and design  tasks. there are obvious benefits to having a single architecture for both. 
* new affiliation: expert systems laboratory  simon fraser university  bumaby  b.c.  canada v1a 1. 1 recognition 
we view recognition tasks as having the following structure: the knowledge base contains models for task entities  each model specifying possible components  states and relationships for its corresponding entity. the reasoning engine uses these models to interpret input data. an interpretation is a structural description composed of instances of models in the knowledge base representing the recognized entities and their actual states and relationships. so viewed  recognition subsumes both synthesis and diagnosis including many expert system tasks of current interest both in research and industrial applications. 
     in synthesis  the input is specified as requirements  desires  choices  or measurements. the knowledge base contains models of solution steps  design components and their configurations. the output is a structural description of the synthesized entity. in diagnosis  the input takes the form of signals  measurements or symbolic tokens. the knowledge base holds models of components  faults  or conditions  and the output is a structural description of the faulty situation. 
     platypus is designed for  constraint-based  recognition tasks. constraints are part of the natural ontology for context-sensitive recognition. in the context-free case  recognition degenerates into the weak method  match  used in rl  mcdermott  1a . the relationship between diagnosis and design was noted in  pople  1 . for a description of recognition in scene understanding and other disciplines  see  havens  1 . the whole notion of recognition and representation by partially described schemata goes back at least to minsky . 
1 platypus as an expert system shell 
platypus can be viewed as a new form of expert system shell  havens  1 . rule-based methodology is mature; has had many successes  but its limitations are now apparent. unstructured knowledge bases and shallow knowledge representations imply ad hoc control  lack of meaningful explanations  and knowledge acquisition and maintenance bottlenecks. these problems are due both to the lack of structure in the knowledge base and to a lack of methodology for its construction. current expert system 

shells offer many new features  but at best integrate them at the programming level. for recognition tasks  platypus implements a more coherent   knowledge level   newell  1  architecture. it supports interactive choice and retraction of input; gives a structural description as solution; allows incremental refinement of the solution description; supports default reasoning  and can provide explanations in terms of the semantics of the models in the knowledge base. 
1 platypus applied to configuration 
configuration is a well-known application of expert system technology  rl/xsel  mcdermott  1a  1b   cossack  frayman  1  . as systems become more complex  their manufacture involves increasing numbers of mutually constraining options and features. any mistakes made in configuration by sales or manufacturing engineers are costly both for the manufacturer and for the customer. configuring the system correctly at the time the order is made is the preferred solution. the generic configuration task has been formally defined as follows: 
given a fixed  pre-defined set of components  an architecture that defines certain ways of connecting these components  and requirements imposed by a user 
for specific cases  either select a set of components that satisfies all relevant requirements or detect inconsistencies in the requirements.  frayman  1  
     there are several things to note in this definition. first  configuration is distinguished from more general design and synthesis tasks by the requirement that components come from a fixed predefined set. second  configuration is seen as a satisficing task. there are multiple competing criteria for optimization  e.g. cost and performance   and hence no definition of an optimal solution. third  a useful configuration system must not only detect inconsistent requirements  but must be able to report the inconsistencies in a helpful way  perhaps suggesting alternatives. 
we are building a configurator for tektronix 
1-series workstations as an initial demonstration of the platypus architecture. configuring 1 workstations is a typical configuration task. there are optional boards  peripherals and expansion cabinets  constraints on placement of boards within cabinets  memory requirements to be met for optional software packages  and installation information needed by the customer. the configurator is designed to be used at the point of sale both to capture the customer's requirements and to complete the resulting order.. 
     in platypus  there is no separation of these input and verification/completion phases  as in xsel/r1 or cossack . rather  specification of requirements can be completely incremental  with the opportunity to view the implications of the current set of requirements before adding another. the platypus architecture guarantees that only the necessary incremental amount of work is done at each step. 
     being able to specify requirements incrementally allows us to provide a conceptually simple interface to the user. the configurator always presents a current configuration that is complete and is consistent with current user choices and preferences among defaults. the presentation includes parallel iconic and textual views of the current configuration. the user interacts with the interface by directly modifying the current configuration. after each modification  the configuration is made consistent with the new change or the modification is rejected as inconsistent with previous user choices. as much as possible  user choices are restricted to those consistent with previous choices  by constraint propagation  but this is not guaranteed  and some modifications may be rejected. on demand  rejected or disallowed choices can explained as being inconsistent with specific previous choices.1 a hand-coded prototype of this interface has been tested and the interface is now being integrated with platypus. 
1 smart instrument architecture 
the platypus architecture will be described using examples taken from the 1 configurator. the architecture underlying platypus is a combination of four technologies currently of research interest in artificial intelligence. they are 1  a model-based knowledge representation; 1  a rule processor engine; 1  a constraint propagator engine; and 1  a truth maintenance system. 
     figure 1 shows a schematic diagram of the overall design of platypus. the knowledge base contains models for the objects in the task domain represented using a schema  frame  unit  representation. each schema consists of a set of parameters  a ruleset  a set of component models  and a set of constraints on the model's parameters. instances of the schemas become the nodes in the composed network description and inherit their properties. schemas are implemented using the amos portable object system for scheme developed by adams and rees . 
　　　in platypus  the rule processor drives the reasoning process. its task is to interpret the input data in terms of the rules defined in the models. the rule language is chosen to be a conventional horn clause logic similar to prolog  with some concessions to scheme . the rule processor uses a unification pattern matcher and a backchaining control strategy. dependency-directed backtracking  via a straightforward justification-based truth maintenance system  tms   doyle  1   is used for exploring alternative search paths on failure or network inconsistency. 
     a major aspect of the recognition engine in platypus is propagation of constraints on model parameters as their values become specified. our view of reasoning is that search creates hypotheses which provide constraints on the search process itself. search and constraint propagation form a positive feedback system as illustrated in figure 1. the choice of an hypothesis provides constraints on the search space which helps choose another hypothesis and so on. 
1. dependency information is available that would allow us to indicate in detail what properties of models in the knowledge base imply an inconsistency  but we have no current plans for this or for any sophisticated generation of explanation text. 

the result of rule invocation is the construction of the output description which is a network of schema instances. the network makes explicit the objects recognized in the input data  their identifying parameters and their mutual relationships and provides a persistent intensional representation for the search space. the network consists of nodes which represent parameters or state variables and a set of k-ary constraints over the possible values for the parameters. this representation is natural. to both the rule processor and the user  the network represents instances of domain objects recognized in the input data. the arcs between instances are the semantic relationships among objects known in the knowledge base. the parameters of the instances represent the possible identities of the instance. to the constraint propagator  the network represents a set of state variables  their variable domains and a set of k-ary relations over those domains. the constraint propagator can be viewed as an independent engine which is applied to the network description as it is composed incrementally by the rule processor. the constraint propagator refines the domains of the state variables under the constraints thereby refining the descriptions of the instances in the network:. 

the platypus contains an embedded tms to maintain the consistency of the network description composed by the rule processor. a dependency lattice is built as the historical record of the user choices  assumptions  hypotheses  constraint propagations and their side effects made to the network. the tms interacts with the rule processor by analyzing inconsistencies and failures and then proposing a dependency backtrack point to the rule processor. the dependency lattice allows the backtrack of both the constraint network and the rule processor as necessary. 
1 recognition and platypus knowledge 
the architecture outlined above is justified by the belief that recognition tasks have a common underlying organization  havens  1 . these organizing principles include the following observations 
1 models 
recognition knowledge is naturally organized as models. 
this organization is dictated by the ontology of perception. 
both the natural world and the world of human artifact are composed of conceptual entities. these entities are grouped into semantically related classes by type. individual members are identified by their specific attributes and their relationships with other entities. 
　　　platypus attempts to formalize the ontology of recognition by employing a model-based knowledge representation. the knowledge base contains models for the classes of interest in the task domain. each model represents a class of a particular type whose members all share common identifying characteristics. members are distinguished only if they differ in the value of some parameter or participate in different component relationships. each model contains a set of possible components  a small number of parameters and a set of constraints over the parameters of the model and its components. 
　　　as an example  from the 1 configurator system  we will examine the model for the physical slots which hold the various electronic circuit boards of the workstation. 

　　　the semantics of the slot model is the following: a slot is in position 1  1  or 1 of its containing cabinet each slot may contain a single circuit board or be empty. there are various electrical busses each connecting certain slots in certain cabinets  figure 1 . a slot may contain only a board which is supported by the busses resident on that slot. the platypus representation is called slot-model and is shown pictorially in figure 1. the parameters defined in the model are pos# which indicates the position of the slot instance in its cabinet; bus which records which electrical busses reside on this slot; and boardset which indicates which circuit boards may be placed in the slot. with each parameter is its domain of possible values. the constraint propagator manipulates the parameter domains to ensure constraints hold. 
the components of the slot model are board  
cabinet and neighbors. when the model is instantiated  
board will contain a circuit board of a type allowed by the boardset parameter. cabinet will point to the cabinet instance which contains this slot-model instance. neighbors will contain the slot-model instances immediately to the left and right of this slot instance or be empty. 
　　　the constraints defined in the slot model relate its parameters values to specified parameters of the model's components. in slot-model  there are five such constraints. we will examine one of these constraints later  ′1 . 
　　　finally  the rules associated with the model are newsiot which creates a new slot-model instance and installs it in the constraint network and addboard which attempts to place a specified board instance in the slot. an example of a platypus rule will also be considered later  ′1 . 
1 output descriptions and the generative paradigm 
the generative paradigm of chomsky endures as a knowledge representation mechanism. the knowledge base must be finite but account for arbitrary input configurations by producing a correct description for each valid input or reporting failure recognition is seen as the mapping: 
recognition: 
input x knowledgebase =  description 
　　　in platypus  the output description is structural  a constraint network which makes explicit the entities recognized  represented as instances of the models in the knowledge base   the actual parameters of the instance  thereby characterizing the entity   the component relationship between entities  representing structure  and the constraints existing among entities  specifying the semantic relations present in the description . the constraint network inherits the structure of the models in the knowledge base  in particular each instance in the network inherits the type  parameters and constraints of its parent model. figure 1 shows part of the constraint network representation for a tek1 workstation  illustrating model instances  their parameters and associated value domains  their components and the constraints among parameters. 

1 rules & non-determinism 
search is a necessary part of recognition. our knowledge of the world is always incomplete and often erroneous. the input data sensed may be ambiguous in its local interpretation and is frequently insufficient to uniquely determine recognition. 
　　　in platypus  these limitations necessitate a reliance on rule-driven search for recognition. consequently the process of constructing the network description is non-deterministic. rules are associated with individual models to drive the recognition process for that model. 

these rules test parameter values and component existence  and change the network description by creating  deleting  specializing or composing model instances  or by constraining parameter values. non-determinism is implemented via the tms  which does dependency-directed backtracking of rule side effects. 
　　　for example  the workstation model has a rule called option1aruie for upgrading a 1 bitplane workstation to 1 bitplanes: 
option1arule: 
check that the workstation has 1 bitplanes. if an fb1 board is present then remove it 
create a new fb1 board and attempt to place the fb1 in the highest number slot possible  starting with the highest numbered cabinet. otherwise  fail. 
if this rule is applied by the rule processor for some 
workstation instance  it will augment the composed constraint network as indicated above. if the augmented network remains consistent  then the rule returns success. otherwise  an inconsistency is noted by the tms and it attempts a dependency directed backtrack  choosing either another slot for the fb1 or moving the existing board for some other slot such that the fb1 can be placed consistently. 
1 relations  constraints and constraint propagation 
relational knowledge expresses how entities can be associated with one another in any particular network composition. for instance:  the ce board must be in slot 1 of the cem cabinet  or  the fb1  fb1  cm1 board sequence must be in the highest numbered slots  be consecutively placed and be in the same cabinet . 
　　　in platypus  relational knowledge is expressed as constraints over the parameters of a model and its components. for example  the following constraint called lcb-daisychain relates the allowed adjacency of circuit boards in the slots of the first cabinet: 
semantics: the local compute bus  lcb  connects the slots of the cem. the processor  ce   display memory  mem1 & mem 1  and bus adaptor  ba  boards use this bus to communicate. there is a prescribed ordering to these boards. in particular  following the last ba board must be a memory board  an empty slot or the end of the cabinet this constraint is expressed as the 

following relation: 	1 conclusion 

constraint: 
lcb-daisychain c slotboardset x slotboardset 
lcb-daisychain = { ce  ba  ba  ba  ba  mem1  
 ba  meml1  ba  nil  -ba  ba } 
     the role of the constraint propagator in platypus is to incrementally enforce consistency on the output description as it is composed by the rule processor. the constraint propagation algorithm used in platypus is a variation of hierarchical arc consistency  hac   mackworth  mulder & havens  1 . the algorithm provides pairwise consistency for k-ary relations in hierarchically organized variable domains. other stronger forms of consistency could be applied. hac provides an implementation of  partial matching  as defined by mittal . 
1 constructing interpretations 
a consistent constraint network is an intensional description of structure. human recognition may stop with an incompletely specified representation  but in most applications of a system like platypus  one wishes eventually to construct extensions or interpretations of the description. 
     in platypus  a globally consistent interpretation of the current output description need not exist  since the constraint propagation algorithm only guarantees local consistency. if one exists  it can be found by iteratively choosing possible values for not yet fully constrained parameters  and propagating constraints  backtracking in the event of inconsistency. 
     in choosing these possible values  we use the fact that the problem domain normally has a notion of preferences among interpretations and a desire to produce the most preferred one first. in diagnosis tasks  the preference dimensions involve typicality and criticality. preferences have thresholds and the desire is to produce all interpretations having one or more preference value over its threshold. in synthesis tasks  preference dimensions involve cost and performance. the desire is a single optimal interpretation  but optimality not usually well defined. one thus either satisfices or optimizes a single dimension subject to satisfying the others. 
　　　platypus currently allows expression of a preference as an ordering among the possible values of a parameter. this then defines the order in which the remaining possible values of an not-completely-specified parameter will be chosen by the system in constructing an interpretation. as the description is further specified  such system choices  or default values  can be  silently  overridden by user choice or the rule processor. there is currently no provision for describing preferences about the order in which parameters are given default values. 
     generating interpretations based on such locally defined preferences is of course a heuristic  and not guaranteed to produce optimal interpretations. satisficing  however  can be accomplished by incorporating preference thresholds as constraints. 
the contribution of this work is a description of an expert system architecture based on a coherent theory of how recognition tasks are organized. platypus was motivated originally as part of our goal of developing smart instruments but is generally applicable to many synthesis and diagnosis expert system tasks. the system has been implemented as a portable extension to the scheme language. a prototype application for configuring tektronix 1-series graphics workstations is being developed as a demonstration of the architecture. further development of the current system has been postponed until an agreement can be reached with the first author's new organization. future research will focus on the problems of accommodating noisy data and representing uncertainty within the constraint propagation paradigm. 
