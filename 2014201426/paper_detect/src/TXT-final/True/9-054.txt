 
　　　this paper presents a framework for characterizing automatic programming systems in terms of how a task is communicated to the system  the method and time at which the system acquires the knowledge to perform the task  and the characteristics of the resulting program to perform that task. jt describes one approach in which both tasks and knowledge about the task domain are stated in natural language in the terms of that domain. all knowledge of computer science necessary to implement the task is internalized inside the system. 
	preface 	and acknowledgement 
　　　this paper represents the author's persona i view of a globai description of automatic programming. this view resulted from the author's dlscussions wlth and suggestions from numerous colleagues on this area for which he is deeply indebted. 
　　　this paper is a condensation of this view  taken from a larger work  which attempts to structure the f i e l d on the conceptualization expressed here. the interested reader should consult this work  which describes the issues in greater detail and contains supporting evidence for the views summarized here. 
introduction 
　　　the goals of automatic programming are deceptive1y simple; namely  t he effective u t i l i z a t i o n of computers. this implies both simplicity of use and e f f i c i e n t application of the computing resources. 
　　　thus  automatic programming is the application of a computing system to the problem of effectively u t i l i z i n g that or another computing system in the performance of a task specified by the user. although this is certainly what is meant by automatic programming  this d e f i n i t i o n does l i t t l e to r e s t r i c t the set of applicable computer systems included in the automatic programming domain. all compilers  operating systems  debugging systems  text editors  e t c .   f a l l 
this research is 	supported 	by 	the 	advanced research 	projects 	agency 	under contract no. 
dahc1 c 1  arpa order no. 1  program code no. 1 and 1. 
into this domain and  in fact  the term  automatic programming itself was applied to early compiler systems during the 1s. 
　　　what is needed  therefore is to either appropriately r e s t r i c t the d e f i n i t i o n of automatic programming  or to provide a set of c r i t e r i a used for measuring the acceptability or performance of an automatic programming system. such a measure of system merit is extremely hard to arrive at but would contain the following man  machine  and system applicability components: 
　　　the efficiency of the resulting program; 
　　　the amount of computer resources expended in arriving at that program; 
	the 	elapsed 	time 	used 	in 
arriving at the resulting program; 
　　　the amount of effort expended by the user in specifying the task; 
　　　the reliability and ruggedness of the resulting program; 
　　　the ease with which future modifications can be incorporated; 
and f i n a l l y . 
　　　the range and complexity of tasks which can be handled by the system. 
the basic model 
1 　　　one goal of any automatic programming system is to allow its users to state their problems and any advice about its solution in terms natural to the problem. although most problems and their solutions can be most naturally described in the terrnms native to their f i e l d s   some can best be stated and/or solved in terms of a different f i e l d   such as mathematics. occasionally  this other f i e l d is computer science  and the problem or its solutlon is expressed in terms of data structures and their manipulations. such descriptions  in terms other than those of the problem domain  are entirely satisfactory as long as they are part of the conceptual repertoire of the user and are not a r t i f i c i a l l y introduced to enable the system to comprehend the problem or process its solution. 
　　　we therefore treat both the native terms of a h e l d and the terms of other fields which users have found useful to describe and conceptualize problems and solutions in that f i e l d as the problem domain terms of that f i e l d . with this d e f i n i t i o n   we conjecture that the solution of every computable problem can be represented entirely in problem domain terms as a sequence  which may involve loops and conditionals  of actions in that domain which affect a data base of relationships between the entities of the domain. included either as part of the data base or as a separate part of the model. is the history of the model   i . e .   the sequence of actions applied to the model . this logically completes the model and enables questions or actions involving historical information to be handled. in a strong sense  such a solution is a direct simulation of the domain. the system models at each step what would occur in the domain. 
　　　the important part of the above conjecture is that any computable problem can be solved  and hence described  in problem domain terms. this enables us to divide the solution into two parts  an external and an internal part. the external part is the problem specification given by the user in completely domaln specific terms. the requirements for such users is no longer a comprehensive knowledge of computers  but rather the a b i l i t y to completely characterize the relevant relationships between entities of the problem domain and the actions in that domain. in addition  such users should have a rough awar eness of the problem solving capability of the system so that they can provide additional help where needed in the form of more appropriate macro-actions  recommendations about the use of certain act ions  and/or imperative sequences which will solve part or a l l of the problem in 
problem related terms. 
　　　the internal part is f i r s t concerned with finding a solution in problem related terms. if this has not already been provided by the user. second  this part is concerned with finding efficient solutions given the available computing resources. such 
optimizations occur at two levels beyond what is normally considered optimizatlon. f i r s t   
at the problem level  recognition that certain entities and/or relation ships are irrelevant enables their removal from the model. second  since only part of the state of the modelled domain is required  and only at certain points in the solution process  rather than simulating the model completely at each step  the system can employ alternative representations which require less maintenance and which either directly mirror the required part of the domain state or allow such parts to be computationally inferred. such representations may also enable more direct solution of the problem. it is these optimizations which form the main distinction between t he code generation par t of an automatic programming system and current state of the art compilers. 
　　　thus  	our 	d e f i n i t i o n 	of 	an 	automatic programming 	system 	is 	one 	which 	accepts a problem in terms of a model of the domain  which obtains a solution for the problem in terms of this model  and produces an efficient computer implementation of this solution in 
the form of a program. 
system reguirements 
　　　there are seven f a c i l i t i e s to be provided by  or c r i t e r i a to be satisfied by future automatic programming systems. the f i r s t is an interactive system interaction between the system and the user is required so that the specification can be given incrementally and any errors or discrepancies that arise in or from such specification can be handled as they occur. 
　　　along with this interactiveness the system should be very forgiving. it should allow great f l e x i b i l i t y in the way and time at which information is specified. it should also be forgiving by allowing the user to change or retract previous communications with the system. 
　　　the second c r i t e r i a is the amount of non-proceduralness used in the specification of the task to be performed. as far as possible the system should be told what to do rather than how to do it. there i s a continuum between the statement of a problem as the transformation from an i n i t i a l state to a goal state  and the specification of how to perform such a transformation. most of computer languge development can be viewed as a movement from specifying how to do something towards a statement of what is desired. the level of non-proceduralness achi evable wlthin an automatic programming sytem is directly related to the system's capability of turning goals into actions and this is dependent upon fts knowledge of how to acleve certain results in the problem domain. the a b i l i t y of the system to achieve results in the problem domain is used as the main distinction between non-procedural and procedural languages. thus  problems must be stated in a language appropriate for that domain  i.e.  one that can express the structure and interrelationships of the entitles within that domain  and one that users are familiar with for discussing and describing tasks and problems within that domain. only with such a language can the system know how to achieve the desired results rather than being directly told how to produce the desired result. some actions can  however  best be described in terms of bow to accomplish them rather than by the resulting state. such procedural descriptions are quite acceptable as long as they are specified entirely in problem domain terms rather than implementatlon computer terms. 
	in 	addition 	to 	problem 	oriented 
specifications  the amount of information that must be specified for the system to correctly process the problem must be reduced. this can best be done by removing details from the specification and allowing the system to f i l l them i n . as with non-proceduralness there is a continuum here  but the level that is desi red is one which omits from the specification a l l references to entities not contained within the problem domain  and which are not necessary for transferring knowledge between users of the f i e l d   . specifically  a r t i f i c i a l references to the data structures of computer science   e . g .   l i s t s   rings  arrays  symbol tables  and the like   that have been invented as a means of specifying  how  rather than  what  to do must be avoided. 
　　　next  a mechanism is required for the modification of specifications that have been previously entered either because they don't work  or because the environment in which they are operating has changed  or because df fferent behavior is desired. such specifications should be given in terms of changes in deslred results  and  entirely within the language of the problem domain 
i t s e l f . 
　　　once a problem has been specified  a mechanism is needed for insuring that the system produced is the one desired. this is especially c r i t i c a l since the system w i l l be great i y augmenting the specifications. 
discrepancies between the desired system and the one produced can arise from an inadequate knowledge of the system about the domain  from a mis-statement by the user  or from a misinterpretation of something that was specified. whatever the cause. it is important that the user can see the produced system in operation in his own terms. i.e.  in the language of the problem domain i t s e l f   so that he can check the expected behavior against the behavior produced. in addition  the system should be able to generate test input data so that a wide range of behavior of the task specified can be observed by the user. if a discrepancy is found  the user additionally requires capabilities to locate and isolate the source of the discrepancy  and then  to modify it to obtain the desired r e s u l t . 
　　　after a correct program has been produced  a mechanism is needed for transforming it into an e f f i c i e n t one. such efficiency w i l l rest on two kinds of informatlon. f i r s t   knowledge about the problem domain which enables alternative ways of performing the same task to be evaluated. secondly  information about e f f i c i e n t ways to u t i l i z e computers so that a total cost can be assigned to each of the different ways of solving the problem in domain terms. implied  but not stated in the above  is that automatic programming systems don t just automate programming. they also provide f a c i l i t i e s which help the user move from an understanding of a task to be accomplished to a finished running system which performs that task. an automatic programming system is a system which aids the user in a l l the steps from problem d e f i n i t i o n and design to f i n a l completed running programs. 
　　　to meet a l l the above c r i t e r i a automatic programming systems require detailed knowledge about the problem domain. the requirement for this knowledge li mits the   system's a p p l i c a b i l i t y to other areas  and hence  one measure of such systems is the range of problem domains which they can adequately handle 	and 	their 	method 	of 	obtaining this knowledge. 
the four phases: an overvlew 
　　　automatic programming begins with the application of problem solving to problem statements rather than problem solutions; i.e.  with the attempt by a computer system to obtain an understanding of the task being specified. once the task has been understood. if it is not in process form. it must be transformed into one. this is the traditional area of artificial intelligence and human program design. it must be verified that the resulting process model is the one desired by the user and that it is adequate for the user's problem. if not  it must be modified and transformed by the above steps and reverified. it must then be made into an e f f i c i e n t l y running program. this involves the automation of the ad hoc knowledge of 
computer science. 
　　　a complete automatic programming system thus consists of four major phases- problem acqulsition  process transformation  model verification  and automatic coding. problem acquisition is the process by which the system obtains  1  a description of the problem to be solved or task to be performed in a form processable by the system  and  1  the knowledge needed to solve the problem. the result of this phase is a well formed problem and knowledge base which can be manipulated by the system and transformed into a high level process for solving the problem during the second phase. the third phase is used to verify that this process is the one desired and that it is adequate for the problem solution. the fourth phase  automatic coding  f i l l s in the necessary details  optimizes the process  and produces the actual code to solve the problem. 
the automatic programming model 
　　　one of the most s t r i k i n g and deep rooted features of the automatic programming model presented here is the interface it creates between a high level external specification of a problem which omits data structures which are not part of the domain and the internal implementation of that specificaton in an 
efftclent 	representation. 
　　　this choice of a basic interface has predicated large parts of the entire model. through this choice as the basic interface wlthln the automatic programming model four important gains are expected. 
　　　f i r s t   the complete mode  conjecture states that such a division is feasible for stating and solving domain dependent problems. 
　　　second  since the choice of a data representatton and the mat ntenance of is consistency occupy such a large portion of current programs  the size and complexity of spect f i c a t i o n s without such representations should be drastically reduced over those which retain these representations. 
　　　third  since so much detail has been removed from the specification it is easier for. the system to understand what the task is rather than getting lost in the details of what is going on. 
　　　finally  since the problem has not been overspecified with a particular choice of representation so that the probiem was expressible  the system is now free to choose a representation that w i l l e f f i c i e n t l y solve the problem at hand. the system has been given increased f l e x i b i l i t y in its choice and may well outperform humans in correctly making representation choices; not because the system is more intelligent than the user  but because it can cycle through more possibilities and bring to bear a greater level of effort in such optimizations than any user is willing or able to invest in such issues. 
problem acquisitlon 
　　　the problem acquisition phase i s concerned with obtaining an understanding of the users problem and the domain in which it exists so that the process transformation phase can attempt to find a sequence of transformations or operations in that domain 
which will obtain the solution required by the user. thus  the problem acquisition phase is concerned with building a model of the users domain which represents the i nteractions between the entities of that domain and the effect on those entities by the allowed transformations or operations applicable within the domain. it is our primary contention that only through the development of such a model of the user's domain can the automatic programming system have any degree of generality in the domains for which it is applicable. 
　　　currently  a  1 such models of user domains have been coded into a system. it is proposed here that such models can be specified to the system by its users and that through these models the system can acquire the knowledge necessary to solve problems within these domains and to understand what is required for such a solution. the two main issues  then  are what constitutes an adequate and appropriate model and how is such a model specified or communicated to the system. 
　　　there are basically two types of models analogical and fregean. analogical models bear a strong resemblence to the structure of the object being described  such as the floor plan for a room  or the diagram model used  by gerlernter in his geometry proving program. 
　　　fregean systems  on the other hand  are linguistic or relation based  l n which expressions are built up on the relation 
.between 	functions 	and 	arguments 	to 	those functions. 
　　　since one of the basic goals of the automatic programming system is the generality of problem domains that it is willing and capable of handling  the fregean model approach has been chosen. 
　　　we can now define the adequacy and appropriateness of the models for an automatic programming system. a fregean model i s adequate if it contains a complete enough description of the relations between the entitles in the problem domain that a sequence of operations or transformations on this model 
can be b u i l t to solve the problem posed by the user. this is what was referred to as the complete model in the basic model section. thus  the adequacy of a model is dependent upon the use of that model to solve the problem. operationall  this requires that the automatic programming system is capable of finding the complete set of applicable transformations on the model and can calculate the consequences of each of these actions. the appropriateness of the model is a measure of how well suited the available transformations are to solving the problem at hand  i.e.  an adequate model can be made more approprlate by addi ng to it non-primi tlve transformations made up of a sequence of primitive ones  which are suitable building blocks for the problem being posed. the model rr dy also be made more appropriate by including recommendatlons about the s u i t a b l l i y of alternative strategies for sequences of model transformations. 
　　　users can significantly reduce the well-known problem of building a powerful general purpose problem solver by tailoring the specified model to make it more appropriate for the problem at hand. 
　　　the state of the art in natural language understanding appears adequate for the description of problems and of models and beyond our a b i l i t y to u t i l i z e the information thus obtained  and hence  should not be a bottleneck in an automatic programming system. evidence for this viewpoint comes from the work of woods in the moonrocks program  from winograd in the blocks descr i ption program  and from martin kay in the mind system. each of these systems represents an alternative linguistic technology and each is capable of 
handling a wide range of linguistic forms within the domain of its competence. 
　　　the basic viewpoint  then  is to process the user's natural language communication with the understanding that it is meant to convey to the automatic programming system a model of his problem domain. towards this end the system can extract entitles and the relationships between them from the communication. it can further query the user as to the relationships between entitles which have not  as yet  been e x p l i c i t l y specified but which have been inferred by the previous communication. such inferences by the system about the incompleteness of the model require a sophisticated understanding not only of the communication but of the types of models used for problem domain specification. unfortunately  our sophistication in both these areas is quite limited. in communication we need to be able to understand how information is ordered for presentation  how context is established and u t i l i z e d   how the capabilities of the recipient effects the communication  and how these capabilities are perceived by the speaker. in modelling we 
　　　
need to have a space of possible models  an understanding of how the parts of a model interact  a means for recognlzlng 
incompleteness and inconsistencies in models  a means for obtaining a l l the ailowed operations on the model  and the means for transforming the models with these operations. 
process transformation 
	our contention is that the main 	a c t i v i t y 
in programming is not finding a solution but in finding a solution which drops out the 
irrelevancles and which abstracts the necessary processing so that it can be e f f i c i e n t l y implemented. it is recogni zed that this is a strong contention  but in most programming problems it is f e l t that a solution is known and the main concern is in finding a more efficient one. this is not optimization in the normal sense of the term. the concern  rather. is with finding irrelevancies in the complete model and representational abstractions based on the required processing of that model. once these logical representations have been found they 
must be e f f i c i e n t l y implemented. 
　　　the above contention. if true  greatly shifts the emphasls within the process transformation phase from that of a general problem solver solving problems in a domain independent way to modifying a solution so that it does not maintain any irrelevant portions of the complete model and which abstracts the relevant portions into a more e f f i d e n t representation for the process ing required. together with problem acquisition  the a b i l i t y to find representational abstractions and transform complete model solutions into ones which u t i l i z e these representations represent the mat n technological deficiencies with obtaining an automatic programming system. 
model 	verification 
　　　although the automatic coding phase w i l l produce only correct code. program testing cannot disappear. this is because the problem acquisiti on phase and the process 
transformation phase w i l l undoubtedly employ a number of heuristies and may very well incorrectly interpret either the problem statement or the allowed transformations that can occur in the user's model. because of t h i s   the user must verify that the system created is the one that he desired. 
　　　the technology for this is at hand. it consists of today's methods wherein a test case is given to the system and its performance is used to validate the model that it constructed. additionally  the system can aid the process by generating test cases of its own which probe areas of which it is uncertain and which could have led to either misunderstanding or incompleteness in the original model. one might also expect that program debugging would disappear  but for very similar reasons it too w i l l remain under automatic programming. if there is a disparity between the user's model and the system's model  then the reason for this disparity must be obtained. 
automatic coding 
　　　automatic coding is concerned with finding an efflet ent computer implementati on of the process description obtained from the proceeding phase. this description does not yet include a choice of data representations  but does specify the major processing elements and sequences. it is intended that this phase w i l l not need any domain specific knowledge except for input frequency and distribution information. the major logical representation and processing decisions have already been made by the process transformation phase. 
	of 	ali 	the 	phases 	in 	the 	automatic 
programming system  the automatic coding one is the one essential component of any automatic programming system. without it the system cannot produce programs  and hence  though it may be useful it is not an automatic programming system. 
　　　most people are not truly creative when they reorganize sections of their program to increase efficiency. rather than inventlng t o t a l l y new representations  they appear to select one out of an ill-defined set of such possible representations and to adapt and modify it to function in the current situation. this is probably the main challenge to the automatic coding phase  the a b i l i t y not only to cycle through a set of alternative representations but to adapt and modify them to the existing situation. such an a b i l i t y would vastly increase the appl cableness of a small set of alternative representations. 
　　　from such automatic coding studies  one would expect to see both a set of heuristics and a calculus  eventually  for data representation choices. 
summary and conclusions 
　　　the definition of automatic programming started with a goal  namely  reducing the effort required to get a task running on a computer. from this a framework was adopted in which the external characteristics of automatic programming systems could be described in terms of: 
1. the 	terms 	in 	which 	the 	problem 	is stated; 
1. the method and time at which the system acquires the knowledge of the problem domain; 
1. the characteristi c 	of 	the 	resulting program. 
the choices we made are; 
1. problem statement in natural language in terms of the problem domain. 
1 1. know i edge abou t the domain acquired i nteractively in natural language in terms of the complete model of the problem domaln. 
1. resulting programs which are optimized with respect to data representations  control structure  and code. 
　　　this approach requires significant advances in a r t i f i c i a l intelligence techniques  in such areas as knowledge representation  inference systems  learning  and problem solving  and in the codification of programming knowledge in the areas of data representations  aigorithm selection  and optimization techniques. 
　　　other choices could certainly be made  and the resulting systems might look very different. one particular set of choices  suggested by. al p e r i l s   represents a system based on a completely different paradigm. his system is predi cated on incremental growth from an accepted base  namely  fortran. this idea is to increase the declarative parts of the language at the expense of the procedural. the declarative parts are in turn replaced by a series of questions from the system which specify how a defined concept is to be used. for instance  the concept  array* might generate queries to see whether the size was dynamic at run time  whether insertions or deletions are being done  whether the elements are homogeneous  and whether they are accessed sequentially. from such questions and the programs which use these concepts  an optimal representation can be chosen. 
　　　in this system  higher levels occur when enough example systems have been generated and understood by humans that someone can codify this knowledge and introduce a new level of semantics and questions. 
　　　there is no doubt that such a system would be useful  and it has the appealing attribute that the f a c i l i t i e s of the system can be incrementally expanded from a widely distributed and available base. also  such a system could instantly be used by existing programmers who could gradually learn to use the new f a c i l i t i e s on top of their a b i l i t y to 
use fortran. 
　　　on the other hand. it is not clear how far such a technique can be pushed  and whether this is the best way to achieve the goal except in the short-term. 
　　　automatic programming systems  however realized  would substantially reduce the effort and training required by its users and would enable the subsystem produced to more closely reflect the intents of their designers. 
　　　so much time  money  and effort is currently being expended  and even greater amounts forecasted in the future  for the creation of software products  that the potential benefits from automatic programming systems are enormous. therefore  since the required technologies seem feasible  such systems  u t i l i z i n g either the approach outlined in this paper or various others  should be extensively investigated. 
