 
we identify a new and important global  or nonbinary  constraint which ensures that the values taken by two vectors of variables  when viewed as multisets  are ordered. this constraint is useful for a number of different applications including breaking symmetry and fuzzy constraint satisfaction. we propose and implement a linear time algorithm for enforcing generalised arc-consistency on such a multiset ordering constraint. experimental results show considerable promise. 
1 introduction 
global  or non-binary  constraints are one of the factors central to the success of constraint programming  regin  1; 1; beldiceanu  1 . global constraints specify patterns that occur in many problems  and call efficient and effective constraint propagation algorithms. in this paper  we identify a new and important global constraint. this constraint ensures that the values taken by two vectors of variables  when viewed as multisets  are ordered. such a constraint is useful in a number of domains. for example  in the progressive party problem  probo1 in csplib.org   we wish to assign a host for each guest and period. we can model this with a vector of variables for each period. each variable is assigned the host for a particular guest. this model has unnecessary symmetry as the periods can be freely permuted. we can break this symmetry by considering the multiset of values associated with each vector and ordering these multisets.the aim of this paper is to study such multiset ordering constraints and to develop efficient and effective techniques for enforcing them. 
1 formal background 
a constraint satisfaction problem  csp  consists of a set of variables  each with a finite domain of values  and a set of constraints that specify allowed values for subsets of variables. a solution is an assignment of values to the variables satisfying the constraints. to find such solutions  we explore partial assignments enforcing a local consistency like generalized arc-consistency  gac . a constraint is gac iff  when 
   * support received by epsrc under gr/r1 and by the science foundation ireland. we thank chris beck and chris jefferson. 

　vectors of variables are indexed from 1. the minimum element in the domain of x1 is   and the maximum is max xl . the function floor x  assigns all variables in f to their minimum values  whilst ceil x  assigns all to their maximums. the vector is identical to x except v now has the domain . an occurrence vector occ x  associated with x is indexed in decreasing order from the maximum max x  to the minimum rnin x  value from the domains in 
x. the ith element of occ x  is the number of occurrences of max x  - i in x. when comparing two occurrence vectors  we assume they start and end with the occurrence of the same value  adding leading/ trailing zeroes as necessary. finally  iff x is lexicographically less than or equal to y. 
1 motivating applications 
1 matrix symmetry 
constraints 	1 many constraints programs contain matrices of decision variables  so called  matrix models    and the rows and/or columns of these matrices are symmetric and can be permuted  flener et al   1 . such symmetries are very difficult to deal with as there are a super-exponential number of permutations of the rows or columns to consider. there are several ways to break symmetry in a csp  such as sbds  gent and smith  1  or sbdd  fahle et al  1 . one of the most effective  and the one which we will concentrate on as a major application for a multiset ordering constraint  is adding extra symmetry-breaking constraints to an initial model. existing techniques for dealing with such symmetries typically eliminate only some of the symmetry. additional techniques  like those proposed here  are therefore of considerable value. 
　the progressive party problem mentioned earlier has a 1d matrix of decision variables with matrix symmetry. the rows of the matrix are the guests  the columns are the periods. each variable gives the host assigned to a given guest in a given period. as periods are indistinguishable  the columns of the matrix are symmetric. one way to break such column symmetry is to lex order the columns  frisch et al.  1 . similarly  as guests can be indistinguishable   some of  the rows may be symmetric and can be lex ordered. alternatively  we can treat each row and/or column as a multiset and break such symmetry by multiset ordering the rows and/or columns. 
　unlike lex ordering  multiset ordering the rows of a matrix may not eliminate all row symmetry. for example  consider the symmetric matrices: 

both satisfy the constraint that the first row is multiset less than the second. it is therefore a little surprising to discover that multiset ordering  which does not break all row symmetry  is not dominated by lex ordering  which does  but is incomparable. for example   but 

　when we have both row and column symmetry  we can multiset order both rows and columns. like lex ordering both rows and columns  this may not eliminate all row and column symmetry. consider the symmetric matrices: 

both have multiset ordered rows and columns. unsurprisingly  multiset ordering rows and columns is incomparable to lex ordering rows and columns. consider the symmetric matrices: 

the first has lex ordered rows and columns  but the columns are not multiset ordered. the second has rows and columns that are multiset ordered but the columns are not lex ordered. 
　an alternative way to deal with row and column symmetry is to multiset order in one dimension and apply the symmetry breaking method of our choice in the other dimension. this is one of the best features of using multiset ordering to break symmetry. it is compatible with any other method in the other dimension. for instance  we can multiset order the rows and lex order the columns. preliminary results in  kiziltan and smith  1  suggest that such a combined method is very promising. this combined method does not eliminate all symmetry  but it is unlikely that any polynomial set of constraints does . consider the symmetric matrices: 

both have rows that are multiset ordered  and rows and columns that are lex ordered. multiset ordering the rows and lex ordering the columns is again incomparable to lex ordering rows and columns. consider the symmetric matrices: 

the first matrix has rows that are multiset ordered and columns that are lex ordered. however  its rows are not lex ordered. the second matrix has rows and columns that are lex ordered but does not have rows that are multiset ordered. whilst the two orderings are theoretically incomparable  our experimental results  see later  show that multiset ordering the rows and lex ordering the columns is often the most effective symmetry breaking constraint currently known. 
1 	fuzzy constraints 
another application for multiset ordering is to fuzzy csps. a fuzzy constraint associates a degree of satisfaction to an assignment tuple for the variables it constrains. to combine degrees of satisfaction  we can use a combination operator like the minimum function. unfortunately  the minimum function may cause a drowning effect when one poorly satisfied constraint 'drowns' many highly satisfied constraints. one solution is to collect a vector of degrees of satisfaction  sort these values in ascending order and compare them lexicographically. this leximin combination operator identifies the assignment that violates the fewest constraints  fargier  1 . this induces an ordering identical to the multiset ordering except that the lower elements of the satisfaction scale are the more significant. it is simple to modify a multiset ordering constraint to consider the values in a reverse order. to solve such leximin fuzzy csps  we can then use branch and bound  adding an ordering constraint when we find a solution to ensure that future solutions are greater in the leximin ordering. 
1 	gac algorithm for multiset ordering 
the last section motivated why we want multiset ordering constraints. we need  however  to be able to propagate such constraints efficiently. we therefore developed an efficient gac algorithm for such constraints. 
1 	background 
the algorithm exploits two theoretical results. the first reduces the problem to testing support for upper bounds of x and lower bounds of y on suitable ground vectors. the second reduces these tests to lex ordering suitable occurrence vectors. identical results hold for the strict multiset ordering constraint but for reasons of space we omit them here. lemma 1 given two disjoint and non-repeating vectors of variables  x and y  with non-empty domains  gac x  my  


1 	constraints 

 proof:  =   as the constraint is gac  all values have support. in particular  has support. the best support comes if all the other variables in x take their minimums  and all the variables in y take their maximums. hence   similarly  for y1. 
　  =  the first constraint ensures that rnax x1  is supported. the values which support max xi  also support all smaller values. hence  all the values in the domain of xi are supported. by an analogous argument  all the values in the domain of yi are supported. hence the constraint is gac. qed. 
　the next lemma reduces these tests for support to lex ordering suitable occurrence vectors. 
lemma 1 given two multisets of values  m and n  m  m 

proof: see  kiziltan and walsh  1 . 
1 	a worked example 
based on these lemmas  we have designed an efficient algorithm for enforcing gac on a multiset ordering constraint. the algorithm goes through the xt and yj checking for support in the appropriate occurrence vectors. incremental computation of the lex ordering test avoids repetition of work. consider the multiset ordering constraint where: 
 we construct occurrence vectors for floor x  and ceil y   indexed from 1 to 1: 
occurrences of the 	for example  index 1 is 
1 as the value 1 occurs twice. 
　we first check if  if so  we can fail immediately because no value for any variable can have support. here  . in fact  we record  in a pointer     that the two occurrence vectors are lex ordered by index 1 of occ floor{x    which is strictly smaller than index 1 of occ ceil y  . this means that we will fail to find support in the yj if any of the xi is assigned a new value greater than 1. we now go through the xi checking for support for their maximum values  and then the yi checking for support for their minimum values. 
consider 	x1. 	as it has a singleton domain  and  its only value must 
have support so we skip it. now consider x . do its values have support  changing occ floor{x   to  decreases the 
number of occurrences o f m m   i i   = 1 by 1  and increases the number of occurrences of by 1. as this upsets the lex ordering of the two oc-
currence vectors. we therefore prune all values in the domain of x1 larger than  . this leaves a single supported value  1. 
　to decreases 
the number of occurrences of min  x1  = 1 by 1  and increases the number of occurrences of by 1. as with x1 any value of x1 larger than upsets the lex ordering. we therefore prune 1 from the domain of x1   now consider x1. changing 	to decreases 
the number of occurrences of by 1  and increases the number of occurrences of max x1  = 1 by 1. the occurrence vectors beneath a would now be lex ordered the wrong way. we therefore also prune the value  = 1  leaving a single supported value 1 in the domain of x1. as x1 and x1 have singleton domains  their values have support. 
similarly  we check the minimums of the  for support. 
however  rather than prune values above  and in some cases equal to    there is now a dual pointer . and we prune values in the domains of up to  and in some cases equal to  the pointer is the largest index such that the occurrence vectors beneath it are lex ordered the wrong way. any value less than cannot hope to change the lex ordering 
will still order the vectors the wrong way. such values can therefore be pruned. once we have considered each of the yj  we have the following generalized arc-consistent vectors: 

1 	algorithm details 
the algorithm uses two pointers and and two flags and s to avoid traversing the occurrence vectors each time we look for support. the pointer is set to to the most significant index above which all occurrences are pair-wise equal and at   they are strictly ordered. if the vectors are equal then   is set to -  the pointer  is set to the most significant index below   such that the occurrence vectors are lex ordered the wrong way. if no such index exists  we set  to - 1. the flag  is set to true if all the indices between   and  1 are pair-wise equal and the flag  is set to true if the sub-vectors below  are lex ordered the wrong way. for example  given the occurrence vectors in section 1    is set to 1  to 1  and the flags and are set to true. 
　we summarise the major steps the algorithm performs: a. b. 
c. for each xi if its maximum disturbs the lex ordering on the occurrence vectors  tighten its upper-bound to   when the occurrence vectors are lex ordered below    otherwise to 
d. for each yi if its minimum disturbs the lex ordering on the occurrence vectors  then tighten its lower-bound to when the occurrence vectors are lex ordered below a  
otherwise to  + 1. 
　when we prune a value  we do not need to check recursively for previous support. pruning changes neither the lower bounds of x nor the upper bounds of y. these values continue to provide support. the exception is when a domain is a singleton  and pruning causes a domain wipe-out. 
we now give pseudo-code for an algorithm that maintains 
gac on a multiset ordering constraint between vectors x and y which are of length n and m respectively. as the algorithm reasons about occurrences vectors  the original vectors need not be identical in length  though they often are . 
　the algorithm is called whenever lower bounds of x1 or upper bounds of yj change. lines al to a1 build the occurrence vectors ox and dy. line bl calls the procedure to 

constraints 	1 


1 	constraints 

is equivalent to gac on the original multiset ordering constraint. however  such an arithmetic constraint is only feasible for small n. further  most existing solvers will not enforce bc on such an arithmetic constraint  but will delay it until all but one of the variables are instantiated. 
1 	decomposition 
multiset ordering is equivalent to the lex ordering the associated occurrence vectors. as we have efficient algorithms for constructing occurrence vectors  via the global cardinality constraint  regin  1   and for lex ordering  frisch et al.  1   this might be an alternative approach. however  as the following theorem shows  such a decomposition hinders constraint propagation. also  the two global cardinality constraints in such a decomposition are more expensive to enforce than the algorithm presented here. we write gcc x  ox  for the global cardinality constraint that channels from a vector of variables x to the associated occurrence vector ox. 

　another approach is to use the sorted constraint in the eclipse solver. this ensures that the values taken by one vector of variables are identical but in sorted order to the values taken by a second vector of variables. to post a multiset ordering constraint on two vectors  we can channel each into a sorted vector and lex order these. the above example demonstrates that such a decomposition again hinders propagation. the sorting constraint is also more expensive to enforce. 
1 	experimental results 
we designed some experiments to test three goals. first  is multiset ordering an effective method for dealing with row and/or column symmetry  second  how does multiset ordering compare to lex ordering  which one breaks more symmetry  is a combined method  which multiset orders one dimension and lex orders the other one of the matrix  superior  third  does our gac algorithm do more inference in practice than the decomposition  similarly  is the algorithm more efficient in practice than its decomposition  
the symmetry breaking constraints we used are strict lex 
ordering on the columns on the rows  multiset ordering on the rows    strict  multiset ordering on the columns and combinations of these constraints. such constraints are posted between adjacent rows/columns. the results of the experiments are shown in tables where a  -  means no result is obtained in 1 hour  1 secs . the experiments are done using 1log solver 1 on a 1mhz pentium iii with 1 mb ram using windows xp. 
1 progressive party problem 
there are a set of host boats  each with a capacity  and a set of guest boats  each with a crew size. we wish to assign a host 

table 1: 1-1 progressive party problem using row-byrow labelling. 
for each guest and period  such that a guest crew never visits the same host twice  no two guest crews meet more than once  and the spare capacity of each host boat  after accommodating its own crew  i s not exceeded  probo1 i n c s p l i b . o r g   . 
　a matrix model of this problem  smith et al.  1  is a 1-d matrix of guests x periods where each variable is assigned a host representing that a host is accommodating a particular guest in a given time period. the rows are the guests  the columns are the periods. this model has column and partial row symmetry: any two periods  and any two guests with the same crew size are indistinguishable. we consider the 1-hosts and 1 guests problem with 1 and 1 time periods  referred as 1-1 and 1-1. these problems have ;p!1!1!1! row and column symmetries where p is the number of time periods. the actual data can be found in csplib.org. due to the problem constraints  no pair of rows/columns can be equal  hence we can safely pose strict lex ordering. however  any two distinct rows/columns might be equal when viewed as multisets. 
　as in  smith et al.  1   the guest boats are ordered in descending order of their size. we order the host boats in descending order of spare capacity to choose a value in a succeed-first manner. results obtained by row-by-row  and column-by-column labelling strategies are given in tables 1 and 1. with row-by-row labelling  we cannot solve 1-1 with or without symmetry breaking. for the 1-1 problem   iexk breaks a lot more row symmetry t h a n h o w e v e r   the reverse is true for the columns. here  ' does not break any symmetry but does. multiset ordering one dimension of a matrix therefore does not necessarily break less symmetry than lex ordering the same dimension. such 
phenomena occur through interactions with the search strategy: a search strategy might already lex order  so multiset ordering constraints break additional symmetry. the smallest search tree and also the least solving time is obtained by  lexr. this supports our conjecture that lex ordering one dimension combined with multiset ordering the other can break more symmetry than lex/multiset ordering both dimensions. 
with column-by-column labelling  we are able to solve the 
1-1 problem. neither of 	break 
any symmetry. the smallest search tree is obtained by this supports our conjecture that multiset ordering one dimension can break more symmetry than lex ordering the same or both dimensions. if the search strategy already orders both dimensions lexicographically  imposing a constraint like multiset ordering in one dimension breaks additional symmetry. 

constraints 	1 


table 1: 1-1 progressive party problem using columnby-column labelling. 
1 	sports scheduling with odd teams 
this is a modified version of prob1 in csplib.org. we have n teams  n is odd   playing over n weeks. each week is divided into  n - l /1 periods  and each period is divided into 1 slots  home and away. we wish to find a schedule so that every team plays at most once a week  every team plays twice in the same period over the tournament and every team plays every other team. we slightly modify the model in  van hentenryck et al.  1   where teams is a 1-d matrix of periods x weeks x slots. each element of teams is the team playing in a given period  week and slot. we treat this matrix as 1-d where the rows are the periods and columns are the weeks  and each entry is a list of variables giving the slots. 
　as the periods and the weeks are indistinguishable  this problem has row and column symmetries. we pose strict ordering constraints on the rows and columns of teams as the periods and weeks cannot be equal. due to the constraints on the periods  posing multiset ordering on the rows is not effective. 
　results obtained by column-by-column labelling of the teams are given in table 1. for one column  we first label the first slots; for the other  we first label the second slots. with this strategy   does not break any symmetry  so we omit it in the table. posing multiset ordering by our algorithm is much more effective and efficient than by gec and lex ordering constraints. this holds for many other search strategies. in table 1  we note that gives a smaller search tree than  however  for other search strategies the reverse is true. this supports the theoretical result that lex ordering and multiset ordering are incomparable. 
1 	conclusions 
we have identified a new and important global  non-binary  constraint. this constraint ensures that the values taken by two vectors of variables  when viewed as multisets  are ordered. we have developed an efficient linear time algorithm for enforcing generalised arc-consistency on such a multiset ordering constraint. we have proposed a number of applications for this new constraint including breaking symmetry in matrix models  and fuzzy constraint satisfaction. we have shown that alternative methods for posting a multiset ordering constraint like an arithmetic constraint or decomposition are inferior. finally  we have implemented this generalized arcconsistency algorithm in ilog solver. experimental results on a number of problem domains show considerable promise. 

table 1: sports scheduling problem. 
