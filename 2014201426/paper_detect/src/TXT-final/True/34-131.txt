 	structure of the theory 


　　　a theory of human cognitive processes in writing code for computer programs is presented which views behavior in terms of three processes: understanding  planning  and coding. using this theory  a model of the coding process has been created which reproduces the code generation behavior of an experienced  human programmer working on a set of 1 fortran problems. the model is stated as a computer program organized as a production system. 
a theory of human computer programming behavior 

　　　programming is an activity which is engaged in  in one form or another  by more than a million people  boehm  1 . surprisingly  research on human behavior in programming is very sparse and consists mainly of measurements of programmer performance. the research presented here takes a different approach than these previous studies. instead of attempting to measure individual variables associated with programmer behavior  it presents a theory of the program writing process. the theory uses a set of ideas developed by allen newell  1   and lies within the framework of the information processing approach to human problem solving  newell & simon  1 . 
　　　before presenting the theory itself  a 
　　　necessary prerequisite is definition of the class of tasks for which the theory is intended. though computer programming has been spoken of as though it were one task. in fact  a number of different 
tasks are included under this heading; they include  among many others  writing specifications for programs  writing programs given a set of specifications  debugging programs that another programmer has written  and writing documentation for programs. the particular task that has been selected for the focus of this theory is one in 
which the programmer is given a description of a function  or set of functions  which the program is to perform. the programmer must then find a 
method to perform the function and implement the method in the programming language. as a working situation  it is one which occurs by itself frequently in scientific and educational programming environments and as a part of almost every other programming task. limitations on research time and resources prevent inclusion of situations in which different parts of the task are performed by different people or of situations involving debugging behavior  though there are no obvious limitations of the theory which prevent doing so in the future. 
　　　the theory consists of three basic processes: understanding  planning  and coding  though the 
work presented here focuses only on coding. each of these processes occurs one or more times in every instance of the programming task. the operations performed by each of these processes and the way in which they invoke each other are described in the following section. 
understanding 

when a problem-solver is presented with a 
problem he has a variety of sources of information  both internal and external  available about i t ; these include his general  world  knowledge about the general type of problem at hand  reference works such as programming language manuals  and last  but not least  written or spoken problem directions - before he can actually start work on the problem  he must use these information sources to build representations of the basic elements that the problem deals with and of their properties. specifically  he must have representations of the initial state of the problem  the desired final state or goal  and one or more operations which he can apply  appropriately  to begin the transformation on the initial state. the process of building these representations is referred to as  understanding  in this theory. 
planning 

　　　when the building of representations that composes the understanding process is complete  the second of the three processes  planning  is invoked. the type of plan produced by it can best 
be described as a method for solving the programmlng problem; it consists of specifications of the way in which information from the real world is to be represented within the program and of the operations to be performed on these representations in order to achieve the desired effects of the program. these methods are used as schemas  or outlines  to guide the writing of the actual code in much the same way as plans are used to guide solutions of logic problems by gps  newell and simon  1 . the theory asserts  based on a sufficiency argument  that such a plan exists for nearly every programming problem which fits 
within the basic task definition. 
　　　plans are expressed in a functional language of the sort investigated by newell and freeman  1 ; functions specified in the language invoke structures which  in turn  require other functions. this type of behavior may be characteristic of the whole class of design problems. 

1 

analogous concepts are the plans used in the planning version of gps for the logic task  newell & simon  p. 1  1  and the language accepted by the functional description compiler routine of the heuristic compiler  simon  1 . 
     planning does not take place as a single operation; instead  a process of step-wise refinement takes place in which step makes part of the plan more detailed. the terminating condition for the refinement is that some  reasonably large  part of the plan is sufficiently detailed so that the programmer feels that he knows how to translate it into code  even though a l l of the 
details of the code are still unknown. at that point the final process in the writing of programs  coding  takes over. the coding process operates on a piece or part of a plan until either code is produced or some criterion is met which causes the coding process to report failure; when failure occurs information is passed back to the planning process which again attempts to produce a codeable plan. 
coding 

     the third of the three processes in the theory is coding. for human programmers  the basic cycle for the generation of code consists of using the plan to select and write a piece of code  assigning an effect or action to the code that has been written  and comparing the effect  or action  to the stipulations of the plan. the results of this comparison are used to select and write more code or to change the code that has been written; in turn  an effect is assigned to this new code which is compared to the plan. this cycle continues until the cumulative effect of the code meets the requirements of the plan or until some condition  such as effort expenditure  is met which indicates that the piece of plan is not codeable. 
     the effects that are assigned to code are based on the differentiations among the data that the program must actually make in order to accomplish i t s purpose. consider as an example a program for printing a l l the odd numbers in a set of integers. the program must differentiate between odd and even numbers in order to perform this task. an effect that could be assigned to a line of code in this program might be   i f the number is odd  this branches to statement 1   a state-
ment which uses the information about the odd-even distinction. as more lines of code are written  their effects are accumulated in a manner which also makes use of these differentiations; thus  the effects  this loops through a l l the numbers  
and   i f the number is odd  branch to statement 1   might be combined to give  this tests each number to see i f i t ' s odd.  when effects of this type are assigned to whole segments to code  the result is that the code is executed with symbols such as  odd number  replacing the real data; hence  the whole process has been named  symbolic execution.  
     these effects are expressed in a functional language. it resembles closely the language used to express plans  with the major difference  that the actions stated are ones that have actually been achieved rather than ones which are intended. in protocols of programming behavior  this distinction between planning statements of intent and coding statements of effect appears clearly enough so that it may be used to identify 
which of the two processes is taking place at a given point. 
     an example of a complete symbolic execution cycle for the problem just mentioned might start 
with the plan element   test each number to see if i t ' s odd.  for a fortran program  the program-
mer would begin by writing do 1-1 and assigning it the effect   this loops through a l l the numbers.  given this effect and the plan  the programmer might next write if l i /1 .ne. l i   go to 1 and then assign it the effect   this tests whether i t ' s odd and goes to 1 if it is.  finally  after closing the do loop by writing 1 continue  the programmer would summarize the effect of a l l three lines as  this loops through a l l the numbers and tests each one to see if i t ' s odd.  since this matches the plan element  program writing would proceed to the next plan element. 
     an alternative possibility in this example illustrates another aspect of symbolic execution. suppose the programmer had known only a test for even parity. since it was the only parity test available  he might have written if l i /1 .eq. l i   and assigned to it the effect   this tests whether i t ' s even.  noting that the plan requires the opposite effect  he would then alter  .eq.  to  .ne.  to obtain the test for odd parity. the 
general principle of which this is an example is that confronted with erroneous or inappropriate code  the symbolic execution process attempts to patch or modify it to obtain the desired effect. this patching or modifying behavior is one of the main characteristics that distinguish symbolic execution from the sort of goal tree building and backtracking behavior seen historically in programs such as the logic theorist  newell and simon  1  and more recently  in systems such as planner  hewitt  1 . these systems rely heavily for problem solving power on the ability to backtrack to a previous  successful position: backtracking is preferred over the creation of new subgoals. in symbolic execution  on the other 
hand  attempting to modify or add on to what had already been done takes precedence  and backtracking is an infrequent event. 
     when backtracking does take place  i t may occur at several levels. in addition to attempting to code the plan element in an alternative way  the program writer may decide that the plan is at fault. when this happens  a return is made to the planning process  and an attempt is made to find a plan  or piece of plan  which is easier to code. this new attempt in planning may even require a return to the understanding process to reinterpret the problem. if the understanding process is considered to be a  top  level process and coding process a  bottom  level one  then this ability to return to the planning and understanding process represents a  bottom-up  process  and both bottomup and top-down processes take place in programming. 

1 

a model of coding 

     with this theory as a basis  a more detailed model of the coding process has been constructed. 
this theory is described completely in brooks  1  and is summarized here. the model is intended to reproduce certain characteristics of the behavior seen in protocols of a programmer  thinking aloud  while writing a series of short programs in fortran. these characteristics include the order and sire of unit for code generation. the model is stated as computer program in a dialect of the lisp programming language. 
 the structure of the model is based on the structure for human problem-solving systems presented and defended by newell and simon  1 . it consists of a short-term memory  stm  and a longterm memory  ltm ; the ltm consists of a production system and two other structures  meanings and code. 
     stm is presumed to have a fixed capacity of a small number  less than 1  of chunks or symbols  each of which can be used to access information of arbitrary size and complexity in ltm. the slots are ordered so that introduction of new items at one end causes old ones to be lost off the other  a process analagous to one type of human forgetting behavior. 
     in addition to the introduction of new items two other processes  item modification and rehearsal  alter the contents of stm. item modification consists of updating or adding to the information in an item already in stm  as contrasted with the addition of an item containing entirely new information. rehearsal takes an item from the middle or end of stm and places it at the beginning so that it will not be bumped off the end and lost. 
     the most important structure in ltm is the production system. a production system consists of sets of pairs of conditions and actions to be performed when the conditions are met. an appropriate decision rule is employed to insure that only one aet of actions are performed at a time. executing the actions results in some change in the state of the world so that aa the system operates different conditions are met and different actions are invoked. none of the actions involve explicit branching; rather  all control is accomplished through differences in the meeting of conditions and the execution of associated actions. 
     the theory asserts that a production system is the main internal control mechanism for determining the course of problem solving and the main knowledge structure. an extensive defense of the 
  suitability of this particular control structure for modeling human behavior is given in newell and simon  1  p. 1 . the conditions for the production system in this theory are the presence or absence of certain items in stm. the conditions can describe items uniquely or they can be stated in terms of general classes of items. disjunctive or conjunctive specification of combinations of items are also possible. an example of a condition is: 
 any item which contains the word  planelement  and the unique item which is a pointer to meanings.  
if stm contains items which meet that specification  then the actions associated with it would be invoked. an example of a set of actions might be: 
 rehearse the item which contains planelement and the item which is a pointer to meanings. replace plan-element in the first item by old-plan-element.  
other long-term memory structures 

     in addition to the production system the model makes use of two other long-term memory structures. the first of the two is used for storage of the body of information about the program that gets built up as the writing of code proceeds. some of this information is contained in the code itself  but much of i t   such as the meanings of variables and labels and the effects of pieces of code  cannot be retrieved from the written code alone and is used over much too long a time period for it to remain in stm  at least in an unencoded form. because of the problem of dynamically adding information to a production system  in the program this information is contained in a structure outside the production system called meanings. meanings is organized as a set of attribute-value pairs  one set for each variable or expression. examples of the attributes include the type of the expression - pointer  label  array  etc. - and the name that is actually used for i t in the fortran program. addition of information to meanings and retrieval from it are accomplished by two special functions  newmeaning and getmeaning  which are called by the production system. 
     the third major ltm knowledge structure in addition to the productions and meanings  code  is actually information about how to access an external memory  the code that the programmer has already written. it is quite likely that very little of the actual code remains sccessible in ltm once it has been written out on paper; when the subject in this study wanted to rewrite or reuste pieces of code  longer than a line or so  that he had already written  he was almost never able to recall them directly from memory. any use  modification or correction to code which has been written 
must therefore retrieve the code from the paper external memory; and the ltm must contain the information necessary to perform the retrieval. the code structure in ltm contslns this information. since no experimental data were available on how subjects actually organize this information in memory  a simplified structure for code has been assumed; it is always searched linearly  most recent code first. 
knowledge representations in the model 

     the preceding section describes the basic knowledge structures of the model. the following section describes the way knowledge is represented within these structures. 
the plan 

     according to this theory of programming  a plan consists of a sequence of operations which must be performed in order to achieve the desired effect of the program. in the model  a plan is represented basically as a single list  each item of which is a single operation of the plan. a production places these items one at a time into 

1 

stm for coding. in some s i t u a t i o n s it is necessary to indicate that a group of these items is to be performed together; examples might be to show that a l l the items in the group belong inside the same loop or that they are part of the same branch of a c o n d i t i o n a l . for this purpose  special marker elements  somewhat l i k e begin and end in algol  are provided which may be placed before and a f t e r sets of items to indicate that they belong together in a group. 
　　　in the protocols a s i n g l e   functional language is used to t a l k about both plans and the effects of pieces of code. this is r e f l e c t e d w i t h i n the model by using a single n o t a t i o n a l system to represent both. the general form that plan elements expressed in this notation take i s : 

　　　a f i n a l comment about this notation as applied to plans is that it makes no d i s t i n c t i o n between plan elements which lead to the generation of actual program code; for example    s e t the pointer equal to the index of the f i r s t odd number found   and those which only r e s u l t in the establishment of data representations  such as   create a pointer to keep track of the l o c a t i o n of the f i r s t odd number.  
templates 
　　　since the plan i t s e l f is presumed to be language-independent  the information about the syntax and semantics of the language in which the code is a c t u a l l y w r i t t e n must be contained in the production system. for syntactic information this is done by means of structures called coding templates which are formally equivalent to a backus-normal form d e f i n i t i o n of the language  using very h i g h - l e v e l p r i m i t i v e s and very few recursion s l o t s . each template consists of a small segment of code - at most 1 or 1 lines s p e c i f i e d as a mixture of three types of informat i o n : actual code elements  descriptions or specif i c a t i o n s of code elements which are to be i n s e r t ed in the code  and parameter s l o t s which can be replaced by descriptions or s p e c i f i c a t i o n s at the point when the template is actually used. the descriptions of code elements may. in f a c t   be another template. an example of a template i s : 

	v e r i f i c a t i o n of 	the model 
　　　the model was v e r i f i e d using a data base consisting of protocols of the behavior of an experienced fortran programmer w r i t i n g a set of 1 short programs. the problems a l l involved manipulations on an array  l  which contained 1 random numbers. an a u x i l i a r y array  m  was used to indicate c e r t a i n things about the operations which had been performed l. a sample problem from t h i s set i s : 
rearrance the array so that all odd numbfs ark at the bkcimninc. place ones in the corresponding positions in m. 
　　　while working on the problems  the subject had available both paper and pencil and a terminal connected to an i n t e r a c t i v e computer system. for each program he was given a problem d e s c r i p t i o n and the name of a f i l e containing code to read in and w r i t e out the random numbers. his i n s t r u c tions were to w r i t e and debug the program and to   t a l k aloud  while doing so. a video tape recorder was used to record the subjects behavior. 
　　　transcriptions of the program-writing portions of these protocols formed the basic data for the v e r i f i c a t i o n . an example of part of one of these t r a n s c r i p t i o n s i s : 


　　　from the 1 segments which were i d e n t i f i e d as coding behavior in the 1 protocols  	four were selected for modeling by the program. 

1 

　　　a number of c r i t e r i a were used for selection  including the extent to which they were representative of other coding segments and their s u i t a b i l ity for effectively testing the theory. for each of these segments input to the program consisted of a statement of the plan derived from the protocol and stated in the notation described previously.  for a complete description of how this was accomplished  see brooks  1 .  for the segment consisting of lines 1 of the protocol just presented  part of this plan appeared as: 

　　　using this segment or protocol as an example  it is also possible to see how the plans were derived from the protocol. in this case  planning began very soon after the subject received the problem description; it takes place in lines 1 through 1 of the protocol  about 1 seconds after the subject received the problem description. since this is the only identifiable planning behavior seen in the protocol  it is assumed that planning was completed in this segment and that this same plan was used without modification throughout the writing of the entire program. this segment shows that the plan consists  in part  of looping through the array  testing each number  and keeping a pointer to the last position at which a non-odd occurs. the subject's comments as he is writing code in lines 1 and 1 indicate that the plan actually consists of keeping two pointers  one for the position at which the next odd is to be placed and one which goes through the array pointing at the next element to be tested. finally  from his comments in lines 1  not shown  as he is checking over the program and from the code he actually writes  it may be inferred that  once he has found an odd number  he intends to increment the pointer to the next odd  swap the odd number with the element pointed to by the pointer to the next odd  and then set the corresponding element to 1* 
　　　the production system takes the steps of this plan one by one  places them into stm and attempts to convert them into code. a sample of a trace of the production system on the plan just given is: 
     the production system models behavior in two respects. f i r s t   it generates essentially the same code  including errors  as does the subject; the only differences l i e in the areas of variable names and some slight differences in the order of code generation. 
     second  the production system uses knowledge structures which correspond in size and general organization to those used by the subject. an example is the way in which if statements are generated. in the production system this code is generated with 1 templates  one for the basic if statement and goto  and a second one  invoked from within the f i r s t   for the test inside the if statement. corresponding behavior in the protocol indicates that the subject also divides this knowledge into the same two units. 
assertions made by the model 
　　　the mode makes 1 general assertions about coding behavior: 
1. coding knowledge is organized as a very large number of unique plan elements  each of which has associated with it the specific information for translating it into code. 
1. this translation is accomplished by a symbolic execution process in which  as each line of code is laid down  a recognition process assigns it an effect. 
1. the information about programming language syntax used in laying down the code la organized as a collection of small pieces of knowledge  each of which specify how to write code for a desired action or operation. 
     the major support for these assertions comes from the correspondence between the behavior of the model and the behavior of the subject in the protocols. additional support for each of the assertions comes from the following analyses: 
1. the aasertlon about the structure of coding knowledge was further verified by estimating the number of new productions that would be necessary to code the plans for four additional segments. it was found that additional productions were necessary for each new plan and segment  and that the nunber of additional 


　　　the  elements present in stm  are the elements which served as the invoking conditions for the production that f i r e d o f f on the 1th cycle of the production system. 	new-code-1 is the action part of the production; 	it consists of changes to be made to the contents of stm and the other memory structures in the system. 
productions necessary did not decline as the total cumulative size of the production set grew. this is a strong indication of the large amount of knowledge specific to each plan element that makes up a programmer's knowledge of how to create code. 
1. the assertion about the role of code creation in symbolic execution was further supported by asking an experienced fortran programmer to judge whether symbolic execution was visible in the protocols. he was able to find it in 1 of 1 segments of coding behavior  indicating that symbolic execution is a ubiquitous feature of this set of protocols. 

1 

1. to add support to the assertion about the representation of syntactic knowledge  an estimate was made of the total number of templates necessary to represent completely the subject's knowledge of fortran syntax. the importance of this number is that it indicates whether the template is an appropriately sized unit for modeling syntax knowledge. when an enumeration of the syntax constructions  not observed in the protocols  was used to conservatively estimate the total number of templates needed the result was 1  suggesting an absolute upper bound of no more than 1. this figure is of approximately the correct magnitude  indicating that the template is of an appropriate size to represent syntax knowledge. 
implications for artificial intelligence 

using productions systems to model parallel 

　　one of the central features of this model is the use of a production system as both the central control mechanisms and the primry knowledge structure. an important question is whether this was an appropriate choice. a primary characteristic of a production system for modeling behavior is that  at a given point  the selection of the next piece of behavior is made in parallel from a l l the possible alternatives. any sequential dependencies seen in the behavior of a production system is the result of a specific implemenatlon and is not an inherent characteristic of the control structure itself. a structure that was essentially different from a production system would select behavior via a sequence of decisions that was an inherent part of the control mechanism structure. to argue that production systems are a particularly good choice for representing coding behavior requires that there be some aspect of the coding process which cannot be easily represented in serial fashion. 
　　in this case  a strong argument for essential parallelism can be made from the retrieval of knowledge about the association between plan elements and code. one of the main findings of this study has been that a programmer has a large body of knowledge about how to code particular plan elements. since this body is so large  serial processes in searching it ought to reveal themselves by extremely long retrieval times for information about how to code most plan elements  perhaps on the order of several minutes. additionally  the protocols ought to contain some evidence of sequential elimination of unwanted information until the correct solution is found. in this set of protocols  once the subject has a plan  coding of i t seems to start almost immediately without any utterances which would indicate that the subject has to expend effort to figure out how to 
begin. additionally  while there are several instances in which the subject considers alternative methods of doing coding  there is no evidence 
of a fixed  sequential elimination of unwanted alternatives. 
　　this evidence strongly suggests that the search for coding information is made in a parallel manner. while it is true that it is possible to map a parallel process onto a serial model  both evaluation and explication of the model can be accomplished more effectively when the correspondence between the model and the process is a clear one. given the parallel nature of the search process in this case  representing it with a production system is particularly appropriate. 
implications for the use of backtracking 

     one of the most common ways to organize a problem solving system is as a backtracking subgoaler. systems with this organization attempt to solve problems by reducing them to a set of subproblems  whose solution imply the solution to the initial problem. when the system falls at a subproblem which it has attempted to solve  it 
returns or backtracks to some prior  successful state. systems of this type vary considerably along such dimensions as the strategy used to generate and select subgoals  the amount and kind of information retained from failures  and the point to which return from failure occurs  nilsson  1; newell & simon  1 . 
     while the model presented here is not organized as a backtracking subgoaler  it is of interest to inquire what role backtracking plays in coding behavior. in i t s purest form  backtracking in programming would consist of completely abandoning some piece of code by erasing it or crossing it out and beginning again at some earlier point  up to which the code was known to be correct. in these protocols  this type of behavior occurred in only one problem. a far more common occurrence  taking place in 1 to 1 of the protocols  was that the unsatisfactory code is modified by insertion of lines  crossing out  changing names  etc.  until i t is corrected. in the production system this behavior is accomplished by productions which hsve as their invoking conditions the effects that have been assigned to the unsatisfactory code and which  as their effects  modify the existing code. 
     the point to be emphasized about this behavior is that  when a failure to generate correct code occurs  as much of the old solution attempt as possible is saved and reused. this is in strong distinction to systems such as gps  ernst & newell  1  and planner  hewitt 1  which  when failure occurs  discard the old solution attempt entirely. the contrasting way in which the subject and the model in this study behave has the effect reducing the number of goals attempted at any one level since the information obtained from attempting one goal is available in the form of written code for use by successive goal attempts. the goal  tree  thus becomes more of a straight line. generalizing from this  human computer programming suggests that a paradigm of  patch and move forward  is better suited to some tasks than the wide-spread 
 backtrack and subgoal.  

1 

directions for further work 
     the model presented here covers only the coding process and is  strlckly speaking  applicable only to this one subject. future work should attempt to broaden it both in terms of the processes covered and generality for other individuals. some of the research questions ought to be: 
1. how are plans created by human programmers  in particular  is the creation of new plans an active problem solving process or does it involve primarily retrieval of stored plan information  1. 
1. generation of code by a symbolic execution process in which first  code is laid down and then consequences are generated from i t . the consequence generation produces a large number of subproblems. 
solution of these subproblems by a recognition process. together with symbolic execution  this implies goal control dependent on the 
problem structure  rather than via a goal stack. 
bibliography 
1. to what extent and in what ways does the programmer's knowledge of the programming language he is using affect the plans he uses  
1. is the generation of code by symbolic execution an invariant across programmers and situations or are there other methods of coding that human programmers use. 
　　not only do answers to these questions represent intriguing problems in their right  but the answers to them may prove useful in applied work on improving software technology. 
footnotes 1. 
1. 
1. a. boehm  b. w. software and its impact: a quantitative assessment. rand corp. 1. 
brooks  r. a model of human cognitive 
processes in writing code for computer 
programs. doctoral dissertation. psychology dept. carnegie-mellon university  1. 
ernst  c. w. & newell  a. gps: a case study in generality and problem solving  academic press  new york  1. 
freeman  p. & newell  a. a model for functional reasoning in design. proc. international joint conference on artificial intelligence  1. the elements of the newell theory that  are used here are: 
1. development of plans by heuristic search consisting of successive functional elaboration in which functional specifications invoke structures which  in turn  require further functions. 1. hewitt  c. description and theoretical analysis of planner. doctoral dissertation  massachusetts institute of technology  1. 
1. newell  a. notes on the psychology of programming. computer science department carnegie-mellon university  forthcoming . 
1. newell  a. & simon  h. a. human problem solving  prentice-hall  new york  1. 
1. nilason  n. j. problem solving methods in artificial intelligence  mcgraw-hill  new york  1. 
1. simon  h. a. the heuristic compiler  in simon  h. a. & sikloesy  l.  eds.  representation and meaning  prentice-hall  englewood cliffs  new jersey  1. 1 
