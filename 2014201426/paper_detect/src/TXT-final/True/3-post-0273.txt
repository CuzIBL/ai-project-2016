
the purpose of this poster is to introduce a dialectical theory for plan synthesis based on a multiagent approach. this approach is a promising way to devise systems able to take into account partial knowledge and heterogeneous skills of agents. we propose to consider the planning problem as a defeasible reasoning where agents exchange proposals and counter-proposals and are able to conjecture i.e.  formulate plan steps based on hypothetical states of the world.
1 introduction
the problem of plan synthesis achieved by autonomous agents in order to solve complex and collaborative tasks is still an open challenge. increasingly new application areas can benefit from this research domain. from our point of view  multi-agent planning can be likened to the process used in automatic theorem proving. in a sense  a plan can be considered to be a particular proof based on specific rules  called actions. in this poster  we draw our inspiration from the proof theory described by  lakatos  1 . the plan synthesis problem is viewed as a dialectical and collaborative goal directed reasoning about actions. each agent can refine  refute or repair the ongoing team plan. if the repairing of a previously refuted plan succeeds  it becomes more robust but it can still be refuted later. if the reparation of the refuted plan fails  agents leave this part of the reasoning and explore another possibility: finally  bad  sub-plans are ruled out because no agent is able to push the investigation process further. as in an argumentation with opponents and proponents  the current plan is considered as an acceptable solution when the proposal/counter-proposal cycles end and no more objection remains.
¡¡the originality of this approach relies on the agent capabilities to elaborate plans under partial knowledge and/or to produce plans that partially contradict its knowledge. in other words  in order to reach a goal  such an agent is able to provide a plan which could be executed if certain conditions were met. unlike  classical  planners  the planning process does not fail if some conditions are not asserted in the knowledge base  but rather proposes an assumption-based plan or conjecture. obviously  this conjecture must be reasonable: the goal cannot be considered  achieved  and the assumptions must be as few as possible because they become new goals for the other agents. for instance  suppose that a door is locked: if the agent seeks to get into the room behind the door and the key is not in the lock  the planning procedure fails even though the agent is able to fulfill 1% of its objectives behind the door. another possibility is to suppose for the moment that the key is available and then plan how to open the door etc. whereas finding the key might become a new goal to be delegated. to that end  we designed a planner that relaxes some restrictions regarding the applicability of planning operators.
1 assumption-based planning model
in order to produce conjectures  we propose an assumptionbased planning model based on a domain independent planning mecanism  htn. in htn planning model  the objective is not to achieve a set of goals but to perform some sets of tasks. the agent's input includes a set of operators and also a set of methods  each of which is a prescription on how to decompose some tasks into some sets of subtasks. the agent proceeds by decomposing non-primitive tasks recursively into smaller and smaller subtasks  until primitive tasks  that can be performed directly by planning operators  are reached.
¡¡assumption-based planning is defined as hg  e  ai: g  is a goal description  i.e.  a set of world states   e is a partial description of the world  i.e.  the agent's beliefs  and a is a description of the actions that an agent can execute. e and g are described in propositional logic.
a primitive operator ¦Á is a tuple hname¦Á  pre¦Á  del¦Á 
add¦Ái where name¦Á is the name of the primitive action 
pre¦Á is the preconditions set needed to execute ¦Á  del¦Á and add¦Á define respectively the set of effects to delete and to add to the agent's beliefs.
¡¡a compound operator ¦Á is described by a method hn¦Á  pre¦Á  act¦Ái where n¦Á is the name of ¦Á  pre¦Á is the preconditions set needed to apply ¦Á  act¦Á defines a list of actions to execute  i.e.  the method body .
¡¡a planning problem is defined by a tuple he  o  gi: e defines the agent's beliefs; o = {hpre¦Á del¦Á add¦Ái | ¦Á ¡Ê a} defines the description of the operators that an agent can execute; g defines the goal of an agent.
a conjecture ¦Ö is defined as an ordered list of couples ¦Ö =
 hh¦Á1 ¦Á1i ... hh¦Án ¦Áni  where ¦Ái is an action in a; h¦Ái describes the assumptions that must hold before executing ¦Ái. if h¦Ái is an empty set  no assumption is needed to apply ¦Ái.
¡¡given a planning problem he o gi  a conjecture ¦Ö is equivalent to an ordered list of n + 1 world states ¦Ö = e1 e1 ... en with e1 = e ¡È h¦Á1 and ei =  {ei 1 ¡È h¦Ái 1}   del¦Ái  ¡È add¦Ái  1 ¡Ü i ¡Ü n . the set of solution conjectures c e o g  of a planning problem can be recursively defined:
  if g is an empty set  the empty conjecture is returned.
  otherwise  let ¦Á be the first task or goal of g  and r be the remaining goals: i  if ¦Á is a primitive action and there is a conjecture ¦Ö1 to reach ¦Á then c e o g  = {append ¦Ö1 ¦Ö1  | ¦Ö1 ¡Ê c e o r }; ii  if ¦Á is a primitive action and there is no conjecture ¦Ö to reach ¦Á then c e o g  =  ; and finally  iii  if ¦Á is a composed action then c e o g  = c e o append act¦Á r   where act¦Á defines the actions list to be executed in order to realize ¦Á.
¡¡to reach its goal  an agent must check all assumptions made by the conjecture. it can rely on its teammates competences to make those assumptions become true. in other words  assumptions made by one agent become additional goals to be recursively satisfied. the assumption computation distinguishes two kinds of assumptions: i  hypothesis represents literals that do not belong to the current agent's beliefs. this means that expressions missing from the beliefs are not considered as false but rather as unknown; ii  fact negation represents literals that are negations of facts in the current agent's beliefs: this fact is withdrawn and replaced by its negation.
1 dialectical controller
in a multi-agent context  the plan synthesis relies on dialectical exchanges between agents as expected in a debate. this is convenient for dialogue where participants have no predetermined role  i.e.  proponent  opponent . agents interact collaboratively in the dialogue so as to construct a plan without assumption fulfilling the assigned goals. agents have a dialogue based on speech acts. at the informational layer  speech acts can contain conjectures or propositions needed to elaborate the global shared plan. the conjectures and the refutations suggested by the agents during the dialogue are stored in a structure called proof board. each agent has its own proof board initialized at the dialogue beginning. the proof board defines the public part of the agents' interactions and records the agents' reasoning. each time an agent uses a speech act to refine  refute or repair a conjecture  the proof board is updated. through agents' dialogue  only one specific part of the shared plan is considered. we call this particular conjecture  the current conjecture. this conjecture defines the dialogue context. in order to structure the dialectical plan synthesis  we propose to define a set of dialogue conventions described according to the states of the proof board. these conventions are organized in two layers:
  an informational layer that defines the rules to exchange refinements  refutations and repairings about the current conjecture. each new conjecture suggested by an agent produces new goals to achieve for the other agents.
  a contextualization layer in which agents decide to start  when a set of goals is assigned to the system  or stop interacting when they believe that a solution was found or is not reachable. finally  agents can decide to change the dialogue context by modifying the current conjecture if it has been refuted or none of the agents can refine its assumptions.
¡¡the proof board of each agent can be viewed as a proof tree. each node defines a conjecture suggested by an agent. the edges of the tree express refinement relations. each child node defines a sub-conjecture proving an assumption of the conjecture contained in the father node. in order to test if a solution plan i.e.  a plan without assumption is contained in the proof board  agents try to extract recursively a sub-tree of the proof board from the root node. for each assumption in the root node  a sub-tree which nodes are not refuted and do not contain assumptions must be extracted. this test is recursively triggered on the alternative refinements proposed for each assumption. the performatives list used are shown in tab. 1. we consider two performatives levels. the performatives used to refine  refute or repair conjectures that have an informational content and the performatives used to modify the dialogue context. each time a performative is received or sent  the proof board is modified
levelsperformativesinformationalrefine  refute  repaircontextualizationprop.enter  prop.leave  prop.change  ack.enter  ack.leave  ack.change  rej.enter  rej.leave  rej.changetable 1: performatives list ordered by level.
1 conclusion
the advantage of the dialectical plan synthesis is to merge in the collaborative plan generation  the composition and the coordination steps. it also includes the notion of uncertainty in the agents' reasoning and allows agents to make conjectures and to compose their heterogeneous competences. moreover  we apply conjecture/refutation to structure the multi-agent reasoning as a collaborative investigation process. however  former works on synchronization  coordination and conflict resolution are integrated through the notions of refutation/repairing. from our point of view  this approach is suitable for applications in which agents share a common goal and in which the splitting of the planning and the coordination steps  when agents have independent goals  they locally generate plans and then solve their conflicts  becomes difficult due to the agents strong interdependence.
