 
many of standard practical techniques of solving constraint satisfaction problems use various decomposition methods to represent a problem as a combination of smaller ones. we study a general method of decomposing constraint satisfaction problems in which every constraint is represented as a disjunction of two or more simpler constraints defined  possibly  on smaller sets of values. we call a problem an amalgam if it can be decomposed in this way. some particular cases of this construction have been considered in  cohen et a/.  1; 1b; 1al including amalgams of problems with disjoint sets of values  and amalgams of independent problems. in this paper  we concentrate on constraint classes determined by relational clones  and study amalgams of such classes in the general case of arbitrary finite sets of values. we completely characterise amalgams of this form solvable in polynomial time and provide efficient algorithms. 
1 introduction 
in the constraint satisfaction problem  csp  the aim is to find an assignment to a set of variables subject specified constraints. csp provides a generic approach to various combinatorial problems frequently appearing in artificial intelligence and computer science  including the propositional satisfiability problem  in which the variables must be assigned boolean values  graph-theoretical problems  scheduling problems  temporal and spatial reasoning  database theory  and many others. 
¡¡the general csp is np-complete  montanari  1. however  the time complexity of many practical problems can be considerably decreased by representing a problem as a combination of smaller problems. such decomposition methods have been intensively studied and implemented in most of existing constraint solvers. most of them deals with the hypergraph associated with a problem instance  see  e.g.  gottlob et al.   1; dechter and pearl  1; freuder  1    and to date are highly developed. another possibility  decomposition of constraints themselves  cohen et al.   1; 1b; 1a   remains almost uninvestigated. the present paper focuses on this class of decomposition methods. 
¡¡in many cases of interest we may restrict the form of allowed constraints by specifying a constraint language  that is a set of allowed constraints. every constraint is specified by a relation  so  a constraint language is just a set of relations over the set of values. one of the most natural ways to decompose such a restricted csp is to represent every its constraint as a 
¡¡disjunction of two or more simpler constraints on  possibly  smaller sets of values. we say that a constraint language  t  is the amalgam of t1  t1 if every constraint in t is the dis-
junction of a constraint from t1 and a constraint from t1. in this case we call t1  t1 the components of t. 
¡¡the main research direction in the study of amalgams is  of course  developing efficient algorithms solving the corresponding constraint satisfaction problem. however  as we shall see the complexity of the csp arising from an amalgam is not determined automatically by the complexity of its components. therefore  the first research problem we deal with is the tractability problem: under which conditions the problem arising from an amalgam is tractable.  a problem is called tractable if it can be solved in polynomial time.  then we tackle the algorithmic problem: design efficient algorithms for tractable amalgams. 
constraints 	1 ¡¡as is naturally expected  algorithms for amalgams tend to use algorithms for their components  especially if ones are already known. unfortunately  in general  the connection between constraint languages and their amalgam cannot be expressed by usual constraint techniques  and strongly depends on properties of particular constraint languages. thus  solutions to both research problems are expected to be nontrivial. amalgams have been introduced in  cohen et al  1   though another name was used. in icohen et a/.  1a   amalgams were considered in the simplest case when the sets of values for languages t1  t1 are disjoint. in this case  for any amalgam  the corresponding problem is trivially reducible to the problems over the components  that solves both the algorithmic problem and the tractability problem: an amalgam gives rise to a tractable problem if and only its components do. certain properties of interaction of constraint languages may yield a reduction of an amalgam to its components. in  cohen et al  1  and later in  cohen et al  1b   several such properties  so-called independence of constraint languages  have been identified. a number of 
previously unknown tractable constraint languages have been represented as amalgams of very simple and well studied independent constraint languages. 
¡¡it has been shown in  jeavons  1b  that the tractability of the constraint satisfaction problem arising from a constraint language implies the tractability of the problem for the relational clone generated by the language. therefore  a reasonable strategy is to concentrate on relational clones rather than arbitrary constraint languages. in this paper we solve the tractability and algorithmic problems for amalgams of relational clones. we completely characterise tractable amalgams and provide efficient algorithms in this case. the characterisation criteria is stated in terms of  first  properties of components of an amalgam  and second  the tractability of a certain constraint language on a 1-element set of values. the latter language reflects the interaction of the components. thus  both the characterisation and the reducing algorithms use schaefer's dichotomy theorem for boolean constraints  schaefer  1 . 
¡¡throughout the paper we heavily use the algebraic technique for csp developed in  jeavons  1b; jeavons et a/.  1 . 
1 	preliminaries 
1 basic definitions 
let a be a finite set. the set of all n-tuples of elements of a is denoted an. a subset of an is called an n-ary relation on a  and any set of finitary relations on a is called a constraint language on a. 
definition 1 let y be a constraint language on a set a. csp r  is the combinatorial decision problem whose instance is a triple v =  v; a; c  in which v is a set of variables  and c is a set of constraints  that is pairs of the form c =  s  q  where s is a list of variables of length mc called the constraint scope  and q y is an rnc-ary relation  ccdled the constraint relation. the question is whether there exists a solution to v  that is a mapping ¦×: v -  a such that ¦× s  € q 
for all  s  q  c. 
example 1 an instance of graph q-colorability consists of a graph g. the question is whether the vertices of g can be labelled with q colours so that adjacent vertices are assigned different colours. 
¡¡this problem corresponds to element set  of colours  and the disequality relation on a. 
a constraint language t is said to be tractable  np-complete  if the problem csp r  is tractable  np-complete . 
now we introduce the central notion of the paper. 
definition 1 let ta  tb be constraint languages on sets a  b respectively. the amalgam of ta  tb is defined to be the constraint language on a u b 
 are 
of the same arity . 
example 1 let a = {a c d} b = {b c d}  and ta = {qa}  tb = {qb} where qa qb are partial orders: 

columns of the matrices represent tuples of the relations. 
then  where qa u qb is a quasiorder. 
example 1   cohen et a/. 1  let z be the set of all integers  and y the set of congruences of the form x = a 
 mod m  treated as unary relations. the chinese remainder 
theorem implies that y is tractable. the amalgam consists of expressions of the form x = a  mod ra  v x = b 
 mod n   and by results of  cohen et al  1b  is tractable. for example  this means that we are able to recognised in polynomial time the consistency of the system 
x1 = 1 	 mod 1  v x1 = 1 	 mod 1  x1 = 1 	 mod 1  v x1 = 1 	 mod 1  x1 = 1 	 mod 1 . 
we are concerned with the following two problems. 
problem 1  tractability problem  when is csp tractable  
problem 1  algorithmic problem  find a polynomial time algorithm for tractable csp |. 
in fact  properties of the amalgam do not strongly depend neither on properties of the original constraint languages nor on the way they interact. for example  if v   t1 contains no relations of the same arity then their amalgam is empty. we  therefore  should restrict the class of constraint languages to be studied. 
1 relational clones 
for any problem in csp t   there may be some sets of variables whose possible values subject to certain constraints which are not elements of y. these constraints are said to be implicit and arise from interaction of constraints specified in the problem  jeavons  1a . 
¡¡to describe implicit constraint relations we make use of the natural correspondence between relations and predicates: for an n-ary relation q on a set a  the n-ary predicate pe is true on a tuple a if and only if a  q. usually  we will not distinguish a relation and the corresponding predicate  and freely use both terminology. an existential first order formula is said to be primitive 
positive  pp-  if its quantifier-free part $ is a conjunction of atomic formulas. 
definition 1 a relation is an implicit relation of a constraint language y on a set a if it can be expressed by a pp-formula involving relations from y and the equality relation =a. 
¡¡a constraint language y is said to be a relational clone if it contains all its implicit constraint relations. 
¡¡the relational clone  y  of all implicit constraint relations of t is called the relational clone generated by y. 
1 	constraints example 1 the intersection of relations of the same arity  and cartesian product are expressible via pp-formulas: 

the notion of a relational clone considerably simplifies the analysis of constraint satisfaction problems in view of the following result that links the complexity of a constraint language and the relational clone it generates. 
theorem 1   jeavons  1b   let t be a constraint language on a finite set  and t  t  finite. then csp t'  is polynomial time reducible to csp t . 
this result motivates restricting problems 1 to the class of relational clones. 
example 1  continuation  reconsider the constraint language t from example 1. results of  cohen et al  1b  implies that  is also tractable. this larger amalgam includes  e.g.  constraints of the form  mod m v y = b  mod n   which are not members of 
1 	invariance properties of constraints 
another advantage of considering relational clones is that they often admit a concise description in terms of algebraic invariance properties  poschel and kaluznin  1; jeavons  1b . an  m-ary  operation / on a set a preserves an n-ary relation q on a  or q is invariant under /  or / is a polymor-
phism of q  if for any 
q the tuple 	belongs 
to q. for a given set of operations  c  the set of all relations invariant under every operation from c is denoted by inv c. conversely  for a set of relations  t  the set of all operations preserving every relation from t is denoted by pol t. every relational clone can be represented in the form inv c for a certain set of operations c  poschel and kaluznin  1 . therefore  in view of theorem 1 the complexity of a finite constraint language depends only on its polymorphisms. 
¡¡we need operations of some particular types that give rise to tractable problem classes. 
definition 1 let a be a finite set. an operation f on a is called 
proposition 1   jeavons et al  1; 1   // t is a constraint language on a finite set  and pol t contains an operation of one of the following types: constant  semilattice  affine  majority; then y is tractable. 
the complexity of constraint languages on a 1-elemcnt set is completely characterised in  schaefer  1 . this outstanding result is known as schaefer's dichotomy theorem. by making use of proposition 1 the algebraic version of schaefer's theorem can be derived  jeavons et al  1 . 
   'note that in some earlier papers  jeavons  1b; jeavons et al  1  the term ac1 operation is used. 
theorem 1  schaefer   schaefer  1  a constraint language t on a 1-element set is tractable if and only if pol t contains one of the operations listed in proposition i. otherwise t is np-complete. 
1 	tractable amalgams 
in this section we give a complete solution of problems 1 for amalgams of relational clones. throughout the section 
a b are finite sets   are relational clones on a  b respectively. first  we reduce problems 1 to the case when  = 1 and prove np-completeness results in this case. then we concentrate on tractable cases and present a solving algorithm for these cases. 
1 	the result 
we assume that contain empty relations of any arity  because otherwise contains a constant operation  and therefore is tractable by proposition 1. the case when d is empty was completely investigated in  cohen et al  1a . 
proposition1   cohen et al.  1a   /f d =  then csp is polynomial time reducible to csp ra   
csp rb . hence  	is tractable if and only if both 
ra   rb are tractable. 
so  we assume d to be non-empty. 
proposition 1   jeavons et al  1; jeavons  1hl  /f / is a unary polymorphism of a constraint language t then the 

mial time equivalent to csp t . 
by  we denote the restriction of a  unary  operation / onto a set c. the following statement is straightforward. 
nology. 
definition 1 the relational clone to be monolithic i f c o n -
tains no unary relation e with 
let denote the relational clone generated by the set where c =  c ...  c 1. obviously  
is defined analogously. 
¡¡¡¡1 we do not specify the length of the tuple c =  c ...  c   because it is always clear from the context. 

constraints 	1 


1 	constraints 


constraints 	1 

