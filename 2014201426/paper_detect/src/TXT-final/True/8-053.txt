s from the text p-list a list  called a b-list  which has an l-list for each possible occurrence of any of the brackets. each such l-list has the entries: the bracket together with its confidence    and a null character  1  representing selection of a symbol other than the bracket  together with a confidence which represents the effect of suppressing the bracket    note the example below . if there are k brackets on the original l-list  there are  entries on the new l-list. for single-character brackets  the non-bracket confidence  v  is simply that of the highest confidence non-bracket character on the original l-list. for multiple-character brackets v it the average of the highest-confidence nonbracket characters. this latter measure has not been tested  since the extended dictionary-matching procedure has never failed to correctly classify a multiple-character basic symbol which was also * covering bracket. 
     the cover procedure selects a nest from the blist by generating  by descending number of brackets 
-1-

ordered l i s t of principal basic symbols  and an abstract representation of the global structure to be assigned to the text  a roden-form pattern. 
　　　the success of the method depends on the abili t y of the association procedure to  spread the risk  of selecting a particular pattern over a sufficiently large number of characters in the text -thus the need for eliminating recursion and adjacent non-terminals in patterns in order to bring to the surface the principal basic symbols which serve to identify the occurrence of that pattern  for example  note the explicit structure of  aexp  in example g1 of section i i   . another important property of the method is that the pattern is automatically positioned with respect to a. thus  missing delimiters  which cause the bounds on a phrase to be set incorrectly  are detected by noting that the pattern was successful in matching the interior of the bounded text. similarly  erroneous delimiters are detected by noting that the pattern has been truncated on one or both ends by an i n correctly positioned bound. for an example of the latter  consider the processing of the  for state-
ment  of fig. 1: after the f i r s t two phases of context analysis  the p-list might have the form 

figure 1 
the erroneous   ;   has caused a higher-level goal to partition the string into two  statement 's. the high confidence head match of  for statement  to for :* w i l l cause the association procedure to immediately report an  r-add  failure   i . e .   a delimiter is hypothesized to have been  added  just beyond the right end of a . 
　　　the task of the association procedure is to process the bounded segment  a  of the p-list to produce a skeletal instance  n  of the pattern p. 
　　　first  a process is invoked to construct from 1 and b  the basic symbol l i s t  w  for p; i . e .   w is a l i s t of occurrences of these basic symbols. 
the elements of w are triplets   symbol   value    pointer   where  value  is the average confidence that the string found at  pointer  in a i s   in fact  the basic symbol  symbol . symbols found at the head and t a i l of a are tagged with special*-  -1 indicators so that patterns which require head and/or t a l l symbols can distinguish them. 
　　　a l l possible occurrences of basic symbols of more than one character w i l l be found on w. an unpleasant problem is encountered if a l l possible single-character symbols are also included: errors 
may be introduced which w i l l not be detected by the subsequent context-free analysis. for example  in any algebraic language  the symbol which would be selected from the alternative l i s t for some operator  such as *  w i l l be the f i r s t operator in the hierarchy which occurs on the l i s t . that i s   if a + appears as the lowest confidence entry on an l - l i s t for *  then the expression w i l l parse as  and the error w i l l never be detected. the following approach seems to circum-
vent the d i f f i c u l t y : when processing a singlecharacter basic symbol  which is classified as a delimiter  an l-list is selected only if that delimiter has higher confidence than any other delimiter which may appear on the l - l i s t . delimiters which are missed with this procedure are detected as drop errors in subsequent syntactic analysis and corrected by the recovery procedure. 
　　　the second step in the association process has the task of selecting and expanding elements of the pattern p. the match is controlled by the l i s t w  of occurrences of basic symbols. briefly  the association procedure sequences through w  from l e f t to right. the elements of w serve to select a subpattern of p if a correspondence can be established between the basic symbols of each. selected subpatterns are appended to the growing skeletal node  n. iterative and selective patterns  if not selected  are appended with an x  unexpended  indicator in the event that they may be needed in subsequent drop recovery. in rare cases  on exhausting the pattern  a string erroneously recognized as a basic symbol may result in a partially satisfied conjunctive pattern accompanied by unused symbols on w.  e.g.  an erroneous do in processing a  for statement  in algol could lead to an unsatisfied :=  with the :- and the correct instance of the jio l e f t on w.  these 
cases are corrected by sequencing through the pattern  the match is now controlled by the pattern  and w from right to l e f t   searching w for an instance of each unsatisfied symbol in the pattern. if a l l of these can be satisfied  and w is s t i l l not empty  we examine the remaining entries on w for symbols which are both in the proper order  position in 1  and have higher confidence than a symbol already selected. if such an instance is found  the original symbol is replaced. 
　　　if in a conjunctive pattern a head or t a i l match is obtained  then the right-extensibility  r-add  or left-extensibility  l-add  indicators  respectively  are set at the node. the r-add i n dicator at a node specifies that the associated pattern is satisfied with the portion of the pl i s t bounded by g but that the remainder of the pattern can only be satisfied by matching more of the p-list to the right. thus  if an error has  in fact  been detected  it must be an erroneously recognized basic symbol  an  add    which caused the right bound of g to be incorrectly positioned. similarly  the l-add indicator specifies a possible incorrect l e f t bound. 
-1-　　　1.1 resolution. if the association process was not able to correct a l l detected errors  the parser reports the failure to the parent node. 	otherwise  a procedure is invoked  given n and the bounds of g  to set the bounds for the subphrases of n. 	then the parser is applied recursively to n. 	if the recursive call reports an error involving a covering bracket assigned at the current level  the parser restarts the cover  associate  resolve process with the next valid cover nest in the sequence  see  cover conflicts  below . 
　　　1.1 error recovery and correction.* the only  syntactically-correctable  errors which remain to be considered are those which cause the incorrect positioning or positing of subgoals. when the parser reports a failure in the analysis of a subpattern  the indicated failure is of four main types  cover-conflict  add-failure t dropfailure  or total failure. 
　　　the treatment of failures is  of course  determined by the context of the type of pattern in 
which the error is detected. in disjunctive patterns  the failure may simply indicate a syntactic dead-end  i . e .   incorrect positing of a subgoal. therefore  error processing is postponed until the entire disjunctive pattern is scored in hopes that a subsequent disjunct w i l l succeed. this strategy proves to be reliable since the most d i f f i c u l t patterns to satisfy  i . e .   the most redundant  are 
matched f i r s t . 
　　　1.1 add-fallures. an add-fallure occurs when a substring has been erroneously recognized as a basic symbol  at the current or higher level  resulting in the assignment of a phrase to a substring which has been truncated at one or both ends. 
　　　the strategy of add-failure correction is to back the failure up the parse graph until 
 a  a conjunctive branch point is encountered where an adjacent iterative or selective node can be removed along with the basic 
symbol which is presumed to be the source of the d i f f i c u l t y ; or 
 b  a disjunctive branch point is encountered where the parser can postpone the error recovery  the effort could be wasted on a syntactic dead-end . 
　　　1.1 drop-failures. when a basic symbol is missed by the association process   i . e .   a drop error   the result is an improperly bounded subgoal. the error is detected at a lower level  when the subgoal is analyzed  as a left-drop  l-drop  or right-drop  r-drop . the stragegy of drop recovery is to back up the parse graph u n t i l 
 a  a context is encountered which permits the introduction of a new iterative phrase to cover the unrecognized text; or 
 b  basic symbol which delimited the subgraph containing the drop is encountered  per-
mitting the parser to replace this i n -
stance of the symbol with another instance in the unrecognized portion of the text;or 

for examples  see darden. 
 c  a selective node is encountered  allow-ing the parser to abandon the recovery 
effort  or 
 d  a disjunctive branch point is encountered  allowing the parser to postpone error recovery. 
　　　1.1 cover-conficts. since the cover generation algorithm produces covers ordered by descending total number of brackets  cover errors are detected during an attempt to suppress a basic symbol which is also a bracket belonging to a cover established at level k. when this condition is detected  the parser sets the  request recover indicator  at the current node. as with the other 
error indicators  this information is backed up the parse graph until the parser either shifts to another successful analysis path at a disjunctive node or reaches the phrase node at level k where the culprit nest was assigned. at this point the 
parser restarts the cover  associate  resolve process with the next valid nest in the sequence. 
　　　1.1 total failure. a total failure is usually an indication of a syntactic dead-end or is the f i r s t indication of an add-error. the strategy of total-failure recovery is to back up the error indication until either a disjunctive 
branch point is encountered  permitting the parser to try another analysis path  or a conjunctive branch point is encountered. in the latter case  the recovery investigates three possibilities: f i r s t   that the unsatisfied conjunct was an erroneously expanded iterative phrase; second  that one or more basic symbols  which delimit the conjunct  are mispositioned   i . e .   a combined add/drop error has occurred ; and t h i r d   if the conjunct which failed occurs at the head or t a i l of the pattern  then a higher-level l-add or radd is assumed and reported to the parent node. 
　　　in the f i r s t case  we must have a pattern fragment . . a b y . . .   with possibly one of a y null and p an iterative subpattem. the basic symbols 
which selected p are suppressed at the current level and the text segment reanalyzed as an ay. 
　　　in the second case  we must have a pattern fragment of the form . . a t b . . . where only one of a p failed. since we have symmetry  assume that p failed. if the recovery is to succeed  t must be an add-error and must have been dropped in the text bounded by p. therefore  we suppress t and search for the highest confidence occurrence of a t in the text bounded by  if found  we reanalyze the text segment with the new assignment. the process is continued u n t i l there are no more t ' s to try or a successful parse is obtained. if errors s t i l l remain  which are only head or t a i l errors  then it is assumed that the third case holds  and the appropriate error is reported. 
-1-　　　1.1 	scoring the complete node. 	when the parser completes the analysis of a particular node  the scoring procedure is invoked to evaluate the success of the analysis. 	the processing of a disjunctive node w i l l not reach this stage unless a l l the dlsjuncts reported some type of error. 	in this case the parser attempts to select the most promising path for error recovery by replacing the disjunctive node by the subnode reporting the highest basic symbol match score  ties are broken by taking the subnode with the largest number of selecting characters . 	if a l l subnodes reported total failure  then total failure is i n dicated for the node. 
　　　the scoring of conjunctive nodes is straightforward. the basic symbol match score has already 
been recorded by the association process. the complete node score is simply the logical product of the scores of a l l the subnodes. iterative and selective nodes are simply given the score of their respective subnodes. 
summary of context analysis 
　　　the context analysis system comprises three phases. the f i r s t phase  extended-dictionary matching  replaces substrings of the text which are sufficiently close to basic symbols in the dictionary. the second phase  name-space clustering  attempts to discriminate an instance of every 
name in the text and to assign a common spelling to a l l occurrences of the same name. the third phase  syntactic analysis  applies a strategy of unbounded-context parsing and hierarchical consistency checking to achieve reliable partitioning of the entire text into simpler subproblems. the main path through the parser accomplishes the matching of patterns to the text by successive covering  association  and resolution processes. identifiers are given special treatment. error detection and recovery is based on the discovery of either part i a l matches  e.g.  head or t a i l matches  or 
matches which are properly contained within the bounds assigned to a subgoal. 
	v. 	discussion 
　　　this paper has been concerned with the methods employed in a syntax-directed contextual post-processor for the detection and correction of character recognition errors. we conclude with a few 
observations about these methods and about possible directions for future work. 
　　　the high r e l i a b i l i t y of the extended-dictionary matching process follows from the fact that dictionary entries of the same length are generally quite distant from one another  in the sense of a hamming-distance  and from arbitrary strings 
which may occur in the object language. 
　　　if one is satisfied with the assignment of a common spelling to a l l occurrences of the same name  the name-space clustering performs satisfact o r i l y . even if this spelling is different from that intended by the author of the text  if the name is local to the processed text  then the resulting program is semanticaliy equivalent to the original. however  the author of the text may be dismayed to find that every occurrence of his v a r i able min has been changed to mom. 
　　　it is clear that if the present strategy and tactics prove inadequate to achieve our goal of a 1% overall error rate  that there are a large number of extensions which can be expected to further enhance i t s performance. these generally involve improvements in the parser's handling of local context  for we are f a i r l y confident that the parser has a firm grip on global syntactic structure. 
　　　the principal techniques currently employed in hierarchical consistency checking involve the parenthesis-counting of minimal cover nests and the basic-symbol matching of the association pro-
cess. many additional checks are possible: for example  constraints on the minimum and maximum  where maxima e x i t     lengths of substrings  checks for valid prefixes and suffixes and for substrings which cannot appear in the tentatively assigned subgoal. 1 
　　　there are two extensions which we are p a r t i cularly interested in investigating:  a  the detection of prefixes or suffixes in identifiers. the intrinsic nature of clustering methods is to group very similar samples. thus is it likely that a method which associates a l l instances of buffer w i l l also group together a l l instances of both bufferi and bufferl. however  the distance measure should be able to recognize the cases where two strings have t a i l  head  substrings which are quite distant relative to the root substring and give proportionately more weight to the t a i l  head  contribution to the distance.  b  the concept of a name needs to be extended to include names  such as arrays or functions  which nearly always occur with some accompanying structures  e.g.  matrix  ... ...  or fun    ...    the recognition of this structure w i l l help both in discovering instances of the name and in correcting errors in the accompanying bracket structure. 
　　　a final observation is that the unboundedcontext parser's grasp of global structure may 
well prove sufficient for the system to discover the language membership of a piece of garbled text. that i s   if the system contains roden-form 
grammars for algol  fortran  lisp  and snobol  the parser could determine which grammar to apply  based on an i n i t i a l analysis of the text by each grammar  taking the most redundant grammars f i r s t . 
acknowledgements 
the author wishes to thank his colleagues at 
the university of texas at austin  and especially dr. woodrow w. bledsoe and dr. e. m. greenawalt. 
