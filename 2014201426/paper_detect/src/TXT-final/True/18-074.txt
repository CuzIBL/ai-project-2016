 
     this paper explores the issues that arise when sss'-like search algorithms are implemented in parallel. there is an important implicit assumption regarding the open list of sss*  and a*-like algorithms ; those states which are guaranteed never to become part of an optimal solution are forced down into the open list and never rise to the top for expansion. however. when multiple processors are introduced in a parallel version of sss*. these buried states become subject to expansion despite their provable suboptimality. ir such states are not identified and purged  they may exert an enormous drag on the parallel algorithm because considerable processor effort will be wasted  however  the pruning mechanisms of alpha-beta can be adapted by a parallel sss*; the resulting algorithm hybrid is suitable for searching game trees and general and/or trees in parallel 
	1 	introduction 
a. the alpha-beta and sss' algorithms 
     the alpha-beta game tree search algorithm offers significant potential for search speedup by  pruning   or ignoring game tree branches that cannot affect the final mlnimax value of the root. the state space search algorithm  or sss*  stockman 1 . as originally presented  usually dominated alpha-beta by the  parallel  traversal of subtrees. whereas alpha-beta was condemned to search strictly in a left-to-right fashion  sss* sent  probes  simultaneously into the tree  and  in a manner not unlike a*  nilsson. 1   maintained an  open  list of partial solutions ordered by descending merits. however  sss* could also be used to search general problem-reduction representations as well as simple game trees  stockman and kanal. 1 . stockman's original sss  underwent a few revisions  and the final version  pearl. 1  is admissible and always dominates alphabeta.  we shall henceforth assume that the reader is familiar with the next-state operator g of sss* as well as list notation for trees.  
b. essential components of sss* 
     for later comparisons  we give a high-level description of the sss* algorithm: 
algorithm sss* 
 1  place the start state  i.e.  root  on the open list. 
 1  if open is empty  exit with failure and halt. 
 1  remove the top state s from open. 
 1  if s is final  i.e.. represents a complete solution then return s with success and halt 
 1  apply the next-state operator g to s and add g s  to the open list  possibly with changed merits . 
 1  go to  1 . 
     additional detailed discussions of sss* can be found in  leifker and kanal. 1 . 
     our goal is to implement a form of sss* in parallel  using a generalized alpha-beta pruning process to excise suboptimal states from the open list before any processor effort is wasted. this proposed algorithm  which we call hybrid  is suitable for use in searching general and/or trees as well as game trees. since any game tree can easily be transformed into an and/or tree  with strictly alternating levels of and-nodes and ornodes   general and/or trees are used in the discussion which follows  although  as in game trees  only top-down expansion of states will be considered our concepts are unlike previous hybrid algorithms  campbell and marsland. 1   in that there is a true coalescence of alpha-beta and sss*. not simply a juxtaposition of the two in one program. 
	ii 	introduction of parallelism 
a. where to introduce parallelism 
     the control part  or driver  of sss* is relatively straightforward. a state is removed from the top of open and examined. 
if it is final  i.e.. its root is solved   it is taken as the solution and the algorithm halts  if not. the  next-state  operator g is applied to the state and the result s  placed back into the open list. if the number of states in open ever drops to zero  the algorithm halts with failure 
b. a first possibility 
     to implement a form of non-partitioned sss* in parallel  multiple processors obviously must be introduced somewhere. one of two possible locations is shown in figure l. where only the top state from open is removed at a time. the processors v    p 1 pn then cooperate to expand this state through the next-state operator g and return the results back to open. if g were a very complex operator having many disjoint  tasks  this arrangement would probably be very attractive. the fundamental algorithm would not be changed  and it would still share in all the formal properties enjoyed by sss*. the only difference would be that the actions of operator g would be accelerated considerably. 
     this method of  operator parallelism  must be rejected tor the following reasons:  l  it forces processors to assume specialized tasks.  1  it can create enormous bottlenecks when work cannot be conveniently partitioned  and  1  it has the potential to cause enormous congestion among the waiting processors because the tasks have been broken down into excessively primitive components. 
c the alternative 
     the alternative  shown in figure 1  overcomes many of these pitfalls and is amenable to parallel processing by n processors  even when n is not specified until runtime. the basic approach is to permit each processor to access the open list. 

each processor removes the next state from the top of the open list  expands the state by itself  and returns the resulting state s  back to open this is the method adopted by hybrid. as one might expect. hybrid is not simply a variation of sss* - it represents a new way of heuristic control using the operator g. consequently  the formal properties of sss* do not necessarily hold for hybrid. the remainder of this section defines hybrid formally and discusses the ramifications of allowing pro cessors to manipulate stales from the interior- of the open list 
     a special notation must be introduced to facilitate discussion of parallel algorithms. the construction 
	  obegin - statement-list 	coend 
indicates concurrent execution  dijkstra  1  in that all statements of - statement-list are executed simultaneously. the notation is augmented here such that processors may be specilied explicitly by attaching their names as labels to statements. 
     the hybrid algorithm simply assigns each of the given n processors a copy of the sequential sss* program. pormalty  the preliminary version can be defined as: 

	d. leitker and l. kanal 	1 

figure 1 
the boolean variable. halt serves as a global flag to initiate parallel processing and then to terminate it when a solution is found. presumably the open list and the halt variable are contained in shared memory and guarded by semaphores. more elaborate synchronization constructs could also be used  hoare  1 . but these concerns will not be addressed here. the point to remember is that processors must be in critical sections to change any data in shared memory  and that at most one processor can be in a critical section at a time. 
	ill 	anomalies op the hybrid algorithm 
a two problems with the proposed hybrid 
     the proposed version of hybrid given in section ii is only preliminary because two interesting anomalies occur which must be investigated further:  1  there is no clearly defined time to halt should hybrid find no solution; and  'j  the preliminary version of hybrid is not admissible  i.e.. if hybrid halts with a solution  that solution cannot  be guaranteed to be optimal  b. the first anomaly: when to halt  
     as defined above  the algorithm is simply allowed to enter an infinite loop if no solution exists for the given tree. although this is hardly desirable in a practical application. it does illustrate a problem that occurs whenever more than one processor is granted access to an open list. suppose that hybrid is executed on a given tree with two processors  p  and pj;   and that the open list contains one start state when execution begins. processor pi  will enter a critical section  remove the state from open  exit the critical section  and begin generating its successors. processor pj will then pursue a similar action  but it will find the open list  empty because ;pi  has not finished expanding the state. if processor pj is sufficiently naive  it may conclude from the empty list that the given prr has no solution and then may even attempt to force the entire algorithm to terminate with failure. since this is clearly not the true state of the computation  hybrid  as given above  merely instructs all processors to wait idly until  1  a  next  state arrives at the open list for expansion  or  1  the global halt condition is raised by the discovery of a true solution. 
c. the second anomaly: is hybrid admissible  
     as n  the number of processors  increases  there is also in increase in the likelihood that the algorithm will halt with a non-optimal solution. to see this  recall that the check for termination is made when the state is removed from open  not after it has been generated and about to be placed back onto open. the inadmissibility of hyybrid  then  although unexpected. is easily demonstrated: as the number of processors increases  the total number of examined states increases  thus raising the probability that a non-optimal solved state hovering near the top of the open list will be selected for expansion and identified as a final solution. this does not occur in sequential 

1 	d. leifker and l. kanal 
sss*. for there the open list is kept strictly sorted by merit  and only the top state is examined at a time. 
d. correcting the anomalies 
     both the anomalies may be easily eliminated. the first anomaly is corrected by halting only when the open list is empty and all processors are idle; the second by maintaining a  tentative optimal merit   i.e.. a running best solution found so far   and halting only when all remaining states on open are below this threshold. unfortunately  even with these modifications  hybrid as it stands is grossly inefficient because of the presence of provably suboptimal states on the open list. this issue is discussed in section iv. 
     there is an important implicit assumption regarding the definition of z. initially  z is empty and grows as the algorithm evaluates more and more terminal nodes. however  once a node becomes provably suboptlmal. it remains provably suboptimal and is removed from all additional consideration. if this were not the case  rule  1  above would give rise to nodes with only transient suboptimality. 
d. the final version of hybrid 
z. if there is such a node  the entire state is discarded and the processor returns to open for another state. 
iv 	provably suboptimal states      the efficient final version of hybrid is essentially the same as corrected hybrid at the end of section iii  with the exception that as each processor in hybrid removes a state from open  it verifies that no node in the state is a member of 

a. efficient use of processor effort 
     very often in the course of execution of sss* the interior of the open list may contain states which are guaranteed not. to be subsumed by any optimal solution. this never causes a problem in sequential sss*  for there only the top state is examined. however  considerable processor effort will be wasted if any processor is permitted to fetch and expand any of these provably suboptlmal states. it is therefore clear that any efficient version of hybrid requires a decision procedure to  test  states as they are taken off the open list. if the state is provably suboptlmal. it is discarded. it is expanded only if it has any potential of becoming an optimal solution. 
b. another look at alpha-beta 
     the alpha-beta algorithm  suitably generalized  can be adapted for use in an efficient version of hybrid. although alpha-beta evaluates nodes in a strict left-to-right fashion  the use of alpha values and beta values captures very neatly the concept of suboptimality. if these attributes can be managed by hybrid  they will provide a quick decision procedure for identifying provably suboptimal branches of the search tree. however  for mnemonic purposes  we shall use the names  floor  and  ceiling  in place of  alpha value  and  beta value ; when discussing the attributes of problem #k. it is convenient to write  floor k   and  ceiling k  . it should be emphasized that this notation is not a function in the mathematical sense  but is rather an attribute which can be accessed and changed. 
c. definitions 
     formally  if node #n is terminal and solved with merit m  then floor n  = celling n  = m. ir terminal node #n has not yet been expanded  then floor n  = 1 and ceillng n  = 1. if non-terminal node #n has and successors  then floor n  is defined as the minimum of its successors' floors  and ccillng n  is defined as the minimum of its successors' ceilings. if nonterminal node #n has or successors  then floor n  is defined as the maximum of its successors' floors  and ceillng n  is defined as the maximum of its successors' ceilings. for any given prr having nodes p1 pn   we define the set z of provably suboptimal nodes as follows: 
 1  if any node pk has an ancestor pj- such that pj is in z  then pk is in z. 
 1  if any node pk has an ancestor p; such that floor p    is greater than ceiling pk    then pk is in z. 
 1  if any or node pk has an ancestor py and sibling node pi such that floor p   is greater than floor pk    and floor p   is greater than ceillng p;  . then pk is in z  a  don't-care  cutoff . 
	v 	remarks 
     this is only a high-level description of the hybrid concept. the detailed mechanisms for practical implementations and the design of appropriate data structures and algorithms to detect provably suboptimal states are current topics of our research. 
