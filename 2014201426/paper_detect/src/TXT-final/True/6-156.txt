 
flux belongs to the high-level programming languages for cognitive agents that have been developed in recent years. based on the established  general action representation formalism of the fluent calculus  flux allows to implement complex strategies in a concise and modular fashion. in this paper  we extend the flux language to reason about domains involving continuous change and where actions occur concurrently. using constraint logic programming  we show that this reasoning is performed in an efficient way. 
1 introduction 
one of the most challenging and promising goals of artificial intelligence research is the design of autonomous agents  including robots  that solve complex tasks in a dynamic world. to reach autonomy in partially known  constantly changing environments requires the high-level cognitive capabilities of reasoning and planning. using a mental model of the state of their environment allows for the agents to calculate the outcome of different action sequences in advance and then choose the best plan to execute for a specific goal in mind. 
　formal theories of reasoning about actions and change have the expressive power to provide such high-level capabilities. the fluent calculus  thielscher  1   as one of the established action representation formalisms  uses the concept of state update axioms to solve the representational and inferential aspect of the classical frame problem. based on this formal theory  the high-level programming method flux has been developed in recent years  thielscher  1 . 
using the paradigm of constraint logic programming  the powerful flux kernel provides general reasoning facilities  so that the agent programmer can focus on the high-level design of intelligent agents. 
　autonomous agents in real-world environments have to take into account that the execution of actions takes different amounts of time. some actions can be modeled as discrete changes  others involve continuous change and should rather be seen as the initiation or termination of complex processes. such processes may contain parameters whose values change continuously and which are formalized as functions over time. a car moving on a road with a constant velocity v  for instance  can be represented by a 'process fluent' 
movement 	where the parameter x1 denotes the 
location of the car at the time when the motion was initiated. the fluent movement itself  although it describes the particular continuous change for the location x of the car at the time t  will stay unchanged until some other action will affect it. continuous change is then modeled by fluents describing arbitrarily complex  continuous processes. these fluents remain stable in between the occurrence of two consecutive actions  and yet they internally represent continuous change. 
　in a world full of ongoing processes  however  an agent executing a plan is not the only source of change. also the laws of physics frequently imply an evolution of the environment  like for example  the action of a falling ball bouncing when it reaches the floor. the fundamental property of such so-called natural actions  reiter  1  is that they must occur at their predicted times  provided no earlier actions  natural or deliberative  prevent them from occurring. because such actions may occur simultaneously  concurrency must be accommodated. 
　in this paper  we present a flux system which allows for the design of intelligent agents that reason and plan in domains involving continuous change and where actions occur concurrently. using the paradigm of constraint logic programming  our extension to flux integrates both kinds of actions  deliberative and natural  into one method for the planning and execution of actions. reasoning in terms of time intervals  our method allows for the efficient generation of plans in concurrent  continuous environments. our work is based on the theoretical approach presented in  herrmann and thielscher  1; thielscher  1a . other existing agent programming methods like the robot control language developed in  shanahan and witkowski  1  or the golog programming language  levesque et al.  1   do not handle  in domains involving concurrency and continuous change  the concept of a natural action at all or only have separate accounts for natural actions on the one hand  reiter  1  and for deliberative actions on the other hand  grosskreutz  1 . 
　in the next section  we introduce our example scenario and shortly recapitulate the fundamentals of the flux system. we then give briefly the theoretic solution in the fluent cal-

cuius. thereafter  we present our extension of flux to concurrent  continuous domains and discuss the employed constrained handling techniques. in the last section we conclude and show some possible future work. all programs are available on our web site: h t t p : //www. f l u x a g e n t . o r g / 
1 flux 
the example agent program in this paper is set in a waterway scenario. the agent has to steer a barge through a system of canals. the water levels in the canals are dependent on tides. at some places of the canals there are locks which a ship can only pass on a high tide. due to the geographical facts the tide levels differ for different locks. the canals themselves are too small to turn around but sometimes there are intersections where the agent steering the barge can choose one direction  see also fig. 1 . 
　to develop an agent for this scenario  we use the highlevel programming method flux which is grounded in the action theory of the fluent calculus. the fluent calculus is a many-sorted predicate logic language with four standard sorts: fluent  state  action  and slt for situations   thielscher  1 . states are compose of fluents  as atomic states  using the standard function o : state state state and constant  state  denoting the empty state . the program for our agent  for example  uses these two fluents: representing that the barge is at cell 
at time and tide denoting that at time the water level at lock i is at high/low tide. similarly as in the situation calculus  reiter. 1   the constant denotes the initial situation and the situation after having per-
formed action a in situation s at time t. the state of a situation s is denoted by the standard function state s . for example  the initial state in the waterway scenario of fig. 1 may be axiomatized as1 

the reader may notice that an incomplete state with additional negative information has been specified  i.e.  the substate  may contain many more fluents  but no more at or 
tide fluents. the foundational axioms of the fluent calculus ensure that the composition function 	exhibits the properties of the union function for sets  with 	is the empty set   so that a state is identified with all the fluents that hold. on this basis  the macros holds 	and holds 	we defined as follows: 

   'in anticipation of the integration of continuous change  the argument t denotes the time when a fluent becomes true or an action takes place. 

figure 1: an example waterway scenario where the goal for the agent is to steer the barge from cell  1  to the harbor at cell  1 . there are three locks at cells  1    1    1 . 
in our waterway scenario there are two elementary actions: 
gobyship{d   the deliberative action of the agent to steer the barge to the next cell which lies in the direction d  and turntide  the natural action indicating the turn to the tide w at lock i. the fundamental frame problem is solved in the fluent calculus by a so-called state update axiom for each action  which describes the effects of the action in terms of the difference between the states before and after the execution of it. for example  the action turntide can be specified as 

where   -   and   +   are macros for fluent removal and addition; and the macro denoting in the fluent calculus that at time t action a is possible in state state s . 
　to reflect the incomplete knowledge of an agent about its environment  incomplete states are encoded in flux as open lists  that is  lists with a variable tail  of fluents  thielscher  1 . these lists are accompanied by constraints for negated state knowledge as well as for variable range restrictions. the constraints are of the form notholds    indicating that fluent does not hold in state and notholdsalll indicating that no instance of holds in z. in order to process these constraints  so-called declarative constraint handling rules  friihwirth  1  have been defined and proved correct under the foundational axioms of the fluent calculus  for details see  thielscher  1  . 
　for example  the initial state depicted in fig. 1 may be specified by this clause  init zo  :-
z1= at 1 1  tide lockl high 1  tide  lock1 high 1  tide lock1 high 1  
not holds all at         z   not holds all tide         z . 

which also reflects the negative information that no    fluent occurs in sub-state   the location of our agent is unique   and that there are no more tide fluents other than specified in state 
the predicate poss  realizes the precondition ax-
ioms for actions  that is  it defines under which conditions an action is possible at time t in state z. there is one such predicate clause for each action. conditioning in flux is based on the foundational predicates knows knowsnot  and knows val representing that the agent knows that fluent / holds  respectively  does not hold  in state and that there exist ground instances of the variables in such that fluent / is known to be true in state take  for example  the precondition axiom for the action turntide which is implemented as follows  
poss  turntide l w   t  z  	:-
 w=high  	knows val  l tr  tide l low tr  z   duration l low d ; 
 w=low/ knows val  l tr  tide l high tr  z   duration l high d    {t =:= tr + d}. 
where the auxiliary predicate duration denotes the duration of the corresponding tide at lock/. the execution time of the action will be constrained  using the syntax of the constraint handling library clp r  of the eclipseprolog system  to be the sum of the starting time of the old tide plus the duration of the old tide. 
　as in the fluent calculus  the effects of actions are encoded as state update axioms. for this purpose  the flux kernel provides a definition of the auxiliary predicate update its intuitive meaning is that state is the result of positive and negative effects and respectively  wrt. state in other words  the pred-
icate encodes the state equation 
on this basis  the agent programmer can easily implement the update axioms by clauses which define the predicate stateupdate as for example in the following encoding for the action turntide 
state update zl turntide l w  t z1  :holds tide l wo to  zl   w=high  update zl  tide l high t    
 tide l wo to   z1 ; 
w=low  update zl  tide l low t     tide l wo to   z1 . 
1 	the concurrent  continuous fluent calculus 
the fluent calculus for concurrent actions is based on the additional pre-defined sort concurrent  of which action is a sub-sort  thielscher  1a . single actions which are performed simultaneously are composed to terms of sort concurrent by a new binary function. the latter is denoted by     and written in infix notation. this function shares with the function combining fluents to states the properties of associativity  commutativity  idempotency and existence of a unit element. the constant  read: of sort concurrent acts as the unit element wrt. function  . . similar to the holds macro the abbreviation is used to denote that concurrent action c1 is included in concurrent action 
state update axioms for concurrent actions are recursive. they specify the effect of an action relative to the effect of arbitrary other  concurrent actions: 
i.e.  are the additional negative and positive  respectively  effects which occur if action a is performed besides c. here  can be a single action or a compound action which produces synergic effects  that is  effects which no single action would have if performed alone. using recursive state update axioms  the effect of  say  two simultaneous but independent actions can be inferred by first inferring the effect of one of them and  then  inferring the effect of the other action on the result of the first inference. the recursions stops with the base case of the empty action  which is defined as: 

two or more actions may interfere when executed concurrently  which is why the condition in the above state update axiom may restrict the applicability of the implication in view of concurrent action c. 
　integrating continuous change in the fluent calculus requires the introduction of process fluents which can represent arbitrarily complex  continuous processes. because such processes may be modeled by equations of motions  continuous time must be represented. to this end  the new sort real is added  which is to be interpreted as the real numbers 
 thielscher  1a . the sort is accompanied by the usual arithmetic operations along with their standard interpretation. the continuous fluent calculus includes the pre-defined fluent starttime where is of sort real  determining the time start at which a state arises  provided that starttime is unique: 

as already indicated throughout the paper  a parameter t of sort real is also used to denote the time at which a fluent arises as in or to represent the occurrence of an action as in a standard requirement for the possibility to perform a concurrent action c at time t in state may then be expressed as follows:1 

　the fluent calculus for continuous change includes the distinction between deliberative and natural actions  thielscher  1a . the latter are not subject to the free will of a planning agent. rather they happen automatically under specific circumstances. in our example domain  the 
　　　1 variables of the new sort concurrent are denoted by the letter c. 
　　　1in our example domain we have no actions that are in mutual conflict. therefore  we do not need to specify additional constraints in this precondition axiom. 
action of the turn of the tide is a natural one. the standard predicate natural   adopted from  reiter  1   declares the action a to be natural. to facilitate the formalization of the automatic evolution of natural actions  the continuous fluent calculus introduces two macros. the expression expectednatactions  shall indicate that in state ac-
tions c are all the natural actions that are expected to happen at time /: 
given the above notion  the macro nextnatactions stands for the concurrent action c being all natural actions that happen in state z at time t with t being the earliest possible time point at which natural actions are expected: 

the fluent calculus for continuous change uses the notion of a situation tree with trajectories  thielscher  1a  where a trajectory is associated with a situation and denotes the further evolution of the state determined by the natural actions that are expected to happen. we do not follow this approach in this paper  as the original motivation for employing trajectories has been domains with uncertainty about the occurrence of natural actions  and we do not consider such domains here. the incorporation of domains with uncertain natural actions is left for further work. instead  we include the natural actions in the situation terms  as with deliberative actions. 
1 integrating concurrency and continuous change into flux 
similar to the binary function which denotes the composition of states from single fluents and is represented in flux by a list of fluents  we represent the binary function     as a list of actions in flux. in this way  we introduce concurrency into flux  i.e.  all the actions in the list are performed concurrently. on this basis  the unit element of the function      the constant is encoded as the empty list . 
　given the notion of a list of concurrent actions  the state update axioms for the actions are defined recursively in flux. 
the predicate res  specifies the 
effect of performing at time t the list of concurrent actions li in state z  and situation si  and leading to the new state z% and the new situation do  after the execution of the concurrent actions. it represents one plan step and is encoded as follows 
res zl sl   t z1 s1  :holds starttime to   zl    update zl  starttime t    starttime to   z1 . 
res zl sl  a|l  t z1 do  a|l  t s1   :update*  a|l        a   l1    state update zl  a  t  z1    res z1   ll t z1   . 
where the clause for the base case of the recursion extends the effect of the constant  e   which by itself has none  to update the pre-defined fluent start1me t  needed for flux with continuous change to the new value t. similar to the encoding of the macros for fluent removal and addition  the predicate update is used in the clause for the recursive case to implement the elimination of one single action from a term of arbitrary other  concurrent actions. 
　consider  for example  the state update axiom of the single action gobyship d  which is implemented as: 
state update zl gobyship d   t z1  	: -
knows val  x y  at x y to  zl   holds starttime st  z1   {t  = st + 1}  adjacent x y d x1 yl   update zl  at xi yl t    at x y to   z1 . 
that is  the location of the barge together with the agent will be updated from the old position to the new cell where the auxiliary predicate adjacent computes the adjacent cell 
lying in direction d of cell the travel from one cell to another is assumed to take one hour in our example scenario. therefore  although the execution time t of this action is not fixed by the clause in any way  the effects of the action manifest at least one hour later as the formation of the old state. now take  e.g.  the flux query 
 -init z1   res z1 so  gobyship 1   turntide lock1 low   1 z1 s1 . together with the above definition of the state update axiom and the definitions for the predicate init  with the additional inclusion of fluent starttime  1   and the state update axiom of action turntide given in section 1. together with an appropriate encoding of the fact that a high tide lasts two hours at the third lock  duration  lock1   high  1   and the knowledge that going south is represented by direction number 1  our extension of flux can infer the effects of this concurrent action by first inferring the effects of action gobyship 1  and on the result of this inference infer the effects of action turntide  lock1  low . flux yields the correct substitution: 
z l =   a t   1   1   1 . 1     t i d e   l o c k l   h i g h   1 . 1     tide lock1 high 1  tide lock1 low 1   
starttime 1 |z  
sl=do  gobyship 1   turntide lock1 low   1 so  
　continuous time is  as already shown above and in section 1  easily integrated into flux. the eclipse-prolog system version 1  which we use  includes the constraint handling library clp r . this library allows for solving linear constraints with real numbers. its syntax requires for constraints to be included in braces. 
　the precondition axioms and state update axioms for natural actions are encoded in our extension of flux in the same fashion as for deliberative actions  see section 1 . additionally  we include an implementation for the predicate natural a  which is as follows for the example domain: 
:- a=turntide l w     l=lockl; l=lock1; l=lock1 . 
given this predicate  we model the macro expectednatactions by the built-in second order predicate setof as follows: 
setof a  	 natural a  poss a t z    c  
on this basis  the macro nextnatactionsi is defined in flux as: 

nextnattime t z  :natural  a    poss a t z   not  natural al   poss a1 t1 z   t1 t   !. 
nextnatactions c t z  :- nextnattime t z   setof a   natural a  poss a t z    c . 
　having defined natural actions in the same way as deliberative ones leads to the question: how to combine deliberative and natural actions into one common approach for planning  natural actions must occur at their predicted times. the times for the execution of deliberative actions are not fixed in advance. how to determine these execution times  the examination of every possible time would lead to a combinatorial explosion and is  in general  not possible for time of sort real. one general solution  which reduces the search space to a minimum and still yields answers for all possible domains  is to use qualitative instead of quantitative information. we only consider periods of time in our approach. there we discriminate three time intervals for a deliberative action wrt. the next expected natural action s : firstly  the deliberative action can be postponed to the next plan step and the  possible set of  natural action s  is executed. secondly  the deliberative action is performed before all natural actions which are expected next. finally  the deliberative action and the natural actions are joined toeether to a new concurrent action. the predicate exec  encodes the recursive planner for a plan with depth steps integrating deliberative and natural actions into one method. the computed plan leads from state z  and situation si to the new state z1 and the new situation s1. the predicate is implemented as exec zl sl zl sl 1 . 
exec zl si z1 s1 depth  :depth 1/ nextnatactions c t z   
 {1}  c1=c; action a   poss a ta zl   holds starttime to   z l     {ta =t1}   {ta t  t1=ta}  c1= a ; 
   {ta=t  t1=t}  append  a  c c1     res zl sl cl tl z1 s1   depthl is depth-1  exec z1 s1 z1 s1 depthl . 
where the predicate action a  defines the action a to be deliberative and the auxiliary built-in predicate append appends two list. for our example domain  the predicate action is encoded by the fact action  gobyship  to ensure that the time never goes backward  the execution time ta of the deliberative action is constrained in an appropriate way. 
　reasoning with time constraints instead of real time renders planning efficient. using this plan method we are left with only three choices regarding the execution time of a deliberative action. furthermore  the order of these choices  which represents a kind of heuristic  can be adjusted to the concrete domain at hand. only after a plan  where the constraint solution lies in the appropriate time intervals  has been computed  a concrete time for the execution of the actions is fixed and the actions are executed. 
　to complete our planning method  we include the following definition of the predicate goal z  denoting the goal state z  goal z  :- knows at 1    z . 
where the goal in our example scenario is that the barge is situated at the harbor in cell  1   see also fig. 1 . 
given the predicate goal  we define a recursive predicate 
ida representing the sequence of actions which leads from the initial state in the initial situation to the goal state in steps. this predicate implements the iterative deepening algorithm  which is optimal and complete  russell and norvig  1 . it is encoded as follows: ida z1 s1 z s n  :exec z1 s1 z s n   goal z  ; nl is n+l  findplan zo so z s nl . 
　the precondition axiom for the action gobyship is specified in the following way: 
poss gobyship d   t z  	: -
knows val  x y  at x y     z   directions x y dl   member d dl  adjacent  x  y d x1  yd   
 lockplace l xl yl   knows val  l w t1  tide l w to  z   
 w=high; w=low  duration l low td   {t =t1+td}  ; 
	not 	 lockplace l xl yl  . 
that is  after having determined the current location  the auxiliary predicate directions delivers a list of possible directions for the cell i and the standard predicate member selects one direction ri. afterwards  with the help of the auxiliary predicate lockplace denoting the occurrence of a lock / at cell the adjacent cell is searched for a lock. if there is none  the action is possible without further constraints for the execution time t. in the other case  the water level at the lock must be high or the action has to be executed after the disappearance of the low tide. specifying the preconditions for the actions gobyship and turntide as given above and in section 1  respectively  fulfills the general condition for the possibility to perform a concurrent action as given in section 1. 
　consider now  for example  all specified flux clauses together with suitably specified facts for the example domain and the following query: 
 -init zo   	ida z1 s1 z s l . 
our extended flux system then generates a plan with four steps and yields the following substitutions and linear constraints: 
z =  start ta 1  at 1 ta 1  tide lock1  high 1  tide lockl low 1    tide lock1 high 1 |   
s = do  gobyship 1    do  gobyship 1   turntide lockl low  turntide lock1 high    do  gobyship 1  turntide lock1 low    do  gobyship 1 j so ta l  1  1  ta 1  
linear constraints: ta 1 =1  ta 1.1 
ta 1 =1  ta 1.1 
the above sequence of actions s constitutes a solution to our planning problem given in fig. 1. it is not yet completely specified. rather  the execution times of some deliberative actions are given as time intervals. the reader may also notice that some deliberative actions are planned simultaneously together with natural actions. finally  we can apply the built-in predicate minimize t   which tries to find a minimal solution for a constraint variable t  to the above linear constraints and get the following: 

ta 1 = 1 . 1 	ta 1 	= 1 . 1 
1 	discussion 
we have presented an extension to flux for domains involving continuous change and where actions occur concurrently. our method is based on the theoretic solution in the fluent calculus  thielscher  1a . 
　our extension allows for the generation of plans including both  deliberative and natural actions. if necessary  the system generates and executes concurrent actions  i.e.  where two or more single actions are performed simultaneously. in order to plan efficiently  our flux program computes with time intervals instead of single time points using the paradigm of constraint logic programming. we have illustrated how this method can be successfully applied to example domains like the waterway scenario. additionally  our approach can easily be applied  with only minor modifications  to more complex domains involving  for example  compound concurrent actions which produce synergic effects. 
　other high-level programming languages for reasoning about action and change  like golog or the robot control language  have not yet an approach to integrate both  deliberative and natural actions in a common system to generate plans. the robot control language  shanahan and witkowski  1  does not have the notion of a natural action. the systems based on golog either accommodate only natural actions  reiter  1  or handle only deliberative actions  grosskreutz and lakemeyer  1  in domains involving concurrency and continuous change. 
　the extension to domains involving uncertainty about the occurrence of a natural action has not been tackled in this paper. an approach to this problem could be the use of conditional planning. conditional plans based on a generalized concept of plan skeletons as search heuristics have been incorporated into flux  thielscher  1b . to use conditional plans as a method to accommodate such domains is an important aspect of future work. 
acknowledgments 
i want to thank my supervisor michael thielscher  olaf 
perner and all members of the flux group at technische 
universitat dresden for many fruitful discussions about this work. three anonymous reviewers provided helpful comments on this article for which i am grateful. 
