 algorithm . each such strategy is a sche-
ma that can be as simple as this one  or as complex as we desire. more complex patterns typically i n clude additional levels of specification on the gates and enaolenients  providing more than one level of solution within the strategy itself. roughly speaking  the larger the strategy pattern i s   the more stereotyped a solution it represents  in that it provides a more thorough specification of the next several levels of the plan at once. smaller patterns contribute only the central causal idea and the gates and enablements  leaving the strategies for solving a l l subgoals up to the synthesizer. 
1. 	operation of the csa synthesizer 
　　in the csa system  the act of inserting a new strategy pattern in the synthesizer s database of strategies inherently also suggests to the system where to store the pattern and when to retrieve it as a relevant strategy for some goal. this organization occurs via the appropriate-when feature in the strategy's input description. 
   the appropriate-when conditions specify the circumstances under which it might be most appropriateto prefer this strategy over the possibly numerous other strategies available to the system for the sarae general goal. for example  the appropriatewhen conditions for the  send it by mail  strategy are different from the appropriateness conditions for the hand carry i t   stragegy  even though both strategies accomplish the same goal of causing a change in location of a small object. 
   the system uses the appropriate-when conditions to decide where in one of the system's discrimination networks to situate the strategy. there is one discrimination network for each goal predicate  e.g. loc  in the system. it is the purpose of a network  whenever a goal involving the net's predicate appears during plan synthesis  to select the most appropriate strategy in that particular instance. for this reason  we call these networks  causal selection networks   csn's . csn's are described in more detail in  rl . 
   the selection process is sensitive to the features of a l l known strategies which best differentiate those strategies according to their contextual relevance. the nodes of a csn therefore are intended to probe as much as necessary of the context of the goal whose solution is sought and its environment to make a  most appropriate  selection in that environment. in using a central csn structure for this selection process  rather than adopting a more distributed scheme in which strategies compete  e.g. as do planner theorems  sw1  or production rules  dk1    we are reflecting our very strong theoretical bias that intelligent  coordinated selection from among alternate strategies is one of the central issues of ai. 
   our system therefore consists of a potentially large number of csn's  each of which contains  at 

prob1em-solvln*-u: rierger 1 

i t s t e r m i n a l nodes  a set of s t r a t e g i e s . each strategy i s expressed v i a cause-effect patterns s i m i l a r to the one i l l u s t r a t e d above. 
　　in t h i s environment  the plan s y n t h e s i z e r ' s o v e r a l l behavior is as f o l l o w s . the i n i t i a l goal  there may be several concurrent goals  but we w i l l consider the simplest case where there is j u s t one  causes the relevant csn to be c a l l e d up and a p p l i e d . the csn poses queries to the databasedeductive component in order to select the most app r o p r i a t e s t r a t e g y   w i t h i n the l i m i t s o f i t s a v a i l able s t r a t e g i e s and a v a i l a b l e information about the context of the problem. once s e l e c t e d   the synthes i z e r creates as i t s subgoals any gating and enabling states  as s p e c i f i e d by the gates and enablements of the selected s t r a t e g y   which cannot be expected to be true at plan execution time. in t h i s manner  the synthesizer r e c u r s i v e l y attacks the i n i t i a l goal u n t i l no d e t a i l s remain or u n t i l a s p e c i f i e d l e v e l of d e t a i l  depth bound  is achieved. the paradigm is that of problem r e d u c t i o n   where the reduction operators are  possibly q u i t e complex  csa .strategy p a t t e r n s   and where a l t e r n a t e strategy s e l e c t i o n occurs 
  i n t e l l i g e n t l y   v i a the csn's. 
　　the most common source of subgoal v i o l a t i o n in t h i s environment seems to be   c o n t e x t u a l l y   bad orderings on the gating and enablement states in one or more subgoal s t r a t e g i e s . although it seems to be f e a s i b l e to learn and record good orderings  i n i t i a l l y   the synthesizer cannot be assumed to know anything about p o t e n t i a l ordering problems. by d e f i n i t i o n   t h e r e f o r e   in the absence of e x p l i c i t ordering i n f o r m a t i o n   the synttiesizer always a t tacks the gating and enablement conditions in the order they appear in the i n t e r n a l representation. s i m i l a r l y   for compound i n i t i a l goals  represented by anotner of our l i n k s     the components are a t tacked in the order s p e c i f i e d . 
　　we w i l l r e t u r n to the o v e r a l l synthesizer s t r a tegy l a t e r . we now t u r n to a d e s c r i p t i o n of the spontaneous computation component of the s y n t h e s i z e r   and describe how it r e l a t e s to the synthesizer strategy j u s t o u t l i n e d . 
1. 	spontaneous computation 
　　the spontaneous computation  sc  component of the csa system provides us w i t h a demon-like  assoc i a t i v e access mechanism. it is of use and i n t e r est in other phases of our project  especially as a model of c e r t a i n categories of inference in l a n guage comprehension . however  we focus here only on the aspects which r e l a t e to the synthesizer. 
　　the csa sc component is a generalized implement a t i o n of the notion of p a t t e r n - d i r e c t e d invocation in that it provides f o r more complex invocation patterns and f o r a more s o p h i s t i c a t e d h i e r a r c h i c a l o r g a n i z a t i o n of i n v o c a t i o n p a t t e r n s . a csa sc i n vocation   t r i g g e r   p a t t e r n is a c o l l e c t i o n of nested n-tuples composed v i a and  or  and any r e l a t i o n s to v i r t u a l l y any complexity. each nested nt u p l e is i d e n t i f i e d as  1  an associative component of the t r i g g e r p a t t e r n    z  a non-associative component of the t r i g g e r p a t t e r n   or  j  a  computab l e     an s-expression which must evaluate non-nil. a s s o c i a t i v e components are those that have the pot e n t i a l for t r i g g e r i n g the execution of the spontaneous computation. non-associative components are patterns that must be true   i . e . in the database or 
iieducible  in order f o r an sc to r u n . but which themselves have no p o t e n t i a l for i n i t i a l l y t r i g g e r ing the computation. we denote associative components by the symbol   +     non-associative components by the symbol   -     and computables by any other lisp p r e d i c a t e . 
　　in a system w i t h t h i s type of invocation p a t t e r n   an important issue is now to organize the a s s o c i a t i v e parts of t r i g g e r s so t h a t   given some s t i m u l u s   a l l   n i b b l e r s   i . e . t r i g g e r patterns which contain a component that matches the s t i m u l u s   can be accessed a l l at once. for t h i s purpose  we employ a c o n s t r u c t i o n c a l l e d a   t r i g g e r t r e e     and use the metaphor of   p l a n t i n g   a t r i g g e r p a t t e r n in a t r i g g e r t r e e . the i n t e r n a l s t r u c t u r e of t r i g g e r trees are i r r e l e v a n t to t h i s discussion  and are described in  r1 . we need only the term here  and that is because each t r i g g e r tree w i l l correspond to a population of sc's  namely the c o l l e c t i o n of sc's whose t r i g g e r p a t t e r n s ' associative components have been planted in the t r e e . 
　　to i l l u s t r a t e   suppose we wish to create an sc which reacts a s s o c i a l l v e i y whenever blockl comes to be located at l o c a t i o n a while block1 is located at l o c a t i o n b  ♀♀ whenever any block greater than 1 cm in height comes to be located at l o c a t i o n c. then we would define t h i s sc to our system as f o l l o w s : 
	  plant 	'  ok  and 	 log block1 a   
 log ul1ck1 b       
	 and 	 loc -x c    
	1 	 height -x -y   
 great erp -y 1    
 some body   some t r i g g e r tree   
this i l l u s t r a t e s a l l three types of t r i g g e r components   a s s o c i a t i v e   non-associative. and computable . the body is any eval-able lisp sexpression  and the t r i g g e r tree is the name of the t r i g g e r tree   e . g .  tti   in which we want the ass o c i a t i v e components of t h i s p a t t e r n p l a n t e d . the integers   a l l l ' s in t h i s case  in the p a t t e r n are used by the database-deductive component  and represent the energy budget  measured in database fetches  which can be expended in attempting to demonstrate that the associated component of the p a t t e r n is true a f t e r an i n i t i a l t r i g g e r i n g by some other component. atoms p r e f i x e d with hyphen signs denote v a r i a b l e s . variables are global to the ent i r e t r i g g e r p a t t e r n   i n that two v a r i a b l e s w i t h the same name must be c o n s i s t e n t l y bound to the same constant in a stimulus p a t t e r n  as in planner and conniver  ms 1   . 
　　associative access to a l l sc's which   n i b b l e   at a stimulus pattern is caused by a c a l l having e i t h e r of the f o l l o w i n g forms: 
　　　　 sactivate   t r i g e e r - t r e e    stimulus   or 	    t r i g g e r 	tree  	 stimulus   
  i . e . t r i g g e r trees can be used semantically as functions a l s o   . in e i t h e r case   stimulus  is a f u l l y constant nested n - t u p l e . 
　　a p p l i c a t i o n of a t r i g g e r tree in t h i s manner r e s u l t s in a queue of sc bodies which are ready to run. in the process of a c t i v a t i o n and the determi n a t i o n of which n i b b l e r s are a c t u a l l y ready to run  there is considerable i n t e r a c t i o n w i t h the database-deductive component in determining which patterns are f u l l y s a t i s f i e d  beyond the s u p e r f i c i a l associative t r i g g e r i n g   . lggi some other t h e o r e t i -
in r1r . 1 applications of this interaction are lcations 	of 	discussed 
　　trigger trees can then be regarded as populations of contextually related sc s to participate in a larger construct we c a l l a  channel '. it is the channel construct that gives us a f i n a l pattern directed invocation f a c i l i t y akin to planner and c1nniver  except that channels provide for more generality in the hierarchical control over populations of bc's. since we use channels only t r i v i a l l y in the plan synthesizer at present  we do not discuss them further here. interested readers are referred to . 
　　we now return to the main topic of the paper  f i r s t describing the subgoal annihilation detection strategy. 
1 subgoal 	violation 	detection 
　　as the synthesizer attacks and solves each subgoal in the manner described earlier  it protects that subgoal by planting one or more v i o l a t i o n patterns in a central synthesizer-related trigger tree. a violation pattern  conceptually  is any pattern which would be directly inimical to the pattern representing the subgoal which is being protected. for this reason  we c a l l protection patterns  guardian clusters.  it is the responsi b i l i t y of a guardian cluster  for the duration of i t s existence  to ensure the continuation of the state it protects  spontaneously f i r i n g when i n i m i cal patterns materialize. 
　　to i l l u s t r a t e   to protect the state  loc blockl a   we would plant a relatively simple pattern such as: 
 and  + 1  loc blockl -x    
 not-eual -x 'a   
i.e. a guardian that would react if the location of 

promem-solvtnfru: rie*er 
1 

blockl is ever predicated to be anywhere but location a  the protected state. 
   the planting of a guardian cluster occurs immediately upon the successful solution of the state the cluster is designed to protect.  i.e. a l l gating and enabling states . gating and enabling states which are found to exist already  and which therefore require no synthesis  are also protected as though they had been solved by the synthesizer. 
   the point of guarding each subgoal as it is solved is to ensure that at the end of a l l the gate and enablement solutions  a l l subgoals w i l l s t i l l be in effect so that  a  the action of the csa schema can be performed  actually  added to the output action stream  in the presence of a l l its enablements  and  b  performance of the action w i l l achieve the intended result in the presence of all its gates. therefore  guardian sc s are destroyed  actually  masked  after the synthesizer finally generates the action. semantically  since the action has been performed  the protected states are no longer needed for the time being. 
　　there are some interesting theoretical questions aboutwhat  exactly  constitutes a guardian cluster of sc's for any given state. in its simplest form  we conceptualize the guard to trigger on  the negation  of the guarded state. however  things are. seldom so simple that planting just the syntactic negation of the pattern w i l l be'adequate. 
   we do not yet have what we would call a general theory of guardian cluster generation. however  we expect the semantics of the predicate in the protected state can provide the synthesizer with direction in constructing the guardian cluster. for example  for those predicates which are uni-valued  but which have a continuous range  such as luc   we plant a pattern of the form shown earlier  namely: 
protect  log x y  	   and  + 1  log x z   
 not-cqual z y   
for predicates which are either true or false  we plant a pattern involving the predicate which is the opposite of the protected state's predicate  e.g. to protect the state  free  hand    we plant: protect  free -il     + 1  grasping -il   
guardian clusters vs. inference 
　　it is d i f f i c u l t at this time to assess the range of problems involved in planting good guardian clusters. however  one requirement is assured: we must rely heavily on a good inference system which generates a moderately rich set of inferences from each event arising during synthesis  i.e. meaning paraphrases  implications  and so forth. our bias is to keep the guardian cluster f a i r l y concise  relying on inference to hit this violation target in a shotgun fashion.** 
** we feel that studying the processes of subgoal annihilation detection w i l l shed some light on the interesting question of how problem solving and inference interact. as an example of problem solver - inference interaction  reconsider the midnight snack example. there  the two goals are  1  have clean hands  and  1  get the greasy leftovers  gl  into the trash can. now  the essence of the model concept that represents the greasy leftovers is sc-like i t s e l f ; namely  it represents an object  one of whose features is: whenever this object is touched  i.e. whenever an assertion matching  grasping -h gl  is made   the grasping object w i l l become greasy. this is an inference which  plays the role of an  active  component in the object's def i n i t i o n  similar to an  imp  in winograd's terminology  w1j  . 
	ii our synthesizer were to synthesize 	and 	pro-
tect the plan for clean hands f i r s t   one state that would be directly asserted at some point during the 
 throwing away  subgoal  the second one  would be  grasping liani  gl   where gl is the model concept ior the leftovers. this grasping state  being a component of the trigger pattern for this active feature of gl  would cause the inference  greasy hand  to be generated. that in turn would set off the guardian cluster for the clean hands state  assuming of course that this cluster were s u f f i ciently rich to include  greasy hand  as a component. this could be arranged  for instance  by including a relatively exhaustive definition of the state  clean hands   namely  an enumeration of a l l closely-related inimical states  dirty  greasy  etc.  alternatively  some of these problems might be avoided if we were to break a l l these concepts down into further primitives  and arrange to trigger on the more primitive symbols rather than the higher level ones. in any event  the point is that without this inference that connects a grasping of something greasy to the resulting greasiness of the grasper  the grasping state asserted during the solution of one of the subgoals would not trigger the guardian cluster. however  with such an inference  the guardian cluster is hit. thus  details aside  we get a glimpse of how inference can interact with plan synthesis. 
   to summarize  there are two issues relating to spontaneous subgoal guardians:  1  how to express the guardian cluster  and  1  how much responsibility to delegate to the guardian vs. how much to place on a more general inference f a c i l i t y . 
1. 	unravelling 
   the protection paradigm described above suggested itself relatively soon after the development of the sc component of the csa system. we then puzzled for a while about what should actually happen at subgoal violation time. our criteria were twofold:  1  that violations be detected at the earliest possible phase of synthesis  and  1  that as much as possible of the plan up to the violation point be salvaged. 
   the f i r s t criterion seems to be solved by the sc detection paradigm. the general motivation for early detection is that  during the earlier phases  there is more fundamental knowledge about the how s and why's of the plan's construction. this makes possible both more accurate diagnosis of violations and more accurate analysis of the implications of plan rearrangement. the second criterion of maximum plan salvage has more practical motivations  but also coincides with our intuition that human problem solving involves considerable salvaging and stitching together of plans. 
　　since the source of conflicts we are primarily considering is bad orderings  the repair of a conf l i c t w i l l amount to reordering parts of the plan in a way that avoids the conflict. the simplest and most obvious strategy would be simply to start over tfith a new order  possibly resynthesizing many gate and enablement suboals. this is not a good approach  because it is inherently combinatorial  and because it duplicates el fort* it would be more desirable to have a give-and-take arrangement wherein conflicts can be resolved by having one subgoal back off for a moment to allow the other subgoal to complete  then having the retreated subgoal simply rejoin without having to resyntheslze. 
   uur theory oi correction follows these ideals. we call the technique that implements this giveand-take strategy  unravelling . the unravelling scenario goes as follows  see figure below . suppose gating state a has been achieved as a subgoal  and has been protected. suppose that during the synthesis of another brother subgoal b  e.g. a brother gate   a's guardian cluster is triggered  indicating that some state lust achieved in the partially completed synthesis oi b has violated state a. the plan which leads up to a then unravels one level by reverting to the context which existed immediately prior to the attainment of a  i . e .   the unravelling mechanism undoes the action which causes a. it then removes a  alleviating the immediate violation  and notes that it w i l l have to reconstruct this last step in the plan leading up to a. 
problem-solving-1: rieger 
1    as a is unravelled  the gates on a's causal link and the enablements of a's causing action  once protected themselves during the earlier part of the synthesis  are re-protected by reawakening their guardian clusters. these gates and their clusters are then melded into the current context  i.e. that in which b is being synthesized . then b is a l lowed to proceed. when b completes  a rejoins  n.b. a does not resyntheslze  but rather simply closes in  around  the plan for b  which now has conceptually been spliced in  by reissuing the action which achieves state a. a's gates and enablements are then once again unprotected  and a itself is again protected. at that point  both a and b w i l l coexist  permitting the syntliesizer to get on with the next gate or enablement  or  in case a l l have been completed  issue the action at the level awaiting such a completion. 
   the semantics of this unravelling-rejoining are this: ordinarily   brother subgoals do not have to know of each other s existence. however  when one does something which is inimical to the other  they must at that point become aware of each other. by unravelline the f i r s t one a single level  we alleviate the immediate problem  but at that point also force pieces of the two goals  actually  the plans leading up to them  to coexist in the same context. 
this is because  the process of unravelling a casts a s gates and enablements into the population of currently guarded states. 
　　unravelling is tree to occur wherever and whenever it is needed to permit the current subgoal to proceed. this means that one unravelling can set off other unravellings  e.g.  that subgoal b might cause more than one unravelling inside of a's plan after being allowed to proceed past the f i r s t conf l i c t   that the melding; of a's prior context  i.e. its gating and enabling states  into the existing context could in turn trigger an unravelling of part of b's plan  and so forth. all problems arise because of now having to force two brothers  or  in the l i m i t   distant cousins  which previously knew nothing of each other to live in the same environment. 
　　this give and take paradigm i s   we feel  the best possible conflict resolution paradigm. at one end of the spectrum  unravelling amounts to one simple backoff  while at the other end of the spectrum  it can amount to multiple backoffs which in the limit amount to a complete reversal of all subgoals  i.e. each later one comes to be spliced in before former ones . the important point  and the feature that we feel gives this approach elegance  is that only the unravellings that have to be done are actually done. there is no wholesale reordering of subgoals  and  conceptually  l i t t l e overhead for conflict-free plans. 
1. 	example 
　　we now illustrate the theory via a simple blocks world example which conveys some of the subtleties of the unravelling process. starting with an i n i t i a l configuration as shown in figure 1 a   we pick up the. action as it stands in figure 1 b   solving the goal  un a b . the synthesizer has been able to construct a standard synthesis without any protection violations up to this point and is about to attack the. subgoal  free-hand  - state s l l . first let us remark that there are two csa links  shown to the right  in this graph that have not 
been previously mentioned in this paper. they 1 are the  state-coupling link  and the  gated one-shot byproduct  link.  see  r1    h1  and  rg1  for a complete coverage of the csa links.  the state-coupling link connects two states and implies that the state at its head can be considered to be true because of the truth of the state at its t a i l . the gated byproduct link is identical in syntax and semantics to the gated causality link. however  the intent of the causality link distinguishes it from tne dyproduct link  in that the state caused by the action on a byproduct link is not the state intended by the performance of the action  but merely a byproduct. thus  the fate of a dyproduct state is irrelevant to plan synthesis and it need not be protected. but a byproduct state can cause a violation as decisively as any other state. therefore  byproduct states must be treated as other achieved states with respect to violation detection. 
　　in attempting to solve the goal  on a b   the synthesizer has set up subgoals  grasping a    loc hand b   and  cleartop b .  grasping a  has been solved  its subgoals s1  s1  and s1 were already true in the i n i t i a l configuration  by performing the action  grasp a . similarly  the second suboal t s1  has been solved by per-
formmg action a1.  s1 had no subcoals . to this point  the 

synthesizer has proposed an action sequence  a1 a1 . 
	'-  	denotes: 	unprotected 
    denotes: protected 
numbers in nodes denote sequence of actions 
b.l. 	context requirements 
   when an unravelling occurs  previously protected states come to be unmasked and reprotected. the de-
mand on the context mechanism therefore is that it be able to revert to the context immediately prior to the f i r s t masking of those subgoals. as the re-
protection occurs and the prior context is exhumed  items from that context are melded into the existing context. this process can itself trigger 
other 	subgoal 	violations 	pending 	in the current 
context. although any given example can grow to be quite complex in its unravelling behavior  unravel-synthesizer . s1 is true in the i n i t i a l configuration and nothing 
lias negated i t . now the synthesizer attempts to solve s l l   
 free-hand . the currently protected states s1  sb  s1  and sio are marked with ' + ' in figure 1 b . since sll is a violation of the protected state s1  let us describe the steps taken by the synthesizer to complete this plan. 
- the action  a1  which causes the violated 	state 
 s1  is unravelled. this leaves a new action sequence  a1 . the context in which s1 s subgoals 
were 	protected 	is 	exhumed and melded in with the current context  yielding a set of protected states s1 sa s1 s1 s1 s1. 	an item  s1.a1  is pushed onto an  unravel stack . 
- a test for secondary violations is made   i . e . 	a    the last subgoal to be solved is  cleartop b   s1. the action aa can only achieve this goal after the subgoals s1  s1  and sll have been solved. s1 is true because s1 is true and this fact is explicitly denoted by a state coupling link  built by the 
test to determine whether any of the currently active states  s1 s1 s1  violate any of the newly reprotected states  s1 s1 s1  . this is done in the order of the most recently solved state f i r s t 
 i.e. sio  then s1  then s1 . the violation of s1 violating s1 is detected  s1 is unravelled  and its entry is pushed onto the unravel stack. the unravel stack now looks like:  s1.nil   s1.a1 . the action entry for s1 is nil because there is no action to be unravelled for s1. this nil entry w i l l signify that the synthesizer must construct a plan tor s1 at the time s1 is rejoined.  the reason for this new synthesis is that s1 is no longer true - that is why it was violated!  
- no more secondary violations 	are 	detected 	and sll 	can 	now be protected. 	since a l l the subgoals 
p r o b l e m - s o l v r - 1 : b i e g e r 
1 

- the entry f o r s1 is popped o f f the unravel stack and the synthesizer is again c a l l e d r e c u r s i v e l y 	to generate 	a 	new 	s o l u t i o n 	f o r  loc hand b . 	this process does 	not 	cause 	any 	f u r t h e r 	v i o l a t i o n s . figure 1 displays the new p l a n ; a1 is threaded onto the 	a c t i o n 	sequence  	y i e l d i n g 	 a1 a1 a1 a1 a1 .  loc hand b  is again protected and the synthesizer returns to the l e v e l that was s o l v i n g s1. 
- s1 is r e p r o t e c t e d   leaving the set of states s1 s1 sb s1 p r o t e c t e d . the synthesizer e x i t s from t h i s recursive c a l l   r e t u r n i n g t o the l e v e l that 
	was working on s1  remember  . 	it was at t h i s l e v -
el that s1 v i o l a t e d s1. 
　　　　 a  	figure 1. 	 b  for s1 are now 	solved  	these 	subgoals' 	guardian clusters can be hidden  by popping contexts   leaving 	only states s1 s1 sb protected. 	the action a1 is 	appended 	to 	the 	action 	sequence  	yielding  a1 a1 . 	a 	test must now be raade to see if s1 or ti e byproduct state s1 cause a violation of any 	of the currently protected states. 
- it is detected that s1 violates s1. s1 is unravelled  yielding an unravel stack:  s1.n1l    s1.nil   s1.a1 . no secondary violations need be considered since secondary violations are caused only by the reactivation of hidden guardian clusters. s1 has no subgoals and  thus  no guardian clusters are reactivated. the action sequence remains  a1.a1 . the currently protected states 
are s1 so s/. 
- since subgoals of s1 caused violations  the top entry on the unravel stack   s1.nil   is popped. if the action slot it is time to start rejoining  on the unravel stack entry is not nil  the action is threaded onto the action sequence and the violated state is reprotected. in this case  the action slot is nil  so that there is no action to be threaded. thus  the synthesizer is called recur-
sively to generate a solution to the goal s1. of course  there is the possibility of a new protection violation  which is exactly what happens in this case. the plan generated by the synthesizer 
as a solution to  free-hand   s1  involves state s1 and actions a 1 and a1 as seen in figure 1. a1 is threaded onto the action sequence  a1 a1 a1   but when a test is made to determine if s1 causes any violations  the contradiction between  luc hand free-space  and  loc hand b  is detected. since s1 was protected  a violation occurs. 
- as in this case  when a violated goal is statecoupled .to another  special care must be taken in unravelling. it should be recalled that the reason for the coupling is to denote the fact that  for example  s1 is true only because sb is true. thus  if we were to unravel s1 by splicing a1 out of the action sequence  then s1 would not have been true 
when we thought it was. the solution is to break the causal link between the unravelled action  a1  and the unravelled state  s1   and construct a causal link between the action and the coupled state  sv . this transformation is depicted below. state sb is l e f t without a causing action as its entry is pushed onto the unravel stack: 
 s1.n1l . s1.nil   s1.a1 . the protected states are 
- the synthesis for s1 now continues with a1 being threaded onto the action sequence:  a1 a1 a1  a1 . the guardian for  loc hand free-space  is hidden and sb can be rejoined. 
prnmem-sol vln -**: r!e*er 
k  1 

l u s t r a t e subgoal infringement in our everyday domain  consider the b a t t l e of the trousers scenario: ;iost of us know that it is easier to put long pants on before shoes! s t r i c t l y speaking  n u t t i n g the shoes on f i r s t does not v i o l a t e the gating c o n d i t i o n f o r p u l l i n g the pants on:  path is unobstructed . however  it c e r t a i n l y increases the cost of the subsequent operation. somehow  the. synthesizer must have access to nominal e f f o r t s r e quired for s t r a t e g i e s   be able to h a l t synthesis whenever the nominal e f f o r t f o r some strategy seems to have been s e r i o u s l y exceeded  then i d e n t i f y and unravel the c u l p r i t . we consider subgoal i n f r i n g e ment to be an open t o p i c . 
b. 	other a p p l i c a t i o n s 
　　the a s s o c i a t i v e detection aspect of our design is a p p l i c a b l e to c e r t a i n forms of plan o p t i m i z a t i o n as w e l l as subgoal v i o l a t i o n d e t e c t i o n . one i n t e r e s t i n g form concerns a process we c a l l  object  adoption . this is the process wherein the synthes i z e r commits i t s e l f to p a r t i c u l a r o b j e c t s   times  l o c a t i o n s   etc. in the i n s t a n t i a t i o n of a plan in the concrete terms required f o r a c t u a l execution. 
　　one instance of object adoption that provides an i n t e r e s t i n g example of sc-based plan o p t i m i z a t i o n is that of free area s e l e c t i o n . consider the blocks problem i l l u s t r a t e d below. a computer-wise mundane s o l u t i o n is to place b on the t a b l e   place a on b  attempt to place b on c  by c l e a r i n g b's top  generating a subgoal v i o l a t i o n   and proceeding as described above. the plan eventually gets b u i l t   dut contains a superfluous intermediate l o c a t i o n f o r b  namely the t a b l e . c l e a r l y   the simpler s o l u t i o n would have been to place b d i r e c t l y on c in the f i r s t operation of c l e a r i n g a's top  then p l a c -
ing a on b. 	     

　　the problem here could have been avoided had the synthesizer been w i l l i n g to leave b's l o c a t i o n 
  f l o a t i n g   a f t e r c l e a r i n g a's top in the f i r s t step   i . e .   to defer the obiect adoption . in our system  t h i s can be accomplished by d e s c r i b i n g some features of b's l o c a t i o n   together w i t h a default recommendation  v i a a csa d e s c r i p t o r : 
 *d* x   class x area  
	 xysize 	x  the xy-size of the block    
            rec  part-of x table    and by delegating r e s p o n s i b i l i t y to t h i s d e s c r i p t o r ror eventually ensuring that i t binds i t s e l f t o some concrete object  a l o c a t i o n in t h i s case  before the end of the synthesis. this r e s p o n s i b i l i t y is phrased by associating with the d e s c r i p t o r an sc wnich w i l l react to patterns  on b - x     since the d e s c r i p t o r is w i l l i n g to commit i t s e l f to any -x. 
　　now  each time the synthesizer is about to undertake the synthesis or a subgoal  it f i r s t shouts at t h i s population of   c o n c r e t i z a t i o n   sc's  in essence asking whether there are any f l o a t i n g r e f e r ences which would make short s h r i f t of the subgoal  i . e . obviate a standard synthesis. in t h i s example  the synthesizer eventually shouts  on b c  before undertaking it as a subgoal. this shout exc i t e s our f l o a t i n g c o n c r e t i z a t i o n sc  it responds a f f i r m a t i v e l y   committing i t s e l f at that p o i n t to c  since the tops of blocks are l e g i t i m a t e areas a l s o     and  v o i i a !   the synthesizer is spared the synthesis ! 
　　there are some other i n t e r e s t i n g forms of subgoal o p t i m i z a t i o n in t h i s f a s h i o n . a f u t u r e report w i l l t r e a t them i n more d e t a i l . 
1. 	discussion and conclusions 
　　we have presented a general theory of d e t e c t i o n and c o r r e c t i o n f o r subgoal a n n i h i l a t i o n problems which stem from bad orderings. the theory i s   we f e e l   e f f i c i e n t   u n i f o r m   and general. i t i s e f f i cient in the sense that it does only the minimum amount of work necessary to ameliorate a n n i h i l a t i o n s   and does not incur resvnthesis. it is uniform in the sense that it is a theory of cont r o l that w i l l f u n c t i o n with any s u i t a b l y formatted problem s o l v i n g representation   i n our case  csa cause-effect schemata . it is general in the sense that it does not r e l y on any s o r t of domains p e c i f i c knowledge  w i t h the possible exception of having to know the semantics of the system s p r e d i cates when p l a n t i n g appropriate guardian c l u s t e r s . 
　　there are many complex issues of subgoal a n n i h i l a t i o n that remain to be explored. one problem w i t h any performance system such as ours is that it o f t en has a myopic view of what it is doing. there seems to be a need f o r  meta  watchers  sc s  whose r e s p o n s i b i l i t y i t i s t o watch the o v e r a l l d e t e c t i o n - u n r a v a l l i n g process f o r r e c u r r i n g patterns of a c t i v i t y . since our scheme is a form of r e l a x a t i o n   such an overseer would presumably i n tervene when it perceived the u n r a v e l l i n g to be looping   i . e . t r y i n g to solve an i n s o l u b l e ordering problem   and so f o r t h . 
　　other i n t e r e s t i n g problems have to do w i t h bad strategy s e l e c t i o n   as opposed to bad o r d e r i n g . we have steered clear of t h i s topic in t h i s phase of our research  p r i m a r i l y because switching s t r a t e gies in mid-stream seems to c a l l for more r a d i c a l reconsideration of the. t o t a l plan  possibly leading to p a r t i a l or complete resynthesis. we do not p r o pose to leave t h i s problem at r e s t   only to s i d e step it temporarily. in s h o r t   we w i l l be working on our synthesizer for quite some time to come. 
acknowledgments 
　　we wish to thank the other members of the .laryland csa group   m i l t grinberg  mache creeger  john boose  and georgy fekete  i o r t h e i r p a r t i c i p a t i o n in numerous discussions and for t h e i r suggestions. we wish also to thank nasa for the support of t h i s research under grant nsg-1. 
davis  k. and j. king  an overview of production systems  stanford aim 1  1b. ernst  g. . and newell  a.  gps: a case study in generality and problem s o l v i n g   academic 
	press  	1 
	mcdermott  drew v. 	and 	g.j. 	suss man  	the 
c1nn1ver reference manual. mit al memo 1a  jan. 1. 
n i l s s o n   n i l s j .   problem solving methods in 
	a r t i f i c i a l i n t e l l i g e n c e * 	mcgraw-hill  	1tt 
	kieger  	c  	an organization of knowledge for 
problem solving and language comprehension  a r t i f i c i a l i n t e l l i g e n c e   v o l . 1  no. 1  
1. 
rieger  c  the representation and selection of commonsense knowledge f o r natural language comprehension  proc. georgetown u n i v e r s i t y l i n g u i s t i c s roundtable  1. rieger  c.  spontaneous computation in 
	cognitive 	models  	to 	appear 	in cognitive 
science. 
	rieger  	c  	and 	grinberg  	m.   	the 
	declarative 	representation 	and 	procedural 
	simulation 	of 	causality 	in 	physical 
	mechanisms  	proc. 	u c a l - 1   	mit  	august 
1. 
s a c e r d o t i   e a r l   the nonlinear nature of plans  proc. 1ijcai  t b i l i s i   ussr  sept. 
1. 
sussman  gerald j.   a computer model of skill acquisition. mit ai-tr 1  aug. 
1. 
	sussman  gerald 	jay 	and 	terry 	winograd.  
	micro-planner reference manual. 	mit al memo 
	1  j u l y   	1. 
tate  a.  i n t e r a c t i n g goals and t h e i r use  proc. 1jcai. t b i l i s i   ussr  sept. 1. 
	waldinger  richard  achieving several 	goals 
	simultaneously  	sri 	tech. 	note 1  j u l y   
1. 
winograd  t e r r y   frame representations and the procedural-declarative controversy  in representation and understanding  d.g. bobrow and a. cotttns  ed. academic press  
1. 

p r o b l m s - s o l v i n g : 	rieger 
1 
