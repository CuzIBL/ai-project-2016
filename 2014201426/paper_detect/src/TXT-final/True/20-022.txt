 
　natural language grammars with large coverage are typically the result of many person-years of effort  working with clumsy formalisms and sub-optimal software support for grammar development. this paper describes our approach to the task of writing a substantial grammar  as part of a collaboration to produce a general purpose morphological and syntactic analyser for english. the grammatical formalism we have developed for the task is a metagrammatical notation which is a more expressive and computationally tractable variant of generalized phrase structure grammar. we have also implemented a software system which provides a highly integrated and very powerful set of tools for developing and managing a large grammar based on this notation. the system provides a grammarian with an environment which we have found to be essential for rapid but successful production of a substantial grammar. 
i introduction 
as part of the alvey programme  the uk research initiative in 
information 	technology  	three 	collaborating 	projects 	 at 
cambridge  lancaster and edinburgh universities  have been set up to produce a general purpose morphological and syntactic analyser for english. one project is developing an integrated morphological analyser and lexicon package  russell et al. 1 . the grammar project  which is the focus of this paper  has developed a metagrammatical notation and implemented an associated software system to facilitate the writing of a substantial grammar of english. the third project has implemented a chart parser augmented with unification  phillips and thompson 1   which analyses sentences of english morphosyntactically using the rule systems and lexicon developed by the other projects. 
   in this paper  we first discuss the metagrammatical notation in which the grammar  grover ct al. forthcoming  is being written and then describe the associated grammar development environment  carroll et al. 1  which provides the grammarian with software tools to facilitate the rapid development of a large but consistent and tractable grammar. the metagrammatical notation is a development of generalized phrase structure grammar  gpsg   gazdar et al. 1  but is designed to be both more expressively powerful and more computationally tractable. the grammar development environment is modelled on similar systems  e.g. evans 1  karttunen 1   but goes beyond them in terms of speed  efficiency  and the provision of a genuinely integrated lexical  morphological and syntactic development environment. 
bran boguraev  john carroll 
computer laboratory  university of cambridge  
com exchange street  cambridge cb1qg  england 
ii the metagrammatical notation 
the metagrammatical notation we have designed is based on 
gpsg  but has been modified and extended to be more flexible and expressive and is interpreted somewhat differently. the first motivation for these changes is to define a notation which provides a specialised programming language for specifying grammatical theories and grammars for particular languages  rather than defining a specific theory directly. this approach both ensures that developments in syntactic theory will be less likely to render the grammar development environment obsolete and also provides the grammarian with an expressively flexible and powerful notation for grammar writing  rather than a formalism embodying a restrictive theory. 
　the second motivation for reinterpreting and modifying the rule types of gpsg is to provide a procedural and strictly ordered interpretation of the various rule types. in gpsg  rules are defined declaratively as applying simultaneously in the projection from immediate dominance  id  rules to local trees. as shieber  1   ristad  1  and others have pointed out this leads to a computationally complex and conceptually difficult system. the approach taken here is broadly that used by popowich  1  for definite clause grammars  pereira and warren 1   and that outlined  although not implemented  by shieber  1  for gpsg  metagrammatical rules are expanded into an 'object' grammar which is a unification grammar. the interpretation of the metagrammatical rules is provided by the procedure for their expansion and the much simpler semantics of the resulting object grammar. furthermore  because no attempt is made to expand out into a pure context-free formalism  the object grammar remains manageable. 
　the object grammar consists of a set of phrase structure rules whose categories are feature complexes  and which form the input to the parser. an example of an expanded rule of the object grammar for forming a variety of english clauses is given in figure 1. features consist of feature name / feature value pairs. 
feature values can be variables  the values beginning with 1 in the figure   which can be bound within the rule. parsing with the object grammar involves matching categories by unifying their feature sets. unlike gpsg  our metagrammar defines a set of partially instantiated phrase-structure rules and not a set of local trees sufficiently instantiated to define a portion of syntactic structure. however like gpsg  the metagrammar is designed to capture linguistic generalisations; for this reason  and also to simplify and abbreviate the statement of 'object' rules  such as the one in the figure  it contains statements of the following eleven kinds: 

 n -  v +  bar 1  subj +  -   n +  v -  bar 1  poss -   n -  v +  bar 1  subj -  wh 1   inv 1  neg 1  agr 1 wh 1   case nom  pro 1  h +  inv  1  neg  1  agr  1  
vform 1  aux 1  fin  1  comp norm  	agr 1  	vform 1  aux 1  fin  1  
figure 1. an object grammar rule. 
	briscoe  grover  boguraev  and carroll 	1 
a. feature declarations 	g. linear precedence rules 

   feature declarations define the feature system used by the grammar. they encode the possible values of a given feature. the feature system is very similar to that used in gpsg  but a feature can additionally take a variable value which ranges over the set of actual values as declared. 
	vform 	slash cat 
b. feature set declarations 
   feature set declarations define sets of features which propagate in the same manner and which will appear together on particular categories. for example  relevant features to propagate between nps and head noun daughters  plu  per  etc.  may be grouped together in a set called nominalhead  and the name of this set used later in the rules which perform this type of propagation to refer to the whole collection of features. 
nominalhead 
c. alias declarations 
   aliases are a convenient abbreviatory device for naming categories and feature complexes in rules. they do not affect the expressive power of the formalism. 
		nom 
d. category declarations 
   category declarations define a particular category as consisting of a given set of features. these declarations are used to expand out the partially specified categories which typically appear in id rules. they also make the system more explicit by obliging the grammarian to state which categories a feature will appear oa category declarations replace part of the function of feature cooccurrence restrictions in gpsg. 
nominal: 
e. extension declaration 
   some features  such as slash  are not part of the 'basic' make up of a category and in this system tend to be added to categories in id rules by the application of metarules. features which appear in categories only by virtue of metarule application must be defined as extension features; doing this again makes the system more explicit. 
extension 
f. immediate dominance rules 
   id rules encode permissible dominance relations in phrase structure trees. the immediate dominance properties of the 'object' rule in figure 1 can be expressed by the clauses rule below; however other properties of the object rule  e.g. the ordering of the categories in it  are determined by other types of rules in the grammar. transitives below is another example of an id rule. it states that a transitive vp will contain a lexical head  which must be subcategorised as transitive  and a np sister. 
clauses: 
transitives: 
1 	natural language 
   linear precedence  lp  rules encode permissible precedence relations in id rules. the first rule below states that nps always precede vps in english ps rules which contain both categories on the right-hand side. the second states that categories bearing the subcat feature  i.e. lexical categories  precede those having no such specification. 
		 subcat  
h. phrase-structure rules 
   ps rules encode both permissable dominance and precedence relations in phrase markers. they are included in the formalism so that the expressive power of the system is not restricted by the ecpo property*  gazdar et al. 1 . our current grammar makes no direct use of this rule type but the grammarian can at any point choose to abandon the id/lp format and use a mixed system  entering directly a few 'marked' ps rules  distinguished from id rules by their lack of commas  which do not conform to the general lp rules for english. 

i. feature propagation rules 
　feature propagation rules define how features propagate between mother and daughter categories in id or ps rules  if either mother or daughter has a variable value for one of these features . the effect of propagation rules is to bind variables or instantiate values of features in rules of the 'object' grammar. propagation rules can be used to encode particular feature propagation principles  such as the various versions of the head feature convention proposed for gpsg. however  such principles are not 'hard-wired' into the formalism  so that maximum flexibility and expressiveness is maintained. propagation rules are stated in terms of id or ps rule patterns which may contain variables over categories  w ; for example  the following rule states that nps inherit features from the head  noun  daughter in any id rule which is nominal  contains a head and which may optionally contain other daughters of any type. 
nominal: 
j. feature default rules 
　feature default rules default specified values onto features with no value in categories in a particular environment in an id or ps rule. these default rules replace feature specification defaults in gpsg; because the rules assign values to features in the context of an id or ps rule  their application can be accurately controlled  and thus the need for feature cooccurrence restrictions to prevent the construction of 'illegal' categories is diminished. both feature default rules and feature propagation rules have a similar syntax to kilbury's  1  independently motivated category cooccurrence restrictions  although their function is somewhat different the accusative default below states that an np which is a sister to a verbal or prepositional lexical head will be accusative  if unspecified for any other case value . 
	accusative: 	 -n  -  h  np. case 1  - acc. 
* a grammar has the exhaustive constant partial ordering property if the set of expansions  defined by id rules  of any one category observes a partial ordering that is also observed by the expansions of all the other categories. 
k. metarules 
　metarules encode systematic relationships between sets of id or ps rules and automatically add further rules to the basic set produced by the grammar writer and the application of other metarules. metarules can be written to apply to id rules or ps rules  including those which result from linearisation of id rules . metarules can also be restricted to apply to id or ps rules containing a lexical head through use of the w category variable  as opposed to the u 'unrestricted' category variable  in the input pattern. for example  passive adds a new vp rule without the np direct object  and with an optional 'by' phrase  for every basic vp rule with a lexical head and a non-predicative np daughter. slash creates new id rules with a slash feature appearing on one of the non-head daughters with a variable value which is bound to the slash feature of the mother. 

iii metagrammar interpretation 
   in gpsg  the set of legal local trees is defined declaratively by simultaneous application of the various rule types during the 'projection' from id rules to fully instantiated local trees. in this system  although the metagrammatical notation shares many similarities with gpsg  there are crucial differences in the interpretation of the notation. the rules of the metagrammar jointly specify a set of partially instantiated phrase structure rules  rather than fully instantiated local trees. that is  rules are allowed to contain variable values for features and these variables arc instantiated at parse time by unification. propagation rules specify restrictions on the instantiation of these variables; for example  the rule 

will force agreement between the determiner and nominal phrase in the id rule for nps which introduces determiners and nominal phrases  by binding the plu variables on all the categories. if we assume that whereas *a' is specified as  'the' is 
unspecified for a value of plu  then the result of matching 'the' to the det category in the expanded id rule will not instantiate 
 however  matching 'boys' to nl will instantiate all the instances of  1 to  therefore  'a boys' will not be accepted by the expanded id rule because  1 cannot both be instantiated as and 
　the object grammar is produced by applying category  propagation and default rules to id  and ps  rules in that order and then applying the non-linear metarules one-by-one in order to the set of fleshed out id rules*. after each metarule has applied  
* this approach to metarule expansion is more restrictive than thompson s  1  principle of finite closure. 
propagation and default rules are applied to any new id rules and these are added to the original set before the application of the next metarule. next  the resulting expanded set of rules is linearised according to the lp rules and any linear metarules are applied to the complete pool of ps rules. this procedure is summarised in figure 1. 
   in essence  this grammatical formalism combines prolog-style unification  as used in definite clause grammars  pereira and warren 1  and patr-ii  shieber 1   with a metagrammatical notation designed to capture linguistic generalisations and so simplify the statement of the grammar. the formalism defines a 'space' of potential grammatical thcones which can be explored by the theoretical linguist. it also allows full use of any mixture of these theories for the flexible specification of a wide coverage grammar of a particular natural language. 
iv the grammar development environment 
　the grammar development environment  gde  is a software system which has been developed to facilitate the writing of a grammar for a significant fragment of english in our grammatical formalism. by analogy with present-day programming environments  barstow et al. 1  where software development is supported by powerful interactive programming tools  the gde provides grammar writers with a set of tools for grammar development  allowing them to input  edit and generally manage the necessarily large number of metagrammatical rules and monitor the interactions between them. the gde is also able automatically to expand out such a set of rules into an object grammar  and from the collaborating projects incorporates versions of the parser and of the morphological analyser with a 
　lexicon of approximately 1 entries. 
　the gde is a 'second generation' system  drawing on several ideas first implemented in systems such as program  evans 
1   gpsgp  phillips and thompson 1   and d-patr  karttunen 1   but differs from them in that it was designed to satisfy all three of the following criteria: 
- to be easy to use 
- to enable a grammarian to achieve high productivity - to be portable and machine independent. 
a. ease of use 
　the first objective  simplicity of use and robustness  is particularly important to a linguist with little or no experience of the system. thus  since the metagrammatical notation is based on gpsg  the syntax accepted for its rules follows that of gazdar et al.  1  as closely as possible. the user of the system is therefore likely to be familiar with the gde's rule notation and would not have to learn a new notation  as would be necessary when starting to use the  also gpsg-based  program system  evans  1 . for example  figure 1 gives an example of a metarule as it has to be presented  firstly to program  and secondly to the gde. 



figure 1. the contrast between program and gde declarations. 
program requires the user to input the grammar both in a syntax that will be acceptable to the underlying prolog system lexical analyser  and one which corresponds closely to the internal datastructures used by program. apart from being idiosyncratic  this notation is difficult to use and a syntax error in a declaration is likely to provoke a prolog error message. the gde  on the other hand  has its own grammar declaration parser and gives informative diagnostics for invalid input  based on the type of grammar item  e.g. feature name  it was expecting. 
   the gde is an environment with many powerful capabilities; however we disagree with teitelman and masinter  1   but in the context of the development of grammars rather than programs  that a powerful environment need necessarily be only for the expert user. all interaction with the gde is carried out through a logically structured set of commands which are able to prompt at any stage as to the type of input expected next there is also automatic command completion. gde commands perform high level operations; for example in a single command the user can instruct the gde to display all the rules resulting from applying a given subset of metarules to a specified set of id rules: 
 pass and sai m e t a r u l e s 
performing a similar task using program involves the user in a lengthy interaction to select the id rules and metarules concerned  followed by explicit commands to 'normalise* both sets of rules and perform the metarule expansion. thus in general  the major difference between the two systems is that with the gde the user specifies a goal for the system to achieve  whereas to achieve the same goal with program the user has to devise a sequence of low level operations and lead the system through them by hand. 
b. encouraging high productivity 
   the second design criterion was to help a more experienced user of the system achieve as high a productivity as possible. the gde encourages an interactive and incremental style of grammar development by providing metagrammatical rule editing facilities  and by enabling the grammarian to quickly identify incorrect rules and assess the consequences of changing them. identifying the incorrect rules is usually the harder task. with other grammar development environments  d-patr  karttunen 1  being a good example  the grammarian has to study syntax trees produced by the parser  and sometimes only from incorrect feature values in them try to deduce which rules are incorrect in the gde the name of an incorrect ps rule in the object grammar can be read directly from the portion of a parse tree that is faulty. ps rule names are unique and each is generated from the name of the id rule in the metagrammar and the names of any metarules that were involved in its formation; multiple linearisations of the same 
1 	natural lanouaof 
rule are also distinguished. thus  the faulty id rule  metarule or lp rule in the metagrammar is easily identified. as well as a parser the gde also contains a sentence and sentence fragment generator which is particularly useful for detecting rules which cause overgeneration and so degrade the performance of the grammar. 
when an incorrect rule is found  it may be edited within the 
gde. the high level rule display commands  mentioned above  are often sufficient for assessing the consequences of the rule change  and using them is usually a more reliable strategy than just another attempt to parse several more sentences. the gde performs extensive 'bookkeeping* on behalf of the grammarian  including keeping track of which files contain rules that have been changed and so should eventually be saved  and regenerating the object grammar when required after a change to the metagrammar. as rules are added to the system  the grammarian can constantly monitor the coverage and performance of the grammar by parsing a corpus of sentences which are maintained by the system and which are intended to represent the coverage of the grammar at any one time. the grammarian is freed by the bookkeeping from having to worry about details of management and is thus able to concentrate attention on grammar development. 
   of course  the powerful facilities provided by the gde would be of limited use if the actual system were not quick enough in execution to keep up with the grammarian; with metagrammars of the size currently being developed it has proven necessary to make the gde cache several types of intermediate result  such as the rules resulting from metarule application. expanding a large metagrammar  in order to be able to parse a sentence  from scratch currently takes of the order of three minutes on a motorola 1-based workstation  but after this has been done once  re-expansion when the gde detects a change to the metagrammar rarely takes more than a few seconds. parsing a sentence seldom takes longer than five seconds  using the highly optimised chart parser from the collaborating parsing project . in contrast  since program and d-patr were not developed with efficiency in mind  their processing times for single sentences  even using smaller grammars  of a minute or more significantly limit the productivity of the experienced user. 
c. portability 
   although the gde was implemented as a software tool for a 
   specific project  the flexibility of our metagrammatical formalism  section iii  makes the gde of potential use to the more general community of linguists and grammarians. it is intended that the software should be freely available  and so firstly it is portable  being originally written in cambridge lisp  a derivative of portable standard lisp  and since translated into common lisp  and secondly machine independent  since it does not count on being able to use a mouse or any windowing capability. indeed the same version of the gde runs on an ibm mainframe  a gec minicomputer and an acorn single-user workstation. in contrast  any serious work using program requires the poplog  hardy 1  editor running on a specific type of terminal  and d-patr needs to be able to call the interlisp-d windowing functions and the special system text editor  tedit . 

v an example grammar development session 
　the gde interaction that follows demonstrates several of the points made in the previous section. the major point is that the output of a single gde command is often sufficient to pinpoint a bug in the grammar. other features highlighted are the integrated nature of the tools  e.g. parser  generator  provided  and the bookkeeping that is performed to allow the grammarian to focus fully on grammar development. the user first reads in a file containing an existing  small  grammar  and tries to parse a couple of sentences.  user input in bold . 
fido 
the second sentence should not have received a parse  so there must be a bug in the grammar. viewing the parse tree immediately suggests where the problem lies: the expansion of the metagrammar has produced a rule vp/nopass  pass/+   which both appears at the place where the parse should have failed  and which also from its name looks suspect.  the user goes on to exit the parser  examine the id rule and metarule involved  and restrict the applicability of the latter. 
parse gde  view id *nofass vp/nopass : 
h subcat nopass   
gde view metarule pass 
an exhaustive generation of all noun phrase structures licensed by the grammar indicates that the rule introducing determiners may be overgenerating  but the user decides to ignore this for the time being  and write the changed grammar back to disc. the gde first saves the existing version of the file in case the user later wants to refer to it. 
   this example interaction is representative of real ones in the process of developing a large grammar. our experience is that a 
	briscoe  grovsr  bogursev  and carroll 	1 
system such as the gde is essential for rapid but successful production of a substantial grammar in a mctagrammatical notation. 
vi conclusions 
   the usefulness of our formalism and associated grammar development environment can only be assessed ultimately on the basis of its success in allowing rapid development of grammars  and associated theories and analyses ; work on expanding the coverage of the grammar is still in progress  but currently  on the basis of only 1 person-months of development  the english grammar contains detailed analyses of: 
- most vp complements  including the various control constructions 
- the auxiliary system 
- declaratives  imperatives and passives 
- y/n and constituent questions  topicalisation 
- np complements  vp and pp modifiers 
- ordinary  zero and free relatives - the np specifier system - ap complements. 
a recent metagrammar contained 1 id rules  1 metarules  
1 propagation rules  1 default rules  and 1 lp rules  which produced an expanded object grammar of 1 ps rules. this makes the current grammar roughly equivalent in size  though not coverage  to diagram* and the critique project grammar**. these latter grammars are widely recognised to be two of the largest developed for machine; however  both involved considerably greater human effort. 
acknowledgements 
   the system described in this paper evolved as a team effort and was greatly influenced by the comments of members of the two collaborating projects-alan black  john phillips  steve pulman  graeme ritchie  graham russell and henry 
thompson-as well as from discussion with bob moore and stu 
shieber. we are grateful for comments on earlier versions of this paper from roger evans and graham russell. the work was supported by research grant gr/d/1 from the uk science and engineering research council under the alvey programme. 
