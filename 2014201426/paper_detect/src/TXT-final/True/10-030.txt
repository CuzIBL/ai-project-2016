language access to distributed data with error recovery 
earl d. sacerdoti 
a r t i f i c i a l intelligence center 
stanford research institute 
　　　this paper discusses an effort in the application of a r t i f i c i a l intelligence to the access of data from a large  distributed data base over a computer network. a running system is described 
that provides real-time access over the arpanet to a data base distributed over several machines. the system accepts a rather wide range of natural language questions about the data  plans a sequence of appropriate queries to the data base management system to answer the question  determines on which machine s  to carry out the queries  establishes links to those machines over 
the arpanet  monitors the prosecution of the queries and recovers from certain errors in execution  
and prepares a relevant answer. 	in addition to the components that make up the demonstration 
system  more sophisticated functionally equivalent components are discussed and proposed. 
　　　the work described in this paper represents the joint efforts of an integrated  energetic group at sri. members of this group include rich fikes  now at xerox parc   koichi furukawa  now at etl . 
gary hendrix  paul morris  now at uc irvine   nils nilsson  b i l l paxton  jane robinsonr daniel sagalowicz  jonathan slocum  and mike wilber. 	the research reported herein  other than the development of the lifer system  was supported by the advanced research projects agency of the department of defense under contract daag1-c-1 with the u. s. 	army research office. 

a. 	introduction 
　　　man's use of tools shapes his environment. man's use of tools also shapes his behavior. as technology evolves more complex tools  the impositions these tools make on their users become more stringent. although it is d i f f i c u l t to reproduce strings of ten digits  we learn to do it well  because the interface to the telephone system demands i t . although it is d i f f i c u l t to type very fast  the standard keyboard was originally designed to allow enough time between keystrokes to keep early typewriters from jamming   we train ourselves to use a suboptimal --indeed  subaverage-
arrangement of keys  because the interface to keyboard systems demands i t . 
　　　as the amount of information moving across the man-machine interface increases  the impositions of machines on our behavior also increase. since computers exchange large amounts of information with their human users they place great 
impositions on us. a goal of research in a r t i f i c a l intelligence is to reduce the extent of these impositions  thus making the benefits of computer use more widely available. 
　　　one example of the imposition set by the computer arises in the area of management information systems. imagine that a user in a decision-making role knows that his data base contains some information that pertains to a decision he must make. the user wishes to extract that information from the data base and restructure  summarize  or analyze it in some way. ideally  the user would be able to interact with the computer in his own terminology and issue a request for the information he desired. but today's computer systems typically require following a very s t i l t e d   formal mode of interaction. even then  the user w i l l only be able to obtain certain preprogrammed reports  and this is hardly what is needed for the typical decision maker in his role of managing by exception. 
　　　if the decision maker wants a new perspective on the information in the data base  he must call in a programmer who works with the data base on a 
　　　regular basis. the programmer carries in his head four kinds of knowledge that must be used in order to gather the desired information. first  he knows how to translate the request for information from the decision maker's terms into the terms of the data that is actually stored in the data base. second  he is able to convert the request for data from the overall data base into a series of requests for particular items of data from particular f i l e s . third  he knows how to translate the particular requests into programs or calls on the data base management system's primitives in order to actually i n i t i a t e the appropriate computation. fourth  he knows how to monitor the execution of his request to ensure that the expected data is being obtained. 
　　　for the past year  a group at sri has been working on automating the activities carried out by our hypothetical data base expert. the following section presents an overview of a running system that performs at least some of the expert's functions both reliably and e f f i c i e n t l y . our current progress on representing and using each of the four kinds of knowledge described above w i l l be detailed in the subsequent sections. 
b. 	overview of the  ladder system 
　　　our running demonstration system  called ladder  for language access to distributed data with error recovery  represents an application of state-of-the-art techniques from the field of 
a r t i f i c i a l intelligence in a real-time performance system. because it consists of a number of rather independent  modular components  new capabilities can be incorporated easily as we learn how to make them run efficiently. 
　　　ladder has been developed as a management aid to navy decision makers  so the examples presented throughout this paper are drawn from the domain of navy command and control. applications of this work to other decision making and data access problems should be obvious. 
knowledge 	r e p r . - l : 	sacerdoti 
1 　　　the ladder system consists of three major functional components  as displayed in figure 1  that provide levels of buffering of the user from a data base management system  dbms . ladder employs the dbms to retrieve specific field values from specific f i l e s just as a programmer might  so that the user of ladder need not be aware of the names of specific fields  how they are formatted  how they are structured into f i l e s   or even where the files are physically located. thus the user can think he is retrieving information from a  general information base  rather than retrieving specific items of data from a highly formatted traditional data base 
　　　ladder's f i r s t component accepts queries in a restricted subset of natural language. this component  called inland  for informal natural language access to navy data  produces a query or queries to the data base as a whole. the queries to the data base refer to specific fields  but make no mention of how the information in the data base is broken down into f i l e s . 
　　　for example  suppose a user types in  what is the length of the kennedy    or  give me the kennedy's length   or even  type length kennedy  . 
inland would translate this into the query:     lgh   nam eq 'john//f. kennedy'   . where lgh is the name of the length field nam the name of the ship name f i e l d   and ' j1hn//f. kennedy' the value of the nam field for the record concerned with the kennedy. this query is then passed along to the second component of the system. 
　　　the queries from inland to the data base are specified without any presumption about the way the data is broken up into f i l e s . the second functional component called ida  for intelligent data access  breaks down the query against the entire data base into a sequence of queries against various f i l e s . ida employs a model of the structure of the data base to perform this operation  preserving the linkages among the records retrieved so that an appropriate answer to the overall query may be returned to the user 
　　　for example suppose the data base consists of a single f i l e whose records contain the fields  nam class lgh . 
then  to answer the data base query issued above  ida can simply create one f i l e retrieval query that says  in essence   for the ship record with nam equal ' j1hn//f. kennedy '  return the value of the lgh field   suppose  however  that the data base is structured in two f i l e s   as follows: ship:  nam class . . .   
　　　　　　class:  classname lgh ..   in this case the single query about the kennedy's length must be broken into two f i l e queries. these would say  f i r s t    obtain the value of the class field for the ship record with nam equal 
 john#f.kennedy'.  then.  find the corresponding class record  and return the value of the lgh field from that record.  finally  ida would compose an answer that is relevant to the user s query   i . e . it w i l l return nam and lgh data  supressing the 
class-to-classname link  
　　　in addition to planning the correct sequence of f i l e queries 	ida must actually compose those queries in the language of the dbms. 	our current system accesses  on a number of different machines  a dbms called the datacoraputer    whose input language is called datalanguage. 	ida creates the relevant datalanguage by inserting field and f i l e names into pre stored templates. 	however  since the data base in question is distributed over several different machines  the datalanguage that ida produces does not refer to specific files in specific directories on specific machines. 	it refers instead to generic files 	files containing a specific kind of record 	for example  the queries discussed above might refer to the ship f i l e rather than f i l e ship.active in directory navy on machine dbms 1. 	it is the function of the third major component of ladder to find the location of the generic f i l e s and manage the access to them. 
　　　to carry out this function the third component  called fam  for file access manager  relies on a locally stored model showing where files are located throughout the distributed data base. when it receives a query expressed in generic datalanguage  it searches i t s model for the primary location of the f i l e  or files  to which it refers. it then establishes connections over the arpanet to the appropriate computers logs in  opens the f i l e s   and transmits the datalanguage query  amended to refer to the specific files that are being accessed. if at any time  the remote computer crashes the f i l e becomes inaccessible  or the network connection f a i l s   fam can recover and  if a backup f i l e is mentioned in fam's model of f i l e locations  it can establish a connection to a backup site and retransmit the query. 
　　　the existing system  written in interlisp   can process a f a i r l y wide range of queries against a data base consisting of some 1 files containing about 1 fields. processing a typical question takes a very few seconds of cpu time on a dec ka-1 computer. an annotated transcript of a session with the system is provided in the 
appendix 
　　　thus ladder provides at least some of the functions of the hypothetical data base expert in each area of expertise mentioned in the previous section. the following sections w i l l provide more detailed views of the demonstration programs and ongoing research efforts in each of these areas. 
c 	iis-lyxsi. language interface 
　　　the task of providing access to the data base in the decision maker's terms is served by a functional component that accepts typed english text as input and produces formal queries to the ida component as output. in order to provide truly natural access  this component must allow each user to expand the language definition with his own idiosyncratic language use. 
　　　we are developing a family of language interface components with increasing generality and true  understanding  of the input. in this section we describe our i n i t i a l performance system. 
* in the introduction we described four activities that our system would carry out and here we are describing only three functional components. this is because the third activity  translating particular queries into the primitives of particular dbms's  is shared between ida and fam. 

knowledge 	repr . - 1 : sacerdot i 1 


figure 1 	overview of the ladder system 

       our i n i t i a l system is b u i l t around a package of programs for language d e f i n i t i o n and parsing called language interface f a c i l i t y with e l l i p s i s and recursion  lifer   lifer consists of a parser and a set of interactive functions for specifying a language fragment oriented towards access of an existing computer system. the language is defined by what may be viewed as a set of productions of the form meta-symbol =   pattern  expression  
where meta -symbol is a meta-symbol in the language  pattern is a l i s t of meta-symbols and symbols in the language  and expression is a lisp expression whose value  when computed  is assigned as the value of the meta symbol. 
       the set of productions is used by lifer to build internal structures  called t r a n s i t i o n trees  that represent the language defined.* the transition trees are then used to parse user inputs in a top-down  l e f t - t o - r i g h t order. the response of the system to a u s e r s input is simply the evaluation of the response expression associated with the top-level pattern that matches the input  together with a l l the subsidiary response expressions associated with meta-symbols contained in the expansion of the top-level pattern or any expansion of a higher-level meta-symbol. 
       the most important feature of lifer from the point of view of developing a r i c h and usable . language d e f i n i t i o n is the ease with which the 
grammar can be updated and the consequent changes tested. the ease of a l t e r i n g the grammar is such 
   transition trees are a simplification of woods' augmented t r a n s i t i o n networks   1   . 
that lifer provides a f a c i l i t y for casual users to add paraphrases to the language d e f i n i t i o n   	in 
english. 	for example 	the user might type 
       define    length kennedy  to be like  what is the length of the kennedy . subsequently  the system w i l l accept 
         commander kitty hawk and 
  speed and current position subs within 
       1 miles of gibraltar and i n t e r p r e t them correctly. questions 1 through 1 in the appendix provide further examples. 
       the lifer parser has a very powerful mechanism for processing e l l i p t i c a l inputs  as exemplified by questions 1 and 1. simple kinds of anaphoric reference  such as that shown in question 1* are handled within the language d e f i n i t i o n . 
       the nature of the lifer parser imposes a discipline on the developer of the language d e f i n i t i o n . for parsing to operate e f f i c i e n t l y   the grammar must severely r e s t r i c t the number of acceptable words at each point in a sentence  and the tests applied to words in the l e f t - t o - r i g h t scan must be as cheap as possible. these goals are best s a t i s f i e d with a language d e f i n i t i o n that d i r e c t l y encodes into the syntax most of the r e s t r i c t i o n s imposed by the semantics of the domain. rather than contain meta symbols l i k e  noun phrase   the inland grammar is composed of e n t i t l e s l i k e  ship s p e c i f i c a t i o n      carry-verb phrase   and  pair of positions.  questions 1 and 1 give examples of a small fragment of the inland grammar. this approach of producing a semantioally-oriented syntax is similar to that used by brown and burton   and waltz   1   . 

k n o w l e d g e r e p r . - l : 	s a c e r d o t i 
1 

　　　using lifer's interactive language definition f a c i l i t i e s we have developed a language definition that we believe is one of the most extensive that has been incorporated into a computer system. it accepts a wide range of queries about the information in the data base as well as queries about the definitions of data base fields and about the grammar i t s e l f . 
d
 	intelligent data access 
　　　a casual user would like to be able to access a data base as if it were an unstructured mass of information. unfortunately  a data base is in reality a collection of f i l e s   often with very complex linkages among them. even worse  a distributed data base may consist of different f i l e s on different machines  possibly handled by different dbmss. an operation amounting to automatic problem solving is required to decide how to link up the files in the data base to extract and aggregate the information requested in a given query. an example of this situation is presented in question 1 in the appendix  where a single question from the user s point of view requires four queries of three f i l e s to develop an answer. 
　　　our i n i t i a l efforts in this area have concentrated on access planning for collections of data bases supporting a relational model of the data   1   . the knowledge necessary to decide how to link among relations is contained in what we call a structural schema. the structural schema contains information for each relation describing how it can be linked to other relations. in addition it contains information about each field s counterparts in other relations and certain special-case information. 
　　　we have taken two approaches to the process of intelligent data access. the f i r s t   embodied in a program called ida  uses a heuristic approach to the problem of linking among f i l e s . the structural schema is embodied in a frame-like representation  with individual frames defined for each field and each f i l e . the program 
generates a single query at a time  examines the results  and then determines the next query to be asked. this approach can lead to suboptimal sequences of f i l e accesses or can even f a i l to answer an answerable question  but it trades these shortcomings for rapid execution and straightforward extensibility. 
　　　our second approach  embodied in a design for a program called dbap  for data base access planner    uses a formal  theorem-proving approach. the structural schema is represented as a set of axioms about the elements in the query language  the fields  and the f i l e s . these axioms are encoded as qlisp  1 procedures. the program builds a complete sequence of queries to the data base before beginning the actual interactions with i t . thus  it can plan an optimal sequence of f i l e accesses  given a sufficiently detailed model of the data base a partial implementation indicates that this approach is essentially an order of 
magnitude slower than ida. for very large f i l e s this expenditure of planning time would undoubtedly be repaid by faster data base retrieval. 
e 	ells. access management 
　　　the third major component of ladder  called fam  for file access manager    locates particular f i l e s within the distributed data base  establishes connections to them  and transmits to and monitors the responses from the remote computers where the f i l e s are located. fam can recover from a range of expected types of errors by establishing links to backup files and retransmitting the failed query. 
　　　fam accepts as input datalanguage commands that refer not to specific files on specific machines  but to generic f i l e s   as defined in section b. based on a locally stored model of the distributed f i l e system  fam selects the appropriate specific f i l e s for the generic f i l e s mentioned in the commands. if network links to the machines where the f i l e s reside do not yet exist  they are established if the f i l e s in question are not yet open they are opened finally  the query  modified to refer to specific f i l e names  is transmitted to the remote machine. 
　　　if certain types of errors occur during the prosecution of the query  fam w i l l attempt to recover. fam currently handles two types of error conditions. the f i r s t is a failure of the network connection which is usually noticed by the tenex operating system as a lack of interaction over the network for a given interval of time. in this case fam attempts to find alternative locations for the files referenced in the query  establishes links to them  and retransmits the query. the second type of error is an explicit complaint from the datacomputer. in practice  this usually arises when fam's model is inaccurate  and a f i l e that was expected to be in a particular location in fact was not. in this case  fam updates i t s model and attempts to recover as before. 
　　　fam is implemented by making strong use of the features of interlisp that support multiple control 
and access environments  . when fam opens a connection to a particular machine  it builds a piece of pushdown stack that contains as locally bound variables the appropriate information about that connection  and whose control environment is poised to interact with the remote machine. an interaction with a particular remote machine can thus be invoked via a generator function. 
f. 	directions for further work 
knowledge r e p r . - l : sacerdoti 1 　　　as of march 1  the ladder system has been brought to a stage of development where it can be used with some success and enjoyment by casual users. it accepts a rather wide range of queries against a simple data base  and is quite robust. this has been achieved by making many simplifying assumptions. the language component does not understand the user's queries in any fundamental sense; rather  it reflexively invokes ida with the appropriate arguments. the data access component assumes that a l l queries can be answered by joining records from various f i l e s . both systems make strong assumptions that the user knows the kinds of information that are in the data base and is asking relevant questions. now that an i n i t i a l system has been developed and demonstrated  we can concentrate 
on e f f o r t s to improve i t s robustness 	g e n e r a l i t y   
and coverage of the language. 
       u n t i l r e c e n t l y   there e x i s t e d a c l e a r t r a d e o f f between b u i l d i n g two kinds of language systems on the one hand  systems e x i s t e d t h a t ran r e l i a b l y in r e a l time but had very meagre semantic underpinnings  whose e x t e n s i b i l i t y was c l e a r l y l i m i t e d   and which did not t r u l y understand inputs to them  in the sense t h a t they d i d not compose an i n t e r n a l r e p r e s e n t a t i o n of t h e i r meanings. on the other hand there were systems t h a t covered the language much more thoroughly  were b e t t e r grounded l i n g u i s t i c a l l y   and developed a r e p r e s e n t a t i o n of what the i n p u t s meant  but t h a t could not run in r e a l t i m e . even worse  there was no c l e a r way to i n t e g r a t e the e f f o r t s being put i n t o the two approaches: the underlying c o n t r o l s t r u c t u r e s and language d e f i n t i t i o n systems were incompatible. 
       a f t e r e v a l u a t i n g the b e n e f i t s of the lifer approach and reexamining the requirements and behavior of the more semantically based systems  we have developed a  core language system  that is capable of supporting both approaches  and of supporting systems at intermediate p o s i t i o n s on the t r a d e o f f between r e a l - t i m e performance and l i n g u i s t i c grounding. 
       the core system accepts a wide range of s t y l e s of language d e f i n i t i o n   ranging from the semantically o r i e n t e d syntax of the inland grammar to an amalgam of m u l t i p l e knowledge sources s i m i l a r to that used by the sri speech understanding system   1   . i t accepts language d e f i n i t i o n s a t intermediate points w i t h i n t h a t range as w e l l   and it should thus c o n s t i t u t e a v e h i c l e for b r i n g i n g more l i n g u i s t i c a l l y and semantically o r i e n t e d s t y l e s of language processing i n t o a c t u a l use in a staged f a s h i o n . we are developing a research plan that should enable us to simultaneously explore the issues involved in true language understanding while augmenting the power  coverage  and l i n g u i s t i c relevance of the demonstration system. 
       our plans f o r data access include extensions to the input language of ida to permit q u a n t i f i e d 
       queries. this w i l l enable the system to d i s t i n g u i s h between such queries as  what is the l a s t reported p o s i t i o n of each sub   and  what is the l a s t reported p o s i t i o n of any sub   
       we w i l l attempt to demonstrate the g e n e r a l i t y of our approach to data base access planning by i n t e r f a c i n g to a d i s t r i b u t e d data base stored p a r t i a l l y on a dbms supporting a codasyl-type  model and p a r t i a l l y on the datacomputer supporting a r e l a t i o n a l model. 
       in a d d i t i o n to these e f f o r t s   which we expect w i l l improve our performance system  we are c o n t i n u i n g to progress in our longer range research. an i n t e g r a t e d language understanding and access planning system b u i l t around the r e p r e s e n t a t i o n of knowledge in semantic network form is being designed. the longer term e f f o r t s w i l l b e n e f i t from the t o o l - b u i l d i n g involved i n the performance-oriented work. development of the performance system is guided and p r i o r i t i z e d by the r e s u l t s and problems encountered in our longer term research. the e a r l y successes of t h i s program have provided an i n i t i a l demonstration of the b e n e f i t s 
of simultaneously pursuing lower r i s k research aimed at c o s t - e f f e c t i v e performance and higher r i s k research aimed at advancing the s t a t e of the a r t . 
