 
　this paper proposes a method for adapting the traditional devices of model theory to the task of specifying the input/output behavior of a r t i f i c i a l intelligence reasoning programs when viewed as inference engines. the method is illustrated by specifying two programs  one a toy example and the other a program for retrieving information from a declarative knowledge base. close examination shows that many intuitions about the properties of a retriever can be stated rigorously in terms of inference and that the model-theoretic specification can then be used to prove that the retriever 
has these properties. 
1. 	ai needs specification techniques 
　the success of a r t i f i c i a l intelligence as a science hinges on our ability to build a theory that relates a program's structure to its behavior. essential to this enterprise are methods for producing rigorous specifications of programs at a high level of abstraction that can be used to codify and communicate our results. 
　there are two specification methods predominantly  though certainly not exclusively  used: english prose typically describing various structural components of the program and their role in the program's performance  and the actual code that is used to implement the program. an english prose specification can be highly abstract but  in practice  usually at the expense of rigor and precision. consider the problem of predicting how a program so described in a journal w i l l behave on examples not considered in the article. morse yet  consider the problem of showing that the program has certain properties. though a program's code does not suffer from the lack of precision that an english specification typically does  it is not sufficiently abstract. hence  appropriately enough  code rarely works its way into the l i t e r a ture. 
　a methodology that has been pursued successfully throughout computer science is that of separating the description of what a program computes from how it computes i t . on the one hand there are descrip-
	this work has been supported in 	part 	by 	grant 
gr/d/1 from the science and engineering research council. 
tions of a program's input/output behavior and on the other descriptions of its internal modules  processes  states and data structures. 
　this paper considers the case for using model theory to specify what a program computes. a 
method is proposed for adapting traditional modeltheoretic techniques and is illustrated by specifying two programs. the f i r s t is a toy example used to illuminate the key points of the technique  while the second  a knowledge retriever  is used to demonstrate application of the technique to a realistic aj program. beyond what is demonstrated by these examples and those mentioned in the section 
on related work  l i t t l e is known about the range of applicability of the technique. 
1. 	overview of the proposed technique 
　a major concern of ai is with programs that manipulate representations  which 1 take to be data structures that denote. this raises the possibility that many such programs can be viewed as inference engines  deriving conclusions from their representations. this paper is concerned with developing techniques for using model theory to specify the input/output behavior of programs seen from this viewpoint. 
　for example  a planner can be seen as an inference system. the program embodies a theory of action and its input is a pair of sentences each predicating a condition on the world. the planner produces a plan such that its theory of action logically implies that the second input sentence would be true if the plan were performed in any world satisfying the f i r s t input sentence. 
　unfortunately  many planning systems such as strips  fikes and nllsson  1  do not meet such a specification. in order to deal with the enormously complex problem of finding an appropriate plan among the set of all plans  these systems employ problem representations that often find plans quickly but do so at the expense of occasionally failing to find any at a l l . as an inference engine such a system is incomplete. how then can such an incomplete system be specified  
　the approach advocated here is to produce another model theory whose logical implication relation is weakened1 in such a way that the program is a sound and complete inference engine with respect to i t . many people i n i t i a l l y find this approach quite odd. 
they are accustomed to thinking of a model theory as specifying what can be concluded validly from what-in some sense  as a competence theory of inference. i suggest that those who are comfortable with this viewpoint consider the weaker model theory as a performance theory of inference. other people are accustomed to thinking of a model theory as a way of assigning meaning to symbols and are skeptical of producing a new meaning assignment. but i am not suggesting that the original model theory be discarded; on the contrary  it is s t i l l 
a valuable device in the study of meaning. the new model theory can be thought to provide an additional meaning assignment. if the program is working under this alternative meaning then it is a complete inference engine. hence  the symbols mean one thing to us and something different to the program. according to our theory of meaning the program is incomplete but according to its weaker theory of meaning it is complete. 
   how can these new  weaker model theories be produced and what is their relationship to the unweakened model theory  to answer the question consider a model theory as laying down a set of constraints on what constitutes a model. of a l l  mathematical  objects  only those that satisfy the constraints qualify as models. a model theory also associates with each model a truth assignment  a total function from sentences to their truth values. hence  
a model theory constrains the range of truth assignments that can be generated. in a standard propositional logic  for example  these constraints ensure that any truth assignment that assigns two sentences true  also assigns their conjunction true. the logical implication relation associated 
with a model theory is a product solely of the range of truth assignments that the model theory generates. relaxing the constraints produces a new model theory  one that may generate additional truth assignments. no matter how the constraints are relaxed  the new model theory must have a weaker logical implication relation than the original . that is  if and are logical 
implication relations and is obtained by relaxing the model theory for   then alpha  beta implies alpha beta. to see this  observe that a truth assignment can serve only as a counterexample to a claim that one sentence logically implies another; hence if none of the truth assignments from the relaxed model theory are counterexamples then certainly none from the original model theory are. 
1. 	a toy example 
　consider a program that reasons about an arbitrary equivalence relation named  r . a user com-
municates with the program  making assertions and queries  each of which specifies a sentence of the form  r alpha beta    where alpha and beta are sym-
   1 one logical implication relation is weaker than another if the inferences sanctioned by the f i r s t are a subset of those sanctioned by second. 
	a. frlsch 	1 
bols drawn from some lexicon. 
　this program can be specified in terms of the symbolic manipulations it performs. there are many conceivable specifications but for the sake of argument let us say that the program works by maintaining a collection of disjoint sets. i n i t i a l l y there is a unit set for each symbol in the lexicon. whenever the user asserts  r alpha beta   the program combines the sets that contain alpha and beta into a single set. to respond to the query  r alpha beta   the program simply determines whether the elements alpha and beta are in the same set. there are many well-studied algorithms for performing this set-union task  tarjan and van leeuwen  1   the best of which can process a series of n assertions and queries in slightly greater than 1 n  time. 
　to the user of the system this specification is too detailed and too concrete. a more abstract  
non-procedural definition of this reasoning system can be obtained by replacing the question  what 
does the reasoner do   with  given a set of sentences that have been asserted  what query sentences succeed   at this higher level of abstraction the various set-union algorithms are a l l equivalent. 
　in response to the question of what queries succeed  it can be shown that the program described above answers  yes  to a query i f   and only i f   it legitimately can do so based on what it has been 
told. that is  it answers  yes  if  and only i f   the queried sentence logically follows from the set of asserted sentences. forgive my pedantry while i spell out the obvious details of the model theory that gives rise to the logical implication relation for this language; these details w i l l be valuable in considering how to relax a model-theoretic 
specification. 
　each of the model theories discussed in this paper is given a name. the one presented next is called  e . in cases where confusion could arise  terms like  e-model  and  e-logical implication  and symbols like  |=e  are used to indicate which model theory is under consideration. 
　an e-model is a pair  where 1 is a non-empty set 	of 	individuals 	called the domain and 	a is a function that maps every symbol in the 	lexicon 	to an 	element 	of 	1 	and maps r to a binary relation 
over d such that: 
 1  a r  is reflexive  
 1  a r  is symmetric  and 
 1  a r  is transitive. 
　the truth assignment associated with  is the function that takes each sentence of the form 
r alpha.beta  to true if the relation a r  holds between a alpha  and a beta   and to false other-
wise. these truth assignments can then be used in the usual fashion to define the notions of esatisfiability  e-validlty  and e-logical implication for this language. 

1 	a. frisch 
　this model theory serves two purposes in analyzing the program. first  it provides a rigorous 
semantics for the language that the prograa manipulates and in doing so defines logical implication for the language. second  it is used in specifying what the program computes by stipulating that it responds  yes  i f   and only i f   the queried sentence e-logically follows from the asserted sentences. in the case of this program the two uses go hand-in-hand because the program is a sound and complete inference engine. but it is important to distinguish between these two uses of a model theory as we turn our attention to a reasoning program that is not complete. 
　suppose that for some reason we were not happy with a program that required slightly greater than 1 n  time to process a series of n assertions and queries.  i told you this was a toy example!  furthermore  suppose that we were willing to replace the set-union algorithm with the following algorithm  which is much weaker but slightly faster. whenever  r alpha  beta   is asserted  the 
program adds the pair  alpha beta  to an associative store. the program responds  yes  to the query  r alpha beta   i f   and only i f   alpha and beta are identical or the associative store contains either  alpha beta  or  beta alpha . 
　this program is incomplete with respect to e. for example  if only r a b  and r b c  have been asserted  the query r a c  w i l l not result in  yes  even though the queried sentence e-logically f o l lows from the two asserted sentences. e s t i l l gives a semantics for the language manipulated by the program but it no longer specifies what the 
program computes. however  there is a weaker model theory--call it ew--whose logical implication relation does specify the input/output relation of this program. ew is identical to e except that constraint  1   which says that a r  must be transitive  is eliminated. with respect to ew the program is a sound and complete inference engine- though admittedly soundness and completeness are normally taken to be with respect to a model theory that specifies the meaning of the language. 
1. 	knowledge retrieval 
　a r t i f i c i a l intelligence reasoning systems commonly employ a knowledge base module  kb  that stores information expressed in a representation language and provides facilities for other modules of the system to retrieve this information. though there has been a growing concern for formalization in the study of knowledge representation  l i t t l e has been done to formalize the retrieval process. this section outlines an attempt to use the proposed specification technique to remedy the situation. since a method should be judged by the results that can be obtained with i t   the section is not as concerned with the method itself as with how it can contribute to the study of retrieval. 
1 . 1 . 	retrieval as inference 
　the retrieval problem that i have studied1 takes the knowledge base to be a set of sentences of the first-order predicate calculus  fopc . while fopc may be less expressive than many other languages that could be used  it is expressive enough to lead to a serious retrieval problem; most notably  logt-
cal implication is only semi-decidable. 
　a query asks whether a specified closed sentence of fopc can be retrieved from the kb  and the retriever responds  yes  or  no.  so  for example  one could query  can 'uncle john bill ' be retrieved   it is not d i f f i c u l t to extend this notion of query to include fopc sentences with free variables. such an extension enables one to ask   what are all the x's such that 'uncle x bill ' can be retrieved   however  for purposes of this exposition it suffices to consider only the f i r s t form of query. 
　a specification must determine whether a r e t r i ever responds  yes  or  no  for any given kb and any given query. just as one can speak of a sentence logically following  or being provable  from 
a set of sentences  one can speak of a queried sentence being retrievable from a set of sentences contained in a knowledge base. thus the task of specifying a retriever comes down to one of specifying a retrievability relation. 
　i place three requirements on any retrievability relation that i study. if kb is a set of sentences and q a single sentence of some language whose logical implication relation is then any retrievab i l i t y relation for that language should satisfy: soundness: if q is retrievable from kb then 

verbatim retrieval: if q kb then q is retrievable from kb. 
	decidability: retrievability is 	decidable. 
　the f i r s t requirement demands that sentences not logically following from the kb are not retrievable while the second demands that sentences explicitly in the kb are retrievable. the third requirement  which ensures that the retriever can be realized by an effective procedure that is guaranteed to terminate  is weaker than it ideally should be-that the retriever could be realized by a procedure requiring only some small amount of computational 
resources. 
　it should come as no surprise that i specify a retrievability relation for fopc by identifying it with the logical implication relation of a model theory obtained by relaxing the standard tarskian 
model theory for fopc  tarski  1 . 1 call the tarskian model theory  t  and the relaxed model theory that specifies the retriever  r . 
　consider how  as a retrievability relation  stands up to the above requirements. since obtained by relaxing constraints in the specifica-
x 	＊ 	- 
1
　　 frisch and allen  1  examine the problem in more detail. 
tion of  the soundness requirement is met  according to the argument of section 1. any logical implication relation will satisfy the second requirement  regardless of the model theory. since |=t is not decidable  it is the third requirement that forces a relaxation of t and leads to the 
viewpoint of knowledge retrieval as limited   i . e .   incomplete  inference. hence it is the undecida-
b i l i t y 	of 	fopc 	that 	makes the retrieval problem 
interesting. 
1. 	specifying a retriever 
　1 have used this viewpoint of retrieval as limited inference to specify a slightly simplified version of the knowledge retriever incorporated in the argot dialogue-participation system  allen. frisch and litman  1 . the specification is produced in stages  f i r s t by specifying a retriever that is extremely conservative in what it infers and then by extending it with additional forms of decidable inference such as those dealing with taxonomic hierarchies and property inheritance  as typically done by semantic-network systems . at each stage a retrievability relation is specified by identifying it with both a provability and a logical implication relation. a point worth noting is that these specifications of argot's retriever were developed after the program. only the extremely conservative retriever is considered here  though section 1 briefly outlines how semantic-network-style taxonomic inference can be incorporated. 
　the strategy for ruling-out certain inferences to obtain this extremely weak inference engine is based on the important intuition that retrieval is more like a matching operation than a deductive operation. stated in terms of inference  the simple retriever satisfies the no-chaining restrlcuon; imagining the kb and query divided into quanta called  facts   the simple retriever cannot chain two facts together in order to respond affirmatively to a queried fact. tn other words  a queried sentence is retrievable only if each of its facts is retrievable from a single fact in the kb. this intuition contrasts with the notion that retrieval deduces the queried sentence by repeatedly combining facts together to derive new facts. 
   the use of the word  fact  has been deliberately vague and will not be made precise until section 1. however before turning to the specification of retrieval it is worth noting that the main connective in a fact is disjunction. this is a crucial point because r is derived by weakening only the interpretation of disjunction. hence  a fact is given a weaker interpretation in r  eliminating chaining and thus making r-logical implication decidable over the set of facts. a key example is that the specification does not sanction a simple form of chaining  the disjunctive form of modus ponens: 
	a. frisch 	1 
　it is tempting to try to produce the specification of the relaxed model theory by following the tactic used in section 1 of simple textual deletion of some constraint on what constitutes an unrelaxed model. however  in the case of t it is not so straightforward. e specifies three constraints on the relations that can be assigned to the symbol  r  and thus prevents the atomic sentences of the language from obtaining certain combinations of truth values.  recall that all sentences in the object language of e are atomic.  relaxing e to obtain ew involves deleting one of the three constraints  allowing the atomic sentences to be given additional combinations of truth values. 
　unlike e  t places no constraints on the relations that a model can assign to a relation symbol and therefore the atomic formulas of the language can be assigned any combination of truth values. so the strategy of generating additional truth assignments by giving the atomic sentences more combinations of truth values cannot be pursued in this case.1 since the truth assignments to atomic formulas cannot be increased we must consider the truth assignments to molecular formulas. t is truth-functional; the truth value of a molecular formula in a model is a function of the truth values of the formula's constituents tn that model. for example  a disjunction is true in a t-model i f   and only if  one of its disjuncts is true in that model. in order to admit more truth assignments while s t i l l maintaining a compositional semantics  the truth value of a molecular formula must be a function of some other feature of the formula's constituents. the best-known non-truth-functional model theories are the possible-worlds model theories  kripke  1   which are commonly used 
for modal logics  in a pwmt  possible-worlds model theory  one speaks of the truth value of a formula in a world  and for a molecular formula this may be a function of the truth values of the formula's constituents in other worlds. there are many reasons for moving from a tarskian to a possible-
worlds model theory  but the sole motivation here is that the possible-worlds framework is a more 
expressive medium for describing a model theory; every truth-functional model theory can be written in a possible-worlds form but not vice-versa. 
　so  the f i r s t step to reaching the ultimate target of a model theory for specifying the retriever is to produce a pwmt--call it t'--whose models correspond to those in t and which therefore yields precisely the tarskian truth assignments. the next step is to produce k by relaxing t' so that it allows more models and associates non-truthfunctional truth assignments with the added models. 
　for present purposes  consider a model in a pwmt to be a 1-tuple  d a w  where d--the domain-and w-the set of worlds in the model--are non-empty 
1
　　 it is assumed here that only 1 truth values are used. belnap  1  1  pursues a strategy of using 1 truth values. 
1 a.frisch 
sets and a is a function fron a non-logical symbol and a world to an appropriate denotation for that symbol. because the non-logical symbols may have different denotations in different worlds  there is a truth assignment associated with each world in a model. the manner in which such a truth assignment is derived varies from one pwmt to another. 
　the current task is to define tf   a pwmt that corresponds to t. since a t-model generates only one truth assignment  let t1 be a possible-worlds theory in which a l l models contain exactly one world. hence  the t'-model  d a  w}  corresponds to the t-model  d lambda x.a x w  . in the obvious way  w in  d a {w}  can be associated with a truth assignment  the same as that associated with its corresponding t-model. i make this explicit because  as previously mentioned  it is the manner in which these assignments are generated that is to be relaxed. specifically  consider the equation that inductively defines the way t' assigns truth 
values to disjunctions. if v m w is the truth assignment associated with world w i n model m then 

where or is the usual boolean disjunction. 
　to specify r  t' is relaxed to allow models with more than one world. this enables r to construct non-truth-functional truth assignments by defining the assignment associated with one world in terms 
of those associated with other worlds. 	in particular  	r assigns true to a disjunction in a world if 
any of its disjuncts are assigned true in any world in the model. this modification is effected by 
replacing  1  with  1 . 

　the equation gives a formula of the form 	  	v 	  the same interpretation as a traditional pwmt would 
give to the modal formula  possibly 
　notice that  1  and  1  are in f u l l agreement on those models that contain only a single world. hence r s t i l l generates a l l the tarsklan truth assignments. however  r also generates many nontruth-functional truth assignments. as an example consider any two-world model whose worlds are complementary--they disagree on the truth value assigned to every atomic formula. every l i t e r a l  an atomic formula or its negation  must be true in exactly one of the two worlds  and therefore in either world every disjunction of literals is true  regardless of the truth of the literals in that world. this vividly illustrates how the logic is weakened; if one knows only that a disjunction of literals is true  one knows nothing of the truth 
values of those l i t e r a l s . 
　r-models with complementary worlds play an important role in studying the properties of this model theory. whereas r-models with identical worlds produce only the tarsklan truth assignments  those with complementary worlds are the most un-tarskian in that their truth assignments differ most from the tarsklan truth assignments. such r-models can 
demonstrate  for example  that p and -p v q do not r-logically imply q. 
1. 	properties of the retriever 
　this section examines the properties of the retrievability relation specified by model theory r. i state these properties without proof  concentrating instead on how they coincide with certain informal intuitions about retrieval. 
　the principal motivation for relaxing t to produce r was to obtain decidability of logical implication. yet because r s t i l l gives negation  conjunction and quantification their standard tarskian interpretations   remains undecidable. how-
ever  it is decidable for sentences of a particular normal form. a universal clause is a universally quantified disjunction of literals. an existent i a l disjunction is an existentially quantified conjunction  each conjunct of which is a disjunction of literals; that is it is of the form  

where each lij is a l i t e r a l . an atomic sentence is neither a universal clause nor an existential disjunction though a disjunction with a single disjunct is permitted. this seemingly-trivial insistence that every existential disjunction and universal clause contains a disjunction has the crucial consequence that these sentences are interpreted more weakly by r than by t. 
property 1 
there is a procedure  which given any finite set of universal clauses-kb-and any existential disjunction-q-decides whether 
　though this crucial property is not proved here  the remaining properties mentioned in this paper are the key lemmas in its proof. 
　one intuition about retrieval is that it yields exact answers. for example   is not retrievable from a kb containing solely 
 liar richard-nixon  v liar john-dean   because a particular x cannot be named. so a retriever only says that an individual with a particular property exists if it is able to name that individual. the following property formally states that |=r captures this intuition. 
property 1 
an existential conjunction  

is r-logically implied by a set of universal clauses  kb  if  and only i f   there is a substitution  1  of ground terms for the variables x 1  x 1    . such that 


　now consider the problem of retrieving a ground clause--a disjunction of variabje-free literals-from a set of universal clauses. 
property 1 
let kb be a set of universal clauses and q be a ground clause. then kb  q if  and only if  b q for some b that is a ground instance of a clause in kb. 
　this is a no chaining property where a fact is formalized as being a ground clause. notice that r-logical implication is restricted not just to a single universal clause but to a single instance of the clause. this means that 

because the query t-logically follows only from two instances of the clause 1n the kb: 

such an inference can be seen as chaining a sentence with itself  and hence our intuitions say that it should not be performed by the retriever. property 1 confirms that the specified retriever captures this intuition. 
　there are many conceivable retrievers that  like this retriever  satisfy the no-chaining restriction for the definition of  fact  used here. however  among these retrievers the one specified here occupies a privileged position by virtue of property 1. 
property 1 
for any two ground clauses  kb and q  kb |*=r q if  and only if  kb  q. 
recall  from the soundness requirement of section 
1  that for a relation to be considered a r e t r e v a b i l i t y relation it must be a subset of |= t . therefore  with respect to the present definition of  fact    is the strongest retrievability relation satisfying the no-chaining restriction! 
1. 	extensions 
   1 expect that having a model-theoretic specification w i l l result in big payoffs when the capabilities of the simple retriever are extended. consider extending the retriever to do a specific kind of finite chaining-for example  reasoning about inheritance and taxonomies as is typically done by semantic-networks. fopc can be enhanced with notational devices for expressing information about taxonomies and the tarskian model theory can also be extended to deal with these syntactic additions. our clear and simple intuitions about taxonomies make this an easy task. since the taxonomic extensions are decldable and the retriever is to reason fully about them  these same extensions can be made to r in order to obtain a retrievability relation for the enhanced language. 
　though the d i f f i c u l t task of finding a proof theory or a decision procedure s t i l l remains  imagine the difficulty of doing so without the guidance of a model theory. how would one know when a l l necessary inferences were captured  or if the 
	a. frisch 	1 
captured ones were reasonable  of course one's intuitions could provide guidance  but not to the degree provided by a model theory constructed from the same intuitions. 
   in another application  r could be extended to form a logic of what i.evesque  1  calls  explicit belief -those beliefs that an agent can readily access   i . e .   retrieve . r provides a useful foundation on which to build since it accounts for certain crucial facts: an agent's explicit beliefs may be t-inconsistent  an agent cannot explicitly believe most of the tconsequences of his explicit beliefs  and an agent can explicitly believe that p but not that q  even if p and q are t-logically equivalent and he expli-
citly believes so. 
1. 	related work 
　there is one line of research that has resulted in a logic so close to r that i discuss it here at the exclusion of all else. the comparison is brief  though a detailed one certainly is called for. 
　belnap  1; 1  presents a four valued relevance logic that provides a weakened interpretation of propositional logic. levesque  1  in turn uses this logic as the foundation of a modal 
explicit-belief operator in a propositional logic. with the retrieval problem in mind  patel-schneider  1  extends belnap's logic with quantification  resulting in a system with a t-entailment relation strikingly similar to  though not explicitly discussed  each of these systems provides a standard logical system with an alternative  relaxed model theory and in each case the motivation is to obtain a weak logical implication relation  called  entailment  in these systems  with certain properties. 
　propositional sentences in patel-schneider's system and those embedded in levesque's implicit-
belief operator have the same interpretation as in the underlying system of belnap. hence  1 shall compare propositional interpretations in r only with those in belnap's four-valued logic  which henceforth is called simply  b . 
　whereas the elimination of chaining motivated the development of r  the elimination of inconsistency motivated the development of b. consequently  the two logics weaken the logical connectives of fopc 
differently. r weakens the interpretation of disjunction so that a disjunction of false formulae may be either true or false. b weakens the interpretation of negation so that the truth of a 
sentence is not related to that of its negation- intuitively what one would expect from a logic 
designed to eliminate inconsistency. 
　the remarkable result is that  like r  b does not sanction the chaining of facts as defined here. however  b is weaker than r in that no sentence is b-valld. whereas b denies the existence of v a l i dity  r carries the no-chaining intuition through 

1 	a. frisch 
to its definition: a normal for* sentence is rvalid i f   and only if  each of its facts is valid. specifically  the relationship between the two systems is that for sentences in prenex conjunctive 
normal font 

1. 	conclusion 
　model-theoretic specifications of ai programs are useful for several reasons. they are wore abstract than lisp-code specifications yet formal enough to prove that a specified program has certain properties  such as those discussed in section 1. it is hard to imagine a form of specification that moves further in the direction of saying what is computed without saying how. perhaps this accounts for why the retrieval specification presented here is extremely short  though an efficient implementation wouid require a program of moderate size. in addition to being technically valuable  a model theory can be a useful heuristic tool  serving to sharpen and extend our intuitions. though a proof-theoretic specification also can possess some of these properties  ideally one would like to have both forms of specification available; the moreappropriate specification can then be chosen for any given task. 
　this paper gives  i hope  strong evidence that a model-theoretic specification of a program is a 
　valuable tool. furthermore  it suggests how these specifications may be produced for incompletereasoning programs. yet the u t i l i t y of a methodol-
ogy must be demonstrated by more than two examples  however persuasive they may be. the important question that remains unanswered is  what is the range of ai programs that can be specified naturally with a model theory   i stress the word  naturally  because a cumbersome model-theoretic specification will not provide the benefits discussed above. 
　during a period when the retrieval specification used mechanisms other than possible worlds  i often felt that the specification was stretching the methodology to its limits  that slight extensions to the retriever would introduce immense complexity to the specification. my pessimism subsided with the introduction of possible worlds  and the potent i a l for extension is now one of the strong points 
of the retrieval specification. the use of possible worlds is just one element in a large body of well-studied model-theoretic devices and logical implication is just one of a range of model-
theoretic relations  which potentially could be used in the construction of specifications. on this rests the hope of using the proposed methodology to specify a wide range of programs. further attempts to develop and use the technique are needed to see how far it can be extended before breaking down. 
acknowledgements 
	lengthy discussions with david a. 	mcallester 	in 
december 1 led to several ultimately-correct suggestions for approaching the problem of producing a model-theoretic account of my retriever. the 
retrieval specification in this paper is the result of a two-year process that produced numerous incorrect and/or over-complex specifications. i am most grateful to dave  without whom i would have slept better for two years but never would have written this paper. i am also grateful to peter patel-schneider  chris mellish  remko scha and 
aaron sloman for their useful comments on various versions of the paper  to james allen  andy haas and pat hayes with whom i have had extensive discussions on model theory and knowledge retrieval  and to fran evelyn for her eagle-eyed proofreading. 
