 
       the problem studied is t h a t of l e a r n i n g problem s o l v i n g h e u r i s t i c s by d o i n g . the purpose is to explore the l e a r n i n g behavior of a h i g h l y constrained mechanism. the c o n s t r a i n t s are choosen on the basis of dsychological c o n s i d e r a t i o n s . computer runs show t h a t the c o n s t r a i n t s do not prevent successful l e a r n i n g . 
t
he 	l e a r n i n g s t y l e of the program t u r n s out to be 
a f u n c t i o n of the s t r u c t u r e of the problem space. 
	i 	heuristics learning 
       the task studied in t h i s paper is t h a t of d i s c o v e r i n g problem s o l v i n g h e u r i s t i c s by d o i n g . we presuppose a task-independent  weak problem s o l v e r which can take a problem space and a problem as i n o u t   and search f o r the s o l u t i o n to the l a t t e r . we add a set of l e a r n i n g mechanisms which s p e c i f y how the i n f o r m a t i o n generated during search should be encoded f o r f u t u r e use. the task of the system is to c o n s t r u c t a s t r a t e g y f o r searching a problem space on the basis of repeated problem s o l v i n g t r i a l s in t h a t space. systems of t h i s kind have been described by anzai & simon  1   by langlev  1    by ohlsson  1; 1   as w e l l as by o t h e r s . they w i l l here be c a l l e d h e u r i s t i c s l e a r n e r s . 
       the purpose of the work reported here is not to c o n s t r u c t the most i n t e l l i g e n t l e a r n i n g system which the s t a t e of the a r t a l l o w s   but to study how a p a r t i c u l a r set of c o n s t r a i n t s on an i n f o r m a t i o n processing system a f f e c t s i t s l e a r n i n g behavior. the c o n s t r a i n t s chosen f o r study are based on psychological c o n s i d e r a t i o n s   although no d e t a i l e d comparison between the drogram and human behavior w i l l be made in t h i s paper. 
	ii 	the universal puzzle learner 
	an e a r l i e r version of 	the 	universal 	puzzle 
learner 	 upl  	program 	has 	been 	described 	in 
ohlsson  1; 1 . the t h i r d and c u r r e n t v e r s i o n c o n s i s t s o f three l a y e r s : the implementation language  the problem s o l v e r   and t h e l e a r n i n g mechanisms. 
a. 	implementation language 
       upl is w r i t t e n in pss  a n e o - c l a s s i c a l production system language  ohlsson  1 . it allows the user to organize production memory i n t o nodes  each node c o n t a i n i n g one or more p r o d u c t i o n s . when pss is   i n   a node  it w i l l t r y to f i r e a production from t h a t node before it consides productions from other nodes. control can be t r a n s f e r r e d from one node to another by the f i r i n g of a p r o d u c t i o n . 
       the pss c o n d i t i o n matcher recognizes a c o n s t r u c t c a l l e d sequence v a r i a b l e s   which f u l f i l l the same f u n c t i o n as the   t h r e e dots  of i n f o r m a l mathematics; the expression   a  seq  b   in which  se1  is a sequence v a r i a b l e is i n t e r p r e t e d as  any l i s t c o n t a i n i n g a  followed by any number of expressions  followed by b . sequence v a r i a b l e s match against the empty sequence  so t h a t   a b   is an instance of   a  seq  b     . as an example of the use of sequence v a r i a b l e s   the expression    se1  x1   w i l l bind the v a r i a b l e x1 to the l a s t expression in any l i s t which has at l e a s t one element. as a second example  the expression   alternatives: x1  seq    w i l l recognize a l i s t w i t h one or more a l t e r n a t i v e s . the sequence v a r i a b l e s are bound to the sequences they match a g a i n s t . the pss sequence v a r i a b l e s can be seen as a development of the  remaining segment  f e a t u r e     !     of the ops language f a m i l y  forgy & mcdermott  1 . 
b. the problem solver 
       the next l a y e r of upl is a task-independent  weak problem solver c o n s i s t i n g of 1 nodes w i t h various t a s k s   such as s e t t i n g g o a l s   m a i n t a i n i n g the g o a l - s t a c k   generating a c t i o n s   censoring a c t i o n s   doing c o n f l i c t r e s o l u t i o n   executing a c t i o n s   e v a l u a t i n g r e s u l t s o f a c t i o n s   backing u p   and r e s t a r t i n g . the program takes a problem space and a problem as i n p u t . a problem space is given to the program in two p a r t s   a bnf grammar d e f i n i n g a knowledge-state  and a l i s t of operator d e f i n i t i o n s . a problem is presented as an ordered p a i r o f s t a t e s   the i n i t i a l s t a t e and the goal s t a t e . the problem solver is task-independent in the sense t h a t it does not make any assumptions about the expressions which are used as the knowledge-elements of the problem space. 

　　　the problem solver works as follows. the current goal is analyzed by subgoaling rules. actions to be taken are generated either by forward-searching proposers  by a rudimentary form of means-ends analysis  or bv random generation. when one or more actions have been generated  they are subject to scrutiny by censors which may or may not reject some of them.  notice that the censors apply before the action is taken.  if more than one action survive the censor  conflict resolution is applied. execution of the selected action is done by an interpretative procedure which takes an operator definition as input. an operator definition is a schema-like structure with slots for the name of the operator  central parameters  auxiliary parameters  background  inputs  outputs  and side-effects. the outcome is evaluated  and the program then either restarts from the i n i t i a l state  backs up to the immediately preceeding state  or returns to the goal-handling node. 
　　　the problem solver is 	constrained 	in 	three ways. 
　　　1. context independence-the rules by which the system sets subgoals  generates actions  and censors actions are restricted to perform tests on the current knowledge-state only. this constraint implies that the choice of action in the current knowledge-state cannot depend on the history of the problem solving attempt. looking forward in time  it implies that the problem solver cannot plan in the sense of deciding upon a sequence of actions. in short  action selection is localized to the current knowledge state. 
　　　1. fragmentary path memory-the program has four different knowledge-states available: the i n i t i a l state  the state in which the current goal was set  pushed  or popped  the current state  and the immediately proceeding state. immediately after action execution  five states are available  because what was formerly the  immediately preceeding state  is not deleted u n t i l after evaluation of the new state. thus  the evaluation node has a slightly wider view of the solution path than the other nodes. 
　　　1. incomplete search control-since deleted states are lost the program cannot backup to any arbitrary state. search is organized as follows: immediately upon entering a new state  that state is evaluated statically. if the outcome is negative  a backup is made to the immediately preceeding state. if the outcome is positive  an effort is made to push ahead: if dynamic evaluation reveals that the state i s   after a l l   bad  then one of the bad actions is taken anyway. if dynamic evaluation shows that there are no 
 legal  actions in the current state  the program restarts from the i n i t i a l state. 
　　　these constraints are studied because they exemplify the kind of constraints which can be caused by psychologically relevant memory limitations  eg limited capacity working memory. 
	s. ohlsson 	1 
c. learning mechanisms 
　　　the learning strategy of the program is to notice situations in which some production rule should have f i r e d   but did not. for example  an action with a good outcome should have been suggested by some proposer rule  because it is the task of those rules to know about good actions. if it were  in fact  generated by task-independent methods  then some change in the set of proposers is called for. the program then assembles a production instantiation which corresponds to that instantiation which would have f i r e d   had there been any proposer capable of f i r i n g . next  it t r i e s to generalize existing proposers in such a 
　　　way that one of them acquires the a b i l i t y to generate that instantiation. if no existing proposer can be generalized to cover the instantiation  a situation-specific production is created and added to production memory  to constitute raw material for future generalization attempts . similarly for the creation of the other types of rules. 
　　　revision of existing productions is done through a generalization algorithm. the algorithm is written as a lisp program  and constitutes about half the code of the entire upl program. it takes any two lisp s-expressions as input and generalizes the f i r s t of them in such a wav that it would match against the second  if the two of them were given as inputs to the pss pattern matcher. the complexity of the algorithm depends to a large extent on i t s a b i l i t y to handle pss sequence variables  see above . for example  
given the three expressions  ep  p =  q  p = q   
 ep  a r  b  a * b   and 
　　　　　　 ep  c1 c  =  b  c1 c1   b   where a l l atoms are interpreted as constants  the algorithm responds with the expression 
　　　　　　 ep  x1  seq   x1  seq  * x1   where x1 and x1 are ordinary variables and  seq  is a sequence variable. 
　　　the algorithm delivers some output for any pair of inputs; if the two s-expressions given to it have nothing in common  it w i l l report a single variable. the algorithm computes an interpretable measure of how much i t s f i r s t argument had to be changed in order to  cover  i t s seoond argument. this measure is used to direct search through the space of possible generalizations. if the algorithm finds a generalization  the corresponding production is revised. there is only one generalization algorithm; thus  proposers  censors  and subgoaling rules are revised in a uniform way. 
　　　revision of productions is attempted under the following conditions. if an action has a good outcome  try to revise the proposers so that they can produce that action in the future. the criterion for a good outcome is that the current knowledge-state has a higher overlap with the 
1 s. ohlsson a c t i v e goal than the preceeding s t a t e   i e t h a t i t has more knowledge-elements in common.  the program can use a t a s k - s p e c i f i c e v a l u a t i o n f u n c t i o n   i f the user cares t o s p e c i f y one.  the ease f o r censor r u l e s is analoguous: if an a c t i o n has a negative outcome  t r y to r e v i s e the censor r u l e s . i f a s t a t e i s i n t e r e s t i n g   w i t h o u t being e i t h e r good or bad  t r y to r e v i s e the subgoaling r u l e s so t h a t they w i l l set up t h a t s t a t e as subgoal. in s h o r t   the l e a r n i n g behavior of the program is governed by i t s conception of good  bad  and i n t e r e s t i n g knowledge-states. fine t u n i n g of the l e a r n i n g mechanisms proceeds mainly by a d j u s t i n g the c r i t e r i a f o r those three c a t e g o r i e s . 
	iii results 	and 	discission 
       the upl1 program learns s u c c e s s f u l l y in several puzzle domains  i n c l u d i n g the m i s s i o n a r i e s and cannibals problem  the tower of hanoi p u z z l e   and the t i l e s and squares t a s k . it solves the f i r s t - m e n t i o n e d problem w i t h o u t search or unnecessary steps on i t s f i f t h pass over the problem. the simpler t i l e s and squares problem is solved through the miminal s o l u t i o n path already 
o n the f i r s t t r i a l . 
       i n t e r e s t i n g l y   the   l e a r n i n g s t y l e   o f the program v a r i e s w i t h the task t o which i t i s a p p l i e d . in the t i l e s and squares puzzle  the program learns mainly through the a c q u i s i t i o n of proposers. i t creates r u l e s o f the form   i f i t i s p a r t of the goal to place o b j e c t x in p o s i t i o n y  and p o s i t i o n y is empty  then move x to y . the censors and the subgoaling r u l e s created are unimportant f o r subsequent problem s o l v i n g . indeed  the two acquired subgoaling r u l e s are never a p p l i e d . in c o n t r a s t   in the tower of hanoi t a s k   upl 1 improves mainly by l e a r n i n g to decompose the top goal i n t o the a p p r o p r i a t e sequence o f subgoals  i e i t discovers t h a t g e t t i n g d i s c s 1  1  and 1 onto some peg x i m p l i e s g e t t i n g 1 and 1 onto x  which in t u r n i m p l i e s g e t t i n g 1 onto x. the d i f f e r e n c e between the two tasks which i s r e s p o n s i b l e f o r the d i f f e r e n c e i n l e a r n i n g behavior is t h a t more work is necessary before p a r t of the top goal becomes s a t i s f i e d in t h e tower of hanoi problem than in the simpler problem. 
       on the m i s s i o n a i r i e s and cannibals problem  on the other hand  upl1 l e a r n s mainly by the a c q u i s i t i o n of censors. the only general proposer it can f i n d f o r t h i s task is  when there are two c a n n i b a l s and a boat on one s i d e   and a s i n g l e c a n n i b a l on the o t h e r   then l e t the two cannibals row a c r o s s     which  as it happens  c o r r e c t l y generates two of the steps on the s o l u t i o n p a t h . the d i f f e r e n c e between the problems which causes t h i s d i f f e r e n c e i n l e a r n i n g behavior i s simply t h a t there are fewer r e g u l a r i t i e s to be detected in the problem space f o r t h i s problem than in the very r e g u l a r spaces associated w i t h the other two t a s k s . 
       there are two basic phenomena of human l e a r n i n g which upl1 seems incapable of mimicking. 
       1 . e x p o n e n t i a l l y decreasing l e a r n i n g c u r v e s - i t is a basic f e a t u r e of human l e a r n i n g t h a t change i s most r a p i d d u r i n g the i n i t i a l encounter w i t h a new t a s k . an e a r l i e r v e r s i o n of upl had r e l a t i v e l y f l a t l e a r n i n g curves  and so does upl1. we conjecture t h a t   e m p i r i c a l   or   i n d u c t i v e   l e a r n i n g systems in general w i l l have d i f f i c u l t i e s in mimicking t h i s property of human l e a r n i n g . there is a c e r t a i n tension between r a p i d i n i t i a l change and l e a r n i n g through g e n e r a l i z a t i o n over a sequence of successively encountered i t e m s   or i n s t a n c e s . 
       1 . automatization-by a u t o m a t i z a t i o n i s meant t h a t the amount of computational e f f o r t  eg number of production system c y c l e s   to reach s o l u t i o n on a problem decreases in the abscence of improvements in the s o l u t i o n . the same sequence o f  moves   s t e p s   i n f e r e n c e s   e t c .   i s generated  but w i t h l e s s work. this is a c e n t r a l f e a t u r e of human l e a r n i n g . however  it does not appear in the behavior of upl1  because the number of p r o d u c t i o n system cycles needed to make a move does not decrease as new h e u r i s t i c s are a c q u i r e d . automatization r e q u i r e s a move-chunking or composition mechanism. 
