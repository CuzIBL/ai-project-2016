 
　　　　　automatic 	debugging 	is 	examined 	in 	the context 	of 	compiler 	correctness. 	a 	system 	is described whose goal is to prove the correctness of t r a n s l a t i o n s 	i n v o l v i n g 	h e u r i s t i c a l l y 	optimized code. 	the class of e r r o r s that can be detected and corrected using such a system is also discussed. 
keywords and phrases: debugging  compilers  error d e t e c t i o n   e r r o r c o r r e c t i o n   program v e r i f i c a t i o n 
introduction 
           in lsamet1a  we describe the use of a compiler t e s t i n g system  samet 1  in detecting errors in h e u r i s t i c a j l y optimized code as well as the prospects f o r automatically c o r r e c t i n g them. this work is motivated by the r e a l i z a t i o n that often there is no a p r i o r i knowledge of how c e r t a i n computer programs are to be optimized. in such a case  there may be a need to resort to h e u r i s t i c s ; thereby n e c e s s i t a t i n g a mechanism for v e r i f y i n g that the various attempts at o p t i m i z a t i o n do indeed l u n c t i o n p r o p e r l y . 
           compiler t e s t i n g is a technique of proving that given a compiler  or any t r a n s l a t i o n procedure  and a program to be compiled  the t r a n s l a t i o n has been c o r r e c t l y performed. compiler t e s t i n g r e l i e s on the existence of an intermediate r e p r e s e n t a t i o n common to both the source and object programs. this representation r e f l e c t s a l l o i ' the computations performed on a l l possible execution paths. given the existence of such a r e p r e s e n t a t i o n   the t e s t i n g procedure consists of three steps. f i r s t   the nigh l e v e l language program is converted to the intermediate representation v i a the use of a s u i t a b l e set of syntactic  transformations  samet1b . second  the low l e v e l program must be converted to the intermediate r e p r e s e n t a t i o n . this is achieved by use of a process termed symbolic i n t e r p r e t a t i o n  samet1  which i n t e r p r e t s procedural descriptions of low l e v e l machine operations to b u i l d the intermediate r e p r e s e n t a t i o n . t h i r d   a check must be performed of the equivalence of the two representations. this check is in the form of a procedure which applies equivalence preserving transformations to the r e s u l t s of the f i r s t two steps in attempting to reduce them to a common r e p r e s e n t a t i o n . this technique has been applied to lisp and pdp-l1 assembly language. 
errors 
           errors in the t r a n s l a t e d program that are caused by the t r a n s l a t i o n process are categorized i n t o four classes. errors of the f i r s t class are detected by the symbolic i n t e r p r e t a t i o n procedure while the remaining three classes are detected during the proof procedure as computations are being matched in the two intermediate r e p r e s e n t a t i o n s . 
 1  errors p e r t a i n i n g to the well-iormedness of the program 	include 	improper 	c a l l i n g 	sequences  i l l e g a l 	stack 	p o i n t e r 	formats  	i l l e g a l operations 	on 	c e r t a i n 	high 	level 	data s t r u c t u r e s   	e t c . 
 1  a l l of the computations in one of the intermediate representations were found to e x i s t in the other r e p r e s e n t a t i o n   but the 
*this work 	was supported in 	part by 	the advanced 
research projects agency of the department of defense under contract dahc 1-c-1. the views expressed are those of the author. 
reverse is not t r u e . such an error may a r i s e when c e r t a i n side e f f e c t computations occur in one of the programs and not in the other. a l t e r n a t i v e l y   t h i s may also arise when c e r t a i n t e s t s are performed in one program and not in the other. 
 1  there are occasions when each of the intermediate representations r e f l e c t s the performance of the same computations along each execution path  y e t   the two representations are not i d e n t i c a l . this occurs when the r e s u l t s of the  execution paths are d i i f e r e n t . 
 1  the actual proof procedure may reach a point at which it cannot continue. this is the case when a f u n c t i o n in the intermediate representation oi the low l e v e l program can not be matched with a function in the intermediate representation corresponding to the o r i g i n a l 
	high level 	program. 
	e r r o r c o r r e c t i o n 	is a d i f f i c u l t 	task. 	in 
 samet1a  we show how the following h e u r i s t i c s are used to debug an i n c o r r e c t l y translated complex f u n c t i o n  1 i n s t r u c t i o n s   . whenever an error occurs in a f u n c t i o n   we determine if the error is caused by the wrong function being applied to a set of arguments or the correct function being applied to the wrong set of arguments. our approach is f i r s t to attempt to correct the f u n c t i o n . next  an attempt is made to correct the arguments. when c o r r e c t i n g arguments  we know the accumulators which must contain the arguments and thus we can work backwards to determine where and when the wrong values were computed and loaded i n t o the accumulators. often the debugging process is aided by the presence of i n s t r u c t tons that manipulate data that w i l l no longer be referenced in the program. such i n s t r u c t i o n s often serve as candidates for removal and replacement by the correct i n s t r u c t i o n . errors also occur frequently in t e s t i n g the wrong sense of a c o n d i t i o n . this is especially common with arithmetic r e l a t i o n s such as less than and greater than. such occurrences are signaled by the presence of e r r o r s in both subtrees of a c o n d i t i o n in close proximity   i n terms of the logical flow of the program  to the i n s t r u c t i o n at 
which the condition is tested. this can be corrected in the f o l l o w i n g manner. reverse the sense  of the t e s t . if a l l of the errors disappear  then the diagnosis is c l e a r l y c o r r e c t . if some of the errors disappear  then the diagnosis is q u i t e l i k e l y to be v a l i d . the previous is e s p e c i a l l y true if at least one error in each subtreedisappears a f t e r making the change. note that changing the sense of the test may lead to new e r r o r s . however  as long as some of the current errors disappear  the c o r r e c t i o n is l i k e l y to be valid. 
　　　　　the above h e u r i s t i c s were used in a manual process to debug the erroneous program. we believe that many of these errors could be corrected a u t o m a t i c a l l y . however  there is a need to continue exercising the proof system with erroneous encodings to determine it any more error c o r r e c t i o n h e u r i s t i c s can be discovered. 
