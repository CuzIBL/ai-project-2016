t r a n s a c t i o n a l blackboards 
j. robert ensor and john d. gabbe 
a t & t bell laboratories holmdel  nj 1 

a b s t r a c t 
　　the blackboard architecture is a popular structuring framework for expert systems. with this structure  an expert system is built as a collection of knowledge sources which are scheduled by a controller and communicate through a shared data region  called a blackboard. the performance of such a system may be significantly enhanced by the concurrent execution of the knowledge sources. however  introduction of concurrent execution into blackboard systems requires extension of the architecture with new mechanisms for scheduling knowledge source activities  synchronizing knowledge source interactions  and accessing shared data. this paper describes our design for transactionbased facilities supporting parallel execution of knowledge sources in a blackboard system. 
i. i n t r o d u c t i o n 
　　the blackboard architecture is an important structural framework for expert systems. in this architecture  an expert system consists of a shared data region  called the blackboard   a set of knowledge sources  and a control mechanism. the blackboard is a data base which is shared by the knowledge sources as their communication medium. containing rules and hypotheses which express the domain expertise of the system  the knowledge sources respond to each other through observed changes in the blackboard. the control mechanism schedules execution of the knowledge sources according to information from its goal queues and the blackboard. 
　　several expert systems have been built according to the blackboard architecture. examples include a speech-understanding system  erman et al  1   a sonar interpretation system  nil and feigenbaum  1   a vehicular tracking system  lesser and corkill  1   and a protein crystallography interpretation system  terry  1 . although these systems are founded on the blackboard architecture  they vary significantly within the framework  demonstrating the utility and flexibility of the paradigm. experience suggests that this architecture is particularly suitable for systems representing multiple areas of expertise and for systems solving problems with complex information interdependences. 
　　multiprocessor computing environments should be capable of increasing the scope and utility of expert systems and successfully addressing problems beyond the reach of most uniprocessors  such as real time speech recognition or robot control. the domain and control knowledge of an expert system may be distributed onto several processors. the interactions of modular knowledge sources may simulate their modeled events  with both communication paths and timing of interactions. thus multiprocessor configurations have the potential to support the construction and execution of expert systems with new and useful properties. 
multiprocessor computers are often difficult to use. 
while the processors can execute in parallel  the exchange of data  code  and results among these processors can often make the overall system slow. therefore  a balance must be reached among the costs of loading code  accessing data  and communicating requests and responses. two extreme approaches have received most attention by researchers. at one extreme are systems in which processing nodes frequently exchange small sets of data and do small computations with each data set  e.g.  dennis  1 . at the other extreme are systems that place a large  autonomous program on each processing node. in these systems  the nodes exchange data infrequently and spend most of their time performing  local  computations  e.g.  lesser  1 . the work described in this paper focuses on supporting systems closer to the latter extreme. we present mechanisms for constructing expert systems as collections of knowledge sources communicating through a shared data medium. these are systems in which knowledge sources executing on different processors perform moderate to large computations between communications. 
　　the integrity of data that is accessed asynchronously by several clients must be maintained. providing transactional access to shared data bases is a common solution to this problem. a sequence of operations on one or more data elements  beginning with a start-tran1action request and ending with either a 

commit- or an abort-transaction request  a transaction is a unit of activity with three properties: atomicity  consistency preservation  and permanence. atomicity means that  in net effect and even when failures occur  either all operations in the unit happen  the transaction commits  or none of them happens  it aborts . consistency preservation means that a transaction moves data from one consistent state to another. permanence means that the effect of a committed transaction persists  surviving any noncat as trophic failures  until the next transaction involving that data is committed. 
　　we extend the blackboard architecture to support systems executing in multiprocessor environments by providing transactional access to the blackboard. our extensions are novel in their ease of use and in the richness of structure that they support. two mechanisms are provided for safe access to the blackboard data. knowledge sources can communicate by accessing shared data in separate transactions. furthermore  several knowledge sources can participate in a common transaction if they need to see a common  consistent view of shared data. 
ii. system structure 
　　figure 1 illustrates a system that we designed to understand the use of the blackboard. we term the control and knowledge sources agents because they are both modular units of activity. the agents are distributed on various processors and may execute concurrently. knowledge source activities on each node are controlled by the control sources on that node.  the collection of control sources is the controller mentioned in the blackboard architecture description.  in our present implementation  the distribution of agents is subject to restrictions. the initial distribution is specified by the system designer  and we provide no mechanism to support agent migration among processors. although the blackboard resides on a single machine  it could be distributed without changing its interface. 

figure la 
network of processing nodes 
	j. ensor and j. gabbe 	1 
a. the blackboard 
　　the blackboard is a repository of data; each datum holds an arbitrary lisp s-expression. because agents may share data and reference them in an interleaved fashion  some mechanism is needed to maintain consistency of the blackboard. we associate a transaction manager with this data base  and require that any reference to the blackboard be part of a transaction. 
　　the blackboard transaction manager controls asynchronous references to shared data via locks. there are two types of locks: write and read. the holder of a write-lock has exclusive access to the locked datum and may modify the datum. holders of read-locks may read the datum concurrently. no writer may access a datum while a read-lock for that datum is held. when a client first references a datum  the transaction manager attempts to obtain the appropriate lock. all locks are held to the end of the transaction in which they were obtained. thus the transaction manager preserves data consistency by preserving serializability  eswaran  1 . 
　　when trying to obtain a lock  the transaction manager might find that it is not available. the transaction that needs the unavailable lock is suspended until the lock can be obtained. sometimes more than one transaction may be waiting to obtain a lock  and this introduces the potential for deadlock among the waiting transactions. for example  transaction a might wait for a lock held by transaction b  while transaction b waits for some other lock held by transaction a. the transaction manager detects deadlocks and resolves them by aborting a suspended transaction. this abortion is simply reported to the agents participating in the transaction; these agents must then decide what action is appropriate. 
   data consistency among agents interacting within a transaction is maintained by time stamps. if serializability among agents within a transaction is violated  

figure lb 
agents within a node 

1 	j. ensor and j. gabbe 
the blackboard transaction manager aborts the transaction. this abortion is reported to the agents participating in the transaction  as with deadlock detection. 
　　computation based on the transactional blackboard is not data driven; that is  accessing values in the blackboard does not automatically trigger agent activity. this seems appropriate in a distributed environment because the blackboard might not be able to schedule activities on remote sites. this is in 
contrast to the centralized case supported in previous proposals  e.g.  the hearsay iii approach of balzer et al  1 . 
b. the agents 
　　each knowledge source contains some of the system's domain specific knowledge. this knowledge is expressed in terms of the data visible to the agent that portion of the blackboard accessible to the agent plus those data sent as message parameters by other agents. as a knowledge source executes  it examines the visible system state. if the system state matches a condition known to the knowledge source  the agent takes specified actions. these actions include requesting that the controller schedule a knowledge source activity by placing an entry on the controller goal queue  performing some operations on the blackboard  and/or sending a message to another knowledge source. 
c. inter-agent communication 
　　the multiprocessor environment fosters a richness of system structure. each processor can support a 
　　community of agents - complexes of control sources and groups of knowledge sources working closely together - and these communities can interact with communities on other processors. agents executing on the same machine can communicate with efficiency and facility  for they may directly access common data and may include arbitrary references as parameters in the messages that they send to each other. since the cost of message transmission between machines is higher than a few memory references on a single one  agents executing on separate machines cannot communicate so cheaply. further  these agents may include only values in their message parameters  and the conversion of local data to transmittable data values may be expensive. each node in our system then contains procedures to convert the value of arbitrary s-expressions to transmittable data values. in addition  each communicating agent needs access to procedures to reference these transmitted data values once they have been received. 
   agents may also communicate through the blackboard  and two mechanisms are provided for this interaction. agents can interact by accessing shared data in separate transactions  or several agents can participate in a common transaction. this latter mechanism is often useful; for example  the controller might start a transaction to check the precondition of a goal-queue entry. the knowledge source that the controller then activates might need to access the data mentioned in the goal-queue entry. because the knowledge source should see these data in the same state as the controller  it continues the same transaction. to include a second agent in a transaction  the first agent merely passes its transaction identifier and status to the second. the transaction status indicates whether the transaction is to be committed  aborted  or continued. 
d. scheduling and transaction protocols 
　　the controller maintains one or more goal queues  each comprised of entries generated by knowledge sources. a goal-queue entry has three parts: an expression  called the precondition   an action to be taken if that precondition is true  and a status indicator which may contain a transaction identifier if the action is to continue an on-going transaction. 
　　scheduling activity by selecting entries from its goal queue  the controller proceeds down the goal queue evaluating entry preconditions. if the precondition is false  its action can not be selected  and the goal is deferred. if the precondition holds  the corresponding action is executed. in evaluating a precondition  the controller might need to access data in the blackboard. if there is no transaction identifier associated 
with the queue entry  the controller begins a new transaction. if an identifier is already associated with the queue entry  the controller continues this transaction. at the end of the decision process  the controller aborts the newly-started transactions associated with deferred goals. if an agent is activated as a result of the queue entry selection  that agent is given any associated transaction identifier. 
　　in addition to scheduling  the control agents are responsible for the initiation and termination of transactions. these activities are based on the contents of the goal queues. as mentioned above  the controller begins a transaction or continues an existing one when it schedules a knowledge source for activity. when an agent finishes executing  it notifies the controller. the controller now checks the goal queue for entries with the transaction identifier of the knowledge source just completed. if the queue has no entries with this transaction identifier  the controller terminates the transaction according to the transaction status. if other entries contain this identifier  the associated actions will presumably continue this transaction. 
iii. implementation 
　　our initial implementation of an expert system using the transactional blackboard is designed to execute on a network of three symbolics lisp machines connected via an ethernet. zetalisp flavors  weinreb  1   the blackboard and knowledge and control sources communicate with each other via messages  the parameterized invocations of flavor methods. the 

message parameter restrictions discussed above are enforced at run-time by the execution environment. the blackboard transaction manager  which reads or writes objects on behalf of agent requests  and its associated data base reside on a single machine. 
a. data 
   lisp s-expressions are the unit of storage and retrieval in the blackboard  and a blackboard datum is indexed by a lisp name. because the blackboard has no knowledge of the internal structure of the data it stores  the storage and retrieval support functions available to an agent are responsible for constructing transmittable data for storage and reconstructing the representations on retrieval. generally  these functions need access to the definitions of the data in order to reconstruct their representations. 
b. transactions 
   access to the blackboard data is allowed only within transactions. the transaction manager associated with the blackboard receives requests from agents  executes on their behalf  and packages responses. with each request to the blackboard  an agent presents a unique agent identifier and a transaction identifier. the transaction identifier is returned to an agent when it begins a transaction as a return 
value of the start-transaction command. 
　　the blackboard transaction manager supports five transaction states and state-changing messages. figure 1 illustrates these states and the messages that cause state transitions. starting in the ground state  a transaction moves with the start-transaction message into the active state where read and write messages are handled. commit- and abort-transaction messages terminate a transaction by moving it to the committed and ground states respectively. the straddle and precommitted states provide for the implementation of two- and three-phase commit protocols  skeen  1   which are a means of coordinating transactions involving more than one transactional server. 
1. a t o m i c i t y . atomicity ensures that at the end of a transaction all the write actions associated with the transaction have taken place  the transaction commit-

figure 1 
transaction states 
	j. ensor and j. gabbe 	1 
ted   or all the data referenced by the transaction are restored to the state that existed when the transaction began  the transaction aborted . in each transaction  an existing datum is copied before it is first written.  if there is no existing datum  the  copy  so indicates.  this copy then serves to save the state of the datum that existed before the transaction began. if the transaction commits  the copy is discarded; if the transaction aborts  the copy replaces the current version of the datum. 
1. consistency. our transactional blackboard has two broad consistency tasks: first  to maintain data consistency among several transactions  intertransactional consistency   and second  to preserve a consistent view of data for those agents within an individual transaction  intra-transactional consistency . 
　　inter-transactional consistency of blackboard data is maintained with locks. the write locks are exclusive and guarantee that no activity can interfere with the writer while it is modifying data. read locks are shared  and many agents may concurrently read a datum. since the datum is not modified during this time  consistency is maintained. all locks are held to the end of the transaction  and requests made to locked data are queued until release of locks. 
　　the transaction manager checks for deadlock whenever it queues a read or write request. in the present implementation  the blackboard retries queued requests referencing a particular datum in the order in which they are received. if a deadlock exists  the manager calls a deadlock handler to abort one of the transactions. although the transaction manager contains a default handler  a preferred deadlock handler may be specified by an agent when it initiates a transaction to allow deadlock resolution to be based on domain knowledge. 
　　intra-transactional consistency is maintained through the use of time-stamps. the time stamps are used to enforce serialization through a basic timeordered scheduling algorithm  bernstein  1 . when an agent first participates in a transaction  it is assigned a time-stamp  called the agent time for that agent. the write time-stamp for each blackboard datum is the agent time of the write request being executed on that datum. the read time-stamp for each datum is the later of the datum's current read timestamp and the agent time of the read request being executed on that datum. a datum maintains a separate read time-stamp for each transaction holding a read-lock. a read request for a datum is rejected if the agent time is earlier that the datum's write timestamp. a write request is rejected if the agent time is earlier than either the read or write time stamp of the datum. the establishment of a serializable intratransaction schedule and concomitant coordination of the participating agents is the responsibility of the agent controlling the transaction. the blackboard regards an intra-transaction time-order violation as a 1 	j. ensor and j. gabbe 
fatal error and aborts the offending transaction. the blackboard's transaction manager checks for possible time-order violations before queuing a store or retrieve request  so the errors are detected immediately. 
1. persistence. persistence ensures that the results of committed  and straddled and precommitted  transactions will survive system crashes. to implement persistence  copies of data are kept on devices with independent failure modes and recovery protocols are supported. we use a straightforward logging and checkpoint scheme to preserve copies on independent devices. the implementation might be expensive in both space and time. it is not practical to encumber all agents with this overhead  and thus logging can be deactivated for any transaction. if a transaction is not logged  crash recovery returns its data to some previous  archived  consistent state  instead of the most recent consistent state. the recovery protocols are not expensive to implement because they are driven by external agents  not the blackboard itself. 
iv. conclusions 
　　our transactional blackboard architecture supports the construction of expert systems for multiprocessor environments. the transactional interface allows asynchronous requests to be safely issued to the shared data of the blackboard. clients of this transactional service must specify the boundaries of each transaction  and they must deal with aborted transactions. we feel that this marginal cost over a serial system is small and should not interfere with the business of building expert systems. 
   more importantly  we provide mechanisms to make use of this shared data in an intelligent way. control decisions are based on domain knowledge and communication costs. the controller presumably tries to utilize the processors of the computing facility to effect good system performance or to model some system of interest. the controller remains knowledge-based and does not use scheduling to protect shared data. knowledge sources are not required to provide explicit synchronization or protect the consistency of shared data. if several agents wish  they may participate in common transactions. to do so  they only need to pass transaction identifiers among themselves. 
　　we are using this architecture to build some expert systems. our experience indicates that this architecture is very helpful for large  multi-author projects  where each designer works rather independently to implement a small area of expertise. in addition to reaffirming the advantages of modularity in program structure  we would like to report on the performance advantages realized by executing our expert systems on multiprocessor computers. unfortunately  we have not yet performed the necessary experiments. 
