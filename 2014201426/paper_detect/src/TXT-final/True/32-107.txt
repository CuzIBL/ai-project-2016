 
agent-based computing represents an exciting new synthesis both for artificial intelligence  ai  and  more generally  computer science. it has the potential to significantly improve the theory and the practice of modelling  designing  and implementing complex systems. yet  to date  there has been little systematic analysis of what makes an agent such an appealing and powerful conceptual model. moreover  even less effort has been devoted to exploring the inherent disadvantages that stem from adopting an agent-oriented view. here both sets of issues are explored. the standpoint of this analysis is the role of agent-based software in solving complex  real-world problems. in particular  it will be argued that the development of robust and scalable software systems requires autonomous agents that can complete their objectives while situated in a dynamic and uncertain environment  that can engage in rich  highlevel social interactions  and that can operate within flexible organisational structures. 
1 	introduction 
an increasing number of computer systems are being viewed in terms of autonomous agents. agents are being espoused as a new theoretical model of computation that more closely reflects current computing reality than hiring machines  wegner  1 . agents are being advocated as the next generation model for engineering complex  distributed systems  wooldridge  1 . agents are also being used as an overarching framework for bringing together the component ai sub-disciplines that are necessary to design and build intelligent entities  russell and norvig  1   despite this intense interest  a number of fundamental questions about the nature and the use of agents remain unanswered. in particular: 
 what is the essence of agent-based computing  
 what makes agents an appealing and powerful conceptual model   what are the drawbacks of adopting an agent-oriented approach  
  what are the wider implications for ai of agent-based computing  
　these questions can be tackled from many different perspectives  ranging from the philosophical to the pragmatic. this paper p r o i d s from the standpoint of using agentbased software to solve complex  real-world problems. however in the course of this analysis  a number of broader points are made about the general direction and emphasis of future ai research. 
　building high quality software for complex  real-world applications is difficult. indeed  it has been argued that such developments are one of the most complex construction tasks humans undertake  both in terms of the number and the flexibility of the constituent components and in the complex way in which they are interconnected . moreover  this statement is true no matter what models and techniques are applied: it is a consequence of the  essential complexity of software   brooks  1 . such complexity manifests itself in the fact that software has a large number of parts that have many interactions  simon  1 . given this state of affairs  the role of software engineering is to provide models and techniques that make it easier to handle this complexity. to this end  a wide range of software engineering paradigms have been devised  e.g. object-orientation  booch  1; meyer  1   component-ware  szyperski  1   design patterns  gamma et al.   1  and software architectures  buschmann et al.  1  . each successive development either claims to make the engineering process easier or to extend the complexity of applications that can feasibly be built. although evidence is emerging to support these claims  researchers continue to strive for more efficient and powerful techniques  especially as solutions for ever more demanding applications are sought. 
　in this article  it is argued that although current methods are a step in the right direction  when it comes to developing complex  distributed systems they fall short in three main ways:  i  the basic building blocks are too fine grained;  ii  the interactions are too rigidly defined; or  iii insufficient mechanisms are available for dealing with organisational structure. furthermore  it will be argued that: agent-oriented 
	jennings 	1 

approaches can significantly enhance our ability to model  design and build complex  distributed  software systems. 
 the remainder of the paper is structured as follows. section 1 discusses the essence of agent-based computing. section 1 makes the case for an agent-oriented approach to software engineering. section 1 provides a brief case study to back up the paper's main arguments. finally  section 1 outlines an approach for tackling some of the key open problems that need to be addressed if agent-based computing is to reach its full potential. 
1 	the essence of agent-based computing 
the first step in arguing for an agent-oriented approach to software engineering is to precisely identify and define the key concepts of agent-oriented computing. here the key definitional problem relates to the term  agent . at present  there is much debate  and little consensus  about exactly what constitutes agenthood. however  an increasing number of researchers find the following characterisation useful: 
an agent is an encapsulated computer system that is situated in some environment  and that is capable of flexible  autonomous action in that environment in order to meet its design objectives  wooldridge  1  
　there are a number of points about this definition that require further explanation. agents are:  i  clearly identifiable problem solving entities with well-defined boundaries and interfaces;  ii  situated  embedded  in a particular environment-they receive inputs related to the state of their environment through sensors and they act on the environment through effectors;  iii  designed to fulfill a specific purpose-they have particular objectives  goals  to achieve;  iv  autonomous-they have control both over their internal state and over their own behaviour;  v  capable of exhibiting flexible problem solving behaviour in pursuit of their design objectives-they need to be both reactive  able to respond in a timely fashion to changes that occur in their environment  and proactive  able to opportunistically adopt new goals   wooldridge and jennings  1 . 
　when adopting an agent-oriented view of the world  it soon becomes apparent that most problems require or involve multiple agents  to represent the decentralised nature of the problem  the multiple loci of control  the multiple perspectives  or the competing interests. moreover  the agents will need to interact with one another  either to achieve their individual objectives or to manage the dependencies that ensue from being situated in a common environment. these interactions can vary from simple information interchanges  to requests for particular actions to be performed and on to cooperation  coordination and negotiation in order to arrange inter-dependent activities. however  whatever the nature of the social process there are two points that qualitatively differentiate agent interactions from those that occur in other software engineering paradigms. firstly  agent-oriented 
1 	awards 
interactions occur through a high level  declarative  agent communication language. consequently  interactions are conducted at the knowledge level  newell  1 : in terms of which goals should be followed  at what time  and by whom  cf. method invocation or function calls that operate at a purely syntactic level . secondly  as agents are flexible problem solvers  operating in an environment over which they have only partial control and observability  interactions need to be handled in a similarly flexible manner. thus  agents need the computational apparatus to make context-dependent decisions about the nature and scope of their interactions and to initiate  and respond to  interactions that were not foreseen at design time. 
　in most cases  agents act to achieve objectives either on behalf of individuals/companies or as part of some wider problem solving initiative. thus  when agents interact there is typically some underpinning organisational context. this context defines the nature of the relationship between the agents e.g. they may be peers working together in a team or one may be the manager of the other agents. in any case  this context influences an agent's behaviour. thus it is important to explicitly represent the relationship. in many cases  relationships are subject to ongoing change: social interaction means existing relationships evolve and new relations are created. the temporal extent of relationships can also vary significantly  from just long enough to deliver a particular service once  to a permanent bond. to cope with this variety and dynamic  agent researchers have: devised protocols that enable organisational groupings to be formed and disbanded; specified mechanisms to ensure groupings act together in a coherent fashion; and developed structures to characterise the macro behaviour of collectives  jennings and wooldridge  1; wooldridge and jennings  1 . 
　drawing these points together  figure 1   the essential concepts of agent-based computing are: agents  high level interactions and organisational relationships. 

figure 1: canonical view of an agent-based system 

1 agent-oriented software engineering 
the most compelling argument that can be made for adopting an agent-oriented approach to software development is to have a set of quantitative data that showed  on a standard set of software metrics  the superiority of the agent-based approach over a range of other techniques. however such data does not exist. hence arguments must be qualitative in nature. 
 the structure of the argument that will be used here is as follows. on one hand  there are a number of well-known techniques for tackling complexity in software. also the nature of complex software systems is  reasonably  well understood. on the other hand  the key characteristics of the agent-based paradigm have been elucidated. thus an argument can be made by examining the degree of match between these two perspectives. 
　before this argument can be made  however  the techniques for tackling complexity in software need to be introduced. booch  identifies three such tools: 
 decomposition: the most basic technique for tackling large problems is to divide them into smaller  more manageable chunks each of which can then be dealt with in relative isolation. this helps tackle complexity because it limits the designer's scope; at any given instant only a portion of the problem needs to be considered.  abstraction: the process of defining a simplified model of the system that emphasises some of the details or properties  while suppressing others. again  this technique works because it limits the designer's scope of interest at a given time. attention can be focused on the salient aspects of the problem  at the expense of the less relevant details. 
 organisation1: the process of identifying and managing the inter-relationships between the various problem solving components. the ability to specify and enact organisational relationships helps designers tackle complexity in two ways. firstly  by enabling a number of basic components to be grouped together and treated as a higher-level unit of analysis  e.g. the individual components of a sub-system can be treated as a single unit by the parent system . secondly  by providing a means 
of describing the high-level relationships between various units  e.g. a number of components may work together to provide a particular functionality . 
next  the characteristics of complex systems need to be enumerated  simon  1 : 
 complexity frequently takes the form of a hierarchy. that is  a system that is composed of inter-related subsystems  each of which is in turn hierarchic in structure  until the lowest level of elementary sub-system is reached. the precise nature of these organisational relationships varies between sub-systems  however some generic forms  such as client-server  peer  team  etc.  can be identified. these relationships are not static: they often vary over time. 
  the choice of which components in the system are primitive is relatively arbitrary and is defined by the observer's aims and objectives. 
  hierarchic systems evolve more quickly than non-hier-archic ones of comparable size. in other words  complex systems will evolve from simple systems more rapidly if there are stable intermediate forms  than if there are not. 
  it is possible to distinguish between the interactions among sub-systems and the interactions within sub-systems. the latter are both more frequent  typically at least an order of magnitude more  and more predictable than the former. this gives rise to the view that complex systems are nearly decomposable: sub-systems can be treated almost as if they are independent of one another  but not quite  since there are some interactions between them. moreover  although many of these interactions can be predicted at design time  some cannot. 
with these two characterisations in place  the form of the argument can be expressed: 
  show agent-oriented decomposition is an effective way of partitioning the problem space of a complex system 
 section 1 ; 
  show that the key abstractions of the agent-oriented mindset are a natural means of modelling complex systems  section 1 ; 
  show the agent-oriented philosophy for dealing with organisational relationships is appropriate for complex systems  section 1 ; 
 having made the case that agents are well suited for engineering complex systems  a number of pragmatic issues that will affect whether agents catch on as a software engineering paradigm are examined  section 1 . finally  the downside of agent-oriented developments is discussed  section 1 . 
1 merits of agent-oriented decomposition 
complex systems consist of a number of related sub-systems organised in a hierarchical fashion. at any given level  subsystems work together to achieve the functionality of their parent system. moreover  within a sub-system  the constituent components work together to deliver the overall functionality. thus  the same basic model of interacting components  working together to achieve particular objectives  occurs throughout the system. 
　given this fact  it is entirely natural to modularise the components in terms of the objectives they achieve1. in other words  each component can be thought of as achieving one or more objectives. a second important observation is that 
	jennings 	1 

complex systems have multiple loci of control:  real systems have no top  {meyer  1  pg 1. applying this philosophy to objective-achieving decompositions means the individual components should localise said encapsulate their own con* trol thus  entities should have their own thread of control  i.e. they should be active  and they should have control over their own actions  i.e. they should be autonomous . 
 for the active and autonomous components to fulfil both their individual and collective objectives  they need to interact with one another  recall complex systems are only nearly decomposable . however the system's inherent complexity means it is impossible to know a priori about all potential links: interactions will occur at unpredictable times  for unpredictable reasons  between unpredictable components. for this reason  it is futile to try and predict or analyse all the possibilities at design-time. it is more realistic to endow the components with the ability to make decisions about the nature and scope of their interactions at run-time. from this  it follows that components need the ability to initiate  and respond to  interactions in a flexible manner. 
 the policy of deferring to run-time decisions about component interactions facilitates the engineering of complex systems in two ways. firstly  problems associated with the coupling of components are significantly reduced  by dealing with them in a flexible and declarative manner . components are specifically designed to deal with unanticipated requests and they can spontaneously generate requests for assistance if they find themselves in difficulty. moreover because these interactions are enacted through a high-level agent communication language  coupling becomes a knowledge level issue. at a stroke  this removes syntactic concerns from the types of errors caused by unexpected interactions. secondly  the problem of managing control relationships between the software components is significantly reduced. all agents are continuously active and any coordination that is required is handled bottom-up through inter-agent interaction. thus  the ordering of the system's top-level goals is no longer something that has to be rigidly prescribed at design time. rather  it becomes something that is handled in a context-sensitive manner at run-time. 
　from this discussion  it is apparent that a natural way to modularise a complex system is in terms of multiple  interacting  autonomous components that have particular objectives to achieve. in short  agent-oriented decompositions aid the process of developing complex systems. 
1 suitability of agent-oriented abstractions 
a significant part of the design process is finding the right models for viewing the problem. in general  there will be 

1  indeed the view that decompositions based upon functions/ actions/processes are more intuitive and easier to produce than those based upon data/objects is even acknowledged within the object-oriented community  meyer  1  pg 1. 
1 	awards 
multiple candidates and the difficult task is picking the most appropriate one. when designing software  the most powerful abstractions are those that minimise the semantic distance between the units of analysis that are intuitively used to conceptualise the problem and the constructs present in the solution paradigm. in the case of complex systems  the problem to be characterised consists of sub-systems  sub-system components  interactions and organisational relationships. taking each in turn: 
  sub-systems naturally correspond to agent organisa-tions. they involve a number of constituent components that act and interact according to their role within the larger enterprise. 
  the suitability of viewing sub-system components as agents has already been made  section 1 . 
  the interplay between the sub-systems and between their constituent components is most naturally viewed in terms of high level social interactions;  at any given level of abstraction  we find meaningful collections of entities that collaborate to achieve some higher level view   booch  1  pg 1. this view accords precisely 
with the treatment of interaction afforded by the agentoriented approach. agent systems are invariably described in terms of  cooperating to achieve common objectives    coordinating their actions  or  negotiating to resolve conflicts . 
  complex systems involve changing webs of relation-ships between their various components. they also require collections of components to be treated as a single conceptual unit when viewed from a different level of abstraction. here again the agent-oriented mindset provides suitable abstractions. a rich set of structures is typically available for explicitly representing and managing organisational relationships. interaction protocols exist for forming new groupings and disbanding unwanted ones. finally  structures are available for modelling collectives. the latter point is especially useful in relation to representing sub-systems since they are nothing more than a team of components working together to achieve a collective goal. 
1 need for flexible management of changing 
organisational structures 
organisational constructs are first-class entities in agent systems. thus explicit representations are made of organisational relationships and structures. moreover  agent-based systems have the concomitant computational mechanisms for flexibly forming  maintaining and disbanding organisations. this representational power enables agent-oriented systems to exploit two facets of the nature of complex systems. firstly  the notion of a primitive component can be varied according to the needs of the observer. thus at one level  entire sub-systems can be viewed as singletons  alternatively  teams or collections of agents can be viewed as primitive 

components  and so on until the system eventually bottoms out. secondly  such structures provide a variety of stable intermediate forms  that  as already indicated  are essential for the rapid development of complex systems. their availability means individual agents or organisational groupings can be developed in relative isolation and then added into the system in an incremental manner; this  in turn  ensures there is a smooth growth in functionality. 
1 software engineering pragmatics 
having made the case for an agent-oriented approach to designing and building complex systems  the next step is to determine whether it will catch on as a software engineering paradigm. this question is important because the history of computing is littered with good technologies that were never widely adopted. two key pragmatic issues are relevant here:  i  the degree to which agents represent a radical departure from current software engineering thinking and  ii  the degree to which existing software can be integrated with agents. in general  take-up is more likely if agents are consistent with the trends of software engineering  evolution rather than revolution  and if legacy software can be incorporated in a straightforward and clean manner  a brown field versus a green field scenario . 
　a number of trends become evident when examining the evolution of programming models from machine languages  to procedural and structured programming  to object-based and declarative programming  onto component-ware  design patterns  and software architectures. firstly  there has been an inexorable move from languages that have their conceptual basis determined by the underlying machine architecture  to languages that have their key abstractions rooted in the problem domain. here the agent-oriented world view is perhaps the most natural way of characterising many types of problem. just as the real-world is populated with objects that have operations performed on them  so it is equally full of active  purposeful agents that interact to achieve their objectives1. indeed  many object-oriented analyses start from precisely this perspective:  we view the world as a set of autonomous agents that collaborate to perform some higher level function   booch  1  pg. 1. secondly  the basic building blocks of the programming models exhibit increasing degrees of localisation and encapsulation  parunak  1 . agents follow this trend by localising purpose inside each agent  by giving each agent its own thread of control  and by encapsulating action selection. thirdly  ever richer mechanisms for promoting re-use are being provided. here  the agent view also reaches new heights. rather than stopping at re-use of sub-system components  design patterns and component-ware  and rigidly pre-ordained interactions  application frameworks   agents enable whole subsystems and flexible interactions to be re-used. in the former case  agent designs and implementations are re-used within and between applications. consider  for example  the class of agent architectures that has beliefs  what the agent knows   desires  what the agent wants  and intentions  what the agent is doing  at its core. such belief-desire-intention architectures have been used in a wide variety of applications including air traffic control  process control  fault diagnosis and transportation  chaib-draa  1; jennings  1; jennings and wooldridge  1 . in the latter case  flexible patterns of interaction such as the contract net protocol  an agent with a task to complete advertises this fact to others who it believes are capable of performing it  these agents may submit a bid to perform the task if they are interested  and the originator then delegates the task to the agent that makes the best bid  and various forms of resource-allocation auction  e.g. english  dutch  viekrey  have been re-used in significant numbers of applications. in short  agent-oriented techniques represent a natural progression of current software engineering thinking and  for this reason  the main concepts and tenets of the approach should be readily acceptable to software engineering practitioners. 
 the second factor in favour of a rapid take up of agents is that their adoption does not require a revolution in terms of an organisation's software capabilities. agent-oriented systems are evolutionary and incremental as legacy  non-agent  software can be incorporated in a relatively straightforward manner  jennings et al.  1 . the technique used is to place wrapping software around the legacy code. the wrapper presents an agent interface to the other software components and thus from the outside it looks like any other agent. on the inside  the wrapper performs a two-way translation function: taking external requests from other agents and mapping them into calls in the legacy code  and taking the legacy code's external requests and mapping them into the appropriate set of agent communication commands. this ability to wrap legacy systems means agents may initially be 

* although there are some similarities between object- and agentoriented approaches  e.g. both adhere to the principle of information hiding and recognise the importance of interactions   there are also a number of important differences. firstly  objects arc generally passive in nature: they need to be sent a message before they become active. secondly  although objects encapsulate state and behaviour realisation they do not encapsulate behaviour activation  action choice . thus  any object can invoke any publicly accessible method on any other object. once the method is invoked  the corresponding actions are performed. thirdly  object-orientation fails to provide an adequate set of concepts and mechanisms for modelling complex systems: for such systems  we find that objects  classes and modules provide an essential yet insufficient means of abstraction   booch  1  pg 1. individual objects represent too fine a granularity of behaviour and method invocation is too primitive a mechanism for describing the types of interactions that take place. finally  object-oriented approaches provide only minimal support for specifying and managing organisational relationships  basically relationships are defined by static inheritance hierarchies . 
	jennings 	1 

used as an integration technology. however  as new requirements are uncovered  so bespoke agents may be developed and added. this feature enables a complex system to grow in an evolutionary fashion  bated on stable intermediate forms   while adhering to the important principle that there should always be a working version of the system available. 
1 the downside 
having highlighted the potential benefits of agent-oriented software engineering  this sub-section seeks to pinpoint some of the inherent difficulties associated with agent-based systems. these problems are directly attributable to the characteristics of agent-oriented software and are  therefore  intrinsic to the approach.  these complement the more pragmatic problems that are often associated with agent-oriented projects  wooldridge and jennings  1 .  naturally  since robust and reliable agent systems have been built  designers have found means of circumventing these problems. however  at this time  such solutions tend to be made on a case by case basis. 
　much of the power of agents derives from the fact that they are situated problem solvers: they act in pursuit of their design objectives while maintaining an ongoing interaction with their environment. however such situatedness makes it difficult to design software capable of maintaining a balance between proactive and reactive behaviour. leaning too much towards the former risks the agent undertaking irrelevant or infeasible tasks  as circumstances have changed . leaning too much towards the latter means the agent may not fulfill its objectives  since it is constantly responding to short-term needs . striking a balance requires context sensitive decision making which  in turn  means there can be a significant degree of unpredictability about which objectives the agent will pursue in which circumstances and which methods will be used to achieve the chosen objectives. 
　although agent interactions represent a hitherto unseen level of sophistication and flexibility  they are also inherently unpredictable in the general case. as agents are autonomous  the patterns and the effects of their interactions are uncertain. firstly  agents decide  for themselves at run-time  which of their objectives require interaction in a given context  which acquaintances they will interact with in order to realise these objectives  and when these interactions will occur. hence the number  pattern and timing of interactions cannot be predicted in advance. secondly  there is a de-coupling  and a considerable degree of variability  between what one agent first requests through an interaction and how the recipient ultimately responds. the request may be immediately honoured as it is  refused completely  or modified through some form of social interchange. in short  both the nature  a simple request versus a protracted negotiation  and the outcome of an interaction cannot be determined at the onset. 
 the final source of unpredictability in agent-oriented system design relates to the notion of emergent behaviour. it has 
1 	awards 
long been recognised that interactive composition-collections of processes  agents  acting side-by-side and interacting in whatever way they have been designed to interact  milner  1}-results in behavioural phenomena that cannot be deconstructed solely in terms of the behaviour of the individual components. this emergent behaviour is a consequence of the interaction between components. given the sophistication and flexibility of agent interactions  it is clear that the scope for unexpected individual and group behaviour is considerable. 
1 agents for business process management 
this section describes an agent-based system developed for managing a british telecom  bt  business process  jennings et a/.  1 . the particular process is providing customers with a quote for installing a network to deliver a particular type of telecommunications service. this process has a number of traits that are commonly found in corporate-wide business processes. in particular  the process is dynamic and unpredictable  it is impossible to give a complete a priori specification of all activities   it has a high-degree of natural concurrency  and there is a need to respect departmental and organisational boundaries. 
　in more detail  the following departments are involved: the customer service division  csd   the design division  dd   the surveyor department  sd   the legal division  ld  and the various organisations that provide the out-sourced service of vetting customers  vcs . the process is initiated by a customer contacting the csd with a set of requirements. in parallel to capturing the requirements  the csd gets the customer vetted. if the customer fails the vetting procedure  the quote process terminates. assuming the customer is satisfactory  their requirements are mapped against the service portfolio. if they can be met by an off-the-shelf item then an immediate quote can be offered. in the case of bespoke services  however  the process is more complex. csd further analyses the customer's requirements and whilst this is occurring ld checks the legality of the proposed service. if the desired service is illegal  the quote process terminates. if the requested service is legal  the design phase can start. to prepare a network design it is usually necessary to dispatch a surveyor to the customer's premises so that a detailed plan of the existing equipment can be produced. on completion of the network design and costing  dd informs csd of the quote. csd  in turn  informs the customer. the business process then terminates. 
　following the principles of agent-oriented decomposition  the system's autonomous problem solving entities were identified  figure 1 . thus  each department is represented by an agent  as is each individual within a department. since all these entities are active problem solvers with their own objectives  this mapping is both natural and intuitive. to achieve their individual objectives  agents need to interact 

with one another. in this case  all interactions take the form of negotiations about which services the agents will provide to one another and under what terms and conditions  faratin et al.  1 . the nature of these negotiations varies depending on the context and the prevailing circumstances: negotiations between bt internal agents are more cooperative than those involving external organisations  and negotiations where time is plentiful differ from those where time is short. thus  for example  to get a customer vetted  the csd agent negotiates  in a competitive manner  simultaneously with all the vc agents to determine which of them can perform this service the quickest. this interaction involves generating a series of proposals and counter-proposals and if it is successful it ultimately results in a mutually agreeable contract. generally speaking  the flexible nature of the interactions means the negotiators can tailor their behaviour to the prevailing circumstances. thus  they can both vary the amount of utility they expect from an agreement and relax their constraints in a context dependent manner. 

figure 1: agent system for managing the quote process 
direction of arrow indicates the consumer of the service labelling the arrow. 
　the final system design task is to characterise the organisational inter-relationships. here  the following classes are applicable: collections of agents being grouped together as a single conceptual unit  e.g. the individual designers and lawyers in dd and ld respectively   audiority relationships  e.g. the dd agent is the manager of the sd agent   peers within the same organisation  e.g. the csd  ld  and dd agents  and customer-subcontractor relationships  e.g. the csd agent and the various vc agents . explicitly representing such relationships is important because it provides a means of clustering collections of agents so they can be dealt with as a single conceptual unit and because it has a significant impact on the negotiation behaviour of the participants. 
1 	discussion 
this paper has sought to justify the claim that agent-based computing has the potential to provide a powerful suite of metaphors  concepts and techniques for conceptualising  designing and implementing complex  distributed  systems. however  against this promise lies the perils that:  i  there is insufficient know-how about building agents that can engage in flexible social interactions;  ii  the means by which sociality impacts upon individual and collective behaviour is not well understood; and  iii  the way in which organisational relationships impact upon the behaviour of individuals and societies needs to be clarified. 
　one means of tackling these fundamental issues is to follow an approach that proved successful in elucidating the foundational principles and structures of individual  asocial  agents. newell's  knowledge level analysis provided the seminal characterisation of intelligent agents-it stripped away implementation and application specific details to reveal the core of asocial problem solvers. since the aim here is to do the same for social agents  newell's basic approach can be re-used. thus a new computer level needs to be defined. this level can be called the social level  jennings and campos  1 . it should sit immediately above the knowledge level and it should provide the social principles and foundations for agent-based systems. the primary benefit of developing a social level description is that it enables the overall system's behaviour and key conceptual structures to be studied without the need to delve into the implementation details of the individual agents or the specifics of particular interaction protocols. thus prediction of the behaviour of the social agents and of the overall system can be made more easily. 
　to this end  a preliminary version of the social level will be outlined  following newell's general nomenclature : 
  the system  the entity to be described at that level  is an agent organisation. 
  the components of an agent organisation  the primitive elements from which it is built up  are the agents themselves and the channels through which they interact. interactions occur because of the inherent dependencies that exist between the agents  either through the environment or as a consequence of their adopted goals   jennings  1 . thus dependencies are also a primitive component. the final component is the organisational relationships that hold between the agents. 
	jennings 	1 

  composition laws define how the components are assembled to form the system. in this case  the agents undertake particular roles in the organisation. these roles define the objectives of the agents and their organisational relationships  the channels through which they interact  and the patterns of their interaction. accompanying the roles are the organisation's rules that define the laid down procedures or the emergent norms. these rules specify  among other things  who can adopt which roles and under what terms and conditions  what should happen if roles are violated  and how role conflicts should be handled. 
  behaviour laws determine how the system's behaviour depends upon its composition and on its components' behaviour. these laws indicate how the agents within the organisation should balance their individualistic objectives with those that stem from being part of the organisation. here no single law is universally best; rather  there is a continuous spectrum from the purely selfish to the altruistic. 
  the medium is the elements the system processes to obtain the behaviour it was designed to achieve. in this case  it is the social knowledge that each agent maintains about the agent organisation and its role therein. this includes  among other things  its social and organisational obligations  its mechanisms for influencing other agents and its mechanisms for altering the organisational structure. 
