 
　　　　pas-ii  a computer program which represents a generalized version of an automatic protocol system  pas-i  is described. pas-ii is a t a s k - f r e e   i n t e r a c t i v e   modular data analysis system for i n f e r r i n g 
　　　　the information processes used by a human from his 
verbal behavior while solving a problem. the output of the program is a problem behavior graph: a descript i o n of the subject's changing knowledge state during problem s o l v i n g . as an example of system operation the pas-ii analysis of a short cryptarithmetic protocol is presented. 
	1 . 	introduction 
　　　　automatic protocol analysis is a j o i n t e f f o r t by man and machine to i n f e r from the record of the time course of a subject's behavior  the underlying information processes. as developed   1     it usually r e f e r s to the v e r b a l i z a t i o n s of a subject solving some problem under i n s t r u c t i o n s to think out loud. protocol analysis designates the f u l l range of a c t i v i t i e s engaged in by the psychologist when working 
w i t h protocols: d e s c r i p t i o n of the subject's behavior according to an hypothesized model  induct i o n of new r u l e s   d e r i v a t i o n of consequences from a model in the context of s p e c i f i c data  and measure-
ment of adequacy of a model. the i n i t i a l focus of our work has been behavior description in terras of information processes  given an hypothesized general 
model 	 the so-called problem space in which the 
subject 	operates . 
　　　　the pas-i system  1  1  was our f i r s t attempt at automatic protocol a n a l y s i s . this is a f u l l y automatic  n o n - i n t e r a c t i v e   specialized system designed to analyze c r y p t a r i t h m e t i c protocols and p r o duce as output a problem behavior graph  pbg describing the subject's search through a posited problem space. the protocol analysis is represented as a sequence of processing stages that eventually transform the raw protocol i n t o a problem behavior graph. at each stage rules are applied which e f f e c t a t r a n s formation of the data. the organization of pas-i is shown in figure 1. 
　　　　pas-1 has successfully analyzed protocols from donauh-geraldtrobert and cross+roads=danger c r y p t arithmetic problems. the results obtained in the donald+gerald=robert task for two of the subjects have been discussed in d e t a i l  1  and demonstrate that t h i s approach to automatic protocol analysis is 
both feasible and rewarding. 
　　　　encouraged by the success of pas-i we have designed and b u i l t an improved version called pas-ii. pas-ii was designed w i t h two major goals in mind: to make it i n t e r a c t i v e and task f r e e . by i n t e r a c t i v e we mean that the user is permitted to take an active p a r t in the analysis: he can provide answers to subproblems the syetem is unable to solve  correct processing e r r o r s   and even maintain c o n t r o l over the processing sequence. c l e a r l y   r e a l - t i m e i n t e r a c t i o n 
　　　　of t h i s sort makes the system a more powerful t o o l 
for protocol analysis. 	by task free we mean that 
the system is independent of any p a r t i c u l a r problem domain. to make pas-ii task free we p a r t i t i o n e d the system i n t o two -parts: the problem dependent part 
consisting of the processing rules or h e u r i s t i c s used at each stage of the analysis  and the problem independent part consisting of the general control structure and command language. thus  to apply the system to a protocol in a new problem area the user 
must f i r s t supply the system w i t h processing rules for that domain.* the design of pas-ii also included four subgoals: to make the system transparent  
m o d i f i a b l e   extendable  and open  see figure 1 . 
　　　　two important implementation issues were not addressed in the design of pas-ii. 1 . improve system performance in c r y p t a r i t h m e t i c . this includes expanding the deductive and inductive inference c a p a b i l i t i e s   and   f i n e tuning  the system by optimizing the processing  h e u r i s t i c s to produce the best possible analysis w i t h i n the given framework. 1 . extend the scope of the analysis. for example  extend the system back to handle the speech recogn i t i o n and segmentation problems inherent in producing a t r a n s c r i p t i o n from the audio tape. or extend the system to handle the problem of inducing the problem space from the protocol or inducing a production system model from the problem behavior graph. 
　　　　it was decided to make pas-ii i n t e r a c t i v e and task f r e e   postponing the problems of increasing 
power in a p a r t i c u l a r task or broadening the scope of the analysis. this decision was influenced by the debire to provide a working t o o l for protocol analysis that could be used by p a r t i c i p a n t s at a workshop on new techniques in cognitive research held at cmu in the summer of 1  1 . the pas-ii system is c u r r e n t l y running in lisp at cmu on a pdp-1 and is a v a i l a b l e to the cmu  and the arpa network  community. 
　　　　this paper is organized as follows. the task of protocol analysis is discussed in section 1. this is followed in section 1 by a b r i e f description of the s t r u c t u r e of the program and in section 1 by an example of i t s use in analyzing a cryptarithmetic p r o t o c o l . section 1 concludes with a discussion of the general executive s t r u c t u r e of the system and i t s i m p l i c a t i o n for ai data analysis programs. 
	1. 	task of protocol analysis 
　　　　protocol analysis is a complex data processing task requiring both deductive and inductive inference c a p a b i l i t i e s . our current approach to protocol analysis is based on a p a r t i c u l a r theory of human problem s o l v i n g . for a description of t h i s theory and an i n t r o d u c t i o n to the task of protocol analysis see newell and simon   1   . 
u l t i m a t e l y   a l i b r a r y containing processing rules for a number of d i f f e r e n t problem domains w i l l be a v a i l a b l e to the user. 

1 


1 

theoretical substructure 
       problem space. we assume human problem solving takes place by search in a problem space. the ele-
ments of this space are the possible states of knowle d♀e the subject can have about the task  where a state of knowledge is simply an expression of what the subject knows at some particular point in the space. besides knowledge states  the problem space also includes a set of operators. these define operations the subject can perform on knowledge at a particular state to yield new knowledge -- hence to move to a new knowledge state. the operators are incremental  that ia  they take as input a small portion of the total knowledge state  a small set of knowledge ele-
ments  and produce as output new knowledge elements  
       problem behavior graph. 	the subject's search through the problem space for a solution can be described as a sequence of operator applications that create a string of incrementally changing knowledge states. the plot of this search is called the problem behavior graph 	 fbg . 	figure 1  also used to illustrate the output of the analysis given in section 1  shows a 
       problem behavior graph for cryptarithmetic. 	the nodes represent operator applications: the knowledge ele-
ments at the lower left of each node are the inputs  those at the lower right are the outputs. pbg branching results from the subject abandoning information and returning to a prior knowledge state  usually because of a discovered contradiction . for example  in figure 1 the outputs of nodes 1 and 1 conflict:  r is 1  conflicts with  r is odd   and leads to the abandonment of nodes 1  1 and 1  note that the knowledge state at any point in the graph is the conjunction of a l l output elements on the path from the given point back to the beginning of the graph. all nodes on the path from the last node back to the beginning of the graph are called currently active nodes. their output elements define the current knowledge state. 
data analysis 
       the data being analyzed is the transcribed text of a subject's verbal protocol. as the text is transformed into a pbg it is subjected to four major types of processing: linguistic  semantic  group  and pbg. figure 1 typifies such a processing sequence. 
       linguistic processing. the text is first segmented into shorter strings called topic segments ' each of which is expected to ultimately yield approxi-
mately one problem space element. each segment is then parsed using a grammar sensitive to the problem domain under consideration. the result of parsing is a set of semantic elements which represent the meaning of the segment. for example  the segment  d is not equal to 1  might yield the elements  nec  eq d 1  in the cryptarithmetic task. here  neg  is called an indicator element   eq d 1  a knowledge element. 
       semantic processing. the semantic elements produced through parsing are f i r s t combined in very elementary ways to produce new elements  i.e.   neg  and  eq d 1  become  neq d 1 . next  new elements reflecting relationships between elements from adjacent segments are produced. thus   eq d 1  from one segment and  therefore  eq t 1  from the next segment become  becauseof  eq d 1  eq t 1    e.g.   because d is 1  t is 1.  finally  these elements are arranged into i n i t i a l approximations of operator groups  each containing an operator element and the surrounding knowledge and indicator elements. an operator 
group is defined to be an operator together with its input and output knowledge elements. 
       group processing. the tentative operator groups produced during semantic processing are now analyzed to obtain a complete picture of what the subject knows 
at each moment and what operators he applies. first  variables in semantic elements are identified by comparing the elements to the current context as defined by the pbg. thus if  eq d 1} were in the pbg then when given the element  eq  l  1   where  l  stands for a class of letters  we recognize that  l  in this case is the letter d. 
　　　the second part of group processing consists of finding  or hypothesizing  the origin of every knowl-
edge element in each tentative group. the origin of a knowledge element is defined to be the operator which produced i t   plus the inputs to that operator  plus the operators which produced those inputs  etc. thus the origin can be represented as a tree which defines a collection of overlapping operator groups. 
       pbg processing. the operator groups produced during group processing are now incorporated into the pbg. in general  each group becomes a node in the pbg. in the simplest case the new node is just attached to the last currently active node. however  when contradictions occur  the output of one node conflicts with the output of another  restructuring occurs to eliminatethe conflict  see figure 1 . 
	1. 	structure of the program 
       pas-ii takes as input a transcribed text of the verbalization of a subject solving a problem and produces as output a pbg. the processing rules for the various stages  including the rules defining the problem space  are given to the system. these rules are supplied either by the system builder via a library of rules for various problem domains or by the user himself. 
modular structure 
       pas-ii is organized as a modular data analysis system. 	the basic unit of organization is the mode: a processing state which has associated with it a buffer capable of holding rules or data. 	this buffer can be modified by the editing functions available in the command language. 	there are three types of modes: run modes  which hold the data being analyzed  rule 
modes  which hold the processing rules  and auxiliary modes  which hold task-free system-oriented rules. thus the information in the rule modes constitutes the problem dependent part of the system. 
       the next level of organization ia the stage: a 
       unit consisting of one run mode and any number of associated rule modes. data processing is performed in a stage by applying the rules from the rule modes associated with that stage to the data present in the run mode of the previous stage. the result of the processing is then put into the run mode of the current stage. figure 1 illustrates the modular organization of pas-ii  with the arrows indicating data flow and the lines indicating mode associations. 
       the highest level of organization is the processor: 	a unit consisting of consecutive stages in the control cycle. 	for example  in pas-ii two linguistic btages form the linguistic processor and three semantic stages form the semantic processor 

1 

1 

       modes. the modes c u r r e n t l y implemented in pasii are l i s t e d in table 1. note that most run modes have one or two rules modes associated w i t h them. this association is i l l u s t r a t e d in table 1 and also in figure 1  which shows the modular composition of the various processors in pas-ii. the arrows in the f i g u r e define the data l i n k s e x i s t i n g between modes. the mode at the t a i l of an arrow provides the data that the mode at the head of the arrow processes. for 
example  processing in the topic mode involves applyi n g the segmentation rules to the data in the text mode and then placing the r e s u l t in the topic mode. as each l i n e in text is processed  it is deleted from the text b u f f e r . however  a copy of these deleted l i n e s is stored elsewhere in text and can be r e t r i e v e d  see the process functions in table 1   . the arrows in figure 1 do not necessarily define the c o n t r o l cycle  i . e .   the order in which processing occurs. the c o n t r o l flow is i l l u s t r a t e d in figure 1  to be discusaed l a t e r   . 

       functions. the functions currently implemented in pas-ii are listed in table 1. they constitute the 
command language available to the user  and are divided into four categories: 	basic  edit  flag  and process functions. 	note that a mode name is a function that puts the user into that mode. 
　　　　a function c a l l consists of a function name followed by i t s arguments. any number of function calls may occur together. if it is not clear which names are the functions and which are the arguments  parentheses can be used for disambiguation. in ambiguous cases the system always assumes the name is a function name rather than an argument. thus if the user types help topic display 1 it could mean either  help topic : give me information about the topic mode  and  display 1 : display line 1 of the current buffer; or  help : t e l l me how to get help   topic : put me into the topic mode  and  display 1 : display line 1. the system would make the latter interpretation. 
comparison w i t h figure 1 shows how pas-ii maps onto pas-i. note that the scope of the analysis has been extended to include a trace processor  not discussed i n d e t a i l i n t h i s paper . 
　　　　a u x i l i a r y modes. there are four a u x i l i a r y modes: save  controls association  and information. the save mode contains rules which specify which mode buffers are to be saved on  or read into from  a disk f i l e when the write  or read  command la executed. the control mode contains rules which define the control cycle for the system. i n i t i a l l y these ruleb define the c o n t r o l flow shown in figures 1 and 1. the association mode contains rules which define the associations between run and r u l e modes. the i n i t i a l  or default  associations are those shown in figure 1  the control and association modes  together with the create f u n c t i o n   permit the sophist i c a t e d user to create new modes  redefine mode associations  and reorganize the control flow for 
the e n t i r e system  one example of t h i s is the use of a reorganized pas-ii to analyze a problem description  problem text  in natural language in order to i n f e r from that text a tentative problem space  one that a subject might use in representing the problem   1   . 
　　　　the information mode is unique in containing no buffer and recognizing none of the functions that constitute the command language  instead  t h i s mode responds to key words in the users input  which may be in sentence form. the mode provides the user w i t h 
　　　　general information about pas-ii: i t s basic organiz a t i o n   purpose  and techniques of operation. this is to be contrasted w i t h the help f u n c t i o n   which p r o -
vides the user with s p e c i f i c   on-the-spot information about the mode he is i n . 
control 	structure 
       the c o n t r o l cycle for pas-ii is shown in the flow diagram of figure 1. 	the s o l i d arrows indicate 
the stage that is entered once processing in the current stage is f i n i s h e d . the broken arrows indicate 
which stage to enter before processing is s t a r t e d . processing in linguistic1  semantics  and graphic1 is incremental. 	in each of these modes only part of the data from the previous mode is processed at one time. this i n i t i a l portion of the data is then carried through the rest of the system  leading to the growth 
of pbg nodes  before the rest of the data in the previous mode is processed. this is done to establish a semantic context  the pbg  as early as possible in the processing sequence so it can provide feedback needed for l i n g u i s t i c   semantic  and group processing. 
　　　　since the control organization of pas-ii is quite f l e x i b l e   the user is under no constraints to process the data in the order shown in figure 1. he 
may skip or repeat stages w i t h i n the e x i s t i n g c o n t r o l framework  and may redefine the control cycle  via the control mode . he may also have the system put him i n t o the next run mode in the c o n t r o l loop  or even automatically step him through the run modes  i n i t i a t i n g the processing at each stage  see next 
and automatic in table 1 . 
data processing 
       figures 1 and 1 show the processors which comprise the control cycle of pas-ii. in the topic 
processor transcribed text is segmented i n t o phrases containing only a single task t o p i c . * * then in the l i n g u i s t i c processor an i n i t i a l c o l l e c t i o n of these 
at present the pbg provides feedback for group processing only. 
this is a s l i g h t extension: pas-i requires segmented t e x t as i n p u t . 

1 

1 



segments is parsed yielding sets of semantic elements. these elements are processed and refined in the semantic processor to produce groups composed of one operator element and lts associated input and output knowledge elements. in the pbg processor these groups 
are incorporated into the pbg. the trace processor is then used to compare this pbg with the trace 
produced by a given production system model of the subject. 
       topic processor. the topic processor contains two run modes: text and topic. text is an i n i t i a l i zation mode; it holds the data for topic to process. thus no real processing takes place in i t . the topic mode uses the segmentation rules to segment a l l the text in the text mode. these rules have the general form: .string  / string1   where a string is any sequence of words  punctuation marks  or word classes  as defined in the grammar mode   including the null sequence. the slash  /  indicates where the text is to be broken  i.e.  after every occurrence 
of string  that is immediately followed by an occurrence of string-. figure 1 show segmentation rules for cryptarithmetic  to be used in the example in section 1  . 
       linguistic processor. the linguistic processor contains two run modes: linguisticl and linguistic1. in linguisticl the extraction rules are used to select a consecutive set of segments from topic  representing an i n i t i a l guess as to the minimum number of segments from which a group can be inferred. processing consists only of transferring these segments from the topic mode to the linguisticl mode. at present  the extraction rules are simply a single integer specifying how many segments to transfer. 
       processing in the linguistic1 mode consists of applying the space and grammar rules to a l l the topic segments in linguisticl. the parsing operation pro-
duces  for each segment  a set of semantic elements representing the meaning of the segment. the rules in the space mode define the problem space and have the form:  semantic-element  type  where a semantic element is either an operator  knowledge  or indicator element  and the type is either op  kn  or ind. the grammar rules define a key-word grammar and have the form:  clas1  =  item1 item  . .   item1 item 
 ...  ...   where an item is either a class  denoted by angle brackets  or a l i t e r a l  such as a word  letter  or character . an asterisk  *  can be used between any two items to indicate a match with any string of text  and any grammar rule which is a disjunction of single literals can be written without parentheses. figure 1 shows space and grammar rules 
for cryptarithmetic. 
space rule 1 in figure 1 is an exception. it defines a set named  v  containing two members  the class  letter  and the class  earry . 
two parsers are available  a simple top down parser and a more sophisticated parser written by m. rychener. 
       semantic processor. the semantic processor contains three run modes: semanticl  semantic1  and semantic1. in semanticl the integration rules produce new elements by combining semantic elements generated from the same or adjacent segments. in semantic1 the normalization rules map knowledge and indicator elements into single elements reflecting the relationships existing between two or more knowledge elements. in semantic1 a tentative operator group  protogroup  is formed. the integration and normalization rules are* replacement rules of the type a =  b  i.e.  replace a with b. both a and b can be lists of semantic elements. a slash  /  indicates that the next elements of the l i s t occur on the next line of the mode buffer. class names and x's are used as variables  and in the normalization rules a's are variables which stand for knowledge elements on adjacent lines connected by the and indicator. typical integration and normalization rules for cryptarithmetic are shown in figure 1. grouping rules are not shown.* they define a protogroup to be the largest consecutive sequence of elements containing 
no more than one operator element. 
       group processor. there are two run modes in the group processor: graphic1  and graphic1. graphic1 processing f i l l s in the values of variables in the semantic elements by comparing the element containing variables with a l l the elements currently active in the pbg  i . e .   the current context. when a match is found the appropriate values are f i l l e d i n . currently the unknowns rules are not accessible to the user. 
       processing in graphic1 is a joint man-machine effort.** the goal is to hypothesize for each knowledge element its origin  i.e.  the operator and its inputs  and the operators that produced those inputs  etc.  that produced that knowledge element as output. the system queries the user asking for possible operators and inputs that could have produced the element whose origin is being sought. from this information the system constructs an origin tree  and hypothesizes which path through the tree represents the actual origin of the element. the path is picked on the basis of the agreement between the hypothesized inputs and the actual context defined by the current pbg. the origin rules  like the grouping and unknowns rules  are currently not accessible. 
       pbg processor. the pbg processor contains one run mode: graphic1. in the graphic1 mode  processing consists of taking the operator groups produced in graphic1 and incorporating them into the problem behavior graph. the conflict rules are used to determine whether or not any knowledge elements in the operator groups conflict with knowledge already in the pbg. if such a conflict occurs  the pbg rules are used to restructure the pbg so the conflict is eliminated. 
at the current stage of development the grouping rules have not been made accessible to the user. 
1 this is the major place where we have not regained in pas-ii the power for automatic processing available in pas-i. 
       both the conflict and pbg rules are ordered production rules of the form s -* a  i.e.  in situation s take action a  1  1 . a situation is defined by a l i s t of values of certain variables  called the state vector  sv. the left side of each production rule has the form  v. v  v . . .    where v repre-
sents a permissible value for the nth statl vector 
variable. the right side has the form  a. a a . . .     where the a'g represent actions to be taken. the current values of the state vector variables are compared with the left side of each production rule. the f i r s t match  from top to bottom  determines the actions to be taken  an asterisk is considered to match any value . 
       figure 1 shows conflict and pbg rules for cryptarithmetic. the conflict rules determine 
whether or not two given knowledge elements conflict. the example conflict state vector contains:  same 1   which is true  t  if the second items of both the elements are identical and false  f  otherwise;  item 1     which returns as a value the f i r s t item of the f i r s t element  the element in the pbg ; and  item 1     which returns as a value the f i r s t item of the second element  the element in the group . thus if the two elements being compared were  odd r  and  neq r 1  conflict rule 1 would match the state vector and the decision would be that no conflict exists. 
       the pbg rules determine the type of restructuring that occurs once a conflict is detected. the pbg state vector in figure 1 has 1 variables: type  which has the value con if restructuring is based on conflict and sim if it is based on similarity; and  item 1   which is defined above. the actions shown in figure 1 are blockrej  a type of restructuring where blocks of adjacent nodes are abandoned  and copy  a. specification that the group causing the restructuring should remain in the active portion of the pbg after restructuring. the state vectors for conflict and pbg may contain variables and actions other than the ones shown in figure 1. for a complete description of these rules see the pas-ii reference 
manual  1 . 
       trace processor. the topic  linguistic  semantic  group and pbg processors comprise the major portion of pas-ii. it is thib portion which represents a generalized version of pas-i. the trace 
processor ie a new extension to the system and has no analogue in pas-i. some parts of i t   like the match 
mode  are s t i l l under development. the trace processor enables the user to write a production system 
model of the subject  1   and then compare the trace obtained by running the production system model with the pbg obtained by analyzing the protocol. the details are described elsewhere  1 . 
	1. 	example of program operation 
       to illustrate the use of pas-ii  we present a listing of the actual user-machine interaction i n -
volved in the on-line analysis of a short cryptarithmetic protocol. 	the cryptarithmetic task is given in figure 1. 	both the protocol and the cryptarithmetic rules used for this example 	are shown in figure 1. 	the protocol is stored in the text mode and the cryptarithmetic rules in the eight rules modes shown. 	these rules approximate the minimal set needed 
the pbg rules are also used for restructuring when similarities  identical nodes  are detected  as discussed in an earlier paper on pas-i  1 . 

       the user f i r s t entered the text mode and displayed its contents. he then entered the next mode in the control cycle  topic  and started processing 
by typing go. this caused the segmentation rules to be applied to the data in text. the system indicated that the data in line 1 of the previous mode had been transformed into the seven lines shown above  and asked if this transformation was satisfactory  ok  . at this point the user typed yes  telling the system to actually put those seven lines into the next seven 
at least four times as many rules would be needed for a complete set  1 . 

1 

	figure 1. 	cryptarithmetlc rules. 
1 

lines of the topic buffer. 	if the processing had 
been unsatisfactory  the user could have jumped to the segmentation mode  changed the rules  jumped 
back to topic  and reprocessed the data using the new rules before proceeding with the next processing step. 
       the user then entered the next mode  linguisticl  and started processing. the extraction rules were applied to the seven lines of data in topic and the system indicated that the processing should consist of placing these lines in linguisticl unchanged. note that the system indicated that line 1 from topic was transformed into a single line in linguisticl  etc.  as opposed to the previous step where one line in text 
was transformed into seven lines in topic. 

       processing in linguistic1 consisted of applying the space and grammar rules to the data in linguisticl to produce a parse. in step 1 the parse tree was printed and the user set the flag batch true to eliminate the ok  question  the system then assumes the answer is always yes  and the flag suppress true to eliminate further printing of the parse trees. then  before going to the next mode in the control cycle  the user set the flag automatic true so the system would automatically step through the appropriate run modes executing go. at this point the linguistic1 buffer held the seven sets of semantic elements shown above. 


processing in semantic1 consisted of applying the 
integration rules to the semantic elements in linguistic1. as indicated above there were five applications of the rules. processing in semantic1 consisted of applying the normalization rules to the seven sets of elements in semantic1  there were two applications of the rules  and five sets of elements were left in semantic1. processing in semantic1 conisisted of applying the .grouping rules  which are not explicit. these rules simply attempted to pull from semantic1 one operator element and its associated knowledge elements. since no operator elements were present  it pulled a l l the elements from semantic1. 

processing in graphicl consisted of applying the 
unknowns rules  which are not explicit. these rules involve searching the existing pbg for elements that 
match the elements containing unknowns. in this simple example no matches were found because the pbg had not yet been grown. thus  in step 1 when the unknown carry  c  was not found  the user told the system to replace its processing result with  becauseof    eq c1     odd r    . this was put into line 1 of the graphicl buffer  rather than the result containing  e . in effect the user told the system that the value of  c  was c1  i.e.  that the 
unknown carry was the carry into the second column  the l+lsr column . 
　　processing in graphic1 and graphic1 occurred as follows: graphic1 was entered and the elements from line 1 of graphicl were processed interactively to determine their operator groups. graphic1 was then entered and these groups were grown as new nodes in the 
1 pbg  	next graphic1 was reentered and the elements 
from line 1 of graphic1 processed. this graphic1graphic1 loop was repeated for each line in graphic1. below is shown only one of these loops : processing and growing the elements from line 1 of graphic1. 
     in graphic1 the system queried the user to determine possible origins  operators and their inputs  for the elements in question. this information was represented as an origin tree as shown above. this tree is displayed below in a more conventional style. 

	figure 1. 	origin tree 
the system analyzes the tree and decides which path represents the best origin for the top element  in this case  odd r . here there are only two alter-
natives: 	the path with the operator: 	assign a value 
to the carry into column 1   av c1    and the path with the operator: process column 1   pc 1 . the system chooses the latter  based on implicit origin rules which t e l l it to choose between operators by rating them according to their inputs. the decision function currently in use is: 
where an input is  used  if it occurs in the pbg. thus  av c1  has a rating of 1 while  pc 1  has a rating of  1 -1 or 1. the format of the operator groups produced in graphic1 is: operator  input list  output. 
 td r 1 . 
tional representation. note that the conflict between  aeq r 1  and  odd r  led to a back-up that abandoned nodes 1  1 and 1. thus the currently active nodes  the ones that define the current context  are those joined by the heavy lines in figure 1. 
	1. 	discussion 
     the i n i t i a l program  pas-i  is an a r t i f i c i a l 
     intelligence program by any reasonable criteria. the task it attempts  the inference from verbal behavior to problem behavior graph  is a task requiring intelligence when done by humans. the mechanisms used are those common to other a r t i f i c i a l intelligence programs that tackle somewhat similar tasks: grammars to deal with the surface structure of natural language  representation of knowledge  matching  and heuristic search to infer information not directly expressed in the utterances. 
　　pas-ii is a program that accomplishes the same cask as pas-i. hence  it too is an a r t i f i c i a l i n t e l ligence program. but when looked at structurally it 
more closely resembles a data processing framework or  possibly  a language. 	something has happened in going from pas-i to pas-ii  something worth identifying and discussing. 
** 
     let us start with planner  1  and qa1  1 . these systems are languages for writing programs to perform a class of a r t i f i c i a l intelligence tasks. the 

choose to maximise: 	 1 x used-inputs   unused-inputs  
space limitations prevent us from including the entire l i s t i n g . 
conflict and pbg rules ere described in detail in an earlier paper  1 . 
there are other representatives of this class  e.g.  popi-er  1  and conniver  1  1 . 
1 



exact boundaries of these tasks are obscure but their central core is clear and includes a large fraction of the tasks for which heuristic programshave been built -- theorem proving  robot planning  symbolic manipulation  etc. these systems were formed  essentially  
by taking a l i s t processing framework and embedding 
within it some of the ad hoc mechanisms developed for particular heuristic programs. 	they include back-
tracking  a generalized matching f a c i l i t y   a global data base  accessed by pattern matching  and multiprocessing control. embedding these mechanisms within & language makes possible their use in novel combinations  and in interaction with the other mechanisms available in higher languages . 
     this same embedding of mechanisms into a language system has occurred in the transition from pas-i to fas-ii. pas-ii provides a framework within which a class of al programs can be easily constructed. this class is not the same as that of the planner/qa1 type system  which is more  mainline  a r t i f i c i a l 
     intelligence. rather  it appears to be characterized as linguistic data processing  the essential feature being the processing of long sequences of data  rather than just a sentence at a time . this class includes  of course  protocol analysis. it also includes a number of other tasks: content analysis of more classical varieties  1   problem space construction  1   test grading  and what is coming to be called semantic f i l t e r i n g . 
     the embodiment of mechanisms into a language framework has occurred at two levels in pas-ii  one corresponding roughly to that of planner/qa1 and the other more specialized. 	the f i r s t level is represented by the pas-ii framework of run modes  rule 
modes  common command language  editing system  and control structure. this includes a set of mechanisms for the data base  the run modes   a matching facility  the common mechanism for how the rules work 
on data   and a backtrack f a c i l i t y  the saving of buffers so that processing can be undone . added to this is the explicit control structure for processing within a stage and passing through the stages  which corresponds to a weak method  1  in the same sense as gps1b basic methods or the basic methods built into the goal construct in planner/qa1. these provide a schema of operation which  though almost content free  is s t i l l a rational procedure for achieving the overall goal. the mechanisms adopted in pas-ii are somewhat more shaped than their correspondents in planner/qa1  e.g.  there is not a single global data base or one stratified by a general context mechanism  rather the data is organized into homogeneous groups  the modes  along structural lines. 
     the second level is the specialization of the various modes to specific subtasks inherent in tasks of the class: segmentation  parsing  normalization  etc. the specialized rule systems contain the knowledge about the processing. thus writing any sort of legal rules within a given rule system generates processing of the right sort  though it may not do the right task ＊ in this respect providing a single generalized rule system or scheme for pattern matching and pattern evoked actions  in the manner of planner/qa1  would move more of the knowledge required back across the boundary from the language system  pas-id to the coding within the system  the user program in pas-ii  which is the set of actual rules in the rule nodes . 
     as one moves pas-ii in the direction of a generalized system for a wider class of problems  one can expect the collection of rule modes to increase  becoming eventually  a library in the classic subroutine library sense. the system designer is then faced with the problem of providing these modes with the rules needed to define processing in the various problem domains. however  one advantage of specialized rule systems is that when their structure is highly constrained it becomes easy to predict the effect of modifying rules in the system  as compared to predicting the effect of modifying statements in a general programming language . this sets the stage for the development of self-modifying systems which rewrite their own rules or  in effect  learn to improve their performance in some data processing task  1  1 . such a capability in an interactive pas-ii-like system would enable the system to build or modify its own rules for a particular problem domain  using feedback from the user to direct the search for good sets of rules. 
　　　the evolution from pas-i to pas-ii in analogy to the more general evolution going on toward planner-like language systems should add to the awareness that embedding mechanisms in language remains a potent scheme for making advances in a r t i f i c i a l intelligence. 
acknowledgments 
　　　this paper w i l l appear in the preprints for the third international joint conference on a r t i f i c i a l intelligence  ijcai-1 . this research was supported in part by research grant mh-1 from the national institutes of health and in part by the advanced research projects agency of the office of the secretary of defense  f1-c-1  which is monitored by the air force office of scientific research. 
