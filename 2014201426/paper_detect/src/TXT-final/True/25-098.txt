 
our experience in the idas natural language generation project has shown us that idas's klone-like classifier  originally built solely to hold a domain knowledge base  could also be used to perform many of the computations required by a natural-language generation system; in fact it seems possible to use the classifier to encode and execute arbitrary programs. we discuss idas's classification system and how it differs from other such systems  perhaps most notably in the presence of template' constructs that enable recursion to be encoded ; give examples of program fragments encoded in the classification system; and compare the classification approach to other ai programming paradigms  e.g.  logic programming . 
1 	introduction 
this paper investigates a new approach to programming that is based on controlling a kl-one-type classifier  brachman and schmolze  1 . in this approach  'inputs' are classes that are given to the classifier  'programs' are the existing classes in the taxonomy maintained by the classifier  and 'outputs' are formed by classifying the input class into the program taxonomy  and reading off some of the attributes that the class inherits by virtue of its position in the taxonomy. we have used this approach to implement  reiter and mellish  1  most of the natural-language generation component of the idas on-line documentation system  reiter et al.  1   and have noticed that it seems possible to use classification programming to implement many other kinds of programs as well. we mean this not just in the sense that our classification programming system is turingequivalent  which it is   but in the more important sense that it seems like a natural way to express certain kinds of computations; this has proven to be the case in idas  at any rate. 
¡¡this work is perhaps best considered as an attempt to explore a poorly investigated portion of the space of pos-
* e-mail c.mellisheed. ac.uk. 
   + e-mail e.reiter1ed.ac.uk. ehud reiter is supported by serc grant gr/f/1 
knowledge representation 
sible programming languages; it is not yet clear whether this exploration will lead to a useful general-purpose programming language. much of our work is inspired by the development of logic programming  which arose out of the realisation that controlled theorem-proving could be the basis of a programming language; our hope is to show that controlled classification can similarly be used to create a programming language. we would like to emphasize  incidentally  that although this paper presents work in progress  we have implemented the ii system we discuss in this paper  and have used it to build a substantial portion of a documentation generation system; the system we are describing here is not simply a paper design. on the other hand  ii was not developed originally as a general-purpose programming language and it is clear that it is deficient in a number of respects  e.g. syntax  existence of optimising compilers and debuggers  that prevent it from being  at present  a practical general programming language. 
¡¡we will compare classification programming system mainly to logic programming  both because that is the programming paradigm we are most familiar with  and also because our experience to date with classification programming has suggested that such programming 'feels like' programming prolog; at the most basic level  for example  both classification and logic programming are very declarative approaches to building programs. classification programming also  however  contains characteristics that are more reminiscent of objectoriented programming and production systems  and this may make it useful in applications that are difficult to develop in prolog. 
¡¡section 1 of this paper briefly describes what a classifier does. section 1 introduces the ii system and gives a simplified formal syntax and semantics for its core. section 1 describes how ii can be used to represent and execute programs  and gives examples of a simple prologstyle append function and a rule from the idas surface realisation grammar. section 1 compares classification to related approaches  and section 1 presents some concluding comments about classification programming and its future prospects. 

1 	classification 
a classification system computes subsumption relationships between domain entities  and records these subsumption relationships by maintaining a classification taxonomy. for example  a classifier could determine that the class bachelor  defined as  person with attributes {sex:male  age-status:adult  marital-status:unmarried}   was subsumed by the class man  defined as  person with attribute {sex:male  age-status:adult} ; and hence that bachelor should go beneath man in the taxonomy. space does not permit a detailed discussion of basic classification technology and terminology; the interested reader may wish to read  for example  ibrachman and schmolze  1  or the chapters in  sowa  1 . we will assume in this paper that the reader is familiar with basic classification terminology  such as the terms value restrictions and primitive class. 
   a classification-based knowledge representation system usually contains an assertional component or 'abox' as well as the subsumption reasoner  't-box' . one of the simplest a-box's  and the one that will be of primary interest here  is a default inheritance system  where attributes are inherited from superclass to subclass in the subsumption taxonomy  unless they are overridden by an attribute value specified in a more specific class. these inherited attributes are typically distinguished from the attributes the classifier examines when performing subsumption calculations  since current-day classification algorithms cannot handle default attributes. 
   a classification-based kr system performs inferences by combining the abilities of its t-box and a-box. for example  suppose the system was informed that 
  the class adult-person  defined as  person with {age-status:adult}   has the default attribute haschildren :true; 
  the class unmarried-adult-person  defined as  person with {age-status:adult  marital-status unmarried}   had the default attribute has-children:false. 
  john is a person with attributes {sex:male  age-status: adult  marital-status: unmarried} 
john is subsumed by both adult-person and unmarriedadult-person  and unmarried-adult-person is subsumed by adult-person. if a query is issued for the value of has-children for john  the system will prefer the default attached to unmarried-adult-person because this class is more specific than  i.e.  is subsumed by  adult-person; hence  the system will conclude that john has the value false for the role has-children. 
   the above illustrates the simplest use of classification to make inferences and computations; the classifier uses its knowledge about the individual class john to place that class in the taxonomy  and then uses the class's computed taxonomy position to make inferences about its attributes. writing general-purpose programs requires adding facilities for procedure calls and data structuring; the techniques used by ii to do this are based on adding template and reference constructs that allow new classes to be dynamically created  classified  and queried  for attribute values  while the system is responding to an attribute value query. these constructs are described in section 1  and their use for programming is discussed in section 1. 
1 	i i 
ii is the knowledge representation system used in idas  and includes: 
  an 	automatic 	classifier 	that 	supports 	value 
restriction.1 
  a default-inheritance system that gives precedence to defaults from subsumed  more specific  classes. 
  various support tools  such as a graphical browser and editor. 
1 is probably not the best possible classification programming language  and if we were to start over we would undoubtably build a somewhat different system. but ii has been the basis of our experiments with classification programming  and hence we will use it in this paper. 
   more formally  the open-class symbols used in specifying an 1 knowledge base are of three kinds. we will use c e c to denote a concept  class  name  ra e ra an assertional role name and rd € rd a definitional role name. definitional roles are those seen by the classifier  whereas assertional roles are those whose values are inherited by the default mechanism. definitional roles are not processed by the default-inheritance system  although they are inherited in a non-default manner   and assertional roles are ignored during classification. 

1
¡¡¡¡the ii classifier also supports other class-definition operators  e.g.  a very limited form of role differentiation   but these will not be discussed in this paper. 
1
¡¡¡¡ note that for compactness this paper uses a different 1 syntax from that used in the implementation. 
1 
the = statement defines open-door to be the class of all open entities whose actor role has a filler subsumed by animate  and whose actee role has a filler subsumed by door. these are definitional value restrictions. the =  statement describes the value for an assertional role  decomposition  of open-door. the value is specified by a template  which provides the name of a class subsuming the value  sequence  and a set of specifications for role values of this class  here  the roles 1  1 and 1 . these role values are themselves specified by templates. each of these templates defines a class whose ancestor is an action  grasp  turn  pull  that has the same actor as the open-door action and that has an actee that is the filler of the handle role of the actee of the open-door action. 
   for example  if open-1 was defined as an open action with role fillers actor:sam and actee:door-1: open-1 = {open} with {actor:sam  actee:door-1} then open-1 would be classified beneath open-door by the classifier on the basis of its actor and actee values. if an inquiry was issued for the value of decomposition for open-1  the above definition from open-door would be inherited  and  if door-1 had handle-1 as the filler of its handle role  the three templates in the sequence would be expanded into three actions   grasp-1 turn-1 pull1   each of which had an actor of sam and an actee of handle-1; these three subactions would then themselves be classified into the taxonomy. 

1 	classification programming 
ii was designed to represent a fairly conventional knowledge base of entities and actions  but we discovered that it could also be used to represent and execute generalpurpose programs. to do this  
1. classes in the taxonomy are regarded as rules  whose conditions are specified in the definitional roles  value restrictions  and whose conclusions are expressed in the assertional roles. 
1. queries are represented as new classes that must be classified. 
1. the classifier acts as a pattern-matcher that selects 

knowledge representation 

a rule which fits the query. 
the 'running' of a classification program is initiated by a request for the value of an assertional role for a class that has already been classified. the interesting case arises when this role value is specified by a template. in this case  the class specified by the template must be created and classified. if some role value for the new class is needed to satisfy the original request  then this may lead to more new classes being created and classified. in this way  the classification programmer has access to recursion. 
   classes can also be used to represent data structures  with roles being used to represent and access the data structure's fields. such data structures can be dynamically constructed by templates during the 'execution* of a classification program  and their components can be dynamically accessed with references. it is also possible to add special-purpose constructs for common structures such as lists  which may improve efficiency; this is similar to the approach taken by prolog  which has a special syntax and compiler optimisations for constructing and accessing lists. it is important to note that programs and data in ii are represented with the same kind of structure  namely classes  and are subject to the same operations  namely classification and role inheritance; in languages such as prolog  in contrast  a real distinction is made between programs and data and the operations that make sense on each. 

1 converting prolog programs into classification programs 
simple prolog programs can be fairly mechanically converted into ii programs  provided that the clauses in the program distinguish between input and output arguments  and no deep backtracking is performed. these restrictions of course remove much of the power of prolog  but we illustrate the process here in an attempt to give readers used to prolog more of an intuition for classification programs. 
¡¡to generate an equivalent ii program for a simple prolog program  the following must be performed: 
  an ii primitive class is generated for each prolog predicate1. 
  a role is defined for each argument  input and out-put  of a predicate  argument names must be introduced  since classification requires keyword parameters instead of prolog's positional arguments . 
  a class is defined for each clause  which 
- includes an appropriate value restriction for every constrained input argument. 
- includes a template for each 'call' of a predicate in the clause's right-hand-side  with embedded templates used to create any necessary complex terms  data structures . 
- includes templates and references that relate the output of the lhs predicate to the inputs of the lhs predicates and the outputs of the rhs predicates. 
such a program is queried by creating a class from the input query  classifying it  and requesting the value of any desired output arguments. 
¡¡an example of this mapping is the following version of the prolog append function. since i i   unlike prolog  does not have a special syntax for list manipulation  the interpretation below assumes lists are repre-
sented with lisp-like cons cells  e.g.   a b  is represented as cons  a  cons  b  n u l l     . the components of a cons 
structure will be referred to with the f i r s t and rest roles. the following definitions also assume that the first two arguments of append are the inputs input 1 and 
input1  and the third argument is the output output. 
1
¡¡¡¡primitivenes1 can be simulated in the simplified syntax by using a definition of the form: 
c = ... with {c-q:true} 
where c-q is a role not mentioned elsewhere in the knowledge base. 
1 

target = {sentence } with {semantics:or} 	forming the necessary classification by hand 1 . 

and then queries about the realisation of target are posed. 
   in this instance  the semantic distinctions actortheme/acteetheme and command/statement are independent. a given  complete  semantic representation a will be classified under one of each of these pairs. it follows that target will be classified both under one of active/passive and also under one of imperative/declarative. the appropriate value will then be inherited for the subject  either an empty phrase  or the value of the deepsubject  which will be a noun-phrase with a semantics taken from an appropriate point in a . 
   instead of giving separate definitions for declarative and active  the programmer could have associated the assertional statements about them  e.g.  {subject: deep1ubject }  with sentence. under ii's default inheritance mechanism  this means that a sentence would by default be assumed to have these assertional properties unless its definitional information  i.e.  the semantics value  was such that it was classified beneath the more specialised class imperative or passive. using default inheritance in this manner allows the grammar to process incomplete semantic inputs  which can be useful. 
1 	comparison to other systems 
there are interesting similarities between classification programming and a number of existing programming schemes. space does not permit a detailed comparison here  but we will attempt to summarise the most important points. we have already discussed briefly some similarities between classification programming and prolog  though the rigid distinction between inputs and outputs suggests a closer match in some respects with functional languages such as ml  milner et al.  1 . the use of  multiple  inheritance in ii reminds one naturally of object-oriented languages  including smalltalk  goldberg and robson  1  and the feature-oriented and declarative datr language  evans and gazdar  1  for lexical description. the use of complex functional descriptions is reminiscent of recent feature logics and extensions to unification grammars  such as tfs  zajac and emele  1  and fuf  elhadad  1   as weli of the type specification languages of ait-kaci and his associates - kbl  ait-kaci  1  and l o g i n  ait-kaci and nasr  1 . indeed  papers on tfs  fuf and kbl all present versions of the prolog append definition that are similar to ours. our discussion of ii definitions as pattern-action rules suggests a connection with production systems such as ops1  brownstone et a/.  1 . 
1 	classification 
the major way in which ii differs from other systems providing inheritance  such as smalltalk  d a t r   tfs  fuf  login and kbl  is by the incorporation of a nontrivial classifier. in these other systems  the types or classes from which information can be inherited are primitive  there are no non-trivial sufficient conditions for class membership . this is essentially like running 
ii without any = statements  with the programmer per-
knowledge representation 
1 	d e t e r m i n i s m 
prolog  tfs  fuf  login and kbl provide  in place of classification  unification and disjunction. a primitive class can be associated with a set of possible  definitions  and  when these are matched with the known role-value pairs of a more specific class  only certain combinations will turn out to be consistent. if more than one is possible  then non-determinism arises. in classification programming  classification determines uniquely where a class fits within the taxonomy and there is no non-determinism. in this respect it behaves more like a language like ml  where the first matching clause is always chosen  though in classification  it will be the most specific definition  regardless of the textual order . classification programming sacrifices bidirectionality by this approach. 
   ops1 provides disjunction implicitly by considering all productions whose conditions are satisfied. if an ops1 program used a conflict-resolution strategy that preferred the most specific matching productions  then this might in some ways approximate the behaviour of a classification system; in practice ops1 conflictresolution strategies tend to also consider other factors  such as when a data element was created or last updated. 
1 	o b j e c t - o r i e n t a t i o n 
in classification programming  a given class may be classified beneath several parent classes  and thereby inherit will information from all of these classes. this is illustrated by our realisation grammar example  in which a sentence class may  for instance  be a child of both declarative and passive; such a sentence will inherit a value for subject from declarative  and a value for deepsubject from passive. our append example  which looks close to similar definitions in prolog  ml  tfs  fuf  kbl and l o g i n   is not really representative for this reason. when an ii programmer produces definitions of subclasses of a given class these are not required to be dis-
joint. in the other languages  the multiple clauses for a predicate  function or type are interpreted as disjoint alternatives. the effect of multiple inheritance can be coded in other ways in these languages  of course. in the end  the difference is a matter of orientation. ii classes are in this respect more like classes in smalltalk and d a t r  and  to some extent  productions in ops1   and ii references can be seen as a form of message-passing. 
1
 in fact  a limited kind of classification seems possible in 
kbl via the lattice ordering on the type signature. if a type which is equivalent to a conjunction of simpler types  and hence not primitive  can be associated with a kbl  definition   then a kind of classification would be needed to associate this  definition  with a class that was subsumed by both of the classes in the conjunction. but we have seen no examples of this being done in the papers on kbl and this in any case would involve only a very simple notion of classification  which does not take account of role values . nb kbl definitions associate only necessary conditions with classes and correspond roughly to ii =  statements. because this is a different sense of the word  definition  than our own  we will distinguish it by quotes. 
the use of default inheritance in ii is another feature in common with object-oriented systems. 
1 	declarativeness 
although classification programming has an objectoriented orientation  unlike most oop languages  with the exception of d a t r   it is purely declarative. it also differs from ops1 in this respect. 
1 	r e c u r s i o n 
the template mechanism in ii is what distinguishes it from other classification systems; in particular  templates permit the ii programmer to implement recursion and procedure calls. several systems have been built that combined classification and forward chaining production rules  including clasp  yen et a l   1   classic  brachman et a l   1   and consul  mark  1 ; these rules could perhaps be used to achieve some of the same functionality as il's templates  but we are not aware of any attempt to use these systems as we are using i i . consul also seems to have had some template-like capabilities  but the details are unclear  and again this facility was not used in the way we use templates in i i . 
1 	laziness 
in i i   assertional roles are only accessed  and templates expanded  when this is necessary to answer a query. this lazy evaluation strategy  which is not the only mechanism that could be used in classification programming  differs from the forward chaining rules of ops1 and classic. it is similar to lazy evaluation as it appears in functional languages. 
1 	procedures vs d a t a 
as with tfs  fuf and k b l   ii makes no distinction between procedures and data  the same operations being applicable to both. in this respect it differs from l o g i n   prolog  ml and ops1. 
1 	conclusion 
this paper has shown how a kl-one-like classification system can be used to execute general-purpose programs  if it is augmented with a default inheritance system and constructs that allow recursion to be programmed  e.g.  templates . the resultant programming system has some similarities to logic programming  productionrules systems  and object-oriented approaches  but does not fully fall into any of these categories. classification programming has proven to be a very useful tool in the idas system  and we expect that it will be similarly useful in other knowledge-centred applications which require integrating some algorithmic reasoning with a klone-like domain knowledge base. whether the classification approach will lead to a general-purpose language that is as useful as  say  prolog is unclear at this point in time; at minimum  however  classification programming provides a novel and interesting perspective on what constitutes programming  and on the relationship between knowledge and reasoning. 
