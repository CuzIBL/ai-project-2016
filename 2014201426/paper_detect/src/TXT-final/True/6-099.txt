 
an agent communication protocol specifies the  rules of encounter  governing a dialogue between agents in a multiagent system. in non-cooperative interactions  such as negotiation dialogues  occurring in open societies it is crucial that agents are equipped with proper means to check  and possibly enforce  conformance to protocols. we identify different levels of conformance  weak  exhaustive  and robust conformance  and explore how a specific class of logic-based agents can exploit a new representation formalism for communication protocols based on simple if-then rules in order to either check conformance a priori or enforce it at runtime. 
1 introduction 
a protocol specifies the  rules of encounter  governing a dialogue between two or more communicating agents  rosenschein and zlotkin  1 . it specifies which agent is allowed to say what in any given situation. it will usually allow for several alternative utterances in every situation and the agent in question has to choose one according to its strategy. the 
protocol is public  while each agent's strategy is private. protocols can help to define a suitable standardised semantics for agent communication languages in order to allow actual interoperability in open environments. instead of being related to some  virtually inaccessible  private mental state of the agent as proposed by kqml  labrou and finin  1  and fipa   the meaning of a dialogue move refers to some publicly agreed and verifiable conversational state. for instance  one may equate the meaning of a dialogue move with the set of possible responses to this dialogue move as defined by the public protocol  pitt and mamdani  1 . of course  this does not disqualify the idea of a private semantics  but simply emphasises that standardisation cannot be achieved at this level. following these ideas  pitt and mamdani  have established the notion of a layered semantics for agent communication languages which integrates both private and public levels  and each agent must implement both of them to actually be able to converse with other agents. 
　when considering interactions that are not necessarily cooperative  typically negotiation   it cannot be safely assumed that agents will always follow the rules of encounter specified by a particular protocol. it is then crucial to provide proper means of evaluating how well agents are adapted to these protocols  in a sense that has to be precisely defined in the context of the interaction. in this paper  we introduce three different levels of conformance  weak  exhaustive  and robust conformance  and show that a logical representation of the protocols for logic-based agents greatly facilitates determining  both a priori and at runtime  whether or not these agents behave in conformance to the protocols. we also show how to enforce conformance at runtime for such agents and suggest a preliminary definition for the notion of protocol competence  an attempt to measure how well an agent is adapted to a given protocol beyond the basic requirements of conformance. 
　the remainder of this paper is organised as follows. in section 1 we introduce a new formalism for the representation of protocols based on if-then-rules. section 1 motivates the introduction of our three levels of conformance. abductive logic programming has recently been used as a basis for defining  private  strategies for agents negotiating over the distribution of resources  sadri et ai} 1 . section 1 introduces these agents  illustrates how to check protocol conformance for them  and shows how the agents themselves can ensure their conformance without requiring any extra reasoning machinery. section 1 concludes the paper. 
1 representing protocols 
in this paper  we will assume some restrictions on the kind of dialogues that we want to deal with. the dialogues we are considering only involve two agents which sequentially alternate dialogue moves. these restrictions  notably avoiding concurrency  allow us to concentrate on a particular class of protocols  namely those reprcsentable by means of deterministic finite automata  dfas   of which there are numerous examples to be found in the literature  pitt and mamdani  1; dignum and greaves  1 . our aim for this section is to introduce a protocol representation formalism based on simple if-then-rules and to show that it is adequate to represent the kinds of protocols that we are interested in here. 
　we recall here that a dfa consists of  i  a set of states  including an initial state  and a set of final states    ii  a set of events  and  iii  a transition function 1 which maps pairs of states and events to states. figure 1 shows an example  taken from  pitt and mamdani  1 . events are occurrences of dialogue moves; states are the possible stages of the conver-

multiagent systems 	1 


figure 1: the continuous update protocol 
sation. the protocol  entitled  continuous update protocol   aims at continuously updating the other agent about the value of some proposition. note that it is always the same agent a  the initiator  who informs the other agent b. the legal communicative behaviour of both agents is captured by such a protocol. we make this notion of legality precise in the following definition: 
definition 1  legality  given a dfa with transition function s  a dialogue move p is a legal continuation wrt. a state s iff there exists a state s' such that  
we shall refer to legal inputs  respectively outputs  for an agent x as those legal continuations where x is the receiver  respectively the utterer  of the dialogue move. 
　protocols such as that of figure 1 can alternatively be represented as sets of if-then-rules which specify the set of correct responses for a particular incoming dialogue move. for example  to express that agent b could react to an inform move sent by a either by sending an acknowledgement or by terminating the dialogue  we may use the following rule: 

note that variables arc implicitly universally quantified  except those that only appear on the righthand side of an implication  which are existentially quantified. in general  in this representation  dialogue moves are instances of the schema 
where x is the utterer  y is the receiver the identifier of the dialogue  and t the time when the move is uttered. subject is the type of the dialogue moves  i.e. a performative  such as end  of the communication language  possibly together with a content  as in inform p  . we shall mostly use the abbreviated form p{t  to dialogue moves  omitting the parameters not relevant in the discussion. for the sake of simplicity  we will assume that the start of the protocol is triggered by some external event start-it is possible to conceive this as the result of some meta-level negotiation process to agree on a particular protocol. the start signal start is sent by the system to exactly one agent and exactly once during a dialogue. similarly  a dialogue ends once one of the agents sends the signal stop to the system. dialogue inputs for the agents are either dialogue moves sent by other agents or a start signal sent by the system. 
　going back to the example of figure 1  we observe that this automaton in fact represents two subprotocols  one for the initiator  and one for its partner. we will refer to these two subprotocols as . they can be translated into a set  composed of two subsets  of if-then-rules as illustrated in table 1. in general  given a protocol we shall refer to the subprotocol guiding the behaviour of agent as  
　this example suggests that we can simply translate protocols into if-then-rules where we have a single performative on the lefthand side. we call protocols that permit such a straightforward translation shallow. shallow protocols correspond to dfas where it is possible to determine the next state of the dialogue on the sole basis of the previous event. of course  this is not always the case since it may be necessary to refer to the current state of the dialogue to determine the new state  think of two transitions with the same label leaving two different states and leading to two different states . in principle  any automata-based protocol can be transformed into a protocol that is shallow in this sense  by simply renaming any duplicate transitions . in fact  we have observed that many of the automata-based protocols proposed in the multiagent systems literature happen to be shallow already or could at least be made shallow by renaming only a small number of transitions. 
　now suppose px ... pn are the dialogue moves of our communication language  including start and stop . in the light of the above remarks  we will more generally translate dfas into two sets of rules of the form 

where the righthand side of the rule defines the possible continuations wrt. the protocol after the input p1  that we will sometimes refer to as the trigger of the rule . to ensure that this protocol is well-formed  we will require that the two sets of rules meet some requirements  r1-r1 : there has to be at least one rule with start on the lefthand side in the protocol  and start may never occur on the righthand side  rla  initial ; there is at least one rule with stop on the righthand side and stop never occurs on the lefthand side  rib  final ; any dialogue move occurring on the righthand side of the first subprotocol also occurs on the lefthand side of the second one  and vice versa  r1  matching ; every subprotocol includes the additional rule 

to avoid concurrent moves  r1  non-concurrency ; for each rule occurring in a subprotocol  if x is the receiver and y the utterer of the dialogue move occurring on the lefthand side  it must be the case that x is the utterer and y the receiver of every dialogue move occurring on the righthand side  r1  alternating ; all dialogue moves occurring on the lefthand side of the rules of each subprotocol are distinct from each other  r1  distinct triggers . 
　the meaning of each rule which appears in a protocol is intuitively clear: it specifies for any expected dialogue move the set of correct responses the agent may utter in reply. the following definitions make these notions more precise: 
definition 1  expected inputs  the set of expected inputs for an agent a wrt. a protocol v is defined as: 


1 	multiagent systems 

definition 1  correct responses  the set of correct responses for an agent a wrt. a protocol v and a dialogue move pj is defined as: 

intuitively it is not sufficient for a dialogue move to be merely expected in order to be considered legal; it is also necessary that the move takes place at the right moment in the history of the dialogue. but note that it follows from the property of matching  r1  that the set of legal inputs for an agent at a certain stage of a dialogue is a subset of its expected inputs. 
1 levels of conformance 
taking for granted that agents share the same language of communication  we are now going to define three different levels of conformance to a protocol. note that we define these notions on the basis of the observable conversational behaviour of the agents  i.e. what they utter  without making further assumptions on how they actually come to generate these utterances. we start with the notion of weak conformance: 
definition 1  weak conformance  an agent is weakly conformant to a protocol v iff it never utters any illegal dialogue moves  wrt. v . 
the following theorem shows that  in the context of our shallow protocols  the concept of legality is reducible to that of correctness  meaning that we can avoid to inspect the legality of the input and thus avoid to deal with the complete dialogue history. 
theorem 1 an agent that never utters an incorrect response in reply to an expected input of a shallow protocol v is weakly conformant to v. 
proof  sketch  for shallow protocols  the current dialogue state is uniquely identifiable given the latest move in the dialogue. hence  the notions of correct response and legal move coincide  i.e. an agent that never utters an incorrect response will never choose an illegal continuation and will therefore be weakly conformant to the protocol. ＆ 
it is clear that any application governed by a protocol at least requires the level of weak conformance-otherwise it would not make sense to define a protocol in the first place. the notion of weak conformance captures that the agent does not utter any illegal moves  but does not actually require that the agent utters any dialogue move at all. for interactions where  silent moves  are undesirable  a stronger version of conformance is usually required. we make this idea precise with the notion of exhaustive conformance: 
definition 1  exhaustive conformance  an agent is exhaustively conformant to a protocol v iff it is weakly con-
formant to v and it will utter at least one legal output move for any legal input ofv it receives. 
exhaustive conformance is certainly what is intuitively expected in most interactions-it is indeed often preferred to avoid considering silent moves as part of a protocol  at least to avoid confusion with lost messages. one may then argue that exhaustive conformance should be the minimum requirement for any interaction. we believe  however  it is worth making the distinction between weak and exhaustive conformance. the first reason is that there are examples where the lack of response can be considered to be part of the protocol. in such circumstances  it can be sufficient to design a weakly conformant agent  provided that silent moves will not have undesirable consequences. for instance  in a dutch auction process  when there is no signal of acceptance from the other parties in the auction  other agents in the negotiation  the auctioneer makes a new offer which he believes more acceptable  by reducing the price . here  because of the convention  protocol  under which the auction operates  a lack of response is sufficient feedback for the auctioneer to infer a lack of acceptance.  uennings et al.  1j. in this case  the agent can safely be designed to react appropriately only to the proposals it is ready to accept. but if we consider recent argumentationbased protocols inspired by dialectical models it is sometimes assumed that  'silence means consent   amgoud et al. 1. in this case  a lack of response can commit the receiver to some propositions-this is a typical case where it is crucial that agents are exhaustively conformant. the second reason for our distinction of weak and exhaustive conformance is that they are conceptually different since weak conformance only involves not uttering  any illegal moves   while exhaustive conformance involves uttering  some legal move . this implies substantially different approaches when the issues of checking and enforcing conformance are raised  as we shall see below. 
   another important problem of agent communication is the need to deal with illegal incoming messages  and to react appropriately to recover from such violations. for instance  any fl pa-compliant communicative agent has to integrate a performative n o t - u n d e r s t o o d as part of its language  fipa  1. this motivates us to introduce the following notion of robust conformance: 
multiagent systems 	1 definition 1  robust conformance  an agent is robustly conformant to a protocol v iff it is exhaustively conformant to v and for any illegal input move it will utter a special dialogue move  such as 
robust conformance goes a step further than exhaustive conformance since it requires that an appropriate response is uttered also in reply to illegal moves. technically  this necessitates that the agent is able to identify the legality of an incoming dialogue move  i.e. it needs to be able to check conformance wrt. the other agent's subprotocol. 
　note also that in the case where all agents in the society are known to be weakly conformant  it is theoretically unnecessary to deal with robust conformance  since no agent will ever utter an illegal move . such an assumption would  however  somewhat contradict the  spirit  of an open society. we should also point out that in dialogues with a very high contingent of illegal utterances the additional notunderstood moves may in fact burden communication channels unnecessarily and simply ignoring illegal moves would in fact be a better strategy. 
1 logic-based agents 
we are now going to consider the case of a specific class of agents based on abductive logic programming that have recently been used in the context of negotiation scenarios  sadri etal  1 . the communication strategy s of such an agent  which forms part of its so-called knowledge base k  is represented as a set of integrity constraints of the following form: 

on receiving dialogue move p at time t  an agent implementing this rule would utter p' at time t + 1   provided condition c is entailed by its  private  knowledge base. again  variables are understood to be implicitly quantified in the same way as our protocol-rules. 
1 	checking conformance 
there are different ways of checking conformance. one way is to check conformance on-the-fly  i.e. to check step by step that every dialogue move uttered by an agent is conformant to the protocol. another way-much more interesting when one has to design an agent to take part in an interaction-is to check conformance a priori  i.e. to check conformance by examining the specification of the agent rather than an actual dialogue. in general  this is a difficult task  because  i  the behaviour of the agent depends on some hardly tractable notions  e.g.. beliefs and intentions   and  ii  conformance may depend on the history of the dialogue. we are now going to discuss some simple sufficient conditions for weak conformance  in the context of the logic-based agents introduced earlier  that may be checked a priori. 
　to begin with  we introduce the notion of response space. intuitively  the response space of an agent specifies the possible moves that the agent can make when using a given strategy 1  without considering the specific conditions relating to its private knowledge base. 
definition 1  response space  the response space of an agent with strategy s  henceforth noted s*  wrt. a communication language c is defined as the following set: 
that is  the response space is  essentially  the set of protocolconstraints we get by first dropping all private conditions c and then conjoining implications with identical antecedents by collecting the corresponding consequents into a single dis-
junction. the reason why we define the disjunction of the empty set as will become clear when we consider the next theorem  which offers a very simple way to check weak conformance a priori for a logic-based agent. in particular  it avoids dealing with the dialogue history  and it does not make any assumptions on the content of the agent's knowledge base  except to require that it is possible to extract the response space  as previously described . 
theorem 1 let v be a protocol and let s* be the response space of an agent a wrt. the language of moves occurring in  then agent a is weakly conformant to v. 
proof let 1* be the response space of agent a wrt. the language of protocol then for every rule in   will contain an implication 
 with the same antecedent p -and possibly a number of additional implications for dialogue moves in the language that do not occur as triggers in  all the antecedents of the implications in 1* are distinct.  now suppose holds. observe that a formula of the form in can only be the consequence of an implication in s* with the same antecedent 	will only follow from provided we have 
　in other words  whenever holds  then will have the shape of a protocol that is a  syntactic restriction  of the protocol   possibly together with a number of irrelevant rules  with triggers not present in furthermore  by construction  any agent will be weakly conformant to the  protocol  represented by its response space. hence  agent a will also be weakly conformant to because any dialogue continuation that would be legal wrt. would certainly have to be legal wrt. .  	
the opposite direction of theorem 1 does not hold  because  looking at the form of strategies  it is clear that private conditions may prevent the agent from uttering a particular dialogue move. in other words  it could be the case that s*   v but that the agent is still weakly conformant to v because of its specific knowledge base. 
　the same argument prevents us from having a theorem similar to theorem 1 in the case of exhaustive conformance  and of course for robust conformance . here we would have to look more precisely at how dialogue moves are actually being generated. the basic idea would be to check that  for every expected input in the protocol  the disjunction of the conditions c related to this move in the agent's strategy is entailed by the agent's knowledge base. 
1 	enforcing conformance 
even when theorem 1 is not applicable and an agent cannot be proven to be weakly conformant a priori  it is still pos-

sible to constrain the agent's behaviour in such a way as to simply prevent it from uttering illegal moves. the problem of enforcing conformance  referred to as regimentation by jones 
1 	multiagent systems 


table 1: examples of dialogue strategies 

and sergot   is then to try to find easy  and hopefully automatic  ways to ensure that an agent will always be conformant to a given protocol. 
　we will now show how a simple filtering function may be defined in the context of our logic-based agents. since this relies on the concrete behaviour of our agents  this requires some details about the operational model which underlies these agents. by a generated response we now mean a response produced by the abductive iff proof procedure of fung and kowalski   1 . in our case  the abducibles are the dialogue move s  that the agent will actually generate as the consequence of the observation of another agent's dialogue move  see  sadri et aly 1  for details . 
theorem 1 an agent generating its dialogue moves wrt. the knowledge base  will be weakly conformant to  
proof   sketch  let us assume that p{t  is a legal input  wrt. protocol   that our agent receives  and that is a move generated as a response by the agent. since the move is legal  it is expected in  the proof procedure will produce a tree and each branch of this tree will have one of the correct responses  together with the constraints of the dialogue strategy and the additional condition of nonconcurrency  r1 . now if is a generated response of the proof procedure  must also be a conjunct on one of these branches. but such a branch will evaluate to false if  precisely because of the condition of non-concurrency. this means that the procedure will never generate an incorrect response. therefore  by theorem 1  our agent will be weakly conformant to  ＆ 
thus the filtering function is provided by the protocol itself. this result has very practical consequences. for instance  before entering an interaction  an agent can ensure its weak conformance to the public protocol which regulates the interaction  and thereby avoid possible penalties imposed by society   by adding the protocol to its own knowledge base. now  while we can prevent an agent from uttering illegal dialogue moves  it is difficult to see how we could force it to utter some dialogue move  exhaustive conformance  without considering its private knowledge base and modifying its private strategy. we therefore believe that exhaustive conformance cannot be enforced automatically and should ideally be ensured during the specification of the agent by the designer. 
　note that this filtering function will not block correct responses generated by the agent  unless two or more moves are being generated at the same time. this is again due to the non-concurrency condition  r1 . 
　we should also point out that it is possible that an agent with knowledge base would not utter any dialogue move given a particular input p t   while an agent with knowledge base  i.e. the same agent after  downloading  the protocol would utter a  legal  move. this may  for instance  be the case if p{t  never occurs on the lefthand side in the agent's original strategy and v includes a  deterministic  protocol rule such as . if this type of behaviour is not intended  we have to ensure that the communication languages of the agent and the protocol match  for instance  by adding the constraint to the agent's strategy for every move p that is an expected input in  
1 	examples 
we are now going to illustrate some of the points made earlier by means of example. consider again the continuous update protocol of table 1  and more specifically subprotocol vb. the set of constraints given in table 1 represents two possible strategies for an agent a. here  the - -operator is understood as negation as failure. we assume that the predicates friend and enemy are fully defined in the knowledge base of our agent  that is  it can determine whether or not an agent x is a friend or an enemy   and we also assume that an integrity constraint stipulates that it is not possible to be at the same time friend and enemy of the same agent 
 friend   
　dialogue strategy s  relies upon the communication language  which is based on the set {inform{p  question{p  ack end}. it is interesting to note that no rule can be triggered after a question about p if it is the case that the agent a does not consider x as a friend. however  the agent a is still weakly and exhaustively conformant to since this move can never be legally uttered within the protocol by its partner  it is not a legal input for subprotocol  
multiagent systems 	1 　next consider dialogue strategy s1  which relies upon the communication language  based on the set {inform p   challenge{p  ack  end . agent a is not weakly conformant to vb since  in some situations  namely  when it does not consider x as friend  neither as an enemy   it may want to challenge the initiator x. this move is not expected in the protocol  if the agent a decides to enforce weak conformance as described earlier in theorem 1  it will remain silent in the situation previously described. 
finally  let us consider an agent with the response space 
  that is  an agent that never utters any 
dialogue moves at all. it is clear that such an agent will be weakly conformant to any protocol. this certainly suggests that the notion of conformance alone is not sufficient to evaluate how well an agent is adapted to a protocol. 
　another application of the notion of response space could be to assess how well an agent can explore a given protocol beyond the minimal requirement of being able to conform to it. intuitively  given a protocol v  we would expect a  competent  agent to have a response space that  almost   covers  v  namely it has the potential to utter as many dialogue moves as the protocol allows. this would offer a notion complementary to that of conformance. 
　note also that none of the agents discussed here is robustly conformant. one of the reasons for this latter remark is the fact that these agents cannot notice that the dialogue move they receive is not legal if it is an expected input  for instance if their partner starts the dialogue with an ack . they would consequently react  appropriately  to these moves- which can be quite confusing. 
1 conclusion 
this paper has introduced different levels of conformance as basic notions to check and enforce that the behaviour of an agent is adapted to a public protocol regulating the interaction in a multiagent system. these notions have been explored in the context of the logic-based agents of sadri et al. . our approach starts from on an alternative representation formalism for communication protocols based on if-then-rules for the kinds of protocols that can be represented as dfas. in particular  we argue that it is typically not necessary to consider the history of the dialogue besides the previous move to determine the possible legal dialogue continuations  shallowness . this allows us to show that a sufficient condition for an agent to be weakly conformant is to never give an incorrect response in reply to an expected input. in the context of logicbased agents we have used this result to propose a simple way to check a sufficient condition for weak conformance  which has the great advantage of ignoring the conditions related to the  private  knowledge base  by identifying an agent's response space   and avoids to consider the dialogue history. we have then shown how the concrete behaviour of the iff proof procedure can be used to define a regimentation policy to enforce weak conformance. finally  we have illustrated these notions and their limitations by means of examples. 
　a number of results have previously been obtained in the context of agents based on abductive logic programming  e.g. the termination of certain types of negotiation dialogues  sadri et al.  1 . on the one hand  because we mostly ignore the details of the knowledge bases of agents and do not restrict ourselves to any specific protocol here  we cannot obtain such strong results. on the other hand  our work provides more general tools for logic-based agents communicating by means of  various  public protocols. 
　the work presented here can be extended in a number of ways. in particular  we only deal with very specific kinds of dialogues  although they can be generated by a wide range of protocols . amongst other things  we plan to explore whether our formalism is expressive enough to capture more complex dialogues  such as those taking place between more than two agents or those not representable using dfas  e.g. dialogues where concurrency is allowed or where checking conformance requires reference to the content of a dialogue move rather than just the communicative act itself -
acknowledgements. we would like to thank the ijcai referees for their helpful comments. this research has been funded by the european union as part of the socs project  societies of computees   ist-1. 
