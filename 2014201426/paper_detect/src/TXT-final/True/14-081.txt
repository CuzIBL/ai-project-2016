 
a technique is presented for taking a program written in pure 
lisp and automatically deriving a program which computes the inverse function of the given program the scheme is based on a set of rules for inverting the primitive functions plus a method of solving for variables introduced by non-invertible functions. as an example  a program to reverse a list is inverted. 
1. introduction 
　this paper describes ongoing research on the problem of automatically inverting applicative programs. the motivation for this work is to achieve a better understanding of the transformation of computer programs. inversion is an important program manipulation problem. in addition  program inversion may prove to be a fruitful special case for studying the general transformation problem the domain of purely applicative programs is chosen because the absence of side effects results in much cleaner program manipulation. 
　the program inversion problem was originally addressed by mccarthy 1  in the context of turing machines sickel  provides an algorithm for determining the invertibility of logic programs. dijkstra  presents a manual derivation of the inverse of an imperative program. a rule for inverting the cons construct in applicative programs is described by scherhs . wadler  has implemented a limited inversion facility as pari of the interpreter for his what  language. darlington's  program transformation system handles inversion by the folding and unfolding of recursion equations. however  his system requires the user to specify the different input cases for the inverse program neither wadler nor darlington address the issue of the generality of their mechanisms. 
this research was sponsored by the defense advanced research projects 
agency  dod   arpa order no 	1  monitored by the air force avionics 
laboratory under contract f1 c 1. the views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies  either expressed or implied  of the defense 
advanced research projects agency or the us government 1 　given a program p  we define the inverse of p as p'1 such that p1 p x   = x for all x in the domain of p. our problem is to automatically derive p 1 from p. in other words  starting with an equation of the form y = f x   we want an equation in the form f1 y  = x the contribution of this paper is a new method for attacking this problem. it involves successively stripping off the outermost function on the right-hand side and adding the corresponding inverse function to the left-hand side. each primitive construct in the language requires a separate rule and an additional rule is required to handle recursive and auxiliary function calls. constructs without a unique inverse are inverted by the introduction of new variables the values of these variables are determined by solving the simultaneous equations generated by this process the language chosen is a minimal subset of pure lisp  including car  cdr  cons  cond  and equal. 


　finally  if the outermost function on the right-hand side of the current equation is a recursive call to the function we are trying to invert  then we generate a recursive call to the inverse function on the left hand side. in other words  if f x  is the original function  and the current equation is of the form 

we can replace it with 

where f 1 is the name of the inverse function. 
　this same rule applies when the outermost function on the right-hand side is a user defined auxiliary function. it is replaced by its own inverse on the left hand side and the equation defining the function must then be inverted. note that if a function has two arguments  its inverse consists of two separate functions  one to produce the first argument and one to produce the second argument. these are distinguished by subscripts in the example below. 
1. example: reverse of a list 
　as an example of the application of this technique  we invert a program which computes the reverse of a list. reverse 
 abbreviated r  takes a list and reverses the order of its top level elements. it uses an auxiliary function  tailcons  abbreviated c   which appends an element to the end of a list. note that our goal is to express the argument z as a function of r z  or s. the derivation is shown in figure 1. 
　the resulting program removes the last element of the list and adds it to the beginning of the reverse of the rest of the list. c x-1is one of the inverses of tailcons. and returns the front of the list excluding the last element. similarly  c y-1 is the other inverse  and returns the last element of the list. what remains is to derive these two inverses from c  x  y . this is done in figure 1. 
1. observations and current research 
　an obvious question at this point is how do we know that all the indeterminate variables can be solved for. if a function has a unique inverse  or in other words is one to-one  then the equations that result from applying our rules will have a unique solution. however  our ability to solve those equations will ultimately limit the power of this method. 
　if a function is not one-to-one  then this technique produces a partial inverse in the sense of inverting what can be inverted and indicating exactly what information is missing. for example  consider inverting a program which swaps the elements of a 
　two-element list: 

after inversion becomes 

this is a partial inverse because the variable a remains indeterminate. the reason is that we neglected to specify that the 

　

1 
	another observation is that the program for the inverse of 	 	dijkstra  e. w. 
reverse is not the same as the original program. even though the 	program inversion. 
inverse of the reverse function is the same function  the inverse of 	unpublished notes  ewd1  pp. 1. 
the reverse program is in fact the program derived in the example. 
	 1  	mccarthy  john. 
inverting the inverse of a program should yield the original 	the inversion of functions defined by turing machines. 
program  and it does in the case of reverse. 	in shannon  c.e.  and j. mccarthy  editors   automata 
studies  pages 1. princeton university press  
	current research on this problem is focused on extending this 	princeton  n.j.  1. 
technique to more complex inversion problems in addition  i hope 
	 	mccarthy  john  et al. 
to prove the correctness of the method for as wide a class of 	lisp 1 programmers manual. 
programs as possible. in particular  since the inversion algorithm 	mit. press cambridge  mass.  1. 
implements a one-to one function  it should be possible for the 
algorithm to invert itself. 	 	scherlis  w. l. 
expression procedures and program derivation. 
phd thesis  department of computer science  stanford 
acknowledgments 	university  august  1. 
	i would like to thank allen newell  bill scherlis  and herbert 	sickel  sharon. 
 
simon for several helpful discussions concerning this research. in 	invertibility of logic programs. 
addition  merrick furst  michael horowitz  greg korf  bruce lucas  	in proceedings of the fourth workshop on automated 
and mark stehlik read and provided constructive comments on 	deduction  pages 1. austin  texas  feb.  1. 
drafts of this paper. 
	 	wadler  phil. 
what's what  
1. 
