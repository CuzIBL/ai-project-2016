 
todays computer interfaces are one-size-fits-all. 
users with little programming experience have very limited opportunities to customize an interface to their task and work habits. furthermore  the overhead induced by generic interfaces will be proportionately greater on small form-factor pdas  embedded applications and wearable devices. automatic personalization may greatly enhance user productivity  but it requires advances in customization  explicit  user-initiated change  and adaptation  interface-initiated change in response to routine user behavior . in order to improve customization  we must make it easier for users to direct these changes. in order to improve adaptation  we must better predict user behavior and navigate the inherent tension between the dynamism of automatic adaptation and the stability required in order for the user to predict the computers behavior and maintain control. this paper surveys a decade's work on customization and adaptation at the university of washington  distilling the lessons we have learned. 
1 introduction 
today's software is mass produced with a plethora of features designed to satisfy every user. but since different people are working on different tasks with different styles  there is no way to organize features in a way that makes essential functionality convenient for everyone. consider word processing  for example; most people will never use automatic line numbering  but legal secretaries couldn't survive without it. 
　the shift away from the desktop and towards pervasive computing greatly exacerbates the problem of  steelcase inspired  software for several reasons. first  the shift from quiet office to ubiquitous use introduces complex environmental factors that increase the differences between the usage patterns of distinct individuals; indeed  a single user will require different features depending on context. second  the form 
　 current address: google inc  1 bayshore parkway  mountain view  ca  1 
   +current address: ibm tj watson research center  p.o. box 1  yorktown heights  ny 1 
factor of mobile devices is enormously more variable than that of desktop machines - for example  the ratio of large to small desktop display size is about four  but it varies by a factor of 1 between a cell-phone and a liveboard. 
　the wisdom of user-centered design have been well documented  lewis and reiman  1 . however  as user needs and device characteristics diverge  the traditional design methodology of intensive user studies becomes unscalable. while each user deserves a personalized interface  designed for the device at hand and providing simple access to the commands and features they need  there aren't enough ethnomethodologists and designers to manage  interpret  and respond to so many studies. indeed  the only resources that scale with the number of users are the users themselves and the computing devices they are using. 
　we use the term adaptation to denote personalization which is automatically performed by the interface without explicit user directives. by customization we mean personalization which is directly requested by the user. our argument  thus  is that adaptivity and customization are the only scalable approaches to personalization. interfaces should automatically adapt to the capabilities of the device at hand  to network connectivity  and to the individual user's activities  location  and context; users should be able to guide and control adaptation through a variety of customization mechanisms. 
1 customization and adaptation 
of course  many existing desktop applications allow limited customization by letting the user  1  select which menus are visible   1  add buttons to toolbars   1  define macros  and  1  even add custom functionality via scripting languages such as visual basic. while customization is important  most users fail to customize effectively. few users are comfortable with macros  regular expressions  or scripting languages  and even programmers are often too busy to invest the necessary time now in order to speed future sessions. thus  the challenge is to create improved methods for users to direct their interface  rearrange functionality as well as appearance  and recover from inappropriate adaptations. 
　similarly  many systems support limited adaptation  but users don't always appreciate it. defaults that remember the last option or directory selected are simple and can be helpful  but microsoft's smart menus disorient  while the office 

invited speakers 	1 

assistant's guesses fall far from the mark. the danger of adaptivity is its potential to create confusing inconsistency and rob the user of control. thus  the challenge is to develop datamining algorithms that can accurately predict a user's behavior and to navigate the tension between too rapid adaptation  disorienting  and too little  inefficient   and to seek interface metaphors that increase user control. 
1 	deep deployment 
successful customization and adaptation methods will maximize their benefit when used by a broad range of applications. ideally  there will be deep deployment'  a uniform layer at the operating systems level that records clickstream data across applications  and supports ubiquitous personalization. for this to work  the interfaces themselves must be described using declarative representations like those developed by the model-based interface community  foley et al  1; 
puerta  1  
　deploying personalization methods at the os layer will bring several advantages. the first is consistency of behavior amongst applications. second  knowledge of a user's activity with one application may improve adaptation of another's interface. third  cross-application personalization may offer the highest benefit to users  since many common tasks involve patterns connecting two or more programs. 
1 	outline 
in the rest of this paper  we describe a sequence of our projects which are making progress on this vision. the underlying techniques range along a continuum of user-involvment  and our expository progression follows this vector from customization towards pure adaptation. along the way we compare related endeavors and summarize lessons learned. 
1 customization by command 
the internet softbots project  etzioni and weld  1  marked the genesis of work on intelligent user interfaces at the university of washington. by acting as a personal assistant  the softbot supported a qualitatively different kind of human-computer interface. users were able to make highlevel requests  and the softbot used search  weld  1   inference  etzioni et al.  1   and knowledge to determine how to satisfy the request. furthermore  the softbot was able to tolerate and recover from ambiguity  omissions  and errors in these requests. 
　at its core  the softbot could handle goals specified in an expressive subset of first-order logic with modal operators for handling time and for distinguishing information gathering goals from those that requested state changes  golden and weld  1 . we labeled the softbot a goal-oriented interface  because human requests specified what the user wanted; the softbot was responsible for deciding how and when to satisfy the request. since most users are uncomfortable with logical notation  we provided a forms-oriented interface front end. unfortunately  we found the forms approach to be unscalable  and goal-specification was a challenge for many users. in response  we investigated two research directions: reliable natural-language interfaces  popescu et al  1; yates et al.  1  and programming by demonstration  lau et al  1 . 
1 programming by demonstration 
if it's too hard for users to specify goals  then a natural objective is the design of an interface that can watch a user's normal behavior and help as appropriate. in the case of repetitive tasks  this amounts to programming by demonstration  pbd . of course  pbd has been studied extensively  cypher  1   but most previous systems were heuristic and domainspecific. we sought a domain-independent approach  suitable for deep deployment  that offered the expressiveness of a scripting language and the ease of macro recording  without a verbatim recorder's accompanying brittleness. while our pbd interface resembles a keystroke-based macro interface  it generalizes from the demonstrated actions to a robust program which is more likely to work in different situations. it is useful to think of a pbd-interface as having three components: 1  segmentation determines when the user is executing an automatable task  1  trace induction predicts what the user is doing from a prefix of her activity trace  and 1  facilitation manages user interaction to aid the user in completing her task. the focus of our work was on the trace induction phase. 
　we formalized pbd trace induction as a learning problem  as follows. a repetitive task may be solved by a program with a loop  where each iteration solves one instance of the task. the pbd system must infer the correct program from a demonstration of the first few iterations. each action  e.g.  move  select  copy  paste  ...  the user performs during this demonstration causes a change in the state of the application  e.g.  defines a mapping between editor states . therefore  we modeled this problem as one of inferring the function that maps one state to the next  based on observations of the state prior to and following each user action. 
　pbd presents a particularly challenging machine learning problem  because users are extremely reluctant to provide more than a few training instances. thus the learner must be able to generalize from a very small number of iterations. yet in order to be useful  a wide range of programs must be learnable. thus the problem combines a weak bias with the demand for low sample complexity. our solution  called version-space algebra  lets the application designer combine multiple strong biases to achieve a weaker one that is tailored to the application  thus reducing the statistical bias for the least increase in variance. in addition  the learning system must be able to interact gracefully with the user: presenting comprehensible hypotheses  and taking user feedback into account. version-space algebra addresses this issue as well. 
1 	version-space algebra 
originally developed for concept learning  a version space is the subset of a hypothesis space which is consistent with a set of training instances  mitchell  1 . if there is a partial order over candidate hypotheses  one may represent the version space implicitly  i.e.  with boundary sets  and manage updates efficiently. version space algebra defines transformation operators  e.g.  union  join  etc.  for combining simple 

1 	invited speakers 


figure 1: algebraic specification of the version space for a smartedit program. 
version spaces into more complex ones. we also developed a 
probabilistic framework for reasoning about the likelihood of each hypothesis in a composite version space. 
　after constructing a library of reusable  domainindependent component version spaces  we combined a set of primitive spaces to form a bias for learning text-editing programs  figure 1   which was used in the smartedit pbd implementation. 
1 	the smartedit implementation 
we verified the utility of version-space algebra for pbd with 
smartedit  an emacs-like editor. when a user notices that she is about to perform a repetitive task  she clicks a button to start the pbd recorder. after completeing one instance of the task  she clicks another button to mark the first demonstration. smartedit initializes the version space using the recorded state sequence as the first training example. as the user continues to type  smartedit updates the version space with every action. in parallel  smartedit displays what action it thinks the user will next perform  and its confidence in the prediction. these probabilities are calculated by voting the version space. when the user is confident that smartedit has learned her procedure  she may let it execute in single-step or fully autonomous mode. we explored a number of ways of structuring the user's dialog with the learner  including decision-theoretic control  wolfman et al  1   but many aspects of facilitation require further study. 
　version-space algebra provides smartedit with several benefits: efficient methods for incremental update and voting  without explicit enumeration of the version space  lau et al  1   and flexibility. by varying the algebraic formulation for the hypothesis space  we experimented with several other version spaces for learning single-loop programs from traces with varying amounts of segmentation information  as well as learning programs with multiple nested loops. 
1 	experiments and observations 
empirical studies validated our approach on a range of textediting scenarios  e.g.  bibliographic reformatting  html to  conversion  information extraction  etc. . we show that a program that generalizes correctly for each of these scenarios can be learned quickly in as few as one or two training examples. an informal user study confirmed smartedit's usability and usefulness  and showed that even novice smartedit users perform tasks more quickly and concisely with pbd than without. 
　however  we learned a negative lesson when we started widespread distribution - despite incorporation within emacs  relatively few people used smartedit frequently. 
from this we conclude that the overhead of a macro recorder interface is relatively high. since most repetitive tasks are short  it is often easier to do them manually and avoid the cognitive load of complex customization. others have found similar results - users customize relatively little  mackay  1  - perhaps because customization facilities are complex themselves  mcgrenere et al  1 . we conjecture that widespread pbd adoption requires automatic segmentation  and the adaptation mechanisms  described in the next section  may provide this capability. 
1 	adapting to user behavior 
the ai community has a long-standing interest in adaptive interfaces. the calendar's apprentice  dent et al  1  used machine learning to predict meeting location and durations. this research and similar work on email classification  maes and kozierok  1  led to an important principle about the incorporation of imperfect behavioral predictions in an interface: defaults are an effective way to minimize the cost to the user of  inevitable  poor predictions. horvitz's decision theoretic framework  horvitz  1  resulted in additional principles: graceful degradation of service prediction  expected utility of disambiguation dialogs as a function of user time and attention   and the use of timeouts to minimize cost of prediction errors.1 
　our work on adaptive interfaces focussed initially on website design  perkowitz and etzioni  1  and led to algorithms for datamining web logs to discover aggregate patterns  which powered the automatic creation of index pages  perkowitz and etzioni  1 . later we concentrated on mining individual behavior patterns  generating personalized sites for display on small  wireless devices  anderson et al  1b   our emphasis was on  information-goal seeking  behavior  common to wireless internet use  rather than general browsing or surfing. the proteus system modeled adaptation as search through the space of possible websites. site modification operators included highlighting text  adding shortcut links  and eliding parts of pages. we adopted the decision-theoretic approach  guiding search with expected utility calculations based on a model of the cost of manipulating the small pda screen and fetching pages over the slow wireless connection. 
　a small user study revealed two important lessons. for the most part  the adaptations were good ones; proteus suggested useful shortcuts and the elided content was almost always useless to the user. however  the cost of deleting important parts of a page was very high. reweighting our utility function would have led to more conservative behavior  but 
   'it is ironic that the office assistant violates most of horvitz' s principles  which were developed at microsoft research. 

invited speakers 	1 


figure 1:  a  main dialog box for print command   b  after clicking the  properties...  button  the default  setup  tab is displayed   c  after clicking the  features  tab  the user can select double-sided printing; the user must now click  ok  twice. 

the problem of accurate behavior prediction is central to interface adaptation; we discuss it in the next section. 
　a second problem stemmed from the fact that frequently users didn't find a shortcut link  even though proteus had added it in the appropriate place. shortcut-naming was usually to blame  and this raised the general issue of saliency  which we discuss in section 1. 
1 	predicting user behavior 
high-quality adaptation requires the ability to learn an extremely accurate model of user behavior. our comparison of existing techniques showed that a mixture of markov models had the best predictive power  anderson et al  1a . 
 shortcuts generated by the mixture model saved users up to 1% of their navigational effort.  but all models performed poorly when data was sparse; hence none of these models would work well for situations where a user is exploring new parts of the interface - even if she is performing a task which is similar to one she has performed frequently in another context  e.g.  shopping cart checkout at a new store . to remedy this problem  we developed relational markov models  rmms   a generalization of markov models that overlays relational structure on the states  anderson et al  1 . 
　intuitively  rmms do for markov models what probabilistic relational models  prms  do for baysian networks  friedman et al.  1 . rmms generalize markov models by partitioning the states into classes; each class has an associated k-ary relation  r  and members of the class correspond to r instantiated with distinct ground values. the domain of each variable can be hierarchically structured  and a smoothing techniqued called shrinkage is carried out over the cross product of these hierarchies. rmms make it possible to generalize beyond the observed states. for example  suppose a user surfing through an e-commerce web site goes from a page about nirvana's  nevermind  cd to a page containing a biography of nirvana. an ordinary markov model can infer nothing from this about what the user will do when visiting a page about a pearl jam cd  but an rmm would be able to infer that the user might next go to a pearl jam biography. rmms make effective learning possible in domains with very large and heterogeneous state spaces  given only sparse data. experiments on academic and e-commerce websites show that rmms trained on only ten instances perform as well as markov models which were trained on ten thousand instances  anderson et al  1 . we are currently extending rmms by incorporating structure in the same way that dynamic bayes nets extend markov models; see  sanghai et al  1 . 
1 	partitioned dynamicity 
as our experience with unnoticed shortcuts showed  saliency is essential - any adaptive mechanism that introduces new commands or options to an interface  must ensure that the user finds them. furthermore  the mechanism must take care not to obscure important existing functionality. 
　one way to increase saliency  while minimizing the cognitive dissonance associated with adaptivity  is to partition dynamism - to segregate dynamic and static areas of an interface. indeed  a number of well-designed adaptive interfaces exhibit this property. for example  the news stories and advertisements on yahoo change continuously  but because the layout is fixed  the adaptation causes little distress to users. in contrast  the automatic menu shortening feature of microsoft office 1 violates partitioned dynamicity  since the location of commands in the menus changes unpredictably. 
　powerpoint xp's  insert symbol  command provides another example. previous versions required a long sequence of clicks to select the correct font and navigate to the desired symbol  but the dialog box in the xp version has a  recently used symbols  area. 
　we conjecture that partitioned dynamicity is a useful general principle for adaptation in interfaces. because 

1 	invited speakers 


figure 1: abstract-state machine for the printing dialogs; the example user's path is darkened. 
users become accustomed to changes in the dynamic area  these changes don't disturb their conceptual model  norman  1 . and because existing navigational patterns remain unchanged  users maintain control even if adaptation is unhelpful. the alternative  dual-interface approach of  mcgrenere et al  1  shares many benefits with partitioned dynamicity  but trades convenience for screen real estate. 
1 	example: adapting desktop dialogs 
we believe that the proteus architecture  developed for adaptive websites  would be even more useful in a desktop application setting. as a story-board example  suppose that a user wishes to print a word document  doublesided. as figures 1 and 1 show this requires six user actions.1 first  the user presses c t r l - p to print the current document. next  she must click on  properties...  which yields  setup  options. clicking on the  features  tab uncovers two sided printing options; another click selects book-style duplex. then  ok  must be clicked twice  once to close the properties window and the other to confirm printing.1 however  if an individual user executes this pattern hundreds of times  always choosing duplex printing  the system should recognize this and provide a shortcut. 
　figure 1 shows one possible result  where the main screen has partitioned dynamicity  and the duplex options  with a new default value  have been added. in this example  we assume that the user had never chosen the  tablet  duplex value. for the shortcut  therefore  the system deleted the value  casting the duplex variable into a boolean. as a result  the duplex option could be rendered with a simple  space-efficient checkbox. of course  if the user later desired the tablet format  they 
1 using windows me  office xp  and a hp r1 printer. 
1 of course  one can quibble with the design of this particular interaction  but it is a result of today's software engineering process  and many similar designs exist -that's why adaptation is so promising 

figure 1: after adaptation  duplex printing is the default and visible on the main print dialog. by discarding the infrequently used  tablet  value  the variable can be cast as a boolean and a simple  space-efficient check-box widget used. could find it unchanged on the  features  tab.1 
　restricting a state variable's set of valid values and type casting are just two representative transformations; many more exist. note that it is only possible to perform these transformations when the interface is represented in an abstract  declarative language. the next section discusses additional benefits from such a representation. 
1 adapting to device characteristics 
the trend towards mobile and ubiquitous computing has resulted in an morass of device form factors and input mechanisms  and it is nearly impossible for a designer to target each of these manually. furthermore  as shown in previous section  some parts of the interface may be generated dynamically in response to the particular usage patterns. hence  we are building an automated solution  called supple. others researchers have laid useful foundations. starting with  foley et ai  1   the model-based ui community has developed declarative  interface-representation languages; supple uses an extension of the representation developed for pebbles  nichols et ai  1 . 
　researchers have explored many methods for  compiling  a declarative ul representation into concrete form for use on a specific target device. for example  pebbles uses a hand-constructed decision tree for this task; other approaches include hierarchical templates  szekely et ai  1   stylesheets  schreiber  1   and tools for facilitating 
　　1  some might argue that this problem could be simply solved by using a mru default for options like duplex  without restructuring the dialogs. but changing defaults is very dangerous unless they are visible to the user. 

invited speakers 	1 


figure 1: given different pda screen resolutions  supple generates different interfaces for a household controller. 

manual design  eisenstein et al  1 . yet another method is based on a higher-level encoding of the design in terms of design patterns  lin and landay  1 . 
　in contrast  we adopt the decison-theoretic framework and search for the design with the highest expected utility among those that satisfy the device constraints. our supple prototype focusses on screen-size constraints and uses a utility function that models the expected ease of interface operations for each widget. if multiple interface actions are necessary to complete a task  e.g.  if tabs must be selected  panes navigated  or confirmation buttons pressed  the costs are combined linearly. figure 1 shows three different interfaces  from amongst the 1 1 possible  which were generated by supple and deemed optimal for differing amounts of available screen space. 
　while the current supple implementation accepts as input an arbitrary probability distribution over command usage  our framework supports user-based adaptation as described in the previous section. for example  at present supple makes an independence assumption regarding command use  but in practice people use commands in sequence and human designers recognize this by colocating the corresponding widgets. by computing the expected utility of an interface relative to a recorded trace of individual user commands  supple should be able to automatically duplicate this form of design optimization  but in a personalized manner. 
1 	conclusions 
effective personalization requires improved methods for both adaptation  change based on implicit user behavior  and customization  change guided by explicit user requests . interfaces should automatically adapt to the capabilities of the device at hand  to network connectivity  and to the user's activities  location  and context. if they wish to provide customization guidance  users should be able to control the adaptation process at any level. 
　this paper has briefly surveyed some of the projects at the university of washington  which are investigating these issues  and codified several emerging principles: 
  because users find it hard to specify their prefences and goals  it is often more effective to induce them from user behavior. version-space algebra allows an application designer to combine multiple strong biases to achieve a weaker one that is tailored to the application  thus reducing the statistical bias for the least increase in variance. 
  many benefits of model-based ui design have been long recognized  foley et al.  1   but it is increasingly apparent that these declarative models are essential to a set of transformations  e.g.  currying and casting  that facilitate adaptation. 
  since adaptive mechanisms are imperfect  the cost to users of errors must be considered alongside the advantages. decison theory provides a powerful framework for such analysis  horvitz  1   and the requisit utilities can be learned from user behavior or derived from device models. 
  certain interface mechanisms  such as defaults and au-tomatic timeouts  can minimize the cost of errors and so increase the value of adaptation. partitioned dynamicity offers a way to manage adaptivity while minimizing a user's cognitive load. 
  another way to enhance the user experience by improv-ing prediction of user behavior. because rmms smooth  based on an abstraction lattice defined by the relational structure  they are exceptionally accurate when predicting sequential behavior  e.g.  a user's next action  from sparse data. 
acknowledgments 
we thank james landay for helpful discussions. this research was funded in part by office of naval research grants 

1 	invited speakers 

n1-1 & nooo 1-1  national science foundation grants iri-1  iis-1  dl-1  and a career award. 
