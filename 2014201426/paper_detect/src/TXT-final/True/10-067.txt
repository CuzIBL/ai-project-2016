: this paper describes the current status of the psi fragments  checking for completeness and correctness  fills in 
program synthesis system. it alloius program specification detail  corrects minor inconsistencies  and adds cross-references. dialogues using natural language  traces and examples from 
                                                                       it also generalizes the program description  converting it into a which a high-level program model is acquired. this model is then form that allows the coder to look for good implementations. refined into an efficient implementation of the program. psi 
                                                                       the completed program model may be interpreted by a special consists of several modules including a parser-interpreter  trace model interpreter to check that it performs as desired by the user and examples inference expert  dialogue moderator  program 
model builder  coder and efficiency expert. and also to gather information needed by the efficiency expert such as statistics on set sizes and on probabilities of outcome of tests. 
keywords; 	artificial 	intelligence  automatic 	programming. 
the psi program synthesis system is a computer program that acquires high-level descriptions of programs and produces efficient implementations of these programs. simple symbolic computation programs are specified through dialogues that include natural language  input-output pairs  and partial traces. the programs produced are in lisp or in sail. 
psi is organized as a collection of interacting modules or programmed experts. the overall design is a group effort with 
one individual having responsibility for each module as follows: parser-interpreter jerrold ginsparg  ginsparg-1 ; trace and example inference module jorge v. philips  phillips-1 ; moderator louis i. steinberg; domain expert ronny van den heuvel; model builder brian p. mccune  mccune-1 ; coder 
david r. barstow  barstow-1 ; and efficiency expert elaine kant  kant-1 . this paper presents a short description of psi. for further details and discussion of related work  see the references above; for a fuller overview see the description of the 
design of psi as of one year ago  creen-1 . 
the major data paths and modules of the psi system are shown in the diagram below. multiple program specification methods are allowed in the user's dialogue with psi  including english  input and output examples  and partial traces. a more conventional method  that of a very high-level language is a planned addition to psi as shown in the diagram. 
psi's operation may be conveniently factored into an acquisition phase  those modules shown above the program model which acquire the model  and the synthesis phase  those modules shown below the model which produce a program from the model . sentences are first parsed  then interpreted into fragments. the parser is a relatively general parser which limits search by incorporating considerable knowledge of english usage. the interpreter is more specific to automatic programming  using program description knowledge as well as knowledge of the last question asked and the current topic to facilitate the interpretation into fragments. 
fragments and the program model form two of the major interfaces within psi. both are high level program and data structure description languages. the program model includes complete  consistent  and executable  but slowly  
	auto. pro .  	nropn 
1 

another input specification method is partial traces. a trace includes as a special case an example input-output pair. examples are useful for inferring data structures and simple spatial transformations. partial traces of states of internal and i/o variables allow the inductive inference of control structures. the trace and example inference module infers loose descriptions of programs in the form of fragments  rather than programs themselves. this technique allows domain support to disambiguate possible inferences  and also separates the issue of efficient implementation from the inference of the user's intention. general programming knowledge is distributed throughout the modules described above. currently  domain-specific knowledge is also distributed where appropriate  but a domain expert module is being implemented. application domain-specific knowledge  e.g.  knowledge about learning programs  will be concentrated in this module  which will supply domain support by communicating with other acquisition modules through the fragment interface. 
the moderator  not shown in the diagram  guides the dialogue by selecting or repressing questions for the user. it attempts to keep psi and the user in agreement on the current topic  provides a review-preview on a topic change  helps the user that gets lost  and allows initiative to shift between psi and the user. a new module being planned by richard cabriel i% an explainer  which will generate reasonably clear questions about and descriptions of program models as they are acquired  in order to help verify that the inferred program description is the one desired. it also will be able to explain the how and why of the acquisition and synthesis process to the interested user. 
after the acquisition phase is complete  the synthesis phase begins. this phase may be viewed as a series of refinements or as a heuristic search for an efficient program that satisfies the program model. the coder has a body of program synthesis rules  green and barstow-1  1  that gradually transform the program model from abstract into more detailed constructs until it is in the target language. both algorithm and data structures are refined interdependently. the coder deals primarily with the notions of set and correspondence operations and can synthesize programs involving sequences  loops  simple input and output  linked lists  arrays  and hash tables. 
the refinement tree effectively forms a planning space that proposes only legal  but possibly inefficient  programs. this tree structure is shared by the coder and the efficiency expert. in cases where the coder proposes more than one refinement or implementation  the efficiency expert reduces the search by estimating the time-space cost product of each proposed refinement. the better path is followed and there is no backup unless the estimate later proves to be very bad. an additional planned method to reduce the size of the search space is the factoriiation of the program into relatively independent parts so that all combinations of implementations are not considered. an analysis for bottlenecks can allocate synthesis effort to more critical parts of the program. 
in summary  we have formulated a framework for an automatic programming system and have a start on the kinds of programming knowledge that must be embedded therein. psi is moderately successful in that it is currently running and has synthesized many significantly different programs including simple storage and retrieval and learning programs. however  not all of the planned modules are completed yet  and it is still too early to attempt an evaluation of the overall design  its applicability  or the methods used. 
acknowledgements 
the individuals responsible for the work reported here include the current psi members - brian p. mccune  jorge v. phillips  louis i. steinberg  david r. barstow  jerrold ginsparg  ronny van den heuvel  and elaine kant  as well as former members bruce nelson  avra cohn  and juan ludlow. 
this research was supported by the defense advanced research projects agency at the department of defense under contract mda 1-c-1. 
