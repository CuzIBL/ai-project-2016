
we combine the modal logic s1 with the description logic  dl  alcqi. the resulting multi-dimensional dl s1alcqi supports reasoning about change by allowing to express that concepts and roles change over time. it cannot  however  discriminate between changes in the past and in the future. our main technical result is that satisfiability of s1alcqi concepts with respect to general tboxes  including gcis  is decidable and 1-exptime-complete. in contrast  reasoning in temporal dls that are able to discriminate between past and future is inherently undecidable. we argue that our logic is sufficient for reasoning about temporal conceptual models with time-stamping constraints.
1 introduction
an important application of temporal description logics  tdls  is the representation of and reasoning about temporal conceptual models  artale  1; artale et al.  1; 1 . knowledge captured by such models is translated into a tdl tbox and reasoning algorithms for tdl are then used to detect inconsistencies and implicit is-a relations in the temporal model  artale and franconi  1; artale et al.  1; calvanese et al.  1 . a serious obstacle for putting this general idea to work is posed by the fact that for many natural temporal conceptual formalisms and their associated tdls  reasoning turns out to be undecidable.
﹛the most prominent witnesses of this problem are the various temporal entity-relationship  ter  models used to design temporal databases  chomicki and toman  1 . ters are classical er data models extended with two additional classes of constraints that model the temporal evolution of data in an application domain  spaccapietra et al.  1 . first  timestamping constraints are used to distinguish temporal and atemporal components of a ter model. timestamping is usually implemented by marking entities  i.e.  classes   relationships and attributes as snapshot  temporary  or unrestricted. the idea behind such a classification is to express that object membership in entities  relationships  and attribute values cannot or must change in time; this is achieved by snapshot and temporary marks in the diagram  respectively. second  evolution constraints govern object migration between entities and can state  for example  that every instance of the entity child will eventually become an instance of the entity adult.
﹛ter models with both timestamping and evolution constraints can be translated into the tdl dlrus  artale et al.  1 . unfortunately  reasoning in this logic is undecidable. moreover  the computational problems are not due to the translation to tdls: even direct reasoning in the generally less powerful ter models is undecidable  artale  1 . there are two principal ways around this problem. the first approach restricts the application of timestamping: it allows arbitrary timestamping of entities  but gives up timestamping of relationships and attributes  i.e.  all relationships and attributes are unrestricted . this re-establishes decidability of ter models with restricted timestamping and evolution constraints  artale et al.  1 . the second approach to regaining decidability allows for full use of timestamping  but prohibits the use of evolution constraints.
﹛this second alternative is pursued in the current paper. we devise a multi-dimensional description logic s1alcqi that is obtained by combining the modal logic s1 with the standard dl alcqi. the s1 modality can be applied to both concepts and roles; axioms in the tbox are  however  interpreted globally. this logic can be viewed as a description logic of change: it can express that concept and role memberships change in time  but does not permit discriminating between changes in the past or future. we show that ter models with full timestamping  i.e.  timestamping on entities  relationships  and attributes  but withoutevolution constraints can be captured by s1alcqi tboxes.
﹛the main contribution of this paper is to show that reasoning in s1alcqi is decidable. we also pinpoint the exact computational complexity by showing 1-exptime completeness. thus  adding the s1 change modality pushes the complexity of alcqi  which is exptime-complete  by one exponential. our upper bound can be viewed as an extension of the decidability result for a simpler multi-dimensional dl  s1alc   gabbay et al.  1  which is not capable of cap-
turing ter models. however  we had to develop completely new proof techniques as the decidability proof for s1alc relies on the ability to duplicate points in a model  which is impossible in the presence of s1alcqi's number restrictions. our lower bound applies also to s1alc  hence we show that this logic is also 1-exptime-complete.
﹛the paper is organized as follows. section 1 introduces the logic s1alcqi. section 1 shows that reasoning in s1alcqi is decidable in 1-exptime by first providing a tree abstraction of s1alcqi interpretations and then presenting a 1exptime procedure that checks for the existence of such a tree abstraction. section 1 illustrates how s1alcqi is able to capture conceptual models with timestamping constraints. full proofs and the 1-exptime lower bound can be found in the full version of this paper  artale et al.  1 .
1 the logic s1alcqi
the logic s1alcqi combines the modal logic s1 and the description logic alcqi in a spirit similar to the multidimensional dls  gabbay et al.  1; wolter and zakharyaschev  1 . the syntax of s1alcqi is defined as follows. let nc and nr be disjoint and countably infinite sets of concept names and role names. we assume that nr is partitioned into two countably infinite sets nglo and nloc of global role names and local role names. the set rol of roles
. the set of
concepts con is defined inductively as follows: nc   con; if c d ﹋ con  r ﹋ rol  and n ﹋ n  then the following are also in con:   and c. a tbox is a finite set of general concept inclusions  gcis with c d ﹋ con.
﹛an s1alcqi-interpretation i is a pair  w i  with w a non-empty set of worlds and i a function assigning an alcqi-interpretation i w  =  忖 ﹞i w  to each w ﹋ w  with 忖 a fixed non-empty set called the domain and ﹞i w a function mapping each a ﹋ nc to a subset ai w   忖 and each r ﹋ nr to a relation ri w   忖℅忖; for r ﹋ nglo we additionally require ri w = ri v for all w v ﹋ w. we extend the mapping ﹞i w to complex roles and concepts as follows:

 
and y ﹋ ci w} ≡ n}

an s1alcqi-interpretation i =  w i  is a model of a tbox t iff it satisfies ci w   di w for all
w. it is a model of a conceptfor some w ﹋
w. a concept c is satisfiable w.r.t. a tbox t if there exists a common model of c and t . note that when s1alcqi is considered a temporal description logic  the elements of w correspond to time points. we do not distinguish between global and local concept names because a concept name a can easily be enforced to be global using the gci.
the concept constructors 
  and ﹠ are defined as abbreviations in the usual way. for roles  we allow only single applications of s1 modalities and inverse. it is easily seen that roles obtained by nesting modal operators and inverse in an arbitrary way can be converted into an equivalent role in our simple form: multiple temporal operators are absorbed and inverses commute with temporal operators.
﹛the fragment s1alc of s1alcqi is obtained by allowing only roles of the form  and r  and replacing the concept constructor   n r c  by  r.c. we note that neither s1alc nor s1alcqi enjoys the finite model property: there are concepts and tboxes that are only satisfiable in models with both an infinite set of worlds w and an infinite domain 忖. an example of this phenomenon is the concept  c and the tbox  with r ﹋ nglo.
1 reasoning in s1alcqi
we show that in s1alcqi  satisfiability w.r.t. tboxes is decidable in 1-exptime. for simplicity  throughout this section we assume that only local role names are used. this can be done w.l.o.g. as global role names can be simulated by r  for r a fresh local role name. let c1 and t be a concept and a tbox whose satisfiability is to be decided. we introduce the following notation. for roles r  we use inv r  to denote r  if r ﹋ nr  s if r = s   inv  and inv s  if. we use rol c1 t   to denote the smallest set that contains all sub-roles used in c1 and t and is closed under inv. we use cl c1 t   to denote the smallest set containing all sub-concepts appearing in c1 and t that is closed under negation: if c ﹋ cl c1 t   and     is not the top level operator in c  then  c ﹋ cl c1 t  .
﹛in the rest of this section we devise tree abstractions of models of c1 and t which we call  c1 t  -trees. in the subsequent section  we then show how to construct looping tree automata that accept the  c1 t  -trees and thus reduce satisfiability in s1alcqi to the emptiness problemof looping tree automata  yielding decidability of s1alcqi.
1 tree abstractions of s1alcqi models
intuitively  for a  c1 t  -tree 而 that abstracts a model i of c1 and t   the root node of 而 corresponds to an object x in i that realizes c1. successors of the root in 而 correspond to objects in i that can be reached from x by traversing a role in some s1 world. similarly  further nodes in 而 correspond to objects of i reachable from x by traversing multiple roles. to describe the concept and role interpretations of i in its abstraction 而  we decorate the nodes of 而 with extended quasistates as introduced in definition 1 below. extended quasistates are defined in terms of types and quasistates  which we introduce first. intuitively  a type describes the concept memberships of a domain element x ﹋ 忖 in a single s1 world.
definition 1  type . a type t for c1 t is a subset of cl c1 t   such that
for  c ﹋ cl c1 t  
for for
we use tp c1 t   to denote the set of all types for c1 and t . to describe the concept memberships of a domain element in all s1 worlds  we use quasistates:
definition 1  quasistate . let w be a set and f : w ↙ tp c1 t   a function such that for all w ﹋ w we have:
c ﹋ f w  iff c ﹋ f v  for some v ﹋ w.
we call the pair  w f  a quasistate witness and the set {f v  | v ﹋ w} a quasistate.
to check whether a set of types {t1 ... tn} forms a valid quasistate  we can simply check whether the pair  w f   with w = {t1 ... tn} and f the identity function  is a quasistate witness. note  however  that each quasistate has many witnesses.
﹛quasistates only abstract concept membership of a particular object in all worlds. to capture the role structure relating objects adjacent in some s1 world in a given s1alcqi model  we develop the notion of a extended quasistate. ultimately  in the desired tree abstraction these two objects turn into a parent and a child nodes; the child is then labeled by the extended quasistate in question. note the similarity to handling inverse roles using the double blocking technique used in tableau algorithms for alcqi  horrocks et al.  1 .
definition 1  extended quasistate . let w be a set   w f  and  w g  quasistate witnesses  and h : w ↙ rol c1 t   ﹍  such that  for every r ﹋ nr ﹍ {s  |
  for some w ﹋ w  then h v  = r  for some v ﹋ w;
1. if h w  = r  for some w ﹋ w  then either or h v  = r  for all v ﹋ w;
1. it is not the case that h w  = r for all w ﹋ w;
  for some w ﹋ w  then  for all v ﹋ w.
we call  w f g h  an extended quasistate witness and the set of triples q w f g h  = { f v  g v  h v   | v ﹋ w} an extended quasistate. elements of q w f g h  are called extended types and etp c1 t   denotes the set of all extended types for c1 and t . we say that q w f g h  realizes a concept c if c ﹋ f w  for some w ﹋ w; we say that q w f g h  is root if for all w ﹋ w.
intuitively  given a node labeled with the extended quasistate witness  w f g h   the quasistate witness  w f  describes the node which is labeled with the extendedquasistate   w g  describes the predecessor of this node  and h describes the role connections between the two nodes. conditions 1 to 1 ensure that the mapping h assigns roles in a way that respects the semantics of modal operators. to fully understand these conditions  note that we assume an ordering  between roles which allows us to use a single role in the extended quasistate to capture all the implied roles. the dummy role 汍 is intended only for use with the root object  which does not have a predecessor.
﹛we now introduce the concept of a matching successor. the main difficulty is to properly capture the effects of qualified number restrictions   n r c  which constrain the possible combinations of extended quasistates in  c1 t  -trees: the extended quasistates assigned to children nodes must satisfy the qualified number restrictions of the parent node.
definition 1  matching successor . let w and 忙 be sets  x /﹋ 忙  and let e be a function mapping each y ﹋ 忙﹍{x} to an extended quasistate witness  w fy gy hy  such that gy = fx for all y ﹋ 忙. we call  w 忙 x e  a matching successor witness if for all w ﹋ w:
1. if   n r c  ﹋ fx w  and or inv
hx w  then |{y ﹋ 忙 | r ≒ hy w  c ﹋ fy w }| ≡ n 
  then |{y ﹋ 忙 | r ≒ hy w  c ﹋ fy w }| ≡ n   1 
﹛﹛n r c ﹋ cl t  c c ﹋ g w r ≒ x     and 忙          1
then
1 and |{y ﹋ 忙 | r ≒ h w  c f w }| ≡ n n r c f w .
the pair  q w fx gx hx  {q w fy gy hy  | y ﹋ 忙}  is called a matching successor .
﹛we say that two matching successor witnesses are equivalent if they define the same matching successor.
the intuition behind this definition is as follows: the object x stands for a parent node  described by fx  and the set of objects 忙 for all its children  described by fy . the extended quasistates are chosen in a consistent way w.r.t. the information that is represented twice: the parent part of the extended quasistates labeling the children matches the quasistate attached to the parent itself  i.e.  gy = fx for all y ﹋ 忙 . a matching successor witness is then a witness such that the extended quasistates attached to x and to all elements of 忙 can be used to build a part of a model of c1 and t without violating any qualifying number restrictions. also  the domain of such a model is eventually built from the objects {x}﹍忙. as already mentioned  matching successors are the most crucial ingredient to the definition of  c1 t  -trees.
definition 1   c1 t  -tree . let 而 =  n e g n1  be a tuple such that  n e  is a tree with root n1 ﹋ n and g a mapping of 而's nodes to extended quasistates. then 而 is a  c1 t  -tree if:
1. g n1  realizes c1;
1. g n1  is root;
1. for all n ﹋ n  the pair  g n  {g m  |  n m  ﹋ e}  is a matching successor.
note that the matching successor witnesses induced by the matching successors consisting of the extended quasistates associated with a node and its children in the  c1 t  -tree do not necessarily share the same set w. this poses a difficulty when showing that  c1 t  -trees are proper abstractions of models of c1 and t : when we want to convert such a tree into an interpretation  we need to decide on a common set of worlds w. this difficulty can be overcome using the following lemma  which shows that we can assume that all extended quasistate witnesses are based on sets of world w of identical cardinality.
	x	y1 y1	﹞﹞﹞	yl yl+1	﹞﹞﹞	ym 1 ym	﹞﹞﹞	yn yn+1	﹞﹞﹞	﹋ 忙
w	糸	糸	糸	糸	﹞﹞﹞
  world w is replaced by worlds {v1 ... vl}
v1 v1
	..	...	...
vl	
figure 1: reducing the size of a matching successor witness.lemma 1  compatible matching successor . there exists an infinite cardinal 汐 such that the following holds: for every matching successor witness  w 忙 x e   there is a matching successor witness  such that
   w 忙 x e  and  define the same matching successor and;
  for all y ﹋ 忙 ﹍ {x} and all extended types 糸 ﹋
  we have:

intuitively  the lemma is proved by replicating elements of w a sufficient number of times. when all extended quasistate witnesses for a  c1 t  -tree are based on a set of worlds of identical cardinality  we can connect these extended quasistate witnesses to a model by simply permuting the set w in an appropriate way. in this way  we can prove the difficult right-to-left direction of the following theorem. theorem 1. c1 is satisfiable w.r.t. t iff a  c1 t  -tree exists.
1 decidability and complexity of s1alcqi
we now develop an effective procedure to check whether there exists a  c1 t  -tree for a given concept c1 and tbox t . we also show that the procedure runs in 1-exptime. since it is easy to see that the number of all possible matching successors  q q  is 1-exponential  we cannot simply generate all of them and check whether they give rise to a  c1 t  -tree. instead  we start by showing that if a  c1 t  tree exists  then there is one with slim matching successors witnesses only  i.e.  all matching successors in this tree are witnessed by matching successor witnesses whose size is at most exponential. in the rest of the paper  let maxc1 t =   and n = |cl c1 t  |.
lemma 1. let  w 忙 x e  be a matching successor witness for a matching successor  q q . then there is a and a matching successor witness  such that: n ﹞ 1 .
we call a matching successor witness slim if it satisfies the cardinality bounds given in the above lemma. we call a matching successor slim if it has a slim matching successor witness.
﹛to prove lemma 1  we need to construct the required slim matching successor witness  from  w 忙 x e . to this end  we choose a set  and a function 米 that associates an extended type 米 y  with every such that   米 y  ﹋ q w fy gy hy  and
  if 糸 ﹋ q w fz gz hz  for some then we have.
the function 米 tells us which objects in 忙 can  in every particular world w  be used to fulfill number restrictions that have been originally fulfilled by  extended types of  objects in .
﹛the set 忙  in turn  is the basis to constructing a slim witness as it can always be chosen in a way such that |etp c1 t  |﹞ maxc1 t +1  ≒ n﹞1n﹞ maxc1 t +1 . finally  for a witness in which |忙| is bounded as above  we can simply eliminate superfluous worlds of w to obtain a slim witness. this can be done by keeping at most |etp c1 t  | ≒ n ﹞ 1n worlds for each element of; those worlds can be chosen from w independently.
﹛the crucial step of the actual construction is illustrated in figure 1: consider a particular world w. in the original witness the number restrictions in the parent object are fulfilled  e.g.  by the objects yl+1 ... yn with ym ... yn falling outside of the set 忙. assume first  for simplicity  that the objects ym ... yn have been assigned a common extended type 糸. we then pick objects y1 ... yl ﹋ 忙 such that 米 y1  = ﹞﹞﹞ = 米 yl  = 糸. since n   m + 1 ≒ maxc1 t we can always find l ≒ maxc1 t + 1 of such objects in 忙 such that l = n   m + 1; follows from the definition of 忙. thus we can transform the old witness to a new one as depicted in figure 1. whenever more than one extended type is associated with ym ... yn in the original witness  we simply pick objects in 忙 with an appropriate matching 米 value and proceed similarly to the above example. to construct a slim matching successor witness we fix the set 忙 and apply this transformation to all w ﹋ w independently. note that the transformation preserves quasistates associated with all objects in 忙  hence all s1 modalities are preserved  and that all number restrictions are met.
lemma 1. there is a procedure that runs in 1-exptime to generate all slim matching successors.
we simply use a brute-force approach to enumerate all candidates for slim matching successor witnesses up to exponentially sized 忙 and w and test for satisfaction of the conditions in definition 1.
﹛as the next step  we show that whenever a  c1 t  -tree exists  then there is a  c1 t  -tree constructed solely from slim matching successors  i.e.   g n  {g m  |  n m  ﹋ e}  is a slim matching successor for all n ﹋ n. we call such a
 c1 t  -tree slim.
lemma 1. for any c1 and t   a slim  c1 t  -tree exists whenever a  c1 t  -tree exists.
since the children in a slim matching successor are a subset of the children in the original matching successor  it is easy to convert an arbitrary  c1 t  -tree into a slim one.
﹛finally  to check whether a slim  c1 t  -tree exists we define a looping tree automaton ac1 t that accepts exactly the slim  c1 t  -trees. to check satisfiability of c1 w.r.t. t   it then suffices to check whether this looping automaton accepts at least one such tree. this observation yields a 1-exptime decision procedurefor satisfiability in s1alcqi as the emptiness problem for looping tree automata is decidable in time linear in the size of the automaton  vardi and wolper  1 .
﹛we use extended quasistates as states of the automaton ac1 t and slim matching successors to define the transition relation. since c1 t -trees do not have a constant branching degree  we use amorphous looping automata which are similar to the automata model introduced in  kupferman and vardi  1  except that in our case the branching degree is bounded and thus the transition relation can be represented finitely in a trivial way.
definition 1  looping tree automaton . a looping tree automaton a =  q m i 汛  for an m-labeled tree is defined by a set q of states  an alphabet m  a set i   q of initial states  and a transition relation 汛   q ℅ m ℅ 1q.
let t  be a tree with root r ﹋ n and labeling function. a run of a on t is a mapping 污 : n ↙ q such that 污 r  ﹋ i and  汐 汕  ﹋ e}  ﹋ 汛 for all 汐 ﹋ n. a looping automaton a accepts those labeled trees t for which there exists a run of
a on t.
we construct an automaton for c1 and t as follows.
definition 1. let c1 be a concept and t an s1alcqi tbox. the looping automaton ac1 t =  q m i 汛  is defined by setting m = q = etp c1 t    i := {q ﹋ q | q realizes c1 and q is root}  and 汛 to the set of those tuples
 q q q  such that q ﹋ 1q and  q q  is a slim matching successor for c1 and t .
the following lemma states that the obtained looping automata behaves as expected.
lemma 1. 而 is a slim  c1 t  -tree iff 而 is accepted by
ac1 t .
it is easily seen that there are at most 1-exp many extended quasistates and thus ac1 t has at most 1-exp many states. to construct the transition function of the automaton  we need to construct all slim matching successors which can be done in 1-exptime by lemma 1. since emptiness of looping automata can be checked in polynomial time  the overall decision procedure for satisfiability in s1alcqi runs in 1exptime. this holds regardless of whether numbers inside number restrictions are coded in unary or in binary.
theorem 1. satisfiability in s1alcqi w.r.t tboxes is decidable and 1-exptime-complete.
the lower bound in theorem 1 is obtained by reducing the word problem of exponentially space-bounded  alternating turing machines. since the reduction does not use inverse role and qualifying number restrictions  we also obtain a 1exptime lower bound for satisfiability on s1alc.
corollary 1. satisfiability in s1alc w.r.t tboxes is decidable and 1-exptime-complete.
1 capturing conceptual schemata
it is known that the tdl alcqius is able to capture the temporal conceptual model erv t  a ter model that supports timestamping and evolution constraints  is-a links  disjointness  covering  and participation constraints  artale et al.  1 . in erv t  timestamping is implemented using a marking approach as sketched in the introduction. the translation of atemporal constructs is similar to the one using alcqius; see  artale et al.  1  for full details and examples. in the following we briefly recall the translation of atemporal constructs and then show that s1alcqi is sufficient to capture the fragment of erv t that has timestamping as the only temporal construct.
﹛when translating erv t to tdls  entities e-denoting sets of abstract objects-are mapped into concept names ae and attributes p-denoting functions associating mandatory concrete properties of entities-are mapped into roles names rp interpreted as total functions  which is enforced by the
gci. in s1alcqi  unrestricted entities and attributes need no special treatment. properties of snapshot or temporary entities and attributes are captured as follows:
	snapshot entity 	temporary entity 	snapshot attribute 	temporary attribute
 relationships-n-ary relations between abstract objects-are translated using reification: each n-ary relationship r is translated into a concept name ar with n global role names r1 ... rn. intuitively  for each instance  the tuple  y1 ... yn  with  x yi  ﹋ rii w is a tuple in the relationship r at a time point w. to ensure that every instance of ar gives rise to a unique tuple in r  we use gcis  for 1 ≒ i ≒ n. to capture snapshot relationships  we assert   while for temporary relationships  we assert  in the tbox.
﹛note that the latter gcis do not fully capture temporary relationships. as an example  consider the interpretation i =  {w1 w1} i   with 
 
1	= { 	 }	. although the gci   expressing temporary relationships  is satisfied   b c  is constantly in the temporary relationship r. this is due to a mismatch between the models of an erv t schema and the models of its translation into s1alcqi. in particular  in models of erv t  tuples belonging to relationships are unique while in models of the reified translation there may be two distinct objects connected through the global roles ri to the same objects  thus representing the same tuple  e.g. the objectsin the above interpretation . then  s1alcqi models in which the above situation occurs do not directly correspond to any erv t model. similarly to  calvanese et al.  1   however  it is possible to show that:  i  there are so called safe models of s1alcqi that are in one-to-one correspondence with erv t models  and  ii  every satisfiable s1alcqi concept is also satisfied in a safe model. when reasoning about erv t schemas  we can thus safely ignore non-safe models. an s1alcqi interpretation i =  w i  is safe for an erv t schema if  for every n-ary relationship r reified with the global functional roles ri  and every w ﹋ w  we have the following:
 x y x1 ... xn﹋忖 :    x x1  ﹋ r1i w ＿  y x1  ﹋ r1i w ＿ ... ＿  x xn  ﹋ rni w ＿  y xn  ﹋ rni w .
it is not hard to see that:  1  the model in the example above is not safe  and  1  given a safe model  the above gcis correctly capture the temporal behavior of relationships.
1 conclusions
this work introduces the modal description logic s1alcqi as a logic for representing and reasoning in temporal conceptual models with timestamping constraints. a novel technique is used to show decidability and 1-exptimecompleteness for s1alcqi. this is also the first decidability result that allows reasoning in temporal conceptual models with timestamping for entities  relationships  and attributes. furthermore  reasoning on the less expressive logic s1alc is also shown to be 1-exptime-complete.
﹛this paper leaves several interesting open problems for further investigation. the fine line separating the decidable tdls from the undecidable ones is not fully explored: we plan to investigate further extensions of s1alcqi that still enjoy decidability. two natural candidates are s1alcqi that allows  in addition to s1 modalities  an irreflexive   thus enabling statements about everywhere else  and s1alcqi with temporalized axioms  enabling tbox statements to appear in scope of s1 operators . another open issue concerns decidability and complexity of s1alcqi in finite models.
﹛on the knowledge representation side  we believe that a converse translation-from ter with full timestamping to s1alcqi-is also possible; this result would allow to fully characterize the complexity of reasoning in ter with timestamping. the limits of the expressive power of s1alcqi
w.r.t. various constraints that have appeared in literature on temporal models other than timestamping also remain to be determined.
