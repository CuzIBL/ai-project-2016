 
we describe three experiments using meta-language and meta-reasoning to solve problems involving belief  heuristics  and points of view. these experiments use the knowledge representation system sphere  built at hewlett-packard laboratories and based on the ideas of fol . a key idea underlying our research is the segmentation of knowledge into contexts and the meta-linguistic treatment of these contexts as objects. 
	i 	introduction 
　　recent research in artificial intelligence has focused on meta-knowledge  1 1 . meta-knowledge has attracted attention because of an increasing awareness that much of reasoning is about language and the structure of knowledge. several representation systems have mechanisms for embodying meta-linguistic constructs  among them krl   prolog   lcf   mrs  and omega . most of these systems use a quoting mechanism to distinguish language from meta-language. one system  fol   separates language and meta-language into different contexts and makes language structures true objects to meta-contexts. this results in a more expressive and uniform system. 
　　in this paper we summarize three examples of meta-theoretic represention and reasoning. we implemented these examples in the representation system sphere  an intellectual descendant of fol. we describe sphere in the next section; for the moment it is sufficient to understand that sphere encapsulates knowledge in contexts. these contexts can manipulate other contexts; a context that manipulates another is a meta-context. the first example uses a  tree  of metacontexts to represent beliefs about beliefs. we reason about the beliefs of a participant in a competitive bidding situation. the second example illustrates describing heuristics declaratively in met a-contexts. in this example  we describe the game of mastermind to a context and describe heuristics for playing the game to its meta-context. the last example 
shows how contexts can present and manipulate multiple views of a single underlying object. the problem domain is that of using graphics effectively to gain an understanding of rubik's cube. 
ii sphere 
　　key features of sphere are: 1  all statements are relative to some context. 1  a context is a triple  composed of its own language  individuals  functions and relations   a set of facta  wff's   and a partial model  the simulation structure  semantic attachments . conceptually  a context is a self-contained theory of some domain. 1  the basic inference mechanism is simplification: the reduction of an expression  term or wff  to a simpler form. these systems have two important simplification mechanisms: syntactic simplification and semantic simplification. syntactic simpiication uses the facts  axioms  of a context as re-writing rules. semantic simplification uses the values of computationally effective procedures and data structures to transform expressions.* the power of these systems arises from using the data 
* more specifically  the attachment to a constant  relation or funcstructures that encode expressions and contexts as the semantic attachments to constants in meta-contexts. thus  a constant in the language of one context  the meta-context  can be semantically attached to the data structure that encodes another context  the subordinate context . the meta-context can manipulate that constant as it does any other constant. we present examples of this meta/subordinate manipulation later in this paper. 
contexts have parallels in systems such as frl   viewpoints 
  conniver   and qa1 . manipulating the syntax of language independently from the mechanisms that effect its semantics parallels work on 1-lisp . sphere  like its ancestor fol  cleanly defines and uniformly integrates these mechanisms in a mathematically rigorous system. we have also used sphere as the semantic base for a natural language understanding system  and for a system that unifies the relational and algebraic database calculi. 
	ill 	bid 
　　our first example shows how to represent some aspects of the concept of belief with multiple contexts. our strategy is to embody an agent's beliefs in a context: entering that context to reason with the agent's beliefs and treating that context as an object to reason about the agent's beliefs. 
　　we view the world subjectively from the perspective of  the context of  p  the president of a paint company. he bids on contracts to supply paint. in deciding what to bid  he needs to consider the bids and bidding practices of his competitors  q and r. we represent p's belief's about q and r's beliefs as the constants q and r in p's context. we attach contexts to these constants. these contexts resemble p's context in many respects  including representing competitors as constants with attached contexts. 
　　belief contexts all share a common language of paint manufacturing. making paint requires possession of a process. processes vary between companies. each process uses several ingredients  for any given process  p  and ingredient  i  quanty p i  is the amount of i used in p. calcium-carbonate  alkyd-resin  and titanium-dioxide are typical ingredients. 
tion  syntactic objects  in a context is a pair: the name of a context and the name of a constant in that context. frequently  this named context is the lisp context. procedurally  semantic simplification translates  through attachments  the terms of an expression into an expression in another context  runs the simplification mechanism in that context  and translates the result back to the original context.  this translation process may involve passing through several intermediate contexts.  not all contexts have the same simplifies in particular  the simplification mechanism in the lisp context is the lisp evaluator. thus  in semantic simplification  the data structures that encode contexts and expressions often become the arguments for lisp functions that manipulate contexts and expressions. 
1 r. filman et al. 
　　every paint company president believes he can get each ingredient for a given cost cost i   though costs may vary between companies. for each process  the proceucott p  is the cost of making paint with that process: the scalar product of the quantity and cost of each ingredient. 
　　each company also has its own competitors and a pricing-practice. a pricing-practice is a function of a company's costs and the lowest bid of its competitors. each pricing-practice determines the company's bid. each belief context has this general knowledge about paint processes  arithmetic and bidding. 
a context p represents the state of p's beliefs. 
this context has an axiom representing p's pricing practice and axioms representing p's beliefs about his costs for commodities. in context p  constant 
q  r  represents p's belief's about  the state of q's  r's  beliefs . each of these constants is attached to a context  contexts q and r . each of these contexts has the language of paint bidding. q has an axiom for pricing-practice  representing what  p believes is q's pricing-practice . it has axioms representing what  p believes q believes are q's commodity costs . and it has two constants  p and r. this second constant  r  is attached to a context  qr  that represents p's beliefs about q's beliefs about r. 
　　clearly  we can continue hypothesising contexts indefinitely  representing  p's beliefs about q's beliefs about p's beliefs about q's...  in practice  we stop at the fourth level. figure 1 shows the resulting context structure. we have fifteen contexts representing beliefs  arranged in a tree. 
　　p's bid is the result of applying his pricingpractice to his minimum process cost and the lowest expected bid of his competitors. we use another meta-context to compute bids. the metacontext finds p's minimum cost  determines his competitors and computes the expected bid of each competitor in the competitor's context. the meta-context then determines the bid by simplifying the pricing-practice of the results. the computation is a recursion  similar to the familiar recursion of mini-maxing game trees. the recursion halts at the leaves of the context tree  where contexts do not have attachments to competitors. at that point  only a company's costs are used in computing its bid. 
　　we used these structures to describe some  actual beliefs  to the system. figure 1 summarizes the results of this test run. for the example  we asserted that p believes that 1  there is a standard process known to all manufacturers; 1  there is a proprietary process unique to p  but known to his competitors; 1  p has a new process  unknown to p's competitors; 1  q has a sec ret-process  but that q believes that p doesn't know about it; 1  everyone believes that q can get cheaper alkyd-resin  1  r can get cheaper titanium-dioxide; 1  q doesn't know 
 1 ; 1  everyone knows that r is a predatory pricer while q is not; and 1  each of q and r view p's pricing practices to be like their own. 
　　using this data  our system calculates what p should bid. the example expresses  to a first approximation  some complicated relationships about the beliefs of others. this expression has the virtue of being both computationally effective and uniform. 
　　our use of multiple contexts to embody belief is in contrast to appelt's use of possible world semantics for belief . possible worlds involve reasoning about the possible states of an agent  reducing  through figure 1. the context structure of bid. the top number in each context is context's cost  computed by the meta-context function owncostf   and the bottom number is the context's bid  computed by the meta-context function ownbidf . contexts with normal pricing practices are circles; those with predatory pricing practices are blobs. 
the use of axioms and inference rules  this initially infinite set down to a solution set with the desired properties. our context approach allows us to directly incorporate the knowledge of an agent in the same  axiomatic  format in which it was originally expressed and to constructively refine a single object  the context  as further inferences are made. our approach implements some of the' ideas expressed by konolige and nilsson on multiple agent planning systems . 
	iv 	mastermind 
our second example implements a program that plays mastermind 
. meta-theory plays two key roles in this system. first  metabtatements express facts about the hidden sequence. second  metameta-statements describe the control structure and heuristics that the player uses in deducing more information and in planning its next guess. we built a system with a subordinate context whose language describes guesses and solutions  a series of meta-contexts embodying successive knowledge refinements  and a meta-meta-context that describes control 

r. filman et al. 1 
and heuristics. 
　　the subordinate context's language has two kinds of objects  colors and positions  and a single  fundamental  predicate: positions p in the hidden sequence it color c. this is sufficient to describe the hidden sequence. however  it is difficult to concisely express the information provided by guesses in the subordinate-context's language. instead  we represent guesses as meta-context statements of the form  exactly n of the following statements are true . reasoning in mastermind involves reasoning with these meta-btatements about the fundamental predicate. 
     there are two useful types of meta-statements about the fundamental predicate. imagine that the hidden sequence is  red blue orange green . the guess  red blue orange red  elicits the response that two colors are in the correct position and one is in an incorrect position. 
this information can be expressed as: 


     these are both examples of a more general kind of statement - counting statements. counting statements indicate the number of objects in a set that satisfy some predicate. in the present case  the predicate identifies objects attached to true statements in the subordinate context. 
     the meta-context has four axioms. three allow a conclusion  from appropriate count information  of whether particular objects satisfy the predicate. the fourth relates the count of a set  a  and of its subset  b  to the count of the set difference a - b . these theorems  and a few others that relate counting to mastermind  form the basis for all the necessary inferences. 
     a separate context  meta to the meta-context described above  contains the axioms that describe how to play the game. figure 1 shows the context structure of the mastermind player. the playing strategy is to discover a pattern consistent with what is known so far. the control strategy finds a consistent guess by making a hypothesis and inferring as much as it can. it repeats the  hypothesize and infer  cycle until it has restricted the possibilities to a single pattern. the system represents each hypothesis with a new context  built by extending a copy of the previous hypothesis-context with the new hypothesis. hypotheses may turn out to be false  forcing the system to backtrack. the heuristic used to pick a hypothesis is to find a counting statement on the smallest set of sentences and hypothesize one of those sentences. when the hypotheses have restricted the possibilities to a single consistent pattern  the system guesses that pattern. the system repeats this guessing strategy until it discovers the secret pattern. 
     the inference part of the control cycle uses forward chaining. the inference mechanism is modified with a pruning heuristic and an ordering heuristic. the pruning heuristic discards less specific information implied by more specific information. for example  if i know the fact that two of the three colors red  blue  and green are present  and then discover that red is definitely present  i can conclude that either blue or green is present and then forget the original fact. the ordering heuristic suggests making inferences from more specific information before inferences from less specific information. the two heuristics change forward inferencing from a blind search to a procedure for improving the quality of information. we found these heuristics to be sufficient to focus the system on appropriate inferences. 
     the control meta-meta-context has axioms specifying the above strategies and heuristics. heuristics embedded in programs are difficult to understand and to change. we did not embed our heuristics in a program. using meta-theory allowed us to describe heuristics declaratively but use them procedurally. this separation illustrates a unification of 
the procedural/declarative dichotomy. this idea of declaratively describing heuristics at the meta-level parallels davis' work on teiresias 
     the control meta-meta-theory  running under the sphere simplifies actually plays the game. the system is intended to incorporate the heuristics of one of the authors. in fact  being less prone to mistakes  it plays slightly better than he. 
	v 	views 
     one use of contexts is for abstraction: structuring several views of the same situation. several contexts can share the same partial model  but talk about it in different ways. a major difficulty in implementing multiple views is maintaining consistency between views and the domain  and among views. our approach encapsulates the details necessary to display each view in a context. these contexts have axioms about the appearance of domain objects. we use meta-level axioms about the relation between views and domain objects to maintain consistency declaratively. 
     this quality of expression is particularly useful for representing complex objects with computer graphics. graphics uses geometric objects as symbols for physical objects or concepts. explicitly representing this symbolic relationship permits straightforward definition  
1 r. filman et al. 
easy modification  and effective use. we wish to build display systems with knowledge about the domain  the form in which it appears  and the mapping between this form and its content. contexts facilitate keeping these various functions separate and in an explicit form. this section describes a system with several display forms and an explicit mapping between display forms and their content. 
　　rubik's cube  is both physically and mathematically a complex object. we can independently represent and display it from either of these views  treating it as a problem of turning sides and matching colors or as a problem in group theory. different viewb require different display notations. all are helpful in coming to understand the cube. 
we built a seven-context system for manipulating the 
cube. we encapsulated each of three display views in a separate context. two of these show the physical appearance of the cube. they are 1-d projections of all six cube faces that differ in the orientation of the  hidden  back faces. the third is a table of colored squares representing the position of cube lets in time as the cube is turned: rows representing successive moves  and columns  positions. this  wallpaper-like  display highlights the periodicity of sequences of moves. the cubelets that move in the cycle contrast with those that stay still. figure 1 shows the contexts of the cube system. 
　　each display context has its own ontology. the 1d display contexts have terms for subfaces  colors  and cubelets; functions that relate subfaces to colors; and functions that relate sets of subfaces to cubelets. in the table context  color corresponds to the identity of cubelets  not the visible colors of the cube. shades of colors correspond to twists and flips . for example  the constant red is declared in both the 1-d display contexts and the table context  but has a different meaning in each. context separation keeps the programmer from confusing these different meanings. 
　　a fourth context stores the state of the cube. each of the three display contexts is attached to the cube context both directly  for display purposes  and indirectly  through its own meta-context. they maintain the display relationship between graphic symbol and object. these meta-contexts share a language for manipulating the cube and for displaying the results of manipulation. constants of type operator in the meta-contexts are attached to subordinate-context functions to move the cube. typical primitive operators are right  turn the right face 1＜ clockwise  and front-1  front inverse; turn the front face 1＜ counterclockwise . more complicated operators are built using functions for concatenation  repetition and taking the inverse. operators can be simplified syntactically. for example  fourfold repetition of any primitive operator simplifies to the identity operator. we have similar axioms for other simplifications. thus  much can be simplified symbolically without actually  manipulating  the cube. 
　　operators are constants and by themselves do not change the cube. to actually change a cube  we apply the function move to an operator and the cube. axioms that simplify move-terms both change the cube context and invoke the current display context to show the results. this structure maintains consistency between domain objects and the corresponding display objects. 
　　with this system we can apply complex manipulations to the cube in a language that can be syntactically simplified. we can view the results of this manipulation in one format and then switch contexts to view the cube in another. this ability to associate linguistic manipulation of operators with different graphic displays facilitates mastery of the cube. 
figure 1. the context structure of the cube system. 
vi conclusion 
　　in this paper we summarized three examples illustrating the power and flexibility of representation using meta-theory. each of these issues 
 modality  heuristics  and views  is difficult to express in conventional ai terms. with the appropriate quality of meta-theoretic machinery  we have uniformly expressed and manipulated them all with a single representation system. three ingredients contributed to the success of these representations: encapsulation  the clean separation of language and met a-language  and the ability to recurse on meta-languages. we believe that these ingredients form part of a crucial foundation for building intelligent systems. 
acknowledgments 
we thank jonathan king  egon loebner  anne paulson  bert raphael and richard weyhrauch for their helpful comments on this paper. we also thank steve gadol  bob kanefsky  anne paulson and richard weyhrauch for their participation in building the sphere system. 

tarnlund  eds.   logic programming  academic press  new york  1  pp. 1. 
 conn  a.   high level proof in lcf   proceedings 1th workshop on automated deduction  austin  1   pp. 1. 
 davis  r.   applications of meta level knowledge to the construction  maintenance and use of large knowledge bases   memo-1  artificial intelligence laboratory  stanford university  stanford  1 . 
 gawron  j. m.  j. king  j. lamping  e. loebner  e. a. paulson  g. k. pullum  i. a. sag and t. wasow   the gpsg linguistics system   proceedings 1th annua/ meeting of the acl  toronto  1   pp 1. 
 genesereth  m.   metaphors and models   proceedings aaai-1  
stanford  1   pp. 1. 
 genesereth  m.  r. greiner  and d. smith   mrs manual   memo hpp-1  heuristic programming project  stanford university  stanford  1 . 
 goldstein  i. p.  and r. b. roberts   using frames and scheduling   in p. h. winston  and r. h. brown  eds.   artificial intelligence: an mit perspective  vol. 1  mit press  cambridge ma  1   pp. 1. 
 hewitt  c   g. attardi  and m. simi   knowledge embedding in the description language omega   proceedings aaai-1.  stanford  1   pp. 1. 
 hofstadter  d. r.   metamagical themas   scientific american 1  1  1   pp. 1. 
 knuth  d.   the computer as mastermind   journal of recreational mathematics 1  1  1   pp. 1. 
 konolige  k.   a metalanguage representation of relational databases for deductive question-answering system   proceedings ijcai-1  vancouver  1   pp. 1. 
 konolige  k.  and n. j. nilsson   multiple-agent planning systems   proceedings aaai-1  stanford  1   pp. 1. 
 kornfeld  w. a.  and c. e. hewitt   the scientific community metaphor   ieee transactions on systems  man  and cybernetics 1  1  1   1. 
 mcdermott  d. v.  and g. j. sussman   the conniver reference manual   memo 1  artificial intelligence laboratory  mit  cambridge  ma  1 . 
 rulifson  j. f.  j. a. derksen  and r. j. waldinger   qa1: a procedural calculus for intuitive reasoning   ai-technical note 1  sri  menlo park  ca  1 . 
 smith  b. c   reflection and semantics in a procedural language.  tr-1  laboratory for computer science  mit  cambridge  ma  1 . 
 weyhrauch  r. w.   prolegomena to a theory of mechanised formal reasoning   artificiai intelligence 1  1  1   pp. 1. 
