
preferences can be aggregated using voting rules. we consider here the family of rules which perform a sequence of pairwise majority comparisons between two candidates. the winner thus depends on the chosen sequence of comparisons  which can be represented by a binary tree. we address the difficulty of computing candidates that win for some trees  and then introduce and study the notion of fair winner  i.e. candidates who win in a balanced tree. we then consider the situation where we lack complete informations about preferences  and determine the computational complexity of computing winners in this case.
1 introduction
when the voters' preferences and the voting rule are fully specified  the computation of the winner is easy for many voting rules. often  however  the voters' preferences or the voting rule itself may be incompletely specified. for instance  only some voters might have expressed their preferences. even if all voters have expressed their preferences  a new candidates might be introduced. as a third example  we might be eliciting preferences using a compact language such as cp-nets  boutilier et al.  1  which induces only a partial or incomplete ordering.  konczak and lang  1  have therefore considered voting with incompletely specified preferences. they compute the candidates winning in some  resp. all  of the complete extensions of the partial preference profiles for a given voting rule. a second kind of incompleteness is in the voting rule itself. for example  the order in which candidates are compared may not yet be fixed. this can make manipulation by a coalition of voters more difficult  conitzer and sandholm  1 .
﹛in this paper  we consider a well-known family of voting rules based on sequential majority comparisons  where the winner is computed from a series of majority comparisons along a binary tree. we study the impact of these two kinds of incompleteness on such voting rules.
﹛the paper is structured as follows. in section 1 we recall some basics on sequential majority voting. in section 1 we deal with incompleteness in the voting rule. we study the complexity of computing candidates that win in some or all possible binary trees. then  in section 1 we focus on binary trees where the number of competitions for each candidate is as balanced as possible and give characterizations of winners in such trees. in particular  it is possible to build in polynomial time a tree featuring a boundedlevel of imbalance where a particular candidate a wins  if such a tree exists. finally  in section 1 we study the scenario where the agents have only partially revealed their preferences  giving characterizations for notions of possible and condorcet winners and proving that such winners can be found in polynomial time.
1 background
preferences and profiles. we assume that each agent's preferences are specified by a  possibly incomplete  total order  to   that is  by an asymmetric  irreflexive and transitive order  over a set of candidates  denoted by 次 . given two candidates  a b ﹋ 次  an agent will specify exactly one of the following: a   b  a   b  or a b where a b means that the relation between a and b has not yet been revealed. a profile is a sequence of total orders describing the preferences for a sequence of n agents. an incomplete profile is a sequence in which one or more of the preference relations is incomplete. for the sake of simplicity we assume that the number n of voters is odd. a condorcet winner  if it exists  is a candidate a such that for any candidate  a strict majority of voters prefers a to b.
the majority graph. given a  complete profile p  the majority graph m p  is the graph whose set of vertices is the set of the candidates 次 and in which for all a b ﹋ 次  there is a directed edge from a to b in m p   denoted by a  m b  iff a strict majority of voters prefer a to b. the majority graph is asymmetric and irreflexive  but it is not necessarily transitive. moreover  since the number of voters is odd  m p  is complete: for each  either a  m b or b  m a holds. therefore  m p  is a complete  irreflexive and asymmetric graph  also called a tournament on 次  laslier  1 .
﹛the weighted majority graph associated with a complete profile p is the graph mw p  whose set of vertices is 次 and in which for all a b ﹋ 次  there is a directed edge from a to b weighted by the number of voters who prefer a to b in p. weights can quantify the amount of disagreement  e.g. the number of voters preferring a to b . when we want to use standard majority graphs  we just consider all weights to be equal  and we call them simply majority graphs.
example 1. the majority graph induced by the 1-voter profile   a   b   c   b   c   a   b   a   c   has the three edges b  m a  b  m c  and a  m c.
binary voting trees. given a set of candidates 次  a binary  voting  tree t is a binary tree where each internal node  including the root  has two children  each node is labelled by a candidate  element of 次   and the leaves contain every candidate in 次  one per leaf . given an internal node n and its two children n1 and n1  the candidate associated to n is the winner of the competition between the candidates associated to n1 and n1  moulin  1 .
﹛a binary tree t is balanced iff the difference between the maximum and the minimum depth among the leaves is less than or equal to 1. in general  such a difference denotes the level of imbalance of the tree.
sequential majority voting rules induced by binary trees. given a binary voting tree t  the voting rule induced by t maps each tournament g to the candidate returned from the following procedure  called a knock-out competition :
1. pick a nonterminal node x in t whose successors p  q are terminal nodes; let p and q be the candidates associated to p and q respectively.
1. delete the branches x ↙ p and x ↙ q from t  thus making x a terminal node with candidate p  resp. q  if p  m q  resp. q  m p  is in g.
1. repeat this operation until t consists of a single node. then the candidate associated to this node is returned.
example 1. given the majority graph in figure 1  a   figure 1  b  shows the voting tree corresponding to the sequence of competitions   a c   b a  .

figure 1: majority graph and the resulting voting tree.
possible winners and condorcet winners. a candidate a is a condorcet winner if and only if  for any other candidate b  we have a  m b. thus  a condorcet winner corresponds to a vertex of the majority graph with outgoing edges only. there are profiles for which no condorcet winner exists. however  when a condorcet winner exists  it is unique. if there is a condorcet winner  then it is the sequential majority winner for each binary tree. if there exists at least one binary tree for which a candidate a is the winner  then a is called a possible winner.
﹛many other ways of computing winners from a majority graph exist  see  laslier  1  for a review . for example  the set of possible winners contains the uncovered set  miller  1   which itself contains the banks set  banks  1 . it also contains the set of copeland winners  defined as the candidates who maximize the number of outgoing edges in the majority graph. when a condorcet winner a exists  all these sets coincide with the singleton {a}.
1 computing possible winners
the set of possible winners coincides with the top cycle of the majority graph  moulin  1 . the top cycle of a majority graph g is the set of maximal elements of the reflexive and transitive closure g  of g. an equivalent characterization of possible winners is in terms of paths in the majority graph.
theorem 1  see e.g.  moulin  1; laslier  1   given a complete majority graph g  a candidate a is a possible winner iff for every other candidate c  there exists a path bi ↙ bi+1 for i = 1 ... k   1 from a to c in g.
﹛since path finding is polynomial  we get the following corollary:
theorem 1 given a complete majority graph and a candidate a  checking whether a is a possible winner and  if so  finding a tree where a wins  is polynomial .
example 1. assume that  given a majority graph g over candidates a  b1  b1  and c  candidate a is a possible winner and that only c beats a. then  for theorem 1  there must be a path in g from a to every other candidate. assume
a ↙ b1 ↙ b1 ↙ c is a path from a to c in g. figure 1 shows the voting tree corresponding to such a path. 

figure 1: a path and the corresponding voting tree.
1 fair possible winners
possible winnersare candidateswho win in at least onevoting tree. however  such a tree may be very unbalanced and the winner could compete with few other candidates. this might be considered unfair. in the following  we will consider a competition fair if it has a balanced voting tree  and we will call such winners fair possible winners. for simplicity  we will assume there are 1k candidates but results can easily be lifted to situations where the number of candidates is not a power of 1. notice that a condorcet winner is a fair possible winner  since it wins in all trees  thus also in balanced ones.
﹛we will show that a candidate is a fair possible winner when the nodes of the majority graph can be covered by a binomial tree  cormen et al.  1   which means that the nodes of the majority graph are the terminal nodes of a balanced competition tree. binomial trees are defined inductively as follows:
  a binomial tree of order 1  written t1  is a tree with only one node.
  a binomial tree of order k  with k   1  written tk  is the tree where the root has k children  and for i = 1 ... k the i-th child is a binomial tree of order k   i.
﹛it is easy to see that  in a binomial tree of order k  there are 1k nodes and the tree has height k.
﹛given a majority graph with 1k nodes  and given a candidate a  it may be possible to find a covering of the nodes which is a a binomial tree of order k with root a. in this situation  we have a balanced voting tree where a wins. thus a is a fair possible winner.
example 1. consider the majority graph g over candidates a  b  c and d depicted in figure 1. since such a majority graph is covered by the binomial tree t1 with root a  we can conclude that a is a fair possible winner. 

figure 1: from a majority graph to a balanced voting tree via a binomial tree.
theorem 1 given a complete majority graph g with 1k nodes  and a candidate a  there is a binomial tree tk covering all nodes of g with root a  if and only if a is a fair possible winner.
proof: assume there is a binomial tree tk satisfying the statement of the theorem. then each node of tk is associated to a candidate. for node n  we will write cand n  to denote such a candidate.
﹛we will show that it is possible to define  starting from tk  a balanced voting tree b tk  where a wins. each node of b tk  is associated to a candidate as well  with the same notation as above. the definition of b tk  is given by induction:   if k = 1  b t1  = t1;
  if k   1  b tk  is the balanced tree built from two instances of b tk 1   corresponding to the two instances of tk 1 which are part of tk by definition; the roots of such trees are the children of the root of b tk ; the candidate of the root of b tk  is the candidate of the root of tk.
it is easy to see that b tk  is a perfectly balanced binary tree  where the winner is a if a is the candidate associated to the root of the binomial tree. proof of the opposite direction is similar. 
﹛notice that a condorcet winner is a fair winner  and that a fair winner is a possible winner. moreover  there is always at least one fair winner  thus a voting rule accepting only fair possible winners is well-defined.
﹛unfortunately the complexity of deciding if a is a fair possible winner is an open problem. however  for weighted majority graphs  it is np-hard to check whether a candidate a is a fair possible winner. this means that  if we restrict the voting trees only to balanced ones  it is difficult for the chair  if he can choose the voting tree  to manipulate the election. the problem of manipulation by the chair  also called  control   has been first considered in  bartholdi et al.  1 .
theorem 1 given a complete oriented and weighted majority graph g and a candidate a  it is np-complete to check whether a is a fair possible winner for g.
proof:  sketch  we prove that the exact cover problem reduces polynomially to the problem of finding a minimum binomial tree with root a covering g. the proof is similar to the one in  papadimitriou and yannakakis  1  that reduces exact cover to the problem of finding a minimum spanning tree for a graph from a class of trees which are sets of disjoint flowers of type 1 and where  for each tree t in the class  the number of flowers of type 1 is.
﹛a flower is a tree where all nodes but the root have degree at most 1 and are at distance 1 or 1 from the root. a flower is of type 1 if at least a node has distance 1 from the root.
﹛binomial trees are trees which consist of disjoint flowers of type 1. in fact  the binomial tree t1 is a flower of type 1  and all bigger binomial trees tk  with 1k nodes  consist of 1k 1 instances of such flowers of type 1  all disjoint1. thus we have.
﹛given an instance of the exact cover problem  consisting of 1k sets of size 1 and 1k elements  each of which appears three times in the sets  the proof proceeds by constructing a graph such that the instance has an exact cover iff the graph has a minimum covering binomial tree. 
﹛on the other hand  given a possible winner a  it is easy to find a tree  with a bounded level of imbalance in which a wins. we define d t a  as the length of the path in the tree t from the root to the only leaf labelled a. we define 忖 a  as the maximum d t a  over all competition trees t where a wins. if 忖 a  = m   1  then a is a condorcet winner  and vice-versa. in fact  this means that there is a tree where a competes against everybody else  and wins. this can be seen as an alternative characterization of condorcet winners.
﹛it is important to be able to compute 忖 a . this is an easy task. in fact  once we know that a candidate a is a possible winner  忖 a  coicides with the number of outgoing edges from a in the majority graph.
theorem 1 given a majority graph g and a possible winner a  忖 a  is the number of outgoing edges from a in g.
proof: if a has k outgoing edges  no voting tree where a wins can have a appearing at depth larger than k. in fact  to win  a must win in all competitions scheduled by the tree  so such competitions must be at most k. thus 忖 a  ≒ k.
﹛moreover  it is possible to build a voting tree where a wins and appears at depth k. let us first consider the linear tree  t1 in which a competes against all and only the d1 ... dk candidates which it defeats directly in g. clearly in such tree  t1  d t1 a  = k. however t1 may not contain all candidates. in particular it will not contain candidates defeating a in g. we now consider  one by one  each candidate c such that c ↙ a in g. for each such candidate we add a subtree to the current tree. the current tree at the beginning is t1. let us consider the first c and the path  which we know exists  which connects a to c  say a ↙ b1 ↙ b1 ... ↙ bh ↙ c. let j ﹋ {1 ... h} be such that bj belongs to the current tree and  i   j  bi does not belong to the current tree. notice that such candidate bj always exists  since any path from a must start with an edge to one of the d1 ... dk candidates. we then attach to the current tree the subtree corresponding to the path bj ↙ ... ↙ c at node bj obtaining a new tree in which only new candidates have been added. after having considered all candidates defeating c in a  the tree obtained is a voting tree in which a wins and has depth exactly k. thus 忖 a  = k. 
﹛we now show that  if a is a possible winner  there exists a voting tree where a wins with level of imbalance at most m 忖 a  1. notice that there could also be more balanced trees in which a wins.
theorem 1 given a complete majority graph g and a possible winner a  there is a voting tree with level of imbalance smaller than or equal to m   忖 a    1  where a wins. this tree can be built in polynomial time.
proof: since a beats 忖 a  candidates  we can easily build a balanced voting tree bt involving only a and the candidates beaten by a. then we have to add the remaining m   忖 a    1 candidates to bt. since a is a possible winner  there must be a path from one of the candidates beaten by a to each of the remaining candidates. in the worst case  this adds a subtree of depth m   忖 a    1 rooted at one of the nodes beaten by a in bt. 
﹛if unfair tournaments are undesirable  we can consider those possible winners for which there are voting trees which are as balanced as possible. theorem 1 helps us in this respect: if a is a possible winner  knowing 忖 a  we can compute an upper bound to the minimum imbalance of a tree where a wins. in general  if 忖 a  ≡ k  then there is a tree with imbalance level smaller or equal than m   k   1  hence the higher 忖 a  is  the lower is the upper bound to the level of imbalance of a tree where a wins.
﹛if a candidate has the maximum number of outgoing edges in the majority graph  i.e.  it is a copeland winner   we can give a smaller upper bound on the amount of imbalance in the fairest/most balanced tree in which it wins. notice that that every copeland winner is a possible winner.
theorem 1 if a candidate a is a copeland winner  then the imbalance of a fairest/most balanced tree in which a wins is smaller or equal than log m   忖 a    1 .
proof: if a is copeland winner then every candidate beating a must be beaten by at least one candidate beaten by a. consider the balanced tree bt defined in the proof of theorem 1 rooted at a and involving all and only the candidates beaten by a. in the worst case all the remaining m   忖 a    1 candidates are beaten only by the same candidate in. in such case  however  we can add to bt a balanced subtree with depth log m   忖 a    1  rooted at b  involving all the remaining candidates. 
1 incomplete majority graphs
up till now  agents have defined all their preferences over candidates  thus the majority graph is complete; uncertainty comes only from the tree  i.e.  from the voting rule itself. another source of uncertainty is that the agents' preferencesmay only be partially known.
﹛let p be an incomplete profile  i.e.  a collection of n incomplete preference relations over 次. the incomplete majority graph m p  induced by p is defined as the graph whose set of vertices is 次 and containing an edge from a to b if the number of voters who prefer a to b is greater than n/1. m p  is thus an incomplete asymmetric graph  or partial tournament  over 次. for instance  the graph induced by the 1-voter incomplete profile  a   b   c   a   c   a  
b c  is the graph with the two edges a  m b and a  m c.
﹛note  importantly  that the set of all  complete  majority graphs extending m p  is a superset of the set of majority graphs induced by all possible completions of p; this inclusion can be strict  which means that summarizing p into m p  implies a loss of information.
﹛we would like to reason about possible winners and condorcet winners in such a scenario. following  konczak and lang  1   we say that x ﹋ 次 is a  -possible winner  resp.  -possible winner  for p iff it is a possible winner in all completions  resp. in some completion  of p  and that x ﹋ 次 is a  -condorcet winner  resp.  -condorcet winner  for p iff it is a condorcet winner in all completions  resp. in some completion  of p. we know from  konczak and lang  1  that  -condorcet winner and  -condorcet winners can be computed from p in polynomial time. however  computing  possible winners and  -possible winners looks far less easy  we conjecture that it is np-hard . now  by reasoning from the incomplete majority graph rather than from the completions of p  we can define the following four approximations of  - and  -possible  and condorcet  winners  which  as we will show shortly  are all computable in polynomial time.
definition 1 let g be an incomplete majority graph and a a candidate.
  a is a weak possible winner for g iff there exists a completion of g and a tree for which a wins.
  a is a strong possible winner for g iff for every completion of g there is a tree for which a wins.
  a is a weak condorcet winner for g iff there is a completion of g for which a is a condorcet winner.
  a is a strong condorcet winner for g iff for every completion of g  a is a condorcet winner.
when the majority graph is complete  strong and weak condorcet winners  resp. strong and weak possible winners  coincide  and coincide also with condorcet winners  resp. possible winners as defined in section 1 .
﹛we denote by wp g   sp g   wc g  and sc g  the sets of  respectively  weak possible winners  strong possible winners  weak condorcet winners and strong condorcet winners for g. we have the following inclusions:
sc g    wc g  ﹎ sp g 
wc g  ﹍ sp g    wp g 
﹛furthermore  because the set of all complete majority graphs extending m p  contains the set of majority graphs induced by the completions of p  any strong possible winner for m p  is a  -possible winner and any  -possible winner for p is a weak possible winner for m p .  and similarly for weak/strong condorcet winners. 
﹛we now give graph-theoretic characterizations for each of the four notions above.
theorem 1 given an incomplete majority graph g and a candidate a  a is a strong possible winner if and only if for every other candidate b  there is a path from a to b in g.
proof:     suppose that for each  there is a path from a to b in g. then these paths remain in every completion of g. therefore  using theorem 1  a is a possible winner in every completion of g  i.e.  it is a strong possible winner.     suppose there is no path from a to b in g. let us define the following three subsets of the set of candidates 次: r a  is the set of candidates reachable from a in g  including a ; r 1 b  is the the set of candidates from which b is reachable in g  including b ; and others = 次    r a  ﹍ r 1 b  . because there is no path from a to b in g  we have that r a  ﹎ r 1 b  =   and therefore {r a  r 1 b  others} is a partition of 次. now  let us build the complete tournament g  as follows:
1. g  := g;
1.   x ﹋ r a   y ﹋ r 1 b   add  y x  to g ;
1.   x ﹋ r a   y ﹋ others  add  y x  to g ;
1.   x ﹋ others  y ﹋ r 1 b   add  y x  to g ;
1.   x y belonging to the same element of the partition: if neither  x y  nor  y x  is in g then add one of them
 arbitrarily  in g .
let us first show that g  is a complete tournament. if x ﹋ r a  and y ﹋ r 1 b   then   otherwise there would be a path from a to b in g . if x ﹋ r a 
  otherwise y would be in
r a . if x ﹋ others and y ﹋ r 1 b   then   otherwise x would be in r 1 b . therefore  whenever x and y belong to two distinct elements of the partition  g  contains  y x  and not  x y . now  if x and y belong to the same element of the partition  by step 1  g  contains exactly one edge among { x y   y x }. therefore  g  is a complete tournament. let us show now that there is no path from a to b in g . suppose there is one  that is  there exist z1 = a z1 ... zm 1 zm = b such that { z1 z1   z1 z1  ...  zm 1 zm }   g . now  for all x ﹋ r a  and all y such that  x y  ﹋ g   by construction of g  we necessarily have y ﹋ r a . therefore  for all i   m  if zi ﹋ r a  then zi+1 ﹋ r a . now  since z1 = a ﹋ r a   by induction we have zi ﹋ r a  for all i  thus b ﹋ r a   which is impossible. therefore  there is no path from a to b in g . thus  g  is a complete tournament with no path from a to b  which implies that a is not a possible winner w.r.t. g .
lastly  by construction  g  contains g. so g  is a complete extension of g for which a is not a possible winner. this shows that a is not a strong possible winner for g. 
﹛clearly  a procedure based on the previous theorem gives us a polynomial algorithm to find strong possible winners. let g be an asymmetric graph  次 the set of candidates  and a ﹋ 次. let us consider the following algorithm:
begin
曳 := {a}﹍ {x| there is a path from a to x in g};
;
repeat
for all  y z  ﹋ 曳 ℅  次   曳  do
   if then	to	; for all z ﹋ 次   曳 do
if there is a path from then add z to 曳
until 曳 = 次 or there is no  y z  ﹋ 曳 ℅  次   曳  s. t. ;
return 曳.
﹛let us call f g a  the set 曳 returned by the algorithm on g and a. then we have the following result:
theorem 1 f g a  = 次 if and only if a is a weak possible winner for g.
proof: we first make the following observation: the graph g obtained at the end of the algorithm is asymmetric and extends g. it is asymmetric because it is so at the start of the algorithm  since g is  and then  when an edge y ↙ z is added to g when z ↙ y is not already in g.
﹛now  assume f g a  = 次. let g be a tournament extending g  and  a fortiori  g . such a g exists  because g is asymmetric . by construction of g  there is a path in g from a to every node of f g a    {a}  hence to every node of 次   {a}; since   this holds a fortiori for g  hence a is a possible winner in g and therefore a weak possible winner for g. conversely  assume
.	denote 成 = 次   曳.	then  for all
  y z  ﹋ 曳 ℅ 成 we have. now  z ﹋ 成 means that no edge z ↙ y  for z ﹋ 成 and y ﹋ 曳  was added to g; hence  for every y ﹋ 曳 and z ﹋ 成  we have that  if and only if z ↙ y ﹋ g. this implies that for all  y z  ﹋ 曳 ℅ 成 we have z ↙ y ﹋ g  therefore  in every tournament g extending g  every candidate of 成 beats every candidate of 曳  and in particular a. therefore  there cannot be a path in g from a to a candidate in z  which implies that a is not a possible winner in g. since the latter holds for every tournament g extending g  a is not a weak possible winner for g. 
﹛since the above algorithm for copmuting f g a  runs in time o |次|1   we get as a corollary that weak possible winners can be computed in polynomial time.
﹛given an asymmetric graph g  成 is said to be a dominant subset of g if and only if for every z ﹋ 成 and every x ﹋ 次   成 we have  z x  ﹋ g. then we have an alternative characterization of weak possible winners:
theorem 1 a is a weak possible winner with respect to g if and only if a belongs to all dominant subsets of g.
proof: suppose there exists a dominant subset 成 of g such that . then there can be no extension of g in which there is a path from a to a candidate z ﹋ 成. hence a is not a weak possible winner for g. conversely  suppose that a is not a weak possible winner for g. then the algorithm for computing f g a  stops with and 次   f g a  being a dominant subset of g. since a ﹋ f g a   次   f g a  is a dominant subset of g to which a does not belong. 
﹛as a consequence of theorems 1 and 1  weak and strong possible winners are computable in polynomial time  which means that they can be seen as polynomial approximations of  -possible and  -possible winners  respectively  the computation of those looks much harder . we do not need such a polynomial characterization for  -condorcet and  condorcet winners  since these are computable in polynomial time; however  for the sake of completeness we give below simple  and obvious  graph-theoretic characterizations of weak and strong condorcet winners.
theorem 1 given an incomplete majority graph g and a candidatea  a is the strong condorcet winner iff a has m 1 outgoing edges in g.
theorem 1 given an incomplete majority graph g and a candidate a  a is a weak condorcet winner iff a has no ingoing edges in g.
﹛given an incompletemajority graph  the set of weak/strong condorcet winners can therefore be computed in polynomial time from the majority graph.
﹛we end this section by giving bounds on the number of weak/strong possible/condorcet winners.
theorem 1 let |次| = m. the following inequalities hold  and for each of them the bounds are reached: 1 ≒
;
1	   	.
1 conclusions
we have addressed various computational issues for sequential majority voting. we summarize here our results and their potential impact.
﹛we first dealt with uncertainty about the choice of the binary tree. because the choice of the tree is under the control of the chair  our results can be interpreted in terms of difficulty of manipulation by the chair  as in  e.g.   bartholdi et al.  1  . we proved that sequential majority voting is easy to manipulate. we gavecharacterizationsof fair possible winners  i.e. possible winners who win in a balanced voting tree. we also dealt with uncertainty about voters' preferences. we showed that in this case  it is easy to compute a lower and an upper bound of the set of candidates winning for some binary tree. these results apply to manipulationby coalitions of voters and elicitation by the chair as these are two situations where we have to reason with incomplete preferences. see  konczak and lang  1  for a discussion on the relationship between computing weak/strong winners and computing constructive and destructive manipulations by coalitions of voters  conitzer and sandholm  1a  and vote elicitation  conitzer and sandholm  1b .
﹛many issues remain open  such as the complexity of computing fair possible winners  and the complexity of deciding whether a candidate is a possible winner for some/all completions of an incomplete preference profile.
acknowledgements
we thank the referees for their many helpful suggestions and corrections. especially  we are very indebted to one of them  who pointed out to us an important problem in the initial version of the paper and gave us useful suggestions for coping with it. national ict australia is funded by the australian government's backing australia's ability initiative  in part through the australian research council. references
 banks  1  j. s. banks. sophisticated voting outcomes and agenda control. social choice and welfare  1 :1- 1  1.
 bartholdi et al.  1  j. bartholdi iii  c. tovey  and m. trick. how hard is it to control an election  mathematical and computer modeling  1/1 : 1  1.
 boutilier et al.  1  c. boutilier  r. i. brafman  c. domshlak  h. hoos  and d. poole. preference-based constrained optimization with cp-nets. computational intelligence  1 :1  1.
 conitzer and sandholm  1a  v. conitzer and t. sandholm. complexity of manipulating elections with few candidates. in proc. of aaai-1  pages 1  1.
 conitzer and sandholm  1b  v. conitzer and t. sandholm. vote elicitation: complexity and strategy-proofness. in proc. of aaai-1  pages 1  1.
 conitzer and sandholm  1  v. conitzer and t. sandholm. universal voting protocols tweaks to make manipulation hard. in proc. of ijcai-1  pages 1  1.
 cormen et al.  1  t. h. cormen  c. e. leiserson  and r. l. rivest. introduction to algorithms. mit press  1.
 konczak and lang  1  k. konczak and j. lang. voting procedures with incomplete preferences. in proc. ijcai1 multidisciplinary workshop on advances in preference handling  1.
 laslier  1  j.-f. laslier. tournament solutions and majority voting. springer  1.
 miller  1  n. miller. a new solution set for tournaments and majority voting: further graph-theoretical approaches to the theory of voting. american journal of political science  1-1  1.
 moulin  1  h. moulin. axioms of cooperative decision making. cambridge university press  1.
 papadimitriou and yannakakis  1  c. papadimitriou and m. yannakakis. the complexity of restricted spanning tree problems. journal of the acm  1 :1  1.
     1 this work has been supported by italian miur prin project  constraints and p