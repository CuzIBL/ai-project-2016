ion of the concrete behavior is necessary in order to get a declarative model of the system's behavior. the idea behind the abstract behavior model of software components is similar to models which are based on dependencies like the one described by  friedrich et al.  1 . if all inputs to the model are correct  a software component should produce a correct output. this conversion has to be performed for all components and their output connections.
모for example  the rule that represents the abstract behavior of the ot  object tracker  component is:
 ab ot 뫇ok firewire  뫸 ok objectmeasurement  where the predicate ab stands for abnormal  and ok indicates a correct event or method call.
in order to locate root causes  i.e.  the components which cause a detected misbehavior  we have to introduce a notation of observations. the easiest way of doing this is to use the same ok predicate for the purpose. if we detect a misbehavior at om  objectmeasurement   we could represent this by the literal  ok om . we introduce a distinguished predicate correct for observations to distinguish observations and computed values . correct x  for a connection x is true whenever the observed connection shows the correct behavior. othcorrect x  is false. the
	 	  뫸  	   	 	  뫸
 ok om   correct om  뫸 ab ot  1 monitoring  diagnosis and repair
coupling the running program with its software architecture model requires an abstraction step. the running program changes its state via changing variable values which is caused by inputs from the environment. but sam only represents the software components and their communication means. therefore  we require to map changes to communication patterns. for this purpose we introduce observers. an observer monitors a certain part of the program's behavior during the execution. if an observer detects a behavior that contradicts its specification  it computes the appropriate observations in terms of setting the observation predicates  correct x  for the connection x  and invokes the diagnosis engine. in the current implementation we used the following observers: periodic event production checks whether an event e is produced at least every n ms  conditional event production checks whether an event e1 is produced n ms after the occurrence of an event e1  spawn processes checks whether a component spawns a number n of processes and periodic method calls checks whether a component calls a method m at least every n ms.
모the observers are used to monitor the state of the system. for this purpose the observers check their rules on a regular basis. in cases of failure the diagnosis procedure is invoked.
모the diagnosis task is based on the model-based diagnosis  mbd  paradigm  reiter  1 . in particular we use reiter's hitting set algorithm  reiter  1 . in order to minimize diagnosis time we only search for minimal cardinality diagnoses which can be easily obtained when using reiter's algorithm. we only construct the hitting set graph until a level where the first diagnosis is computed. in most practical cases single fault diagnoses can be found.
모after diagnosis those components that are responsible for a detected failure have to be killed and restarted. we have to take care of the fact that restarting one component might require restarting another component. this can be done by using the information about strong dependencies between components. the components that have a strong dependency relationship with each other have to be restarted. hence  the steps for repair would be:  1  compute the diagnoses.  1  compute a set of components that have to be restarted. in this step we compute all components that strongly depend on components of a diagnosis.  1  maximize the chance of repair by using a larger set of components to be restarted.
모the proposed diagnosis system has been tested on our mobile robot system. for the evaluation of the diagnosis we introduced artificial faults into the robot control system and analyzed if the diagnosis system detected and located the fault and recovered the control system.

figure 1: diagnosis and repair of a fault in the motion service.
모figure 1 shows the results for an introduced deadlock in the motion service  mo . after introducing the deadlock in mo the event observer for the event motiondelta perceives that no more events are produced. the diagnosis kernel derived that mo is malfunctioning. instantly the repair process starts. the repair action comprises a stop of the behavior engine  be   a stop of mo  and a restart of mo and be. the restart of be is necessary because be is strongly coupled with mo. after repair the diagnosis kernel derives the diagnosis that all components work properly now. the relatively long time for the recovery could be explained by the fact that a repair of services could take a while because of the required starting  stopping and re-configuration of hardware components.
1	related research and conclusion
williams and colleagues  williams et al.  1  used modelbased reasoning to detect and recover failures of the hardware of a space probe. verma and colleagues  verma et al.  1  used particle filter to estimate the state of the robot and its environment. these estimations together with a model of the robot were used to detect faults. previous research has dealt either with hardware diagnosis or diagnosis of software as part of the software engineering cycle. however  diagnosis of software and repair at runtime has never been an issue. the paper described a model-based diagnosis for detecting  locating and repairing faulty software at runtime. for this purpose a modeling technique for representing software architectures which include components  control and data flow  and dependencies has been introduced. moreover  the concept of observers  have been described in the paper. finally  the paper presented a repair algorithm and first empirical results of our implementation. these results show that software failures  e.g.  deadlocks  can be detected and corrected at runtime.
