 
we perform a comprehensive theoretical and experimental analysis of the use of all-different constraints. we prove that generalized arc-consistency on such constraints lies between neighborhood inverse consistency and  under a simple restriction  
path inverse consistency on the binary representation of the problem. by generalizing the arguments of kondrak and van beek  we prove that a search algorithm that maintains generalized arc-consistency on all-different constraints dominates a search algorithm that maintains arc-consistency on the binary representation. our experiments show the practical value of achieving these high levels of consistency. for example  we can solve almost all benchmark quasigroup completion problems up to order 1 with just a few branches of search. these results demonstrate the benefits of using non-binary constraints like all-different to identify structure in problems. 
1 	introduction 
many real-world problems involve all-different constraints. for example  every fixture for a sports team must be on a different date. many of the constraint satisfaction toolkits therefore provide specialized algorithms for efficiently representing and  in some case  reasoning about all-different constraints. alternatively  we can expand all-different constraints into a quadratic number of binary not-equals constraints. however  it is less efficient to do this  and the translation loses some semantic information. the aim of this paper is to show the benefits of keeping with a non-binary representation. we prove that we can achieve much higher levels of consistency in the non-binary representation compared to the binary. we show experimentally that these high levels of consistency can reduce search dramatically. 
   *the authors are members of the apes research group  http://www.cs.strath.ac.uk/ apes. we thank our colleagues in the group at the universities of strathclyde and leeds  most especially paul shaw. the second author is supported by epsrc award gr/k/1. 
1 	constraint satisfaction 

　many lesser levels of consistency have been defined for binary constraint satisfaction problems  see  debruyne and bessiere  1  for references . a problem is  /'  j -consistent iff it has non-empty domains and any consistent instantiation of i variables can be extended to a consistent instantiation involving j additional variables. a problem is arcconsistent  ac  iff it is  1  inconsistent. a problem is pathconsistent  pc  iff it is  1  j  -consistent. a problem is strong path-consistent iff it is  j  inconsistent for j   1. a problem is path inverse consistent  pic  iff it is  1  1 -consistent. a problem is neighborhood inverse consistent  nic  iff any value for a variable can be extended to a consistent instantiation for its immediate neighborhood. a problem is restricted path-consistent  rpc  iff it is arc-consistent and if a variable assigned to a value is consistent with just a single value for an adjoining variable then for any other variable there exists a value compatible with these instantiations. a problem is singleton arc-consistent  sac  iff it has non-empty domains and for any instantiation of a variable  the problem can be made arc-con si stent. 
　many of these definitions can be extended to non-binary constraints. for example  a  non-binary  csp is generalized arc-consistent  gac  iff for any variable in a constraint and value that it is assigned  there exist compatible values for all the other variables in the constraint  mohr and masini  1 . regin gives an efficient algorithm for enforcing generalized arc-consistency on a set of all-different constraints  regin  1 . we can also maintain a level of consistency at every node in a search tree. for example  the mac algorithm for binary csps maintains arc-consistency at each node in the search tree  gaschnig  1 . as a second example  on a nonbinary problem  we can maintain generalized arc-consistency  mgac  at every node in the search tree. 
following  debruyne and bessiere  1   we call a con-

sistency property a stronger than b {a   b  iff in any problem in which a holds then b holds  and strictly stronger {a   b  iff it is stronger and there is at least one problem in which b holds but a does not. we call a local consistency property a incomparable with b {a ~ b  iff a is not stronger than b nor vice versa. finally  we call a local consistency property a equivalent to b iff a implies b and vice versa. the following identities summarize results from  debruyne and bessiere  1  and elsewhere: strong pc   sac   pic   rpc   ac  nic   pic  nic ~ sac  and nic strong pc. 
1 	generalized arc-consistency 
all-different constraints are network decomposable idechter  
1   abbreviated to decomposable in this paper  as they can be represented by binary constraints on the same set of variables. in this section  we give some theoretical results which identify the level of consistency achieved by gac on decomposable constraints like the all-different constraint. 
　in general  gac on decomposable constraints may only achieve the same level of consistency as ac on the binary representation. the problem is that decomposable constraints can often be decomposed into smaller constraints. for example  we can decompose an n-ary all-different constraint into n n - l /1 binary all-different constraints  and enforcing gac on these only achieves the same level of consistency as ac on the binary representation. we can achieve higher levels of consistency if we prohibit too much decomposition of the non-binary constraints. for example  we can insist that the constraints are triangle preserving. that is  we insist that  if there is a triangle of variables in the constraint graph of the binary representation  then these variables must occur together in a non-binary constraint. binary constraints can still occur in a triangle preserving set of constraints  but only if they do not form part of a larger triangle. under such a restriction  gac is strictly stronger than pic  which itself is strictly stronger than ac. 
theorem 1 on a triangle presenting set of decomposable constraints gac is strictly stronger than pic on the binary representation. 
proof: consider a triple of variables  xi   xj xk . and any value for xi  from its generalized arc-consistent domain. the proof divides into four case. in the first    and  appear in one constraint  and and in another. as each of these constraints is arc-consistent  we can find a value for  consistent with     and for  consistent with . as the  nonbinary  constraints are triangle preserving  there is no direct constraint between  and  so the values for  and  are consistent with each other. hence  the binary representation of the problem is pic. the other three cases follow a similar argument. to show that gac is strictly stronger  consider an all-different constraint on 1 variables each with domains of size 1. this problem is pic but not gac. 
　a corollary of this result is that gac on a triangle preserving set of decomposable constraints is strictly stronger than rpc or ac on the binary representation. we can also put an upper bound on the level of consistency that gac achieves. 
theorem 1 nic on the binary representation is strictly stronger than gac on a set of decomposable constraints. proof: consider any variable and value assignment. nic ensures that we can assign consistent values to the variable's neighbors. however  any  non-binary  constraint including this variable has all its variables in the neighborhood. hence  the  non-binary  constraint is gac. to prove strictness  consider a problem with five all-different con-
　finally  gac on decomposable constraints  is incomparable to strong pc and sac  even when restricted to triangle 
preserving sets of constraints. 
theorem 1 on a triangle preserving set of decomposable constraints  gac is incomparable to strong pc and to sac. proof: consider an all-different constraint on 1 variables  each with the same domain of size 1. the binary representation of the problem is strong pc and sac  but enforcing gac shows that it is insoluble. 
　consider the problem in the proof of theorem 1 with five all-different constraints. this problem is gac  but enforcing strong pc or sac shows that it is insoluble. 
these results are summarized in figure 1. 

figure 1: the consistency of gac on a triangle preserving set of decomposable constraints. 
1 	quasigroup problems 
quasigroup problems lend themselves to a non-binary representation using all-different constraints. a quasigroup is a latin square  a n by n multiplication table in which each entry appears once in every row and column. quasigroups model a variety of practical problems like tournament scheduling and designing drug tests. quasigroup completion  the problem of completing a partial filled quasigroup  has been proposed as a constraint satisfaction benchmark  gomes and selman  1 . 
　an order n quasigroup completion problem can be represented as a non-binary constraint satisfaction problem with n1 variables  each with a domain of size n. the constraints are 1n all-different constraints of size n  one for each row and column  and any number of unitary constraints or preassignments. the special structure of these constraints allows us to prove some tighter results. 
	stergiou and walsh 	1 

theorem 1 in quasigroup completion problems  gac is equivalent to nic. 
proof: we need to show that gac implies nic. the neighborhood of any variable in an order n quasigroup completion problem are the 1n - 1 variables that appear in the 1 all-different constraints that contain the variable. as these constraints are gac  we can find consistent instantiations for each of the variables. in the binary representation  none of these variables have a direct constraint with each other. hence  this is a consistent instantiation for the neighborhood. 
d 
　gac on quasigroup problems remains strictly stronger than pic and incomparable to strong pc and to sac. 
theorem 1 in quasigroup completion problems  gac is strictly stronger than pic. 
proof: by theorem 1  gac is stronger than pic. to show that it is strictly stronger  consider an order 1 quasigroup  in which 1 diagonal elements have domains {1}  and all the other elements  including the other diagonal element  have domains {1  1}. this problem is pic but is not gac. d 
theorem 1 in quasigroup completion problems  gac is incomparable to strong pc and to sac. 
proof: consider the problem from the last proof. this problem is strong pc and sac but is not gac. 
　consider an order 1 quasigroup. let every element have a domain {1  1} except the top right which has the domain {1}  the bottom left which has the domain {1  1} and the bottom right which has the domain {1}. this problem is gac but enforcing strong pc or sac shows that it is insoluble. d 
　what can we learn from these results  first  on quasigroup completion problems  we achieve the maximum level of consistency  viz. nic  possible for a gac procedure on decomposable constraints. and second  we achieve this at very moderate cost. regin's algorithm for achieving gac on a set of all-different constraints has a cost that is polynomial in n. by comparison  enforcing nic on binary constraints is exponential in the size of the neighborhood  which is o n  in this case . 
1 	maintaining gac and ac 
we now compare an algorithm that maintains gac on decomposable constraints over one that maintains ac on the binary representation. we say that algorithm a dominates algorithm b if when a visits a node then b also visits the equivalent node in its search tree  and strictly dominates if it dominates and there is one problem on which it visits strictly fewer nodes. using the previous results  we can reduce our analysis to comparing algorithms that maintain nic  pic and ac. in fact  we do better than this and prove some general results about algorithms that maintain any level of consistency stronger than fc in which we just filter domains. this covers algorithms that maintain nic  pic and ac  as well those that maintain rpc and sac. we shall use /1-consistent and inconsistent to denote any two such levels of consistency. 
we assume throughout a static variable and value ordering. 
we can then associate each node in the search tree with the 
1 	constraint satisfaction 
sequence of value assignments made. we say that a node  is a-compatible with another node 
where j   i  if enforcing a-consistency at ' not remove a  from the domain of the respective variable. first  we give a necessary and sufficient condition for a node to be visited. 
theorem 1 a node is visited by an algorithm that maintains a-consistency iff it is consistent  it is a-compatible with all its ancestors  and its parent can be made a -consistent 
proof:  the proofs of the first and third conjuncts are similar to those in  kondrak and van beek  1 . for the second  suppose that node  is not a-compatible with one of its ancestors and it is visited. let 
with j   i  be the shallowest of those ancestors. since  is an ancestor of   it is also vis-
ited. when we visit node and a -consistency is enforced  is pruned out from the domain of . node cannot therefore be extended to this is a contradiction. 
　 wlog assume that node i is the shallowest node that can be made a-consistent  its child  is consistent and a-compatible with all its ancestors  but the child is not visited. since   is consistent and  1-compatible with all its ancestors  a  is in the domain of . at node   we do not annihilate any of the domains of future variables because the node can be made .1-consistent. the branch will therefore be extended to the remaining values of the next variable . one of these values is a - and therefore node is visited. 
　this results lets us rank algorithms in the hierarchy presented in  kondrak and van beek  1 . 
theorem 1 if a-consistency is  strictly  stronger than inconsistency then maintaining a-consistency  strictly  dominates maintaining b-consistency. 
proof: 	all nodes visited by an algorithm that maintains 
.1-consistcncy  are .1-consistent with all their ancestors and have parents that can be made a -consistent. but as aconsistency is stronger than b-consistency  all these nodes are b-consistent with all their ancestors and have parents that can be made b-consistent. hence maintaining a-consistency dominates maintaining inconsistency. to show strictness  consider any problem that is inconsistent but is not aconsistent. 
　from this result  it follows that mgac on decomposable constraints strictly dominates mac on the binary representation  and that mac itself strictly dominates fc. we can also prove the correctness of mgac and mac using the following general result. . 
theorem 1 maintaining a-consistency is correct. 
proof: soundness is trivial as only consistent nodes are visited. for completeness  suppose that some n-level node is consistent. since this node is consistent  all its ancestors are also consistent. wlog consider the deepest node that is not visited  and its parent is 
visited. when node is visited a -consistency is enforced  and since all its descendants are consistent  there is no domain wipe-out. therefore  k is visited. 

1 	experimental results 
to demonstrate the practical relevance of these theoretical results  we ran experiments in three domains. 
1 	quasigroup completion 
gomes and selman have proposed random quasigroup completion problems as a benchmark that combines some of the best features of random and structured problems  gomes and selman  1 . for these problems  there is a phase transition from a region where almost all problems are soluble to a region where almost all problems are insoluble as we vary the percentage of variables preassigned. the solution cost peaks around the transition  with approximately 1% of variables preassigned  gomes and selman  1 . 
　we encoded the problem in ilog solver  a c++ constraint toolkit which includes regin's algorithm for maintaining gac on all-different constraints. we used the brelaz heuristic for variable selection  as in  gomes and selman  1   and geelen's promise heuristic for value ordering  as in  meseguer and walsh  1  . gomes et al. observed that search costs to solve random quasigroup completion problems can be modeled by a  heavy-tailed  distribution  gomes et al  1 . we therefore focus on the higher percentiles. table 1 gives branches explored to complete an order 1 quasigroup with p% of entries preassigned  maintaining either ac on the binary representation or gac on the all-different constraints. we sec a very significant advantage for mgac over mac. with a random value ordering  the worst case for mgac was also 1 branches. cpu times reflect the difference in explored branches. for example  some instances at the phase transition for quasigroups of order 1 were solved by mgac in seconds  while mac took hours. 

table 1: percentiles in branches searched to complete a quasigroup of order 1 using either mac or mgac. * means that the instance was abandoned after 1 branches. 1 problems were solved at each data point. 
　table 1 shows that  as we increase problem size  almost all the problems remain trivial. the only exception was a single order 1 problem with 1% of its variables preassigned. search was abandoned at the cuttoff limit of 1 branches. apart from this  all instances were solved in less than 1 branches. this is a significant improvement over the results of  gomes et al  1  where  despite the use of random restarts  problems of order 1 were too expensive to solve  especially at the phase transition. 

table 1: percentiles in branches explored to complete quasigroups of order 1  1  1 and 1 using mgac. 
1 	quasigroup existence 
a variety of automated reasoning programs have been used to answer open questions in finite mathematics about the existence of quasigroups with particular properties ifujita et al  1 . is gac useful on these problems  we follow  fujita et al  1  and look at the so-called qg1  qg1  qg1  qg1 and qg1 class of problems. for example  the qg1 problems concern the existence of idempotent quasigroups  those in which a-a = a for each element a  in which  1a 1 = a. for the definition of the other problems  see  fujita et al.  1 . in these problems  the structure of the constraint graph is disturbed by additional non-binary constraints. these reduce the level of consistency achieved compared to quasigroup completion problems. nevertheless  gac significantly prunes the search space and reduces runtimes. 
　to solve these problems  we again use the solver toolkit  maintaining either gac on the all-different constraints  or ac on the binary representation  and the fail-first heuristic for variable ordering. to eliminate some of the symmetric models  as in  fujita et al  1   we added the constraint that a n   a - 1 for every element a. table 1 demonstrates the benefits of mgac over mac. in qg1 and qg1  mac explores twice as many branches as mgac  in qg1 the difference is orders of magnitude  whilst there is only a slight difference in qg1 and qg1. mgac dominates mac in terms of cpu time as well as in terms of explored branches. it would be interesting to identify the features of qg1 that gives mgac such an advantage over mac  and those of qg1 and qg1 that lessen this advantage. 
we now compare our results with those of finder 
 slaney  1   mace  mccune  1   mgtp  fujita et 
	stergiou and walsh 	1 


table 1: branches explored using mac on the binary representation and mgac on the all-different constraints. 

1/.  1   sato  zhang and m.  1   and sem  zhang and zhang  1 . table 1 shows that solver outperforms mgtp and finder by orders of magnitude  and explores less branches than sem. sem and sato have sophisticated branching heuristics and complex rules for the symmetry breaking that are far more powerful than the symmetry breaking constraint we use  zhang and zhang  1 . it is therefore impressive that our simple solver program is competitive with well-developed systems like sem and sato. 
　to conclude  despite the addition of non-binary constraints that disturb the structure of the constraint graph  mgac significantly reduces search and runtimes on quasigroup existence problems. we conjecture that the performance of sem and sato could be improved by the addition of a specialized procedure to maintain gac on the all-different constraints. 
1 	small-worlds problems 
recently   watts and strogatz  1  has shown that graphs that occur in many biological  social and man-made systems arc often neither completely regular nor completely random  but have instead a  small world  topology in which nodes are highly clustered  whilst the path length between them is small. walsh has argued that such a topology can make search problems hard since local decisions quickly propagate globally  walsh  1 . to construct graphs with such a topology  we start from the constraint graph of a structured problem like a quasigroup and introduce randomness by deleting edges at random from the binary representation. deleting an edge at random breaks up an all-different constraint on n variables into two all-different constraints on n - 1 variables. for example  if x1  x1  x1 ...  xk are all-different and remove the edge between x1 and x1 then we are left with all-different constraints on x1  x1 ...  xk and x1  x1 ...  xk. 
　figures 1 and 1 show percentiles in the number of branches explored and in cpu time to find the optimal coloring of order 1 quasigroups in which we delete p% of edges from the binary representation. the hardest problems had 1% of their edges removed. mgac dominates mac by orders of magnitude in the hard region both in terms of branches explored and cpu time. all instances were solved by mgac within 1 seconds while approximately 1% of the instances could not be solved by mac within 1 hour. as p increases  problems become very easy and both mgac and mac quickly find a solution. mac starts to outperform mgac in terms of cpu time as the overhead of gac on the large number of 
1 	constraint satisfaction 
all-different constraints is greater. 

figure 1: percentiles in branches explored by mac and mgac to color small world problems. 

figure 1: percentiles of cpu seconds used by mac and mgac to color small world problems. 
1 	related work 
 gomes and selman  1  solved quasigroup completion problems using the mac algorithm and a binary representation. they found that a randomization and restart strategy could eliminate the heavy-tailed behavior of the backtracking algorithm. however  they were still not able to consistently solve quasigroup completion problems of order 1 or larger. 
　 meseguer and walsh  1  solved quasigroup completion problems using forward checking  fc  on the binary representation. they found that discrepancy and interleaved based methods can reduce the heavy tail. however  their experiments were limited to quasigroups of order 1 and less. 
　 bacchus and van beek  1  have compared generalized fc on non-binary constraints with fc on the hidden variable and dual encodings into binary constraints. they show that 


table 1: branches explored and models found on qg1 problems by a variety of different programs. 

a simple extension of fc on the hidden variable encoding dominates generalized fc on the non-binary representation. 
1 	conclusions 
we have shown experimentally and theoretically the benefits of achieving generalized arc-consistency on decomposable constraints like all-different constraints. generalized arc-consistency on such constraints lies between neighborhood inverse consistency and  under a simple restriction  path inverse consistency on the binary representation of the problem. on quasigroup completion problems  generalized arcconsistency achieves neighborhood inverse consistency. by generalizing the arguments of  kondrak and van beek  1  we proved that a search algorithm that maintains generalized arc-consistency on decomposable constraints dominates a search algorithm that maintains arc-consistency on the binary representation. our generalization also proves the correctness of the algorithms that maintain arc-consistency or generalized arc-consistency. our experiments demonstrated the practical value of achieving these high levels of consistency. for example  we solved almost all benchmark quasigroup completion problems up to order 1 with just a few branches of search. on quasigroup existence problems  we are competitive with the best programs  despite lacking their specialized branching heuristics and symmetry breaking rules. 
　what general lessons can be learnt from this study  first  it can be very beneficial to identify structure in a problem by means of a non-binary representation. we can use this structure to enforce higher levels of consistency than can be practical in a binary representation. second  theory can be motivated by experiment. we were led to attempt our theoretical analysis by the exceptionally good experimental results on quasigroup completion problems. and finally  the all-different constraint really can make a big difference. 
