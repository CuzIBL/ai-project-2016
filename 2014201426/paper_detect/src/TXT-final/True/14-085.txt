ed forms of typical control structuring mechanisms from programming languages: 1  operation sequencing  1  diikstra's if statement    see section iia below   and 1  the while loop. the complex schemas result from our unified theory of combinatorial search algorithms  and presently consist of schemas for divide and conquer  branch and bound  greedy  and dynamic programming algorithms. it is our view  that well designed algorithms are often adaptations of one of a small number of 
1 


1 


before the schema can be used a selection must be made of a description of the input and output data types as discussed in section ia. for the sort problem the selection of a description of the integerlist data type containing the generator funny cons will ultimately lead to the production of insertion sorts and selection sorts. the selection of the append generator leads to the production of quicksort and mergesort algorithms. the underlined function names in the divide and conquer schema are data operations to be filled in by the adaptation process. the predicate prim returns true exactly when its argument is an element of the set of primitive objects of the input data type. primsol produces the correct output for the problem when its argument is a primitive object. decompose splits its argument into smaller pieces on which the algorithm recurses. finally compose takes the results of the two recursive calls and combines them to form the output object. 
　　　we w i l l ignore the heuristics for guiding the instantiation of the prim and primsol operations and focus instead on the two heuristics for handling the nonprimitive case. one of these heuristics suggests selecting an operator for decompose from the dskb and then solving for the specifications of compose. selection of the simplest decompose operator leads to mergesort and insertion sort algorithms  depending on the previous choice of generator . the dual heuristic suggests selecting an operator for the compose and then solving for the specifications of the decompose operation. selection of the simplest such compose operator for the sort problem leads to the production of quicksort and insertion sort. in the case of quicksort we select append as our compose operation and derive the following specification for decompose 

	i l l 	conclusion 
　　　an overview has been presented of a system for generating algorithms from user supplied s p e c i f i c a t i o n s . the system attempts to adapt one of a small number of algorithm schemas to the specifications. the process of adapting a schema generates s p e c i f i cations for subalgorithms. the r e s u l t i n g algorithms are guaranteed to be correct since the adapt a t i o n process works by attempting to instantiate a correctness schema in order to make it a true f o r -
mula. 
　　　we are continuing to generalize and extend our theory of combinatorial search algorithms which supplies the knowledge and organizing principles underlying our control structure and data structure knowledge bases. for experimental purposes we have a prototype system running that is able to handle the proofs of correctness formulas and the generat i o n of subspecifications for the sorting algorithms discussed in section i i b . 
