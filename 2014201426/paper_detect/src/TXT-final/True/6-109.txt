 
when a security incident occurs it is sometimes necessary to identify its causes for legal and cautionary purposes. in an attempt to hide the origin of her connection  a malicious user may have jumped from a source host h1 into a series of hosts h1 € h = {h1 h1 ...  hn} before breaking into final target ht. this connection sequence describes a path that makes it difficult to find h1 given ht due  in part  to the prohibitive amount of cooperation and synchronization that is required in practice by administrators. this paper describes a distributed rule-based model that automates this tracing process on-line with a 1  h    worst case scenario. autonomous agents collaborate on the tracing and detection of the origin of an interactive connection using a loop unwinding technique and incorporating public key cryptography to create ciphered channels that allow them for secure communication. to meet the challenges of minimum system workload and improved robustness  the prototype features lightweight design and implementation as well as a dynamic port-allocation scheme to prevent sniffing and denial of service attempts. we describe the proposed model and present the experimental results obtained with the prototype system odiset. 
1 introduction 
unauthorized access to computer systems is increasing in parallel with the growth of the internet  irapalus  1  . for purposes of protection  accountability and liability  the need for connection back-tracing is a reality in the areas of cybernetic-law enforcement and computer security. the authentication structure of our networks as well as their distributed nature complicates the task of spotting the host from 
   *this project was supported by the insys computer security research grant  cdtedra insys de lnvestigacidn en seguridad informdtica  of instituto tecnol1gico y de estudios superiores de 
monterrey 
multiagent systems 
which a connection sequence stems. if some sort of anomalous activity is observed from one of our users  it may be necessary to trace the origin of the session in order to identify the person behind it. in most cases  this is not easy to accomplish  yoda and etoh  1 . 
¡¡within the domain of a lan  it is rather straightforward to perform this tracing given that system administrators usually have access to all the hosts within their lan. unfortunately  not all sessions come from the inside. if a connection is received from the outside  we will have to contact the administrator of a remote host hr in order to discover the identity of the user or the next link of the connection path or chain. our fellow administrator will have to look into her system to realize that  perhaps  it has been compromised as well. it is possible that the user we arc looking for is using hr as a step-stone to reach our server. in that case  we will have to contact some more system administrators within the country and/or abroad  cheswick and bellovin  1   stoll  1 . this has obvious implications time and cost-wise. 
¡¡once a system has been compromised  the perpetrator may have left back-doors installed to facilitate future access to the system. using interactive sessions  she may visit the system again even when the software has been patched and her backdoor remains untouched. it is not necessary for the user to be logged on in order to be detected. audit trail files can be used to do off-line tracing but this can be a tough task since audit logs may have been tampered with or deleted. 
¡¡in the case of connections to web servers through http and https  for instance  the hosts that compose the connection chain between client and server cannot be easily modified. some components of the routing system would have to be modified in order to force the packets to follow a particular path. in the case of interactive sessions  however  applications such as t e l n e t   l o g i n   r l o g i n and ssh allow a user with suitable access permissions to connect from host to host back and forth creating loops at will to scramble her connection path a little. this significantly complicates the structure of the chain and the amount of effort required to detect the root host h1 from where she is actually starting everything up. in fact  the complexity of back-tracing a connection across a set h of n hosts maybe small for a small n and a small number of connection hops  but it rapidly increases as n becomes larger due to the number of hosts that a chain may contain. 
one of the challenges of intrusion detection is to accu1 
rately identify the main causes of an incident. the ultimate goal is to catch intruders in real time and our objective is to help intrusion detection systems do the part of session tracing on-line. there are some intrusion detection and intrusion response tools  yoda and eton  1   asaka et a/.  1   wang et al  1  that provide some sort of off-line connection tracing that also performs data correlation with previously recorded user activity information. 
¡¡this paper proposes an on-line approach that makes use of intelligent agents to identify the origin of a live session by unwinding connection loops. instead of using historical audit trails  this model relies on evidence captured on operating system tables that are continuously refreshed by the system. for this reason  it is not likely that these tables experience changes that go unnoticed. the communication structure of the agents uses rsa public-key cryptography  rivest et al  1   schneier  1  to implement an encryption model that protects all communications between agents. one of the main issues of the multi-agent approach to automatic security monitoring is the overhead imposed by this sort of tools  weiss  1   spafford and zamboni  1 . our prototype system odiset was built from a lightweight design that does not represent a performance threat  making it ideal for wide deployment through an open source operating system. we present the design ideas behind the model  the tracing and communication techniques  the loop-unwinding method  as well as some experimental results of the first release of the prototype. 
¡¡the rest of this paper is organized as follows: section 1 explains the problem of connection back-tracing. section 1 discusses relevant related work in the area. section 1 is a description of our solution approach and the implementation issues of the prototype. section 1 includes experimental results and findings. conclusions and future work are in section 1 right before the listing of bibliography and references. 
1 the problem of connection back-tracing 
given a set of hosts h = {h1  h1 ...  hn   with  a user could create a connection chain of m hops as follows: from host hi into from into from into  
and so on  until finally connecting to target host ' 	the problem of connection back-tracing is: given the set h  the target host 	and username connected to 	find 	the hosts that compose the connection chain and identify its root host  this problem is straightforward. just a 
few hosts need to be analyzed in order to identify the source of a connection sequence. however  as n becomes larger  e.g. n  1   the complexity of the problem increases since a larger number of hosts in h multiplies the possibilities of creating a more confusing connection path. 
¡¡system administrators have limited access to information on who is connecting to one of their servers. on a lan  administrators typically have login access to all servers  which makes the tracing process easier; however  for connections coming from the outside of the lan  they will be unable to freely access all other servers for scrutiny. the visibility of this type of connections reduces to one link of the connection chain. that is  an administrator can only see the terminal number or the ip address/host-name of the immediate host from where the users are logging on. she is unable to tell  however  whether that host is in fact hi  the machine from where the user is actually typing in commands . in order to find out whether that is the root host or not  she will have to contact the administrator of the remote system who  in turn  will have to perform a similar checking. 
¡¡this job is cumbersome and requires time  communication  and trust from the parties involved. for the case of a connection that has been closed already  audit information will have to be examined in order to find the nodes of the chain that lead to the origin of the connection. this off-line sort of tracing has an important flaw: it counts on the existence and integrity of audit log files. for clean systems this would not be a problem but  for systems that have been compromised  and  in the case of a connection chain created to perpetrate an attack this could probably be the case  these files could have been tampered with during a previous break-in f yoda and etoh  1  . on the other hand  if a connection is still alive  i.e. there is a flow of packets between source and destination  information contained on system tables and network packets can be used to trace the user while she is on-line. that is  precisely  our approach. 
1 related work 
there are some projects that touch on the problem of connection route tracing. one of them is the method proposed in  yoda and etoh  1 . this model implements network traffic monitors that perform session tracing once a server has been compromised. a system that computes deviations from the traffic observed at two different hosts helps determine if these hosts were used in the same connection chain. since checking network traffic at a node involves huge amounts of data  multiple packet monitors permanently filter and record specific system activity to build their own logs. these files are analyzed by a data correlator to identify the hosts of a connection chain. it is important to notice that this system deals with the problem of deleted logs by creating its own records. these records  however  may be the target of the same type of attack. 
¡¡ida  intrusion detection agent system   asaka et al  1  is another system that detects the origin of an information exchange related to an incident. it is primarily an intrusion detection system that employs mobile agents to detect local attacks. from a main host  investigation agents are sent over to the requester that needs an integrity check. these agents use the mlsi  marks left by a suspected intruder  strategy to reduce the amount of data needed to flag system activity as anomalous. in order to collect further information on a break-in  ida does passive route tracing using audit log data. the structure of the tracing method is not specified by the authors but its agents broadcast connection evidence to their peers as a way of identifying possible hosts involved in the attack. 
¡¡the tbair system  tracing-based active intrusion response   wang et al  1  is a network-based intrusion detection tool that  unlike most traditionally-passive intrusion 

detection systems  adds active response to security events using a technique called based on sleepy watermark tracing. tba1r tries to attack the root of the vulnerability exploiting problem by locating the originators of the incident to hold them accountable for their intrusions and their method is based on the analysis of evidence collected from the network. 
¡¡thumbprinting  staniford-chen and heberlein  1  is a technique that places several processes across the network in order to capture activity signatures or  thumbprints . this method does not require to have processes on all hosts and  like in the case of  yoda and etoh  1   it replicates packet information for future review. this system is based on the fact that the packet content of a session passing though a set of hosts is invariant and can be compared in order to identify a host in the chain. this system is capable of detecting the root of a connection but it is not designed to identify the exact hosts that are part of the chain. 
¡¡the approach that we present here through the implementation of the od1set system differs from these previous projects in the following manner. it performs on-line rather than off-line tracing  i.e.  it does not use audit logs . the system does not incorporate agent mobility. instead  it uses a distributed model using agents that communicate over secure channels for sharing information. unlike some other models  odiset is able to not only identify the origin of the connection but also all the hosts that are part of the connection chain. 

figure 1: basic composition of an odiset tracing agent: public and private encryption keys  client functionality  server functionality  rule base  and knowledge base  connection chain tree + user data . 
1 solution approach using agents 
 we require systems that decide for themselves what they need to do in order to satisfy their design objectives. such computer systems are known as agents   weiss  1 . the use of agents for performing system assurance activities  spafford and zamboni  1  that typically require the skills of a human  e.g. inference  learning and decision making  makes possible the development of automatic or semiautomatic tools that aid system administrators in their task of securing a system. 
¡¡the distributed nature of agents allows for more efficient  parallel data processing. we take advantage of this feature 
multiagent systems 
that perfectly fits into a network environment  huhns and singh  1  in order to speed up connection back-tracing using autonomous agents. this approach eliminates the need for centralized data collection and analysis  a method that is still in use and that represents a design deficiency by putting the availability of a system in risk  monolithic systems typically suffer from having a single-point-of-attack . 
¡¡in order to provide the agents with survivability features that make them more resistant to attack  each agent owns a digital certificate to create private communication channels when interacting with its peers. with the intention of reducing the probability of denial of service  dos  attacks targeted toward the agents  a port-allocation scheme is used. this scheme dynamically changes the socket port numbers used by the agents in order to avoid being monitored or receiving unfinished-protocol requests. 
¡¡this system features rule-based agent behavior through which individual agents are capable of detecting connection loops in a chain. the approach deals with the problem of deleted or damaged audit information by not using historical audit data. agents look up information on dynamic session tables in order to extract data relevant to the tracing process. the process table  for instance  is not easily modifiable as audit logs are. the system might go down due to inconsistency if changes are made to this type of file  which would make the change evident. 
1 proposed model 
tracing method and security 
the system is composed of a number of tracing agents  figure 1  that communicate with each other sharing information on user connections. there is an agent running at each host hi and the ideal situation is having an agent running on every host of the network. every agent has client and server capabilities that enable it to request information from other agents and to supply information to them. an agent is not useful by itself  it needs to collect information from the others in order to identify the links of a connection chain. the agent at the target host will eventually collect information from a number of its peers and will inform to the local administrator about the origin of the connection. 
¡¡the perceptions of a tracing agent are received from two main sources: 1  the state of the system regarding user sessions and connections  and 1  messages from other agents requesting or providing information. 
¡¡the environment an agent inhabits is highly dynamic and provides the communication channel necessary for an agent to stay in touch with its peers over the network. this environment can also represent a threat to the tracing system if malicious users gain access to it. 
¡¡as a result of the changes perceived by an agent  it can perform a number of different actions: a  send messages to an agent  b  request messages from an agent  c  broadcast messages to all agents  d  generate encryption keys  e  encrypt messages  f  decrypt messages  g  identify connection loops  h  retrieve system status information  and h  save its knowledge to a safe location. 
the knowledge of an agent is stored on a repository known 
1 
as knowledge base  kb . this kb includes tracing host information and user data. a tree structure stores the information on the hosts that are part of a connection chain. information regarding user names  login times and dates is stored on a separate structure. these two elements represent all the knowledge an agent has about the state of its environment. should this knowledge be lost  the agent would lose track of previous events and would have to be updated by its peers. 
¡¡the actions an agent takes depend on the information of the state of the system and its perceptions  russell and norvig  1 . embodied into the agent are a set of rules that enable the agent to work autonomously deciding what to do. as new knowledge is fed into the kb more rules from the rule base need to be analyzed before making any conclusion and proceeding  the rule base is composed of 1 rules . the type of perceptions and actions do not change but the state of the environment does evolve hereby modifying the behavior of agents. the type of rules that make up the rule base are of the form: 
r1: 
 if 	  how-connected user  console  and  what-doing user =ssh-to target     tractng-doneo; 
r1: 
tf    message-type  message  t r a c i n g request  and  valid-public-key pkey =false   
 deny-connectiono and broadcast-
tree    and alert   ; 
¡¡in order to protect their information exchanges  all agents have an rsa key-pair that is used to negotiate symmetric session keys before encrypting their messages. encryption at this level guarantees that the information will not be visible at any point before reaching the top of the ip stack of the recipient party. this will deter sniffing attacks that arc otherwise possible on plain text agent communications  jansen et al.  1 . 
¡¡the tracing process starts when a connection needs to be monitored. agents at target host ht receives local information from the system and checks for remote connections. if there is a connection from a remote machine hr  a will contact agent b at host hr in order to research the connection. for this purpose  a private channel will be opened using the asymmetric encryption keys of the agents. a symmetric session key will be agreed upon and all messages will be encrypted with it for that exchange. the same procedure will be followed if there are relevant connections from outside of the host of hr coming into the server. a set of secure channels will be setup by the agents in order to share the information they have regarding connections and user activity. one hop at a time  the links composing a connection chain will be found. 
¡¡the tracing information obtained by an agent is shared with the rest of the agents through broadcast communication  i.e.  an agent sends a message to all existing agents . this guarantees that the kb's of the agents are consistent with the state of the environment and that  in the event of a security incident  the knowledge acquired by an agent will not be lost as it has been replicated and enriched by other agents. 

figure 1: loop unwinding. if a user connects from host h1 into host ht doing a loop through hops 1  1  1  1  1 and 1 as shown above  agent a at ht will start the tracing process and will be able to identify the loop to reduce tracing time in the future. 
¡¡if we have a set h of n hosts  and a user creates a connection chain c of m hops  the system will behave well with a o n  worst case scenario. suppose m n. if the number q 
 1 q m  of connections that go from host hx into host hy - or vice versa - form a loop  the arrangement of the agents will find at most two relevant connections between the hosts hereby unwinding the loop. this is due to the fact that an agent is capable of identifying repeated connections toward itself by storing information on what users are connected. for the case of loops passing through k hosts  the chain will be reduced to at most 1k hops. this makes a worst case scenario of o n  with n =  
¡¡several methods exist  see  wolf and lam  1  for a reference  for loop unwinding  mostly in the compilers and discrete mathematics areas. in our model  we utilize a simple technique based on observed activity. an agent first stores user name and host-name information on its kb. when a tracing process is started  an agent will engage in communication with several neighbor agents in order to collect data that allow them to draw conclusions. each time agent a receives new information  it checks its kb for loops. this is done as follows  see figure 1 . all tracing requests have an id number w. agent a initiates a tracing round. if while waiting for news on a particular w the agent is being asked by a cooperating agent b for information to complete tracing round w as well  the agent knows it is part of a loop since it is receiving information on a tracing round that it started  all agents  including initiators have this property . the trace is stored on its kb tree t and  if the user being traced repeats a loop that passes through the same host where agent a is located  this agent will reduce the tracing time by omitting a further requests to follow a loop. 
dynamic port-allocation protocol 
network service daemons usually work on a particular port listening for requests. port-scan attacks try to reveal what are the services listening on the ports of a host. once this is done  they look for vulnerabilities present on one of those services and  if they find one  they are in a position to exploit such a flaw on the port they have previously identified. dos attacks are started with port-scans to send a large number of request for service to a vulnerable port so that  at the end  there are so many requests pending to be answered - usually incomplete requests at protocol level - that the machine slows down and needs to be restarted. additionally  if the service on that port does not support encryption  the traffic going through it may be observed by a network sniffer. 
¡¡all network services using sockets on a port may suffer from this sort of attacks. we propose a model to minimize the likelihood of being a target. as we mentioned  all communications between agents is encrypted  so sniffing of plain text is impossible in practice. in order to deter attacks at the service port  we propose a technique that can be used in real life with radio equipment: channel switching  this is currently being implemented on the prototype . initially  all agents listen on a well-know port p. the requests for service on that port do not allocate significant system resources according to the implementation. this basic port is used just to agree on the actual communication port q for the exchange  q  p . for this  the receiver proposes a valid port number that is sent to the other party over a secure channel. they immediately switch to that port for exchanging information. this port switching is repeated during the session within a fixed short period of time. in order to defeat this protection mechanism  a port scan will have to be run again and  by the time it succeeds  the communication may have moved to a different port. frequency of switching and encryption this mechanism possible. 
1 	implementation of the model 
as a proof of concept  the model was implemented on a prototype system named odiset  on-line distributed session tracing . every agent is a stand-alone process implemented with sockets for providing client and server functionality. it can request information from others and it can share information as well. a 1-bit rsa key-pair {kpub kpriv} is generated before the agent is launched. once the agent is started up  it is ready to collaborate in the tracing of a session. when contacting a peer agent  it exchanges public keys and verifies the signature on the received key. the certification must come from the odiset master key whose publickey is accessible to all agents. in order to speed up message encryption  and given that encryption with public-key methods is much slower than the one using private-key algorithms  schneier  1    the agent that is to send a message does the following: 1  it generates a session key kdes for symmetric encryption  1  it then encrypts the message m using kdes* 1  it encrypts kdes using the public key of the recipient  and  finally  1  it sends the encrypted session key and the encrypted message to their destination. the implementation of the rsa and des algorithms is based on version 1 of the rsaref tm cryptographic library by rsa laboratories. 
¡¡the first release of the odiset prototype was developed on a redhat linux 1 box. although agent templates can be easily obtained from multiple agent-generator systems and for different compilers and interpreters  they typically put unnecessary functionality into the agent that produces heavy agents. for this reason  and with the intention of providing 
multiagent systems 
the best performance possible  the implementation was made in c by minimizing the number of libraries to include. considering that programs and data files may be damaged after a security incident and that a security tool can not rely on them  our agents do not use the output of programs such as w  who and ps to read system tables like utmp and wtmp. they incorporate this functionality into its own body  which gives them extended independence. the size of each agent is around 1 kbytes to which we add two encryption keys that need to be uploaded at certain point  around 1 additional kbytes  as well as the knowledge and rule bases that are never uploaded entirely into memory. 
¡¡the knowledge base of each agent includes a tree structure t where all connection chains are stored. whenever a host has received all the information regarding a particular session  it 
stores the connection chain c =  hi h1 ... hri  into t and sends it to all available agents. every agent reads c and finds the hosts in c that match its own tree. it then creates new branches to keep its kb up-to-date. the rule base is encoded along with the body of the agent. being an static structure  it is not necessary to keep it as a separate entity. 
1 experimental results 
in order to evaluate the efficiency of the method  multiple experiments were prepared. after some implementation corrections  all of them were successful after the unwinding technique was incorporated. the testing facility is a set of seven linux machines running kernels 1 and above on redhat 1  redhat 1  redhat 1 and mandrake 1 operating system installations. the general structure of the experiments consists of creating connection chains of length m  {1 1 1} using n hosts where n  {1  1}. this maximum number of machines was selected since our experience tells it is highly improbable that  for session performance purposes  an attacker uses much more step-stone hosts. all cases where there is no loop in the chain  that is  where m = n are easily resolved so we prepared connections that include a series of loops along the chain. for instance  in the three-server setup  the connection goes in circles from host hi into h1  from host h1 into host h1  from host h1 back into host h1 and so on for a total number of m hops. the experiments show that the algorithm effectively unwinds the loops. when an agent finds the same loop repeated several times  it will not try to solve it over and over again. its kb contains user and connection information that allows it to conclude that a user is creating a loop. 
¡¡part of the contribution of this method is the fact that by using loop unwinding  the performance of the algorithm has an upper threshold that is  at most  linear on the number of hosts n through which the user connects. a set of n agents will be in charge of tracing the connection and even for a very long chain  an agent located on each hosts guarantees that loops will not delay the tracing process in any way. 
¡¡table 1 includes tracing numbers with and without encryption. both columns indicate that the growth of the tracing time is below linear time with respect to the number of hops m  this makes us think this model should escalate well to large networks . the time difference from tracing with and without 
1 

table 1: tracing time with and without encryption  rsa key exchange + des chaining block ciphering  with seven hosts  /i=1 ; m corresponds to the number of connection hops. encryption is significant. this only reminds us of the performance cost of using cryptographic algorithms to protect our data. it is not likely that a connection chain extends over more than thirty hosts  for instance. it follows that  even with 1bit keys  the use of encrypted communication is the way to go regarding agent communication for this problem. 
¡¡the strengths of this model are its unwinding algorithm  the possibility of performing on-line tracing and the structure of an autonomous lightweight agent. the proposed dynamic port-allocation method can effectively deter communication sniffing and promises to be effective for the case of agentbased applications as well. a disadvantage of the system is that it works exclusively with alive connections. if  for one reason  the user disconnects the session from our host  the agents will go blind and will not be able to trace the intruder. the model  however  can be easily extended toward off-line tracing  but there are already other systems  like the ones highlighted in section 1  that cover that case. another improvement area is the fact that an agent will see only users that are connected to a host through an interactive session using commands that update system tables. if an intruder exploits a vulnerability and gets to spawn a shell session at the host without having to run a remote connection command  she will not be seen. that is because these connection commands like r l o g i n and ssh write system activity information to system tables. if none of this programs is used by an intruder  the host will not record her presence and she will be able to go unnoticed. 
1 conclusions and future work 
this model proves the feasibility of performing on-line connection back-tracing using lightweight autonomous agents in a distributed fashion. it also proposes two security mechanisms that can be implemented on other software agents to make their communication structure more robust  these mechanisms are random port-switching and encrypted agent communication using certificates . we conclude that the adoption of a tracing system like this by multiple operating systems through a sort of agent sand box per host would indeed contribute to solve security incidents more rapidly. 
¡¡future work includes a  the integration of the odiset tracing tool into an agent-based intrusion detection system  b  the development of survivability methods for agents using replication  mobility and zero-loss mechanisms  and c  the extension of the tracing space to include dial-up connections. 
