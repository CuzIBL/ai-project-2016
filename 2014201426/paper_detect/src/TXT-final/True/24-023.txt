 
this paper extends shapiro's model inference system for synthesizing logic programs from examples of i n p u t / o u t p u t behavior. a new refinement operator for clause generation  based upon the decomposition of prolog programs into skeletons  basic prolog programs with a well-understood control flow  and techniques  standard prolog programming practices is described. shapiro's original system is introduced  skeletons and techniques are discussed  and simple examples are provided  to familiarize the reader with the necessary terminology. the model inference system equipped with this new refinement operator is compared and contrasted with the original version presented by shapiro. the strengths and weaknesses of applying skeletons and techniques to synthesizing prolog programs is discussed. 
1 	introduction 
inductive learning of concepts  given a set of examples and counterexamples  has been given a lot of attention in the artificial intelligence community. this paper concerns a special case of inductive learning  synthesizing prolog programs from examples of their input/output behavior. an incremental inductive inference algorithm was developed in  shapiro  1  for synthesizing logic programs. shapiro named his implementation the model inference system  mis . 
   mis has several components including: detection and removal of a false clause  detection of the inability to prove a goal known to be true  and the ability to find a new clause to justify the known truth of a goal. anyone experimenting with mis quickly discovers that some programs are easy to learn  others can be synthesized with difficulty  and others are beyond the scope of the system. the reason for the variation in performance can be traced to the refinement operator used to produce new clauses  and the search strategy employed to determine if the new clause correctly implies the examples. hence the refinement operator  due to its influence upon the 
scope of the system  is the focal point for this paper. 
this paper will describe mis with one of its refinement 
           leon s. sterling computer engineering & science dept. 
case western reserve university cleveland  ohio 	1 u.s.a. 
operators and with a new refinement operator based on work on decomposing prolog programs into skeletons  basic prolog programs with a well-understood control flow  and techniques  standard prolog programming practices. in contrast to shapiro's refinement operator  which checks and adds new clauses one at a time  the new operator produces all refinements and then checks the clauses generated. in fact  every time mis tries to learn a new clause the refinement operator goes through the same order of clause generation. by checking previously refuted clauses  the program refrains from repeating its mistakes. we will denote mis equipped with our new operator as the model inference system with skeletons and techniques  misst . 
   in misst the refinement operator consists of two phases. the first phase matches the necessary data structures with a skeleton - an appropriate control flow for the program. this generation of a skeleton is accomplished by creating a template using only the input arguments from the program to be synthesized. once the skeleton is created  the second phase enhances the skeleton by applying a technique to it. each technique will generate a program to be checked for correctness. examples of the types of programs which are hard or impossible to learn and those easy to learn will be given for each system. we will examine the implications of the results and cite areas for future research. 
1 	the model inference system 
the model inference system is an implementation of an incremental inductive inference algorithm. given a set of examples and counterexamples of a new concept  mis produces a set of horn clauses to represent the concept. whenever the current set of clauses prove a counterexample true  the proof tree is used to determine the faulty clause in the set which is then removed. if there exists an example not explained by the current set of clauses  a new clause is generated using a refinement operator. a 
major assumption of the system is that an oracle exists which knows the truth or falsity of any particular ground instance of the concept to be learned. 
   the refinement operator determines the type of prolog programs which can easily/not easily be learned through mis. one refinement operator given in  shapiro  1  was specialized for generating clauses for definite clause 
	kirschenbaum and sterling 	1 
grammars whereas a second operator was presented as a more general operator. each operator was designed for synthesizing a different type of program. in this paper  we use the generalised refinement operator for all comparisons with misst. 
   mis needs to have access to certain knowledge to successfully synthesize a logic program. the following two types of knowledge are specific to the intended target program and are supplied by the user. 
   declarations about the type and mode of each variable are used to determine how the variables will be instantiated. 
   information about 'allowable' predicates guides clause creation. an added goal is related to the other goals in the clause through the instantiation of variables as specified by the type and mode declarations. 
   other knowledge is included as part of the mis database. for example  there is a list of instantiations for each type. a list variable can be instantiated to  or  x|x. . 
   the general refinement operator performs in the following way: 
1. instantiate output variables to some input variables  removing those variables from the yet to instantiate output list. 
1. instantiate inputs in the head of the clause to one in the list of possibilities. in the case of lists  this could create two new input variables  one for the head of the list and one for the tail. 
1. instantiate outputs in the head of the clause to one in the list of possibilities. in the case of lists  this could create two new output variables  one for the head of the list and one for the tail. 
1. unify two input variables which are selected at random. 
1. a d d a goal which generates some output. 
1. add a goal for test purposes. the input variables for the new goal are selected from the input variables for the head. 
¡¡mis has specialized search strategies to determine if a clause generated by the refinement operator covers a particular goal. a clause a b1  b1       bn covers a 
   goal a if there is a substitution such that  and bi1 are true for the three given strategies described in  shapiro  1  are called eager  lazy  and adaptive. the eager strategy will find a clause to cover the goal in question and  if necessary  query the user to determine the truth of the goals in the body. this is a powerful strategy in the sense that it will go beyond the current set of facts to synthesize a program. the obvious drawback is the numerous interactions required with the user. the lazy strategy behaves in an opposite manner  only using goals known to be true when checking the examples against the hypothesized clauses. the lazy strategy is less powerful than the eager one but does have the advantage of not requiring any assistance from the user. the adaptive strategy is a combination of the previous two. like the lazy approach  the adaptive strategy will not query the user  but it will try to 1 learning and knowledge acquisition 
see if a goal is correct by not only checking the facts for that goal but also by checking the facts for the body of the clause. the strategy choice is important as to which kind of programs can be synthesized as can be seen with the well-known program append  given below  which can only be synthesized using the eager strategy. 

the complete mis algorithm is given in figure 1. the repeat loop in figure 1 is bounded by the allowed depth of the proof tree. the default depth used is 1. 
	t h e m i s 	a l g o r i t h m 
   given a possibly empty set of horn clauses  background information   goals to be called by the target concept p  false-solutions =  and true .solutions =  
repeat 
read the next example or counterexample of p and add it to the corresponding list of true or false solutions  repeat 
if it is possible to derive a fact in false solutions then find a false clause and remove it from the set of horn clauses representing the hypothesis. 
     if it is impossible to derive a fact in true solutions then generate the refinements until a previously untried clause covers this fact. a d d this clause to the set of horn clauses. until neither of the if tests is entered 
   output the current set of horn clauses. forever 
figure 1 
1 	skeletons a n d techniques 
w i r t h presented the idea of stepwise refinement as a methodology to be used during program development to produce clear  well structured programs  wirth  1 . currently  the collection of prolog examples available from the literature is lacking in structure. we have developed the method of stepwise enhancement to provide this missing structure  kirschenbaum and sterling  1; lakhotia and sterling  1 . 
   stepwise enhancement delivers a structured and procedural approach to prolog program development which can be described as follows: when a new problem is attempted  isolate the basic control flow needed to solve the problem and embody it in a skeleton. once the skeleton has been determined  extra computations are included by applying appropriate programming methods  which we call techniques  to yield an extension. separate extensions can be combined to produce the desired product. the extension s  can then be regarded as another skeleton allowing us to repeat the process until the final program has been developed. the number of refinements made during the top-down development of the program will determine how often the above process will be repeated. 
   stepwise enhancement can be applied to manipulating recursive data structures  one of prolog's strengths  since the various methods available for handling recursive data structures can be naturally partitioned into several skeletons based on a common control flow. these skeletons constitute the basic building blocks for program development. for example  if we need to process an entire list of elements  we might want to use the following skeleton: 

if we want to process a list until we find a particular element then the appropriate skeleton is: 

two points need mentioning here. first  a slight modification in the base case produces a different skeleton. second  the only purpose of a skeleton is to drive computations built upon it. 
   in contrast to the characterization of skeletons in terms of control flow  techniques should be conceived in terms of the specific goal to be accomplished. for example  the appropriate method for counting the number of elements of a list  the number of nodes in a tree  or the number of goal reductions or depth in a proof tree  has been to increment an argument and then carry it as a context. standard prolog programming practices  or techniques  like this one have the common feature that they build upon an already existing program. the technique calculate can be applied to traverse to produce a program to find the length of a list. there are different variants of calculate  one for each type of arithmetic operation that could be added to the skeleton as an extra goal. 
   intuitively  one can think of skeletons as the mechanism which controls the program whereas techniques determine what is done with the data. skeletons  therefore  make explicit the control flow that the program is expected to follow. a consequence of this is our restriction of induction to prolog programs rather than logic programs more generally since logic programs are nondeterministic and therefore display no predetermined control flow. the separation of control flow from technique is the main idea for providing extra structure for program synthesis. for more information about skeletons and techniques see  kirschenbaum and sterling  
1 . 
1 	misst's clause generation 
in our prototype misst system  we have restricted our attention to list data structures. the skeletons are generated by choosing one or more list arguments to recurse upon and by determining all the reasonable base cases. we have made the same assumption as mis that there exists an all knowing oracle to answer the queries posed by the system. we also assume the presence of information detailing allowable predicates for clause creation. 
¡¡an interesting aspect of skeleton generation occurs when the target program uses other predicates for testing and updating arguments. predicates like and require the comparison of two variables which  in all generality  may be any of the variables in the head of the clause or even worse it may be output variables from some other goal in the body of the clause. for example  here are a few of the reasonable possibilities for a skeleton predicate with one list  two element variables and which uses   and  . 

without using some knowledge we will generate too many possibilities. the following quick estimate clearly shows why. let 
  n = the arity of the skeleton predicate 
  pi = number of arguments in the predicate pi 
  m = number of possible predicates to be used in the skeleton 

then  in the special case where each of the m predicates is included in the skeleton once  and all the arguments come from the head of the clause  we will generate ns skeletons. therefore the total number of skeletons generated is at least 1 ns . an example of a poorly generated skeleton would be 

therefore  we have added the following knowledge to misst. 
1. mode of variables - unify input variables for the extra predicates only with the input variables for the head of the clause or with an output variable from another predicate. 
1. type of variables - only unify variables of the same type. 
1. incompatible predicates - a predicate exclusive  p red l pred1  type  is used to indicate if two predicates can only be used together under certain restrictions. for example    and  cannot be used in the same clause if they have the same arguments in the same order. another situation we would like to avoid would be having both x   y and y   x in the same clause. for binary predicates this can be accomplished by having a predicate opposite predl pred1   which will tell if the two predicates produce the same results if the arguments are 
	kirschenbaum and sterling 	1 

switched. a third category checks for symmetry. we do not want to produce one clause having y and another clause which is identical except it contains y  x. 
1. last recursive call - every recursive skeletal clause has the recursive predicate as the last goal. 
   this information is used both in the creation of the clauses and for pruning the redundant clauses. in the sense that this is knowledge about the program  it could be called meta knowledge. related terms in machine learning are background knowledge and preference criteria. the effect of the knowledge is to bias what programs are learned. the skeleton creation phase can be thought of as a description language to determine which concepts are describable. this use of a restricted hypothesis space is one kind of bias description found in  utgoff  1 . 
   the only technique we have implemented so far is collect. this technique adds one output variable to the sought after predicate. depending upon the other goals  the current head of the list is added or not to the output variable. this technique is similar to calculate mentioned earlier in that it adds an output variable  and depending upon the other goals in the clause  the value of the head of the list is combined with other values to be put into the output variable. an example of applying a collect technique to the skeleton search is to return the list remaining after the element has been found. in this case  the head of the input list is never added to the output list. this generates the program search with remainder xs ys . 

1 comparisons between m i s and m i s s t 
misst is given a fact for the target prolog program and creates all possible skeletons using the knowledge mentioned above. these in turn are given to an enhancement module to produce all possible extensions to those clauses. the component of mis which removes incorrect clauses when counterexamples are supplied is applied to the generated clauses to produce the final program. thus  the skeleton creation and the various techniques in the enhancement module determine the possible programs to be learned. 
   misst will synthesize programs having only lists and elements as variables and either has no output variables or the output variable is used for some type of collection. this last restriction can be overcome by including more techniques but it isn't clear at this point how slow the system will become as more techniques are added. some of the programs used for comparison include: prefix  1   suffix  1   append  1   sublist  1   member  1   nonmember  1   select  1   and subset  1 . the number in parenthesis after each of the above predicate names refers to the program number used in the a r t of prolog  sterling and shapiro  1 . we also used predicates union  difference  and intersection in our comparison. the code for union is 
1 	learning and knowledge acquisition 

the code for difference and intersection is similar to the code for union. in each case  the third argument exemplifies a collect technique. 
   unfortunately  since misst is based upon mis  it also cannot remove redundant clauses. the program learned for prefix given below demonstrates this unwanted behavior. 

   removing redundant clauses is  in general  too computationally expensive to be practically implemented. one possible way of avoiding redundant clauses is to take a correct set of hypothesized clauses and form a new set of clauses by selecting a base clause plus all the recursive clauses and check if the examples can be proven by this new set of clauses. if not  repeat the above with a different base case. of course  in general  a program might require two or more base cases and it is also possible that some of the recursive clauses will be redundant. 
   prefix  suffix  and append were easy for both systems to learn. not surprisingly  member  select and append were very easy for mis to learn since that refinement operator gives a high priority to expanding and unifying elements on a list. misst found member  select and append to be nontrivial programs to learn due to the large number of clauses created by the refinement operator. once these clauses have been generated  it is necessary to feed the system counterexamples to weed out the inappropriate clauses. subset was difficult for misst to learn without select being learned first because the first program produced for select in conjunction with the one produced for subset will have an infinite loop in it. misst will recognize the non-terminating condition but  due to the large default depth bound and the numerous clauses to be tested  this is a very slow process. union has the same problems if nonmember and member are not synthesized first. it took a lot of memory to complete the synthesis of union even when its called goals are synthesized first. the code generated for subset is 


select y xs xsl   subset xsl ys . 
subset x  y|ys   :-
subset x ys . 
   the expected prolog program is comprised of the second and fourth clause above. the reason why select was easy for mis to learn  caused mis to fail to learn both subset and union even when the eager search strategy was employed. memory ran out! the refinement operator used for mis gives priority to expanding the variables in contrast to adding goals to a clause. the variable  x|xs  will be expanded to  x y|zs  making it difficult to learn a program which calls numerous goals. both subset and union make use of the predicates member and nonmember. 
   a nice feature of misst can be seen in the synthesis of the program for union. if nonmember and member are previously known to the system  the user does not interact with the system from the time the initial declarations are made until the list of possible clauses are generated. the ability to free the user from system queries during the clause generation stage will generalize for any target program that has all of its called goals previously synthesized. 
   the weakness of misst is the volume of clauses produced. the removal of the duplicate clauses produced by misst  before they are asserted as hypothesized clauses  is the most expensive operation in the system. after the duplicate clauses have been removed it is still necessary to feed the system counterexamples to weed out the inappropriate clauses. however  judicious selection of counterexamples will limit the number required by the system. a possible solution to this problem is to modify misst to keep all the generated clauses in a list to be processed one at a time 
   due to the combinatorial explosion of clause generation  a restriction was made in misst to not allow an expanded variable  x|xs  to have both x and xs in the same goal in the body of the clause. this restriction made it impossible to synthesize a program to remove repeated elements in a list. if the above restriction is removed  union will explode with generated clauses. a possible solution to this is to have different search strategies similar to what is found in mis. 
1 	discussion 
we believe this work will have a greater impact upon learning when knowledge is introduced to direct the generation of skeletons. this is truly the bottleneck in misst. we may need to add knowledge in the form of a relationship between the number of elements in lists  or which list is to be recursed upon  or something else to minimize the number of possible skeletons being generated. if we think of skeleton creation as the 'getting started' process of learning  then misst's difficulty is that it is does not know how to get started. this is a typical problem for learning systems. 
   the knowledge required to determine which of all the possible skeletons are appropriate for a particular learning exercise is not currently captured in misst. one possible approach to reduce the complexity of clause generation without requiring too much from the user would be to ask the user to give the position of the argument s  to be recursed upon. for union  the number of clauses generated would be cut in half. 
   a promising source of insight for structuring skeleton creation is the work of  deviile  1 . the knowledge included in his concept of logic specification overlaps with the knowledge in misst described in section 1 and also contains extra information  for example multiplicity. deville's use of induction schemes in logic descriptions may also be relevant since modifying the logical description of a skeleton can be interpreted as a shifting to a weaker bias as described in  utgoff  1 . the required heuristic methods for deciding exactly how to modify the skeleton creation process needs to be determined. 
   work done by  muggleton and buntine  1  presents a framework for prolog induction which introduces new predicates into the language it is supplied. inverting resolution is the tool used to weaken the bias description. at this time  we do not know how usefull this will be for skeleton generation. 
a c k n o w l e d g m e n t s : we thank the prose discussion group for stimulating conversation. the work of 
leon s. sterling was supported in part by nsf grant ccr-1. 
