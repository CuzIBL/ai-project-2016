
integrating description logics  dl  and logic programming  lp  would produce a very powerful and useful formalism. however  dls and lp are based on quite different principles  so achieving a seamless integration is not trivial. in this paper  we introduce hybrid mknf knowledge bases that faithfully integrate dls with lp using the logic of minimal knowledge and negation as failure  mknf   lifschitz  1 . we also give reasoning algorithms and tight data complexity bounds for several interesting fragments of our logic.
1 introduction
integrating description logics  dls  and logic programming  lp  in a common framework would produce a very powerful formalism; for example  lp rules could be used to model constraints and exceptions over dl knowledge bases. adding a rule layer on top of the dl-based web ontology language  owl  is currently the central task in the development of the semantic web language stack  and the rule interchange format  rif  working group of the world wide web consortium  w1c  is currently working on standardizing such a language. however  dls and lp are based on fundamentally different assumptions: dls are fragments of first-order logic and employ open-world semantics  whereas lp provides negation-as-failure under closed-world semantics.
¡¡several approaches to integrating dls and lp were proposed recently.  rosati  1  proposes an approach that interprets the predicates from the dl knowledge base under open-world and the predicates occurring only in the lp rules under closed-world semantics.  eiter et al.  1  propose a loose coupling of dls and lp by extending the lp rules with special atoms interpreted as queries to a dl knowledge base.
¡¡in this paper  we introducehybrid mknf knowledge bases  which integrate an arbitrary description logic dl1 with disjunctive logic programs and negation-as-failure. this integration is faithful in the sense that it provides exactly the same consequences as dl and lp  respectively  if the other component is empty. unlike the existing approaches  our approach allows the user to freely switch between open- and closed-world views on arbitrary predicates from dl and lp. by means of an example  we argue that our logic produces intuitive and practically useful consequences.
¡¡we base our approach on the logic of minimal knowledge and negation as failure  mknf   developed by  lifschitz  1  to unify several major approaches to nonmonotonic reasoning. to obtain intuitive consequences for our hybrid logic  we modify certain technical aspects of mknf regarding the universe of discourse and equality.
¡¡function-free logic programs are usually decidable if the rules are safe  and many decidable dls exist. however  we show that these restrictions on dl and lp are not sufficient to obtain a decidable hybrid formalism  due to an interaction between dl and negation-as-failure. to obtain decidability  we apply the well-known notion of dl-safety  motik et al.  1   which makes the rules applicable only to individuals known by name. we present several reasoning algorithms for the cases of general  positive  i.e.  without negation-asfailure   nondisjunctiveand positive  nondisjunctiveand stratified  and nondisjunctive  but not necessarily stratified  dlsafe rules. finally  we present tight data complexity bounds for each case and show that combining dls with lp often does not increase the data complexity of lp.
¡¡our approach is related to several nonmonotonic extensions of dls.  donini et al.  1  propose an mknfbased extension of the dl alc  but without lp rules and with unique name assumption  una .  baader and hollunder  1  propose an extension of dls with dl-safe default rules  which are subsumed by our approach due to our treatment of equality and the well-known embedding of default logic into mknf  lifschitz  1 . finally   bonatti et al.  1  present an extension of dls with circumscription that allows for nonmonotonic reasoning on unnamed individuals  but only for unary predicates if decidability is desired.
¡¡we leave the detailed proofs to  motik and rosati  1  and present here only proof sketches.
1 preliminaries
description logics. our approach is applicable to any first-order fragment dl satisfying these conditions:  i  each knowledge base o ¡Ê dl can be translated into a formula ¦Ð o  of function-free first-order logic with equality   ii  it supports aboxes-assertions of the form p a1 ... an  for p a predicate and ai constants of dl  and  iii  satisfiability checking and instance checking  i.e.  checking entailments of the form o |= p a1 ... an   are decidable. we assume familiarity with the standard dl notation  baader et al.  1 .
mknf. the first-order version of mknf  lifschitz  1  can be understood as a variant of the first-order modal logic s1 with a preference relation on models that implements the nonmonotonic semantics. the syntax of mknf is obtained by extending first-order logic with modal operators k and not. a formula p t1 ... tn   where ti are terms  is a firstorder atom. for   an mknf formula  k  and not  are modal k- and not-atoms  respectively;   is ground if it does not contain variables;   is positive if it does not contain not; and   t/x  is the formula obtained from   by replacing all free occurrences of the variable x with the term t.
¡¡we assume that  apart from the constants used in mknf formulae  we have a countably infinite supply of constants not used in the formulae; with  we denote the herbrand universe of such a signature. also  we assume that the signature contains a special equality predicate ¡Ö that is interpreted as a congruence relation on . an mknf structure is a triple  i m n   where i is a herbrand first-order interpretation over   and m and n are nonempty sets of herbrand firstorder interpretations over . satisfiability of closed mknf formulae in an mknf structure  i m n  is defined as follows  for a a first-order atom:
 i m n  |= a	iff a is true in i
 	  |=  1  1 iff  	  =  1 and  	  |=  1
 i m n  |=  x :  	iff 
 i m n  |= k 	iff  j m n  |=   for all j ¡Ê m
 i m n  |= not 	iff 
¡¡the symbols true  false  ¡Å     and    material implication  are interpreted as usual. an mknf interpretation m is a nonempty set of first-order interpretations over . let   and ¦× be closed mknf formulae. an mknf interpretation m is an s1 model of    written m |=    if  i m m  |=   for each i ¡Ê m; m is an mknf model of   if  i  m is an s1model offor eachand some  so-called preference semantics of mknf ; finally    entails ¦×  written   |=mknf ¦×  if  i m m  |= ¦× for each mknf model m of   and i ¡Ê m.
1 hybrid mknf knowledge bases
definition 1. let o be a dl knowledge base. a first-order function-free atom p t1 ... tn  such that p is ¡Ö or it occurs in o is called a dl-atom; all other atoms are called non-dlatoms. an mknf rule r has the following form  where hi  bi+  and bi  are first-order function-free atoms:
kh1 ¡Å ... ¡Å khn ¡û
 1 
k
the sets {khi}  {kbi+}  and {notbi } are called the rule head  the positive body  and the negative body  respectively.
a rule r is nondisjunctive if n = 1; r is positive if k = 1; r is a fact if m = k = 1; r is safe if all variables in r occur in a positive body atom. a program p is a finite set of mknf rules. a hybrid mknf knowledge base k is a pair  o p .
¡¡we define the semantics of k by translating it into a firstorder mknf formula as follows:
definition 1. let k =  o p  be a hybrid mknf knowledge base. we extend ¦Ð to r  p  and k as follows  where x is the vector of the free variables of r:
¦Ð r  =  x :  kh1 ¡Å ... ¡Å khn  
         kb1+ ¡Ä ... ¡Ä kbm+ ¡Ä notb1  ¡Ä ... ¡Ä notbk   ¦Ð p  = vr¡Êp ¦Ð r  ¦Ð k  = k¦Ð o  ¡Ä ¦Ð p 
¡¡k is satisfiable if and only if an mknf model of ¦Ð k  exists  and k entails a closed mknf formula ¦×  written k |= ¦×  if and only if ¦Ð k  |=mknf ¦×.
¡¡mknf as defined by  lifschitz  1  considers arbitrary models  whereas we consideronly herbrand models  see section 1 . we introduce this restriction to obtain an intuitive logic that is compatible with both dls and lp. namely  under the semantics by lifschitz  kmknf  x : ka x   since ka a  does not fix the interpretation of a in . to remedy that  we interpret all constants by themselves  which is standard in data management applications  donini et al.  1; reiter  1 . in order to ensure that our model is large enough  we assume a countably infinite supply of constants. hence  we consider only infinite models of o in which different constants are interpreted as different objects.
¡¡an equality-free first-order formula is satisfiable in an arbitrary model iff it is satisfiable in a herbrand model with an infinite supply of constants not occurring in the formula  fitting  1  theorem 1.1 . hence  without equality we cannot distinguish arbitrary from herbrand models. for compatibility with dls  we need ¡Ö  which we clearly cannot interpret as identity  so we interpret it as a congruence. now a first-order formula with equality is satisfiable in a model with  true equality  iff it is satisfiable in a model where ¡Ö is an ordinary predicate interpreted as a congruence  fitting  1  theorem 1.1 . hence  our approach is fully compatible with dls: if p =    then k |=   iff o |=   for any first-order formula  . similarly  our logic is fully compatible with lp: for a ground atom ¦Á  if o =    then k |= k¦Á iff p entails ¦Á under stable model semantics  lifschitz  1 .
¡¡we believe that our treatment of equality matches the common intuition behind negation-as-failure. in the version of mknf by  lifschitz  1     = ka a  ¡Ä  nota b  has a model with a singleton universe in which a and b are the same  so   entails a ¡Ö b. we consider this quite unintuitive: we did not say that a and b are the same  so we expect them to be different. because of these problems  the semantics of lp is commonly based on herbrand models. we follow this practice  so in our approach   is mknf unsatisfiable  and it can be made satisfiable by explicitly stating a ¡Ö b.
¡¡in  motik and rosati  1  we allow the rules to contain both modal and nonmodal atoms  in order to generalize known extensions of dls with rules such as swrl or dl+log  rosati  1 . however  we also show that general rules can be converted into rules with only modal atoms.
furthermore mixing modal and nonmodalatoms produces an unintuitive semantics  so it is good practice to use either fully nonmodal or fully modal rules.
dl-safety. making the rules safe usually suffices to make function-free lp decidable; however  we show next that this does not hold for mknf rules. note that mknf rules contain modal atoms  so existing undecidability results for first-order combinations of dls with rules are not directly applicable.
theorem 1. for k a safe hybrid mknf knowledge base and a a ground atom  checking whether k |= a is undecidable if dl allows us to express an axiom.
¡¡namely  makes c equivalent to the infinite set   so all elements from  can be accessed in the rules even if the rules are safe. in other words  safety is now not a sufficient condition for domain independence. to ensure decidability  we apply the well-known dl-safety restriction  which makes the rules applicable only to individuals known by name in the abox; for an in-depth discussion  see  motik et al.  1 .
definition 1. an mknf rule r is dl-safe if every variable in r occurs in at least one non-dl-atom kb in the body of r. a hybrid mknf knowledge base k is dl-safe if all its rules are dl-safe.
¡¡note that dl-atomsare interpreted in the same way as nondl-atoms; dl-safety merely provides a syntactic restriction ensuring decidability. for a hybrid mknf knowledge base k =  o p   let pg be obtained from p by replacing in each rule all variables with all constants from k in all possible ways; the knowledge base kg =  o pg  is called a ground instantiation of k.
lemma 1. for k a dl-safe hybrid mknf knowledge base  kg the ground instantiation of k  and ¦× a ground mknf formula. then  k |= ¦× iff kg |= ¦×.
1 example
consider determining the car insurance premium based on various information about the driver. by convention  dlpredicates start with an uppercase and non-dl-predicates with a lowercase letter. let k be the following hybrid mknf knowledge base  the predicate p means  person  :
 1  notmarried ¡Ô  married
 1  notmarried  highrisk
 1   spouse.  married
 1  knotmarried x  ¡û kp x  notmarried x   1  kdiscount x  ¡û kspouse x y  kp x  k p y 
¡¡let us now assert p john . under first-order semantics  some models contain married john  and others contain notmarried john . however   1  applies the closedworld assumption to married: by default  people are assumed not to be married. since married john  does not hold in all models of o  the rule  1   fires  and it derives notmarried john ; with  1   this implies highrisk john .
¡¡the preference semantics of mknf is strongly related to the notion of the gelfond-lifschitz reduct used to define stable models.	let m1 and m1 be mknf interpretations consisting of first-order interpretations i such that i |= married john  and i |= notmarried john   respectively  and let m1 = m1 ¡È m1. clearly  we have m1   m1  m1 |= kmarried john  kmarried john ; intuitively  m1 contains  more knowledge  than m1. the preference semantics of mknf gives the following semantics to not: an mknf model m of an mknf formula   is the minimal knowledge justified by the values of not-atoms. in our example  assuming that notmarried john  is true implies other consequences  such as knotmarried john ; now each such consequence is justified in the sense that it belongs to the minimal knowledge entailed by the knowledge base k in which each not-atom is replaced with its value.
¡¡to understand how open- and closed-world reasoning interact in our formalism  let us assert  spouse. and p bill . now bill can be married to different people in different models; however   1  ensures that married bill  holds in all models. the precondition of  1  is thus not satisfied  so we derive neither notmarried bill  nor highrisk bill . in a way  reasoning in o is performed under open-world semantics  but the modal operators allow us to put on  closed-world glasses  and consider the consequences in all models.
¡¡finally  let us assert spouse bob ann   p bob   and p ann . by  1  we can now derive discount bob ; in contrast  we cannot derive discount bill . namely  the rule  1  differs from the first-order implication  1  in that it requires spouse x y  to be known-that is  it must hold in all firstorder models. the spouse of bill is different in different models  so spouse bill y  for any value of y  and the rule  1  would not  fire  even if it were not dl-safe.
¡¡this examplecannot be expressed in existing combinations of dls and lp: the rules of  eiter et al.  1  cannot derive new dl facts  and  in the approach by  rosati  1   the dl predicates are interpreted under open-world semantics and thus cannot occur under not.
1 reasoning algorithms
given a nonground hybrid mknf knowledge base k  all our algorithms first compute the ground knowledge base kg to obtain an mknf theory without modal operators under quantifiers. for a program with variables  this step is exponential. however  even for nondisjunctive datalog the combined complexity is higher than data complexity by an exponential factor  dantsin et al.  1   so this is to be expected of our logic as well. therefore  for an mknf knowledge base k =  o p   we just consider the data complexity  which is measured in the size of the facts in p and the size of the abox of o. we denote the data complexity of reasoning in dl with c  and set e = np if e   np and e = c otherwise.
¡¡for simplicity  we write k  o  and p instead of ¦Ð k   ¦Ð o   and ¦Ð p . the mknf models of kg are clearly infinite  so we must devise a convenient finite representation for them. we adopt an approach already used by  rosati  1 : we represent an mknf model m using a first-order formula   such that m = {i | i |=  }. we formalize this as follows:
definition 1. let k =  o p  be a hybrid mknf knowledge base. the set of k-atoms of k  written ka k   is the smallest set that contains  i  all k-atoms of pg  and  ii  a modal atom k¦Î for each modal atom not¦Î occurring in pg.
¡¡for a subset p of ka k   the objective knowledge of p is the formula ob. a partition  p n  of
ka k  is consistent if ob.
¡¡let   be an mknf formula and  p n  a partition of ka k . the formula   k p n  is obtained from   by replacing each k¦Î with true if k¦Î ¡Ê p and with false otherwise;   not p n  is obtained from   by replacing each not¦Î with false otherwise; finally       =  k   not  .
¡¡for a set of modal atoms is the subset of dl-atoms of s  s = {¦Î | k¦Î ¡Ê s}  and.
¡¡an mknf model is strongly related to a particular partition of ka k :
definition 1. an mknf interpretation m induces the partition  p n  of ka k  if k¦Î ¡Ê p implies m |= k¦Î and
k¦Î ¡Ê n implies.
¡¡the following key lemma shows that each mknf model m of kg can be represented as a partition of ka k :
lemma 1. let m be an mknf model of kg and  p n  a partition of ka k  induced by m. then  m is equal to the set of interpretations.
¡¡hence  to find an mknf model of kg  we need to find a partition  p n  of ka k . we can do it in different ways for different types of rules.
the general case. as for disjunctive datalog  in the general case we must guess a partition  p n  of ka k . this is captured by algorithm 1.
theorem 1. let k be a dl-safe hybrid mknf knowledge base and ¦× =    ka for a a ground atom. then  not-entails-dl k ¦×  returns true iff  and it runs with data complexity ee.
proof sketch.     if not-entails-dl k ¦×  returns true  a partition  p n  of ka k  satisfying all conditions of algorithm 1 exists. we show that m = {i | i |= obk p} is an mknf model of kg. by condition  1    p n  is consistent on all dl-atoms and  by condition  1   it is consistent on all non-dl-atoms  for a non-dl-predicate q  obk p |= q a1 ... an  can hold only if and obk p |= ai ¡Ö bi for all i . by condition  1   . by condition  1    i m m  |= pg p n  for each i ¡Ê m; furthermore  the values of all k-atoms in m are determined by  p n   so  i m m  |= pg. clearly   i m m  |= o  so  i m m  |= kg. assume now that m is not an mknf model-that is  an mknf interpretation m exists such that and  for each . then 
m induces the partition  of ka k .	because  implies m |= k¦Î  we have  so we can represent  a partition of p with. by lemma 1 .
because is satisfiable  so condition  b  is invalidated;  for each  which invalidates condition  a ; finally   is clearly consistent  which invalidates conditions  c  and  d . hence  condition  1  could not hold for   which algorithm 1 entailment in general hybrid mknf kbs

algorithm: not-entails-dl k ¦×  input:
¡¡k =  o p : a dl-safe hybrid mknf knowledge base ¦× : a ground formula    ka output: true if; false otherwise
let kg be the ground instantiation of k if a partition  p n  of ka kg  ¡È {ka} exists such that
1. pg p n  evaluates to true  and
1. o ¡È pbdl is satisfiable  and
1. for each k¦Î ¡Ê ndl  and
1. for each q a1 ... an  ¡Ê nb and q b1 ... bn  ¡Ê pb  we have b for some 1 ¡Ü i ¡Ü n
1. for ¦Ã = pg not p n  and each partition such that  evaluates to false  or
is unsatisfiable  or
for some k  or
 d  for some  we havefor all 1 ¡Ü i ¡Ü n
1. one of the following conditions holds:

 ii  ¦× =  ka and ka ¡Ê p
then return true; otherwise return false

is a contradiction; hence  m is an mknf model of kg. finally  condition  1  ensures. the     direction is analogous.
¡¡kg can be computed in polynomial time if the size of the nonground rules in p is bounded. a partition  p n  can be guessed and condition  1  can be checked in time polynomial in the size of kg. checking conditions  1 - 1  and  1  requires a polynomial number of calls to an oracle running in c  so all these steps can be performed in e. disproving condition  1  requires guessing a partition  and a polynomial number of calls to an oracle running in c  so it can be performed in e. hence  validating condition  1  can be performed in coe  and the algorithm runs in ee. 
positive programs. for k a positive hybrid mknf knowledge base  k |= ka iff m |= ka for each s1-model m of k: for each such m  since k is positive  an mknf model m of k exists such that .  this is analogous to the case of positive disjunctive datalog.  in other words  for positive queries  we do not need to ensure the preference semantics of mknf. let not-entails-dl+ k ka  be an algorithm that is the same as algorithm 1  only without condition  1 . by adapting the proof of theorem 1  we get the following:
theorem 1. let k =  o p  be a positive dl-safe hybrid mknf knowledge base and a a ground atom. then  not-entails-dl+ k ka  returns true iff  and it runs with data complexity e.
positive nondisjunctive programs. if k is nondisjunctive and positive  we can construct  p n  deterministically in a bottom-up fashion. we can easily show that m1 |= k and m1 |= k implies m1 ¡È m1 |= k for all mknf interpretations m1 and m1  which immediately implies the following:
theorem 1. each positive dl-safe nondisjunctive hybrid mknf knowledge base k has at most one mknf model.
definition 1. for k a positive nondisjunctive dl-safe hybrid mknf knowledge base  rk  dk  and tk are the operators defined on the subsets of ka k  as follows:
rk s  = s ¡È {kh | kg contains a rule of the form  1  such that kbi ¡Ê s for each 1 ¡Ü i ¡Ü n}
dk s  = {k¦Î | k¦Î ¡Ê ka k  and o ¡È sbdl |= ¦Î}¡È
{kq b1 ... bn  | kq a1 ... an  ¡Ê s   sdl and o ¡È sbdl |= si ¡Ö bi for 1 ¡Ü i ¡Ü n}
tk s  = rk s  ¡È dk s 
the operator tk is monotonic on the lattice of subsets of
kaimplies . namely  rk is monotonic similarly as this is the case for datalog  and dk is monotonic because first-order logic is monotonic. hence  by knaster-tarski's theorem  tk has the least fixpoint  which we denote with. it is now easy to show the following:
theorem 1. let k be a positive nondisjunctive dl-safe hybrid mknf knowledge base and m = {i | i |= obk tk¦Ø}. then   i  if   then m is the single mknf model of k;  ii  if k has an mknf model  this model is equal to m; and  iii  the data complexity of computing tk¦Ø is in pc.
proof sketch.  i  clearly  m |= ko and  since tk¦Ø is a fixpoint of tk  m |= pg. if m were not an mknf model  an mknf interpretationsuch that for eachwould exist and it would induce a partition  of ka k  such that. clearly 
 otherwise  eitherfor some is not consistent   but then tk¦Ø is not the minimal fixpoint of tk.
the proof for  ii  is analogous.  iii  as for ordinary datalog  rk s  can be computed in polynomial time. the number of atoms in ka k  is linear in the size of pg  so computing dk s  requires a polynomial number of calls to an oracle running in c. finally  the number of iterations is bounded by the size of ka k   which implies the claim. 
for entailment checking  k |= ka iff obk tk¦Ø |= a  and
k |=  ka iff ob.
stratified programs. we first define a notion of stratification appropriate to mknf programs.
definition 1. let k =  o p  be a nondisjunctive hybrid mknf knowledge base and ¦Ë : pg ¡ú n+ a function assigning to each r ¡Ê pg a positive integer ¦Ë r . for an integer
  let head be the set of head atoms of those rules r ¡Ê pg for whichis a stratification of k if these conditions hold for each r ¡Ê pg:
  for each body atom k¦Î of r  each p   head k ¡Ü¦Ë r  such that ob  and eachhead k  ¦Ë r   either ob is unsatisfiable;
  for each body atom not¦Î of r  each p   head k  ¦Ë r  such that ob  and each head k ¡Ý¦Ë r   either ob is unsatisfiable.
¡¡k is stratified if a stratification ¦Ë of k exists. a stratification ¦Ë partitions p into strata ¦Òi = {r | ¦Ë r  = i}; the sequence of strata ¦Ò1 ... ¦Òn is often identified with ¦Ë and is also called a stratification.
¡¡stratification ensures that deriving an atom k¦Î in a stratum ¦Òi does not change the values of the k- and notatoms from strata   i and ¡Ü i  respectively. for example  consider a knowledge base k where dl is propositional logic  o =  r ¡Ô p ¡Å q  ¡Ä  s ¡Ô  q   and p contains the rules kr ¡û notp and ks ¡û kr. in ordinary datalog  p would be stratified: by evaluating the first rule we derive kr  after which we evaluate the second rule and derive ks. but now the objective knowledge is r ¡Ä s ¡Ä o and it implies  q  which invalidates the atom kp in the body of the first rule. intuitively  definition 1 ensures that such an interaction between o and the derived facts does not happen. clearly  checking stratification is difficult in general. however  if o employs una and no rule in p contains a dl-atom in the head  then stratification of p can be checked as usual. this case is interesting because it allows to define complex constraints over dl knowledge bases. we now show how to compute models of a stratified program:
definition 1. let ¦Ò1 ... ¦Òk be a stratification of a dlsafe mknf knowledge base k. the sequence of subsets
u1 ... uk of ka ¦Ò  is inductively defined as u1 =   and   whereis ob-
tained from ¦Òi by replacing each not¦Î with true if and with false otherwise. finally  let uk¦Ø = uk.
¡¡the following theorem is analogous to the case of ordinary stratified datalog:
theorem 1. let k be a stratified dl-safe mknf knowledge base k  and m = {i | i |= obk uk¦Ø}. regardless of the stratification used to compute uk¦Ø  the following claims hold:
 i  if  then m is an mknf model of k;  ii  if k has an mknf model  then this model is equal to m; and  iii  the data complexity of computing.
nondisjunctive nonstratified programs. we now take k to be a nondisjunctive and nonstratified knowledge base. then  the knowledge base ¦Ã = pg not p n  from algorithm 1 is nondisjunctive and positive  so we can use theorem 1 to ensure the preference semantics of mknf. we define nondisjunctive-not-entails-dl ¦Ò ¦×  to be the same as algorithm 1  but replace condition  1  with t¦Ã¦Ø = p.
theorem 1. for a nondisjunctive nonstratified hybrid mknf knowledge base k and ¦× =    ka with a a ground atom  the algorithm nondisjunctive-not-entails-dl k ¦×  returns true iff  and it runs with data complexity epc.
1 data complexity
we now determine the data complexity-the complexity measured in the sizes of the abox of o and the facts of p- of checking entailment for a hybrid mknf knowledge base table 1: data complexity of entailment checking
¡Ånotdl =  dl ¡Ê pdl ¡Ê conp1nonoppconp1nostrat.pp1noyesconpconp1yesnoconp/conp/conp/1yesyesk. to obtain a precise characterization  we must make assumptions about the data complexity of checking entailment of ground literals in dl. in  hustadt et al.  1   it was shown that checking entailment of ground atoms in many very expressive dls  such as shiq  is data complete for conp. furthermore  there are expressive fragments  such as horn-shiq  hustadt et al.  1  or dl-lite  calvanese et al.  1   for which data complexity of entailment is in p. therefore  we analyze the complexity of mknf knowledge bases for these two cases  and contrast them with the wellknown results for logic programs without a dl knowledge base. table 1 summarizes the results for complexityof checking k |= ¦×  for ¦× =    ka with a a ground atom. all results are completeness results.
¡¡existing results for the corresponding variants of datalog  dantsin et al.  1 providehardnessresults for all cases but for rows 1 and 1 with dl ¡Ê conp. for these cases  we give hardness proofs in  motik and rosati  1 . in the first case  we present a reduction from dags sat   gottlob  1   and in the second one from 1-qbf.
¡¡the membership results are given by the algorithms from section 1. note that  for rows 1 and 1 and ¦× =  ka  since k has at most one model  k |=  ka iff either k is unsatisfiable of  so answering negative queries can be reduced to answering positive ones. furthermore  in row 1 the complexity differs depending on whether we ask a positive or a negative query: in the first case  we can use theorem 1  whereas in the second case we must use theorem 1.
1 conclusion
based on the logic mknf by  lifschitz  1   we have developed the formalism of hybridmknf knowledgebases that provides for a faithful integration of an arbitrary description logic with logic programming. our approach seamlessly integrates open- and closed-world reasoning  without requiring an a priori commitment to either paradigm. it is fully compatible with the first-order semantics of dls and logic programming under stable model semantics. we have developed reasoning algorithms and identified tight complexity bounds for interesting fragments of our formalism. in future  we shall try to extend our approach to well-founded semantics  as this might provide better complexity in some practical cases. furthermore  we shall implement our approach in the ontology management system kaon1
