
we present a method for applying local search to overconstrained instances of the disjunctive temporal problem  dtp . our objective is to generate high quality solutions  i.e.  solutions that violate few constraints  in as little time as possible. the technique presented here differs markedly from previous work on dtps  as it operates within the total assignment space of the underlying csp rather than the partial assignment space of the related meta-csp. we provide experimental results demonstrating that the use of local search leads to substantially improved performance over systematic methods.
1 introduction
previous work on temporal reasoning has focused primarily on exact and complete methods for efficiently solving temporal problems  e.g.   stergiou and koubarakis  1; tsamardinos and pollack  1; armando et al.  1  . the purpose of these algorithms is to find a solution that satisfies a set of constraints  or else prove  by means of exhaustive search  that no solution exists. recently  there has also been work on temporal formalisms where the goal is instead to optimize an objective function; for instance  to maximize a user's preference when the problem permits many solutions  khatib et al.  1; peintner and pollack  1; morris et al.  1   or to minimize the number of violated constraints when no complete solution exists  moffitt and pollack  1 . although these algorithms are guaranteed to find optimal solutions  they are computationally expensive  and hence may not be applicable to large problems. given this  it may be advantageous to instead search for approximate solutions when strict optimality is not required.
¡¡local search algorithms are known to be among the most effective methods for solving computationally intractable problems such as propositional satisfiability  scheduling  and constraint satisfaction  hoos and stutzle  1 . while they do not guarantee optimality  they are often able to produce high-quality solutions within a short amount of time. despite the significant attention that local search has received in combinatorial optimization  its application to problems of quantitative temporal reasoning has as yet been largely overlooked.
¡¡in this paper  we show how local search can be successfully applied to overconstrained instances of the disjunctive temporal problem  dtp   stergiou and koubarakis  1   a particularly expressive form of temporal constraint satisfaction problem. while local search has been commonly applied to finite-domain csps  its application to dtps is of particular interest  as the domains of the temporal variables are infinite  ranging over the entire set of either integers or real numbers. previous work on dtp-solving has focused on a reformulation of the problem  in which a meta-csp is constructed and searched. in contrast  we apply local search directly to the original csp  i.e.  the dtp itself. we discuss issues such as solution initialization  neighbor generation  and cost computation  and provide experimental results demonstrating that the use of local search in solving overconstrained dtps can lead to substantially improved performance as compared to systematic methods.
¡¡it should be noted that ours is not the first attempt to apply local search to temporal reasoning. this work is closely related to  beaumont et al.  1 ; however  that line of research deals with a qualitative interval algebra representation  which is strictly less expressive than that allowed by dtps. nonetheless  their endpoint-ordering technique bears similarity to our approach  in that it also abandons the meta-csp for the original csp search space. our work is also related to  walser  1   where local search is applied to overconstrained integer programs without disjunctions.
1 disjunctive temporal problems
a disjunctive temporal problem  dtp  is a constraint satisfaction problem defined by a pair  where each element xi ¡Ê x designates a time point  and c is a set of constraints of the following form:
ci1¡Å ci1 ¡Å ... ¡Å cin
where in turn  each cij is of the form x   y ¡Ü b; x y ¡Ê x and .  in practice  b is often restricted to the integers.  dtps are thus a generalization of simple temporal problems  stps   in which each constraint is limited to a single inequality  dechter et al.  1 . a solution to a dtp is an assignment of values to time points such that all constraints are satisfied.
¡¡several algorithms have been developed for solving dtps  stergiou and koubarakis  1; armando et al.  1; oddi and cesta  1; tsamardinos and pollack  1 . typically  these algorithms transform the problem into a metacsp  in which the original dtp is viewed as a collection of alternative stps. using this approach  the algorithm selects a single disjunct from each constraint of a given dtp. the resulting set forms an stp  called a component stp  which can then be checked for consistency in polynomial time using a shortest-path algorithm. clearly  a dtp d is consistent if and only if it contains at least one consistent component stp. furthermore  any solution to a consistent component stp of d is also a solution to d itself. consequently  it is standard in the dtp literature to consider any consistent component stp to be a solution of the dtp of which it belongs.
¡¡a number of pruning techniques can be used to focus the search for a consistent component stp of a dtp  including conflict-directed backjumping  removal of subsumed variables  and semantic branching. the dtp solver epilitis  tsamardinos and pollack  1  integrated all these techniques  in addition to no-good recording. at the time it was developed  epilitis was the fastest existing dtp solver  though it was recently surpassed by tsat++  armando et al.  1 .
¡¡dtp solvers such as epilitis perform total constraint satisfaction - that is  their objective is to find a solution that satisfies all the constraints of a dtp. in the event that a dtp is inconsistent  these solvers are capable of detecting such infeasibility  but are incapable of providing partial solutions that come close to satisfying the problem. in response  the dtp solver maxilitis  moffitt and pollack  1  was designed to find solutions that maximize the number of satisfied constraints. partial constraint satisfaction has the disadvantage of being expensive  as the pruning techniques typically used in dtp solving become weaker when relaxations are allowed. if the overconstrained dtp is very large  the systematic search that maxilitis performs becomes intractable  and one must instead settle for an approximate solution. fortunately  maxilitis is an anytime algorithm  and one can interrupt it at any point to extract a  possibly suboptimal  partial assignment. it is not  however  obvious that a systematic search is the fastest way to find an approximate solution.
1 local search
when exact  systematic methods for solving hard combinatorial problems are too expensive  local search offers an alternative approach for quickly generating approximate solutions. applications of local search are numerous  and include planning  ambite and knoblock  1   scheduling  storer et al.  1   and constraint satisfaction  minton et al.  1 .
¡¡the satisfiability problem  sat  is a classic domain for application of local search. the objective of sat is to find an assignment to a set of binary variables that satisfies a boolean formula f  typically given in conjunctive normal form  cnf . a common variation on sat is max-sat  where the objective is to maximize the number of satisfied
clauses in f. a number of local search algorithms have been constructed for both sat and max-sat. one of the most successful variants is gsat  selman et al.  1 . in this algorithm  one begins with a random assignment of truth values to the propositional variables  and then repeatedly chooses a
variable to flip that results in the maximal decrease in violated clauses  breaking ties randomly. to avoid getting stuck in local minima  a technique called random restarts is often used  where the algorithm begins anew with another random assignment. several variants exist for gsat; of these  gsat/tabu  mazure et al.  1  is among those with best performance. it maintains a tabu list of recently flipped variables  which are then temporarily prohibited from being selected for another flip.
¡¡the basic method used in gsat and gsat/tabu can be applied to other problems besides sat. indeed  the structure of a dtp closely resembles that of a sat problem  and it is for this reason that a sat solving approach has been applied to the problem of finding complete solutions to dtps  as in tsat  armando et al.  1  and tsat++  armando et al. 
1  .
1 application to dtps
in applying local search to possibly overconstrained dtps  we again need to decide whether to work in the meta-csp or in the original csp  the dtp . to illustrate these candidates  consider the following very small problem:

clearly there is no complete solution to this problem  since c1 conflicts with c1  and c1 conflicts with the constraint induced by the transitive composition of c1 and c1. as a result  our objective will be to find a solution that maximizes the number of constraints satisfied in the dtp. we define the cost of a solution to be the number of constraint violations it induces; thus  low-cost solutions are better.1
partial assignment space of the meta-csp
one way to view a solution to overconstrained dtps such as the example above is as a partial assignment to the meta-csp  in which some of the meta-level variables are left unassigned.
for example  consider the assignment  c1 c1 c1 c1  ¡û
  in which the constraints c1 and c1 are not given an assignment  indicated by  . here the  partial  component stp that is selected consists of c1 and c1  and has a cost of 1. this particular partial assignment cannot be extended to any solution of lower cost  since inclusion of either of the disjuncts c1 or c1 would result in an inconsistency. however  this does not mean that a solution of higher quality does not exist. indeed  the partial assignment with cost 1 is both consistent and optimal.
¡¡while search in the partial assignment space of the metacsp is common to most systematic methods for solving dtps  it is less attractive for the application of local search. first  systematic methods work within a backtracking tree  where disjuncts are removed in the order in which they were added.1 one technique that is commonly used in dtp solving  incremental full-path consistency  mohr and henderson  1   exploits this property by maintaining a stack of the temporal network updates made during search  using it to cheaply repair path dependencies when backtracking. local search requires the ability to modify arbitrary values in the partial assignment  not necessarily respecting the order in which they were originally assigned; thus it cannot exploit the incremental approach. second  several of the powerful pruning techniques used by dtp solvers such as epilitis and maxilitis have no meaning outside the context of a systematic search tree. for example  semantic branching is able to acquire additional network constraints by exhaustively exploring particular assignments of disjuncts to constraints. in local search  no such exhaustive search is performed  and consequently it is hard to imagine how to adapt this mechanism. finally  in local search  the number of neighbors for a partial assignment will typically be much larger than the number of successors in systematic search  thus making evaluation of alternatives prohibitively expensive.
total assignment space of the original csp an alternative approach is to perform search in the space of total assignments to the time points in the original csp. for the example dtp above  one possible assignment is  a b c  ¡û  1 1 . since this solution violates constraints c1 and c1 it has a cost of 1. a better solution would be  1 1   which violates only constraint c1.
¡¡a key issue for this search space is how to define the neighbors of an assignment. one approach is to include all solutions whose variable assignments differ in exactly one position; for example   a b c  ¡û  1 1  would be a neighbor of  a b c  ¡û  1 1   since the two differ only on the assignment to b. however  because the value of each variable may take any real  or any integer   the cardinality of the set of possible neighbors is uncountably  or countably  infinite. it is for this reason that most of the prior work on dtps has avoided search in this space: the infinite cardinality of the variables' domains precludes the use of methods for exhaustive search. we address this concern in the next section  where we describe our local search algorithm in detail.
1 localitis
in this section  we present localitis  our algorithm for using local search to perform partial constraint satisfaction in a dtp. its basic framework derives from the gsat/tabu algorithm that is commonly used for sat and max-sat instances. it also bears considerable resemblance to walksat oip   used in  walser  1  to solve overconstrained integer programs without disjunctions1.
1 generating the initial solution
typically in algorithms such as gsat  the initial solution is chosen by selecting random assignments for each of the boolean variables. a similar initialization can be done with dtps: each time point can be randomly assigned a value within some interval  l u . if one employs random restarts  this initialization can be done several times to ensure adequate exploration of the search space.
¡¡a potentially better alternative is to make a greedy assignment to the time points  so that the algorithm begins with a reasonable solution. we adopt this approach in localitis. to generate the initial solution  we make use of the maxilitis solver. recall that maxilitis searches in the meta-csp space. we invoke it and let it run until it generates its first solution  in which every constraint is assigned either a disjunct or . since this solution is not necessarily optimal  maxilitis would normally continue  but we instead terminate it  and project an assignment to time points from the component stp it has computed  making random assignments to all time points outside the scope of the component stp. because of the variable and value ordering heuristics used by maxilitis  the first solution it encounters is likely to be better than what a purely random assignment would provide. one could repeat this process for random restarts  placing bias on the selection of assignments so that the set of disjuncts chosen differs between runs.
1 the neighborhood
as described earlier  the most obvious way to define the neighbor s  of an assignment is as the set of assignments that differ in the value of only one time point  for example   a b c  ¡û  1 1  and  a b c  ¡û  1 1  . unfortunately  this definition results in each assignment having infinitely many neighbors. the key to reducing the size of the search space is to note that if we hold fixed the values of all the variables but one  b in the current example   then only a small set of new values for the selected variable are significant. specifically  we only need to consider those values for which the slack of a disjunct belonging to some constraint becomes zero - that is  when an inequality becomes a strict equality. this is somewhat similar to a pivot step in the simplex method for linear programming  which maintains a basic feasible solution that corresponds to an  active system  of constraints in the lp. for instance  in our running example  suppose we are given the assignment of  1 1 . then the significant values for b are 1  1  and 1  as they would make the disjuncts c1  c1  and c1 active  respectively. some of these values may satisfy several new disjuncts at once  for instance  if b is assigned the value 1  it satisfies disjuncts c1 and c1 simultaneously . no other values for b are capable of satisfying a set of constraints that one of the these significant values cannot.
¡¡we can impose yet another restriction on the set of neighbors; namely  that they include only those new  significant values that change the resulting set of satisfied constraints. for instance  while the assignment of 1 to b is significant in that it makes the slack for c1 zero  it does not change the set of satisfied constraints. as a result  this new assignment is not particularly interesting  and need not be considered in the set of neighbors of this assignment.
1 neighbor selection and tabu moves
since our objective is to satisfy the maximum number of constraints  selection of which neighbor to explore is a fairly straightforward process: choose the candidate that satisfies the maximum number of constraints possible. this is identical to gsat  where the variable chosen to flip is the one that will minimize the number of unsatisfied clauses. in the case that several assignments would result in the same minimal number of violations  one is selected at random.
¡¡when a local search process is required to continually make greedy moves  it can easily get stuck in local minima. to avoid this  we adopt a common variation on the technique of tabu search  glover and laguna  1   and forbid local search to change the values of variables that were recently modified. a parameter tt  called the tabu tenure  determines the duration  in search steps  for which this restriction applies. when tabus are applied to sat  no variable flipped at iteration number i is allowed to flip again until tt steps have passed. we introduce tabu moves into localitis in a similar way. if the value of a variable x is changed at step i  its value is then fixed until tt steps have passed. to efficiently determine the tabu status of each variable x  we maintain an array it  where itx stores the search step number when variable x was last changed. a variable is tabu if and only if i itx   tt.
1 efficient cost computation
the simplest way to compute the cost of a neighbor assignment is to temporarily enforce the assignment being considered  and subsequently test all constraints for satisfiability  counting the number that are not satisfied. however  this straightforward implementation has been shown to be rather inefficient  since many of the constraints will not be affected by the local modification  selman et al.  1 .
¡¡a common technique is to instead compute the relative change in cost by testing only those clauses that contain the variable in question. this can be facilitated by a preprocessing step which creates a list for each variable  containing indices for those constraints that it participates in.
1 the algorithm
figure 1 provides the pseudocode for localitis. the function maxilitis-first-path   is used to generate the initial assignment  line 1 . the algorithm then performs local search  generating the neighbors of the current assignment by looking at the non-tabu variables in each disjunct of the dtp  lines 1   and considering  moves   i.e.  assignments to significant values  line 1  that change the set of satisfied constraints  line 1 .  the notation x/y  where y is an assignment z ¡û z  denotes the substitution of y for the original assignment to z in x. the function sat   returns the set of constraints in the dtp that are satisfied by its argument.  the set moves stores the set of minimal-cost neighbors  lines 1   from which one is eventually selected at random  lines 1 . after storing the value of the best solution seen to date  lines 1  and updating tabu tenures  line 1   the process iterates.
1 experimental results
we implemented localitis and conducted a set of experiments whose primary goals were 1  to determine the influence of
localitis dtp d 
1. best-assign ¡û assign ¡û maxilitis-first-path d 
1. for it = 1 to max-steps
1. mincost ¡û¡Þ  moves ¡û
1. for each disjunct d: x y ¡Üb
1. if x not tabu
1. move ¡û  x¡ûy+b 
1. if sat assign  = sat assign/move 
1. if cost assign/move  = min cost
1. moves ¡û moves ¡È{move}
1. endif
1. if cost assign/move    min cost
1. moves ¡û{move}
1. mincost ¡û cost assign/move 
1. endif
1. endif
1. endif
1. repeat lines 1 - 1 for y  i.e.  y ¡ûx b 
1. endfor
1. new-move ¡û random-member moves 
1. assign ¡û assign/new-move
1. if cost assign    cost best-assign 
1. best-assign ¡û assign
1. endif
1. update tabu count for the time point in new-move
1. endfor
1. return best-assign
figure 1: localitis  a local search algorithm for dtps
the way in which the initial assignment is made  1  to analyze the effect of various neighborhood functions and tabu tenures  and 1  to compare the anytime quality of this solver against its cousin maxilitis  which performs an exhaustive search of the dtp in the meta-csp space. no random restarts were used for these tests. to benchmark our algorithm  we used dtps created by a random generator used in testing previous dtp solvers  stergiou and koubarakis  1 . the test case generator takes as arguments the parameters  where k is the number of disjuncts per constraint  n is the number of time points  m is the number of constraints  and l is the constraint width  i.e.  a positive integer such that for each disjunct x   y ¡Ü b  b ¡Ê   l l  with uniform probability. in our experiments  we set k = 1  n = 1  m = 1  and l = 1. a derived parameter r  the ratio of constraints over variables  m/n  expressing constraint density was thus 1. for this set of parameters  1 random problems were generated. the domains of the variables are integers instead of reals  which again is standard in dtp literature. our implementation of localitis was developed in java  and our experiments were conducted on a 1 ghz intel pentium 1 machine running windows xp and having 1 gb of memory.
¡¡in our first experiment  we tested 1 different values for the tabu tenure to measure its effect on solution quality as a function of time. in figure 1  we plot a curve for each tabu tenure in the set {1 1 1}. the number of seconds elapsed is shown on the x-axis  and the number of constraint violations in the solution  averaged over the 1 test cases  is shown on

figure 1: anytime curves for various tabu tenures
the y-axis. we also show the optimal solution cost  which expresses the average number of violations in the optimal solution  i.e.  what maxilitis reported when run until completion . convergence is slowest for when the tabu tenure is 1  this effectively corresponds to the absence of tabu search   and is also somewhat slow for when the tabu tenure is 1. for values 1  1  and 1  convergence is almost identical. larger values  not shown  displayed no improvement over these curves  and so a tabu tenure of 1 was used for all subsequent tests.
¡¡in our second experiment  we studied two different strategies for generating the initial set of temporal values: one using random assignments  uniformly chosen from the range   l l   and the other using maxilitis to greedily generate an initial solution  as described previously. the results are shown in figure 1  among other results that will be addressed momentarily . once again  the x- and y-axes represent the seconds elapsed and the solution cost  respectively. the curve labeled 'localitis  normal ' uses the greedy selection  and the curve labeled 'localitis  random initialization ' does not. the former begins with an average cost of 1 violated constraints  where the latter begins with a drastically higher average of 1 not shown on the graph. the randomly initialized search is able to make up the difference fairly quickly  although it continues to lag for the duration of the search. the shape of the curves are roughly identical  despite the horizontal displacement. thus  it appears that the greedy initialization does indeed improve the starting solution  although the effect on the convergence rate is negligible.
¡¡in our third experiment  we tested two different neighborhood criteria: the first includes all assignments of significant values  ones that force the slack of some disjunct to be zero   while the second also requires that there be some change in the set of satisfied constraints in the dtp. the results are shown in figure 1. the curve labeled 'localitis  normal ' uses the more restricted definition  and the curve labeled 'localitis  any 1-slack move ' does not. while the two begin at the same initial point  as they should  since both use greedy initialization   the 'localitis  normal ' curve is able to generate solutions of higher quality much earlier. for instance  after 1 seconds  'localitis  any 1-slack move ' has gener-

figure 1: anytime curves for maxilitis & localitis variations
ated an average solution cost of 1. only 1 seconds were required for 'localitis  normal ' to obtain this same average. as a result  it seems that one can expect significantly better results when the neighborhood is restricted to only those candidates which modify the partial assignment of the meta-csp.
¡¡finally  we compare the anytime quality of our localitis solver to that of the systematic solver maxilitis  which is  at present  the only other existing method for performing partial constraint satisfaction of dtps. the results are again shown in figure 1. the curves of interest are labeled 'localitis  normal ' and 'maxilitis.' by inspection  it seems that despite its numerous pruning techniques and sophisticated constraint propagation methods  maxilitis is far slower at producing high quality solutions. for instance  at the end of the 1 seconds shown  maxilitis has generated an average solution cost of about 1. for localitis to produce the same average cost requires only 1 seconds. to reach the average cost of 1 that localitis achieves after 1 seconds requires 1 seconds of maxilitis runtime. based on these observations  the speedup achieved appears to be roughly 1 to 1 times faster.
1 discussion and future work
in this paper  we have presented a method for applying local search to overconstrained instances of the disjunctive temporal problem. in contrast to previous algorithms for solving dtps  our technique abandons the meta-csp and instead explores the total assignment space of the underlying csp. our results show that the computation time required to generate high-quality solutions is significantly reduced in comparison to traditional branch-and-bound algorithms for performing partial constraint satisfaction.
¡¡given the freedom allowed by this alternative search space  one particularly interesting avenue of research would be to extend this approach toward more expressive cost functions. whereas this paper concentrates on minimizing the number of violated constraints  one could instead capture the amount by which the constraints are violated. this would give higher value to those solutions whose assignments come close to falling within the prescribed bounds.
¡¡another appealing possibility is to apply this same local search technique to underconstrained rather than overconstrained temporal formalisms. the recent addition of preferences to dtps  appropriately labeled dtps with preferences  dtpps   peintner and pollack  1   allows preference functions to be defined over particular values of the temporal differences. as no efficient optimal algorithm is yet known for maximizing the weighted sum of preferences in dtpps  greedy methods are currently being developed to generate approximate solutions. local search may indeed prove to be a competitive alternative to these algorithms.
acknowledgments
the authors thank neil yorke-smith  dushyant sharma  and bart peintner for their input into this work. this material is based upon work supported by the defense advanced research projects agency  darpa  under contract no. nbchd1 and the air force office of scientific research under contract no. fa1-1. any opinions  findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of darpa  the department of interior-national business center  or the united states air force.
references
 ambite and knoblock  1  jose luis ambite and craig a. knoblock. planning by rewriting: efficiently generating high-quality plans. in proceedings of the 1th national conference on artificial intelligence  aaai-1   pages 1  1.
 armando et al.  1  alessandro armando  claudio castellini  and enrico giunchiglia. sat-based procedures for temporal reasoning. in proceedings of the 1th european conference on planning  pages 1  1.
 armando et al.  1  alessandro armando  claudio castellini  enrico giunchiglia  and marco maratea. a sat-based decision procedure for the boolean combination of difference constraints. in proceedings of the 1th international conference on theory and applications of satisfiability testing  sat-1   1.
 beaumont et al.  1  matthew beaumont  john thornton  abdul sattar  and michael maher. solving overconstrained temporal reasoning problems using local search. in proceedings of the 1th pacific rim conference on artificial intelligence  pricai-1   1.
 dechter et al.  1  rina dechter  itay meiri  and judea pearl. temporal constraint networks. artificial intelligence  1-1 :1  1.
 glover and laguna  1  fred glover and manuel laguna. tabu search. kulwer academic publishers  boston  ma  usa  1.
 hoos and stutzle  1  holger hoos and thomas stutzle. stochastic local search: foundations and applications. kluwer academic publishers  1.
 khatib et al.  1  lina khatib  paul morris  robert morris  and k. brent venable. tractable pareto optimal optimization of temporal preferences. in proceedings of the 1th international joint conference on artificial intelligece  ijcai-1   pages 1  1.
 mazure et al.  1  bertrand mazure  lakhdar sais  and eric gregoire. twsat: a new local search algorithm for sat - performance and analysis. in proceedings of the 1th national conference on artificial intelligence  aaai1   pages 1  1.
 minton et al.  1  steven minton  mark d. johnston  andrew b. philips  and philip laird. minimizing conflicts: a heuristic repair method for constraint satisfaction and scheduling problems. artificial intelligence  1-1 :1- 1  1.
 moffitt and pollack  1  michael d. moffitt and martha e. pollack. partial constraint satisfaction of disjunctive temporal problems. in proceedings of the 1th international florida artificial intelligence research society conference  flairs-1   1.
 mohr and henderson  1  roger mohr and thomas c. henderson. arc-consistency and path-consistency revisited. artificial intelligence  1-1  1.
 morris et al.  1  paul morris  robert morris  lina khatib  sailesh ramakrishnan  and a. bachmann. strategies for global optimization of temporal preferences. in proceedings of the 1th international conference on principles and practices of constraint programming  pages 1  1.
 oddi and cesta  1  angelo oddi and amedeo cesta. incremental forward checking for the disjunctive temporal problem. in proceedings of the 1th european conference on artificial intelligence  pages 1  1.
 peintner and pollack  1  bart peintner and martha e. pollack. low-cost addition of p