 
hearsay-ill provides a framework for constructing knowledge-based expert systems. while hearsayill makes no commitment to any particular application domain  it does supply a variety of generally applicable facilities. these include representation primitives and an interpreter for large-grained  flexibly schedulable production rules called knowledge sources. a detailed overview of the motivations behind hearsay-ill and the facilities it provides are presented. finally  an application of hearsay-ill is described. 
1. introduction 
　hearsay-iii is a domain-independent framework for knowledgebased expert systems. that is. rather than addressing the problems in a specific application domain hearsay-iii provides a  bare  architecture in which to cast an expert problem solver for a 
　chosen domain. in this sense  it is similar in spirit to emycin  van melie 1  and age  nii 1   and other  expert-system-building systems . however. hearsay-iii differs substantially in the specific representation and control regimes it makes available to the expert-system builder. 
　although hearsay-ill is specifically not a speech-understanding system  and we know of no one who expects to use it for building a speech understanding system   it draws strongly on the architectures of the hearsay!  reddy 1  and hearsay-ii  erman 1  speech-understanding systems as was intended by the choice of its name  hearsay-iii can be viewed as an extension along some dimensions of the hearsay-ii architectural style  and 
as a generalization of it along others. the concepts of large 
grained  modular knowledge sources and system-wide communication via a structured global blackboard were attractive to us because they provide a major first step toward achieving our design goals for hearsay-iii. 
　this paper presents the motivations behind the design of hearsay-iii  a detailed overview of its architecture and facilities. and illustrations  via examples  of use of its features although we concentrate on the novel aspects of hearsay-iii. we do not attempt to classify each feature as being new or from hearsayll:  balzer 1a  presents an overview of hearsay-ml with such an orientation. 
　　this research was supported by defense advanced research projects agency contract dahc1 c 1 views and conclusions contained inthis document are those of the authors and should not be interpreted as repiesenting the otf oai opinion or policy of darpa. the u s government or any other person oi 1;:~:. 
connected  ith them and 
uc irvine 
irvine. ca 1 
　the overall design goal for hearsay-iii is the development of representation and control facilities with which a user can construct an expert system for his chosen domain. the specific attributes we want our system-ouilding system to embody include: 
- facilities to support codification of diverse sources of knowledge. we have avoided building into hearsay-iii any commitment to a class of application domains  such as medical diagnosis  which might allow some specificity in the language for describing sources of knowledge instead  we attempt to provide as much generality as possible in the types of knowledge that might be brought to bear on a problem from the chosen application domain. 
- facilities to support application of these diverse sources of knowledge. beyond mere application of the knowledge sources  an important design goal is to allow flexible coordination of the knowledge sources in their pursuit of an acceptable solution. 
- facilities to represent and manipulate competing solutions which are incrementally constructed. this aspect of the hearsay-iii architecture distinguishes it from the 
 diagnosis-system-building system   such as kas duda 1 . emycin  van melle 1   and expert  weiss 1 . 
-facilities for reasoning about partial solutions. that is. not only does hearsay-iii allow for incremental construction of competing solutions  but it also supports in a straightforward way the ability to reason about and manipulate those solutions during the various stages of their construction. 
-facilities for describing and applying domain dependent consistency constraints to the competing partial solutions thus  the system supports application of knowledge globally so as to aid in reducing the search for a solution 
- support for long term  large system development  and in particular  experimentation with varying knowledge for the application domain  and varying schemes for applying that knowledge. 
　in summary  our goal for hearsay-iii is to develop  debug  and experiment with theories of domain expertice. one important area we do not emphasize as a goal for the hearsay-iii design is performance of the application system. it is intended that one use hearsay-iii to gain an understanding of the problem-solving principles of a chosen domain    to study the domain. later  it may be necessary to use a more efficient formalism to construct a performance system for the domain. 

1 

1. the architecture of hearsay-ill 
1. the underlying relational database 
　hearsay-iii is built on a foundation consisting of a relational database system and its corresponding control facilities. the database language is called ap1  goldman 1  and is embedded in interlisp  teitelman 1 . as will be seen in subsequent sections hearsay-iii relies critically on the facilities provided within ap1. 
the ap1 database is similar in structure to those available in the 
planner-like languages  hewitt 1 . but it also includes strong typing on assertion  retrieval and parameter passing in function calls. the type facility in ap1 is available to a hearsay-iii user for application domain modeling in addition to being used to advantage within the hearsay-iii system itself. the hearsay-iii blackboard  sec. 1} and all publicly accessible hearsay-iii data structures are represented in the ap1 database. additional annotations required by the application knowledge sources may also be placed in the ap1 database. because knowledge source triggers are implemented as uniformly represented ap1 demons  modification to the database gives rise to knowledge-source activity  as described in sec 1 . 
　ap1 also makes available to hearsay-iii applications a context mechanism similar to those found in al programming languages such as qa1 rulifson 1  and conniver  mcdermott 1 . hearsay-iii supports contexts in such a way as to make them an integrated part of the reasoning mechanisms made available to an application. this feature is somewhat unique among expertsystem writing systems. the context mechanism supported in hearsay-iii allows reasoning along independent paths which may arise both from a choice among competing knowledge sources and from a choice among competing partial solutions. 
　the ap1 database system also provides facilities for inference rules and constraints. these facilities  in addition to being used in the implementation of hearsay-iii itself  are also available to the user for encoding global domain-dependent relationships. the interaction of constraints and contexts is supported by hearsay ill in that reasoning in a context that produces a constraint violation results in the context being flagged as poisoned  see sec 1  
1. blackboard structure 
　the blackboard is the central communication medium provided by hearsay-iii. it is used by an application program as a repository for a domain model  for representation of partial solutions  and for representation of pending activities hearsay-ill supports the representation on the blackboard of graph structures consisting of structured nodes called units and labeled arcs called roles. the blackboard is segmented into two: the domain blackboard and the scheduling blackboard. the domain blackboard is intended as the site for competence reasoning  while the scheduling blackboard is intended as the site for performance reasoning. the application writer can further subdivide each of these blackboards. 
1.1. units 
　blackboard units are the fundamental components of the representations built by application programs in hearsay-iii. units are typed ap1 objects: their types are called unit-classes. in fact  the segmentation of the reasoning space into distinct blackboards is accomplished simply as the decomposition of the unit-class unit into several distinct subclasses. thus  the domain blackboard consists solely of units of class domain-unit  and its subclasses : the scheduling blackboard consists solely of units of class scheduling-unit  when desired  access can be restricted to a given blackboard simply by using type-restricted ap1 database retrievals 
1.1. choice sets 
　units have structure in addition to their types one interesting feature of units is that they can be augmented to explicitly represent unresolved decisions such units are called choice sets associated with a choice-set unit is a set of alternatives or a 
　generator of alternatives  or both . a choice set can be viewed as a partial elaboration of a decision point; the alternatives represent still further elaborations  and they themselves might be choice sets  thus  competing problem solutions may be represented with a single locus. furthermore  structure common to all alternatives may be factored out and associated with the choiceset unit itself. the choice-set representation allows for the representation of decisions to be data about which the system can reason. 
　hearsay-iii provides two mechanisms for resolving the ambiguity represented by a choice set. these mechanisms interact in an integrated fashion with the context mechanism of ap1. the first mechanism is called a deduce-mode choose of the choice set. an application program may perform a deduce-mode choose when it has conclusive evidence that one alternative is the correct solution for the problem represented by the choice set and 
that there will be no desire to retract that choice based on further evidence in this case  the choice set is replaced by the alternative  i.e.. their properties are merged  in the context in which the choice is made in this context  all evidence that the choice set ever existed is eliminated and the blackboard structure appears as if this choice set was never there 
　the second choice mechanism is called an assume-mode choose. an assume-mode choose also replaces the choice set with a unit which represents a merge of the properties of the choice set and the chosen alternative. however  an assume-mode choose makes these changes in a newly created context that is a child of the one in which the choice was made. the appearance of the blackboard structure in the new context is identical to that resulting from a deduce-mode choose. the choice-set unit still exists in the parent context with structure modified only to eliminate the alternative just chosen. thus  if subsequent reasoning indicates this alternative may not be best  it is possible to return to the original context and select a different alternative 
1.1. acceptance 
　units have associated with the a further attribute called acceptance. acceptance can be thought of as the process of assimilating a unit into larger structure and verifying that it is appropriate in that structure. more simply. hearsay-iii allows the application writer to associate with each unit class a collection of procedurally defined predicates  called vaudator  canonicahzer. uniqueness-determiner. conflict-determiner  and integrator. 
each time a unit is created or is marked unaccepted by a ks. the acceptance routines defined for the unit s class are run. if all succeed  the unit is marked as accepted. if any fail  the unit is marked as being unacceptable: this usually results in the currently active context being poisoned  see sec 1  until a unit has been accepted. hearsay-iii prevents kss from triggering on it 
 the names are merely intended to be suggestive of no.  they are to be used 
1 
1.1. component roles 
　as mentioned earlier. hearsay-iii supports the construction of labeled graphs on the blackboard units are the nodes in those graphs the labeled arcs are called component roies  or simply roles   and are represented as typed relations connecting two units the typing of roles is of significant convenience  because it allows the use of type-restricted ap1 retrievals to simplify searching the structure. roles  in addition to being typed  are also placed in classes called ro/e sets. role sets are used for two purposes. first  they define distinct component hierarchies in which units are related by the transitive closure of the roles in a given role set this allows the supression of detail along chosen dimensions when examining the blackboard structure. the second use of role sets relates to consumption  discussed next. 
1.1. consumption 
　hearsay-iii supports a facility for describing mutual exclusion of units in an aggregated blackboard structure this is accomplished by prohibiting any structure in which two units are both components of a third unit  by transitive closure over a role set   while at the same time those two units are declared to consume a fourth this facility allows a convenient form for expressing the undesirability of using the same partial solution or interpretation for different purposes in an overall solution 
1. knowledge sources 
the domain specific knowledge for an application built in 
hearsay-ill is embodied in knowledge sources  kss  each ks can be thought of as a large-grained production rule: it reacts to blackboard changes produced by other ks executions and in turn produces new changes. 
　to define a ks  the user provides a triggering pattern  immediate code  and a body. whenever the pattern is matchabte on the blackboard. hearsay-ill creates an activation record unit for the blackboard and runs the immediate code at some later time  the activation record may be selected  see sec. 1 about scheduling  and executed  i.e.. the body  which is arbitrary lisp code  is run. in more detail: 
-the triggering pattern is expressed as an ap1 pattern as such it is a predicate whose primitives can be ap1 fact templates and arbitrary lisp predicates composed with and and or operators. whenever the ap1 database 
 which includes the hearsay iii blackboard i.e.. the units and roles  is modified such that any of the ap1 templates in the pattern is matched  the entire pattern is evaluated if the entire pattern matches an activation record is created and has stored in it the ks s name  the ap1 context in which the pattern matched1  called the triggering context . 
and the values of the variables instantiated by the match. 
-at the point the activation record is created the immediate code of the ks is executed this code which also is arbitrary lisp code  may associate information with the activation record that may be of value later in deciding when to select this activation for execution in addition  the immediate code must return as its value the name of some unit class of the scheduling blackboard. the activation record is then placed on the blackboard as a unit of that class the immediate code is executed in the triggering context and haa available to it the instantiated pattern variables. 
-at some subsequent time  the systems base scheduler  see below  may call the hearsay-ill execute action on the activation record. the usual result of this is for the body of the ks to be run in the triggering context and with the pattern variables instantiated if  however  at the point of execution  the triggering context of the activation is poisoned and the ks haa not been marked as a poison handier  the body is not run: rather  the activation record is marked aa awaiting unpoisomng. and wm have its status reverted to ready if the poieon status of the context is ever removed. 
　each ks execution ia indivisible it runs to completion and is not interrupted for the execution of any other ks activation this insulates the ks execution and simplifies the coding of the body: there need be no concern that during a ks execution anything on the blackboard is modified except as effected by the ks itself. 
1. scheduling 
　hearsay-iii is intended for use in domains in which scheduling schemes are likely to be complex. also  the application writer is not expected to have a good a priori notion how to accomplish the scheduling. thus he will need to be able to experiment freely with various schemes. since we view the scheduling problem itself as having characteristics similar to the domain problem  we feel the hearsay-ill blackboard-oriented knowledge-based approach is appropriate for its solution aa well and thus supply the same mechanisms for its solution. 
　because of the indivisibility of ks execution  the scheduling problem in hearsay-iii can be stated as follows: at the end of each ks execution  determine  from the state of the system  the ks activation to execute next. to help solve this problem  several concepts features  and mechanisms are useful: 
- as described above  the time of execution of a ks body is delayed arbitrarily long from its triggering with the activation record unit  on the scheduling blackboard as the mechanism for representing the activation also the immediate code of the ks is run on creation of the activation record  allowing ks specific scheduling information to be added to the activation record 
- some knowledge-sources  termed scneauimg rss. may make additional changes to the scheduling blackboard to facilitate the selection of activation records. scheduling kss may respond to changes both on the domain blackboards and on the scheduling blackboard including the creation of activation records. the actions they may take include associating information with activation records  e.g.. assigning and modifying priorities  and creating new units to represent meta-information about the domain blackboards  e.g.. pointers to the current highestrated unite on the domain blackboard . the scheduling blackboard is the database for solving the scheduling problem 
  the application writer provides s base scheduler procedure that is called by hearsay-iii after startup and actually calls the primitive execute operation for executing each selected ks activation. we intend the base scheduler to be very simple: most of the knowledge about scheduling should be embodied in the scheduling kss for example  the base scheduler might consist simply of a loop that removes the first element from a queue  maintained by scheduling kss. and calls for its execution. if the queue is 

1 

ever empty  the base scheduler simply terminates marking the end of system execution 
hearsay-iii provides a default base scheduler it is comoosed of two functions  either of which can be replaced by the application writer. the default outer base scheduler repeatedly calla the default inner base scheduler and expects it to return a list of activation record units.  when the inner base scheduler returns the empty list  the outer base scheduler exits  hatting system execution.  the outer base scheduler executes each activation record in turn if the ks executed is a scheduling ks and its execution returns a list of  non-scheduling  activation records  the outer base scheduler immediately executes each of thoee activation records in turn. each time the default inner base scheduler is called it nondeterministically chooses one ready scheduling ks activation record  or. if there are none  one non scheduling ks activation record. the default inner base scheduler is particularly trivial and is expected to be replaced in any serious application: the default outer base scheduler is likely to be a reasonable skeleton for many applications 
1. an example of use 
　to illustrate the use of hearsay-iii as an implementation language for expert systems we describe here the implementation of the jitterer problem-solving system  fickas 1 . the problem addressed by the jitterer is the automatic transformation of program parse trees the jitterer maps a given parse tree  initial state  into a new parse tree  the goal state  by the application of a sequence of equivalence-preserving transformations the initial parse tree and the intermediate and final parse trees generated by the transformation sequence are called program development states. the description of the goal state is supplied by the user. 
　the jitterer is one component of a transformational implementation system  balzer 1b  which allows a user to semi automatically refine and optimize a high-level program specification into an efficient implementation. an example of an optimization step a transformational implementation user might attempt is the merging of two set enumeration loops. before actually executing the merge step the user might call on the jitterer to reach a  goal  atate in which the two loops a  are adjacent  b  generate the same sets  and c  do not rely upon or affect the enumeration order of the set elements. if the jitterer is successful  the uaer can execute the merge step and achieve the desired optimization. 
each transformation is composed of 1  a left-hand-aide pattern 
 or simply lhs  that must match a portion of the current program development state. 1  zero or more enabling conditions that must hold in the lhs match context  and 1  a set of actions to perform when 1 and 1 have been satisfied. the application of a transformation generates a new. semantically equivalent  program development state. 
the jittering system faces several interesting problems: 
- many transformations the catalog may be applicable in a given development atate. further  many transformations have a corresponding inverse transformation  allowing infinite sequences. 
-establishing the enabling conditions of a transformation may be coatly. in both machine time and user effort. 
- each jittering problem has in general more than one solution  sequence of transformation applications leading to the goal state  metrics must be identified for ordering competing solutions 1 
1. design of the jitterer 
　the jitterer s basic problem solving mechanism is a backward chaining  best first search. this choice helps alleviate the problems associated with the iarge transformation fan-out. the potentially high cost of establishing enabling conditions  infinite paths and solution ordering 
　the jitterer makes two types of control decisions a selection from among the competing partial solution paths of the next path to extend  and a selection from among competing transformations of a transformation for continuing the chosen path in order to limit search  rules are used to guide both k-nds of decisions a  example of a path selection rule is  if a path s ieng:r  exceeds paththreshoid. suspend it   where paththreshoid has been determined experimentally. an example of a transformation 
selection rule is  if a transformation has side-effect x lower 
 raise  its desirability' 
　these selection rules reference features extracted from the current state as well as features predicted about the effects of possible selections features referenced by the path selection rules include current path cost predicted cost to solution number of transformations applied predicted number of total transformations needed current status  dead suspended alive complete solution  and solution compatability for transformation selection  features of interest include transformation side-effects and predicted transformation cost  as computed in both machine time and uaer effort feature information can be computed on demand or stored and maintained explicitly: the latter approach waa chosen because of perceived recomputation costs 
　a transformation can be applied to a program development atate only after its lhs has been matched and its enabling conditions have been established a straightforward approach to establishing these conditions for a single transformation application would lump all teats into a single scheduiable activity given the potentially high cost of establishing enabling conditions this approach is too inflexible it may be more efficient to order the establishing of the enabling conditions: an attempt to establish one enabling condition may provide information which will lead to 
the suspension or abandonment of the transformation application thus we require that the establishment of each enabling condition be a separate scheduiable activity 
1. hearsay-ill implementation of the jitterer 
　in this section  we describe how each component of the jitterer is implemented in hearsay-iii. 
1.1. state/space representation 
　the jitterer design requires two collateral spaces: the program development space  generated by transformation applications and representing various program development states  and the reasoning space  generated by the best-first and backward chaining search and representing partial solution paths and goal/ 
　　one solution metric it ho* **ll a solution fits in .. tn the uftt' s  *  $ g'rr* development ttrateg  for example an  jitterer produced solution   '* : i undoes a previous optimization o  prevents a future optimization must be given ic.  pno  t  to compute this metric the jitterer must be able tc analyze past dev*iopment steps and predict future development steps  the latter pressing  c t :..s problems 
1 
subgoal relationships. by using hearsay-ills unit-class mechanism  the class of domain-units can be subdivided into reasoning-units and development-units  and thus we implement the two spaces as a segmentation of the domain blackboard. although the reasoning space references units in the development space  the two spaces are essentially independent. 
　a state in the reasoning space is an and/or goal tree. the goal tree is built from reasoning-units {goa'unit  transformationunit  and component roles {sub-gcai. achieves . an or node represents the choice among competing transformations. an and node represents the set of goals  transformation applicability checks  that must be satisfied in order to apply a particular transformation. the hearsay-in choice-set mechanism  see sec. 1.1  provides a framewor* both for structuring the set of competing transformations and for managing child contexts assooated with the choice. an assume-mode choose is used. spawning new reasoning states  contexts  when a transformation is chosen. 
　a state in the program development space represents the entire program parse tree at a particular stage of development. the parse tree is built from development-units  e.g.. loop-unit  assignment-unit  and component roles  e.g.. predicate  thenclause  loop-body . in the development space  there is no notion of a choice set  rather  simply a recording of various program development paths. the application of a transformation generates a new hearsay- iii/ap1 context. note that there is no need to copy the program development state  i.e.. the syntax tree  into the new context; the jitterer relies on the context inheritance mechanism and thus needs to represent explicitly only those portions of the structure that are new or modified 
1.1. transformation representation 
	each transformation is implemented as a domain 	ks 
 henceforth  transformation ks . because of the jitterer s backward-chaining control  the trigger of a transformation ks corresponds to the action portion  translated so to match the goals of the reasoning space  of the corresponding transformation. the immediate code of a transformation ks is responsible for setting up as subgoals the lhs pattern to be matched and the enabling conditions to be established: we describe this further in tne next section the body. when executed  creates a new context  program development state  and makes the appropriate modifications 
1.1. control knowledge 
　as described in sec 1. the jitterer uses rule-based selection knowledge to control search each selection rule is implemented as a scheduling ks  see sec. 1 . for example  one selection rule treats the desirability of a transformation as a function of the sideeffects it produces figure 1 shows the scheduling ks form for one instance of this rule namely that a transformation that unfolds a function in-line has the deleterious side-effect of flattening the program structure.1 
 declare-sks structural-flattening  op  trigger:  and  compet i ngoperator op  
　　　　　　 sideeffect 	op 	unfoldsfunction   immediate code: operator-orderinglevel body: 	 dec reasedes i rabilityop   
figure 1: a transformation selection rule 
'the actual ap1'hearsay-ill syntax has been modifiec here for da'it. 
　earlier we mentioned a rule that checks for a path growing beyond a paththreshold. figure 1 shows the scheduling ks form of this rule note that the evaluation of the immediate code of the two scheduling kss places their corresponding activation records on separate scheduling levels. the jitterers base scheduler gives path-state-change-level priority over operator-ordering-level and hence path suspension is attempted before transformation ordering. 
 declare-sks lengthy-oath  path  
trigger: 
 and 
 competingpath path  
　　　    currentpathlength path  paththreshold   immediate code: path-state-change-level body:  merkassuspended path   
figure 1: a path selection rule 
　as discussed in sec. 1. the jitterer's selection rules reference certain computed problem-solving features this information is stored as auxiliary reasoning structures attached to the relevant units on the scheduling and domain blackboards. for example  an auxiliary reasoning structure for path selection is attached to each goal-unit in the reasoning space1 the scheduling ks in fig. 1 makes reference to the path length of path. current path length information is stored in and retrieved from the auxiliary structure associated with path s frontier goal. 
　to descibe the auxiliary reasoning structure used for transformation selection  we must look more closely at the implementation of transformations as kss. hearsay-iii divides a ks application between triggering and execution. as described 
sec. 1. once a ks is triggered  an activation record is created on the scheduling blackboard where it resides until executed oy the application's base scheduler. the jitterer selects from among the set of activation records of triggered transformation kss. thus  this set that must be ordered. the immediate code of each transformation ks is responsible for attaching an auxiliary reasoning structure to the corresponding activation record. for example  the scheduling ks in fig 1 makes reference to the side-effects of a transformation. these side-effects are among the information stored in the auxiliary reasoning structure attached to the corresponding activation record. the immediate code is also responsible for adding the activation record to the choice set of the appropriate or goal in the reasoning space. 
1.1. the scheduling of enabling conditions 
　the jitterer design calls for the separate scheduling of each enabling condition. this is implemented in hearsay-iii in the same manner described for auxiliary reasoning structures in the previous section: the immediate code of a transformation ks augments the activation record with the set of enabling conditions the scheduling kss and the base scheduler order the set and determine when to attempt establishment of the individual conditions in some cases it may be undesirable to execute an activation record even though all enabling conditions have been established a few scheduling kss look for these cases ard flag the activation record accordingly in general the ability to divide problem solving into such fine-grained activities has been helpful for the jitterer 
'each goal is ne.-.ed as the frontier of a pair  from the 'oot goat 
1 
1.1. the scheduling of scheduling kss 
　the jitterer's selection rules  implemented as scheduling kss. help order the path and transformation search space. however  we are left with the problem of scheduling the scheduling kss the jitterer's scheduling blackboard is divided into a set of mutually exclusive  prioritized scheduling levels. each scheduling ks is assigned to a single level by its immediate code the 
jitterer's base scheduler returns  for execution  an activation record from the highest level on which activation records reside 
　for many levels  intra-level scheduling consists simply of executing activation records in arbitrary order until none remain on the particular level operator-ordering level  referenced in fig. 1. is scheduled in this way. however  some scheduling levels provide structures for ordering their activation records one example is the level on which the activation records of competing transformations are placed; the transformation selection rules maintain an ordered list. another level. reportsolution-level  discussed below  provides a queue for recording the order of activation record appearance. when an activation record is placed on this level  a  queue maintenance  scheduling ks adds it to the end of the queue. given the best-first search the final queue will contain spokesmen for all solutions found by the 
jitterer in their order of preference 
　we have previously seen in fig. 1 and fig 1  two of the defined scheduling levels another example is the scheduling blackboards highest priority level.1 report-solution level. because the ks that detects complete solutions is assigned to this level by its immediate code  its activation records are executed immediately following any ks activation that satisfies its triggering pattern. thus  the jitterer reports a solution to the user as soon as it is found. if instead the jitterer was to find all solutions to a problem before reporting any report solution level should be made the lowest priority scheduling level. 
1.1. use of the acceptance routines 
　the jitterer's scheduling kss normally determine the difficulty of achieving a particular goal  attaching appropriate information to the goals auxiliary structure however  detecting jittering goals that are inherently impossible is performed by a validator acceptance routine. when a new jittering goal is posted in the reasoning space  the appropriate validator determines whether it falls into this special class. if so. the goal is marked as impossible before being considered by the rest of the system. currently  only easily determined impossible goals are handled by the validator routines. thus  more sophisticated tests about impossible goal states are not included in the validator routines because we want the system to be able to schedule these costly activities. once a goal unit is created  all validator routines pertaining to that goal are run. 
　the jitterer applies a set of normalization and simplification rules each time a new program development state is generated  i.e.. whenever a parse tree is changed .1 this cleanup process has been implemented in hearsay-iii through the canonicalizer acceptors: each node type  unit-class  of a parse tree  e.g.. loopunit  assignment-unit  conditional-unit  has an associated canonicalizer: each canonicalizer embodies the set of clean-up 
　　this is actually not quite the highest level even higher are those used by the scheduling kss that do mtra-ievel structuring 
o 
　　while these rotes also make changes to the parse tree they do not cat:-:  ** generation oi ne.. development states 
rules for its node-type it is the responsibility of a transformation changing the parse tree to mark the relevant nodes  units  for  reacceptance  see sec. 1 1  
1. conclusion 
　hearsay-iii was exercised initially on two small test cases: a cryptarithmatic problem and a cryptogram decoding problem in addition to the jitterer. two major implementation efforts are currently underway the first of these is the reimplementation of safe  a system for constructing formal specifications of programs from informal specifications  balzer 1 . second. hearsay-ill is being used as the basis for a system for producing natural language descriptions of expert system data structures  mann 1 . 
　in some problem domains  the major implementation effort will be the encoding of the competency portion of the problem-solving system in the form of kss. the performance portion of the system may not require sophisticated scheduling techniques sufficing on a reasonably tunable set of hardwired scheduling regimes  such as the age system provides in these cases  the hearsay-iii system may seem less useful since the user will have to build-up all but the most primitive control structures from scratch. although such is currently the case  as more and more projects use hearsay-iii. the stock of different application schedulers will grow. it seems reasonable to assume that with a little worn these schedulers can be generalized to provide a new user with a library of hearsay-iii schedulers from which to choose. a new problem domain may be able to use an existing scheduler directly or as the foundation for a more application specific scheduler 
　our experience to date supports our belief that the hearsay-iii architecture is a helpful one the separation of competence knowledge from performance knowledge helps in rapidly formulating the expert knowledge required for a solution. the flexibility that the hearsay-iii architecture gives toward developing scheduling algorithms will undoubtably go a long way toward simplifying this difficult aspect of the overall problem-solving process 
acknowledgments 
　hearsay-iii was originally designed was by bob balzer. lee erman. and chuck williams  with contributions by jeff barnett. mark fox. and bill mann subsequently. phil london and neil goldman contributed significant design modifications lee erman and phil london implemented and maintain hearsay-ill. ap1 was designed  implemented and maintained by neil goldman. steve fickas designed and implemented the jitterer neil goldman. bill 
mann. jim moore  and dave wile have also served as helpful and patient initial users of the hearsay-iii system 
1 

