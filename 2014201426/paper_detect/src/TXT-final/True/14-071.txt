 
　　　a new research multiprocessor named zmob is described  and i t s significance to ai research is surveyed and characterized. zmob  under current construction and scheduled for completion late f a l l 1. is a 1 processor machine with a high speed  interprocessor communications system called the  conveyor b e l t     a non-blocking  1 megabyte/second message switcher. because of i t s large number of processors  high computational throughput  1 m i l l i o n instructions/sec   large cumulative high speed memory  1 megabytes   high interprocessor communications bandwidth  and external communications and sensing channels  zmob opens some new areas of exploration in objectoriented modeling  knowledge-based and domain expert systems  i n t e l l i g e n t sensing and robotics  and d i s t r i b u t e d perceptual and cognitive modeling. the paper attempts to blend a description of 
zmob's hardware with ideas about where and how it f i t s i n t o various types of ai research. 
1. 	introduction 
　　　ai is not in need of new computing hardware to solve i t s basic questions. however  new hardware cannot be dismissed as being irrelevant to progress in a i   because: 
1. beliefs about the nature of computing hardware available influence a researcher's a b i l i t y to conceptualize data and process models of i n t e l l i g e n c e . while a researcher can certainly imagine methods of modeling which require unusual hardware  he may never discover the i n t e r e s t i n g issues because of his i n a b i l i t y to see beyond the f i r s t round of ideas. like it or not  ai is an experimental science which r e l i e s heavily on feedback from the implementation level to the conceptual model l e v e l . 
1. certain ai methods requiring heavy symbolic computation have not been adequately explored simply because the architecture or computational capacity of the supporting computers is not adequate. examples are large pattern-directed rule systems  and certain low and high level v i s i o n techniques  among many others. 
1. certain well researched ai methods. recognized as f r u i t f u l conceptual approaches to various classes of problems  are inherently not designed for conventional machines  and would become p r a c t i c a l   real-world systems if implemented on hardware better suited to tneir needs. distributed and  expert  systems 
　　　* the research described here is funded by the a i r force office of s c i e n t i f i c research under contract af1r-1. as of march 1  a l l zmob design and debugging was completed  and a twoprocessor prototype was running. the f u l l machine  budgeted at approximately $1k hardware cost  is expected to be running by late f a l l 1. which rely on object-oriented programming styles are generally good examples of this category. 
　　　this paper is about a new research computer designed to help stimulate new ways of thinking about ai modeling  and to help advance certain existing computing methods by removing some of the computational barriers that l i m i t these methods usefulness. we o f f e r t h i s research not as a source  but rather a gateway to some new ideas about ai model b u i l d i n g . in w r i t i n g a paper about hardware's role in higher level model b u i l d i n g   we run the risk of overselling the hardware per se. without demonstrating i t s usefulness to model building and theory development. to minimize t h i s r i s k   we have attempted to blend a description of the machine's architecture  including enough d e t a i l to give the reader a complete picture of the machine  with b r i e f tours through the various realms of ai model building which may p r o f i t from t h i s architecture. our hope is to snow that new machine architectures  if developed in a way that is sensitive to current modeling directions in the f i e l d   can be an important l i n k in the larger basic research feedback loop that gradually converges on good ai theories. 
1  zmob and distributed ai 
　　　zmob is a 1 processor multiprocessor which taxonomically f a l l s into the same general category as ck*   but which also has appearances of high speed r i n g networks. each of i t s 1 processors is a completely autonomous computer with enough memory to do s i g n i f i c a n t independent high level computation asynchronously from other processors. however  each processor is intimately linked to a l l other processors by an interconnection system of such high speed r e l a t i v e to the i n d i v i d u a l processor that a l l 1 of a processor s companion processors appear to be equidistant from i t   and  in f a c t   accessible in what amounts to unit time from i t s point of view. zmob is thus a mob of 1 reasonably powerful processors organized in a manner tnat superimposes no actual  or even preferred  geometry on t h e i r l o g i c a l i n t e r connectivity. as such  it is close to the ideal for systems of experts whose intercommunication geometry is governed by domain problem solvers rather than by a p r i o r i donain structure. 
　　　zmob d i f f e r s from cm* in three s i g n i f i c a n t ways. f i r s t   it possesses a larger number of processors  each roughly equivalent in power to a ck* processor.  to our knowledge  i t s 1 processors comprise the largest research multiprocessor yet designed and b u i l t .   second  a l l memory is u n i formly d i s t r i b u t e d equally among the processors 
 there is no high speed shared memory   giving zmob i t s network f l a v o r . third  the interprocessor communications strategy is completely nonblocking  with no p o s s i b i l i t y for hardware-level contention in message passing. zmob w i l l support 1 pairwise processor conversations  and broadcasts from one processor to a l l others or a subset of others equally w e l l . 
　　　in the next section we describe zmob's hardware architecture and operating systems  which w i l l include c  lisp  pascal  proloc  and specialized vision systems. then we survey zmob s 
1 
conceptual and pragmatic usefulness to several areas of a i . 
1. hang on: 	here's 	the hardware! 
　　　zmod is a large  experimental research multiprocessor under construction by the a r t i f i c i a l i n t e l l i g e n c e group within the computer science 
department at the university of maryland. the machine's architecture is 1 autonomous microprocessors  each with 1k bytes of 1 ns memory and capable of approximately 1 i n s t r u c t i o n s per second  connected together via a high speed communications ring called  the conveyor b e l t   . the conveyor b e l t   a 1 - b i t wide  1 mhz s h i f t register  comprises 1  mail stops . each 1-bit-wide mail stop is associated with a zmob processor 
 except for the 1th  which is associated with zmob's external i n t e r f a c e     and represents one stage in the conveyor b e l t . because or the conveyor belt s high speed r e l a t i v e to the needs of any i n d i v i d u a l processor  and because of each mail stop's high speed message pattern matchers  the conveyor belt is a nearly perfect interprocessor communications medium. in p a r t i c u l a r   the conveyor belt gives prompt enough service f o r every processor to be given   u n i t time  message delivery to another a r b i t r a r y processor or bet of processors. 
　　　in addition to i t s conveyor b e l t i n t e r f a c e   each processor has a high speed p a r a l l e l and a s e r i a l interface to the outside world f o r applications involving remote sensing  c o n t r o l   or com-
munications. a special 1th processor interfaces the zmob conveyor belt to a pdp unibus. 
	at 	large  	zmob 	executes 	approximately 
1 m i l l i o n i n s t r u c t i o n s per second on a 1-way d i s t r i b u t e d 1 m i l l i o n byte high speed memory. i t s conveyor b e l t switches interprocessor and external messages at a rate of 1 m i l l i o n bytes per second. 
1 * m a i l stops and bins 
　　　physically  each m a i l stop is a printed c i r c u i t board which occupies one s l o t of the conveyor belt backplane  a 1-dit wide c i r c u l a r bus which passes through a l l mail stops. incoming conveyor belt signals  those from a mail stop s upstream neighbor  a r r i v e via the mail stop s 1 inbound l i n e s   and outgoing conveyor belt signals  those being sent to the mail stop s downstream neighbor  leave via the mail stop's 1 outbound l i n e s . one 1 - b i t   b i n     i . e . . one message  passes through the mail stop each 1 ns  as directed by the 1 mhz synchronous master system clock which is d i s t r i b u t e d to each m a i l stop over precisely matched cables. 
　　　each zmob processor occupies a second printed c i r c u i t board which is physically adjacent to a mail stop board. each mail stop communicates with i t s associated zmob processor via a 1 l i n e i n t e r face that allows the processor to view i t s mail stop as a c o l l e c t i o n of 1 - b i t registers which  when read from and w r i t t e n t o   cause mail and status information to flow to and from the conveyor b e l t . 
　　　l o g i c a l l y   the conveyor b e l t is thought of as a c o l l e c t i o n of bins wnich move around the loop through a l l mailstops each r e v o l u t i o n . bins carry messages  and each processor permanently owns one b i n . once  per conveyor b e l t r e v o l u t i o n   every processors bin simultaneously a r r i v e s back at the processor s mail stop. this event is signaled to a l l mail stops by a master  index pulse   generated by the master clock c i r c u i t r y and d i s t r i buted to each mail stop as with tne master s h i f t clock. 
　　　the mail stops are analogous to the ola f r e i g h t t r a i n mail hooks. when the processor wishes to send a message  it gives it to i t s mail stop  which holds it u n t i l the proper moment for i n j e c t i o n on the conveyor b e l t   i . e . . index pulse time . when the conveyor belt bin permanently owned by a processor arrives back at that processor's mail stop empty  and if the mail stop has been given a message to send  then the message w i l l be injected onto the conveyor b e l t in the processor's bin. during a l l other moments   i . e .   when processors' bins are in t r a n s i t around the conveyor b e l t     each mail stop performs high speed pattern matching to detect a r r i v i n g messages intended for i t s processor. the mail stop can extract one message from the conveyor belt and hold it u n t i l i t s processor has taken i t . 
　　　each mail stop  hence processor  has a unique conveyor belt address  1   which can be used to i d e n t i f y the intended receiver s  of a message. in a d d i t i o n   each mail stop can be instructed by i t s processor to watch f o r a specific pattern of 1's  o's  and  don't care's  in messages' destinations f i e l d s   and to receive any messages matching that pattern. this is a basic mechanism upon which more elaborate pattern-directed invocation techniques and hierarchical processor organizations can be realized. 
	1.. 	messages 
　　　when a message is sent  it w i l l always contain the address of the sender  the data  and information describing the intended r e c e i v e r   s   . there are four modes for describing the intended receiver s : 
send to processor by address 
send to processor by pattern 
send to all processors 
send to set of processors by pattern 
each message is sent under exactly one of these four modes. in the f i r s t two cases  where there is only one intended receiver  the receiving mail stop w i l l consume the message. in the la1t two case1  a receiving mail stop w i l l make a copy of the message  but allow it to continue for a l l to see. in t h i s l a t t e r case  it is incumbent on the sending processor to consume i t s own message a f t e r one complete conveyor belt r e v o l u t i o n . doing 1 is called  readback . 
　　　each mail 1top is capable of buffering one message in the outbound d i r e c t i o n  processor to conveyor b e l t     and one message in the inbound d i r e c t i o n  conveyor belt to processor . messages w i l l be received by a mail stop only if i t s pattern matchers are enabled and deem the message appropriate  and i t s inbound buffer is empty. a received message w i l l generate a processor i n t e r rupt  then remain in the mail stop's inbound buffer u n t i l e x p l i c i t l y read by the mail stop s processor. messages on tne conveyor belt intended f o r a processor whose mail stop's inbound buffer is f u l l w i l l simply continue c i r c u l a t i n g on the conveyor belt u n t i l the mail stop f i n a l l y reads and consumes them  or u n t i l t h e i r senders consume and remove them. when the mail stop's outbound buffer is emptied as the result of i n j e c t i n g the message it contains onto the conveyor b e l t   a second type of processor i n t e r r u p t is generated. the mail stop is therefore a f u l l - d u p l e x protocol   where separate message streams can be in progress both inbound and outbound. 
　　　a mail stop's receiving pattern matchers can be further conditioned to accept only messages from a specific source processor  i d e n t i f i e d by i t s conveyor belt address. this  exclusive source 
mode allows for the uninterrupted transmission of data streams between two processors  or between one source and a group of receivers. 
　　　in order for absolute control commands from the conveyor belt a unibus interface to have guaranteed delivery to any or a l l processors  each mail stop has a separate logic section that is capable of detecting special c o n t r o l   messages from the mail stop associated with the unibus interface processor  the only mail atop capable of sending control messages. control messages are subject to the same inbound pattern matchers as normal messages  except that  1  they cannot be selectively excluded the way normal messages can  and  1  they do not i n t e r a c t with the mail stop's inbound buffer. this transparency allows absolute access to any or a l l processors from the external 
1 

conveyor belt i n t e r f a c e   while not i n t e r f e r i n g with the flow of normal conveyor belt messages. 
1 	conveyor belt format 
       the 1 b i t s of a conveyor belt message are appropriated into four f i e l d s : 

bf - bin f u l l 
ct - control message 
c1-co - control code 
ad - a l l destinations 
dm - destination mode 
when sending a message  the processor has freedon in s e t t i n g the ad and dm b i t s to any values. the ad and dm b i t s describe the mode under which the message is being transmitted  and are inspected by the inbound pattern matchers of a l l potential receiving mail stops: 
	ad 	dm 	interpretation 
1 send to processor by address the message is intended only for the processor whose address is in the destination f i e l d . 
1 send to processor by pattern the message is intended for the f i r s t processor whose posted attern matches the destination f i e l d . 
1 send to all processors the message is intended for all processors.  the destination f i e l d is to be ignored.  
1 send to set of processors by pattern the message is intended for a l l processors whose posted pattern matches the destination f i e l d . 
       the bf and ct b i t s are not controllable by the processor. the bf f l a g is generated e n t i r e l y by mail stop hardware l o g i c   and the ct b i t can only be generated by the 1th mail stop. 
       the 1-bit data f i e l d provides for single or double byte messages. if ct is set then bits c1co are interpreted as a control code. otherwise they can be used as extra data b i t s . the source and destination f i e l d s have been allocated 1 b i t s for possible future increases in the number of processors. 
1. processor 	interface 
       the processor views i t s mail stop as a group of 1 - b i t memory-mapped i/o ports  each of which accesses part or a l l of one of the mail stop s registers. a l l reading and conditioning of the mail stop's current state  and a l l data movement between the mail stop and processor occurs by reading and w r i t i n g to these registers via the 1 - b i t ports. the mail stop can also generate four types of interupt to signal the processor that it requires service: inbound buffer full  outbound buffer empty  readback  and control. 
1.* 	zmob processors 
       each zmob processor is a z1 microprocessor with the following support hardware: 
1. 1k bytes of high speed compute memory 
1. 1k bytes of resident bootstrap operating system read-only memory 
1.. interface logic to conveyor belt 
1. a high speed hardware integer multiplier 
1.. a 1 bit floating point processor chip 
1. a high speed 1-bit parallel and a serial external interface. 
       when zmob is first powered on  a l l processors go through identical reset sequences which i n i tialize all processor and associated mail stop logic. each processor then enters its resident bootstrap kernel  which awaits commands from the unibus interface. support software on the vax then sends operating software to each processor individually  or to all at once  in case a l l will be 
running identical operating systems. 
1. zmob software: high level strategies 
1. conceptual organizations 
       the particular operating system regime under which zmob processors are coordinated depends largely on the domain. we 1ee five conceptually different control regimes for al modeling: 
1. actual synchromy. in this most rudimentary system  each processor performs fixed functions in precise  e.g.  conveyor belt revolution time precision  lockstep with a l l others  but on different data points. this is an architecturally uninteresting use of the machine  but is applicable in such areas as cellular automata modeling and neural simulation  certain numerical methods in perceptual modeling  and so forth. in these applications  either high efficiency  or high precision in simulation timing requires precise synchronization. 
1. logical synchrony. each processor runs an identical operating system capable of performing a fixed set of functions in logical  but not necessarily actual  syn-
chrony with a l l others  eacn working on a piece of a large data space distributed among processors in advance. examples of this mode are models of low level vision or speech  where edge detectors or acoustic processors a l l proceed in parallel on different data   and in parallel data bases storage and retrieval  where all processors carry out  possibly intelligent  hashing and pattern matching on different segments of the database  see  for example . 
.1. uniform multiprocessing. each processor runs an identical operating system  but one capable of general computing or problem solving. each processor is statically or dynamically assigned a subtask  which it then solves asynchronously from all others. a large number of ai methods falls into this category  since each processor is  in effect  a general problem solving agent. 
1. articulated multiprocessing-. distinct domain experts reside in various processors  or sets of processors. each expert is capable of autonomous solution of problems in its domain  which may have been sent to it via a pattern-directed invocation scheme. systems of experts such as those encouraged by microplanner and smalltalk f a l l into this category. 
1. hybrid systems.. the machine is logically segmented to support any or a l l of the above modes simultaneously  because of the nature of the conveyor belt  onequarter of the machine could be devoted to processes requiring actual synchrony  one-fourth to those running logical synchrony  one-fourth to uniform multiprocessing  and one-fourth to articulated multiprocessing. illustrations of hybrid use can be taken from nearly every area 
1 
of ai  including robotics  expert systems  speech systems  natural language systems  and game playing systems. in a typical segmentation  some processors would handle sensory and perceptual information  others the logical database  others the domain problem solving  and others the effector or response control. 
1. four processor-resident operating systems 
　　　in anticipation of such variety of modeling needs  we are developing four higher level processor-resident environments  a l l of which rely on a single  lower level kernel system. at poweron  the kernel system will be broadcast from he vax to all processors. then  at user request  various processors will receive one of the four higher level environments: 
1 . c. in this system  the processor supports a c runtime environment  and runs c code which has been developed and crosscompiled on the vax. 
1. lisp. the processor runs a f u l l z1 lisp system   and communicates via sexpressions passed as ascii strings among processors. the issue of pointer passing on a completely distributed cons node apace will have to be addressed before other forms of interprocessor lisp communication can be achieved. 
1. pascal. the processor supports a pasox runtime environment and either runs cross-conpiled pascal code  or interprets p-codes. 
1. d+d. the processor . runs a dedicated database and demons  operating system. this special-purpose system allows the processor to participate as a piece of a arger pattern-directed  intelligent database  which stores information in lisp s-exnression form  although encoded differently for efficiency. the d+d system will store both constant sexpressions  facts  and schematic sexpressions  demons   and will respond to fetch  store  and trigger commands sent to it via the conveyor belt. 
     the c  lisp and pascal systems already exist for zmob  since each processor is capable of running cp/m  a nearly universal machine-independent operating system for the z1 . d+d is under current development in z1 assembler  using the vax z1o assembler and simulator  and the vax process-oriented conveyor belt simulator specially written for zmob development. 
     the resident low level operating system kernel common to a l l higher level environments is in effect an event-driven task management system which carries out a l l low level interprocessor handshaking and data transfers. the interruptdriven task queues at this low level support a succeso/failure/contingency communication system similar in some respects to sail's process management. we have not yet completed  this system  and are looking at rashid s ipc  as an eventual augmentation of the present kernel. 
     we turn now to some specific ai modeling where zmob w i l l have impact. we have organized this discussion around ai areas  but point out specific systems where appropriate. 
1. where zmod fits: areas and issues 
1 object-oriented 	programming 	and 	experts 
     the concept of object-oriented programming dates at least from the work of alan kay  and carl hewitt  and more recently is the dominant systems organization paradigm of the smalltalk system. in this style of programming  active knowledge is organized around cooperating experts called objects. 'the hierarchical organization of objects into classes  subclasses and instances both aids the user in creating new objects and facilitates elegant communication among objects in the form of message passing. 
　　　zmob's distributed  geometry-independent nature makes it an ideal parallel machine for implementing systems organized in such a manner. the localized processing required for the objectoriented approach is encouraged by zmob's d i s t r i buted memory. at the same time  its ability to dynamically link arbitrary pairs of processors in direct communication allows for sophisticated message passing capabilities. 
     we are currently in the process of designing and implementing a system for computer aided design and simulation of mechanisms  cadsom  on zmob . this system possesses many of the features outlined above including separate proces-
sors as experts for different parts of a user defined mechanism and message passing as a means for real-time graphical simulation of the kinematics of the mechanism. 
　　　briefly  the operation of our cadsom system is as follows. the user  say a mechanical engineer  begins with a rough design of a mechanism in mind. he or she then interactively identifies parts from a frame-like database of primitive part descriptions. these can then be further specified as to size  weight  shape  etc. while viewing the object on a graphics terminal. as a part is described it is assigned to a processor and as the links between parts are described by the user  communication paths are established among the processors. finally  when the user has described the complete assembly  he or she may specify an i n i t i a l velocity or force upon some part at which point the system performs a graphical simulation in real-time of the kinematics of the mechanism. it is during the simulation phase that truly parallel object-oriented processing occurs with part experts interacting both to compute velocity  acceleration  and force vectors for the next incremental time step and to detect 
obstructions to their motion. 
1. parallel pattern matching and production rule systems 
     though the production rule system has been popular and successful as a design methodology especially for large-scale .-knowledge   engineering tasks for some time  see       it has 
only been recently that the problem of implementing such systems in parallel has been confronted. in particular  forgy in  has designed a  production rule system based in part on ideas from data flow theory. though to our knowledge  hi1 system has not yet been implemented on a parallel machine  many of his algorithms including those for pattern matching are inherently parallel. 
　　　a fertile area of study for zmob is this topic of parallel pattern matching specifically addressing ways of avoiding the need for a large global database of patterns. distributing the large database over many processors raises additional problems. one in particular is that of bottlenecking at processors who have a disproportionate share of requests on their portion of the database. thus the design of algorithms for e f f i ciently and dynamically reconfiguring the database organization is an important area of research on zmob. 
	1. cognitive 	modeling 
     many of the past and present theories advanced as plausible cognitive models of natural language understanding  causal reasoning  inference  and problem solving directly or indirectly posit distribution of functions in ways appropriate to zmob. parallel matching of krl frames   scripts in frump and related systems  are examples where theoretically quantized knowledge unit1 could be experimentally distributed across processors. the actors in meehan's story generator  and entities in complex social or political sinulation models are examples where independent problem solving agents could be run by separate processors. individual  word experts in the word expert parser { and   are a perfect f i t 
1 
for zmob. in that theory  each word is modeled by a self-contained word expert  lisp code that interacts with other experts during the comprehension of a sentence in context. our csa representation   and   and its simulation system directly segment the world of causality into events and event clusters which could be parallelized directly into autonomous agents. in fact  the whole area of causal reasoning in the physical 
world seems directly suited to distributed modeling. in all these cases  zmob could be playing the dual role of helping shape theories about distribution of cognitive function  and of making experimentation more reasonable. experience with the wep and csa systems  for example  is that interesting research has sometimes not been attempted because of our beliefs and frustrations about computational limits of the conventional machines we are using. 
1. robotics and real time sensing systems 
　　　zmob's real-time performance and external serial and parallel channels per processor make it ideal for applications involving coordinated and articulated control of effectors and/or synthesis pf 1ensory information. as the nbs robotics lab  and others have found  multiple fixed-function processors can bring sophisticated vision  sensng  and joint control to nearly any level of desired motor performance. in an automated shop  for example  where a number of tools and their associated vision and manipulator systems must run in coordination  zmob processors could be assigned in modular clusters that communicate both at the intra- and inter-group levels. in one module  for example  several processors would perform regionwise feature extraction in parallel  feeding results to a separate scene-constructing processor  which then directed the team of manipulator trajectory computing and .joint controlling processors. another processor in the cluster could scan for certain error or contingency conditions  and a final processor could coordinate its group's efforts with other group coordinators. in a large job shop  human operator stations could be tied in by other processors. 
　　　in sensing environments  zmob could assign processors to fixed sensor clusters in a complex environment  such as three mile island. each processor would contain both physical and causal models of the segment of the environment it sensed  and the relation of that environment to the site at large. given powerful enough causal models and the current operating context and user intent  e.g.  during dynamic maneuvers such as peak load power up   individual processors could ntelligently coordinate their environment with the larger environment  report abnormalities with annotations about probable causes  and even take local corrective procedures  then inform superior processors of the changes. distributed i n t e l l i gence in a complex sensor/effector system like tmi is an attractive solution to real-time critical decision making  and zmob seems ideally suited for such distribution. a central research topic here is to develop the common language of causality through which processors communicate. with its effective interprocessor communications bandwidth of 1 megabaud  zmob's potentials for distributed real-time decision making are considerably higher than even the fastest traditional networks. also  because of the large number of processors  redundancy either at the decision making or sensory level is feasible. 
1. management of large information spaces 
	in  we have described the concept 	of 	an 
i-space  	and 	an 	i-space 	project in progress at 
maryland. an i-space is an information hub for large societal or institutional organizations where there is a large quantity of information and/or e large number of tools for manipulating that information  as well as a need to interface a wide variety of users to both the information and tools in real time. the goddard i-space is perhaps the archetype of all i-spacea  in that the user group is quite diverse  administrators  scientists  engineers  technicians  schedulers  etc.   and in that the information content of the system at.large is both tremendous and highly distributed  science and engineering databases  real-time data acquisition systems  real-time control systems  planning and administrative databases  and so forth . the keys to the i-space concept are uniformity in information presentation on high resolution tv screens  and flexibility in synthesizing information in user-idiosyncratic ways from a l l parts of the i-space for simultaneous display on his screen. 
	while the user interface in 	the 	goddard 	1-
space system is reminiscent of the pie system.  the real-time requirements of accessing ana synthesizing  information from remote hosts  administrators' desktop computers  real-time satellite links  and local planning databases call for much more computational power than pie  or  indeed  than most computing facilities possess. because of this  zmob will play a prominent role  called the i-bank  in the goddard i-space. in this role  zmob's processors will run dedicated  intelligent links to the outside world  remote hosts  telephone links  satellite links  etc.  that comprise the i-space. the system s vax-based user interfaces  running frame-like packets which put out real-time control and information requests into the i-space  make demands on zmob as a gateway to the outside  thus distributing most or the system s time-critical scheduling to zmob a processors. we see this type of architecture as mandatory for large-scale information systems. 
1 .1. 	distributed 	databases 	and 	formal 	ai 
research 
     preliminary design of a predicate logic system to be implemented on zmob is currently in progress at the university of maryland. based on such foundational worn as     and the setoriented extensions of   this system features a distributed relational database and the predicate logic language prolog  used as an interface to the database for querying and other purposes. 
　　　i n i t i a l l y   three types of processes are envisioned: the search space process which accepts the user s database query  divides it into problems and starts up several problem solving processes to handle them; the problem solving processes which run prolog and build tasks for the database processes; and the database processes which   i n i t i a l l y   handle one relation of the entire database apiece and perform lookup  updating  and unification. in the future  the ability to perform efficient reorganization or the database will be added in order to spread an overused relatiop among several processors and to group several relations in the same processor. zmob s architecture allows complete freedom to effect such a reorganization while its message passing protocols allow problem solving processes to com-
municate by capability with data base processes  a necessity for efficient database lookup. 
	1. heuristic 	search 
　　　the problem of searching a large state space has long begged for a parallel solution. several algorithms for doing this have appeared in the literature        but most have not yet been implemented on true parallel hardware. those that have been implemented are not as useful as they could be. for example. baudet s parallel version of alpha-beta exhibite a better than linear speed-up with two or three processors  but improves very l i t t l e with more than five. zmob s f l e x i b i l i t y makes it easy to implement these algorithms  compare their performance  and develop new methods from that experience. 
	1.. 	computer vision 
　　　some preliminary work has already been done in the area of image processing on zmob. in   a vision system running on zmob is described which divides tne 1 by 1 pixel image into 1 by 1 regions  one per processor. timing simulations showed that a simple 1 by 1 averaging of the entire image could be performed in about 1 fifths of a second while elaborate relaxation algorithms 
1 
involving 1 labels per point 	could 	complete 	an iteration in about 1 seconds. 	such timing esti-
mates show that orders of magnitude speedup can be achieved using zmob in the vision domain.  provides further timing estimates for picture processing algorithms including image loading and unloading times  and notes that for most nontrivial algorithms zmob effects as much as a tenfold speedup over execution on the host  computer  in this case  a vax 1 . in  these results are compared with those of possible imple-
mentations on other parallel architectures  in particular  switching networks. 
1. other 	areas 
　　　in  the appropriateness of zmob for research in cellular automata is discussed  specifically addressing the problems of reconfigurable parallel computers. other future applicaion areas include numerical analysis  network topology and performance evaluation  and neural modeling. finally  zmob could also function as a microprocessor instructional machine for students or as a message switching station for large computer networks. 
1. 	summary 
　　　zmob is scheduled to become f u l l y operational in late f a l l 1. as we emphasized in the i n t r o duction  it w i l l d i r e c t l y solve no theoretical ai problems. but it w i l l   we hope  encourage deeper research into e x i s t i n g areas where computational l i m i t a t i o n s have t r a d i t i o n a l l y posed serious barr i e r s   and stimulate new and more ambitious ways of thinking about ai and cognitive processes. it w i l l   we hope  represent a new  important l i n k in the design/implement/test feedback loop that is so important to a l . 
