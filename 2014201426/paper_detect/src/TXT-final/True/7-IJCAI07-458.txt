
we introduce a human-computer interaction system which collaborates with a user by providing feedback during user activities. the goal of the system is to help a user complete a high-level activity that has been represented hierarchically. while a user is performing the high-level activity  our system analyzes what sub-events a user has already completed and what sub-events are needed next in order for the user to finish the activity. the representations of human activities are constructed using a previously developed context-free grammar based representation scheme. we focus on a game named 'pentagram game' to illustrate our system. in the experiments  our system shows the ability to guide the user to complete the 'pentagram game' by providing explicit feedback. the feedback not only contains atomic level instructions but also describes higher-level long-term goals of the composite activities. 
1 introduction 
humans understand the structure of activities  and they take advantage of this knowledge of structure when performing high-level activities. in the middle of performing a complex activity  humans know exactly what sub-events have already occurred and what sub-events need to be performed next. they explicitly or implicitly know what to do next  considering what they have done in order to achieve the goal in the past. for example  during a dance of an expert dancer  the dancer explicitly or implicitly knows what his/her next move should be. the dancer knows all his/her moves and their order in the dancing activity  and uses this knowledge during the dancing activity to decide various moves. 
　motivated by the ability of human experts  we design a human-computer interaction  hci  system which collaborates with a user to help the user complete high-level human activities. similar to human experts  the system has knowledge on the structure of the activity that the user wants to perform. our system has a representation of an activity which describes how the correct activity should look like temporally  spatially  and logically  and uses it to automatically guide the user to perform the represented activity. while the user is trying to perform the activity he/she wants to do  our hci system makes its own analysis on the current status of the activity being performed  and produce feedback. if the user does not perform the correct sub-event  the computer interface alerts the user to the mistake.  the goal is to enable the system to provide feedback  or advice  to the user based on its action representation and visual observations. 
　a hci system helping a novice in the task of tightening nuts while installing a car tire is a typical example that motivated the construction of our algorithm. the task is composed of multiple sub-events  tightening a single nut  which must follow a particular order: nuts must be tightened in the order that is similar to drawing a star. also  in this type of tasks  a user can undo sub-events  un-tightening a nut  to recover from his/her mistake. the detailed structure and characteristic of this activity is discussed in the section 1. our system has the ability to guide a user not only to perform sub-events in a correct order but also to undo sub-events when he/she made a mistake. our algorithm is designed to provide feedback to accomplish those activities as well as other general activities. 
　previous hci systems had mainly action-reaction based models. those systems recognize human actions and perform particular reactions already encoded in the system. research on intelligent environments is a typical example of these reactive systems. the goal of our system is a little different. the goal of previous reaction based hci systems is to provide correct reactions for corresponding actions  while that of our system is to guide and instruct how to make a whole high-level activity successful by providing feedback. reaction based hci systems are not suitable in our case. in order for reaction based hci systems to guide a user to perform represented activities containing concurrent as well as sequential sub-events  the system must specify all possible steps and branches of the order of sub-events; the number of cases becomes very large. in addition  the feedback provided by our system is hierarchical  which is difficult for reaction based systems to deal. 
　the main technical contribution made in this paper is on the algorithm to provide feedback  which estimates the internal states of the incomplete composite activity and predicts what sub-event is needed in order to complete the action. 
in the case of simple sequential models  such as finite state machines or hidden markov models  estimating which state and what to do is a simple task since they inherently contain the information on the next occurring sub-event. however  in the case of activities that can only be represented by highly complex models  such as full first-order logic  this is no longer a simple task. we use the human activity representation framework developed by ryoo and aggarwal . in activities consisting of concurrent sub-events  it is not easy to determine which point the system has reached  and what sub-event is urgently needed in concurrent activities. in addition  in highly complex activities  some sub-events might have an identical sequence in the beginning  confusing the system in its decision as to the status of the activity.  
1 related works 
the reactive systems mentioned in the introduction have similar aspects as our system. since coen  presented design principles of intelligent environments  several research projects constructed hci systems for intelligent environments  rooms  and workspaces  hassens et al.  1; kulkarni  1 . they introduced the concept of reactive behavioral systems  extending previous rule-based reactive systems. their main goal is to make the hci correctly respond to relatively simple user behaviors or actions within the activity context. 
　on the other hand  several works on surveillance and children monitoring systems attempted to recognize hierarchical human activities  minnen et al.  1; park and aggarwal  1; siskind  1 . most of those works only focused on after-the-fact detection of activities  and did not attempt to provide feedback to the user who is performing the activities. in the work done by ryoo and aggarwal   high-level human activities were represented hierarchically using context-free grammar  cfg  syntax  specifying temporal  spatial  and logical relationships among sub-events. their representation was similar to the first-order logic using allen's temporal predicates  allen  1   and recognition was done hierarchically. 
1 feedback 
the objective of our algorithm to provide feedback is as follows: given a situation where the user is in the middle of performing an action  the system must analyze which sub-events are already done and which sub-events need to be done. the explicit feedback must be provided finally  stating which sub-events are immediately needed and what is their appropriate starting time and ending time. 
　we assume that the system initially has the language-like representation of activities. we start with converting the representation of activities into a directed graph representation  which makes the system able to apply our algorithm. we then discuss principle theorems justifying our approach. finally  we present a general algorithm for providing feedback to hierarchical activities. the system must convey hierarchical structure of activities and generate hierarchical feedback. 
1 language-like representations 
in order for our hci system to provide feedback  the system must have a formal and complete representation of the activity that a user is trying to accomplish. we use ryoo and aggarwal's cfg-based representation syntax to construct a formal representation of activity by listing necessary temporal and spatial conditions. it is always assumed that the system has a programming language-like representation of the activity it wishes to recognize. 
example 1 let's look into a spinning move in figure skating as an example. spinning moves that figure skaters do are complex human activities  which involve both arm and leg movements. assume that our system wants to provide feedback  advice  to a skater to perform a common combination spin  a camel-sit spin. in a camel spin  a skater must spin with his/her leg and arm fully outstretched horizontally  into the general shape of a 't'. in a sit spin  the skater must sit while spinning. the camel-sit spin is a sequence of two spins: the skater must initially spin with a 't' shape  and then sit while spinning. our system must have the following cfg-based representation before applying our feedback providing algorithm: 
camel-sit spin person1  =    list  def 'a'  spin person1       list  def 'b'  sit person1         list  def 'c'  stretch arm person1    
 	 	 	 	 	 	 	def 'd'  stretch leg person1         	and  equals a  this   and  and  during c  a   during d  a     
	 	 	 	 	 	and  during b  a   
and  meets c  b   meets d  b          ; 
1 directed graph representations 
the language-like representation of activities is human-oriented. in order to estimate ongoing status of the activity and to generate proper feedback  our system converts a programming language-like activity representation into an internal directed graph representation automatically using the following algorithm. 
　in our directed graph representation  a vertex is a time point  either starting time or ending time of a sub-event   and an edge from vertex t1 to vertex t1 implies t1   t1. the purpose of this conversion is to calculate the necessary temporal ordering between times associated with an activity's sub-events. our feedback providing algorithm uses this directed graph representation of human activities  since the directed graph representation enables us to calculate the order of two time points easily. 
　the procedure to convert our cfg-based representation into a directed graph representation is presented below. 
　first  the system must convert allen's temporal predicates for time intervals into equalities and inequalities among time points. in our cfg-based representation  temporal relationships are specified as a logical formula of allen's temporal predicates. following the definition of temporal predicates  the representation can be converted into equalities and inequalities among time points as follows: 
let a and b be the time intervals   astart aend  and  bstart bend . 
equals a  b   	=  astart = bstart and aend = bend before a  b    	=  aend   bstart meets a  b   	=  aend = bstart overlaps a  b   =  astart   bstart and bstart   aend starts a  b    	=  astart = bstart and aend   bend during a  b   =  bstart   astart and aend   bend finishes a  b   =  aend = bend and astart   bstart 
　also  we add one trivial inequality astart aend for all time intervals a. as a result  logical concatenations of allen's temporal predicates are converted into logical concatenations of equalities and inequalities among time points. next  the system removes the predicate not  as follows. 
not t1 t1   	=  t1   t1 or t1 = t1 not t1=t1   	=  t1   t1 or t1   t1 
　the system then converts a logical formula into a disjunctive normal form  dnf . the end product is the disjunction of conjunctive clauses of pure equalities and inequalities. this suggests that the activity representation can be divided into several conjunctive clauses  where each clause presents necessary temporal conditions for the activity. there is no semantic difference between the dnf representation and the directed graph representation we plan to construct. for each clause  we formulate one directed graph to help the user visualize the representation. the system first calculates time points that are equal  checking the equalities in a clause. the system assigns one vertex for a set of time points which are equal. for example  if t1=t1 and t1=t1  only one vertex is assigned for a set {t1  t1  t1}. then  an edge is constructed from a vertex v1 to a vertex v1  if t1  t1 such that   t1 v1 and t1 v1 . what this directed graph representation suggests is that the activity can be completed if and only if an integer value is correctly assigned for each vertex while satisfying the temporal order of the graph. 
example 1 the language-like representation of the camel-sit spin  which we discussed in example 1  may be converted into a directed graph. first  the temporal predicates are converted into equalities and inequalities. 
 astart aend  and bstart bend and cstart cend and dstart dend  and astart=thisstart and aend=thisend and astart cstart and cend aend  and astart dstart and dend aend and astart bstart and bend   aend  and cend = bstart and dend = bstart  
　this already is a dnf composed of only one conjunctive clause. figure 1 shows a final directed graph representation of the example. 

figure 1: the directed graph representation for 'camel-sit spin'. edges  as  ae    as  bs    ce  ae   and  de  ae  are omitted in the graph.
 
1 consistent state and feedback 
this subsection describes principle definitions and theorems which justifies for our algorithm theoretically. 
　in our directed graph representation  analyzing the status of ongoing activity is identical to finding up to which vertices the user has assigned a correct value. since vertices correspond to the starting or ending times of sub-events  assigning values for vertices means that a user started and ended sub-events in those time points. we denote a set of assigned vertices as a state of the graph. 
　the system can calculate more than one possible assignment  i.e. state  in one situation. there might be multiple candidate assignments for each vertex  since sub-events can occur multiple times. in addition  the system might leave some vertices unassigned  leaving them to be assigned in the future. among many possible states  few of them satisfy the temporal order specified in the graph. we call those states consistent states. 
definition 1  assigned vertex  we define a vertex assigned vertex  if the system has assigned an identical value to all time points associated with the vertex. we define a vertex unassigned vertex  if the system did not assign any value to the time points associated with the vertex. we define a vertex half-assigned vertex  if the sub-set of time points in the vertex are assigned while the others are unassigned. 
definition 1  consistent state  let s be a set of assigned vertices in a graph g. let h be a set of half-assigned vertices in g. we say the graph g is in the consistent state with the assignment s and h if and only if 
1. v  w:  v  w  s h  v w if there exist a path from v to w  and 
1. v:  v 	 s    parents of v s  and 
1. v:  v 	 h    parents of v s  and 
　the consistent state implies that there is no contradiction among assigned values of the graph. the consistent state clearly shows up to which point the activity has been processed. from definition 1  we know that a graph without any assignment is also in a consistent state. among consistent states  the states which we are particularly interested in are maximum consistent states. if additional assignments based on currently provided time intervals are not possible for a consistent state  it is a maximum consistent state. 
　calculating the maximum consistent states of an ongoing activity is the key component not only for analyzing the status of ongoing activity  but also for providing feedback. we introduce two theorems which will lead us to use an iterative approach to find maximum consistent states. 
theorem 1 let u be a set of all vertices in a graph g in a consistent state. let v be a vertex  where v u-h-s and  parents of v   s. if we assign a value larger than  max of parents of v  to the entire time points in v  then g is still in the consistent state. if we assign the same value only to the sub-set of time points in v  making the v half-assigned  then g is still in the consistent state. 
theorem 1 let v be a vertex  where v h. if we make vertex v an assigned vertex by assigning identical values for all time points in v  then g is still in the consistent state. 
　iteratively updating consistent states using theorem 1 and 1 will lead us to the maximum consistent states. assuming that the system knows all starting times and ending times of sub-events  the system can check whether further update is possible or not. if possible  the system can assign the value of detected sub-events for corresponding vertex. the only constraint is that the starting time and the ending time of the same sub-event must match. for example  if there are two time intervals  1  1  and  1  1  for the sub-event a  the system cannot assign 1 for as and 1 for ae. this can be checked by applying either a dynamic programming algorithm or an algorithm which traverses back when adding the ending time of a sub-event. the resulting time complexity is either linear time or quadratic time in each case. 
algorithm to calculate maximum consistent states 
1 initialize all vertices in the graph as unassigned vertices 
1 do 
1 apply theorem 1 and 1 to find a vertex v 
1 make v an assigned vertex or a half assigned vertex accordingly 
1 update v.value as a list of possible assignments 
1 for all i  
1 update v.value i .p as a list of assignments of parent vertex which is less than v.value i . 
1 if v.value i  is an ending time of a sub-event  
1 traverse back the graph using value and value i .p of ancestors of v to check the 
starting of the sub-event was assigned 
1 if not  remove v.value i  from v.value 
1 while v  nil 
1 return assignments of the graph 
　even though maximum consistent states do not have any contradiction among their assignments on vertices  it does not imply that the future assignments without any contraction are possible. therefore  we must calculate maximum valid consistent states based on the maximum consistent states. 
definition 1  valid consistent state  we call a consistent state as a valid consistent state  if it has at least one possible combination of future assignments that satisfies temporal relationships among vertices. the maximum valid consistent states are the valid consistent states which do not have other valid consistent states containing them. 
algorithm to calculate maximum valid consistent states 
1 for each maximum consistent state with the assignment 
s and h  
1 s' = s ; h' = h 
1 do  
1 find as	v such that 
{v s'   ae is not assigned  ae = current time point    ae is assigned for v' h'  ae current time point  } {v h' as current time point} 
1 s' = s' -  as 	 descendent of v  
1 h' = h' -  as 	 descendent of v  
1 while as 	 nil 
1 return set of all s' and h' 
　after calculating maximum valid consistent states  the system can provide feedback to the user. the feedback is one-step look-ahead information of the activity. by applying theorem 1 and 1 once more to calculated maximum consistent states  the system is able to see what sub-events are needed next in what time interval. 
1 hierarchical feedback algorithm 
the actual algorithm for feedback providing is described in this subsection  especially focusing on the hierarchical aspect of our feedback. 
　most high-level human activities have hierarchical structures; sub-events also have their own sub-events. this implies the system needs a hierarchical algorithm to recognize time intervals of sub-events  and suggests that hierarchical feedback is needed. 
　therefore  a recursive algorithm is designed  where the base case is the feedback providing for atomic actions  directly telling the user to do the atomic action . for composite activities  the system analyzes sub-events' temporal structures using our directed graph representation of the activity  and tells the user to start or end a particular sub-event  by applying the algorithm presented in subsection 1. if that sub-event is an atomic action  then the system can simply tell the user to do the action. if that sub-event itself is a composite activity  the system must tell the user how to complete that sub-event also. that is  the system must examine sub-events of the sub-event to provide hierarchical feedback. this process continues until the atomicity is gained. 
example 1 let's look into the spinning moves in figure skating once more. assume that a user wants to perform the camel-sit/sit spin. we already defined what the camel-sit spin is and what the sit spin is. the camel-sit/sit spin is a combination of the camel-sit spin and the sit spin  where the skater changes his/her axis feet between two spins. we can set the sub-events of the camel-sit/sit spin to be the camel-sit spin and the sit spin. assume that the system wants to provide feedback when the user just started to spin at time 1. applying the approach presented in subsection 1 will result with the system telling the user to 'start the camel-sit spin  after 1+'. however  that information is not sufficient. the system must explicitly specify how to start the sub-event also  as follows: 
1. in order to do a camel-sit/sit spin at  1  1+   do the camel-sit spin at  1  1+  
1. in order to do a camel-sit spin  1  1+   do a stretch  arm at  1+  1+  and do a stretch leg at  1+  1+ . 
1. stretch arm and stretch leg are atomic actions  so do them now. 
　we always assume that the system knows time intervals of sub-events already occurred by using the recognition algorithm for the cfg-based representations. further  we also assume that the system knows the starting time of a sub-event as soon as the sub-event started. that is  for each sub-event  the system has a list of time intervals which specifies previous occurrences of the sub-event  and has candidate starting times of the sub-event that are not completed. 
algorithm to provide hierarchical feedback: 
1 using previous recognition algorithms for the cfg-based representation  find all possible starting times and ending times of sub-events 
1 convert the cfg-based representation into directed graph representations 
1 find the maximum valid consistent state closest to goal 1 apply theorem 1 and 1 once more to construct feedback. when to start or end the corresponding sub-event is specified 
1 if the sub-event from step 1 is a composite itself  apply the same procedure from step 1 to the sub-event 
1 return the concatenated feedback 
1 experiments 
we focus on the activity named 'pentagram game' for the experiments. the 'pentagram game' is a composite action  a sequence of moving or removing stones in a particular place  similar to the activity of tightening the tire of a car. for our experiments  we define three types of atomic actions that take two parameters: move stone person1 place1   remove stone  person1  place1   and basic safe person1  place1 . the first atomic action describes a person1 moving a stone to place1. the seconding atomic action describes a person1 removing a stone from place1 and placing it to somewhere else. the last atomic action describes that a person1 did not perform any action related to place1. for the notational convenience  we will simply write move stone person1  place#  as 'move#'  since only one user is moving the stones. our system detects the starting time and ending time of the atomic actions using the computer vision techniques. 
　in order to make the high-level activity 'pentagram game' successful  the user must place all stones in the locations following a particular order. figure 1 describes the order of the activity 'pentagram game'. one important characteristic of the 'pentagram' is that the user can always remove stones to go back to previous the state  which makes the activity more complex than it seems to be. for example  following the sequence of atomic actions satisfies the 'pentagram game' activity: move1-move1-remove1-move1-move1-move 1-move1. even though move1-remove1 was interrupted in the original sequence m1-m1-m1-m1-m1  this also is a 'pentagram game' activity since the person removed the stone from place1 before other moves. before defining the composite activity 'pentagram game'  we need to define move followed by remove  such as m1-m1-rm1-rm1. we name this activity as a composite activity safe person1  stone1  place1  place1  place1  place1  place1 . when playing 'pentagram game'  'safe' activity can be inserted between correct moves. 
　therefore  the 'pentagram game' will be composed of five 'move stone' atomic actions  and five 'safe' composite activities: safe-m1-safe-m1-safe-m1-safe-m1-safe-m1. our language-like representation for the activity 'pentagramgame' is as follows. the actual representation of the 'safe' is omitted due to the limitation of space. 
　pentagramgame person1  place1  ...  place1  =    	 	list   def 'x1'  move stone person1  place1    

figure 1: the illustration of the setup for 'pentagram game'. there are five locations: place1  place1  ...  and place1. black stones are to be placed on each location. if the placement is done in correct order from 1 to 1  then the activity 'pentagram game' is complete. otherwise  if in an incorrect order  the activity is incomplete. note that the user can freely remove placed stones when he/she thinks the placement is wrong. 

figure 1: the directed graph representation for 'pentagramgame'. the dotted vertices are unassigned vertices or half-assigned vertices.
 	 	 	def 'x1'  move stone person1  place1     	 	 	def 'x1'  move stone person1  place1     	 	 	def 'x1'  move stone person1  place1     	 	 	def 'x1'  move stone person1  place1     	 	 	def 's1'  safe person1  place1  ...  place1     	 	 	def 's1'  safe person1  place1  ...  place1     	 	 	def 's1'  safe person1  place1  ...  place1     	 	 	def 's1'  safe person1  place1  ...  place1     	 	 	def 's1'  safe person1  place1  ...  place1       and    
starts 'this'  'x1'   finishes 'this'  'x1'   meets 's1'  'x1'   meets 'x1'  's1'   meets 's1'  'x1'   meets 'x1'  's1'   meets 's1'  'x1'  meets 'x1'  's1'   
meets 's1' 'x1'   meets 'x1'  's1'   meets 's1'  'x1'    
 ; 
　we shot a video of users doing the 'pentagram game'. some of them performed a complete sequence of successful activities  while others were stopped in the middle of an activity. for some sequences  mistakes were intentionally made  such as inserting move1-move1 after initial move1. the purpose of these erroneous insertions was to test whether our feedback providing algorithm can correctly guide the user to complete the overall activity. for example  if we fed the input sequences of move1-move1-move1  the system must guide user to start remove1 and start remove1. 
　videos taken by the sony vx-1 were converted to a sequence of frames with a frame rate of 1 per second. each 

figure 1: the raw sequence of input images. the 'pentagram game' activity 	is 	completed 	in 	the 	following 	order: 	move1safe move1-remove1 -move1-move1-move1-move1.. 
recognition results: 

feedback provided at time point 1: 
objective: pentagramgame  1  1+  
 safe  1  1+  
  safe1  1  1+  
   undoing1  1  1+  
    remove1  1+  1+  therefore  do remove person1  place1  now. 
figure 1: the recognition results of the input shown in figure 1. output of feedback providing system at time point 1 is also provided. the system clearly states hierarchical feedback. 
frame has a resolution of 1. from the raw visual input sequences  starting times and ending times of the atomic actions were recognized automatically. recognized atomic actions were coupled with time intervals  making the recognition and feedback providing of composite activities possible.  because of the simple domain  the recognition rate for atomic actions 'move stone' and 'remove stone' were 1. the stone blobs were clearly detected and tracked. as a result  the system was able to correctly recognize the activity 'pentagram game' regardless of the number of atomic actions.  
　based on the perfect recognition of atomic actions  our new feedback providing algorithm was tested. figure 1 and 1 shows the feedback generated as the sequence of input frames were given. the feedback contains hierarchical information. the feedback starts from telling the objective time intervals of a high-level activity that the user wants to accomplish. then  the system states what sub-event must be started or ended in order to accomplish the activity. for example  in figure 1  the system informs the user in what time interval the composite activity 'pentagram game' must be done. then  the system mentions the composite activity 'safe' is needed in time interval  1  t 1   in order to perform 'pentagram game' in the time interval  1  t 1 . the 'undoing' activity is needed in time interval  1  t 1   and finally  the atomic action 'remove' is needed in time intervals  t1  t1  to complete 'undoing'. 
1 conclusions and future works 
　the contribution of this paper is the framework and the algorithm to provide feedback for ongoing activities. the feedback contains simple instructions to start or end one sub-event of the activity  and it also contains instructions on how to start or end the sub-event itself. based on the previous cfg-based representation and recognition of the activity  the system estimates the state of activity correctly  and calculates what sub-event must happen next. this is a novel human-computer interaction system based on the computer vision. the ability to provide feedback for complicated activities represented in terms of time intervals distinguishes our work from other works on temporal planning using temporal networks. in future  we plan to test our system on more complex domains. 
