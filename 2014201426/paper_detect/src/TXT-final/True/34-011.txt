 
an important component of mechanical theorem proving systems are unification algorithms which find most genaral substitutions which  when applied to two expresssions  maka them equivalent. functions which are associative and commutative  such as the arithmetic addition and multiplication functions  are often the subject of mechanical theorem proving. an algorithm which unifies terms whose function is associativa and commutative is presented here the algorithm eliminates the need for axiomatizing the associativity and commutativity properties and returns a complete set of unifiers without recourse to the indefinite generation of vurianu and instances of the terms being unified required by previous solutions to the problem. 
introduction 
       at the core of many theorem proving systemi is a 
       unification algorithm which returns for a pair of input expressions a set of unifying substitutions  assignments to the variables of the expressions which maka tha two expressions equivalent. typical is the unification algorithm of robinson  for unifying atomic formulas of the first order predicate calculus in resolution theorem proving . 
       this work treats the case of unifying terms of the first order predicate calculus where the function is associative and commutative such functions are mathematically important and thus of interest to developers of theorem proving programs examples of such functions are the arithmetic addition and multiplication functions. 
       the case where the function is simply commutative is easily handled by a trivial extension to robinson's unification algorithm which unifies the arguments of one term against permutations of the arguments of the other term. 
       the case where the function is simply associative is quite difficult and we know of no general solution suggestive of the difficulty of this problem is the fact that there may be an infinite number of unifiers for a pair of terms. for example  the terms t xa  and f ax  where f is associative  a is a constant  and x is a variable has unifiers with x=a  x=f aa   x f aaa   ...  we represent the argument lists of associative functions with no extra parentheses  i.e.  f abc  rather than f af bc   or f f eb c .  
two principal approaches to handling associativity or 
*research supported by the national science foundation  gj-1  and by the advanced research projects agency of the secretary of the office of defense  f1o-1-c-1 . 
commutativity are available. the first  standard approach is to represent the terms conventionally  i e.  f af bc   or f f ab c  rather than f abc   and axiomatize the associativity or commutativity property. the associativity axiom would be f xf vz =f f xy z  and the commutativity axiom would be f xy=f yx . these axioms could be applied using some equality inference rules such as paramodulation  
       the second approach represents associative functions as functions with an arbitrary number of arguments  i.e.  uses f abc  rather than f af bc   or f f ab c  special purpose unification algorithms are provided tor terms whose functions are associative  commutative  or both. examples of this approach in first order predicate calculus theorem proving are the work of nevins  and slagle  the algorithms for associativity  and for associativity and commutativity are incomplete  i.e.  they fail to return all the unifiers in some cases. an example of this approach in the area of programming languages for problem solving is the use of the associative data type tuple or vector and associative and commutative data type bag in the qa1 and qlisp languages  1  again  in this case the algorithms for pattern matching  unifying  these expressions are incomplete in both these cases  the incomplete algorithms can be augmented by a process which alters the input expressions to cause the unification algorithm applied to the altered expressions to return additional unifiers the addition of this process  slagte's widening operation for the first order predicate calculus  and stickel's variable splitting operation for expressions of qa1 and qlisp   results in completeness. widening and variable splitting are both operations that must be performed on one or both input expressions an arbitrary number of times  replacing single variables of the expressions uniformly by two variables; it i: essentially  repeated  paramodulation by the functionally reflexive axiom. 
       an example of the latter approach is the unification of f abz  and f xy  where f is associative and commutative. the special purpose unification algorithm would fiurn the unifiers 
{x -e  y -f bz }  {x -b  y - az    {x -z  y -f ab }  {x -f bz   y -a   {x -f az   y -bh and {x - ab   y -z . but this is an incomplete set of unifiers since the possibility that the value of z is not wholly contained in either the value of x or the value of y is not represented. after performing a widening operation on f abz  resulting in f abz1  by instantiating z by   z1 . additional new unifiers such as |x -f azj   y -f bz* * z -f z|z1   and {x -t abzj   y -z1  zh i|z1 } ire returned by the unification algorithm. 
related to this approach  though different in detail  is 
plotktn's work on the theory of building in equational theories  of which associativity and commutativity are examples. in the case of associativity  plotkin retains terms in a normal form: right associative form  although it could equivalent  have been our unparenthesized form. his equivalent of the widening rule  the replacement of a variable by two new variables  is applied continually inside the unification 
1 

algorithm rather than being used outside it. thus his generalization of 1  if there  xists a substitution i such that unification algorithm may generate an infinite number of t f c . 
unifiers as opposed to a unification algorithm guaranteed to produce a finite number of unifiers and a potentially infinite similarly  substitution 1 is an instance  generalization  process  widening  for altering inputs to the unification of substitution v if  for every term t  t# is an instance algorithm to obtain additional unifiers. the difference in  generalization  of t r approaches seems to be principally one of organization of the search process. 
tht ac unification algorithm 
　　　　in this paper  we present a new special purpose unification algorithm which we call the ac unification we present here an algorithm for unifying two terms algorithm for terms whose functions are associative and whose function is associative and commutative terms will be 
	commutative which returns a complete set of unifiers 	this 	represented as if the function had an arbitrary number of 
	algorithm eliminates the need for axiomatizing associativity 	arguments with no superfluous parentheses. 
and commutativity and also eliminates the cost of continually applying 	these 	axioms 	which 	often 	results 	in 	much 
we will assume that the argument lists of the two 
unnecessary or redundant computation. it also eliminates the terms being unified have no common arguments. this 
need for using the process of widening or variable splitting presents no difficulty since no unifiers are lost and efficiency 
whose necessity  for discovering a complete set of unifiers in is gained if common arguments are eliminated immediately. 
the case of unifying any particular pair of expressions  is 
this is done by removing common arguments a pair at a time  
difficult to ascertain. 
one from each of the argument lists for example  before unifying  and kbbbcz   the b's common to the two terms are removed yielding f xxyac  and f bbcz   and the c's 
tarminoioty common to the two new terms  rm removed yielding f xxya  and f bbz . an example of the utility of immediately 
	definition 	a tarm is defined to be 	removing common arguments is the unification of f g x y  and 
 1  a constant  		common to the two terms are 
 1  a variable  or 	immediately removed  the unification algorithm will return the 
 1  a function symbol succeeded by a list of terms  the most general unifier  if the common g x 's are arguments of the function . retained  unification will likely result in the generation of the 
                                                                             additional less general unifier we shall use the symbols a  b  and c to represent constants  x  y  and z  possibly indexed  to represent the algorithm will be expressed partially in terms of variables  and f to represent a function which is associative an algorithm for the complete unification of terms with an end commutative. associative and commutative function with only variables at arguments. the result of unifying such terms is an definition a substitution component is an ordered pair assignment to each variable of the terms some sequence of of a variable v and a term t written as v -t a substitution terms each variable is assigned a term t   whose function component denotes the assignment of the term to the symbol is not f  or a term  occurrences variable or the replacement of the variable by the term. of term t  as arguments of f . for such an assignment to be a 
unifier  the only requirement is that for each term t  used in 
       delinition a substitution is a set of substitution any assignment there are the same number of occurrences of components with distinct first elements  i.e.  distinct variables that term occurring as arguments of f in each of the unified being substituted for. applying a substitution to an terms instantiated by the assignment for example  in expression results in the replacement of those variables of unifying  if term t is part of some the expression included among the first elements of the assignment to one of the variables  then 1 times the number 
	substitution components by the corresponding terms. 	the 
of occurrences of t in the assignment for x| plus the number 
	substitution components are applied to the expression in 	us
	of occurrences of t in the assignment for  1 p'	 the number 
parallel and no variable occurrence in the second element of of occurrences of t in the assignment for xq must equal 1 
a substitution component will be replaced even if the variable times the number of occurrences of t in the assignment for 
occurs as the first element in another substitution component. yj plus the number of occurrences of t in the assignment for 
substitutions will be represented by the symbols r and 1. 
	y1 	for 	example  
the application of substitution to expression a is denoted by as the composition of substitutions denotes the y1*-f aabbb   is ＊ unifier of substitution whose effect is the same as first applying there are 1 a's and 1 b's in the instantiations of f xix|x1x 1   end with the unified term being f aabbbbb . substitution s  then applying substitution v  i.e.  a ##     af # for every expression a. 
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　with each pair of terms with an associative and commutative function with only variable arguments is daftmtian a umtxini substitution or uoiiuu of two associated a single equation representing the number and expressions is a substitution which when applied to the two multiplicity of variables in each term. for example  the expressions results in equivalent expressions. in ordinary equation  is associated with the pair of unification  two expressions are equivalent if and only if they terms given above. this equation succintly represents the 
are identical. in unification of argument lists of commutative condition for a substitution to be a unifier: that the sum of the 
functions  two expressions are equivalent if they have the number ol occurrences of any term in the value of each 
same function symbol and the same arguments in the same or variable multiplied by the multiplicity of the variable in the 
different order. term must be equal for the two terms. 
	definition 	term s is an incunte of term t  and t is a 
non-negative integral solutions to such equations can 
1 

be used to represent unifiers. the solutions must be note that if a variable could have as its value zero non-negative integral since each variable must be assigned a terms rather than one or more terms as in the first order non-negative integral number ol occurrences of each term. predicate calculus  it would be unnecessary to form this subset of 1n  where n is the number of solutions  sums. only 
       in order to generate all the solutions to the problem of the sum of all the solutions would be required since any unifying the two terms  it is necessary to be able to variable present in this sum could have value zero  and the represent all the solutions to the equation derived from the variables in the corresponding unifier could be matched terms  every non-negative integral solution to the equation against zero terms. this is the situation wifh fragment is representable as a sum of elements of a particular finite variables in the bag data type in qa1 and qusp  1   see set of non-negative integral solutions to the equation  i.e.    every non-negative integral solution to the equation is a sum 
 equivalently  a sum with non-negative integral weights  of to be more precise in the definition of the algorithm  elements of a particular finite set of non-negative integral the algorithm consists of the following steps: 
solutions. the finite set of non-negative integral solutions by whose addition the entire non-negative integral solution 1. form an equation from the two terms where the coefficient space is spanned is generable by generating in ascending of each variable in the equation is equal to the multiplicity of ordor of value solutions to the equation  eliminating those the corresponding variable in the term. 
solutions composable from those previously generated. this process can be made finite by placing a bound on the 1. generate all non-negative integral solutions to the maximum solution value which will be used; such a maximum equation eliminating all those solutions composable from other is proved in a later lemma to eliminate no needed solutions. solutions. 
1 associate with each solution a new variable. 
1. tor each sum of the solutions  no solution occurring in the sum more than once  with no zero components assemble a unifier composed of assignments to the original variables with as many of each new variable as specified by the solution element in the sum associated with the new variable and the original variable. 
       now we present the complete algorithm for unifying general terms with associative and commutative functions using the algorithm for the variable only case above. we are 
       associated with each solution above is a new variable here concerned with terms whose function is associative and  in the rightmost column . the assignment of as many commutative with arbitrary arguments  i.e.  arguments that occurrences of that variable as specified in the solution to may contain ordinary  non-associative  non-commutative  each of the variables of the original term results in a partial functions or f or other functions which are associative and solution to the unification of the the original terms in commutative. we assume the presence of ordinary unification particular  the assignment of 1 occurrences of variable 1-* to to deal with those aspects of the unification problem not dealt x1 and i occurrence to yj results in an equal number of with explicitly here. 
occurrences 	of 	variable 	z-j 	in 	each ol 	f x|x|x1  	a n d 
myiy1  	first  when unifying two terms  two new terms with only variable arguments are formed by uniformly replacing 
　　　　every non-negative integral solution to the equation is distinct arguments by new variables. these new terms have a  non-negative integer weighted  cum of the 1 solutions only variable arguments and aer generalizations of the presented above  i.e.  %vry solution is representable as original two terms. for example  in unifying f xxya  and 
f bbz   we form generalizations with substitution 
	however  not every solution to the equation is a 	instantiating the new terms to the original terms. 
solution to the unification problem for which the equation was derived. there is an additional constraint that each variable next  using the previous algorithm for the variable of the original terms must be have at least one term in its only case  we unify the generalizations of the original terms. 
value; it cannot have zero terms in its value. this has already been done for the example above resulting in 1 unifiers as stated previously. 
　　　　hence  we must form that subset of the 1  1 sums for which each element of the 1uple is non-zero.  it is not now we have the generalizations of the two original necessary to consider sums in which any solution has a terms  a substitution to instantiate them to the original terms  coefficient other than 1 or 1 since such solutions  in the and a complete set of their .unifiers. every unifier of the unification problem  are already representable since the original terms is a simultaneous instance of the substitution to solution's inclusion with coefficient 1 introduces a variable instantiate the generalizations to the original terms and a which can have as its value an arbitrary number of terms as unifier of the generalizations. so all that is necessary to get arguments of f thus simulating the case of the coefficient all the unifiers of the original terms is to unify  for each being greater than 1.  there are 1 such sums including for variable being substituted  or  the value in the substitution example  representing the sum by the set of its indices  and the value in the unifiers. 
       in the example  x1 must have value a and y1 must have value b. thus  any unifier of  and 
1 

　　　　stnce x1 and y1 of the variable only cast correspond to a and b respectively  and a and b are not unifiable  any sum including solution 1 to the equation can be excluded from consideration since it would require  as in  1  and  1  above  the unification of a and b. as with the constraint on variables corresponding to non-variable terms not being assigned more than one variable  terms of the form f ...   in the variable only case  this latter constraint on solutions can be applied during the generation of unifiers in the variable only case rather than afterwards. elimination of solution 1 before generation of the 1n sums  and elimination of sums which do not meet the first constraint would result in the formation only of unifiers  1    1    1   and  1  of the variable only case  each of which has a corresponding unifier in th  general case. 
       more precisely  the algorithm consists of the following steps: 
1. form generalizations of the two terms replacing each distinct argument by a new variable. 
1. use the algorithm for the variable only case to generate unifiers for the generalizations of the two terms. the variable only case algorithm may be constrained to eliminate the generation of unifiers assigning more than one term to variables whose value must be a single term  and the generation of unifiers which will require the later unification of terms which are obviously not unifiable. 
1. unify for each variable in the substitution from step 1 and the unifiers from step 1 the variable values and return the resulting assignments for variables of the original terms. this is a complete set of unifiers of the original terms. 
proof of termination. soundness  and completeness of tha ac unification algorithm 
	we 	will 	first 	establish 	the 	validity 	of 	eliminating 
1 

lcm a1 b1   the solution involving only xi and yj can be subtracted from the solution with value k leaving a non-negative integral solution as result. but this difference solution has value    k and is thus composable 
from solutions with value less' than or equal to therefore  the solution with value k   m*lcm a1 b1  is the sum of some solution involving only x  and y. with value less than or equal to lcm a1 b1  and some other set of solutions with value less than or equal to m*lcm a| bj  and the lemma is true for this case. qed. 
       the lemma proves an upper bound on solution values that must be examined in the determination of a complete set of non-negative integral solutions which span the non-negative integral solution space by addition we believe that tighter bounds can be proved. although a proof for a tighter bound would be desirable  it should be noted that a lower proven bound would not reduce the number of found solutions theoretically necessary  but only decreases tha cost of computing them  and would have no effect on the form or number of unifiers returned by the algorithm this it true since any additional solutions discovered using a higher bound than necessary must be composable from solutions bounded by any proven lower bound and would therefore be recognized as redundant and be omitted 
　　　　the maximum of the least common multiples of the coefficients one from the left side and one from the right side of the equation is a lower bound on solution values which must be examined  i. e.  solutions with at least this value must be examined. this is because one of the needed solutions not otherwise generabie is the solution involving only the variables with those two coefficients with maximum least common multiple and having value equal to the maximum least common multiple 
       theorem the ac unification algorithm for terms with associative and commutative function with only variables as arguments always terminates  is sound  returns no substitutions which are not unifiers   and is complete  every unifier is an instance of a returned unifier . 
　　　　proof. the algorithm is guaranteed to terminate since it performs a finite number of operations on the finite number of non-negattve integral solutions generated from the equation corresponding to the two terms. the generation of these solutions is finite due to the trial solution values being bounded. 
       the algorithm is sound since each solution of the derived equation causes the introduction into each of the instantiated terms of an equal number of new variable occurrences thus  the two instantiated terms have the same number of occurrences of each new variable and are therefore unified. 
　　　　any unifier must assign to each variable a term of the form ti  whose function symbol is not 1 or a term 
f t1 n1  ..t m m   with ni occurrences of term ti as arguments of f . 	let k be the cardinality of the set of such terms ti in any solution to the unification of a pair of terms with only variables as arguments. 	the two instantiated terms must have an equal number of occurrences of each of these k terms 	as 	arguments 	of 	1. 	that 	is  	where 	m 	is 	the 
number of distinct variables in the first term being unified  n is the number of distinct variables in the second term  a. is the multiplicity of the jth variable in the first term  b. is the multiplicity of the j i n variable in the second term  cji is tha number of occurrences of term i in variable j in ine first term  and dij is the number of occurrences of term i in variable j in ine second term 
	a 	solution 	t o 	tha 
equation 	corresponding to the terms being unified. it can thus  according to the lemma  be formed as the sum of certain non-negative integral solutions to the equation weighted by positive intagers 
       consider the unifier corresponding to the sum of all those solutions to the equation which are required in the formation of any of the tuples  we will show that the hypothesized unifier is an instance of this unifier returned by the algorithm 
　　　　include in the value of the new variable associated with each of these solutions a number of occurrences ot term i equal to the coefficient of the solution in the weighted sum this will result in the proper assignment of c . occurrences of term i to each variable j of the first term ana dij occurrences of term i to each variable j of the second term 
       do this for each of the k terms in the solution. 	let no other or additional terms be included in the values of the new variables. 
　　　　this assignment of terms in the solution to new variables associated with equation solutions generated in the unification process results in the correct number cj; or dj; of each term being assigned to each variable of the original two terms. 
       thus  any solution to the unification of two terms with only variables as arguments is an instance of a returned unifier and the algorithm is complete. qed. 
       theorem the ac unification algorithm for general terms with associative and commutative function always terminates  is sound  and is complete. 

　　　　unifying each c  with each dj of a returned unifier e of s and t results in  by the assumption of termination  soundness  and completeness of the recursive call on the unification algorithm for terms of lesser complexity  a complete set of unifiers for the original terms s and t. qed. 
1 

conclusion 
       we have presented an algorithm for unifying general terms with associative and commutative function. we have proven that the algorithm is guaranteed to terminate  is sound  and is complete. 
   ... the advantages of this algorithm as compared to other approaches to unifying such terms are that the associativity and commutativity properties need not be axiomatized and that all the unifiers of a pair of such terms are immediately returned eliminating the unnecessary and redundant computation often occurring in other approaches which generate only some of the unifiers at each step with no indication of when all the unifiers have been generated. 
bibliqjfiohy 
1 chang  c. l and lee  r. c. t. symbolic l ogic and mechanical theorem proving. academic press  new york  1. 
1 nevins  a. j. a human oriented logic for automatic theorem proving j. acm 1  1  oct 1   1 
1 plotkin  g. d. building-in equational theories. in meltzer  b. and michie  d.  eds . machine intelligence 1  edinburgh university press  edinburgh  1  pp. 1. 
1 reboh  r. and sacerdoti  e. a preliminary qlisp manual. technical note 1  artificial intelligence center  stanford research institute  menlo park  calif  aug 1 
1 robinson  g and wos  l paramodulation and theorem-proving in first-order theories with equality. in meltzer  b and michie  d  eds . machine intelligence 1  edinburgh university press  edinburgh  1  pp. 1 
1 robinson  j. a a machine-oriented logic based on the resolution principle j. acm i1t i  jan 1   1. 
1 rulifson  j. f  oerksen  j a and waldinger  r. x qa1: a procedural calculus for intuitive reasoning. technical note 1  artificial intelligence center  stanford research institute  menlo park  calif.  nov. 1. 
& 	slagle  j. r. automated theorem-proving for theories with simplifiers  commutativity  and associativity. j. acm 1  1 
 oct. 1   1 
1 stickel  m. e. unification algorithms for artificial intelligence languages. chapter of incomplete ph.d. dissertation  department of computer science  
carnegie-mellon university  pittsburgh  penn. 
