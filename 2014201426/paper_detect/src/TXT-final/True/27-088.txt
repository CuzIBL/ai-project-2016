 
the bulk of previous work on goal and plan recognition may be crudely stereotyped in one of two ways.  neat  theories - rigorous  justified  but not yet practical.  scruffy  systems - heuristic  domain specific  but practical. in contrast  we describe a goal recognition module that is provably sound and polynomial-time and that performs well in a real domain. our goal recognizer observes actions executed by a human  and repeatedly prunes inconsistent actions and goals from a graph representation of the domain. we report on experiments on human subjects in the unix domain that demonstrate our algorithm to be fast in practice. the average time to process an observed action with an initial set of 1 goal schemas and 1 action schemas was 1 cpu seconds on a sparc-1. 
1 	introduction and motivation 
plan recognition  e.g.  kautz  1; pollack  1   is the task of identifying an actor's plan and goal given a 
partial view of that actor's behavior. we have focused on identifying the actor's goal. there are several potential applications for an effective goal recognizer. goal recognition is useful for enhancing intelligent user interfaces  goodman and litman  1 . furthermore  a goal recognizer would allow an autonomous agent to provide useful services to the people it interacts with  such as completing their current tasks and offering advice on how to better achieve future goals. this paper describes a goal recognition module. we do not consider how to integrate a goal recognizer into an agent's architecture. 
¡¡in our scheme  the system observes the actor executing a sequence of actions. the actor does not necessarily know she is being observed  this is keyhole recognition . 
the system attempts to identify the actor's goal as early 
    many thanks to denise draper  terrance goan  robert goldman  steve hanks  henry kautz  nick kushmerick  diane litman  mike perkowitz  rich segal  tony weida  and dan weld for comments and discussion. special thanks to keith golden and mike williamson for their ongoing supply of critique and coffee. this research was funded in part by office of naval research grant 1-j-1 and by national science foundation grant iri-1. 
1 	planning 
as possible. 	what does it mean to identify the actor's goal  to attribute a goal to an actor is to predict that the actor's actions  both observed and unobserved  will be the execution of one of the plans for that goal. the actor's goal may be a conjunction of various goals such as  taking out the trash and fixing the car . 
   the following scenario illustrates the sort of conclusions we want our goal recognizer to produce. the observed actor is a computer user  entering commands into a unix shell. suppose we observe: 
 cd /papers 
there are many plausible goals at this point. the actor might be searching for a particular file. or perhaps she wants to know how much memory is used by the /papers directory. but her goal is not to find a free printer. nor is she reading her mail. why bother to change directories for these goals  changing directories is irrelevant to these goals and we assume the actor does not execute irrelevant commands. if we allowed arbitrarily many irrelevant actions then we could not predict the actor's goal because all the observed actions might be unrelated to her goal. suppose that we next observe: 
 ls 
	paper.tex 	paper.ps 
the second line is the output from i s . the goals we previously rejected are still rejected. let's reconsider the goal of determining the memory usage of /papers. the optimal approach is to execute du instead of i s . if actors acted optimally  we could reject this goal. but actors do not always act optimally. this actor may next execute is -1 on paper.tex and on paper.ps and add the memory usages of the files together. thus  is may be part of a suboptimal plan to determine the memory usage of /papers. now we observe: 
        grep m o t i v a t i n g paper.tex we now reject the memory usage goal. we also reject the goal of searching for a file named paper.tex because the grep command does not contribute to it. the actor might  however  be looking for a file that contains  motivating  or perhaps for a file that contains  motivating  and is named paper.tex. 
   in the following sections we articulate the definitions  assumptions  and algorithm we use to express  justify  and produce these conclusions. although we validate our system in unix  our algorithm and formal results are domain independent. 

1 	overview of the paper 
our objective is to build a goal recognizer that performs well in large  real domains. we need a way to quickly determine if a goal is inconsistent with the observed actions. informally  a goal is inconsistent with the observed actions if the actor could not possibly have executed the actions as part of a plan to satisfy the goal. to determine consistency  we must reason about all plans for each candidate goal. to reason tractably  we borrow techniques for constructing and manipulating graph representations of planning problems  originally developed to produce search control for generative planners  etzioni  1; smith and peot  1 . by analyzing interactions among the actions  action schemas  and goal schemas in our consistency graphs  defined below   we detect cases where no valid plan exists for a goal. 
   most plan recognition algorithms run in exponential time and have not been shown to perform well on large problems. in contrast: 
  our algorithm is sound  never rejects a goal g unless our assumptions entail that g is not the actor's goal  and runs in polynomial time in the size of the input goal recognition problem. this input is smaller than the corresponding input to most plan recognizers. 
  our implementation is fast. we have tested our sys-tem on data collected from human subjects in the unix domain. the average time to process an observed action with an initial set of 1 goal schemas and 1 action schemas was 1 cpu seconds.1 
in our formulation  goal recognition is semi-decidable. it follows that our polynomial-time algorithm is incomplete  i.e. it is not guaranteed to reject every inconsistent goal. in our experiments  however  the algorithm rejects most inconsistent goals. 
   this paper is organized as follows. section 1 defines our terms  the input and output of a goal recognizer  and states our assumptions. section 1 introduces consistency graphs  describes our algorithm  and works through an illustrative example. section 1 describes our empirical validation. finally  sections 1 and 1 discuss related work  the limitations of our system  and future work. 
1 	problem formulation 
we begin with the informal story. the actor constructs and then executes a plan to solve her current goal. although plans may contain conditionals  the observable behavior that results from the execution of any plan is a 
sequence of actions. the system observes a prefix of this action sequence. a plan is consistent with the observed actions a iff that plan has an execution with prefix a. a goal is consistent with a iff there exists a consistent plan for that goal. a key question is what constitutes a plan for a goal  we assume the actor constructs plans without any irrelevant actions. we further assume the actor constructs plan p for goal g only if p might achieve g 
:
¡¡¡¡the data we have collected is publicly available. send mail to neal cs.washington.edu for details. 
given the actor's beliefs about the world. this assumption suggests the system has access to the actor's beliefs. the system is given  as input  an arbitrary subset of the actor's beliefs. the more of the actor's beliefs the system is given  the more goals it can prove inconsistent. 
1 	p l a n n i n g language 
our formulation is general enough to accommodate many planning languages. we use u w l  etzioni et ai  1   an extension of the strips language  because it can express information-gathering goals and actions with sensory effects. this is necessary to distinguish between unix commands such as pwd and cd. in u w l   states are sets of literals. a literalis a possibly negated atomic formula. the conjunction of literals in a state describes all relevant relationships in that world state. models and goals are also sets of literals. the conjunction of the literals in a model or goal is a partial description of a state. a goal schema is a set of literals which can contain variables. a schema can be instantiated by replacing variables with constants. for example  the goal schema for searching for a file with some name  n  where  n is a variable  can be instantiated to form the goal of searching for a file named paper. tex. an action schema consists of a name  a precondition set  and an effects set. an action is an instance of an action schema  with a unique id number. the cd action schema  for example  can be instantiated into many different actions  such as cd /papers or cd b i n . multiple executions of the same action are distinguished by their id numbers. 
   informally  plans are programs composed of nested conditionals and actions. for brevity  we will not define plans but instead make use of a function  executor  which acts as an interpreter for plans. executor is a 
   many-to-one mapping that maps a plan and state to the action sequence that results from executing the plan in the state. we often refer to an action being in a plan  or one action coming before another. action ai is in plan p iff there exists a state s such that executor p  s  -* 
 .. ai .. . if ai and aj are both actions in plan p  then a1 is before a1 iff in every execution of p in which aj appears  a1 appears prior to aj. 
1 	c o n s i s t e n c y 
a plan is consistent with the observed actions if some execution of the plan might produce those observations. 
d e f i n i t i o n 1 plan p is consistent with sequence of actions a iff there exists state s such that executor maps p and s to a sequence of actions of which a is a prefix. 
¡¡consistency of a goal is defined relative to a set of action schema a and a model m. a goal is consistent with the observed actions only if there exists a consistent plan  built out of a  for that goal. a plan for a goal must potentially-achieve the goal  given model m  and contain no irrelevant actions. we now define these terms. 
d e f i n i t i o n 1 plan p potentially-achieves goal g given model m iff there exists a state s such that m c s and g is satisfied by executing p in s. 
if p potentially-achieves g given m then p also potentially-achieves g given any subset of m. this 
	lesh and etzioni 	1 
  a goal recognizer takes a goal recognition problem ii as input and returns a set of goal schemas g'. 
  the input ii = 	 a m a g  	where 
- a is a sequence of actions. a is assumed to be a prefix of the actions executed by the actor. 
- m is a set of beliefs. m is assumed to be a subset of the actor's beliefs. 
- a is a set of action schemas. a is assumed to be a superset of the action schemas the actor plans with. 
- g is a set of goal schemas. the actor's goal is assumed to be an instance of an element in g. 
  the output q' is a subset of g such that for every goal schema in gq' there exists an instance of that goal schema g - and a plan p such that: 
- p could achieve goal g  given the actor's beliefs  constrained by m . 
- p contains no irrelevant actions. 
- p is composed of actions from a. 
- some execution of p is a sequence of actions with prefix a. 
  multiple goals: the actor's goal may be the con-junction of various goals  such as  taking out the trash and fixing the car and writing a paper  figure 1: input/output specification for a goal recognizer. 
makes it easy to treat the beliefs m in the input ii as a subset of the actor's beliefs. 
   what does it mean for a plan to contain no irrelevant actions  we require that every action in the plan support some action in the plan or the goal.1 we define support between actions as follows  the definition of an action 
supporting a goal is very similar . 
d e f i n i t i o n 1 let ai and aj be actions in plan p. ax supports aj iff ai is before aj  ai has an effect that unifies with a precondition p of aj  and no action between ai and aj in p has an effect which negates p. 
   support is blocked only by an action that negates the supporting effect. one upshot is that we allow redundant sensory actions in the actor's plans. in other words  we do not assume that the actor remembers everything she learns from executing sensory actions. we can now define consistency for goals. 
d e f i n i t i o n 1 goal g is consistent with action sequence a  given model m and action schemas a  iff there exists plan p such that  1  p is consistent with a   1  every action in p is an instance of a schema in a   1  p potentially-achieves g given model m  and  1  every action in p supports an action in p or supports g. 
a goal schema is consistent if any instance of that goal schema is consistent. 
1
¡¡¡¡this is a much weaker requirement than that the plan be minimal in order to contain no irrelevant actions. 
1 	planning 
1 	i / o of a g o a l r e c o g n i z e r 
a goal recognition problem ii is a four-tuple {a  m  a  g  where a is an action sequence  the observations   m is a model  a subset of the actor's beliefs   a is a set of action schemas  the actor's plan is composed of actions in this set   and g is a set of goal schemas  a goal recognizer takes a goal recognition problem and returns g' c g. ideally  g' is the set of goal schemas in g that are consistent with a  given m and a. figure 1 summarizes the input/output specification for a goal recognizer. 
   we view goal recognition as the process of discarding goal schemas from the input set g and returning the remaining  unrejected goals. a sound recognizer never discards a consistent goal. a complete recognizer discards every inconsistent goal. 
   when the recognizer returns g''  this means  the actor's goal is an instance of a schema in g*.n if the recognizer is sound  this conclusion is justified by the following assumption. 
a s s u m p t i o n 1 the actor's goal is consistent  given model m. and action schemas a  with the  full  action sequence the actor executes  of which a is a prefix. further  the actor's goal is an instance of a schema in g. 
determining consistency is exponential in the length of the longest plan  that doesn't go through the same state twice . in an unbounded domain  consistency is semidecidable. in the next section  we describe a sound  polynomial-time  but incomplete goal recognizer. 
1 	our goal recognizer 
we now present our goal recognizer  i.e an algorithm which takes a goal recognition problem ii and returns a set of goal schemas. this goal recognizer is provably sound and runs in polynomial time. in this section  we present our theorems and provide intuitions for why they are true. the full proofs are in  lesh and etzioni  1 . in section 1  we validate our algorithm using data gathered in the unix domain. 
   our goal recognizer constructs and manipulates a single consistency graph t based on the input i i . a consistency graph is a directed graph in which the nodes are actions  action schemas  and goal schemas. figure 1 shows a simple consistency graph. 
   informally  the consistency graph represents the plans the actor might be executing. the actions in t represent the observed part of the actor's plan. the action schemas in t represent possible unobserved actions. the goal schemas in t represent the goals the actor might have. the edges in t indicate when one action can support another action or goal. a consistency graph is correct if all consistent plans are represented by the graph. 
d e f i n i t i o n 1 a consistency graph  v ¡ê  is correct  relative to the input goal recognition problem ii = {a  m  a g   iff the following three properties hold: 
 pi  v contains every consistent goal schema in g  
 p1  v contains action schema a e a if an instance of 
x is in any consistent plan for a goal in g  and  p1  s contains the edge  vi-*vj  for every vi vj g v where vi  or an instance of vi  supports vj  or an instance ofvj  in some consistent plan for a goal in g. 


	lesh and etzioni 	1 

strength of this assumption  we can reject a goal if no plan exists which could achieve it  given the actor's beliefs. a simple case where this arises is when a conjunct of some goal is false in the model m and not supportable 
by any effect of any schema in 
t h e o r e m 1  impossible conjunct  i f g i s insupportable and false i n m then - g is legal. 
   the obsolete rule leverages our assumption that every action supports  directly or indirectly  the goal. if some action schema is not path-connected to any goal can support any goal in 
   the following algorithm is a sound goal recognizer that runs in polynomial time in the size of ii. 
f u n c t i o n 1 recognize ii  ::: apply the rules to quiescence on initialize ii . return all goal schemas in the resulting graph. 
t h e o r e m 1 recognize is sound and polynomial-time in the size of xi. 
   the initialize function produces a correct graph  and since we only apply legal rules  the final graph is correct as well. a correct graph contains every consistent goal schema. thus our algorithm returns every consistent goal schema and therefore is sound. 
   the initial graph contains  g u au a '1 elements. in every iteration  we potentially apply every rule to every element. each rule can be applied to an element in linear time in the size of the graph. our algorithm halts as soon as applying all the rules fails to remove anything. thus  the maximum number of iterations is the number of elements in the initial graph. an upper bound for the worst case running time is thus k x  q u a u a|1 where k is the number of rules. this is a loose upper bound  intended only to show that our algorithm is polynomial. 
   our actual implementation is optimized for our current rule set. we have analyzed the dependency relationships among our rules  and fire only a subset of the rules in each iteration. additionally  we often apply many rules in a single procedure. we test  for example  the connectedness between an observed action and all goals with one procedure rather than a call for each goal. this is roughly  times faster than checking every goal separately. furthermore  although the above algorithm processes all observed actions at once  our actual system is incremental. we fold new actions into the processed graph rather than re-initialize the graph every time a new action is observed. when we observe a new action an  we add to fully connect an to and from every node and then apply our rules to this new graph. 
1 	e x a m p l e trace 
now we present a sample trace. the input to the recognizer is ii =   a   m   a  1  where a =  cd /papers  grep 
1 	planning 
m o t i v a t i n g paper.tex   contains representations of cd  ls  grep  and lpq  is empty  we know none of the actor's beliefs   g contains g  =  find a file named paper.tex   g1 =  find a file named paper.tex that contains motivating   and g1 =  find a free printer.  
¡¡the initialize function produces a graph similar to the one in figure 1 except that it is fully connected. 
   in the first iteration  the matching rule removes 1 edges  resulting in the graph shown in figure 1. the 
order rule removes edge 	papers . 
the 	prefix 	rule 	removes 	e d g e s ' p a p e r s     
 ls  /papers   	and 	ep . 
in the second iteration  goal connection removes g1  
g1  and edges  because they point to removed goals. 
in the third iteration  the obsolete rule removes lpq. 
¡¡in the fourth iteration  no rules fire. set  is returned. 
1 	experimental validation 
in this section  we describe how we collected our data  how we converted it into goal recognition problems  and how our system performed on these problems. 
   we gather the raw data as follows. after reading some instructions  the subjects  students in our department  are given english goal descriptions. the subjects try to solve each goal by executing unix commands. for each task  the subjects indicate success or failure. we prohibit subjects from using certain constructs and commands such as pipes and the command awk. 
   we converted this raw data into goal recognition problems. to generate the observed actions a  we matched each observed unix command to an instance of our action schema for that command. we filtered out commands we considered to be typos. we let a be our action schemas for 1 unix commands  including all those used by our subjects. we let  indicating that we know nothing about the actor's initial beliefs. this is the most conservative setting. the goal space  consisted of 1 goal schemas: 1 file-search goal schemas  goals of locating a file that has some qualities   1 assorted  non file-search  goals  and the 1 pairs of these 1 goals. we evaluated our goal recognizer on the following goals: 
 g1  find a file named  core . 
 g1  find a file that contains  motivating  and whose name ends in  .tex . 
 g1  find a machine that has low  load; and determine if oren etzioni is logged into the machine named chum. 
 g1  compress all large  1 bytes  files in the testgrounds subdirectory tree. 
goals g  and g1 are two of the 1 file-search goals. goal g1 is one of the 1 pairs of the assorted goals. this goal demonstrates our ability to handle interleaved plans for multiple goals. goal g1 is one of the 1 assorted goals. table 1 summarizes our results. an update is when one observed action is processed. the length of the plan is the number of actions the subjects executed to achieve the given goal. the remaining goals are the goals still in the graph after the last update. 

our goal recognizer performed very well on these data. 
the average time to process an observed action was 1 cpu seconds on a sparc 1 by code written in lisp. although the goal recognizer is incomplete in general  it detected every inconsistency between the goals and observations in our experiments. thus  our algorithm solved the goal recognition problem  as we have formulated it  very thoroughly and very quickly. 
   but did it work  did our mechanism recognize people's goals  in some sense  goal recognition occurs when the recognizer returns a single  consistent goal. this rarely occurred in our experiments. for example  for goal g1  over half the goals remain. the subjects only executed cd and is until they found core. these commands both support almost all file related goals. thus  almost all file related goals are consistent with the entire plans executed to solve goal g . 
   a common assumption in many plan recognition paradigms is that the actor's actions will eventually serve to distinguish a single plan  or goal . our investigations suggest this is unlikely to be true in the unix domain  even with relatively small sets of possible goals. we view our goal recognizer  which quickly prunes out the inconsistent goals  as a useful module. the next step might be to assign probabilities to the remaining goals. in  lesh and etzioni  1  we propose a very different solution based on version spaces  mitchell  1 . we view goals as hypotheses. when a single  strongest consistent goalhypothesis exists  we know that achieving this goal will benefit the actor. due to space limitations  we describe a special case of this approach  subset convergence  that works well on these problems. 
   we define subset convergence to occur when all the goals in the space share a common  non-empty  subset. subset convergence is useful because an agent might be able to make use of the fact that some goal g' is part of the actor's goal. the last column in table 1 indicates when subset convergence occurred for each goal  except goal g  for which subset convergence did not occur . 
   consider goal g1. all but 1 goals are rejected when a grep is observed. the remaining 1 goals all involve searching for a file that contains some word and  possibly  has some other characteristics  e.g. name ends in  .tex  . the goal of looking for a file that contains some word is a subset of all 1 of these goals. for g 1   subset convergence occurred  on average  after four actions were observed  which was an average of 1 actions before the subjects completed the task. 
   for goal g1  the subject's first command always indicated that part of their goal either was to find a machine with a low load  or to determine if oren was logged into chum. thus  subset convergence occurred immediately. by the second or third command  the goal space converged to goal g 1 . 
   for goal g1  the 1 unrejected goals are g1 itself and the 1 pairs of the assorted goals that include g1. nothing the subjects did to achieve g1 was contrary to  or inconsistent with  the goal of compressing all large files and  for example  finding a free printer. again  subset 
convergence detects  early on  that all 1 goals include the goal of compressing the large files. 
1 	related work 
most plan recognizers  e.g. kautz's  require  as input  a plan or event hierarchy which consists of top-level goals  primitive actions  and composite or complex actions. our input  however  differs significantly. essentially  we take only the goals  input g  and primitive actions  input a . our definition of what constitutes a valid plan for a goal replaces the complex actions. under our formulation  the goal recognizer must consider how the low level actions can be composed into plans. eliminating the complex actions is significant in that there may be up to 1'ai complex actions in the hierarchy. although our input is more compact  it is less expressive; we do not allow arbitrary constraints to be placed between steps in plans. we do  however  allow arbitrarily long plans which an acyclic plan hierarchy does not. 
¡¡a rarely duplicated feature of kautz's theory and system is the ability to recognize concurrent  interleaved plans. kautz assumes that actors execute the minimum number of consistent plans. we can proceed similarly if we assume that the concurrent execution of plans p1...pn for goals g ...gn is always the execution of some single plan p for g f  ... a gn- the technique to recognize interleaved goal-solving is to first run our algorithm  as normal  on the given goal space g. if all goals are re-
jected then run recognition on all pairs of goals  g1 . if this space collapses  run recognition on g1. and so on. this approach is not polynomial or sound because we approximate consistency  if we allow arbitrary numbers of plans  or goals  to be interleaved. we believe  however  that people rarely interleave large numbers of plans. if we assume that actors only pursue at most  say  1 or 1 goals simultaneously then our technique  which can terminate at g1 or g1  becomes polynomial and sound. 
¡¡there has been some work  e.g.  pollack  1   on recognizing invalid plans. we allow some invalid plans  because we allow all plans which could achieve the goal based on the actor's incomplete model of the world. some of these plans will not achieve the goal when executed from the actual world state. we cannot recognize plans built out of incorrect models of the action schemas  as pollack's system can. her system does not consider all allowable plans  as ours does  but instead searches for a good explanatory plan. 
¡¡there is some work on trying to select the best or most probable plan or combination of plans  e.g.  charniak and goldman  1  . our work complements this relesh and etzioni 1 

search; our recognizer can produce the consistent goals which can then be subjected to more expensive probabilistic analysis.  weida and litman  1  extend term subsumption to include plan recognition  motivated by the need to organize large numbers of plans  much like our desire to handle large domains.  vilain  1  describes a polynomial-time plan recognizer based on grammatical parsing. his system is sound and complete on restricted classes of plan hierarchies unlike ours which approximates consistency relationships based on an exponentially large plan space.  bauer et al  1 's definition of when a plan can be refined to include actions resembles our definition of a plan being consistent with actions  but their computational approach is quite different from ours. 
1 	critique and future work 
our algorithm requires polynomial time in size of the input. a more sophisticated algorithm  described in  lesh and etzioni  1   runs in time linear in the number of input goals  though still polynomial in |a| . but reasonable goal spaces may be exponentially large in relevant features of the domain  such as the number of predicates. our solution is based on version spaces  mitchell  1 . we view goals as hypotheses and explicitly compute only the strongest consistent hypotheses and the weakest consistent hypotheses. these two boundaries compactly represent the set of all consistent goals. in  lesh and etzioni  1   we identify a class of goals such that we can determine the consistency of 1n goals by explicitly computing consistency on only n goals. 
   currently  we strongly leverage our assumption that every action in the actor's plan supports another action or the goal. on this basis we reject the goal of finding a free printer if we observe cd /papers. however  if we completely model our domain  then most actions can contribute to most goals. if the actor is searching for a file that contains printer names then cd /papers can  indirectly  support finding a free printer. the problem is not that we fail to recognize this obscure plan but that we fail because we don't model the world well. eventually  we will need a stronger constraint than our current one that every action support another action or the goal. 
   on the other hand  our approach is sensitive to noisy or spurious actions. we assume every observed action is part of a goal-directed plan. this may not adequately capture the role of certain actions such as returning to one's home directory or mopping one's brow. we are currently exploring the possibility of learning which actions are regularly spurious by observing the actor over a long period of time. these actions could then be filtered out from the observations. 
   we have not yet addressed several additional issues. recall that the input observations are actions in our formal action language. but how do we automatically produce  for example  an instance of the cd action schema from the observable string cd /papers  what if the actor executes a command which fails  furthermore  how do we know when the actor finishes one task and begins another  we believe that our goal consistency framework and experimental apparatus puts us in good 
1 	planning 
position to address these issues. 
   although our algorithm and formal results are domain-independent  this does not guarantee that our goal recognizer will be effective in every domain. our case study in unix indicates that our goal recognizer performs well there. we believe these results suggest that our approach will also work well in various software domains. more generally  our approach is particularly well suited to two classes of goals. first  conjunctive search goals  such as the goal of looking for a file that is large  that has not been touched for a month  etc. second  conjunctive set goats  such as compressing all files that are large  that have not been touched for a month  etc. plans for both classes of goals can be very long  and thus task completion will be especially useful. 
