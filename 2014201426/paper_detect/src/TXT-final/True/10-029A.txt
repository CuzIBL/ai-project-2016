advantages of a transformational grammar for question answering 
fred j. damerau 
ibm corporation 
thomas j. watson research center yorktown heights  new york 
     a number of researchers in artificial intelligence  for example  woods 1  p.1 ff.    have asserted that transformational grammars are not a satisfactory basis on which to construct natural language understanding systems  primarily because of efficiency considerations. the evidence for such a claim is by no means strong  petrick 1   and it can be argued that transfer of new theoretical insights into a language understanding system based on transformational grammar is facilitated  plath  1 . this note shows that a transformational parser can also simplify problems of relating canonical representations of queries to data base representations. 
     consider a data base consisting of a set of company names each with an associated list of employees. a natural question for such a data base is m how many people does company y employ   our grammar produces an underlying tree structure whose bracketted terminal string is something like   i     from which a knuth-style semantic interpreter produces a lisp form like  1 . 
 1   employ  company y    how many  person x i     . 
 1   sizeof setx 	' x i 	' testfct 	xi 	 employ 	y 
1     
testfct would trigger extraction of names from the data base  setx would create a set of these names  and sizeof would determine the cardinality of that set. so far  this is simple enough and no difficulty arises. the first query system we constructed had a small data base of business statistics of large corporations  plath 1   petrick 1 . consider in this context a question like  what were ge's 1 earnings  . the underlying structure was something like  1   where the semantic interpreter produced a lisp form of roughly  1 . 
 1   equal  the x1  gross ge x1    some amount x i    . 
 1   setx 	' x i 	' foratleast 	1 	'x1 	 setx 	x1 
 testfct x1  gross ge 1    equal x1 x i         
foratleast 	implements 	the 	default 	quantifier  	and 
testfct finds ge's gross income. this data base also contained the total  number of employees for each company. if we were to ask 
 1  how many employees does ge have  
the system would produce an underlying structure related to  1   leading to a retrieval program like  1 . unfortunately  we need a retrieval program like  1   with   e m p l o y e e   substituted for  gross . we could of course modify the sizeof function to be sensitive to the data field it dominates and return the set rather than the cardinality of the set in appropriate cases  but this is aesthetically unattractive  although this is in fact what we did in our very first system . we could also modify our translation equations and semantic interpreter so as to be sensitive to this situation. while this might be satisfactory in one or two cases  the number of special cases can become very large. 
     in our present application  which is an english query system for the planning files of a small city near our laboratory  there are many more situations of this kind. 	one can ask 
 1  in what zone/planning area/ census tract/ etc.  is parcel 1 located  
for each of these questions  the underlying structure has a top level verb of   l o c a t e d     where the translator would prefer   z o n e   or  planning a r e a   etc. again  one could make the l o c a t e d function sensitive to its arguments  or insert the appropriate equations into the translator  but the complexity of either solution is much greater than before. 
     transformational grammars customarily have two sets of rules  cyclic rules  which apply successively to each level of embedding  and postcyclic rules  which apply globally to the entire sentence. our grammar has an additional set of rules  called string transformations  plath  1   which apply to strings of lexical trees. the transformational parsing program calls each of these sets of rules separately. since the parser is basically a tree processor  it can be applied  via an additional set of rules  to underlying structures like those for  1  and  1   and modify the structures in such a way that the semantic interpreter can produce correct code without data base specific modifications. in the case of  1   the output of the new processing phase  called the precycle  is a structure like  1  instead of a structure like  1   with a data identifica-
tion of   e m p l o y e e   rather than  gross . at the cost of an additional call to the transformational parser  we have insulated both the semantic interpreter and the data base functions from the organization of the data base  confining the necessary modifications to a single table of rules. we have not yet found a class of structural changes we wished to make because of the data base which required more than one rule. therefore  the cost of writing new rules has been much less than the cost of generating new programs for these special cases would have been. 
     while i am sure other system developers are able to solve this general problem  as they must in order to proceed in their work  we have nonetheless been pleased to note that our decision to use a transformational approach on linguistic grounds has had additional benefits on practical grounds. 
