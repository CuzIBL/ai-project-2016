 
model generation can be regarded as a special case of the constraint satisfaction problem  csp . it has many applications in ai  computer science and mathematics. in this paper  we describe sem  a system for enumerating finite models of first-order many-sorted theories. to the best of our knowledge  sem outperforms any other finite model generation system on many test problems. the high performance of sem relies on the following two techniques:  a  an efficient implementation of constraint propagation which requires little dynamic allocation of storage;  b  a powerful heuristic which eliminates many isomorphic partial models during the search. we will present the basic algorithm of sem along with these two techniques. our experimental results show that general purpose finite model generators are indeed useful in many applications. 
1 	introduction 
a large number of problems in ai and computer science can be viewed as special cases of the constraintsatisfaction problem  csp . some examples are machine vision  belief maintenance  scheduling  temporal reasoning  graph problems  and the satisfiability problem. in this paper  we are interested in one special case of csps  i.e.  model generation  where the constraints are expressed in predicate logic. 
　by model generation we mean  given a set of axioms  which are first order formulas   find their models automatically. a model is an interpretation of the function and predicate symbols over some domain  which satisfies all the axioms. the scope of this paper is restricted to finite models  whose domains are finite sets. model generation is very important to the automation of reasoning. for example  the existence of a model implies the consistency of a theory. a suitable model can also serve as a counterexample which shows some conjecture does not follow from some premises. in this sense  model 
　* partially supported by the national science foundation under grants ccr-1 and ccr-1. 
'on leave from chinese academy of sciences  beijing . 
1 	automated reasoning 
generation is complementary to classical theorem proving. finite models help people understand a theory  and they can also guide conventional theorem provers in finding proofs. in recent years  several programs have been developed for generating finite models  such as falcon  zhang  1a  finder  slaney  1   mgtp-g  fujita et al  1   ldpp  sato  zhang and stickel  1   modgcn  kim and zhang  1   and mace  mccune  
1b . they have been used to solve a large number of open questions in mathematics  see for example   fujita et a/.  1; slaney et a/.  1; zhang and stickel  1; zhang  1b  . 
　theoretically speaking  any approach of constraint satisfaction can be used for finite model generation. for instance  a simple backtracking algorithm can always find a finite model  if it exists . of course  a brute-force search procedure is too inefficient to be of any practical use. in general  the performances of backtracking algorithms can be improved in a number of ways such as forward checking and lookahead. there are many other search procedures and heuristics proposed in the ai literature; see  kumar  1  for a good survey. however  in the special case of model generation  we have to address the following two issues: 
  how can we implement constraint propagation and consistency checking efficiently  in particular  what data structures should be used  
  how can isomorphism be eliminated effectively dur-ing the search  two models are isomorphic if one can be obtained from the other by permuting element names. 
　the first issue may be trivial for some constraint satisfaction algorithms because the constraints they accept are often assumed to be unary or binary. it is true that n-ary constraints can be converted into an equivalent set of binary constraints; but this conversion usually entails the introduction of new variables and constraints  and hence an increase in problem size. this issue is particularly important to model generation because in this case  the constraints are represented by complicated formulas. experience tells us that a careful implementation can improve the performance of a program by several orders of magnitude. for instance  sato  zhang and stickel  1  is a careful implementation of the davis-putnam algorithm  a well-known method for satisfiability testing in propositional logic. because of its efficiency  sato has been used by the second author to solve several dozens of open cases of quasigroup problems that can hardly be solved by other constraint satisfaction systems. the second issue is obviously very important  because one model may be represented in many ways  which result in much redundancy in the search space. for propositional satisfiability  isomorphism elimination has been studied via the symmetric property of variables  benhamou and sais  1 . in the study of quasigroup identity problems  a key technique used in  fujita et al.  1; slaney et al  1  is to impose extra constraints as part of the input  so that some isomorphic models need not be considered. it appears that the method implemented in falcon  zhang  1a  is better for handling isomorphism. it works dynamically and does not require extra constraints. falcon has been used by the first author to solve a variety of open problems in abstract algebra. 
　in this paper  we describe a new model generating tool called sem  a system for enumerating models  that combines the strengths of falcon and sato. like falcon  sem is based on first-order ground clauses  and uses the powerful isomorphism eliminating technique. it also incorporates some data structures and inference mechanisms which are similar to those of sato. as expected  sem outperforms any other finite model generator that we know. sem not only reproduced many results obtained by sato and falcon  but also solved several new problems. in particular  sem works very well when the axiom set contains long formulas - the propositional satisfiability based systems like ldpp  sato  zhang and stickel  1   modgen  kim and zhang  1  and mace  mccune  1b  cannot han-
dle these cases because it is too expensive to convert such formulas into propositional clauses. 
　in the next section  we present some basic concepts  the abstract algorithm for finding finite models  as well as some features of sem. in section 1  we compare sem with other similar systems on various test problems  and illustrate the applications of sem with several examples. we hope that these experiments will be used as a basis for further comparison between finite model generators. 
1 search for finite models 
1 	basic concepts 
sem accepts problem specifications in many-sorted firstorder logic. but only finite sorts are allowed and formulas should be in clause form. let  s  f  be a signature where s is a set of sorts and f is a set of function symbols. we shall use the letter s  or s   to denote a sort  and / to denote a function symbol. each sort s e s consists of a finite number of elements  which may be designated by a list of names. alternatively  one can simply give a positive integer  say n  as the cardinality of s  and the elements of s are assumed to be 1 ...  n - 1. in the sequel  an element of some sort will be denoted by e or ei. syntactically these elements may be regarded as constant symbols. the built-in sort bool has two elements: true and false. 
　function symbols are sorted. each f e f has some fixed arity k   1 and is specified by / : s1 ... sk -  s  where s  s1 ...  sk ♀ s. the special predicate 'equality' is specified by eq: s s -  bool  where s is an arbitrary sort. we assume that  for any element e  eq e e  evaluates to 
true; and for any two distinct elements ei - cj  i not= j  of the same sort  eq ej ej  evaluates to false. there can be other predefined functions and predicates  but for the sake of brevity  they will be neglected in this paper. 
　terms are built from  sorted  variables and function symbols in the usual way. for convenience  let us call a term of the form / e1 ...  ek   ei  e si  cell terms or simply cells.  intuitively  such a term corresponds to an entry or a cell in the  multiplication table  of the function /.  we shall denote a cell term by ce or cei;. assigning an element of some appropriate sort to each cell  we obtain an interpretation of the function symbols. 
　the specification of a problem consists of a set of clauses. each clause is a disjunction of literals  and a literal is a term of the sort bool or its negation. all the variables in the specification are universally quantified. our goal is to find an interpretation which makes all the clauses true  i.e.  to find a  finite  model of the clauses. 
1 	model generation as csp 
a constraint satisfaction problem  csp  consists of a 
set of variables  { vi i 1   i   rn }; a domain of values  di  for each variable vi; and a collection of constraints. a solution to a csp is an assignment of values to all the variables such that no constraint is violated. finite model generation may be considered as a kind of csp where the  variables  are the cells in the multiplication tables and the  constraints  are specified by the clauses. 
　the model finding process can be described by the recursive procedure in figure 1. the procedure uses the following parameters: 
  a: assignments  cells and their assigned values   
{ ce e  | c e sort{ce }  
  b: unassigned cells and their possible values  
{ ce d  | dc sort ce }; 
  c: constraints  i.e. the clauses . 
initially a is empty  and b contains all the cells: { ce d  | d = sort ce }. since it is relatively expensive and inconvenient to check the consistency of a set of clauses containing free variables  in the implementation of sem  before the first call of the procedure search  the clauses are instantiated once for all  with each variable replaced by each element of the same sort. 
the procedure propa a  b  c  propagates assignment 
a in c: it simplifies c and may force some variables in b to be assigned. in the next subsection  we give more details about this procedure. 
1 	constraint propagation 
the procedure propa a  b  c  is essentially a closure operation  with respect to a set of sound inference rules . it repeatedly modifies a  b  and c until no further changes can be made. when it exits  it returns the modified triple  a b c . the basic steps of this procedure can be described as follows. 
	zhang and zhang 	1 


1 	automated reasoning 

that in search any two values in 
di that are not used in a are symmetric with respect to c. we can simply delete all the values from di  that do not appear in a  except one  the smallest one in our implementation . this technique of exploiting partially the symmetry of values is called the least number heuristic  lnh . as we will see in the next section  it is very 
effective in reducing isomorphic subspaces. 
1 	the system 
sem was implemented in c. the yacc tool is used for parsing. the current version has about 1 lines of source code. the major algorithm is essentially the same as search  except that  for the sake of efficiency  we use an iterative procedure instead of a recursive one. 
　in sem  the input specification for a problem consists of the following four parts: 
sorts; functions; variables; clauses. 
as an example  we give the specification for the pigeonhole problem. 
example pigeonhole problem  1 pigeons  1 holes . 
 the character 1 ' starts a comment in a line.  

1 experimental results 
in this section  we describe some of our experiments with sem  and illustrate the applications of finite model generation with various examples. we compare sem with other similar systems like falcon-1  zhang  1a   finder  slaney  1   version 1   sato 1  zhang and stickel  1  and mace  mccune  1b   version 1.1 .  all these systems were implemented in c  since different specifications may result in different execution times  we use the sample input files provided by the designers of the systems  whenever possible. for the same problem  we use the same set of axioms. all of our experiments were carried out on a sparc 1 workstation. the following tables show the execution times  in seconds  of the programs on various problems. each row corresponds to one problem instance. its first column is of the form name.n or simply n  where name is the name of a problem  and n is the size of the model. in all but the first table  we also give the number of models  denoted by m . 

1 the pigeonhole problem 
as a simple example of many-sorted applications  let us consider the pigeonhole problem  which has been included as a benchmark in most of the aforementioned systems. when not exploiting symmetry of the clauses  these systems can handle at most 1 pigeons in a reasonable amount of time  say 1 minutes . 
　benhamou and sais  benhamou and sais  1  proposed a method for exploiting symmetry in the propositional case. in the first-order case  we can use the least number heuristic to solve the problem more quickly. table 1 gives the execution times of the two programs  n pigeons and n- 1 holes . the sem specification for this problem was given in ′1. benhamou and sais' algorithm  bs  in short  was implemented in pascal on a sun1 and the run times are taken from  benhamou and sais  1 . 
1 quasigroups and latin squares 
recently a large number of open cases of quasigroup identity problems have been solved by various programs 
 zhang  1; fujita et a/.  1; slaney et al.  1; zhang and stickel  1; mccune  1b . a quasigroup has only one binary function  denoted by . or juxtaposition. in the multiplication table of this function  each row and each column is a permutation of all the elements. 
　in this subsection  we compare sem with finder and sato on the following 1 problems: 
1. iqg: enumerate idempotent quasigroups  i.e. quasigroups satisfying the identity xx - x. 
1. qg1: find idempotent quasigroups satisfying the identity {yx.y y = x. for the sake of efficiency  we also use two additional equations  i.e. y xy.y  = x and  y.xy y = x. 
1. rls: enumerate reduced latin squares. a latin square is called reduced if in the first row and column its elements occur in natural order. thus a reduced latin square corresponds to a quasigroup satisfying the identities: xo = x and ox = x. 
for the first two problems  each program uses a different method for handling isomorphism. sato uses the last-column constraint  fujita et al.  1; slaney et al.  1   finder introduces the 'cycle' function in the specification  slaney  1   and sem relies on the lnh. 
	zhang and zhang 	1 


1 	automated reasoning 

here / and g are two binary function symbols  a and b are two constant symbols. we completed the search for models of size up to 1  but did not find any one.1 
* in the study of orthogonal arrays  given three positive integers g  h and k  we'd like to know if there exists an abelian group g of size g  which has a subgroup h of size h  and on which we can define a function m : g -  g  satisfying the following two conditions:  1  for any a  b e g  m. ab  = m a m 1 ; and  1  for 1   i   k and a e h  mk a  = a  m1 a  not= a  where m＜ a  = a and mi+1 a  - m ml a   . sem successfully found  g h m  for  g h k  =  1  1  1    1  1  1    1  1  1    1  1  1    1  1  1    1  1  1 . 
  in group theory  we know that  xy 1 = x1 im-plies xy = yx. this can be proved with a conventional theorem prover like otter  mccune  1a . in contrast  with sem  we can show that  xy k - xkyk does not imply the commutativity law  for k - 1 1. sem found the appropriate countermodels of sizes 1  1  1  respectively. 
  sem also found some idempotent quasigroups sat-isfying two identities simultaneously  for example  a 1-element model of qg1 and qg1  a 1-element model of qg1 and qg1  and a 1-element model of qg1 and qg1.  the related identities are: qg1.  yx y = x yx ; qg1. x xy  = yx; and qg1. 
{ xy y y = x.  
　for the first two problems 1 it took several days for sem to complete the search. however  the last two problems are not so difficult as they appear - the execution times range from less than one second to several seconds. 
1 	concluding remarks 
we have described sem  a system for enumerating finite models  and compared its performance with those of other similar systems. clearly  sem can solve a wide range of problems efficiently. as shown in this paper and other papers  fujita et al  1; slaney et al  1; zhang and stickel  1; zhang  1a; 1b   finite model generators are very useful tools. so far  they have been mainly used to solve problems in mathematics. but we believe that the related techniques will find applications in al and computer science as well. 
　finite model generation is closely related to search and reasoning  which are two of the most important sub-
jects in ai  and which have been studied extensively. most existing programs are based solely on backtracking procedures. in the future  we shall experiment with more search heuristics and other non-exhaustive methods. the reliability of non-existence results is also worth studying. 
