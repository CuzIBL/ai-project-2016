 
an application of a r t i f i c i a l 	intelligence 
is discussed: an automatic programming system that generates information retrieval programs and data base structure designs for highly structured or network data bases. it is claimed that these applications are unusual in that they have more practical value than is usually the case  being of immediate u t i l i t y to commerclal data base management. the paper concludes wi th a short reflection on the problems associated with the representation and acquisition of knowledge for problem solving programs. in particular  representation of knowledge is important for efficiency of the programs  yet an e f f i c i e n t representation may not be  natural . it was d i f f i c u l t to separate representation from content/ and successful application required that the expert providing the knowledge also know how the program uses that knowledge. 
cr categories: 	1  1u  1  u.1  1 
key words and 	phrases: 	application 	of 
a r t i f i c i a l intelligence  automatic programming  procedure generation  information r e t r i e v a l   network data base. data base task group  data base design  non-procedural languages. 
introduction 
	most 	successful 	a r t i f i c i a l 
intelligence programs exercise their problem solving a b i l i t y in non-realistic environments or apply it to a game playing task  but th is state of affalrs does not constitute a basis for c r i t i c i s m of al. as many of the proponents of al have ma intained  it is necessary for al to cut its teeth on toy problems  games  and in otherwise limited environments before it can proceed to fulf1 i ts high 1y touted promises. perhaps the only f a i r c r i t i c i s m is that this teeth cutting is taking longer than envisioned by early workers in the f i e l d . 
　　　al 	is 	entering 	an 	age 	where practical 	and 	objective 	application is feasible. 	this is not to say that 	there have 	not 	been 	very 	valuable spin-offs from al research that have contributed to 
* a major portion of the work described herein was done while the author was at carnegie-mel ion unlvers!ty  pittsburgh  pennsylvania. 
advances in fields such as computer science  linguistics/ and psychology. however  there have not been many direct applications of al technologies  with perhaps the exception of pattern recognition  to problem areas outside the research laboratory. 
	my background is 	not 	primarily 	in 
a l   but lies more in the area of commercla  data processing  data base management  and information r e t r i e v a l . my experience in these areas predates by several years my introductory exposure to al. this fact is relevant because the problems  which w i l l be descri bed shortly  existed for me long before i dlscovered the technology to solve them. as such  my clrcumstances provlded an amount of practical experience not typically possessed by the al researcher who is looking for problems to adapt to his technology. 
　　　the application described here is a practleal one. the problem solving systems that have been developed can supplant or augment some of the tasks currently being performed by programmers and data base administrators. 
data management application 
　　　the subject of this paper is the successful application of a l   particularly automatic programming technology  to the problems of information retrieval and data base design. this has resulted in a system l 1  that generates information retr1eval programs and data structure declarations. 
　　　these two problem solving tasks have been around for a long time  but growing commercial usage of larger and more complex network data bases has suddenly increased their significance. cas used here  the term  network data base  refers to a data base in which a data i tern may be linked to many other data items. our subject is not data bases on computer networks.  there has been an attempt within the united states and canada to develop a standard for network data bases through codasyl which spawned the data base task group  dbtg  involving both industry and academia. this group has 
produced a spec if i cat ion for a general purpose network data base system u . although not yet accepted as a standard. it is believed by many that the dbtg specification w i l l be so adopted  perhaps 
1 

by default since many computer manufacturers and software firms are now s e l l i n g implementations of the dbtg s p e c i f i c a t i o n . 
       both applications 	described 	herein function 	in the data base environment as s p e c i f i e d by the 	dbtg. 	that 	is  	data structures designed by the system conform to 	dbtg 	s p e c i f i c a t i o n s   	and 	the 
information r e t r i e v a l programs generated by it are cobol procedure divisions containing data manipulation language  dml   as defined by the dbtg. 
programming f o r network data bases 
       introduction of the network type of data base brings with it a new level of complexity for the business programmer. earley 1  points out that instead of the usual l o g i c a l - p h y s l c a l dichotomy that a programmer t r a d i t i o n a l l y deals w i t h   there is a l o g i c a l   a   - l o g l e a l   b   - p h y s i c a l trichotomy facing the network data base programmer. the l o g l c a l   a   level corresponds to data r e l a t i o n s h i p s as perceived by the data user. the l o g l c a l   b   level concerns the actual 1 inks between the data in the data base. 
       bachman 1  recognizes t h i s complexity in the 1 acm turing award lecture where he likens the programmer's problem  in the network data base environment  to that of a navigator. the programmer is given the user's query requirements; his task is to f i n d the proper access path to the data through the myriad of connective l i n k s in the data base. 
　　　the programmer's task should be reduced. after a l l / much i t s complexity is caused by an a r t i fact 1ntroduced by the data network  the data 1 inks. it should be noted here that others in the f i e l d   p r l m a r l l y codd 1 1   have proposed r e l a t i o n a l models of data bases whereby they hope to avoid t h i s a r t i f a c t . it is not clear  however  how t h i s can be done without exactly the kind of problem solving program that is the subject of this paper. 
　　　the technology used to reduce t h i s task comes from work in the area of automatic programming. a compitier developed by buchanan and luckham 1  was used to create the information retrieval program generator. 
programming rules 
　　　the information retrieval program generator is compiled from a set of rules. these rules are stated in a formal ism that closely corresponds to the formalism developed by hoare 1  to describe the logic of programs. each such r u l e describes some type of program construct  be it a loop  assignment statement  a dml statement  or other program construct* 
       one type of rule describes the conditions under which a program statement may be used/ and the e f f e c t of i t s use. for example  the r u l e for a 
        get  statement says that it is not possible to get a record unless i t s location in the data base is known to the data management system  and that the object record w i l l be located in working storage f o l l o w i n g execution of the get. 
　　　this rule is formally stated  to the compller  as: 
      current rl  i i get r l | |  incore rl  in t h i s rule rl is a v a r i a b l e   f o r record name  and  current rl  and  incore rl  are predicates. henceforth we use the convention that rl/ r1/ x i   i i   e t c .   are vari able names. 
       other rules do not bear such close resemblance to a d e s c r i p t i o n one might f i n d in a programming manual as does the rule for get. these other rules capture my own programming know!edge  including h e u r i s ! t l e s   that i had p r e v l o u s l y acquired and developed as a professional programmer. 
　　　one such rule is the rule that describes the top level composition of a program: 
 opened a1 a current r1 a linked rl r1 a 
 closed a1 a st1p xi  
--   program xi  
this rule is d i f f e r e n t than the rule for get: it does not define a program statement  rather it is an i m p l i c a t i o n stated w i t h predicates. the order of the predicates is obviously important. 
　　　a semantic i n t e r p r e t a t i o n of t h i s rule is that a program consists of f i v e 
　　　blocks that :  1  open the required f i l e s of the data base   1  locate the f i r s t record of i n t e r e s t    1  f o l l o w the access path from t h i s record to a l l other records of i n t e r e s t    u  close the f i l e s opened above  and  1  terminate execution. 
       of these f i v e blocks  the second and e s p e c i a l l y the t h i r d   are the most complex. they may involve many f u r t h e r levels of refinement  revealing i t e r a t i o n s   a l t e r n a t i o n s and compositions. the t h i r d block w i l l include the processing of the records on the access path to display values  c a l c u l a t e s t a t i s t i c s   e t c . 

translation 	to micro-planner theorems 
	the 	rules 	are 	translated 	by 	the 
buchanan- luckham 	compiler 	to 
micro-planner 1  theorems that c o n s t i t u t e the information retrieval program generator. 
　　　for 	example  	the 	get 	rule 	is compiled 	t o : 
 defprop get 
	 thconse 	 r1  	 incore  thv r1  
 thgoal  current  thv r1    
 thset  car  thv ans   
 cons  cons  quote get  
 list  thv r l       
 eval  car  thv ans      
 thassert  incore  thv r l         
theorem  
       the theorem presented here is q u i t e condensed from the one a c t u a l l y generated  which also contains bookkeeping  t r a c i n g   uniqueness  and other special f u n c t i o n s . note that the p r e - c o n d i t i o n of the r u l e    current r l     is a goal in the theorem. s i m i l a r l y   the p o s t - c o n d i t i o n    incore rl   is defined as the consequence of the theorem and will be asserted when the theorem is used. when the theorem is used 'get r1' w i l l be catenated onto the answer. 
       program construction proceeds in a sub-goaling f a s h i o n . for example. if uncore patient  is a goal then the get theorem is t r i e d   and  current patient  becomes a sub-goal. a sub-goal may invoke other theorems in t u r n   generating f u r t h e r sub-goals. this process generates a goal tree w i t h leaf nodes which are true or false in a set of assertions known as the   s t a t e   . 
       the i n i t i a l state is the only input to the program generation process and is made up of two major subsets of a s s e r t i o n s . one such subset describes the s t r u c t u r e of the data base  the other describes the query for which program generation is required. 
       the d e s c r i p t i o n 	of 	one 	more 	rule w i l l 	give us a s u f f i c i e n t number of rules for 	an 	example. 	a 	rule 	for 	finding records: 
 hashkey r1 k1 a desire k1 v1 a 
 contains kl v1  i ifind r l | | 	 current rl  
　　　this rule is s i m i l a r to the rule for get; it defines a program statement. 
again  it corresponds closely to a paragraph in a programming manual: to find a record  f i r s t i n i t i a l i z e the key for that record w i t h the value 
i d e n t i f y i n g the desired record. following the execution of find  the record is current to the data management system. current is a dbtg term meaning that a record's exact location in the data base is presently know to the data management system  
example 
　　　assume that a data base d e f i n i t i o n s p e c i f i e s that student records are  hash keyed on snum. if a query asks for information regarding the student having number  snum  1  then two of the assertions in the i n i t i a l state w i l l be: 
 hashkey student snum  
          desire snum 1 . the f i r s t assertion belongs 	to 	the 	set d e f i n i n g the data base  	the second to the set d e f i n i n g the query. 
       micro-planner 	is 	given 	the 	goal  program example   and program generation commences. 	the 	f i r s t 	sub-goal  
 opened a1   is s a t i s f i e d w i t h a set of rules not i l l u s t r a t e d here r e s u l t i n g in an i n i t i a l block of procedure to open the f l l e s . 
       the next sub-goal is  current r l   . since the rule for find has t h i s as a consequence it is t r i e d . the f i r s t two sub-goals in t h i s rule are immedlately true in the s t a t e   and the variables r l   k l   and v1 get bound to student  snum  and 1  r e s p e c t ! v e l y . the t h i r d 
       sub-goal is s a t i s f i e d with the assignment statement rule  not l l l u s t r a t e d h e r e     and an assignment statement is inserted in the program. the p r e - c o n d i t i o n now being t r u e   'find student' is put into the program. 
　　　at t h i s stage 	the 	program 	appears as : 
 block to open f i l e s   move 1 to snum. find student. 
       the state  set of assertions  has also been a l t e r e d and now contains an additional a s s e r t i o n    current student   because of the find r u l e . this may a f f e c t subsequent procedure generation. for example. if the query requires that values from the student record be in working-storage  the system w i l l not generate any procedure for the 
	 current rl  sub-goal 	in the get r u l e . 
designing network data structures 
　　　another problem attendant to data base management is data base s t r u c t u r e design  that is  the design of appropriate links between data elements so that data r e l a t i o n s h i p s can be properly captured and reconstructed. since a l l such r e l a t i o n s h i p s must be i m p l i c i t l y contained in the set of a l l r e t r i e v a l requests. it should be possible to derive a data base s t r u c t u r e from such a set 1 . 
1 

	the 	automatic 	data 	structure 
designer operates in exactly this fashion. it generates a data structure design that is satisfactory for a set of queries. the resulting structure is not optimal but has the characteristic that data redundancy is minimized  and as a corrolary  the number of links are maximized . 
　　　the design program has two major tasks: to design a network structure that can accomodate a l l of the hierarchical relationships referenced in the queries  and to determine the best location in the structure for each data 
i tern. 
　　　detection of a hierarchical relationship in a query is not d i f f i c u l t . the system simply looks for quantifiers or summarizing commands such as   a l l      any    average     t o t a l     etc. for example  a query asking for a class l i s t 
 all values of student-name when class =  history   suggests a hierarchical relationship between class and student-name. similarly  average grade for student-name =  anderson   suggests that there may be many values for grade for a given value of student-name. 
　　　a designer has a problem if  for example. in addition to the class l i s t discussed above  a second query asks for a student transcript  all values of class when student-name = anderson  . the two queries' views of the data base are inverted with respect to each other. 
　　　inciuded in the automat!c design system are rules that recognize such situations. these rules w i l l insure that a special linking record is included in the data base design. through this record w i l l pass two linked l i s t s   one for each hierarchy. 
　　　the second principal task of the designer is to determine the location of data iterns  attributes  in the hierarchical structure. queries may differ in their views of attribute associations. for example  hospital name may be viewed as a patient attribute in one query  where he's being treated   as a doctor attribute  where he works   or as a hospital attribute in other queries. if hospital-patient and hospital-doctor hierarchies  several patients and several doctors per hospital  have already been constructed by the system  then it w i l l assign the attribute in question to the hospital record. this permits usage of hospital name as a unique attribute of hospital  doctor  and patient. 
　　　using earley's terminology  we can say that the automatic data structure designer finds a logical b  arrangement that accomodates a l l loglcal a  relationships. as a matter of fact  translation from loglcal a  to logical b  also characterizes the system's a c t i v i t i e s as a programmer. further translation to the physical level is not the task of these programs. that a c t i v i t y is performed by the data management system  e.g. an 
implementation of the dbtg specification. 
as was the case with the information 
	retrieval 	program 	generator  	the 
automatic data structure designer is defined with a set of rules that are translated by a compller to a program of micro-planner theorems. however  in this case the resulting system is not a code generator  it is a declarative generator. 
representation of knowledge 
　　　if a system is to apply knowledge. it must of course f i r s t obtain such knowiedge. untll generalized learning systems become available that can be adapted in a practical way for use within a particular application domain. it is necessary to imbed knowledge of the application either by building a specific learner for that system or by providing the system directly with the knowledge it needs. the trouble with the former approach is that building the learner may turn out to be impractically d i f f i c u l t . the latter approach is the one that was taken for the applications discussed here. 
complexity of knowledge 
　　　the rule formalism provided a good framework for capturing network data base programmlng and design knowledge. even so  capturing the knowledge involved many trial-and-error iterations because much of it does not have a well understood structure. furthermore  it is possible to map the knowledge into a structured set of formal rules in several valid ways. these representations may d i f f e r with respect to efficiency. 
　　　however  some of the knowledge does have a well-understood structure  for example the knowledge regarding get or find as discussed above. in general  the rules for single program statements like get are similar to usage rules that might be found in a reference manual. it is the rules that control the next higher level of programming  the construction of program blocks  that are complex and not easlly derived. 
　　　such rules were further 	complicated by 	considerations of efficiency both for the 	generated 	programs 	and 	for 	the program generation process 	i t s e l f . 
1 

       as an example we i l l u s t r a t e the two r u l e s t h a t c o n t r o l code g e n e r a t i o n f o r a l t e r n a t i o n . a l t e r n a t i o n occurs i n the generated program whenever the query s p e c i f i e s c o n d i t i o n a l p r o c e s s i n g . during program g e n e r a t i o n   the c o n d i t i o n t h a t i s to be t e s t e d in the generated program is c o n t a i n e d in a l i s t   forms  in d i s j u n c t i v e f o r m . 
       for 	example  	the 	list    gt a b  gt b 	c   	    l t a 1       	means  a b and b d  or a 1. 
	the 	two 	r u l e s 	a r e : 
 null 	forlis v 
 conjunct action  car forlis  	dum a 
 disjunct action  cdr 	forlis   
	-  	 disjunct action forlis  
  null c1nj a act action a setq dum 1     v 
 setq rel  caar conj  a 
 setq itm1  cadar 	c o n j     a 
 setq itm1 	 caddar conj  a 
 detval 	itm1 a detval 	i t m d a 
	 test  list rel 	itm1 	i t m 1     a 
 conjunct action  cdr conj  dum  
- -    conjunct action conj dum  
       those readers who are programmers w i l l agree t h a t these r u l e s bear l i t t l e correspondence to t h e i r own programming knowledge  e l t h e r vlewed i n t r o s p e c t i v e l y   or as such knowledge might be r e p r e s e n t e d in a programming t e x t . 
       the 	f i r s t 	r u l e cdr's 	t h r o u g h 	forlis  each 	time p i c k i n g o f f 	the car  	which 	is a c o n j u n c t i v e 	list 	of p r e d i c a t e s . 	the 	car of 	forlis 	w i l l 	be bound to conj 	in the second 	r u l e . 
       the second r u l e cdr's 	through 	conj u n t i l 	it becomes 	null  	at which p o i n t 	the p r o c e s s i n g 	code 	can 	be 	g e n e r a t e d 
         a c c o m p l i s h e d 	by 	i n v o k i n g 	the act r u l e   not 	shown h e r e   . 
       each 	time the second r u l e 	is 	used  code 	is 	g e n e r a t e d 	to d e t e r m i n e 	the values of 	the 	two i terns 	in 	the 	t e s t d e s c r i b e d by the car of conj. 	then 	the t e s t 	i t s e l f 	is i n s e r t e d 	in 	the g e n e r a t e d program. 
       for 	the 	example 	of 	forlis 	g i v e n above  	the 	generated 	procedure has 	the f o l l o w ! n g 	f o r m : 
	  b l o c k 	to determine value of 	b  
	  b l o c k 	to determine 	v a l u e of 	a  
if a b then 
begin 
	  b l o c k 	to determine 	value of 	c  
if b c then 
begin   b l o c k o f c o n d i t i o n a l p r o c e s s i n g   end 
else pr1 
end 
else pr1 
	pr1: 	 and pr1  
begin if a 1 then 
begin 
	  b l o c k 	o f 	c o n d i t i o n a l 	p r o c e s s i n g   
end 
end 
       the buchanan-luckham c o m p l l e r takes s p e c i a l c a r e w i t h r u l e s t h a t may g e n e r a t e a l t e r n a t i o n s . unbound v a r i a b l e s become i m p o r t a n t   and i t i s f o r t h i s reason t h a t dum is included iin the second r u l e . for f u r t h e r d e t i l s see   1   1   1   . 
       tests are separated in the g e n e r a t e d procedure t o i n c r e a s e r u n t i m e e f f i c i e n c y . in the example above  the v a l u e of c is determined o n l y if a b. since such a v a l u e d e t e r m i n a t i o n may r e q u i r e a l o t of p r o c e s s i n g   i t i s best t o a v o i d i t i f 
       p o s s i b l e . 
	impact of 	r e p r e s e n t a t i o n 	on 	e f f i c i e n c y 
       since the c o n t e n t of the r u l e s determines the d e c i s i o n t r e e t h a t c o n t r o l s the search space  the c h o i c e of mappings mentioned above can have a d r a m a t i c impact on the e f f i c i e n c y of t h e search f o r a program. if the use of a p a r t i c u l a r r u l e occurs f a r o u t in the branches o f the t r e e   and i f the r u l e i s a p o w e r f u l d i s c r i m i n a t o r   then it w o u l d be a p p r o p r i a t e to c o n s i d e r an a l t e r n a t i v e r u l e s t r u c t u r e t h a t would p e r m i t e a r l i e r use of the r u l e in q u e s t i o n . 
	it 	is 	a l s o 	i m p o r t a n t 	to 	d i r e c t 	the 
i n f o r m a t i o n r e t r i e v a l program g e n e r a t o r as much as p o s s i b l e . consider the find r u l e p r e v i o u s l y d i s c u s s e d . t h i s r u l e 
s t a t e s t h a t find has the e f f e c t of making a r e c o r d c u r r e n t . there are in f a c t f o u r o t h e r r u l e s d e s c r i b i n g s t a t e m e n t s t h a t have the same e f f e c t . these r u l e s a l l d i f f e r in the way in which they make records c u r r e n t : some use p o l n t e r s   a n o t h e r u t i 1 i z e s s e q u e n t l a l a c c e s s   e t c . 
1 

　　　　since t h e r e are f i v e ways of making a r e c o r d c u r r e n t / m i c r o - p l a n n e r may t r y s e v e r a l i n a p p r o p r i a t e r u l e s to s a t i s f y a current goal b e f o r e the p r o p e r one is a t t e m p t e d * this can be v e r y expensive s i n c e an i n a p p r o p r i a t e r u l e may not be discarded u n t i l a very l a r g e s u b t r e e has been e v a l u a t e d . 
　　　　f r e q u e n t i y   such searches can be e l i m i n a t e d because the programming c o n t e x t w i l l d e t e r m i n e which type o f find is needed. in the i t e r a t i o n s t e p of a l o o p   f o r example  we would n o t expect a d i r e c t find  r a t h e r we w o u l d expect a find f o r the n e x t r e c o r d on a l i s t or the next r e c o r d in sequence. 
       by c h a n g i n g the r u l e s so t h a t the system is d i r e c t e d to a s p e c i f i c r u l e 
       whenever p o s s i b l e   we were o b v i o u s l y able to a v o i d a l o t of unnecessary s e a r c h i n g . 
	it 	is 	i m p o r t a n t 	to 	note 	t h a t the che 
r u l e s were c o r r e c t w i t h o u t these s p e c i f f l c d i r e c t i o n s . the way in which the r u l e s were used r e q u l r e d a d d ! t l o n a l knowledge about the a p p l i c a t i o n so t h a t the r u l e s c o u l d be used e f f i c i e n t l y . 
       for a p a r t i c u l a r s e t of programs t h a t the system g e n e r a t e d . it t r i e d  on average  about 1 r u l e s per program. of these  on average  o n l y 1 r u l e s were i n a p p r o p r i a t e l y t r i e d   r e s u l t i n g i n 
	b a c k t r a c k i n g 	t o 	use a l t e r n a t i v e 	r u l e s . 
       although we have no e x a c t f i g u r e s to compare w i t h   the system was t r y i n g 1 to 1 times as many unnecessary r u l e s p r i o r to the a d d i t i o n of more s p e c i f i c d i r e c t i o n . the d i f f e r e n c e is m u l t i p l i c a t l v e r a t h e r than a d d l t i v e 
       because the s u b - t r e e a s s o c i a t e d w i t h a 
s i n g l e i n a p p r o p r i a t e r u l e may be q u i t e 
       l a r g e . 
c o n c l u s i o n 
       as a user of al t e c h n o l o g y   i am somewhat d l s a p p o l n t e d t h a t it was not s u f f i c i e n t to d i r e c t l y t r a n s f e r my knowledge to the machine. in i t s e l f a d i f f i c u l t t a s k . i t was a l s o necessary t o observe how t h a t knowledge was b e i n g used by the machine so t h a t i c o u l d change and augment the r e p r e s e n t a t i o n f o r more e f f i c i e n t use of the knowledge. 
       these problems were a l s o encountered w h i l e b u i l d i n g the automatic data s t r u c t u r e d e s i g n e r . another d l f f i c u l t y arose as w e l l . as the designer took shape it became apparent t h a t my d e s i g n knowledge c o n t a i n e d many ad hoc techniques t h a t were not e a s i l y c a p t u r e d in a s e t of general r u l e s . this r e a l i z a t i o n led me to develop the r u l e s f o r the more d i r e c t   general purpose a l g o r i t h m t h a t is embedded in the d e s i g n e r . 
       a l t h o u g h the d i f f i c u l t i e s o f 
       t r a n s f e r r i n g knowledge to the machine were somewhat f r u s t r a t i n g   the process  and the machine as a m i r r o r of m y s e l f   a l s o led to new i n s i g h t s i n t o the p r o b l e m domain. 
acknowledgements 
       the a s s i s t a n c e and encouragement of my t h e s i s a d v i s o r . jack r. buchanan  is g r a t e f u l l y acknowledged  as are the s u g g e s t i o n s o f one o f the r e f e r e e s . 
       t h i s r e s e a r c h was s u p p o r t e d n p a r t by the advanced research p r o j e c t s agency of the o f f i c e of the s e c r e t a r y of defense under c o n t r a c t fi1-c-1  and i n p a r t by the o f f i c e of naval research under c o n t r a c t m1u-1-c-1. i am a l s o i n d e b t e d t o the w i l l i a m l a r i m e r mel ion f e l l o w s h l p   which p r o v i d e d personal f u n d i n g d u r l n g the course o f 
       t h i s r e s e a r c h . 
