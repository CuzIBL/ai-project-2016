
recent applications of plan recognition face several open challenges:  i  matching observations to the plan library is costly  especially with complex multi-featured observations;  ii  computing recognition hypotheses is expensive. we present techniques for addressing these challenges. first  we show a novel application of machine-learning decision-tree to efficiently map multi-featured observations to matching plan steps. second  we provide efficient lazy-commitment recognition algorithms that avoid enumerating hypotheses with every observation  instead only carrying out bookkeeping incrementally. the algorithms answer queries as to the current state of the agent  as well as its history of selected states. we provide empirical results demonstrating their efficiency and capabilities.
1	introduction
plan recognition is the process of inferring another agent's plans  based on observations of its interaction with its environment. recent applications of plan recognition require observing agents whose behavior is reactive  rao  1   in that the observed agent may interrupt plan execution  switch to a different plan  etc. such applications include intrusion detection applications  geib and harp  1   virtual training environments  tambe and rosenbloom  1   and visual monitoring  bui  1 .
모in general  plan recognition relies on a plan library of plans potentially executed by the observed agent. typically  the plan library is composed of top-level plans that are hierarchically decomposed. the recognizer matches observations to specific plan steps in the library. it may then infer answers to plan recognition queries  such as the currently selected top-level plans  current state query   or the ordered sequence of  completed or interrupted  selected plans  state history query .
모existing work leaves several challenges open  see section 1 for details . first  most existing work assumes observations to be of atomic instantaneous actions. however  observations in recent applications are often complex multi-featured tuples  involving symbolic  discrete  and continuous components  e.g.  multiple actuators of the agent . moreover  observations may be of continuous actions  maintained over time. for instance  an observation of a soccer player may include its team name  uniform number  current position  velocity  etc. the computational cost of matching such observations against all possible plan-steps is non-trivial  and grows in the complexity of the observation tuple. however  existing investigations ignore this cost. second  with few exceptions  existing algorithms focus on the current state query  e.g.  tambe and rosenbloom  1; bui  1  . some go as far as to ignore all  tambe and rosenbloom  1  or portions  w rn and stenborg  1  of the observation history  and are unable to utilize negative evidence  where an expected action was not observed .
모this paper focuses on a set of efficient algorithms that tackle these challenges: first  we develop a method for automatically generating a matching decision-tree that efficiently matches multi-feature observations  to the plan library. second  we provide algorithms for efficiently answering the current state and state history queries. these lazy-commitment algorithms avoid computation of hypotheses on every step  as other algorithms do  geib and harp  1  . instead  they use linear-time  current state  and polynomial-time  state-history  bookkeeping with every observation  which allows extraction of hypotheses only as needed. our algorithms are complete  in that they admit all recognition hypotheses consistent with the history of observations; they are symbolic in that they provide hypotheses with no ranking  probabilistic or otherwise .
모we explore the performance of the recognition algorithms with simulated data  and show that they are significantly faster than previous techniques. their efficiency and completeness make them particularly suited for hybrid plan recognition approaches  e.g.   geib and harp  1   in which a symbolic recognizer filters inconsistent hypotheses  passing them to a probabilistic inference engine.
1	background and related work
we focus this brief discussion on closely related work  particularly allowing recognition of interruptible plans. see  carrbery  1  for a recent survey of general plan recognition.
모several investigations have utilized multi-featured observations  also of continuous actions   but did not address the efficiency of matching observations to the plan library  in contrast to our work: resc  tambe and rosenbloom  1  and resl  kaminka and tambe  1  use a hierarchical representation  similar to what we use  to maintain a single hypothesis  resc  or multiple hypotheses  resl  as to the current state of an observed agent. both algorithms ignore observation history in the current state hypotheses  and do not address state history  in contrast to our algorithms.
모geib et al.  geib and harp  1  developed phatt  a hybrid recognizer  where a symbolic algorithm filters inconsistent hypotheses before they are considered probabilistically. phatt assumes instantaneous  atomic actions  and takes a generate-and-test approach: with each observation  the symbolic algorithm generates a pending set of possible expected observations  which are matched against the next observation to maintain correct state history hypotheses. the size of the pending set may grow exponentially  geib  1 . in contrast  our work decouples the current state and state history queries  and incrementally maintains hypotheses implicitly  without predicting impending observations. the hypotheses are thus computed only when needed  when hopefully  many of them have been ruled out .
모other investigations assume atomic observations  and do not consider the cost of matching.  w rn and stenborg  1  explores plan-recognition with limited observation history  to facilitate recognition of reactive behavior.  retzschmidt  1  develops an approach based on matching subgraphs of the plan library. however  the approach does not allow for interruptions of plans.
모our work differs significantly from probabilistic approaches  though it complements them in principle  as demonstrated by geib et al. .  bui  1  explores probabilistic reactive recognition extending hidden markov models  focusing on current state query.  pynadath and wellman  1  explores a probabilistic grammar representation for efficient plan-recognition. none of these considers the cost of matching observations  nor separation of state history from current state queries.
1	matching observations to the plan library
as commonly done in plan recognition work  e.g.   bui  1    we utilize a hierarchical representation of the plan library  section 1 . we present a method for efficiently matching multi-feature observations to the library  1 .
1	the plan library
we represent the plan library as a single-root directed acyclic connected graph  where vertices denote plan steps  and edges can be of two types: vertical edges decompose plan steps into sub-steps  and sequential edges specify the expected temporal order of execution. for the discussion  we refer to the children of the root node as top-level plans  and to all other nodes simply as plans. however  we use the term plan here in its general sense  inclusive of reaction plans  behaviors  and recipes. indeed  to represent behavior-based agents  where typically behaviors execute over a number of time-steps   plans may have a sequential self-cycle  to allow them to be re-selected. however  no cycles are allowed hierarchically.
모each plan has an associated set of conditions on observable features of the agent and its actions. when these conditions hold  the observations are said to match the plan. for example  a kick-ball-to-goal plan  of a robotic soccer player  may have the following features: the ball must be visible  the distance to the ball is within a given range  and the opponent goal

figure 1: example plan library. circled numbers denote timestamps  section 1 .
is visible within shooting distance. if all the above conditions are satisfied  the plan matches the observation.
모at any given time  the observed agent is assumed to be executing a plan decomposition path  root-to-leaf through decomposition edges. figure 1 shows an example portion of a plan library  inspired by the behavior hierarchies of robocup soccer teams  e.g.  kaminka and tambe  1  . the figure shows decomposition edges  solid arrows  and sequential edges  dashed arrows . the top level plans are defend  attack  and score. the figure does not show the observation conditions associated with plan steps. for presentation clarity  we show the decomposition edges only to the first
 in temporal order  child plans. thus in the figure  the path root 뫸 defend 뫸 turn 뫸 with ball can be an hypothesis as to the current plan of an observed player. in realistic settings  likely more than one path will match an observation tuple  and this may result in a set of such decomposition paths  i.e.  a set of hypotheses as to the current state of the observed agent  answering a current state query .
모an observed agent is assumed to change its internal state in two ways. first  it may follow a sequential edge to the next plan step. second  it may reactively interrupt plan execution at any time  and select a new  first  plan. for instance  suppose the agent was executing root 뫸 defend 뫸 turn 뫸 with ball  and then interrupted execution of this plan. it may now choose root 뫸 attack 뫸 pass  but not root 뫸 attack 뫸 turn 뫸 withball.
1	efficient matching
the first phase of recognition  common to all recognition approaches  matches the observations made by the recognizer to plans in the plan library. in contrast with previous work  we consider complex observations  that consist of a tuple of observed features  including states of the world that pertain to the agent  e.g. a soccer player's uniform number   actions taken  e.g.  kick   and execution conditions maintained  e.g.  speed = 1 . matching such observations to plans can be expensive  if we go over all plans and for each plan check all observed features. this  in fact  is what previous work essentially proposes  e.g.  kaminka and tambe  1  .
모to speed this process  we augment the plan library with a feature decision tree  fdt   which efficiently maps observations to matching nodes in the plan library. an fdt is a decision tree  where nodes correspond to features  and branches to conditions on their values. determining the plans that match a set of observation features is efficiently achieved by traversing the fdt top-down  taking branches that correspond to the observed values of features  until a leaf node is reached. each leaf node points at the plans that match the conjunctive set of observations along the top-down path. ide-
ally  each leaf nodes points to only one plan  though this may not be possible due to inherent ambiguity in the plan library.
모an fdt can be automatically constructed  similarly to a machine learning  ml  decision tree  ross  1  but with important differences  see below . we map the plan library into a set of training examples  and then use a modified tree construction algorithm to construct the fdt. each plan step becomes an example  where the observation conditions become attribute values  and the class is the plan step. features not tested by a plan step are treated as all attribute values. after generating the training set  the construction of the fdt is done similar to that of a decision tree with missing attribute values  for lack of space  see  ross  1  for details .
모there are important differences with ml tree construction processes. the goal is to construct an fdt that is specialized to the  training examples . every plan step example appears exactly once  and no pruning step is taken  as is commonly done in ml decision trees .
모the use of the fdt to efficiently match multi-featured observations to plans is a novel application of methods from machine learning to plan recognition. the benefits to plan recognition are significant: the matching time is dictated by the height of the fdt  rather than the size of the library  l . let f be the number of distinct observable features. in a theoretical worst case  plans test all possible features  and thus the height of the fdt is o f . in the worst-case  the leaf in the fdt would point to o l  plans  where l is the maximum number of plans that are ambiguously consistent with a single observation  l    l . thus the complexity of matching observations to plans would be at worst o f + l . this should be contrasted with a o fl  used in previous work   kaminka and tambe  1  . as with any decision tree  there is a one-time cost of constructing the fdt  and storage overhead in using it. however  these costs were not found to be a hindrance in the experiments we conducted  see section
1 .
1	recognition algorithms
we now present algorithms for answering the current state query  section 1   and the state history query  1 . 1 current state query algorithms
an important query in reactive plan recognition is with respect to the current plan step selected by the observed agent. in most hierarchical plan-libraries-as in ours-this query translates to determining the decomposition paths  root-toleaves  that are consistent with the observations  and potentially are being executed by the observed agent. each such path is a current-state hypothesis.
모csq  algorithm 1  is an efficient algorithm for answering the current state query. csq's inputs include the plan library and pointers to the plan-steps matching the current observation  e.g.  as stored in an fdt leaf . it then works in two
algorithm 1 csq matching results m  library g  time-stamp t 
1: for all v 뫍 m do
1:	propagateup v g t 
1: for all v 뫍 m do
1:	while tagged v t 뫇  childtagged t  do
1:	delete tag v t 
1:	v 뫹 parent v 

phases. first  it calls the propagateup algorithm  algorithm 1   to tag complete paths in the plan-library that match the current observation  but taking into account previous observation. the set of matching plans m is assumed to be ordered by depth  parents before children  see below . then  lines 1  it goes over the resulting tags to eliminate any that are hierarchically inconsistent  i.e.  where a parent is tagged  but none of its children is tagged. csq is meant to be called with every new observation. the tags made on the plan-library are used to save information from one run to the next.
모the propagateup algorithm  algorithm 1  uses timestamps to tag nodes in the plan library that are consistent with the current and previous observations. to do this  it propagates tags up along decomposition edges. however  the propagation process is not a simple matter of following from child to parent. a plan may match the current observation  yet be temporally inconsistent  when a history of observations is considered. for instance  suppose that the first observation matches the position plans  figure 1 . the fdt would point the propagation algorithm to the four instances of position  marked with a circled 1   under defend  twice   attack  and score. however  two of the instances are temporally inconsistent  crossed out in the figure : the second instance of position  under defend  cannot be a first observation  since we should have observed either clear or approachball before it. similarly  position under score is inconsistent because its parent had to have followed attack  which was not yet observed. this reasoning about hypothesis consistency over time is a key novelty compared to  tambe and rosenbloom  1; kaminka and tambe  1 .
모to disqualify hypotheses that are temporally inconsistent  propagateup exploits the sequential edges and the timestamps. it assumes that the calls to it have been made in order of increasing depth  as discussed above . this allows an assumption  line 1  that matching parents are already tagged or do not have any associated observable features  and are thus compatible with all observations . line 1 checks for temporal consistency. time stamp t is temporally consistent if one of three cases holds:  a  the node in question was tagged at time t   1  i.e.  it is continuing in a self-cycle ; or  b  the node follows a sequential edge from a plan that was successfully tagged at time t   1; or  c  the node is a first child  there is no sequential edge leading into it . a first child may be selected at any time  e.g.  if another plan was interrupted . if neither of these cases is applicable  then the node is not part of a temporally-consistent hypothesis  lines 1   and its tag should be deleted  along with all tags that it has caused in climbing up the graph. this final deletion of all failing tags takes place in lines 1.
figure 1 shows the process in action  the circled numbers
algorithm 1 propagateup node w  plan library g  time-stamp t 
1: tagged 뫹 
1: propagateupsuccess 뫹 true
1: v 뫹 w
1: while v 1= root g 뫇 propagateupsuccess 뫇 tagged v t  do
1:	if tagged parent v  t 뫈 features parent v   =   then
1:	if	tagged v t	 	1 	뫈
 previousseqedgetaggedwith v t   1  뫈 noseqedges v  then
1:	tag v t 
1:	tagged 뫹 tagged 뫋{v}
1:	v 뫹 parent v 
1:	propagateupsuccess 뫹 true 1:	else
1: propagateupsuccess 뫹 false 1: else
1:	propagateupsuccess 뫹 false
1: if  propagateupsuccess then
1:	for all a 뫍 tagged do 1:	delete tag a t 

in the figure denote the time-stamps . assume that after the matching algorithm returns  at time t = 1   the propagate begins with the four position instances. it immediately fails to tag the instance that follows clear and approachball  since these were not tagged at t = 1. the position instance under score is initially tagged  but in propagating the tag up  the parent score fails  because it follows attack  and attack is not tagged t = 1. therefore  all tags t = 1 will be removed from score and its child position. the two remaining instances successfully tag up and down  and result in possible hypotheses root 뫸 defend 뫸 position and root 뫸 attack 뫸 position.
complexity analysis. for each plan instance that matches the observations  the propagation traverses the height of the plan library  expected to be o logl . note that previous works  e.g.  kaminka and tambe  1   have the same propagation complexity  but do not filter temporal-inconsistency. also  csq utilizes time-stamps on the plan library  rather than external data structures  e.g.   geib and harp  1  .
1	history of states query algorithms
the time stamps used by the csq algorithm can be used to also answer queries about sequence of plan steps taken by the agent from time t = 1 until now  given the history of observations. answering this query  however  is not a trivial collection of all possible current state hypotheses as generated at times t = 1 ... now  since observations  and lack thereof-negative evidence  at time tk may rule out currentstate hypotheses that were consistent at time tk 1.
모an example may serve to illustrate. continuing the example above  suppose the observation at time t = 1 matches the turn plan  three instances . the tag t = 1 propagates successfully and there are six possible current-state hypotheses for time t = 1  we omit the common root prefix : defend 뫸 turn 뫸 without ball  defend 뫸 turn 뫸 with ball  attack 뫸 turn 뫸 without ball  attack 뫸 turn 뫸 with ball  score 뫸 turn 뫸 without ball  score 뫸 turn 뫸 with ball.
모suppose we now make observations at time t = 1 that match kick. the score plan is the only plan consistent with t = 1  though both defend and attack are tagged for times t = {1}. however  after having made the observation at t = 1  we can safely rule out the possibility that defend was ever selected by the agent  because score can only follow attack  and the lack of evidence for either clear or approach ball at time t = 1  which would have made defend a possibility at this time  can be used to rule it out. thus we infer that the sequence of plan paths that was selected by the robot is attack 뫸 position  at t = 1   attack 뫸 turn at t = 1  though we cannot be sure which one of turn's children was selected   and finally score 뫸 kick. if we had only wanted the current-state hypotheses for time t = 1  we would not need to modify hypotheses for time t = 1. however  generating the state history hypotheses requires us to do so.
모we use an incrementally-maintained structure  the hypotheses graph  described below   that holds hypotheses according to time stamps. with every time stamp t  we can use the structure to eliminate hypotheses that were tagged at time t   1  that have become invalid. this also allows separation of the current-state hypotheses from the state history hypotheses  something not addressed with previous work  e.g.   geib and harp  1; bui  1  .

figure 1: an example extracting graph g1.
모the hypotheses graph is a connected graph g1  whose vertices correspond to successfully-tagged paths in the plan library  i.e.  hypotheses . edges in g1 connect hypothesis vertices tagged with time stamp t to hypothesis vertices tagged with time stamp t + 1. g1 is therefore constructed in levels  where each level represents hypotheses that hold at the corresponding time stamp. for each set of observations made at time ti  we add to g1 a level ti  with nodes for all current state hypotheses that were successfully tagged t = t1. we then create edges between vertices x1 ... xn in level ti to vertices y1 ... ym in level ti 1 in the following manner: if xi is not part of a sequence  i.e.  it is a first child   then we connect xi to each vertex yj   j = 1...m ; otherwise  if xi is part of a sequence  we connect xi to yj if any of the plans in yj has a sequential edge to a plan in xi. finally  if xi is equal to yj  we connect them to allow for the self-cycles.
모to generate all sequences of plan paths that are consistent with the observations  we traverse g1 from the last level ti backwards  to level ti 1  and on to the first level. paths that connect level ti to level t = 1 denote valid state histories. to illustrate  figure 1 shows g1 for the example above  t = 1.
complexity analysis. let l be the worst-case number of plans that match a single observation. for each node in g1 with time stamp t  of which there could be at most o l    we check all nodes in time stamp t 1  again  o l    thus a factor of l1 for each additional level. thus over n observations  the worst-case runtime is o nl1 .
1	experiments
we show results of experiments evaluating these techniques with simulated plan libraries and observation sequences. we controlled key parameters  such as the library size l  and the number of features used by each single plan f  f 뫞 1   and the structure of temporal edges. in the experiments below  l was set by modifying the number of top-level plans  children of the root node   and the depth of the library. the branching factor was fixed at 1. the maximum length of observation sequence was 1.
모we generated valid sequences of observations by simulating execution and selection of plan steps. the process randomly chose a path in the library and used all the features in this path to generate observations. based on existence of sequential edges  the process chose to either continue execution along a sequential edge  or jump to a new first child. in all experiments  we contrasted the results with resl  kaminka and tambe  1   the most relevant of the related works.
1	matching experiments
a first set of experiments compares matching run-time using fdt and resl  as the plan library grows in size. we generated different-sized libraries by varying the library depth  and number of top-level plans. to demonstrate the scale-up offered by the fdt as the observation complexity grows  we also vary f  1 1 . for each of these values  we generated 1 random observations sets based on the plan-libraries  and averaged the run-time for matching these using resl and using an automatically constructed fdt.
모the average matching runtime is shown in figure 1. the figures are arranged in a 1 뫄 1 matrix. the rows correspond to the number of top-level plans  1  1  and 1  respectively  top-down . the columns correspond to library depths of 1 and 1. thus the bottom right figure shows the results for the largest library  approximately 1 nodes. the fdts for these included 1 nodes  depending on the number of features associated with each plan  f . in all figures  the horizontal  x  axis shows f  and the vertical axis shows the average matching time in seconds. each point in a figure is the average of 1 runs.
모clearly  the use of the fdt leads to very significant improvements in the matching time  compared to resl-and even when each plan is associated with a single atomic observation. furthermore  its growth curve indicates that its benefits are maintained even as the observations increase in complexity.
1	query answering algorithms
we now turn to evaluate the algorithms answering the currentstate and state-history queries. these answers depend critically on the temporal structure of the plan library  in terms of sequential edges. we follow  geib and harp  1  in varying temporal structure in several ways  fig. 1 :  a  totally

number of actions in each node
figure 1: runtime of fdt  solid line  and resl  dashed .
totally 
	ordered	one	last	unordered

           figure 1: sequential links types. ordered: all children of same parent form a single chain;  b  first: first child has sequential edge to all its siblings;  c  last: siblings have sequential edges leading to the last sibling;  d  unordered: no ordering constraints between nodes. top-level plans are always unordered. propagation accuracy. a key advantage of csq over resl is its ability to use sequential edges and the history of observations to rule out hypotheses that are temporally inconsistent  section 1 . given a sequence of observations  we expect to see fewer current state hypotheses in comparison with resl.
모we again varied the library size through the number of toplevel plans  1 1  and the depth of the plan library  1- 1 . we vary the temporal structure of the library as described above. trials were conducted with sequences of 1 observations. we recorded the number of hypotheses maintained after each observation was propagated.
모figure 1 shows the effect of sequential edges types on the number of hypotheses. there are four figures  each for different depth  1 . the x axis shows the number of top-level plans  while the y axis measures the average number of hypotheses across all trials of the same configuration. each data point reflects the average number of hypotheses over 1 individual observations  organized as 1 random observation sequences  each 1 observations in length   based on the generated libraries.
모the figures show that totally-ordered libraries allow csq to maximally use past observations  and thus result in less hypotheses. in contrast  unordered libraries have no sequential edges  and thus do not gain information from a history of observations. thus the number of hypotheses generated in this case is exactly the same as generated by resl-which

figure 1: average number of hypotheses after propagation.

figure 1: average number of state history hypotheses with progress in observation.
ignores such history in any case  and thus its results for all library types are the same  shown in a single solid line . on average  more than 1% of the current state hypotheses generated by resl were ruled out by the csq propagation.
모we also show the results of evaluating the state history algorithm. figure 1 shows how incoming observations affect the number of state history hypotheses. the x axis shows the progression of 1 observations with time. the y axis shows the number of state history hypotheses generated by traversing the hypotheses graph g1. the totally ordered libraries have very few hypotheses  while the number of hypotheses for unordered libraries grows exponentially  since all combinations of current-state hypotheses are valid.
propagation runtime. given the significant improvement in accuracy  one may expect an associated significant computational cost in csq  compared to resl. we have argued analytically that this is not the case  and this is supported empirically. figure 1 shows the average run-time of csq in the above experiments  in comparison to resl's. the x axis shows the number of top-level plans  while the y shows runtime in seconds. resl is only slightly faster than csq. indeed  the difference in propagating between csq and resl amounts to a few additional checks  for incoming edges .
1	summary and future work
this paper presents methods for efficient  complete  symbolic plan recognition that can answer a variety of recognition queries  with increased accuracy. the algorithms depart from previous approaches in that they take a lazy-commitment ap-

 figure 1: average runtime of propagating resl versus csq proach  separating the current state and state history queries  and implicit representation of hypotheses  until required. in addition  we presented a novel application of decision tree construction for efficiently matching observations to the plan library-a step common to all plan recognition methods. we plan to further explore the use of symbolic algorithms in additional queries.
acknowledgments. this research was supported in part by the israeli ministry of commerce  and by isf grant #1. special thanks to nadav zilberbrand and k.ushi. 