 
　　semantically guided hierarchical deduction prover is a resolution-based theorem-proving procedure which is capable of using the domain dependent knowledge presented in well designed examples. this paper gives an overview of the basic deduction components of the prover  investigates some rules for human design of examples  and demonstrates their usage in proving several non-trivial theorems. 
1. introduction 
　　a method for using domain dependent knowledge in mechanical theorem proving is to present the hypotheses of a theorem-i.e. the axiomatic system involved as a model  or say  an example* -which is then used in guiding a mechanical prover to search a proof along with semantically provable paths. this method has been investigated by several researchers 1 1   where it was used mainly in some natural deduction proving procedures. 
　　though the basic idea of this method is simple and plausible  its potential usage has been limited by some problems or difficulties exposed in earlier implementations. 
　　one problem is that this method often produces incompleteness for the traditional goal-oriented theorem provers  such as a linear resolution procedure or some natural deduction procedures. for example  consider a unsatisfiable set 1 of ground clauses  s - {a v -c v b  - a v b c -ib}. suppose the first three clauses of s are hypotheses. we use m = {a b c} as a model of these hypotheses to guide a linear resolution proof  refutation  of s. let the last clause -b of 1 be the the first goal. the first step of deduction has two different branches: one produces a resolvent -a by resolving -b against -a v b  another produces a resolvent av -c by 
　　this work was supported in part by nsf grant mcs1. 
　* in this paper  the word  example  means a model that contains real semantics. 
resolving - b against the first clause of s. note that  for a semantically guided refutation proof  only the clauses that are false in the given model are treated as semantically provable  so can be used as goals during deduction. because - a is false in m  but a v -c is not  only the first branch can be developed next. then  from -a  only a resolvent -c v b is produced by resolving - a against the first clause of s. now  because -c v b is true in m and there is no other deduction path left  the deduction has to terminate with failure. some previous approaches tried to avoid this source of incompleteness by changing the model during deduction  1 . for example  according to example 1 of   a secondary model m' - {- a  b c} should be used later to finally prove s  the set s of the above example is just a simplified version of the problem given in example 1 of  . but  generally speaking  this strategy is not feasible to implement. one reason for this is that to design a  suitable  example for helping prove a hard theorem is not a easy matter. this is another problem encountered in using this method. 
　　in fact  the design or selection of a suitable example for a theorem to prove is an essential problem with using this method. of course  this task is difficult for a computer to do automatically because domain dependent knowledge is usually needed and also because it is hard to give a precise description of what is a suitable example. as for the human design  the difficulty lies in dealing with the interpretation of skolem functions  here  we are concerned with first-order logic only   because a casually-chosen interpretation of a skolem function may cause proof failure. 
　　this paper tries to give a solution of the above problems. we will use examples to guide a resolution-based theorem prover  semantically guided hierarchical deduction prover  shd-prover . different from the usual goal-oriented deduction procedure  this procedure has a 
　　particular mechanism in producing and retaining all  legal  resolvents producible from a goal clause in each deduction step. in light of this feature  many failure cases caused by using models in a traditional goal-oriented prover can be avoided. for example  this procedure will retain both resolvents -a and a v - c producible from the goal - b at the first step of deduction of the above example. but the resolvent a v - c which is true in m 
　　
1 	t.wang 
will be allowed to be used only as rule clause. then a resolvent -c can be produced in the next step by resolving -a against this new rule. because -c is false in m  it can be used as next goal to finally deduce a refutation of s. 
　　the shd-prover is based on a complete deductive component  hierarchical deduction procedure. the efficiency of this procedure is enhanced by several completeness-preserving refinements. the procedure can prove automatically a series of non-trivial theorems without the help of examples  see  . so  our approach emphasizes also the importance of a compact deductive component. 
　　this paper mainly describes our method of designing and using examples for shd-prover. we will investigate some rules for the human design of examples  especially  for the interpretation of skolem functions. more considerations about completeness and effectiveness problems will be included in these rules. as an application  this method will be used in designing examples to help our prover prove several non-trivial theorems  am1  imv  gcd  lcm and schubert's statement. in order to include type information and other useful knowledge into examples  a three valued modeling and the corresponding interpretation method will be proposed. 
　　the paper concludes with a summary of the results of computer runs in proving the example theorems. 
ii. outline of the hierarchical deduction 
　　 see  for details. those familiar with  should proceed to next section.  
　　the hierarchical deduction procedure proves a theorem by traversing a tree of nodes. each node contains a different set of clauses and other information. all candidate goal clauses are contained in a goal-list. each literal of each goal clause is indexed by a node name  through which a set of nodes can be located to obtain rule clauses for the resolution upon that literal. 
　　at the beginning of a deduction  there is only one node  node l  which contains all input clauses  while the goal-list contains only the input goal clauses. the literals of the input goal clauses are all indexed by 1  which corresponds to the name of the first node. the general proof process is as follows: 
1. the first goal clause g of the goal-list is taken. along with the index of the left-most literal of g  a set of rule clauses is obtained by retrieving the node indicated by this index and ail parent nodes of this node. this index will be the parent name of the new node being produced in this round of deduction. 
1. all  legal  resolvents are produced by resolving the goal clause against each clause of the set of rules upon the left-most literal of the goal clause. for each of the resolvents produced  the indices and the order of the literals inherited from the goal clause are retained  but the indices of the literals inherited from the rule clause are replaced by a larger integer which is just the name of a node being produced; these literals are placed to the left in the resolvent. 
1. if cd  the empty clause  is obtained  then the procedure returns  proved . otherwise  the resolvents will be stored into the new node and also be inserted into the goal-list according to their priorities. then the above process is repeated. 
　　the  legal  resolvents produced by the prover are called h-resolvents  hierarchical resolvents . they are produced under a number of constraints which will be briefly described next. 
　　local subsumption test: the literals previously resolved upon are retained by the resolvent as  framed  literals. a resolvent is said to be locally subsumed if it has more than one literal including its framed literals  sharing a common atom. the locally subsumed resolvent will be discarded. 
　　constraints on common tails: we call any index of a literal in a clause c which is less than the index of the left-most literal of c  a tail index of c. an index that is a tail index of two different clauses is called a common tail indtx of these clauses. we require that a legal resolvent of a goal clause must not be produced by resolving the goal upon the literal of a rule clause whose index is a common tail index of these clauses. we require also that the common tails  consisting of the literals with common tail indices  of the clauses being resolved be mergeable  unifiable . 
　　proper reduction: an h-resolvent h is called a proper reduction of an ancestral goal clause g  iff h is a variant  including indices  of a proper part of g. once a proper reduction is obtained  all other descendant resolvents produced from g  including g itself  will be discarded. 
　　global subsumption test: the hierarchical deduction has a feature that the resolvents grouped in the same node are similar to each other in the sense that the tails of these resolvents all are instances of the same part of a goal clause. based on this property  the procedure can use an effective subsumption test method  so that only a 
　　few relevant resolvents need to be compared to determine whether a new resolvent is redundant. 
　　resolvent evaluation and reordering: the prover uses a best-first search strategy by which the candidate goal clause with largest priority is to be resolved first. the priority of each resolvent is assigned by an evaluation routine based on certain ideas  such as  twin symbol . these ideas are also used by a level subgoal reordering subroutine  which is responsible for selecting an  important literal  from a goal clause to be the left-most literal of that clause. 
　　
	t.wang 	1 
a partial set of support strategy and others: this 
　　
strategy is another use method of the model methodology  or say  set of support strategy  to reduce the search space. with this strategy  some literals of input clauses will be disallowed to resolve upon according to a model or  setting . the prover includes a finite forward chaining subroutine to produce some useful information for the evaluation routine. a special factoring algorithm  hierarchical factoring  is used by the procedure  which allows production of fewer factoring resolvents without causing incompleteness. 
iii. semantically guided hierarchical deduction 
　　now  suppose m is a model of the input set of rule clauses. we require that only the resolvents that are false in m  that is  semantically refutable  can be used as goals by the hierarchical deduction procedure. then this procedure becomes a so-called semantically guided hierarchical deduction  shd-prover . note  the newly produced re-
solvents that are true in m will still be retained in some node  so they may be used later as rules. 
　　in order to incorporate type information and other useful knowledge into a model  the interpretation method to be discussed in this paper will be slightly different from the traditional one. in particular  we will allow the domain d of an interpretation to include a special element   unknown . thus d = do u {unknown}  where do is an ordinary nonempty domain not containing the element  unknown . this element will be used for indicating the interpreted value of semantically meaningless terms  atoms  or formulas. we restrict the use of our interpretation method to a subset of the first-order formulas  namely  the simplified first order formulas. 
　　definition. a simplified first-order formula is a quantifier free first-order formula containing no logical symbol other than -  a  v; and each negation symbol -i occurring in this formula must be applied to an atomic subformula  ie. atom . 
　　all atomic formulas  clauses  and sets of clauses  treated as conjunctions of disjuncts  are simplified firstorder formulas. the formulas in the interpretation normal form  which is to be introduced next  are also simplified first-order formulas. 
　　interpretation. an interpretation i for a simplified first-order formula w consists of a domain d and a definition for each non-variable symbol occurring in w'  such that 
o each n place predicate symbol p is interpreted in i as a function  p : dn -  {true  false  unknown}; 
o each n place function symbol f is interpreted in i as a function  f : dn -  d; 
o the logical symbols are interpreted in / traditionally  except -unknown = unknown  unknown a x = x  domain. shd-prover requires that the domain 
d do  of an interpretation be finite. this finite domain is obtained by the following method. for a theorem w to be proved  we first interpret it by using a natural domain  it may be infinite . then the domain d d1  used by the prover is produced mechanically by the following procedure: 
procedure domain-generator {domain -limit ; count := 1; 
d :- { e : t is the interpreted value of a constant 
 1 place function symbol  of w }; 
while count   domainjimit do count := count + 1; 
　　　　d :- d u { e : c is the interpreted value of an interpretation instance of a term in w over d }; do := d - {unknown}. 
　　the domainjimit can be given by the user. in practice  we prefer to use a small domainjimit first  such as 1  to generate a small size domain. if the prover fails  then repeatedly increase dominjimit and call the prover until a proof is obtained. we will give several examples of this procedure being used. 
　　for shd-prover  the resolvent that is interpreted as  unknown  will be discarded. it is noticed that the expense of obtaining the interpreted value of a literal or a term increases exponentially along with the increase of the number of different variables it contained. we have used a more efficient method  not given here  to implement this semantic test for avoiding the expensive evaluation. 
iv. example design method 
　　semantically guided hierarchical deduction  by retaining the resolvents which are true in the model as rules  has acquired a valuable property: if the prover is guided by a particular model  such that at most one semantically refutable and useful resolvent is produced in each step of a deduction  then the procedure will not lose a proof of a 
　　theorem. our task in designing examples and interpreting 
　　
1 	t.wang 

	t.wang 	1 

　　
1 t.wang 

　　
	t.wang 	1 

