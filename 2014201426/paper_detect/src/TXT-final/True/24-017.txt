 
admissible heuristics are an important class of heuristics worth discovering: they guarantee shortest path solutions in search algorithms such as a* and they guarantee less expensively produced  but boundedly longer solutions in search algorithms such as dynamic weighting. unfortunately  effective  accurate and cheap to compute  admissible heuristics can take years for people to discover. several researchers have suggested that abstractions of a problem can be used to generate admissible heuristics. this paper describes and evaluates an implemented program  absolver ii  that uses a means-ends analysis search control strategy to discover abstracted problems that result in effective admissible heuristics. absolver ii discovered several well-known and novel admissible heuristics  including the first known effective one for rubik's cube  thus concretely demonstrating that effective admissible heuristics can be tractably discovered by a machine. 
1 	introduction 
admissible heuristics are an important class of heuristics worth discovering: they guarantee shortest path solutions in search algorithms such as a* and they guarantee less expensively produced  but boundedly longer solutions in search algorithms such as dynamic weighting  pohl  1  and a;  pearl  1 . unfortunately  
heuristics that are both admissible and effective  accurate and cheap to compute  often take years for people to discover. for example  although the traveling salesperson problem was introduced in mathematical circles as early as 1  lawler and lenstra  1   it was not until 1 that the minimal spanning tree heuristic for it was discovered. the ultimate goal of this research is to develop a system for discovering effective admissible heuristics automatically  thereby shifting some of the burden of discovery from humans to machines. this paper describes and evaluates an implemented program  absolver ii  that can tractably discover effective admissible heuristics. 
previous proposed  but unimplemented methods to 
1 	learning and knowledge acquisition 
generate admissible heuristics for a problem involve finding the length of a shortest path solution to transformed version of the problem; the length is the admissible heuristic. the transformations include edge supergraphs  guida and somalvico  1; gaschnig  1   operator precondition dropping  pearl  1   and homomorphisms  kibler  1 . analytic results show that for such heuristics to be effective  the transformed problems that generate them should be easier to solve and close to the original problem  valtorta  1; mostow and prieditis  1 . one suggested way to make a transformed problem easier to solve is to factor it into independently solvable subproblems when possible  pearl  1 . the only implemented program to generate admissible heuristics by searching for easy-to-solve transformed problems  absolver i  uses an exhaustive generator  mostow and prieditis  1 . because the space of transformed problems is generally too large to search exhaustively  a smarter method of search control is required. 
　this paper extends previous work in three ways. first  it extends and unifies previous definitions of transformations that generate admissible heuristics  section 1 . second  it extends absolver i's transformation catalogs  section 1 . finally and most important  it describes and evaluates a new search control mechanism as implemented in absolver ii  sections 1 and 1 . 
1 	abstracting transformations 
intuitively  an abstracting transformation removes details. to formalize this intuitive definition requires a few preliminary definitions. let a state space search problem be a 1-tuple   s   c   p     where s is a set of states describing situations of the world; c : s x s - -   r isa total positive cost function that returns the length of a directed arc from one state to another; and p is a predicate that characterizes a class of goal states. for example  in the eight puzzle problem  the set of states consists of all tile permutations; the cost function on a pair of states returns 1 if one state is reachable from the other by swapping the blank with an adjacent tile  and oo otherwise. a goal predicate might specify that the tiles are to be in a particular order. problem solving involves finding a finite sequence of states leading from the initial state to a state that satisfies the goal predi-

cate. the cost function can be specified explicitly with a matrix or implicitly  relative to a set of parameterized actions called operators. similarly  the goal predicate can be specified explicitly by enumerating all goal states or implicitly  relative to a goal statement that defines a generated from an abstracted problem is generally too 
class of states. 
as shown in figure 1  a heuristic for a state in problem is computed by first abstracting the state and expensive  we have implemented a catalog of speedup transformations  shown in table 1 and henceforth called speedups   each of which has been proved to preserve admissibility  prieditis  1 . 

then finding a shortest path solution in the abstracted problem   e.g. with a* . the length of that shortest path solution is the admissible heuristic. 1 for example  if the requirement that the adjacent location need be blank is dropped from moves in the eight puzzle problem  then moves in the abstracted problem will result in states where tiles are superimposed. the length of a shortest path solution in this transformed space is therefore an admissible heuristic for the original problem. in fact  this length is the manhattan distance over summed all tiles  i.e. the rectilinear distance to each tile's goal destination . 

figure 1: how a heuristic is computed in our model 
   our definition of abstraction is sufficiently general to cover edge supergraph transformations  precondition dropping transformations  homomorphisms  and other admissible-heuristic-generating transformations not covered by these  e.g. subgoal dropping . 
1 	extended transformation catalogs 
table 1 shows absolver ips catalog of abstracting transformations  which operate on the same strips-style problem representation  fikes et al  1  of absolver i. each transformation has been proved to be abstracting  prieditis  1   thereby guaranteeing that all heuristics generated from the catalog are indeed admissible. since using breadth-first search to compute a heuristic 
1
　　 admissibility  composability  partial ordering  and other results are proved in  prieditis  1 . 

table 1: our current catalog of speedup transformations  * = new  
for example  after applying drop blank  in the eight 
puzzle  the resulting abstracted problem can be factored into a set of independently solvable problems; then finite differencing can be applied to recompute only that factor's heuristic that requires updating after each move in the original space; and finally  a lookup table can be precompiled for each factor. for n x n puzzles  the complexity reduction is as follows  original problem is leftmost : 

   figure 1 summarizes our model for discovering admissible heuristics. an abstracted version of the original problem is sped up and then used as an admissible heuristic for all problem instances  problem + initial state . notice that the effort to discover a heuristic for a problem is amortized over all instances of a problem because the derived heuristic is not instance-specific. 
1 	absolver ii 
absolver ii uses a table  table 1  of plausible abstracting transformations for each implemented speedup to identify and eliminate obstacles to applying speedups.1 an  x  in a particular row/column entry of this table means that the row's abstracting transformation is likely to lead to satisfying the column's speedup transformation  given our experience in applying the model by hand. 
1
　　 finite differencing is not shown because it is implicitly part of factor; precompute is not shown because it depends on hard-to-predict information such as search space size. 
	prieditis 	1 

figure 1: our model for discovering admissible heuris-
tics 

table 1: plausible abstractions for each speedup transformation 
   using this table  absolver ii outputs the first heuristic it finds  which it assumes to be the best one  subject to the following evaluation criteria implicit in its search mechanism: 
  the less information dropped to derive the heuristic the better  e.g. drop fewer preconditions . 
  a heuristic must be derived from an abstracted problem that can be sped up. to avoid generating useless heuristics  absolver ii incorporates necessary conditions for speedup into its generator of abstractions. 
absolver ii is actually comprised of three subprograms: 
composer  dropper  and summarizer. using several meta-heuristics  composer searches through the space of composition abstractions  e.g. sum  for those abstractions that lead to the removal of subsumed operators. dropper attempts to factor a problem into independent subproblems by applying drop-pre and drop-goal  irrelevant operators are implicitly removed; drop is modeled in terms of these two transformations . dropper first builds a set of preconditions and subgoals to drop that are sufficient to make a pair of subgoals independent. next  using several meta-heuristics and a standard search algorithm for combining these drops  it tries to find a minimal set of drops that allows factoring. summarizer attempts to obtain a problem in which subsumed operators can be removed by applying count  to every predicate . failing that  summarizer applies p a r i t y  to every integer  in an attempt to obtain a problem in which 1 learning and knowledge acquisition subsumed operators can be removed. 1 
absolver ips overall search strategy is as follows. 
first  it calls composer. if composer fails to find a problem in which a certain percentage of subsumed operators can be collapsed  then absolver ii calls dropper. if dropper cannot factor the problem into two or more independent subproblems  then absolver ii calls summarizer as a last resort. after absolver ii succeeds in applying a speedup transformation within either composer  dropper  or summarizer  it calls itself recursively on the resulting problem  thus resulting in a hierarchy of abstractions  which generates a hierarchy of heuristics  each of which is used to more efficiently compute heuristics lower in the hierarchy. the rest of this section describes composer and dropper; summarizer is not described since it is relatively straightforward. 
1 	c o m p o s e r : t h e search f o r s u b s u m a b i l i t y 
composer's goal is to find an abstracted problem in which subsumed operators can be removed. it tries to reach this goal by searching through the space of pair-wise compositions with a standard hill-climbing algorithm and a meta-heuristic in the form of a  similarity  coefficient on each candidate composition. the similarity coefficient returns the number of pairs of operators in which the composition results in the same value. the larger the similarity coefficient  the more likely that a particular composition will lead to operator subsumption. composer applies the similarity coefficient to each pair-wise candidate composition and then proceeds in the direction of that pair-wise composition with the largest similarity coefficient  ties are broken arbitrar-
iiy -
   when the number of uninstantiated operators after subsumed operators are removed is 1% of the number of original operators  composer calls itself recursively to build a hierarchy of heuristics. the 1% value  which we chose initially and have not had to change  is a rough indicator that the branching factor of the abstracted problem is sufficiently reduced such that search will be cheaper than in the original space  but not reduced so much that inaccurate though cheap-to-compute heuristics result. 
   for example  in the fool's disk problem  shown in figure 1   where the object is to rotate each of the concentric disks until the numbers on each radius  labeled r1-rs  sum to 1  composer generates the hierarchy of problems shown in figure 1  each of which generates an admissible heuristic. 
   the diameters problem is a transformation of the original fool's disk problem where the following pairs of radii are summed using the sum transformation: r1 and r1  r1 and r1  r1 and r1  and r1 and r1. the perpendicular diameters problem is a transformation of the diameters problem where perpendicular diameters are summed. for example  in the perpendicular diameters problem  the composite r 1 and r 1 is summed w i t h the composite r1 and r1. the a l l numbers problem is a transformation of the perpendicular diameters problem: 
1
　　 currently  absolver ii collapses problems to closed form only opportunistically. 


figure 1: the fool's disk problem 

figure 1: the hierarchy of discovered heuristics for the fool's disk problem 
all the numbers are summed. to compute  for example  the diameters problem heuristic for any state in the original fool's disk problem  the state is abstracted  by 
summing opposite radii  and then the search algorithm  e.g. a*  is called recursively with the diameters problem and the abstracted state. if this heuristic returns oo for a state at any level of abstraction  then the state can be pruned. in sum  to prune states that cannot reach the goal  the original fool's disk relies on the diameters problem  which in turn relies on the perpendicular diameters problem  which finally relies on the all numbers problem.1 
　the complexity of composer is dominated by the complexity of computing the similarity coefficient  whose complexity is  for m operators. for each non-
recursive call of composer  the similarity coefficient will be computed  times for n integers since only integer pairs  or bags  are processed. thus the total complexity of composer is since composer will call itself recursively at most 1 n  times. 
1 	dropper: the search for factorability 
dropper is actually composed of two subprograms: pairwise and combine. over each pair of subgoals  pairwise finds a set of precondition and subgoal drops sufficient 
1
　　 these admissible heuristics are not to be confused with the fool's disk problem-solving strategy described in  ernst and goldstein  1 . 
to make the pair of subgoals independent. for example  figure 1 shows that given a subgoal a t   l   a   and a subgoal at 1 b  in the eight puzzle  an operator of the form move 1 - a  directly adds a t   l  a  and an operator of the form move 1 - b  directly adds at 1 b . since moved . a  places the blank in some location 
 possibly location b  and move 1   b  places the blank in some location  possibly location a   these operators might interact through blank of both operator's pre-
conditions. dropping blank from the precondition of the move operator eliminates this interaction. to test if the entire goal is factorable into at least two parts  the drop sets from each pair of subgoals must be combined somehow. combine uses an iterative deepening search algorithm with the meta-heuristic of focusing on the most frequently occurring drops first. this search algorithm tends to minimize the number of drops to obtain a problem that can be factored into two or more subproblems. in our eight puzzle example  which only 

figure 1: dropping the blank enables factoring  arrows are potential interactions  
has a single drop set  dropping blank from the operator and the goal   combine converges to a factorable set after one iteration. combine is then called recursively on each of the factors. it then terminates successfully since no other factorings can be obtained within each factor and produces the and tree of factors shown in figure 1  which is used to compute the manhattan distance heuristic. 

figure 1: independently solvable factors used to compute manhattan distance 
the complexity of dropper is dominated by pairwise  
	priedttis 	1 

which constructs a transitive closure of the set of operators that can possibly lead to achieving a goal. the worst-case complexity of constructing this transitive closure is   where bb is the backward branching factor  the average number of operator instances that adds a given predicate  and db is the backward depth  the length of the longest chain of operators in the set of relevant operators for a given subgoal . that is  the number of preconditions that pairwise examines is proportional to the number of paths from a subgoal to each operator in the chain. 
1 	experimental results 
table 1 presents the results of applying absolver ii to several well-defined search domains  each of which is sufficiently complex to require heuristics. the table lists the domain  the name of the heuristic  and the percentage of the space that was explored  to two significant digits . the percentage is computed by dividing the number of heuristics generated before the named one was found by the number of abstractions with respect to our catalog of abstracting transformations and multiplying by 1 the space size is a conservative estimate in that it includes only those abstractions that absolver ii actually used. for example  the space size for deriving the manhattan distance is 1  since absolver ii only drops operator preconditions and subgoals to derive the heuristic and there are 1 subgoals and 1 preconditions  1 + 1 = 1 . since integers are not part of the problem specification for the eight puzzle  absolver ii does not apply transformations such as sum. in contrast  to derive the fool's disk heuristic  absolver ii only applies sum  to the 1 radii  and not other transformations; it therefore searches a space of size 1  = 1 . 
the results of this table can be summarized as follows. 
absolver ii discovered effective admissible heuristics in 1 out of the 1 domains by exploring only a fraction of the space of heuristics derivable by the abstracting transformations in our catalog. absolver ii discovered 1 novel heuristics  1 of which turned out to be effective. the novel effective heuristics include the first known  nontrivial  admissible heuristic for the 1 x 1 x 1 rubik's cube  partially precomputed center-corner   which resulted in roughly 1 orders of magnitude speedup with a* over blind search for long solutions; the best admissible heuristic for the eight puzzle  precomputed x - y     which expanded 1 times fewer states than the linear conflict heuristic  hansson et a/.  1   an adjusted more informed version of the manhattan distance heuristic; a heuristic in the rooms world problem  search-computed box distance   which counts the m i n i m u m number of rooms each box must pass through to reach its goal destination and which expanded 1 times fewer states than blind search; the diameters fool's disk heuristic  which expanded 1 times fewer states than blind search; and an instance insanity heuristic  which is analogous to the diameter's heuristic in that opposite side colors are corn-
1
　　 problem formulations  methods for choosing good formulations  derivations  and performance of the resulting heuristics are detailed in  prieditis  1 . 
1 	learning and knowledge acquisition 

table 1: table of admissible heuristics discovered by absolver ii  * = novel; + = effective  
bined and which expanded 1 times fewer states than blind search. 
   absolver ii derived several known admissible heuristics including the manhattan distance heuristic of the eight puzzle  using a different formulation than for the x - y heuristic   the number of misplaced disks heuristic of the towers of hanoi  the mutilated checkerboard heuristic  and the number of misplaced blocks heuristic. all except the manhattan distance heuristic were of the same complexity as the originals-the manhattan distance heuristic is slower by o n  for n x n puzzles because the derived heuristic uses search to compute the number of moves needed to get each tile from its current location to its goal location. 1 
   absolver ii derived several inferior heuristics. in the 1-d routing domain  absolver ii derived the  unvisited signals  heuristic  which returns a count of the number of non-reached signal locations  instead of the more informed steiner tree heuristic  which returns the length of a m i n i m u m rectilinear spanning tree and which we derived by hand  prieditis  1   because it dropped a relation that was too salient for the problem. in the traveling salesperson problem  absolver ii derived the 
 unvisited cities* heuristic  which computes the sum of the least cost edges leading to an unvisited city over all unvisited cities  instead of the more informed minimal spanning tree heuristic  which we derived by hand  prieditis  1   because we have not implemented the speedup required to derive the m i n i m a l spanning tree heuristic. 
   absolver ii failed to find an effective admissible heuristic for the think-a-dot  eight queens  and scheduling problems for the same reason we failed to find one by 
1
　　assuming finite differencing and ignoring a one time 1 n1  initial computation. 

hand  prieditis  1 : all abstractions that could be sped up removed too many important details and therefore resulted in relatively uninformed heuristics. for example  to obtain the factorable abstracted problem that results in the unassigned jobs heuristic for the scheduling domain  the time and seriality constraints must be dropped. the resulting heuristic  which returns the mini m u m costs of unassigned jobs  is poorly informed. our approach to discovering admissible heuristics appears to be unsuitable when the original problem is characterized by high goal or operator  interference   many operators directly change a large proportion of subgoals in the original problem or make a large proportion of operators subsequently inapplicable  and all abstracted problems are characterized by low goal or operator  interference   few operators directly change a large proportion of subgoals or make operators inapplicable . of course  it may be that to derive effective admissible heuristics for such domains requires abstractions and speedups beyond our model or that we were not able to find a  good  formulation in which to derive heuristics. 
1 	conclusions and future work 
absolver ii tractably discovered many known admissible heuristics  though with varying efficiency relative to the original versions  and some novel effective admissible heuristics by using a means-ends analysis search strategy. some of these heuristics were still effective even though they are computed by search. such searchcomputed heuristics might be important in domains where effective closed-form heuristics cannot be found  e.g. rooms world . 
   as absolver ii is an experimental system  it has several shortcomings  each of which suggests interesting directions for future research. first  because it sometimes drops salient relations of a problem  it might be enhanced by a theory that links information loss via abstraction to accuracy of the resulting heuristics. this theory might allow absolver ii to predict the effectiveness of heuristics without testing them  which is currently left up to the user. second  non-abstracting transformations might be required to derive effective heuristics in certain domains  e.g. eight-queens . t h i r d   absolver ii might be able to boost the informedness of certain admissible heuristics by taking into account interactions in the base level between independently solvable factored subproblerns in the abstract level. for example  the lc heuristic might be derivable by incrementing the manhattan distance heuristic by 1 for each base-level interaction found between independent factors with only one shortest path solution. finally  absolver ii sometimes derives inferior heuristics because it overestimates the number of relations to drop to remove interactions; examples could help it focus on those interactions that actually occur. for example  absolver ii could assume  at the cost of admissibility  that a problem is factorable until an interaction is detected among its factors when computing a heuristic for a particular problem instance. once such an interaction is detected  its cause could be located and eliminated by abstraction. 
despite 	its 	shortcomings  	absolver 	ii 	concretely demonstrates that effective admissible heuristics can be tractably discovered by a machine. 
acknowledgements 
thanks 	go 	to 	jack 	mostow  	tom 	mitchell  	alex 
borgida  saul amarel  haym hirsh  christina chang  mukesh dalai  sridhar mahadcvan  and prasad tadepalli. thanks also go to rich cooperman for testing the rubik's cube heuristics and to rich korf for supplying the ida* program used to collect data for the manhattan distance heuristic. 
