
we introduce a new approach to computing answer sets of logic programs based on conceptsfromconstraint processing  csp  and satisfiability checking  sat . the idea is to view inferences in answer set programming  asp  as unit propagation on nogoods. this provides us with a uniform constraintbased framework for the different kinds of inferences in asp. it also allows us to apply advanced techniquesfromthe areas of csp and sat. we have implemented our approach in the new asp solver clasp. our experiments show that the approach is competitive with state-of-the-art asp solvers.
1 introduction
answer set programming  asp;  baral  1   has become an attractive tool for knowledge representation and reasoning. although the correspondingsolvers are highly optimized  cf.  simons et al.  1; leone et al.  1    their performance does not match the one of state-of-the-art solvers for satisfiability checking  sat;  mitchell  1  . however  computational mechanisms of sat and asp solvers are not that far-off. this can  for instance  be seen on the success of sat-based asp solvers assat  lin and zhao  1  and cmodels  giunchiglia et al.  1 . but despite the close relationship to sat and  more generally  constraint processing  csp;  dechter  1    state-of-the-art look-back techniques from these areas  like backjumping  conflict-driven learning  and restarts  are not yet established in genuine asp solvers. in fact  recent approachesto adopt such techniques ward and schlipf  1; ricca et al.  1; lin et al.  1  are rather implementation-specific and lack generality.
¡¡we address this deficiency by introducing a new computational approach to asp solving  centered around the csp concept of a nogood. apart from the fact that this allows us to easily integrate solving technology from the areas of csp and sat  e.g.  conflict-driven learning  backjumping  watched literals  etc.  it also provides us with a uniform representation of inferences from logic program rules  unfounded sets  as well as nogoods learned from conflicts.
¡¡after establishing the formal background  we provide in section 1 a constraint-based specification of asp solving in terms of nogoods. based on this uniform representation  we develop in section 1 algorithms for asp solving that rely on advanced csp and sat techniques. notably  our solving procedure is centered around conflict-driven learning and backjumping. in section 1  we describe our new asp solver clasp  implementing our approach. we finally provide empirical results demonstrating the competitiveness of clasp.
1 background
given an alphabet p  a  normal  logic program is a finite set of rules of the form p1 ¡û p1 ... pm not pm+1 ... not pn where 1 ¡Ü m ¡Ü n and pi ¡Ê p is an atom for 1 ¡Ü i ¡Ü n.
a body literal is an atom p or its negation not p. for a rule r  let head r  = p1 be the head of r and body r  = {p1 ... pm not pm+1 ... not pn} be the body of r. the set of atoms occurring in a logic program ¦° is denoted by atom ¦° . the set of bodies in ¦° is body ¦°  = {body r  | r ¡Ê ¦°}. for regrouping rule bodies sharing the same head p  define body p  = {body r  | r ¡Ê ¦° head r  = p}. in asp  the semantics of a program ¦° is given by its answer sets  being total well-foundedmodels of ¦°. for a formal introduction to asp  we refer the reader to  baral  1 .
¡¡a boolean assignment a over a domain  dom a   is a sequence  ¦Ò1 ... ¦Òn  of signed literals ¦Òi of form tp or fp for p ¡Ê dom a  and 1 ¡Ü i ¡Ü n; tp expresses that p is true and fp that it is false.  we omit the attribute signed for literals whenever clear from the context.  we denote the complement of a literal ¦Ò by ¦Ò  that is  tp = fp and

fp = tp. we let a   b denote the sequence obtained by concatenating assignments a and b. we sometimes abuse notation and identify an assignment with the set of its contained literals. given this  we access true and false propositions in a via at = {p ¡Ê dom a  | tp ¡Ê a} and af = {p ¡Ê dom a  | fp ¡Ê a}.
¡¡for a canonical representation of constraints  we use the csp concept of a nogood. in our setting  a nogood is a set {¦Ò1 ... ¦Òn} of signed literals  expressing a constraint violated by any assignment containing ¦Ò1 ... ¦Òn. an assignment a such that at ¡È af = dom a  and at ¡É af =   is a solution for a set ¦¤ of nogoods  if for all ¦Ä ¡Ê ¦¤.
¡¡for a nogood ¦Ä  a literal ¦Ò ¡Ê ¦Ä  and an assignment a  we say that ¦Ò is unit-resulting for ¦Ä wrt a  if  1  ¦Ä   a = {¦Ò} and  1 . by  1   ¦Ò is the single literal from ¦Ä that is not contained in a. this implies that a violated constraint does not have a unit-resulting literal. condition  1  makes sure that no duplicates are introduced: if a already contains ¦Ò  then it is no longer unit-resulting. for instance  literal fq is unit-resulting for nogood {fp tq} wrt assignment  fp   but neither wrt  fp fq  nor wrt  fp tq . note that our notion of a unit-resulting literal is closely related to the unit clause rule of dpll  cf.  mitchell  1  . for a set ¦¤ of nogoods and an assignment a  we call unit propagation the iterated process of extending a with unit-resulting literals until no further literal is unit-resulting for any nogood in ¦¤.
1 nogoods of logic programs
inferences in asp rely on atoms and program rules  which can be expressed by using atoms and bodies. for a program ¦°  we thus fix the domain of assignments a to dom a  = atom ¦°  ¡È body ¦° . such a hybrid approach may result in exponentiallysmaller search spaces  gebser and schaub  1 ; it moreover allows for an adequate representation of nogoods  as we show in the sequel.
¡¡our approach is guided by the idea of lin and zhao  and decomposes asp solving into  local  inferences obtainable from the clark completion of a program  clark  1  and those obtainable from loop formulas. we begin with nogoods capturing inferences from the clark completion.
¡¡the body of a rule is true if all its body literals are true. conversely  some of its literals must be false if the body is false. for a body ¦Â = {p1 ... pm not pm+1 ... not pn}  the following nogood captures this:
¦Ä ¦Â  = {f¦Â tp1 ... tpm fpm+1 ... fpn}
intuitively  ¦Ä ¦Â  is a constraint enforcing the truth of body ¦Â  or the falsity of a contained literal. e.g. for body {x not y}  we obtain ¦Ä {x not y}  = {f{x not y} tx fy}.
¡¡additionally  a body must be false if one of its literals is false. and conversely all contained literals must be true if the body is true. for ¦Â = {p1 ... pm not pm+1 ... not pn}  this is reflected by the following set of nogoods:
¦¤ ¦Â  = {{t¦Â fp1} ... {t¦Â fpm} 
{t¦Â tpm+1} ... {t¦Â tpn}}
taking again body {x not y}  we obtain ¦¤ {x not y}  = {{t{x not y} fx} {t{x not y} ty}}.
¡¡nogoods induce a set of clauses  which can be used for investigating the logical contents of the underlying inferences. given a program ¦°  we associate a nogood ¦Ä = {tp1 ... tpm fpm+1 ... fpn} with the clause ¦Ã ¦Ä  = { q1 ...  qm qm+1 ... qn} where qi = pi  if pi ¡Ê atom ¦°   and qi = p¦Â  if pi = ¦Â ¡Ê body ¦°   for 1 ¡Ü i ¡Ü n; and define ¦£ ¦¤  = {¦Ã ¦Ä  | ¦Ä ¡Ê ¦¤} for a set of nogoods ¦¤. for the bodies of ¦°  we obtain the following correspondence.
proposition 1 let ¦° be a logic program.
the set of clauses
{¦Ã ¦Ä ¦Â   | ¦Â ¡Ê body ¦° } ¡È {¦Ã ¡Ê ¦£ ¦¤ ¦Â   | ¦Â ¡Ê body ¦° } is logically equivalent to the propositional theory
{p¦Â ¡Ô p1 ¡Ä ¡¤¡¤¡¤ ¡Ä pm ¡Ä  pm+1 ¡Ä ¡¤¡¤¡¤ ¡Ä  pn | ¦Â ¡Ê body ¦°  ¦Â = {p1 ... pm not pm+1 ... not pn}}.
this result captures the intuition that a body should be equivalent to the conjunction of its body literals.
¡¡we now come to inferences primarily aiming at atoms. an atom p must be true if some body in body p  is true. conversely  all elements of body p  must be false if p is false. for body p  = {¦Â1 ... ¦Âk}  we get the nogoods:
¦¤ p  = {{fp t¦Â1} ... {fp t¦Âk}}
for example  for an atom x with body x  = {{y} {not z}}  we get ¦¤ x  = {{fx t{y}} {fx t{not z}}}.
¡¡finally  an atom p must be false if all elements of body p  are false. and conversely  some body in body p  must be true if p is true. for body p  = {¦Â1 ... ¦Âk}  this is reflected by the following nogood:
¦Ä p  = {tp f¦Â1 ... f¦Âk}
taking once more atom x with body x  = {{y} {not z}}  we obtain ¦Ä x  = {tx f{y} f{not z}}.
dually to proposition 1  we have the following for atoms.
proposition 1 let ¦° be a logic program. the set of clauses
{¦Ã ¡Ê ¦£ ¦¤ p   | p ¡Ê atom ¦° } ¡È {¦Ã ¦Ä p   | p ¡Ê atom ¦° } is logically equivalent to the propositional theory
{p ¡Ô p¦Â1 ¡Å ¡¤¡¤¡¤ ¡Å p¦Âk | p ¡Ê atom ¦°  body p  = {¦Â1 ... ¦Âk}}.
combining the last propositions yields the following result.
theorem 1 let ¦° be a tight logic program and
¦¤¦° = {¦Ä ¦Â  | ¦Â ¡Ê body ¦° } ¡È {¦Ä ¡Ê ¦¤ ¦Â  | ¦Â ¡Ê body ¦° } ¡È {¦Ä p  | p ¡Ê atom ¦° } ¡È {¦Ä ¡Ê ¦¤ p  | p ¡Ê atom ¦° }.
then  x   atom ¦°  is an answer set of ¦° iff x = at ¡É atom ¦°  for a  unique  solution a for ¦¤¦°.
¡¡the nogoods in ¦¤¦° capture the supported models of a program  apt et al.  1 . any answer set is a supported model  but the converse only holds for tight programs  fages  1 . the mismatch on non-tight programs is caused by loops  lin and zhao  1   responsible for cyclic support among true atoms. such cyclic support can be prohibited by loop formulas. as shown in  lee  1   the answer sets of a program ¦° are precisely the models of ¦° that satisfy the loop formulas of all non-empty subsets of atom ¦° .1 observe that the exponential number of loops in the worst case  lifschitz and razborov  1  makes an enumeration of all loop formulas infeasible. all loop formulas can however be checked in linear time  and propagation within genuine asp solvers makes sure that they are satisfied by a solution.
¡¡for a program ¦° and some u   atom ¦°   we define the external bodies of u for ¦°  eb¦° u   as
{body r  | r ¡Ê ¦° head r  ¡Ê u body r  ¡É u =  }.
the  disjunctive  loop formula of u for ¦°  lf¦° u   is
  where ¦Â+ = ¦Â ¡É atom ¦°  and ¦Â  = {p | not p ¡Ê ¦Â}. the loop formula of a set u of atoms enforces all elements of u to be false  if u is not externally supported  lee  1 .
¡¡to capture the effect of a loop formula induced by a set u   atom ¦°   we define the loop nogood of an atom p ¡Ê u
as
¦Ë p u  = {f¦Â1 ... f¦Âk tp}
where eb¦° u  = {¦Â1 ... ¦Âk}. overall  we get the following set of loop nogoods for a program ¦°:
		 1 
observe that loop nogoods make direct use of the bodies in eb¦° u  = {¦Â1 ... ¦Âk}  unlike loop formulas lf¦° u  relying on the literals in each ¦Âi. using bodies in loop nogoods is reasonable because unit propagation on completion nogoods makes a body false if it contains a false literal. notably  the usage of bodies avoids a combinatorial blow-up  faced when expressing these constraints in terms of body literals. in fact  representing ¦Ë p u  in terms of body literals yields about |¦Â1 ¡Á ¡¤¡¤¡¤ ¡Á ¦Âk| nogoods instead of a single one. dropping the tightness requirement  we can show that completion and loop nogoods characterize answer sets.
theorem 1 let ¦° be a logic program  let ¦¤¦° and ¦«¦° as in theorem 1 and  1 .
¡¡then  x atom ¦°  is an answer set of ¦° iff x = at ¡É atom ¦°  for a  unique  solution a for ¦¤¦° ¡È ¦«¦°.
the nogoods in ¦¤¦° ¡È ¦«¦° describe a set of constraints that must principally be checked for computing answer sets. while the size of ¦¤¦° is linear in atom ¦° ¡Ábody ¦°   the one of ¦«¦° is exponential. these magnitudes apply to all existing asp solvers  where ¦¤¦° is either encoded via dependency graphs  linking atoms and bodies/rules  or given through the clark completion of ¦°. loop nogoods in ¦«¦° are determined only on demand by dedicated algorithms.
1 conflict-driven asp solving
given the specification of asp solving in terms of nogoods  we can now make use of advanced techniques from csp and sat for developing equally advanced asp solving procedures. different from sat  where every  known  nogood is usually explicated as a clause  our algorithms work on logic programs  inducing several kinds of nogoods. in particular  the exponentiallymany nogoodsresulting from loop formulas are implicitly given by a program  and determined only when used for propagation. the key role of the different kinds of  and partially implicit  constraints  expressed as nogoods  is to identify a reason responsible for deriving a literal by unit propagation. this makes the logical fundament of asp solving the same as the one of csp and sat solving  so that we can directly apply similar reasoning strategies  without the need of a sat conversion or proprietary designs.
¡¡to begin  we give a specification of our nogood propagation procedure in algorithm 1. propagation works on a program ¦°  a set   of recorded nogoods  and an assignment a.
first  we invoke localpropagation on ¦° and accumulated nogoods in  . this function adds unit-resulting literals to a  derived via nogoods either in ¦¤¦° or in  ; that is  a

algorithm 1: nogoodpropagation

input : a program ¦°  a set   of nogoods  and an assignment a.
output: an extended assignment and set of nogoods.
1 u ¡û  	// set of unfounded atoms
1 loop

fixpoint of unit propagation is computed. if localpropagation yields a violated nogood ¦Ä  line 1   then a cannot be extended to a solution. also if ¦° is tight  all unfounded atoms are already falsified. in both cases  we are done with nogood propagation. only if ¦° is non-tight  we check whether an unfounded set  van gelder et al.  1   accumulated in u  has to be falsified.
¡¡initially  u is empty; so in line 1 we determine an unfounded set. note that  if some non-false atom is unfounded  there always is an unfounded set not containing any false atoms. in section 1  we describe our implementation of unfoundedset; we here only require that an unfounded set u of non-false atoms is returned  if it exists. if so  we select in line 1 an atom p from u and add its loop nogood ¦Ë p u  to    line 1 .1 if p is true  then ¦Ë p u  is violated  and we return a and    line 1 . otherwise  fp is unit-resulting for ¦Ë p u  wrt a  and we add fp to a  line 1 . having falsified a single element of u  we re-invoke localpropagation before adding any further loop nogoods. in fact  completion nogoods in ¦¤¦° might suffice for falsifying the residual atoms in u. for example  consider u = {x y z} and rules x ¡û z  y ¡û x  z ¡û y: from fx  we can derive fy and fz. but generally  falsifying a single element does not allow for falsifying the whole set u only via completion nogoods. if we add rule y ¡û z to the above example  then fy and fz are no longer derivable. this is reflected in line 1  where we remove false atoms from u. the shrunken set u is still unfounded  and if it is non-empty  we can immediately determine another loop nogood to falsify the next element of u. observe that no further unfounded atoms are computed until the ones in u are expended. with changing set u  the atom p  selected in line 1  and the bodies in loop nogood ¦Ë p u  change in each iteration  aiming at a firmer representation of the respective unfounded set.
¡¡all in all  our nogood propagation procedure interleaves unit propagation on completion and accumulated nogoods algorithm 1: cdnl-asp
	input	: a program ¦°.
output: an answer set of ¦°.
1 a ¡û  	// assignment over atom ¦°  ¡È body ¦° 
1   ¡û  	// set of  dynamic  nogoods
1 dl ¡û 1	// decision level
1 loop
1
with the recording and propagation of loop nogoods. the latter is only done if the underlying program is non-tight and the falsity of unfoundedatoms cannotbe determined via other nogoods. our approach favors local propagation over unfounded set computations. this is motivated by the fact that local propagation does not add any nogoods to    hence  it is more economical than unfounded set falsification. we further discuss the relation between our propagation strategy and other approaches in section 1.
¡¡conflict-driven nogood learning. our basic algorithm for deciding whether a program has an answer set is similar to conflict-driven clause learning  cdcl  with first-uip scheme  mitchell  1 . given a program ¦°  algorithm 1 starts from an empty assignment a and an empty set   of learned nogoods. via the decision level dl  we count decision literals  i.e.  the literals in a not derived by nogood propagation. the initial value of dl is 1  it is incremented before a decision literal is added to a. for a literal ¦Ò ¡Ê a  we access via dl ¦Ò  the decision level of ¦Ò  that is  the value dl had when ¦Ò was added to a. after encountering a conflict  the decision level is used to guide backjumping.
¡¡the loop of algorithm 1 is similar to cdcl  so we here only sketch the principal steps. first  function nogoodpropagation deterministically extends a  and    as described above. if this yields a conflict  line 1   function conflictanalysis  see below  determines a conflict nogood ¦Ä to be recorded  a unique implication point  uip  ¦Òuip  and a decision level k to jump back to. backjumping and nogood recording work as with cdcl  in particular  a conflict at decision level 1 indicates the non-existence of an answer set. if a is a solution  line 1   the atoms of ¦° that are true in a form an answer set of ¦°. finally  if a is non-conflictingand partial  a decision literal ¦Òd is selected according to some heuristics  see section 1 on further details  and added to a. note that algorithm 1: conflictanalysis
input	: a violated nogood ¦Ä  a program ¦°  a set   of nogoods  and an assignment a.
output: a derived nogood  a uip  and a decision level.

1 while
1let	¡Ê ¦¤¦°	st	¡Ê	and
1¦Ä ¡û  ¦Ä   {¦Ò}  ¡È  ¦Å   {¦Ò} 
1let ¦Ò ¡Ê ¦Ä st b = c    ¦Ò    c and ¦Ä   {¦Ò}   c
1b ¡û c
1 k ¡û max {dl ¦Ñ  | ¦Ñ ¡Ê ¦Ä   {¦Ò}} ¡È {1} 
1 return  ¦Ä ¦Ò k 

¦Òd belongs to the new decision level dl + 1.
¡¡our conflict analysis procedure determines an asserting nogood ¦Ä. that is  after backjumping ¦Ä yields a unit-resulting literal  leading algorithm 1 into a different part of the search space than traversed before. this is similar to an asserting clause  determined by conflict analysis in cdcl. in deriving ¦Ä  we follow the first-uip scheme and stop conflict analysis at the first uip that is found; no further uips are explored. though our conflict analysis procedure is similar to its classical cdcl counterpart we need subtle adjustments. the reason is that unfounded set inference works in a directed way: it only falsifies unfounded atoms  but does not  protect  true atoms from becoming unfounded. for illustration  consider ¦° = {x ¡û not y ;y ¡û not x;u ¡û x;u ¡û v ;v ¡û u y} along with assignment a =  tu . note that tu is a decision literal; its decision level is 1. local propagation on ¦¤¦° and a yields no inferences  due to body u  = {{x} {v}}   and there is no unfounded set. when we extend a by decision literal ty at level 1  local propagation sets atom x and body {x} to false  and v to true . but then  the set {u v} becomes unfounded  which makes us record the loop nogood ¦Ä = ¦Ë u {u v}  = {f{x} tu}. since a contains f{x} and tu  nogood ¦Ä is violated. also  ¦Ä contains only one literal added to a at decision level 1: f{x}. hence  f{x} is a uip. in this example  the violated nogood ¦Ä is immediately asserting. a situation like this cannot occur in classical cdcl  where the initial violated clause always contains more than one literal from the current decision level. the difference to cdcl is caused by the directedness of unfounded set inference in asp  which is  partial   in the sense that not all logical consequences are derived. in terms of a loop nogood {f¦Â1 ... f¦Âk tp}  unfounded set inference can only derive fp  but not t¦Âi for a body ¦Âi  1 ¡Ü i ¡Ü k   at least as long as the loop nogood is not made explicit by recording it. for ¦Ä = {f{x} tu} as above  unfounded set inference would have derived fu at decision level 1  if we had selected f{x} as the decision literal. however  it does not derive t{x} from assignment  tu   which is inferred by unit propagation once ¦Ä is available as an explicit constraint.  undirected unfounded set inference is not yet algorithmically solved. current algorithms only determine unfounded atoms  but not bodies that must be true according to an  implicit  loop nogood. 
¡¡algorithm 1 shows our conflict analysis procedure. it works on an assignment a containing a violated nogood ¦Ä  either from the program ¦° and so in ¦¤¦°  or from the recorded nogoods in  . in line 1  we determine via ¦Ò the literal from ¦Ä added last to a. as mentioned above  ¦Ò might already be a uip  that is  the single literal in ¦Ä from the current decision level. if ¦Ò is a uip  we do not enter the while-loop in line 1. otherwise  ¦Ä contains at least one literal other than ¦Ò from the current decision level. note that  in this case  ¦Ò is not a decision literal. hence  there is some nogood ¦Å in ¦¤¦° or   for which ¦Ò has been unit-resulting. such an ¦Å is determined in line 1  and in line 1 we resolve ¦Ä and ¦Å into a new nogood¦Ä. in line 1  we determine as new ¦Ò the literal from the new ¦Ä added last to a. in each iteration  ¦Ò moves closer to the front of a. hence  we finally derive a nogood ¦Ä that contains exactly one literal ¦Ò from the current decision level; in the worst case  it is the decision literal. in line 1  we determine the decision level to jump back to as the maximum level of any literal in ¦Ä other than ¦Ò. algorithm conflictanalysis is very similar to the first-uip scheme for cdcl. the difference is that conflict resolution might start from an asserting nogood.
1 the clasp system
our new system clasp  implements our approach to asp solving. it combines the high-level modeling capacities of asp with state-of-the-art techniques from the area of boolean constraint solving. unlike existing asp solvers  clasp is originally designed and optimized for conflictdriven asp solving. rather than applying a sat solver to a cnf conversion  clasp directly incorporates suitable data structures  particularly fitting backjumping and learning. this includes dedicated treatment of binary and ternary nogoods  ryan  1   and watched literals for unit propagation on  long  nogoods  moskewicz et al.  1 . unlike smodelscc  ward and schlipf  1   which builds a material implication graph for keeping track of the multitude of inference rules found in asp solving  clasp uses the more economical approach of sat solvers: for a derived literal  it only stores a pointer to the responsible constraint in ¦¤¦° ¡È  .
¡¡unfounded set detection within clasp combines smodels' source pointer technique  simons  1  with the unfounded set computation algorithm described in  anger et al.  1 . it aims at small and  loop-encompassing   rather than greatest unfounded sets  as determined by smodels  simons et al.  1  and dlv  leone et al.  1 . notably  clasp recognizes violated loop nogoodsthat are immediately asserting  cf. section 1   so that the same nogood is not recorded twice.
¡¡the primary operation mode of clasp is conflict-driven nogood learning. beyond backjumping and learning  clasp features a number of related techniques  typically found in cdcl-based sat solvers. clasp incorporates restarts  deletion of recorded conflict and loop nogoods  and decision heuristics favoring literals from conflict nogoods. all these features are configurable via command line options. the default restart and nogood deletion policies are adopted from minisat  ee¡än and s¡§orensson  1 ; the standard heuristics is an adjustment of berkmin  goldberg and novikov  1 . although algorithm 1 details the search for one answer set  clasp also allows for enumerating answer sets. this is accomplished by interleaving backjumping with  systematic  backtracking: after a solution has been found  its decision literals can only be backtracked chronologically; backjumping is restricted for not repeating already enumerated solutions. this strategy avoids the generation of nogoods excluding entire solutions  as done for instance by smodelscc and mchaff 1. clasp's second major operation mode runs  systematic  backtracking without learning. this is similar to the strategy of standard asp solvers like smodels  using lookahead. both operation modes are implemented in a uniform framework  which also allows us to evaluate the efficiency of advanced sat implementation techniques  such as watched literals  in a standard asp solver.
1 experiments
we conducted experiments on a variety of problem classes. our comparison considers clasp  rc1  in its two major modes:  a  the standard one using backjumping and learning  and  b  the systematic backtracking mode using lookahead but no learning. we refer to these variants as claspa and claspb. as  traditional  asp solver  we include smodels  1 . beyond some variations  smodels' strategy is similar to claspb. we also incorporate assat  1  and cmodels  1   both using mchaff  spelt1   and smodelscc  1 . among all compared solvers  smodelscc is closest to claspa. sat-based solvers assat and cmodels convert a logic program into cnf and delegate the search for a supported model to mchaff. for tight programs  this approach amounts to clasp in mode  a . in the non-tight case  assat and cmodels delay checking loop nogoods until an assignment is total  while all other solvers integrate it into their propagation.
¡¡all experiments were run on a 1ghz pc on linux. we report results in seconds  taking the average of 1 runs  each restricted to 1s time and 1gb ram. a timeout is indicated by  - . all solvers were run with their default settings except for smodelscc  for which we used option  nolookahead  as recommended by the developers. the instances used in our experiments as well as extended results  e.g. for dlv and nomore++  being excluded here due to lack of space  are available at  clasp  1 . in brief  the instances in table 1 and 1 are from the areas of bounded model checking  1;1   des cryptanalysis  1   blocksworld planning  1;1  hamiltonian cycles in clumpy graphs  1   hamiltonian paths for the gryzzles game  1   sokoban  1;1   and machine code superoptimization  1 . the instances numbered 1 and 1 are tight  all others are non-tight.
¡¡table 1 gives results for computing one answer set. on the tight instances 1  claspa performs comparable to assat and cmodels. sometimes it is even slightly faster  showing that the low-level implementation of clasp is competitive with stateof-the-art sat solvers  doing most of the work for assat and cmodels. regarding smodels  we see that its systematic backtracking approach does not scale very well; the same applies to clasp in mode  b . instances 1 and 1 are tight on their supported models  that is  every supported model is also an
	nr benchmark	assat cmodels smodelscc claspa claspb smodels
1dp 1.formula1-i-o1-b1.1.1.1.1.1.1dp 1.fsa-d-i-o1-b1.1.1.1.1.1.1elevator 1-d-s-o1-b1.1.1.1.111mmgt 1.fsa-d-i-o1-b1.1.1.1.1.1.1mmgt 1.fsa-d-s-o1-b1.1.1.1.1.1.1des-r1-p1-t1.1.1.1.1-11des-r1-p1-t1111--1des-r1-p1-t1.1.1.1.1--1des-r1-p1-t1.1.1.1.1-11des-r1-p1-t1.1.1.1.1--1p1 time1.1.1.1.1.1.1p1 time1.1.1.1.1.1.1clumpyhc1 1.1.1.1.1-11clumpyhc1 1.1.1.1.1-11clumpyhc1 1.1.1.1.1--1clumpyhc1 1.1.1.1.1--1clumpyhc1 1.1.1.1.1--1clumpyhc1 1.1.1.1.1--1clumpyhc1 1--11--1clumpyhc1 1--11--1gryzzles.1.1.1.1.1.1.1gryzzles.1.1.1.1.1.1.1gryzzles.1.1.1.1.1--1gryzzles.1.1.1.1.1.1.1gryzzles.1.1.1.1.1--1yorick.1.n1.len1.1.1.1.1.1.1yoshio.1.n1.len1-111--1yoshio.1.n1.len1.1.1.1.1.1.1yoshio.1.n1.len1.111--1yoshio.1.n1.len1.1.1.1.1.1.1table 1: experiments computing one answer set.
answer set. as unfounded set checks produce unnecessary overhead here  assat and cmodels are a bit faster than claspa. looking at the hamiltonian problems in 1  we see that smodelscc and claspa scale best. they outperform assat and cmodels by some orders of magnitude; on two clumpy graphs  assat and cmodels even time out  viz. 1 and 1 . both smodels and claspb are ineffective on hamiltonian problems and time out on most of the instances. on sokoban problems in 1  claspa outperforms the other solvers. only cmodels and smodelscc never time out  but they are much slower.
¡¡table 1 shows results for computing all answer sets  or for determining that no answer sets exist  1 #sol . given that assat cannot enumerate answer sets  we only include it on unsatisfiable programs. on satisfiable instances 1  we see that claspa is relatively fast enumerating all answer sets. the superoptimization instances in 1 are easily determined unsatisfiable by assat  cmodels  and claspa. both smodels and claspb show a clear exponential behavior and finally time out. surprisingly  smodelscc scales worst  that is  several orders of magnitude behind other learning solvers and timing out even before non-learning ones. we conjecture that this is because smodelscc does  differently from other learning solvers  not include rule bodies in conflict nogoods. looking at the satisfiable instances among 1  we see that claspa is faster enumerating all answer sets than any other solver we tested. unsatisfiable blocksworld problems 1 and 1 are most effectively solved by assat and cmodels.  note that instances 1 are tight on their supported models.  like with computing one answer set on  satisfiable  sokoban problems in 1  claspa is fastest on both satisfiable and unsatisfiable problems in 1.
nr benchmark	#sol	assat cmodels smodelscc claspa claspb smodels
1dp 1.formula1-i-o1-b1n/a111--1dp 1.fsa-d-i-o1-b1n/a11.1.1.1elevator 1-d-s-o1-b1n/a111111mmgt 1.fsa-d-i-o1-b1n/a111111mmgt 1.fsa-d-s-o1-b1n/a11111test11111111test11111111test11111111test111-1111test111-1-11test111-1--1p1 time11111111p1 time1n/a111111p1 time1n/a-11111p1 time11111111yorick.1.n1.len11111111yorick.1.n1.len1n/a-11--1yoshio.1.n1.len11111--1yoshio.1.n1.len1n/a-11--1yoshio.1.n1.len11111-11yoshio.1.n1.len1n/a-11--1yoshio.1.n1.len11111111yoshio.1.n1.len1n/a--1--1yoshio.1.n1.len11111111yoshio.1.n1.len1n/a-1111table 1: experiments computing all answer sets.
¡¡overall  we notice a huge gap between learning and nonlearning solvers: the latter frequently time out  while the best among the former solve the same instances within seconds  cf. table 1 . the short run-times of learning solvers do sometimes not permit a reliable comparison between them. we however see a clear distinction between different concepts: problems that are intractable for systematic backtracking methods are often easily dealt with using backjumping and learning. note that all our benchmarks are structured to some extent. this is useful for learning solvers  as structure can be explicated via learned constraints. the picture might be different on unstructured random problems as  e.g.  reported in the sat literature.
1 discussion
we have provided a uniform approach to asp solving  allowing for a transparent technology transfer from csp and sat. the idea is to view asp inferences as unit propagation on nogoods  reflecting constraints from program rules  unfounded sets  and conflicts. we have seen that sat translations are unnecessary for applying techniques found in sat solvers.
¡¡in contrast to sat  asp induces furtherimplicit constraints given by loop nogoods. though inherently present  these nogoods need only be explicated when used for propagation and conflict analysis. thus  sophisticated unfounded set checks still work on the logical fundament of csp and sat. based on this perception  we have provided a conflict-driven algorithm for asp solving  using state-of-the-art sat solving techniques. notably  our approach favors local propagation on explicit nogoods over unfounded set checks  which explicate inherent loop nogoods that give rise to unit propagation. in fact  many of the combinatorially constructable loop nogoods might be redundant  that is  entailed by completion and other loop nogoods.  for tight programs  the loop nogoods of all non-singletons are redundant.  in this respect  our approach guarantees that only non-redundant loop nogoods are used for propagation and  particularly  for conflict analysis.
¡¡we have implemented our approach in the clasp system. our empirical results show that clasp is competitive with existing asp solvers. the clasp system directly incorporates state-of-the-art techniques from boolean constraint solving  avoiding a sat translation as it is done by assat  cmodels  and sag  lin et al.  1 . also  clasp records loop nogoods only when ultimately needed for unit propagation; this is different from assat and sag  which determine loop formulas for all  terminating  loops. unlike genuine asp solvers smodels and dlv  clasp does not determine greatest unfounded sets. rather  it applies local propagation directly after an unfounded set has been found. different from dlv with backjumping  ricca et al.  1  and smodelscc  the inclusion of rule bodies in nogoods allows for a straightforward extension of unit propagation to asp  abolishing the need for multiple inference rules. notably  clasp can enumerate answer sets of a program without explicitly prohibiting already computed solutions by nogoods  as done by cmodels and smodelscc.
acknowledgments
the authors are grateful to wolfgang faber  yuliya lierler  and ilkka niemela¡§ for helpful comments on previous drafts of this paper.
