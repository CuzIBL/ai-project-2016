 
this paper represents a beginning development of a parallel truth maintenance system to interact with a parallel inference engine. we present a solution which performs status assignments in parallel to belief nodes in the reason maintenance system  rms  presented by  doyle  1    doyle  1 . we examine a previously described algorithm by  petrie  1  which fails to correctly detect termination of the status assignments. under petrie's algorithm  termination may go undetected and in certain circumstances  namely the existence of an unsatisfiable circularity  a false detection may occur. we present an algorithm that corrects these problems. 
1 introduction 
a major problem facing ai researchers today is that computation time for inferencing and related activities is extremely expensive. this means large knowledge bases will be almost impossible to use in practical applications that require a fast or predictable response time  e.g. realtime systems . however  by designing and using efficient parallel algorithms  we hope to generate a significant increase in speed over sequential methods. 
　we will present a solution which performs status assignments in parallel to belief nodes in the reason maintenance system  rms  presented by  doyle  1    doyle  1 .  petrie  1  describes an incomplete parallel algorithm using the technique of diffusing computation given by  dijkstra and scholten  1 . 
1 background 
in this section we present a brief overview of both termination detection for diffusing computation problem as presented by  dijkstra and scholten  1  and doyle's rms. then  we give petrie's parallel solution for giving status assignments to belief nodes and show how this solution can lead to incorrect termination detection. 
   *supported by mcdonnell aircraft company under contract number z1. 
1 	diffusing computation 
in the diffusing computation problem  we are given a system consisting of a number of nodes  processors  able to communicate over links. we assume the existence of a node without incoming links and call this node the environment or root. all other nodes are called internal nodes. initially each node is in a neutral state. a diffusing computation begins when the environment sends a message to one or more successor nodes. this message or set of messages is to be sent only once. 
　when a neutral internal node receives a message  it becomes engaged and may send messages to its successor nodes. at some later time it returns to the neutral state; nodes in the neutral state may not send messages. a node may change from neutral to engaged and back several times during the computation. 
　a diffusing computation is defined as having terminated when all nodes have reached the neutral state. the computation is such that only a finite number of messages is sent from any internal node. with this restriction  it can be shown that the computation will eventually terminate. 
　we require that the environment be able to tell that the diffusing computation has terminated. to detect termination  a signaling system is superimposed on the diffusing computation such that the environment will be signalled when the computation is completed. the signaling is restricted to require that from the moment the computation begins to the time the environment is signaled  each link will have carried as many messages in one direction as it has carried signals in the other direction. 
the signalling system obeys the following rules: 
rule 1 when a neutral node receives a message and becomes engaged  it  remembers  the identity of its engager. 
rule 1 when an engaged node becomes neutral  it sends a signal to its engager. 
rule 1 an engaged node may not become neutral until it has sent a signal for each message it has received; the signal for the message which caused it to become engaged is sent last  as implied by the rule 1 . 
rule 1 an engaged node may not become neutral until it has received a signal for each message it has sent. 
from these rules  the following theorems are concluded  see  dijkstra and scholten  1  : 
t h e o r e m 1 at all times  a directed path exists from the environment to each engaged node along the edges from engagers to engaged nodes. 
t h e o r e m 1 a bounded number of steps after the diffusing computation has terminated  the environment will have returned to the neutral state. 
t h e o r e m 1 when the environment has returned to the neutral state  the diffusing computation has terminated. 
1 	review of doyle's r m s 
an rms is used along with an inference engine  ie  to maintain a consistent set of beliefs and inferences. the inferences are then passed to the rms  which creates a node for each belief and maintains the dependencies between these beliefs. 
   each node in the rms is to be assigned a status of in or out  where an in label means the node is believed to be true  and an o u t label means either the truth value of the node is not known or the node is not believed to be true. associated with each node is a set of 
justifications  in which each justification contains an inset and an outset. an inset contains those nodes which must be believed in order for the node to be labeled in. an outset contains those nodes which must not be believed in order for the given node to be labeled in. a justification is valid if every node in its inset is labeled in and every node in its outset is labeled 
out. if at least one justification in a node's justification set is valid  the node is labeled in; otherwise the node is labeled out. 
　the consequences of a node c is the set of all nodes which mention c in one of their justifications. the supporters of the node  supporter-nodes  is the set of nodes which the rms used to determine the status of the node. for in nodes  the supporter-nodes are the inlist  j 
outlistof its supporting justification. the rms picks one node from each justification in the justification set to form the supporter-nodes of an out node. these nodes are either an o u t node from an inlist or an in node from an outlist in a justification. 
   the ancestors of a node are formed by taking the transitive closure of the supporter-nodes of that node. the set may include the node itself. 
1 	petrie's use of diffusing c o m p u t a t i o n 
to take advantage of the proofs supplied  dijkstra and 
scholten  1  for diffusing computations   petrie  1  proposed considering each node in a rms to be a separate processor. justifications are then represented as directed arcs from antecedents to the consequence; only a single consequence is computed by each rule in this representation. in all figures  a justification is represented by a circle w i t h incoming arcs f r o m antecedents and outgoing arcs to the consequence. a plus next to the antecedent arc indicates an antecedent in the i n s e t and a minus indicates an antecedent in the o u t s e t . diffusing computation is used to give a status assignment of in or o u t to each node corresponding to the labeling that is performed in doyle's algorithm. 
　petrie admits that his computation is incomplete in the same sense that doyle's is incomplete  which is with respect to unsatisfiable circularities being introduced into the network by a new justification. this in turn creates a graph for which no consistent status assignment can be found. 
   each processor stores the set of justifications for that node. messages are sent to consequences and signals are sent to antecedents in the justification set. when all belief nodes are in a neutral state  one node becomes the environment or root of the diffusing computation when its status changes from o u t to in by the entrance of a new justification  passed from the ie . 
   the algorithm begins by the root node issuing a  nil sweep   which sets the status of its transitive closure of consequences to nil. this is done using a diffusing computation. once the  nil sweep  has terminated  a second diffusing computation is begun for i n / o u t status assignments. 
   the use of the engager is as discussed in the previous section. once a node receives its first message from its engager  it checks to see if its status will change. a nil status will change to in or out  so all statuses will change at least once. if the status is unchanged  a signal is sent back to the predecessor and no messages are sent to the consequences. if the status of the node is changed  it sends messages to its consequences. a processor also replies to any sender if it has already received another message to which it has not replied  i.e. it is engaged and the new message does not change the node's current status assignment. a node replies to the engager  under normal circumstances  when it receives replies from all of its consequences or successors. 
　to detect unsatisfiable circularities  petrie proposes the following solution. along with a status message  an antecedent node sends a list of ancestors to its consequences. this list will include the antecedent when it is sent. if the consequent node appears in an ancestor list it receives  within a message that changes its status  it signals a  trouble reply  to its engager. thus a node can determine if its current status depends on itself. petrie states that if an engaged node switches status twice as a result of being its own ancestor then it is involved in an unsatisfiable circularity. we will also use this observation in our algorithm. 

	fulcomer and ball 	1 
p r o b l e m 	1 	incorrect definition 	of environment node. 
petrie does not define the environment node such that it has no incoming edges  which permits termination to be detected. in his computation  the environment node may have incoming edges  as in figure 1. since s is both a supporter of p and in the transitive closure of consequences of p  p may receive incoming messages. 
p r o b l e m 1 possible false termination detection in the presence of unsatisfiable circularities. 
   in detecting unsatisfiable circularities  petrie's solution allows the consequence to signal a  trouble reply  to its engager if the consequence appears in an ancestor list within a message which changes its status. but if the consequence signals  trouble  to its engager  it can violate all the rules regarding signalling the engager. such a signal must be sent only when the consequence becomes neutral; only after the consequence has sent signals for all other messages it has received; and only after it has received signals for all messages it has sent. 
   even if the sending of the trouble signal is otherwise legal  the sending of this signal makes the consequence neutral. since it must change status  it will have to send messages to transmit its new status to its consequences. these messages violate the requirement that neutral nodes send no messages. 
   the consequences which were engaged by the troubled node above may still be computing their own statuses. the signaling of the trouble reply has cut off the directed path from the environment to such consequences. the environment may detect termination while computation is still going on. thus it is possible to falsely detect termination. 
p r o b l e m 1 non-termination of the underlying computation. 
   the termination-detection algorithm for diffusing computations requires that all nodes send a finite number of messages. in petrie's algorithm  if an unsatisfiable circularity occurs all nodes on the cycle will compute forever  changing their statuses and sending update messages to their consequences on the cycle. petrie's algorithm detects the existence of such cycles but does not stop the status-assignment processing of the nodes on the cycle. 
1 improved algorithm 
the solution we present also uses diffusing computation to perform the status assignments. we use the same mapping petrie proposed  i.e. each node in the rms is a separate processor and justifications are represented as directed arcs from antecedents to a single consequence. we will use the term cycle to mean the circular passing of messages. a better term would be circularity  but its use becomes too cumbersome. for our purposes  a cycle may become an unsatisfiable circularity or may be satisfied. 
   in our solution  the environment or root node does not represent a belief. it is a separate node which is responsible for receiving the justification from the ie and passing the first message to the consequece of that justification to begin the computation. all belief nodes will be considered internal nodes and will compute the same algorithm. the node whose status changes because of the incoming justification will be called the head node. in this section we will discuss the actions of an internal node in general  including the handling of unsatisfiable circularities. then we will discuss the special characteristics of the head node and those of the environment. theorems and selected proofs appear in section 1. 
1 	actions of an i n t e r n a l n o d e 
we will refer to figure 1  throughout this section  in which the dotted justification arc represents the incoming justification from the ie  making p the head node. when an internal node  such as q  receives its first mes-

fiture 1. 
sage from an antecedent  such as t  it becomes engaged and t is considered its engager. a message is of the following form: 
 message type  antecedent  antecedent status  ancestor list  cycle list . 
each time q receives a message  it will send messages to its consequences  which is r in this figure  if q's status or label changes  or if its force list is non-empty. we will discuss the properties of the force list in a later section. 
   in order to perform the parallel status assignment computation  an internal node must have the following extra parameters. the state holds the entire state of belief node prior to the beginning of this computation. the ancestor list holds the node's current ancestor list. the possibles list holds all of the cycles this node has detected. the force list holds all of cycles which have previously been detected as unsatisfiable circularities. the signal wait list holds all ordered pairs of the form  cycle  'u'  and/or  cycle s'  to be sent within the signal to the nodes engager. the detection list holds those cycle list for which it has sent or will send an unsatisfiable pair  cycle 'u'  in its signal back to its engager. 
1.1 	  n i l sweep  message 
   if the message type is  nil sweep   and t is the engager of q  then t sends a message: 
    n i l sweep   t  n i l   1   ♀ . 
to q. at which time q performs the following steps:  1  sets t as its engager   1  saves its entire state prior to receipt of the message  1  sets its status to nil   1  clears its ancestor list   1  makes any changes to its justification list  invalidating any justifications where t was an antecedent if such justifications were previously valid   1  sends messages of the  nil sweep  to its consequences  

if q's status changed because of this message  and  1  signals back to t at any time  when all consequences have signaled to q  unless q receives another message to which it must return a signal before sending a signal to t. 
　by theorems 1 and 1  q will never receive a message of another type as long as it is engaged because of a  nil sweep  message  and the transitive closure of consequences of the head node will be set to nil before sending another message of a type other than  nil sweep . 
1.1 	 label  message 
　the  label  message has the same format as the  nil sweep  message  except the type of message is different  and all statuses being sent will be either in or out. 
　any node  such as r  which receives a  label  message from an antecedent  such as q  will perform the following: 
　if r's detection list is non-empty  then it has sent a pair   cyclelist  'u'  in the signal to its previous engager when r became neutral  for each cyclelist that is an element of r's detection list. upon receiving a label message at this time  r will place new pairs in it's signal wait list of the form   cyclelist  's'  for all elements of its detection list  and set the detection list to empty. this is necessary for handling circularities that may have looked unsatisfiable at one point during the computation  but may actually be satisfiable once all the labels have been propogated. the elements of the signal wait list will be included in r's signal to its engager. once r signals its engager  its signal wait list is cleared. 
if the cycle list sent within q's message is non-empty  
r must place the cycle list in its force list after it has sent its messages out or has determined that it does not send any further messages. if r determines that it must send messages because of the message it received from q  r must include the cycle list received in its message to its consequence in the cycle list. this ensures that each member of the cycle becomes aware of its presence on that cycle. if the cycle list is already present in the force list  this cycle list will not be passed in the next messages sent by r. if r determines that it does not send any messages because of q  then the cycle list is not passed. below  when the case asks if r's force list is empty  it is asking for the state of the force list prior to r's receipt of the message. 
　r will then do the following steps if r itself does not appear in the ancestor list sent by q. 
　case 1: the message does not cause r to change status and r's force list is empty. 
　r may signal back at any time to the sender of the message  obeying all rules of signaling. r will not send any further messages to its consequents. 
　case 1: the message does not cause r to change status and r's force list is non-empty. 
　each element of the force list tells r which possible unsatisifiable circularities it is on. r intersects each element of the force list with its consequences. for each result of the intersection  which is the consequence on the cycle that r is present on  r is forced to send its current status. the force list is then set to empty. 
　case 1: the message does cause r to change status. 
　since r changes status  it must change its supporternodes and ancestors. then it sends its new status  and ancestor list using another  label  message  to all of its consequences. if r's force list is non-empty  it sets it to empty since those consequences on the force list will receive a message from r anyway. 
　internal node r will do the following if r does appear in the ancestor list sent a n d r's possibles list does not contain an element equivalent to the ancestor list r received. in other words  this is the first time r has detected it is on this specific cycle. 
　for case 1 above  r will not send any messages to any consequents. since it does not send messages through the cycle  it does not consider seeing a cycle at all. 
　for case 1 above  r is the first node of the cycle it received to detect that this cycle exists. but r may be involved in another cycle which may be an unsatisfiable circularity  therefore r must propagate its current status to the consequents on the cycles that are elements of the force list  but not necessarily to all consequents. 
　for case 1 above  since r must change status under these circumstances  it places the cycle list from the ancestor list q sent in its possibles list. then r resets its own ancestor list to itself only. all this is in preparation to detect an unsatisfiable circularity. r then sends out  label  messages to all its consequents  but it includes the detected cycle in the cycle list field of the message to its consequence on the detected cycle. the force list is reset to the incoming cycle. 
　internal node r will do following if r does appear in the ancestor list sent a n d r's possibles list does contain an element equivalent to the cycle r received on the ancestor list from q. 
for case 1 above  since r has no reason to pass any 
 label  messages to its consequences  it does not detect an unsatisfiable circularity. the cycle is removed from its possibles list. 
　for case 1 above  r is both engaged and has detected its own presence on a cycle. but since its status does not change  r cannot detect an unsatisfiable circularity. r may be involved in other unsatisfiable circularities because its force list is non-empty. thus r must send out its current status to all consequents that are elements of cycles on the force list  though r does not send out the cycle list it just received in these messages. then the force list is set to nil and the cycle is removed from r's possibles list. 
　for case 1 above  this will be the second time r is forced to change status due to the same cycle. therefore r is the first to detect a possible unsatisfiable circularity. it moves the cycle from the list of possibles to the detection list   deleting it from its possibles list   places this cycle in an ordered pair with *u' to send in its signal wait list r does not send any messages to any consequences  since it is currently in an inconsistent state. this is upheld even if the force list is non-empty. but since no messages are sent out  the force list remains as it is. thus r ceases the message passing around the nodes of 
	fulcomer and ball 	1 
this particular cycle. 
　the force list is what ensures that if any node on a cycle receives a message after an unsatisfiable circularity has been detected by some node on the cycle  that the node which detected the circularity and has included it in its signal to its engager  will now include the matching satisfied pair in its signal to its engager. this is a necessary construct  since a node may think it sees an unsatisfiable circularity and send such a signal  because of a delay in the message passing of another node which will satisfy the cycle. petrie gives an example of this using figure 1  in which the dotted line represents the incoming justification for p. thus p is the head node. after p sends out its label messages to q and t  messages are passed around the cycle q  r  s until q detects an unsatisfiable circularity and signals it to p  only to receive a satisfying message from delayed t  which causes q to signal the matching satisfying pair to t  which propagates it back to p. so no unsatisfiable circularity is present. 
1.1 	 reset  message 
　a third and final message that a node  say q  may receive is the  reset  message. the  reset  message also has the same format with all of its fields empty except for the type field. this message instructs q to reset itself to the state which it saved when it received its first  nil sweep  message. the reset message is sent when unsatisfiable circularity was detected within the graph during the assignment of in and out status to the belief nodes. we leave it as the responsibility of the head node to detect the actual presence of such a circularity as will be presented in the next section. 
　instead of leaving the graph in a state of inconsistent labelings  the graph will return to the state it was in prior to the entry of the justification which caused the diffusing computation. it is this part of the computation which is incomplete  in that we do not solve the labeling problem  but attempt to avoid it. 
the step an internal node follows when it receives the 
 reset  message is to simply reset its state and pass the message to its consequents. 
1 	actions of the environment and head node 
the head node is the consequent of the incoming justification. this node is engaged by the environment. every internal node will have the algorithm available for execution if it becomes the head node  but only one such node will execute the code during a single diffusing computation. the justification will be added to the head node's justification set and the appropriate supporternodes identified. computation proceeds only if the justification is valid and the head node changes status from out to in. the first set of messages the head node initiates are the  nil sweep  messages. the head node will only be set to nil if it is involved in some cycle present in its transitive closure of consequences  as in figure 1  where the dotted line represents an incoming justification. theorem 1 shows that eventually the head node will receive all signals back from its consequences after sending the  nil sweep  message. after all signals are received  the head node initiates the  label  messages. 
it is obvious that every node that receives a  nil sweep  message will eventually receive a  label  message. if the head node has the label of nil  it must check its justifications to change its own status  from nil to in or out before sending the first  label  message. in fig 1. the entering justification became invalid  so the head node  p  assigns itself the status of out  and sends its new status in the  label  messages to q. 
　since the head node is also an internal node  it may detect an unsatisfiable circularity which involves it. if the head node detects an unsatisfiable circularity in which it is involved  it saves this detection and the cycle list until all signals are received. once the head node receives all signals from its consequences  it performs a matching between the pairs  cycle  'u'  and  cycle  's'  propagated through the signals received  in an attempt to match every pair with a'u'toa pair with the same cycle list and an 's' by theorem 1  the existence of one pair with a 'u' without a match to a pair with an 's' means there exists an unsatisfiable circularity with the nodes in the unmatched cycle list. once such a circularity is detected  the head node will send out the  reset  messages to all its consequences. by theorem 1  eventually p will receive all signals from its consequences. then p will signal to its engager the environment  which will detect termination. if no unsatisfiable circularity can be detected  p will not issue the  reset  message  therefore not sending any messages to its consequents. as above  it will eventually signal its engager  the environment. 
1 proof of correctness 
this section presents theorems and selected proofs of the correctness of the algorithm for parallel status assignment. all proofs not given can be found in  fulcomer and ball  1 . previously we defined a cycle to be a circularity of status assignments  i.e. the status of each node within this circularity actually depends on itself  or a node is its own supporter. a node n detects a cycle c if n sees itself on the ancestor list sent in a message from an antecedent a and the status of a causes n to change status. a node is a detector of the cycle if the node detects the cycle. a node is no longer a detector of a cycle if the cycle has been broken. breaking a cycle occurs when a node in the cycle becomes supported by a node outside that cycle. a node n detects an unsatisfiable circularity c  if n is a detector of the cycle c  that matches and at any point prior to c being broken  n sees itself on the ancestor list sent in a message from the same antecedent as in c  such that n must change status. the definitions of detector and broken unsatisfiable circularity are the same as that for a cycle. the following lemmas are necessary. 
we state the following lemmas. 
lemma 1 the detector of an unbroken cycle is unique. 
lemma 1 the detector of an unbroken unsatisfiable circularity is unique  and this node is the unique detector of the unbroken cycle corresponding to this unsatisfiable circularity. 
lemma 1 // an unsatisfiable circularity c is detected  all nodes on c will have c in their force list 

lemma 1 let c be an unsaiisfiable circularity. if any node on c receives a message then all nodes on c will receive a message. 
lemma 1 let c be an unsaiisfiable circularity with n as its detector. another node on c cannot detect c as a cycle unless n has received a message resulting from the breaking of c. 
a corollary of this lemma is: 
corollary 1 let c be an unsaiisfiable circularity with 
n as its detector. another node on c cannot detect c as an unsatisfiable circularity unless n has received a message resulting from the breaking of c. 
lemma 1 let c be an unsaiisfiable circularity and n be its detector. the breaking of c results in n sending the pair  c  's'  in its signal to its engager. 
theorem 1 if an unsatisfiable circularity remains unbroken the message passing within the circularity will halt 
let c be the unsatisfiable circularity  and n be its detector. part of detecting c  involves n changing status. but by construction of the algorithm  n will not send out any messages when it has detected c. since n ceases all message sending  and none of the rules in section 1 have been violated by n ceasing  n will eventually enter the neutral state. if c remains unsatisfiable  i.e. c is not broken  then message passing around c will not occur during the rest of the computation. by lemmas 1  and 1  if any other messages are passed along c  n will eventually signal that c is satisfied. if c is satisfiable then all rules are maintained and n will eventually reach the neutral state. since these are the only two cases  the theorem holds. d 
theorem 1 let c be a cycle and p bethe head node. given p has received all signals corresponding to all  label  messages it has sent out. if the pair c  i u'  is propagated to the head node and no pair c  's'  is propagated to the head node  then c is ultimately unsatisfiable. 
　p cannot match the pair  c/u'  with a pair  c  's' . since  c 'u'  has reached p  by construction of the algorithm  there must exist some node n which detected c to be an unsatisfiable circularity. there is matching  c 's'  sent to p by n  so by lemma 1  n cannot have received another message after the detection of c. by lemma 1  no nodes on c received any messages. thus all nodes on c must still be in a state of inconsistency. therefore  an unsatisfiable circularity exists in the graph. o 
we state the following theorem without proof 
theorem 1 let c be a cycle. if for every pair c  l u'   there is a matching pair  c/s'  propagated to the head node  then no unsatisfiable circularity exists. 
theorem 1 there will be no overlapping between the  nil sweep'' and the labeling algorithm. 
to show this  we must show that all signals from  nil sweep  messages eventually reach the head node before any  label  messages are sent. since there is only one status involved in performing the  nil sweep   there can be no unsatisfiable circularities. even stronger  no node will detect any cycle because after the first change in status to nil  the node will not change again when another  nil sweep  message is received. we assume all node obey the rules in section 1. therefore when the head node receives all signals corresponding to the  nil sweep  messages it sent  all nodes in its transitive closure of consequences will be in the neutral state. d 
we state the following theorems without proof. 
theorem 1 there will be no overlapping among the labeling computation and the reset computation. 
theorem 1 there will be no overlapping of the  nil sweep  and the reset computation. 
theorem 1 if the reset compuiaiion is necessary  the head node will receive all signals corresponding to its reset messages  resulting in termination of diffusing computation. 
1 conclusion 
since none of the conditions for termination detection for diffusing computation are violated  this algorithm will terminate. further research includes locking mechanisms so that multiple justifications can be sent by the ie simultaneously to initiate multiple diffusing computations and the handling of contradictions in parallel. 
 fulcomer and ball  1  
acknowledgments: thanks go to charles petrie for his initiation of the problem and discussion. we would also like to thank the cics group for their discussion and readings of this text. 
