 
in recent years  many new backtracking algorithms for solving constraint satisfaction problems have been proposed. the algorithms are usually evaluated by empirical testing. this method  however  has its limitations. our paper adopts a different  purely theoretical approach  which is based on characterizations of the sets of search tree nodes visited by the backtracking algorithms. a notion of inconsistency between instantiations and variables is introduced  and is shown to be a useful tool for characterizing such well-known concepts as backtrack  backjump  and domain annihilation. the characterizations enable us to:  a  prove the correctness of the algorithms  and  b  partially order the algorithms according to two standard performance measures: the number of nodes visited  and the number of consistency checks performed. among other results  we prove the correctness of backjumping and conflict-directed backjumping  and show that forward checking never visits more nodes than back-
jumping. our approach leads us also to propose a modification to two hybrid backtracking algorithms  backmarking with backjumping  bmj  and backmarking with conflict-directed backjumping  bm-cbj   so that they always perform fewer consistency checks than the original algorithms. 
1 	introduction 
constraint-based reasoning is a simple  yet powerful paradigm in which many interesting problems can be formulated. it has received much attention recently  and numerous methods for dealing with constraint networks have been developed. the applications include graph coloring  scene labelling  natural language parsing  and temporal reasoning. 
　the basic notion of constraint-based reasoning is a constraint network  which is defined by a set of variables  a domain of values for each variable  and a set of constraints between the variables. to solve a constraint network is to find an assignment of values to each variable so that all constraints are satisfied. 
　backtracking search is one of the methods of solving constraint networks. the generic backtracking algorithm was 
* currently with mpr teltech ltd  bumaby  bc  canada 
first described more than a century ago  and since then has been rediscovered many times  bitner and reingold  1 . in recent years  many new backtracking algorithms have been proposed. the basic ones include backmarking  gaschnig  1   backjumping  gaschnig  1   forward checking  haralick and elliot  1   and conflictdirected backjumping  prosser  1 . several hybrid algorithms  which combine two or more basic algorithms  have also been developed  prosser  1 . 
　there is no simple answer to the question which backtracking algorithm is the best one. first  the performance of backtracking algorithms depends heavily on the problem being solved. often  it is possible to construct examples of constraint networks on which an apparently very efficient algorithm is outperformed by the most basic chronological backtracking. second  it is not obvious what measure should be employed for comparison. run time is not a very reliable measure because it depends on hardware and implementation  and so cannot be easily reproduced. besides  the cost of performing consistency checks  checks that verify that the current instantiations of two variables satisfy the constraints  cannot be determined in abstraction from a concrete problem. a better measure of the efficiency of a backtracking algorithm seems to be the number of consistency checks performed by the algorithm  although it does not account for the overhead costs of maintaining complex data structures. another standard measure is the number of nodes in the backtrack tree generated by an algorithm. 
　the need for ordering algorithms according to their efficiency has been recognized before. nudel  ordered backtracking algorithms according to their average-case performance. prosser  performed a series of experiments to evaluate nine backtracking algorithms against each other. however  such an approach is open to the criticism that the test problems are not representative of the problems that arise in practice. even a theoretical average-case analysis is possible only if one makes simplifying assumptions about the distribution of problems. prosser commented on his results: 
   it is naive to say that one of the algorithms is the 'champion'. the algorithms have been tested on one problem  the zebra. it might be the case that the relative performance of these algorithms will change when applied to a different problem. 
　when prosser's results are examined  it is easy to notice that in some cases one algorithm performed better than another in all tested instances. could this mean that one algorithm is always better than another  such a hypothesis can never be verified solely by experimentation; the relationship has to be proven theoretically. in this paper we show that some of these cases indicate a general rule  whereas other do not. moreover  we present a partial ordering of several backtracking algorithms which is valid for all instances of all constraint satisfaction problems. 
　our approach is purely theoretical. we analyze several backtracking algorithms with the purpose of discovering general rules that determine their behaviour. a notion of inconsistency between instantiations and variables is introduced  and is shown to be a useful tool for characterizing such wellknown concepts as backtrack  backjump  and domain annihilation. using the new notion  we formulate the necessary and sufficient conditions for a search tree node to be visited by each backtracking algorithm. these characterizations enable us to construct partial orders  or hierarchies  of the algorithms according to two standard performance measures: the number of visited nodes  and the number of performed consistency checks. 
　the orderings are surprisingly regular and contain some non-intuitive results. for instance  it turns out that the set of nodes visited by forward checking is always a subset of the set of nodes visited by backjumping. this fact has never been reported before although the two algorithms have been often empirically compared. also  the orderings confirm and clarify the experimental results published by other researchers. the characterizing conditions imply simple and elegant correctness proofs of the characterized algorithms. two of these algorithms  backjumping  bj  and conflict-directed back-
jumping  cbj  have not been formally proven correct before1. the orderings proved also to be a stimulus for developing more efficient backtracking algorithms. the idea of combining backjumping and backmarking into a new hybrid algorithm was first put forward by nadel . such algorithm  called bmj  was presented by prosser . bmj  however  does not retain all the power of both base algorithms in terms of consistency checks. prosser observed that on some instances of the zebra problem bmj performs more consistency checks than bm. in the conclusion of his paper he posed the following question: 
   it was predicted that the bm hybrids  bmj and bm-cbj  could perform worse than bm because the advantages of backmarking may be lost when jumping back. experimental evidence supported this. therefore  a challenge remains. how can the backmarking behaviour be protected  
in this work we answer the question by modifying the two bm hybrids  backmarking with backjumping  bmj   and backmarking with conflict-directed backjumping  bm-cbj   so that they always perform fewer consistency checks than both corresponding basic algorithms. 
　apart from presenting specific results for particular backtracking algorithms  our goal is also to propose a general 
   'both bj and cbj were first presented without correctness proofs and no direct proofs of these algorithms have appeared in the literature. however  proofs have been given for certain algorithms related to bj and cbj  bruynooghe  1; ginsberg  1; schiex and verfaillie  1 . 
1 	constraint satisfaction 

to variables  with nodes: the empty tuple e is the root of the tree  the first level nodes are 1-tuples  representing an assignment of a value to variable x1   the second level nodes are 1-tuples  and so on. the levels closer to the root are called lower levels  and the levels farther from the root are called higher levels. similarly  the variables corresponding to these levels are called lower and higher. the nodes that the values in its filtered domain. otherwise the effects of forward checking are undone  and the next value is tried. if there 
are no more values to be tried for the current variable  fc backtracks chronologically to the most recently instantiated variable. a solution is recorded every time the last variable becomes instantiated. represent consistent tuples are called consistent nodes. the example 1. the n-queens problem is how to place n nodes that represent inconsistent tuples are called inconsistent queens on a n x n chess board so that no two queens at-
nodes. we say that a backtracking algorithm visits a node if at some stage of the algorithm's execution the instantiation of the current variable and the instantiations of the past variables form the tuple identified with this node. the nodes visited by a backtracking algorithm form a subset of the set of all nodes belonging to the search tree. we call this subset  together with the connecting edges  the backtrack tree generated by a backtracking algorithm. backtracking itself can be seen as retreating to lower levels of the search tree. whenever some variables become uninstantiated and xh is set as the new current variable  we say that the algorithm backtracks to level h. we consider two backtracking algorithms to be equivalent if on every constraint network they generate the same backtrack tree and perform the same consistency checks. 
chronological backtracking  bt   bitner and reingold  
1  is the generic backtracking algorithm. the consistency tack each other. our representation of this problem identifies board columns with variables  and rows with domain values. figure 1 shows a fragment of the backtrack tree generated by chronological backtracking  bt  for the 1-queens problem. white dots denote consistent nodes. black dots denote inconsistent nodes. for simplicity  when referring to nodes we omit commas and parentheses. the board in the upper right corner depicts the placing of queens corresponding to node 1 in the backtrack tree. capital q's on the board represent queens which have already been placed on the board. the shaded squares represent positions that must be excluded due to the already placed queens. the numbers inside the squares indicate the queen responsible for the exclusion; 1 1 correspond to the first  second  and third queen respectively. 
　the dark-shaded part of the tree contains two nodes that are skipped by backjumping  bj . the algorithm detects a dead-instantiations of the past variables are performed according to the original order of instantiations. if a consistency check fails  the next domain value of the current variable is tried. if there are no more domain values left  bt backtracks to the most recently instantiated past variable. if all checks succeed  
the branch is extended by instantiating the next variable to each of the values in its domain. a solution is recorded every time when all consistency checks succeed after the last variable has been instantiated. 
　backjumping  bj   gaschnig  1  is similar to bt  except that it behaves more efficiently when no consistent in-
stantiation can be found for the current variable  at a dead-
end . instead of chronologically backtracking to the preceding variable  bj backjumps to the highest past variable that was 
checked against the current variable. 
　conflict-directed backjumping  cbj   prosser  1  has a more sophisticated backjumping behaviour than bj. every                                                          1 case x1. the backjump is represented by a dashed arrow. we could say that bj discovers that the tuple  1 1   which is composed of instantiations in conflict with x1  is inconsistent with variable x1. to see this  notice that if we place a queen in column 1 row 1  every square in column 1 is attacked by the queens placed in the first four columns. indeed  there is no point in trying out the remaining values for x1 because that variable plays no role in the detected inconsistency. nodes 1 and 1 may be safely skipped. 
　the light-shaded part of the tree contains nodes that are skipped by conflict-directed backjumping  cbj . the algorithm reaches a dead-end when expanding node 1. at this moment the conflict set of x1 is {1  1  1  1} because the instantiations of these four variables prevent a consistent instantiation of variable x1. to see this  notice that after the fourth and the fifth queen are placed  column 1 of the chess board will contain numbers 1 1  and 1. cbj backtracks to 　　　　　　　　　　　　　　　　　　　　　　　　end at variable x1 when it tries to expand node 1. it then checks between the instantiation of the current variable and the backjumps to the highest variable in conflict with x   in this 
variable has its own conflict set that contains the past variables the highest variable in the conflict set  which is x1. no nodes 
which failed consistency checks with its current instantiation. every time a consistency check fails between the instantiation a  of the current variable and some past instantiation a/   the variable xh is added to the conflict set of xi. when there are no more values to be tried for the current variable xi cbj backtracks to the highest variable xh in the conflict set of xi. at the same time  the conflict set of xi is absorbed by the conflict set of xh* so that no information about conflicts is lost. are skipped at this point. the conflict set of x1 is absorbed by the conflict set of x1  which now becomes {1  1  1}. after trying the two remaining values for x1  cbj backjumps to x1 skipping the rest of the subtree. the backjump is represented by a dashed arrow. in terms of consistency  we could say that the algorithm discovered that tuple  1 1  is inconsistent with the set of variables {x1  x1}. a look at the board in figure 1 convinces us that indeed such a placement of queens cannot be extended to a full solution. it is impossible to fill columns 　in contrast with the above backward checking algorithms  1 and 1 simply because the two available squares are in the forward checking  fc   haralick and elliot  1  performs same row. note that  1 1  is consistent with both x1 and x1 consistency checks forward  that is  between the current vari- taken separately. able and the future variables. after the current variable has forward checking  fc   in contrast with the backward been instantiated  the domains of the future variables are fil- checking algorithms  visits only consistent nodes  although tered in such a way that all values inconsistent with the current not necessarily all of them. in our example  nodes 1  1  instantiation are removed. if none of the future domains is 1 and 1 are visited  but not 1. the board in annihilated  the next variable becomes instantiated to each of figure 1 can be interpreted in the context of this algorithm 1 	constraint satisfaction 



parent  a  ...  a   i  is consistent as well  and it is also consistent with xn. therefore   a1 ...  an-1  is consistent with all variables. from theorem 1 we know that  a1 ...  an  is visited by bj. since all consistency checks between an and previous instantiations must succeed  a solution is claimed by bj. 
proofs of the remaining cases are similar. ＆ 
　naturally  our approach can be extended to other backtracking algorithms. 
　all the above results were originally proven with the assumption that the search is not interrupted until all possibilities are exhausted. this is not generally true if only a fixed number of solutions is sought. however  if we restrict our attention to only those of the search tree nodes that precede  in the preorder traversal  the last node visited by a backtracking algorithm  the theorems are still valid. therefore  our results hold also for the  one solution  versions of the backtracking algorithms  with only slightly modified proofs. 
1 	hybrid algorithms with backmarking 
in this section we briefly discuss backmarking  gaschnig  
1  and its two hybrids. we propose a modification to the hybrids  and then include these algorithms in our hierarchies. backmarking  bm  imposes a marking scheme on the 
chronological backtracking algorithm in order to eliminate some redundant consistency checks. the scheme is based on the following two observations  nadel  1 :  a  if at the most recent node where a given instantiation was checked the instantiation failed against some past instantiation that has not yet changed  then it will fail against it again. therefore  all consistency checks involving it may be avoided   b  if  at the most recent node where a given instantiation was checked  the instantiation succeeded against all past instantiations that have not yet changed  then it will succeed against them again. therefore we need to check the instantiation only against the more recent past instantiations which have changed. 
　the marking scheme is implemented using two arrays: mbl  minimum backup level  of size n  and mcl  maximum checking level  of size n x m. the entry mbl i  contains the number of the lowest variable whose instantiation has changed since the variable x1 was last instantiated with a new value. the entry mc/ i  j  contains the number of the highest variable that was checked against the j-th value in the domain of the variable x . 
　nadel  suggested combining bm and bj into a new hybrid algorithm. prosser presented such algorithm  called backmarking and backjumping  bmj   in  prosser  1 . 
bmj  however  does not retain all the power of each base algorithm in terms of consistency checks. prosser observed that on some instances of the zebra problem bmj performs more consistency checks than bm. bmj is also worse than bm on the benchmark 1-queens problem. 
　a careful analysis of the algorithm leads us to the conclusion that bmj is sometimes worse than bm because the mbl array  which was originally designed for a chronologically backtracking algorithm  is no longer adequate for a back-
jumping algorithm. since bm always tests all values of the current variable for consistency  a single entry for all values is sufficient. in bmj  however  it often happens that only 
some values of the current instantiation are tested  and the 
1 	constraint satisfaction 

fc-cbj 
figure 1: the hierarchy with respect to the number of visited nodes. other values are skipped by a backjump. a separate entry for each value is therefore necessary to preserve all collected consistency information. 
　we propose a modified backmarkjump  bmj1   which solves the problem by making mbl a two-dimensional rather than a one-dimensional array. the new mbl array is of size n x m  where n is the number of variables  and m is the size of the largest domain. this is a reasonable space requirement because bmj already uses one n x m array; each mcl entry has now a corresponding mbl entry. the mbl i  j  entry stores the number of the lowest variable whose instantiation has changed since the variable xi was last instantiated with the j-th value. the entry is set to i every time the current instantiation  x    tj  is being tested for consistency with past instantiations. when the algorithm backtracks  the entries are updated in a similar way as in bmj. thanks to the more efficient backmarking scheme bmj1 is always better than bmj. moreover  since bmj1 does not lose information about consistency checks in the way bmj does  it is always better than bm. 
　an analogous modification of backmarking and conflictdirected backjumping  bm-cbj   which is another hybrid proposed by prosser  produces bm-cbj1: mbl should be made a 1-dimensional array  and maintained in the same way as in bmj1. 
1 	hierarchies 
we now present two hierarchies  which include the four basic backtracking algorithms described in section 1  and the backmarking hybrids discussed in section 1. 
　the hierarchy with respect to the number of visited nodes is presented in figure 1. two algorithms are connected by a link if the set of nodes visited by one of them is always a subset of the set of nodes visited by the other. naturally  the relation is transitive. the relationships derived in section 1 form the core of the hierarchy. note that imposing a backmarking scheme on an algorithm does not change the set of nodes that are visited. thus  for example  bm generates exactly the same backtrack tree as bt. 
　figure 1 shows the hierarchy of algorithms with respect to the number of consistency checks. two algorithms are connected by a link if one of them always performs no more consistency checks than the other. since bt  bj  and cbj perform the same number of consistency checks at any given node  they are in the same order as in the nodes hierarchy. imposing a marking scheme on a backtracking algorithm results in a reduction of the number of consistency checks performed. the figure contains also one forward checking hybrid: forward checking and conflict-directed backjumping  fc-cbj   prosser  1   which has not been discussed here. for a treatment of fc-cbj see  kondrak  1. 
　besides the relationships that are shown explicitly  it is important to note the ones that are implicit in the picture. in order to disprove a relationship between a and b  one needs to find at least one constraint satisfaction problem on which a is better than b  and one on which b is better than a. for example  bm performs fewer consistency checks than fc on the regular 1-queens problem  but more on the confused 1-queens problem  nadel  1 . examples of constraint networks were found that disprove all relationships that are not included in the hierarchies. thus  however counterintuitive it may seem  fc-cbj may visit more nodes than cbj  and perform more consistency checks than bt. 
1 	conclusions 
we presented a theoretical analysis of several backtracking algorithms. such well-known concepts as backtrack  backjump  and domain annihilation were described in terms of inconsistency between instantiations and variables. this enabled us to formulate general theorems that fully or partially describe sets of nodes visited by the algorithms. the theorems were then used to prove the correctness of the algorithms and to construct hierarchies of algorithms with respect to the number of visited nodes and with respect to the number of consistency checks. the gaps in the resulting hierarchy prompted us to modify existing hybrid algorithms so that they are superior to the corresponding basic algorithms in every case. one of the modified algorithms is always better  in terms of consistency checks  than all six backward checking algorithms described by prosser in  prosser  1 . in the future the hierarchies could be extended by applying our approach to other backtracking algorithms  such as dechter's graph-based back-
jumping algorithm  dechter  1  and nader s backtracking algorithm with full arc-consistency lookahead  nadel  1   