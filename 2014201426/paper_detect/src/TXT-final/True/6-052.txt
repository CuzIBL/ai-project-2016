 
many description logics  dls  combine knowledge representation on an abstract  logical level with an interface to  concrete  domains such as numbers and strings. we propose to extend such dls with key constraints that allow the expression of statements like  us citizens are uniquely identified by their social security number . based on this idea  we introduce a number of natural description logics and present  un decidability results and tight nexptlme complexity bounds. 
1 	introduction 
description logics  dls  are a family of popular knowledge representation formalisms. many expressive dls combine powerful logical languages with an interface to concrete domains  e.g.  integers  reals  strings  and built-in predicates  e.g.     sub-string-of   lutz  1bl. these can be used to form descriptions such as  employee working for the government and earning more than her boss  that combine  abstract  logical components  e.g.  working for the government  with components using concrete domains and predicates  e.g.  a numerical comparison of earnings . 
　dls with concrete domains have turned out to be useful for reasoning about conceptual  database  models  lutz  1c   and as the basis for expressive ontology languages  horrocks et al.y 1. so far  however  they have not been able to express key constraints  i.e.  constraints expressing the fact that certain  concrete features  uniquely determine the identity of the instances of a certain class. e.g.  the concrete feature  social security number  ssn   might serve as a key for citizens of the us  and the combination of identification number and manufacturer might serve as a key for vehicles. such constraints are important both in databases and in realistic ontology applications. in a dl context  key constraints have so far only been considered on logical   non-concrete  domains  borgida and weddell  1; calvanese et a/.  1; khizder et al  1; toman and weddell  1. 
it is easy to see that concrete keys can express nominate  
i.e.  concepts to be interpreted as singleton sets  closely related to the  one-of  operator : e.g.  if ssn is a key for human  ssn keyfor human   then the concept  human with ssn  has at most one instance. 
　in this paper  we extend the well-known dls with concrete domains acc v  and shoq d   baader and hanschke  1; horrocks and sattler  1  with key constraints and analyse the complexity of reasoning with the resulting logics allok d  and shoqk d . we show that allowing complex concepts to occur in key constraints dramatically increases the complexity of all d   which is pspacecomplete : it becomes undecidable. restricting key constraints to atomic concepts  such as  human  in the above example  still yields a nexptlml-hard formalism  even for rather simple  ptlme  concrete domains. we show several variants of this result that depend on other characteristics of key constraints  such as the number of concrete features and the  path length . this effect is consistent with the observation that the pspace upper bound for acc v  is not robust  lutz  1. 
　additionally  we prove the n e x p t i m e bounds to be tight by presenting tableau algorithms for allok{v  and shoqk{v  with key admissible concrete domains that are in np  where key admissibility is a simple and natural property. we have chosen to devise tableau algorithms since they have the potential to be implemented in efficient reasoners and have been shown to behave well in practise  horrocks et al  1 . due to space restrictions  we can only sketch proofs and refer to  lutz et al  1  for more details. 
1 	preliminaries 
first  	we 	formally 	introduce 	the 	description 	logic allok d . 
definition 1. a concrete domain v is a pair where is a set and a set of predicate names. each predicate name is associated with an arity n and an n-ary predicate be pairwise disjoint and countably in-
finite sets of concept names  nominate  role names  and concrete features. we assume that nr has a countably infinite subset naf of abstract features. a path u is a composition of n abstract features  and a concrete feature g. let v be a concrete domain. the set of allok d -concepts is the smallest set such that  i  every concept name and every nominal is a concept  and  ii  if c and d are concepts  r is a role name  g is a concrete feature  u 1  ...  un are paths  and  is a predicate of arity n. 

description logics 	1 

then the following expressions are also concepts: 

  a key definiton is an expression   u 1   . . .   uk keyfor c  for paths and c a concept. a finite set of key 
definitions is called a key box. 
as usual  we use t to denote an arbitrary propositional tautology. throughout this paper  we will consider several fragments of the logic allok{v   a♀co{v  is obtained from allok d  by admitting only empty key boxes; by disallowing the use of nominals  we obtain the fragment acc v  of alco{d  and alck d  of allok{d . 
　the description logic alcok d  is equipped with a tarski-style set-theoretic semantics. along with the semantics  we introduce the standard inference problems: concept satisfiability and concept subsumption. 
definition 1. an interpretation x is a p a i r   where  is a non-empty set  called the domain  and is the in-
terpretation function. the interpretation function maps each concept name c to a subset ci of   each nominal n to a singleton subset n1 of   each role name r to a subset each abstract feature / to a partial function 
  and each concrete feature g to a partial 
function q1 from 
　i f i s a path and d i s defined as the interpretation function is extended to arbitrary concepts as follows: 
an interpretation i is a model of a concept c iff 
moreover  x satisfies a key definition  u1 ...  un keyfor c  if  for any  n implies a - b. 1 is a model of a key box k. iff x satisfies all key definitions in k. a concept c is satisfiable w.r.t. a key box k iff c and k have a common model. c is subsumed by a concept d w.r.t. k   written c  for all models i of k 
it is well-known that  in dls providing for negation  subsumption can be reduced to  un satisfiability and vice versa: c  d itf c -d is unsatisfiable w.r.t. k and c is satisfiable w.r.t. kz iff c  -it. thus we can concentrate on concept satisfiability when investigating the complexity of reasoning: the above reduction implies the corresponding bounds for subsumption and the complementary complexity class  usually co-nexptime in this paper . 
　when devising decision procedures for dls which are not tied to a particular concrete domain  admissibility of the concrete domain usually serves as a well-defined interface between the decision procedure and concrete domain reasoners  baader and hanschke  1; lutz  1b : 
definition 1. let v be a concrete domain. a d-conjunction is a  finite  predicate conjunction of the form 
where pi is an n -ary predicate for and the are variables. a 'p-conjunction c is satisfiable iff there exists a function 1 mapping the variables in c to elements of such that 	for each we say that the concrete domain v is admissible iff  i  contains a 
name td for ;  ii  d is closed under negation  and  iii  satisfiability of p-conjunctions is decidable. we refer to the satisfiability of d-conjunctions as d-satisfiability. 
as we shall see  it sometimes makes a considerable difference w.r.t. complexity and decidability to restrict key boxes in various ways. because of this  it is convenient to introduce the following notions: 
definition 1. a key box k is called boolean if all concepts appearing in  key definitions in  k. are boolean combinations of concept names; path-free if all key definitions in k are of the form  g1 ...  gn keyfor c  with ; sim-
ple if it is both path-free and boolean; and a unary key box if all key definitions in k are of the form  u keyfor c . a concept c is called path-free if  in all its subconccpts of the form 
~ 	are concrete features. 	
to emphasize that a key box must not necessarily be boolean or path-free  we sometimes call such a key box general. similarly  to emphasize that a key box is not necessarily a unary key box  we sometimes call such a key box n-ary key box. 
1 	lower complexity bounds 
in this section  we present lower complexity bounds for dls with concrete domains  key boxes and nominals. we start by showing that satisfiability of allk  v -concepts w.r.t. general key boxes is undecidable for many interesting concrete domains. this discouraging result is relativized by the fact that  as shown in section 1  the restriction to boolean key boxes recovers decidability. next  we prove that satisfiability of path-free allk d -concepts w.r.t. simple key boxes is nexpt1lme-hard for many concrete domains and that this holds even if we restrict ourselves to unary key boxes. finally  we identify a concrete domain such that allo d concept satisfiability  without key boxes  is already nexptlme-hard. 
　undecidability of allk. d -concept satisfiability w.r.t. general key boxes is proved by reduction of the undecidable post correspondence problem  pcp   post  1 . 
definition 1. an instance p of the pcp is given by a finite  non-empty list of pairs of words over some alphabet . a sequence of i n t e g e r s w i t h 
m 1  is called a solution for p iff 
the problem is to decide whether a given instance p has a solution. 
the reduction uses the admissible concrete domain w introduced in  lutz  1   whose domain is the set of words over ♀ and whose predicates express concatenation of words. for each pcp instance  we define a 

1 	description logics 

concept cp and unary key box kp such that p has no solution iff cp is satisfiable w.r.t. kp. intuitively  cp and kp enforce an infinite  a;-ary tree  where each node represents a sequences of integers  i.e. a potential solution. the role of the key box is to guarantee that the tree is of infinite depth; concrete features are used to store the left and right concatenations corresponding to the potential solutions; and concatenation predicates from the concrete domain w are used to compute them. finally  an inequality predicate also provided by w is used to guarantee that none of the potential solutions is indeed a solution. since it is known that w-satisfiability is in ptlme  lutz  1j  we obtain the following theorem. 
theorem 1. there exists a concrete domain v such that d-satisfiability is in ptlme and satisfiability of allk d concepts w.r.t.  general  unary key boxes is undecidable. as shown in  lutz  1; lutz et a/.  1   the reduction can easily be adapted to more natural concrete domains such as numerical ones based on the integers and providing predicates for equality to zero and one  binary equality  addition  and multiplication. 
	we now establish lower bounds for 	allk{v  	with 
boolean key boxes and for allo 'd . these results are obtained using a nexptlme-completc variant of the wellknown  undecidable domino problem  knuth  1 . 
definition 1. a domino system d is a triple  t  h  v   where 
t n is a finite set of tile types and represent the horizontal and vertical matching conditions. for d a 
domino system and an initial condition  a mapping r : 	is a solution for 1  and   the following 
　this variant of the domino problem is nexptimecomplete  lutz  1 . the three nexptime lower bounds are obtained by using suitable and admissible concrete domains d1  d1  and d1 to reduce the above domino problem. more precisely  the simplest concrete domain d1 is used in the reduction to allk di -concept satisfiability w.r.t. boolean  n-ary  key boxes  the slightly more complex d1 is used in the reduction to acck. d1 -concept satisfiability w.r.t. boolean unary key boxes  and the most powerful concrete domain d1 is used in the reduction to allo d1 concept satisfiability without key boxes. 
　the idea underlying all three reductions is to use concept n	a	m	e	s	t	o represent positions i n the torus: if a is a domain element representing the position 	expresses that the l-th bit in the binary coding of i is 1  and 	expresses that the i'-lh bit of j is 1. we use standard methods to enforce that there exists a domain element for every position in the torus. the main difference between the three reductions is how it is ensured that no position is represented by two different domain elements-we call this uniqueness of positions. 
　the first reduction uses the very simple concrete domain d1  which is based on the set {1} and only provides unary predicates = 1   =1 and their negations. uniqueness of positions is ensured by translating the position  i  j  of a domain element a into concrete domain values: for and 1 
obvi-
ously ensures uniqueness of positions. since the reduction concept is path-free and d1-satisfiability is easily seen to be in ptlme  we obtain the following: 
theorem 1. d1 -satisfiability is in ptlme and satisfiability of path-free alc/c d1 -concepts w.r.t. simple key boxes is nexrtlme-hard. 
the  somewhat artificial  concrete domain d1 can be replaced by many natural concrete domains v proposed in the literature  baader and hanschke  1; haarslev and moller  1; lutz  1b; 1dj: it suffices that v provides two unary predicates denoting disjoint singleton sets. 
　the second reduction uses the more complex concrete domain do  which  stores  whole bit vectors rather than only single bits. in d1  we can translate the position  i j  of an element a. from concepts xl  yk into a single bit vector of length 1 n + 1  that is then stored as a bv-successor of a  where bv is a concrete feature. since we replaced the 1 n +1  concrete features used in the first reduction  one for each bit  by the single feature bv  it now suffices to use the simple unary key box  bv keyfor t  to ensure uniqueness of positions. as in d1  the reduction concept is path-free. in  lutz et al.  1   it is shown that do-satisfiability is in ptlme. 
theorem 1. do -satisfiability is in ptlme and satisfiability of path-free alck d1 -concepts w.r.t. simple unary key boxes is nexptime-hard. 
again  the artificial concrete domain do can be replaced by more natural ones: we can simulate bit vectors using integers and the necessary operations on bit vectors by unary predicates =  for every interger n and a ternary addition predicate-for more details sec  lutz et al.  1 . 
the last lower bound is concerned with the dl alco v . 
in the absence of key boxes  we need a different reduction strategy and the more complex concrete domain d1  which extends d1 with so-called domino arrays that allow us to store the tiling of the whole torus in a single concrete domain value. we can then ensure uniqueness of positions using a single nominal. computationally  the concrete domain d1 is still very simple  namely in ptlme. however  it no longer suffices to use only path-free concepts. 
theorem 1. d1satisfiability is in ptlme and satisfiability ofalco d1 -concepts is nexptlme-hard. 
1 	reasoning procedures 
we describe two tableau-based decision procedures for concept satisfiability in dls with concrete domains  nominals  and keys. the first is for aslcc' 1aj t  -concepts w.r.t. boolean key boxes. this algorithm yields a n e x p t i m e upper complexity bound matching the lower bounds established in section 1. the second procedure is for s'hook d  w.r.t. path-free key boxes and also yields a tight n e x p t i m e upper complexity bound. s'hoqk 'd  is an extension of the dl shoq{'d  introduced in  horrocks and sattler  1; 

description logics 	1 

pan and horrocks  1   which provides a wealth of expressive possibilities such as transitive roles  role hierarchies  nominals  qualifying number restrictions  and general tboxes with a path-free concrete domain constructor and path-free key boxes. path-freeness of shoqk t ys concrete domain constructor is crucial for decidability. moreover  it allows us to admit general rather than only boolean key boxes. 
　tableau algorithms decide the satisfiability of the input concept  in our case w.r.t. the input key box  by attempting to construct a model for it: starting with an initial data structure induced by the input concept  the algorithm repeatedly applies completion rules. eventually  the algorithm either finds an obvious contradiction or it encounters a contradiction-free situation in which no more completion rules are applicable. in the former case the input concept is unsatisfiable  while in the latter case it is satisfiable. 
　existing tableau algorithms for dls with concrete domains use admissibility as an  interface  between the tableau algorithm and a concrete domain reasoner  lutz  1b; baader and hanschke  1 . in the presence of keys  this is not enough: besides knowing whether a given vconjunction is satisfiable  the concrete domain reasoner has to provide information on variables that must take the same value in solutions. as an example  consider the concrete d o m a i n d the n-conjunction 
　　　　　　　　　　　　. obviously  every solution 1 for c identifies two of the variables v1  v1 v1. this information has to be passed from the concrete domain reasoner to the tableau algorithm since  in the presence of key boxes  it may have an impact on the satisfiability of the input concept. e.g.  this information transfer reveals the unsatisfiability of 
to formalize this requirement  we strengthen the notion of admissibility into key-admissibility. 
definition 1. a concrete domain v is key-admissible iff  i   contains a name  is closed under negation  and  iii  there exists an algorithm that takes as input a d-conjunction c  returns clash if c is unsatisfiable  and otherwise non-deterministically outputs an equivalence relation ~ on the set of variables v used in c such that there exists a solution 1 for c with the following property: for all v  v'  v 
 such an equivalence relation is 
henceforth called a concrete equivalence. we say that exbox k. moreover  we use cl c  k  as abbreviation for the set 
complexity of alcok:{v  
we start the presentation of the alcok d  tableau algorithm by introducing the underlying data structure. 
definition 1. let oa and oc be disjoint and countably infinite sets of abstract and concrete nodes. a completion tree for an alcok d -concept c and a key box k  is a finite  labeled tree  va vc e  c  with a set of nodes such that va oa  vc oc  and all nodes from vc are leaves. each node a va of the tree is labeled with a subset c a  of cl c  k ; each edge  a  b  e with a  b va is labeled with a role name c a  b  occurring in c or k; and each edge  a  x  e with a va and x vc is labeled with a concrete feature l a  x  occurring in c or k . 
　for t =  va vc e c  and a va  we use levt a  to denote the depth at which a occurs in t  starting with the root node at depth 1 . a completion system for an accok  v concept c and a key box k is a tuple where t = ' is a completion tree for c and k  v is a function mapping each with arity n appearing in c to a subset of is a linear ordering of va such that levx a  i m p l i e s i s a n equivalence relation on vc. 
let t =  va  vc  e  c  be a completion tree. a node b 
va is an r-successor of a node a va if  a  b  	e and 
l a  b  = r. similarly  a node x vc is a g-successor of a if  a  x  e and l a  x  = y. for paths u  the notion u-successor is defined in the obvious way. 
intuitively  the relation ~ records equalities between concrete nodes that have been found during the model construction process. the relation ~ induces an equivalence relation on abstract nodes which  in turn  yields the equivalence relation on concrete nodes. 
definition 1. let s = be a completion system for a concept c and a key box k. with t = and let be an equivalence relation on va. for each r 
nr  a node b va is an of a node a va if there exists a node c va such that a c and b is an i -successor of c. for paths u  the notion   -neighbor is defined analogously. 

tended v-satisfiability is in np if there exists an algorithm as above running in polynomial time. 
it can easily be seen that any concrete domain that is admissible and provides for an equality predicate is also keyadmissible  lutz et a/.  1 . 
　in the following  we assume that all concepts  the input concept and those occuring in key boxes  are in negation normal form  nnf   i.e.  negation occurs only in front of concept names and nominals; if the concrete domain v is admissible  then every alcck d -concept can be converted into an equivalent one in nnf  lutz et al.   1 . we use c to denote the result of converting the concept c into nnf  sub c  to denote the set of subconcepts of c  and sub /c  to denote the set of subconcepts of all concepts occurring in key 
1 	description logics 

we write s + agx to denote the completion system s' that can be obtained from s by adding  a x  to e and setting l{a x  = g. 
when nesting +  we omit brackets writing  e.g.  
br1c for 	be a path. with 	is fresh in t  we denote the completion system s' that can be obtained from 1 
by taking fresh nodes 	and setting 
 the completion rules are given in figure 1  where we assume that newly introduced nodes are always fresh. the and rch rules are non-deterministic and the upper five rules are well-known from existing tableau algorithms for alc 'd concept satisfiability  c.f. for example flutz  1dl . only deserves a comment: it considers -neighbors rather than r-successors since  relates nodes denoting the same domain element. 
the last two rules are necessary for dealing with key boxes. 
the  choose rule  rch  c.f.  hollunder and baader  1; horrocks et al.  1   guesses whether an abstract node a satisfies c in case of c occurring in a key definition and a having neighbors for all paths ul in this key definition. the rp rule deals with equalities between abstract nodes as recorded by the  relation: if. b  then a and b describe the same element  and thus their node labels should be identical. we choose one representative for each equivalence class of   the node that is minimal w.r.t.   and make sure that the representative's node label contains the labels of all the nodes it represents. 
definition 1. let s = be a completion system for a concept c and a key box k with we say that the completion system s is concrete domain satisfiable iff the conjunction 
is satisfiable. 1 contains a clash iff  i  there is a n a n d 
a n s u c h 	t	h	a	t	 	i	i	  	there are 
and such t h a t a n d x is of a; or  iii  s is not concrete domain satisfiable. if s does not contain a clash  then s is called clash-free. s is complete if no completion rule is applicable to s. 
we now give the tableau algorithm in pseudocode notation  where check denotes the algorithm computing concrete equivalences as described in definition 1: 
define procedure sat s  
do 
if s contains a clash then return unsatisfiable 

if s contains a clash then return unsatisfiable if s is complete then return satisfiable apply a completion rule to s yielding   
return sat s   
　the algorithm realizes a tight coupling between the concrete domain reasoner and the tableau algorithm: if the concrete domain reasoner finds that two concrete nodes are equal  the tableau algorithm may use this to deduce  via the computation of  even more equalities between concrete nodes. the concrete domain reasoner may then return in check  further  equalities  ~ and so forth. 
　a similar interplay takes place in the course of several recursion steps: equalities of concrete nodes provided by the 

description logics 	1 

concrete domain reasoner may make new rules applicable  for example rp and then which changes v and thus also cs. this may subsequently lead to the detection of more equalities between concrete nodes by the concrete domain reasoner  and so forth. note that  in the absence of keys boxes  there is much less interaction: it suffices to apply the concrete domain satisfiability check only once after the completion rules have been exhaustively applied  baader and hanschke  1 j. 
   in flutz et ai  1   we prove that the algorithm runs in non-deterministic exponential time: there are exponential bounds on the number of abstract and concrete nodes in the completion system  on the number of while loop iterations in each recursion step  and on the size of cs- this yields the following upper bound  which is tight by theorem 1. 
theorem 1. for v a key-admissible concrete domain such that extended d-satisfiability is in np  alcok. 'd -concept satisfiability w.r.t. boolean key boxes is in nexptlme. 
complexity of suoqk  d  
we have designed a tableau algorithm for shoqk d  as a combination of the one for shoq{v  in  horrocks and sattler  1  and the one for alcok d  presented above. it is restricted to path-free concepts and path-free key boxes  but can handle complex concepts in key boxes. the most important difference from the accok d  algorithm is as follows: in the presence of non-boolean key boxes  the rch rule may add concepts of positive  role depth  to arbitrary nodes in the completion tree. thus the role depth does not automatically decrease with the depth of nodes in the tree  as in the case of alcok.{v   and a naive tableau algorithm would construct infinite trees. however  even for suoq v  without key boxes  one has to enforce termination artificially by using a cycle detection mechanism called blocking-whereas the alcok v  algorithm terminates  naturally . it can be shown that blocking can be used in the presence of key boxes without corrupting soundness or completeness. a detailed description of this algorithm and a correctness proof is given in ilutz et al  1 . as a by-product of the shoqk d  tableau algorithm  we obtain a small model property: every satisfiable s'hoqk d -concept has a model of size exponential in the concept length. thus we obtain the following upper bound  which is tight by theorem 1. 
theorem 1. for v a key-admissible concrete domain such that v-satisfiability is in np  suoqk d -concept satisfiability w.r.t. path-free key boxes is in nexptime. 
1 	summary 
we have identified key boxes as an interesting extension of description logics with concrete domains  introduced a number of natural description logics  and provided a comprehensive analysis of the decidability and complexity of reasoning. moreover  we have proposed tableau algorithms for two such  nexptlme-complete  logics. 
　the main result of our investigations is that key constraints are rather powerful  since they dramatically increase the complexity of reasoning: pspace acc{v  becomes undecidable with unrestricted key boxes  and nexptime-complete with boolean key boxes-provided that the concrete domain v is not too complex  i.e.  extended d-satisfiability is in np. 
