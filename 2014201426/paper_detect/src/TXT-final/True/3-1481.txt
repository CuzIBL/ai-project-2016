
query learning models from computational learning theory  clt  can be adopted to perform elicitation in combinatorial auctions. indeed  a recent elicitation framework demonstrated that the equivalence queries of clt can be usefully simulated with price-based demand queries. in this paper  we validate the flexibility of this framework by defining a learning algorithm for atomic bidding languages  a class that includes xor and or. we also handle incentives  characterizing the communication requirements of the vickrey-clarkegroves outcome rule. this motivates an extension to the earlier learning framework that brings truthful responses to queries into an equilibrium.
1	introduction
there has been a burst of recent attention in the problem of preference elicitation in combinatorial auctions  cas   which are auctions in which agents can express values on bundles of items  blum et al.  1; lahaie and parkes  1; conen and sandholm  1; santi et al.  1; parkes  1 . indeed  elicitation is today recognized to be just as important a computational problem  and perhaps more so  as that of winner-determination  nisan and segal  1 . cas can potentially require agents  e.g. people  firms  automated bidding agents  to value an exponentially large number of different bundles of indivisible goods  when determining the value on even a single bundle can be hard  sandholm  1 .
모in query-based elicitation  parkes  1; conen and sandholm  1   agents must be able to respond to simple queries  such as identifying a preferred bundle at given prices  or providing the value of a specified bundle. many of these methods are closely related to the  exact learning with queries  model from computational learning theory  clt   blum et al.  1 . in fact  these are typically learning methods in their own right because they elicit valuations entirely and exactly. one exception is lahaie and parkes   who give a preference elicitation scheme that avoids complete learning when possible. the main contribution in that paper is to explain how to simulate any learning algorithm with membership and equivalence queries as an elicitation algorithm with value and demand queries.
모we extend this earlier work by providing a preference elicitation scheme for a broad class of languages  called atomic languages  which includes xor and or as special cases  see nisan  for a formal study of bidding languages . in addition to validating the flexibility of the lahaie and parkes  framework  our new algorithm demonstrates the power of demand queries. for instance  we know of no learning algorithm for or using just value and equivalence queries.
모our main contribution is to characterize the communication requirements of the vickrey-clarke-groves  vcg  outcome rule  jackson  1 . already known to be sufficient for determining the vcg outcome  mishra and parkes  1   we prove here that any elicitation protocol for the vcg mechanism necessarily also determines a set of  universal competitive equilibrium   uce  prices. this result broadens our understanding of demand queries  demonstrating that if the goal is to verify a vcg outcome it is necessary to verify an efficient allocation and set of uce prices  which can be done through a simple extension of demand queries to universal demand queries.1 we demonstrate how to extend the existing learning framework to terminate with uce prices and an efficient allocation.
모with n agents  a na몮 ve way to handle incentives is to simply run the preference elicitation algorithm  and then run it again n more times with each agent removed. this yields enough information to derive vcg payments. however  the uce-based characterization motivates a design for an extension of the learning-based framework that we call learner extend and adjust  leea   that obtains vcg payments in a single run of the algorithm.
related work. nisan and segal  characterize the minimal communication requirements of implementing an efficient allocation  but do not consider incentives. the large literature on ascending-price vickrey auctions  see parkes  for a survey  is largely motivated by issues of costly elicitation  and recent auctions are designed to terminate with uce prices  mishra and parkes  1 . similarly  conen and sandholm  had previously considered elicitation methods that terminate with the vcg outcome. what is new in our work is the proof that uce prices are necessary  as well as sufficient  for the vcg outcome  together with the careful integration of this methodology into elicitation methods with polynomial query complexity. 1 preliminaries
the purpose of a ca is to allocate a set g of m distinct and indivisible goods among a set n of n agents  each with a valuation vi : 1g 뫸 r. let 붞 be the set of possible allocations  in which no good is given to more than one agent. we aim for an efficient allocation  namely an allocation that maximizes total value. by definition  agent valuations satisfy the property of no externalities  meaning that an agent only cares about its own bundle  and not those allocated to other agents. valuations also satisfy free-disposal  meaning that vi s  뫞 vi t  if s   t  are normalized: vi    = 1  and bounded  so that there is a constant k   1  known to the center  such that vi s    k for all s   g and all i 뫍 n. agents have quasi-linear utility functions  so that agent i's utility for a bundle s at prices p is ui s p  = vi s    p s .
1	bidding languages
a bidding language is used to encode and communicate realvalued functions over bundles; this may for instance be an agent's entire valuation function  or an underestimate of its true valuation function  as in bids in ascending-price cas  hence the name  bidding language  . in this work  the center also uses bidding languages to quote prices to the agents.
모formally  a bidding language consists of syntax and semantics that allow one to encode value information and interpret these encodings. we consider the class of atomic languages. an atomic representation is a pair  b w  where b   1g is a set of bundles  the atomic bundles   and w : b 뫸 r뫟1 is a real-valued function over these bundles  the values of the atomic bundles . an alternate useful syntax is a list of atomic bids  where an atomic bid is a bundle-value pair  s x   and x is to be interpreted as the value of bundle s   g. the semantics of an atomic language l are defined through the evaluation function 뷋l 몫;b w  that extends w to the set of all bundles  so that the value of a bundle s is v s  = 뷋l s;b w . a well-formed atomic language evaluation function satisfies the following conditions:
l1. 뷋l b;b w  = w b  for all b 뫍 b.
l1. 뷋l s;b w  = 뷋l s;b|s w  for all s   g  where b|s = {t 뫍 b | t   s}.
l1. 뷋l s;b 뫋 b1 w  뫟 뷋l s;b   for all b b1   1g and all s   g.
as an important example  consider the family of lan-
k is k  ;  w  = maxs뫍dk s;b  b뫍s w     where dk s;b  defines the set of all s   1b that satisfy  i  |s| 뫞 k   ii  뫋b뫍sb   s   iii  b1 뫌 b1 =   for b1 b1 뫍 s s.t. b1= b1. we call elements of dk s;b  decompositions of s into atomic bundles from b. it is easy to see that 뷋k satisfies conditions l1-l1 above. as special cases we have
l1 = xor and lm = or.
모a bidding language is expressive for cas if it can encode all valuation functions v : 1g 뫸 r뫟1 that satisfy free disposal. it is not hard to see that l1  xor  is expressive  but that lk for k   1 are not  consider for example the valuation that places a value of 1 on all bundles . representation  b w  in a language l of valuation v is minimal if |b| is minimized over all valid l representations of v. in what follows  sizel v  denotes the size of a minimal l representation of function v  when such a representation exists.
1	queries
agents are modeled as  black-boxes  that can respond to queries. a response to a query provides partial information about an agent's valuation function. we adopt queries that are more or less natural in economic settings: value query. a value query value s  to agent i on bundle s asks the agent to report its exact value vi s .
demand query. a demand query demand s p  presents an agent i with a bundle s and prices p over all bundles  in some bidding language . the agent replies yes if bundle s is a best-response at prices p  meaning that vi s    p s  = maxt g  vi t    p t  . otherwise the agent replies with a bundle s1 that makes it strictly better off than s at prices p  i.e. vi s1    p s1    vi s    p s .
universal demand query. a universal demand query uni-
demand s1 ... sn p  presents an agent i with prices p over all bundles together with a set of n bundles s1 ... sn  not necessarily distinct . the agent replies yes if every bundle presented is a best-response to prices p. otherwise  the agent responds with an index j and a bundle s1 such that vi s1    pi s1    vi sj    pi sj .
모note that   may be a valid response to a demand query. also note that prices are general functions p : 1g 뫸 r뫟1  and may be nonlinear  bundles are priced  not just items alone  and non-anonymous  different agents may face a different price for the same bundle .
1	ce and uce prices
cas  and the preference elicitation scheme we consider here  generally operate by converging to a competitive equilibrium. this ensures that the final allocation is indeed efficient.
definition 1 a competitive equilibrium among agents n is an allocation together with prices p that satisfy:  argmax vi s    pi s   for i = 1 ... n
s g
and  1  s  뫍 argmax.
s뫍붞
모if  s  p  constitutes a ce  we call p the ce prices and say that prices p support allocation s . for our results later on incentives  we also need the following concept:
definition 1 a universal competitive equilibrium is an allocation-price pair  s  p  that constitutes a competitive equilibrium among agents n  and such that  constitutes a competitive equilibrium among agents n {i}  for some efficient allocation  of items g among agents n {i}  for all i 뫍 n.
모in fact  it is not hard to show that prices p that support some efficient allocation among agents n {i} for all i 뫍 n also support all such efficient allocations.
1	a learning-based architecture for elicitation
the learning framework of lahaie and parkes   that we call 'learner'  converts individual exact learning algorithms into preference elicitation algorithms. we will demonstrate how to instantiate it here for the class of atomic languages. the goal of a learning algorithm for our purposes is to exactly determine an unknown target valuation v represented in a given bidding language l in a number of queries that scales polynomially with sizel v  and m. let v be the space of possible valuations  in our case all bounded and normalized valuations that satisfy free-disposal and have no externalities.
모exact learning in the computational learning theory literature typically uses membership and equivalence queries. a membership query in our domain is just a value query. learning algorithms maintain a manifest valuation v   which is their current estimate of the target function. on an equivalence query we present v  to the agent; it replies yes if v  = v  and otherwise replies with some counterexample s such that v  s  1= v s .
모lahaie and parkes  note that for a multi-agent scenario  learning algorithms can be run in parallel for each agent while they perform value queries. demand queries play a key role in coordinating learning across agents. when all agents require the response to an equivalence query  one can instead compute an efficient allocation s   and supporting ce prices p  with respect to the current manifests  and present these to the agents as demand queries. call these the manifest allocation and the manifest prices. if all agents reply yes  we have reached a ce and s   is already efficient; we need not learn any more information. otherwise  the responses to the demand queries are in fact counterexamples that can be returned to the learning algorithms as responses to their equivalence queries.
모in the case of a specific bidding language  such as an atomic language  we need to provide means to:  1  learn a target valuation in the given bidding language;  1  compute an efficient allocation with respect to manifests  i.e. solve winner-determination ;  1  compute supporting ce prices.
1	learning atomic languages
we now describe a learning algorithm with value and demand queries for atomic languages.1 the manifest valuation v  is stored as pair  b  w  . let  b w  be the minimal l representation of target valuation v. the manifest representation will always satisfy  1  b   b    and  1  w  b  = w b  for b 뫍 b . this is true initially because we set b  =  . throughout the learning process we will ensure that only elements b 뫍 b are ever added to b   and we make value queries on these new additions to appropriately set w  b . from these conditions and l1 we get that v  s  뫞 v s  for all s   g at all times  and see that v  underestimates v.
	the	outer-loop	of	the	learning	algorithm	issues
demand   v    i.e. with prices quoted equal to the current manifest and in the same bidding language. if the response is yes we are done since 1 뫞 v s    v  s  뫞 1 for all s   g. otherwise we obtain a more-preferred bundle s that is a counterexample  this follows from a simple adaptation of lemma 1 in lahaie and parkes  . we then have 1   v s    v  s  = 뷋l s;b w    뷋l s;b  w  .
by property l1 this means there is at least one undiscovered atomic bundle b 뫍 b|s  b|  s. to derive the atomic bundle b from s  we use the subroutine presented as algorithm 1. recall that k is an upper-bound on agent values.
algorithm 1 findnewatomic s 
construct prices ps where
if t 1  s
otherwise
issue demand   ps  if the agent replies yes then
return s
else if the agent replies with bundle r then
return findnewatomic r 
end if

모the prices ps in this subroutine can be constructed in the atomic language as  bp w p   as follows. first  initialize bp = b  with w p = w . then  add atomic bids  s k  and  {j} k  for all j /뫍 s to complete the representation. the size of this construction is clearly polynomial in sizel v  and m. finally  we then update our manifest by adding  b w  b    where b is the atomic bundle discovered in algorithm 1 and w  b  is obtained via a value query  and continue. this is correct by property l1. the correctness of the algorithm follows directly from this lemma:
lemma 1 on performing query demand   p  in algorithm 1  if the reply to the demand query is yes then s is an atomic bid  and otherwise the bundle returned r is a subset of s and also a counterexample to v .
proof. if the agent replies yes  then it must be that v  r  = v r  for all r   s  because v  always underestimates v. in particular  we have v  b  = v b  for each b 뫍 b|s  and every atomic bundle b   s has been discovered by the minimality of  b w  and condition l1. then  it must be that s 뫍 b is a new atomic bid since v  s  1= v s . if instead bundle r is returned then r   s by the structure of the prices  all other bundles are priced at k . moreover  as v r    p r  = v  r   we have a new counterexample. 1 note that this subroutine is called at most sizel v  times since a new atomic bundle is returned each time. also  observe that algorithm 1 makes at most m demand queries  because we always recurse on strict subsets of the original argument s and |s| 뫞 m.
theorem 1 an unknown target valuation v in any atomic language l can be learned with at most sizel v 몫 m+1 +1 demand queries and at most sizel v  value queries.
모this algorithm is efficient for atomic languages and provides the first polynomial query learning algorithm for the or language. or can be more concise than xor although it is not always expressive  nisan  1 . we do not know of a learning algorithm for or with membership and equivalence queries alone  so this result suggests the power of demand queries. in this context  demand queries are used to provide a
모kind of  focused  equivalence query in which an agent's new counterexample is restricted to being a subset of the current counterexample.
1	computing ce prices for lk
in this section we explain how to compute the manifest allocation and prices for language lk. it is useful to work with the explicit structure of lk  although we intend this to be suggestive of an approach that is workable for any atomic language. we first describe a generalized mixed-integer program  mip  for winner-determination  wd   which will also be revelant for computing ce prices. all mathematical programs defined in this section can be readily solved with mip solvers such as cplex.
모assume agent i's manifest is represented in language lki. the program description takes five arguments:  1  a set of agents n1   n;  1  a vector of bundles s  with one bundle si for each agent i 뫍 n1;  1  a vector of sets of atomic bundles b  with one set bi for each agent i 뫍 n1;  1  values wi b  for each agent over all atomic bundles b 뫍 bi;  1  prices pi b  for each agent over all atomic bundles b 뫍
bi. let ri = |bi|. let 붞i   1b i be the possible allocations to agent i  sets of pairwise disjoint atomic bundles with cardinality at most ki . an allocation here is a vector 붺 =  붺1 ... 붺n  where 붺i 뫍 붞i for each agent i 뫍 n. the generalized formulation wd n1 s b w p  is as follows: ijmax붹i x1  xwi bij aij   zi #
ri
a  e  zi i뫍n j=1
x
ri
s.t.aij 뫞 ki	 i 뫍 n1	 1 
j=1
	xij	aij 뫞 1	 g 뫍 g	 1 
i뫍n1 {j:b 1g}
	e붹i 뫟 1   |{j : bij 뫍 붹i}| + xij aiij   i붹i뫍뫍n붞1i	 1 
모모모모모모{j:b 뫍붹 } zi 뫟pi bij e붹i	  i붹i뫍뫍n붞1i	 1 
{j:bij뫍붹i}
	xij	aij = 1	  ig뫍1뫍nsi1	 1 
           {j:b 1g} aij 뫍 {1}  e붹i 뫍 {1}  zi 뫟 1
모let b~ =  b 1 ... b n   g~ =  g ... g   with n entries   w  =  w 1 ... w n   the values in agent manifests   and ~1 =  1 ... 1   with n entries .1 the usual program to solve winner-determination is wd n  let v  be the value of the efficient allocation obtained through wd. the linear program  lp  to obtain ce prices is as follows.
s. 붺 뫍 붞 1 뷇s
i  ij  n
s
 i 뫍 n
 s   g
	뷇i 뫟w i bij   1pi bij 	 붹i 붹i1 뫍	 1 
{j:bij뫍붹i}	{j:bij뫍붹i}	dk s;bi  xn
	뷇s +	뷇i = v 	 1 
i=1
뷇s 뫟 1  뷇i 뫟 1  pi bij  뫟 1
모variables 뷇i can be interpreted as the utility to each agent from their allocations at the prices computed  and variable 뷇s as the revenue to the seller. this formulation has an exponential number of utility-maximization constraints  1  and revenue-maximization constraints  1 . to address this we can use delayed constraint generation  bertsimas and tsitsiklis  1 . we only keep a subset of these constraints  initially empty   and obtain specific values for each of the variables in the lp. to check whether any implicit constraints of type  1  are violated  we solve wd n g ~ b~ p~ ~1   where p~ is the vector of prices obtained from the lp. if the solution to this is greater than 뷇s  we add the constraint of type  1  that corresponds to the allocation obtained by this auxiliary integer program.
모similarly  we can run wd {i} g ~ b~ w p~    for each agent i to see if we need to generate any constraints of type  1   and check whether the result is greater than 뷇i. note that each such integer program has an exponential number of constraints of type  1  and  1 . to use delayed constraint generation for these  we can run wd {i}  ... si ...  b~ p~ ~1  as an auxiliary program  where si is the solution to the main integer program. if the solution to this program has value greater than zi  we must generate corresponding constraints of type  1  and  1 .1
1	communication requirements of implementing the vcg outcome
in the above discussion  we set aside the issue of incentives in preference elicitation. a reliable elicitation scheme must also induce the agents to truthfully reveal their preferences. suppose that instead of implementing the final ce prices

	1 is identically 1 over all bundles.
the function
1
모모in this case  constraints  1  are irrelevant because they only serve to activate e붹i if appropriate atomic bundles are selected  to indirectly ensure that zi is set to the correct price through constraint  1   and the price here is always 1. similarly constraints  1  are irrelevant because any agent can be allocated any bundle.
1
모모note that this last program is the usual one the proxy would use to determine the value or price of a bundle  given the lk representation of its agent's manifest valuation.
obtained by learner  we provide a payment of pi=1 j	   vi si
to agent j for all j 뫍 n  where  is the efficient allocation  agent values are available via value queries . as nisan and segal  point out  this aligns each agent's utility with the overall objective  and truthful revelation becomes an ex post nash equilibrium of the elicitation protocol. however  this scheme is clearly very costly for the center. the center pays the agents! the cheapest payment scheme that aligns the agents' individual incentives with economic efficiency is the vcg payment  krishna and perry  1 .
모in this section  we may drop the assumption of no externalities so that our results hold with greater generality. valuations and prices are therefore defined over entire allocations. let vi be the set of possible valuations for agent i. a state is a valuation profile v 뫍 v = v1뫄...뫄vn. an outcome in our scenario is an element of o = 붞뫄rn  namely a specification of the allocation and the agents' payments.
모the objective is to implement the vickrey outcome rule  which is a correspondence f =  f1 f1  : v 1 o mapping states v 뫍 v to pairs  붺 q    such that 붺  is an efficient allocation for profile v and  q1 ... qn  is the associated vectorp of vcg payments. letting 붺 p v  뫍 argmax붺뫍붞 i뫍n vi 붺  and 붺  j v  뫍 argmax붺뫍붞 i1=j vi 붺   the vcg payments
 from the agents to the center  are defined as:
	x	x
	f1j v  =	vi 붺  j v    	vi 붺  v  	for j 뫍 n
	i=1 j	i1=j
모mishra and parkes  have shown that to compute vcg payments it is sufficient to obtain uce prices. in fact  we show here that it is not only sufficient but necessary that a communication protocol for vcg discover uce prices.1
모we consider nondeterministic communication protocols. this is the setting in which a center claims the vcg outcome is  붺 q   and must send messages to each agent to convince them of this outcome. each agent checks that the message is valid given the semantics of the protocol and its private type  and if all respond yes the protocol has verified the outcome. definition 1  nisan and segal  1  a nondeterministic communication protocol is a triple 붫 = hw 뷃 gi  where w is the message set  뷃 : v 1 w is the message correspondence  and g : w 뫸 o is the outcome function  and the message correspondence 뷃 has the following properties:
  existence: 뷃 v  1=   for all v 뫍 v.
t
  privacy preservation: 뷃 v  = i 뷃i vi  for all v 뫍 v  where 뷃i : vi 1 w for all i 뫍 n.
protocol 붫 realizes choice correspondence f : v 1 o if g 뷃 v     f v  for all v 뫍 v.
let r = |붞| be the size of the  finite  set of allocations. denote the set of universal price equilibria in state v by e v   where e : v 1 붞 뫄 rnr denotes the universal price equilibrium correspondence.1 the proof of the following is straightforward and omitted in the interest of space.
lemma 1 let hw 뷃 hh qii be a nondeterministic communication protocol that realizes the vickrey outcome rule f.
let w 뫍 w and let 붺  = h w . if v v  뫍 뷃 1 w   then
f1 v  = f1 v    where the vcg payments are with respect to efficient allocation 붺 .
   we note in particular that f1j w  is entirely independent of component vj in the original profile v. thus if   then f1j v  = f1j v  .
theorem 1 communication protocol 붫 = hw 뷃 hh qii realizes the vickrey outcome rule f if and only if there exists an assignment p : w 1 rnr of prices to messages such that protocol 붫1 = hw 뷃 hh pii realizes the universal price equilibrium correspondence e.
proof. as mentioned  mishra and parkes  provide the proof of sufficiency. suppose protocol hw 뷃 hh qii realizes vickrey outcome rule f. for each w 뫍 w  let 붺  = h w   and let for all i 뫍 n and 붺 뫍 붞. note that 붺  is directly obtained from the information generated by 붫  but state v and efficient allocations in the marginal-economies 붺  j v  for j 뫍 n are not. however  we do not need to explicitly compute this information to implement a universal price equilibrium according to definition 1. let q w  be the vcg payments associated with efficient allocation 붺  = h w . the first part of the proof of necessity  which shows that prices p are ce prices  is proved by nisan and segal . we will show that the prices p just constructed are in fact uce prices corresponding to 붺   that are valid for all v 뫍 뷃 1 w . fix agents i 1= j. by lemma 1  any two p lead to the same vcg payment. hence we obtain i=1 j vi 붺  j v    
  which
holds for all   call this equation  i  . by privacy preservation we can write the right-hand side as
.
   by definition pi 붺   = 1  so equation  i  gives:p	 vi 붺     pi 붺     vi 붺  j v   pi 붺  j v    =	h1=i j vh 붺  j v    . the
right-hand side is at most 1  so 붺  j v  is utility-maximizing for all agents i 뫍 n at prices pi. the final step is to establish that 붺  j v  is a revenue-maximizing allocation among agents n {j}. by privacy preservation  the supremum on the right-hand side of equation  i  can be brought within the summation. using our price construc-p tion and rearranging  this yields:p	p i1=j pi 붺  j v   = i1=j vi 붺  j v     vi 붺    뫟 i=1 j vi 붺    vi 붺     for all 붺 뫍 붞. this holds for all 

  for all

figure 1: constructing uce prices.
붺 뫍 붞  where the first equality follows by privacy preservation. this completes the proof. 1
모figure 1 gives the intuition behind this result for the case with two agents. given a message w  the figure shows all valuations that are consistent with w for agent 1  here only v1  and for agent 1  v1 and v1 . the valuations are normalized so that the efficient allocation 붺 has value 1. the conditions for a ce require that all of agent 1's valuations consistent with w be above all of agent 1's valuations consistent with w. to construct valid ce prices  we take the envelopes of agent 1 and 1's valuations  lower and upper  respectively . since agent 1's valuations are all consistent with the same vcg payments  they all peak at the same level. this ensures that the construction also satisfies the constraints of a uce.
1	using universal demand queries: leea
a na몮 ve way to compute vcg payments is simply to run the protocol once with all agents  then once with each agent removed for a total of n + 1 runs. we would then determine the value of the efficient allocation in each run. this gives us sufficient information to compute vcg payments. but given this new characterization result  we can instead modify the general elicitation framework to converge to uce prices. we call this new framework learner extend and adjust  leea . in the first stage we run the standard learner  until ce prices and an efficient allocation are determined. the second stage uses universal demand queries. whenever all the individual learning algorithms are stalled waiting to perform an equivalence query  we determine manifest allocations in the main economy  with agents n  and also in each of the marginal economies  with agents n {j}  for all j . in addition  we determine  manifest  universal ce prices  p. we can then issue query uni-demand bi p  to each agent i  where bi is the vector of bundles currently allocated to the agent in the main economy and in each of the marginal economies  for j 1= i. if all agents reply yes  we have a uce and can derive and implement vcg payments. otherwise  we obtain counterexamples to push forward the individual learning algorithms.
1	conclusions and future work
we presented novel applications of demand queries and demonstrated how they can be used in elicitation other than as parallels to equivalence queries. specifically  we provided a learning algorithm that uses demand queries with specialized prices for the class of atomic languages  a generalization of the or and xor languages. we also showed how demand queries can be used in a ca setting to make truthful bidding an ex post nash equilibrium: we modify an elicitation protocol to converge to uce prices by using universal demand queries  which are a simple generalization of demand queries. indeed  we proved that uce prices are necessarily implicitly discovered in any vcg protocol.
모in future work  it would be useful to find a learning algorithm for the or  bidding language  nisan  1 . or  representations are similar to or representations except that they also allow dummy  phantom  items  that impose restrictions on which atomic bundles can be combined together. this bidding language can represent many natural valuations concisely but lies outside our class of atomic languages. as opposed to the lk languages  knowing the atomics in an or  representation  without the dummy items  does not fully characterize all the valid atomic decompositions of a bundle. it is the structure generated by dummy items that must also be learned. in addition  we would like to completely characterize the relative power of demand and equivalence queries. we conjecture that demand queries are strictly more powerful than equivalence queries.
acknowledgements
this work is supported in part by nsf grant iis-1. 