 
constraint satisfaction - a method for representing and solving many ai problems in a very elegant manner - is a well-studied research area of recent years. freuder observed that some constraint satisfaction problems are fashioned so that certain domain values of constraint variables are interchangeable. the use of such knowledge can increase search efficiency drastically by reducing the problem. in this paper we carry on these considerations and give a formal foundation of interchangeabilities by the notion of domain partitions induced by equivalence relations. we show how these domain partitions can be used in a very accurate manner by the majority of existing constraint propagation algorithms and introduce a novel backtrack procedure exploiting such interchangeabilities of domain values. both theoretical analysis and experiments indicate that our proposed approach is an improvement of freuder's use of neighborhood interchangeability and has very good behavior for certain problem types. 
1 	introduction and motivation 
constraint satisfaction is a well-studied research area of recent years. using constraint satisfaction methods  many problems - especially in ai - can be represented in a very declarative way by identifying the variables of interest for the problem  laying down the domains for the variables and restricting the variable assignments by constraints. more formally  a constraint network r consists of a finite set of variables and a set of constraints. associated with 
each variable v; is a finite  discrete domain . a constraint c on the variables is in its extensional form a subset of the cartesian product of the domains of the afflicted variables. the expression var c  denotes the tuple of variables the constraint is defined on  and is the relational information of the constraint c.1 the assignment of a value  to a 
   *this work was supported by siemens austria ag under project grant css  gr 1/1 . 
1
our notation is similar to the one used in  dechter  1 . 
1 	constraint satisfaction problems 
variable v is denoted by v -d. a tuple t of assignments 
satisfies a constraint c  if and only 
if 
   a constraint satisfaction problem  csp  is the task of finding one or all variable assignments for a constraint network r such that all the constraints of r are satisfied. there are various techniques  like network consistency techniques or backtrack search procedures  for the handling and solving of constraint networks  good descriptions can be found in  mackworth  1; mackworth  1; haralick and elliott  1; dechter and pearl  1; 
dechter  1  . though  it is well-known that the use of special methods for certain problem types can reduce search effort. in this paper we focus on problems where the domain values are structured objects rather than atomic data  and the constraints refer to attributes of the objects and not to the objects as a whole. examples of application areas of these types of problems are design  configuration  or diagnosis. mittal and fray man  mittal and frayman  1  have proposed an approach of partial choices  where at each search step a decision is made only for a part  i.e.  an attribute  of a constraint variable. the methods partial commitment and partial guess are essentially least commitment techniques where some underconstrained decisions are delayed until more information is derived. another interesting work in this field is  mackworth et al.  1   where an hierarchical arc-consistency procedure  hac  is introduced. this algorithm proceeds on the assumption that the variable domains are organized hierarchically in subsets  where the leaf nodes of each domain hierarchy are the intrinsic domain elements  whilst the  abstract  nodes represent groups of domain values with common properties. if the constraints treat groups of domain values equally  hac avoids repetitive checks by filtering on abstract domain levels. 
   thus  for many problem areas it is a matter of fact that some domain objects of a constraint variable behave in the same manner and it is therefore a waste of search time to handle them as totally different objects. freuder introduced in  freuder  1  the notion of interchangeability  where two domain values are interchan-
       1t a  stands for the projection in the sense of relational algebra and extracts for our purposes exactly those values of the tuple t which are relevant to the constraint. 

geable in some local or global environment  if they can be substituted for each other without any effects to the environment. let us summarize the two main definitions. 
d e f i n i t i o n 1   f u l l i n t e r c h a n g e a b i l i t y   f r e u der  1   two values d1 and d1 of a domain dv of a constraint network r are fully interchangeable  if and only if  1  every solution to r which contains d  as an assignment for v remains a solution when d1 is substituted for d1   and  1  every solution to r which contains d1 as an assignment for v remains a solution when d1 is substituted for d 1 . 
definition 1 	 neighborhood 	interchangeabi-
l i t y  freuder  1   two values d1 and d1 for a variable v in a constraint network are said to be neighbor-
hood interchangeable  if and only tf the following condition holds  c is the set of all constraints in the network : 

   neighborhood interchangeability ts a sufficient  but not a necessary condition for full interchangeability. 
   it is shown in  freuder  1  that all neighborhood interchangeabilities can be computed in a pre-phase of search in 1 n 1 .a 1   1 . then  all interchangeable values can be replaced by one representative  which is essentially a form of problem reduction  because a subsequent search has to handle a network of eventually smaller size. it is proven that the usage of local interchangeabilities at preprocessing time is guaranteed to be cost effective for some csps. 
   but it is often the fact that different domain values are interchangeable only w.r.t. certain constraints  whilst there are constraints which distinguish between the intrinsic values. in that cases  neighborhood interchangeability makes no use of that nuances of equivalence. we extend freuder's ideas in a strict manner: we try to find groups of domain values which are essentially not distinguishable w.r.t. a single constraint. if a domain dv is filtered by a constraint c  the values of dv must be enumerated and checked against other value constellations. we propose the replacement of dv by classes of values  a domain partition w.r.t. c   where the size of the new domain and therefore the number of checks are minimal subject to c  without loss of any information. 
   the paper is organized in the following way: section 1 gives a formal definition of domain partitions and shows a simple way of computing them by constructing discrimination trees. in section 1 we show how various algorithms can be modified in term to use these domain classifications  and in section 1 we evaluate the proposed techniques by experimental results. section 1 concludes the work. 
1
¡¡¡¡n is the number of variables and a is the maximum domain size. the network is assumed to be binary. 
1 	domain partitions 
on each domain dv of a constraint network and each constraint c where  an equivalence relation 
evc can be defined  where two domain values of dv are equivalent in regard of  if and only if they behave in exactly the same manner w.r.t. the constraint c. the key item is that this equivalence relation induces a partition of a variable domain into groups of locally  i.e.  subject to a single constraint  interchangeable values. 
d e f i n i t i o n 1   t h e r e l a t i o n   let c be a constraint of a constraint network r and v var c . two values d  and d1 of the domain dv are in the relation .  we write    if and only if the following condition holds: 

 note the difference to neighborhood interchangeability: the relation depends on the single constraint c.  
t h e o r e m 1 the relation is an equivalence relation. 
	p r o o f s k e t c h : 	t w o domain 	values 
are in the relation   if the set of all assignment tuples where d  is assigned to v and the constraint c is satisfied is equivalent to the set where d1 is assigned to v. therefore   is in fact an equivalence relation  because it is defined by the equality-relatoon on sets  which is - of course - an equivalence relation. 
corollary 1 it is well-known in set theory that each equivalence relation on a set s induces a partition of s  which is a set of non-vacuous subsets of s where the elements of the partition are mutual exclusive and the decomposition is exhaustive. thus  according to each constraint c of a constraint network every domain dv can be partitioned into equivalence classes 
. we write  for short. 
   e x a m p l e : let the variables v1 v1 and v1 represent three ports of a board where modules must be mounted on. the available modules have two main characteristics: their mode   analog  or  digital   abbreviated by a resp. d  and their version number  1 or 1 . thus  the domains of the variables can be specified by 

   the following constraints restrict the possible constellations:  c1  the modules mounted on v1 and v1 must be of different mode;  c1  the modules mounted on v1 and v1 must have different version numbers. from the perspective of port v1  the domain  can be partitioned in the following way: 

note that in this simple csp there is no pair of neighborhood or fully interchangeable domain values in in the sense of definitions 1 and 1. 
   in that way  every element of a domain partition  is a set of domain values which are interchangeable w.r.t. the constraint c. similar to  freuder  1   
1 


1 adaptation of various constraint propagation algorithms 
now we are in the position to show how these domain partitions can be used to increase efficiency of various existing algorithms. we give a few modifications of the key procedures and show the advantages of the use of such interchangeability-techniques for certain problem types. we focus on binary csps. 
1 	c o n s t r a i n t f i l t e r i n g 
constraints are most commonly used in a destructive manner. the critical and most time consuming task in network consistency procedures is to check if all values of a particular variable domain can potentially be member of a solution. these checks are done repetitively for singular variables w.r.t. singular constraints. in the case of 
1
¡¡¡¡ a detailed description of the procedure dt and a proof that it actually computes the right thing is given in an extended report version of this paper. 
1 	constraint satisfaction problems 
binary constraints  usually the procedure revise is used  which removes all values of dv   for which no value of the domain of vj can be found such that the binary constraint cij; between vi and vj is satisfied. thus  the worst-case complexity of revise is 1 a 1   where a is the maximum domain size. 
¡¡in figure 1  a modified procedure called is depicted. we use the expression  d is a domain value  to denote the equivalence class of value d subject to the equivalence relation 

figure 1: a revise procedure using domain partitions. 
¡¡the main difference between the  classical  revise and revisedp is that the former checks in the worst case all tuples from  and the latter treats groups of interchangeable values equally and therefore possibly saves checks utilizing information included in the domain partitions. if we assume that the domain partitions  i.e.  the sets for all constraints c and all variables a worst case bound of algowe see that if the structure 
of a constraint network gets no use of domain partitions  all domain partitions are of same size as their corresponding domains   a  would be equal to a and the worst case behavior is not worse than that of the standard revise algorithm. of course  the smaller a  is in comparison to a  the better is the improvement. 
   it is easy to see that revise and revise d p produce exactly the same outcome. in that way  algorithms which use revise  such as arc- and path-consistency algorithms  simply have to change each call to revise by a call to revisedp and get effective use of reduced domain sizes. also many backtrack procedures use revise and therefore can benefit from revise d p . the palette ranges from classical chronological backtracking  where at each search step the domain of the current variable is made consistent to all past assignments  to various forms of look-ahead schemes  where the future search space is brought to certain degrees of  arc- consistency. particularly at the latter approaches  revise is used excessively. 
1 	backtrack search 
in the following  we want to evolve a slightly modified tree search scheme where interchangeable search branches are recognized by the use of domain partition infor-

mation. the structure of the algorithm is basically the same as classical backtrack tree search as described  for instance  in  fox and nadel  1 . 
   but first we have to give some notations we need for the development of the search procedure. each output of a traditional backtrack procedure is an assignment tuple representing a solution for the given csp. because we want to handle groups of interchangeable values  we have to modify the form of the output. instead of single assignment values  sets are used. in that way  assignment tuples are shifted to assignment bundles. 
d e f i n i t i o n 1   a s s i g n m e n t b u n d l e   let v be the set of n variables of a constraint network r. an n-tuple  where the ith element of  ts a nonvacuous subset of the domain dv  is called an assignment 
bundle. 
d e f i n i t i o n 1   s o l u t i o n b u n d l e   let t be the set of all solutions to a given constraint network r. an assignment bundle on the variables of r is said to be a solution bundle  if and only tf 
   therefore  solution bundles represent groups of path' through the search tree  where each path stands for a valid variable assignment of the constraint network. the terms of local and global consistency  see  for instance   dechter  1   can be extended to assignment bundles. 
d e f i n i t i o n 1 	  c o n s i s t e n c y 	of 	a s s i g n m e n t b u n d l e s   

   now we want to modify the classical backtrack search shell such that for each pass a bundle of assignments is computed. the following theorem gives us the fundamental basis for the utilization of domain partitions for that purposes. 


   now the modification of the backtrack procedure is easy figure 1 sketches the new algorithm backtracking d p . at each cycle in the search process the set of variables can be partitioned into three groups: the past variables  the current variable  and the future variables. since all the remaining domain values of the current variable are consistent to the assignments of the past variables  this is guaranteed by the revise at line 1   they are interchangeable w.r.t. that partial solution  bundle . now the domain of the current variable is going to be partitioned along their constraints to future variables. for each group of such interchangeable values a new search branch is opened. clearly  each output of a call to that procedure is an assignment bundle. the following theorem states soundness and completeness of the proposed algorithm. 
t h e o r e m 1 let d be the set of all variable domains of a constraint network r. each output  of a procedure call backtracking d p  1  d  ts a solution bundle to r. the set of all outputs cover all solutions. 
   p r o o f s k e t c h : the design of the algorithm is guided by theorem 1. thus  at each cycle of the search process the derived assignment bundle is either globally consistent or inconsistent. inconsistency leads to a deadend  each output is globally consistent. 
¡¡the algorithm passes through the whole search tree  even if interchangeable subtrees are condensed  and therefore computes all solutions. 
¡¡the advantageous behavior of the search shell backtracking d p for certain problem types is obvious. interchangeable search branches are bundled and visited once. if a dead-end occurs  all the partial assignments 
1 
represented by the derived assignment bundle are proven to be conflicting. a solution bundle represents a group of valid assignments. 
¡¡so we conclude  if the described domain partition knowledge is available  it can be used in a wide range of csp algorithms  both at filtering and search  with minimal change of procedures. apart from a small amount of additional overhead of computing domain partitions in a preprocessing phase and managing groups of domain values instead of singular elements  the new worst-case complexities are not worse than that of the original algorithms. if the problem structures are adequate for  i.e.  if the cardinality of domain decompositions are really smaller than the original domain sizes   effective cost reductions can be achieved. 
1 	performance analysis by experiments 
now we want to investigate the indicated performance improvements of our augmented search technique by experimental analysis. to identify those areas of csps interchangeability makes most capital out of  we are going to use the same test model as proposed in  benson and freuder  1 . 
1 	the experimental model 
different types of problems can be characterized by the following four parameters:  1  n  the number of constraint variables.  1  a  the maximum domain size.  1  t  the constraint tightness. the tightness of a constraint is the fraction of the number of forbidden tuples to the number of all possible tuples  and ranges therefore between 1 and 1. the higher t grows  the more value tuples are ruled out by the constraint  constraints with high values of t are said to be tight .  1  d  the constraint density. this is an indicator of how many constraints are defined in the network and therefore  how dense the constraint network is. d is a value between 1 and 1 and is specified as follows: let n be the number of variables  e the number of constraints; the maximum number of constraints   the minimum e m i n is n - 1 
 a connected constraint graph is assumed ; then d is the v a l u e . in that way  the higher d is  the more constraints are in the network. 
¡¡different algorithms are run on randomly generated csps and the results are compared. the tests are restricted to binary csps. 
1 	test cases and results 
our csp generator produces samples of random csps  where the four parameters n  a  t and d ranges on adjusted intervals. in  benson and freuder  1  it was pointed out that interchangeability techniques are most profitable if  1  the problem space grows  n and a grow    1  the constraint tightness is small  and  1  the constraintdensity is small. the combination of the last two points specifies those regions of problems where the csps are under-constrained. these are problems with many solutions. 
1 	constraint satisfaction problems 
¡¡we tested our algorithms in that manner and came to similar results. furthermore  our analysis shows that the use of domain partitions w.r.t. single constraints beats neighborhood interchangeability in all the test cases. this should be demonstrated by the subsequent results. 
¡¡in the following  three forward-checking search procedures are compared. the first is classical forwardchecking  fc . the second is forward-checking where all neighborhood interchangeable domain values are replaced by one representative value in the preface of search  fc-ni . the third is an instance of the search scheme backtrackingdp  see figure 1  where forwardchecking filtering is used. we call it fc-dp. a good indicator of the complexity of the search process is the number of consistency checks. of course  the checks needed for the computation of neighborhood interchangeability resp. the domain partitions are added to the runtime checks. the sample of each test are 1 randomly generated csps. 

figure 1: the effects of the use of interchangeability w.r.t. the number of variables. 
¡¡the first test demonstrates that utilization of interchangeability grows if the problem increases. the variable size n steps from 1 to 1  the maximum domain size a is fixed on 1  and the constraint tightness t and density d are from the interval   the profitable ranges for the use of interchangeability! . 
¡¡figure 1 shows the results. it can be seen that the positive effect of and grows with the size of n. furthermore  our algorithm is clearly better than fc-ni  and the distance increases with n. 
¡¡the second and third test holds n = 1  d = 1  and steps t  resp. d  from 1 to 1  d  resp. t  is randomly chosen from interval  1 - 1 . as depicted in figure 1 and figure 1  fc-ni and fc-dp are superior to classical fc when t  resp. d  is small. it can also be seen that fc-dp definitely beats fc-ni at these problem types. 
¡¡these results are convincing. the more tuples are permitted by a constraint  the smaller t is   the better 
¡¡¡¡1 forward-checking is a backtrack procedure where at each cycle in the search process all the future variables are filtered against the last-assigned variable. this method is known to behave in a very efficient manner  haralick and elliott  1 . 


figure 1: the effects of the use of interchangeability w.r.t. constraint tightness. 

figure 1: the effects of the use of interchangeability w.r.t. constraint density. 
is the chance that different variable values behave in the same manner w.r.t. the constraint and therefore came into the same class of domain values. if the constraint net is not dense  there are few constraints   there are at each choice point for a variable assignment few future constraints and the interchangeable groups of values are going to split less  line 1 of the backtrackingdp algorithm  depicted in figure 1 . 
   the lack of fc-nl is that it uses only the information that domain values are interchangeable w.r.t. all the connected constraints. in that sense  fc-dp is more accurate because of greater degree of granularity. and this can be achieved with the same overhead as the computation of all neighborhood interchangeabilities. 
1 	conclusion 
we have developed a formal basis for extraction and representation of interchangeable domain values in constraint satisfaction problems. the bulk of existing constraint satisfaction algorithms can be adapted to exploit this information. application fields arise in many areas of model-based reasoning  such as configuration  simulation or diagnosis   mainly in those cases where component-oriented systems are modelled in terms of constraint problems. thereby  identifying the variables for a csp  possible values for the variables are most often representations of complex real-world objects rather than unstructured constants. these objects  consider components  are described by various features. along these features objects can be grouped into classes where the elements of each class have some set of common properties. in that way  constraints are specifying relations on different aspects of the system and take classes of components rather than singular values into consideration. if that is noticed at reasoning  a much more adequate inference technique is employed. 
acknowledgments 
1 am very grateful to markus stumptner and thomas havelka for valuable discussions and comments on an earlier version of this paper. 
