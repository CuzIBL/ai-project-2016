 
   hand-crafting effective visual presentations is time-consuming and requires design skills. here we present a case-based graphic sketch generation algorithm  which uses a database of existing graphic examples  cases  to automatically create a sketch of a presentation for a new user request. as the first case-based learning approach to graphics generation  our work offers three unique contributions. first  we augment a similarity metric with a 
   set of adequacy evaluation criteria to retrieve a case that is most similar to the request and is also usable in sketch synthesis. to facilitate the retrieval of case fragments  we develop a systematic approach to case/request decomposition when a usable case cannot be found. second  we improve case retrieval speed by organizing cases into hierarchical clusters based on their similarity distances and by using dynamically selected cluster representatives. third  we develop a general case composition method to synthesize a new sketch from multiple retrieved cases. furthermore  we have implemented our casebased sketch generation algorithm in a user-system cooperative graphics design system called improvise-!-  which helps users to generate creative and tailored presentations. 
1 introduction 
   automated graphics generation systems promise to aid users in creating effective visual presentations  e.g.  charts and diagrams   mackinlay  1; zhou  1 . upon a user request  e.g.  displaying sales data   these systems directly provide users with the final presentation  e.g.  a barchart . to better tailor a presentation to user preferences  we are building a user-system cooperative graphics generation system  called improvise*  improvise* generates a presentation in two steps: sketch generation and sketch refinement. here a sketch is an outline of a presentation without all visual details  figure 1 . a generated sketch is first presented to users for their feedback. depending on the feedback  improvise* may redesign the sketch or refine it to create a final illustration  e.g.  setting the exact layout of figure 1 . by allowing users to critique a sketch first  improvise* can save the cost of fine-tuning an undesirable design. 
   our focus here is on a case-based learning approach to sketch generation. given a user request  from a database of existing graphic examples  cases  our approach uses a similarity metric to retrieve the case that is most similar to the request. the retrieved case is then directly reused for or adapted to the new situation  e.g.  new data . instead of using a rule-based approach as most graphics generation systems do  mackinlay  1; zhou  1   our decision of using case-based learning is two-fold. first  it is difficult to handextract a complete and consistent set of graphics design rules  while existing graphic examples are abundant  zhou et al.  1a . second  case-based learning is efficient for sketch generation  where we focus on learning overall visual structures instead of precise visual arrangements  e.g.  exact positions and scales  '. 
   although case-based learning has been applied to various design problems  borner  1   it has never been applied to graphics design. as the first case-based learning 

   
art and creativity 	1 
   
approach to graphics design  our work offers three unique contributions. 1  in case retrieval  we apply a set of adequacy evaluation criteria in addition to a similarity metric to ensure that the retrieved case is usable in sketch synthesis. to handle situations where a usable case may not be found  we decompose cases/requests into sub-cases/sub-rcquests to facilitate the retrieval of case fragments. 1  we improve case retrieval speed by organizing cases into hierarchical clusters based on their similarity distances and by using dynamically selected cluster representatives. 1  we synthesize a new sketch from multiple retrieved cases through case generalization and visual decoration inference  e.g.  inferring decorations such as coordinate axes and legends . 
   starting with a brief discussion of related work  we then present our case-based learning algorithm  highlighting the three unique features mentioned above. finally we use a concrete example to demonstrate how a new sketch is created. 
1 related work 
   unlike rule-based graphics systems  mackinlay  1; andre and rist  1; chuah ctal.  1; zhou  1   our work is the first to apply a general case-based learning technique to graphics design. although one system  sage  has an example-based generation component  it only reuses examples created by its own rule engine  chuah et al.  1 . compared to sage  improvise+ uses a much more finegrained representation to capture the semantic and syntacticfeatures of each graphic example  zhou et al.  1b . as a result  without using any rules improvise-*- can create new graphic sketches by directly learning from a wide variety of graphic examples. 
differing from a programming by demonstration system 
 myers et al.  1   where users must supply the desired examples  our approach uses the graphic examples stored in a database. 
   there are many case-based systems developed for other domains  e.g.  engineering design  sycara et al.  1 . the closest to ours are known as case-based structure generation systems  borner  1 . however we have gone beyond existing approaches to address specific challenges in graphics design. in particular  we support a systematic  multi-level case/request decomposition to achieve a more accurate caserequest matching. in contrast  existing systems either ignore case/request decomposition  borner  1  or simplify it 
 e.g.  only leaf-level decomposition  michelena and 
sycara  1  . we also develop a general case composition method to synthesize a new sketch from multiple cases  while existing systems only allow limited case composition  e.g.  combining only highly similar cases  borner  1  . 
1 example-based sketch generation 
   figure 1 gives an overview of our case-based sketch generation algorithm. our algorithm uses a database of existing information graphics  cases  to suggest a visual design for a new user request. here each stored case is described by its data content d and visual representation v. each request is presented by specifying the data d' and its desired visualization v  which may be partially or not specified at all. given such a request  our algorithm first uses a similarity metric to retrieve the top-matched case by computing the similarity distances between the request and existing cases. a topmatched case is the case that has the shortest similarity distance to the request. if the top-matched case fails our adequacy test  the current request is decomposed into a set of sub-requests. the whole process is recursively called to find the top-matched case for each sub-request. depending on the retrieval result  a new sketch  a fully specified v  may be constructed from the visual encoding  v  of a single matched case or composed from multiple cases. upon completion  the user is presented with a rendered graphic sketch  e.g.  figure 
1 . we also involve users at different design stages  figure 1 . for example  our studies have shown that users may express their preferences to retrieve more desired cases  zhou et al.  1b  or propose new visual compositions during sketch synthesis. 
   before discussing our algorithm  we first briefly describe the representations of our cases and user requests. 
1 representation of cases and user requests 

1 	art and creativity    we employ a labeled graph structure to represent our cases and requests. since we have described in detail how to model and represent various semantic and syntactic features of an existing graphic example previously  zhou et al.  1b   we summarize the representation here. 

visual database of cases 
　　our case base contains an assortment of graphic designs collected from a wide variety of sources  zhou et al.  1a . using a labeled graph structure  zhou et al.  1b   each case is described in xml as a graph  figure 1a   which expresses a complex mapping between a data hierarchy  dod1  and a visual hierarchy  v1-v1 . within each hierarchy  a data/visual node is described by a set of features  e.g.  d1 and v1 . there are two types of links in the graph: intra-hicrarchy links for data/visual node relationships  e.g.  d1 is indexed by d1 and all undirected edges implying parent-child relations   and inter-hierarchy links  red dotted lines  for datavisual mappings  e.g.  d1 to v1 . to facilitate case retrieval  we also index each case using two graphs  figure 1b : pdgraph organizes data-visual mapping pairs along the data hierarchy  while pvgraph arranges the mapping pairs by the visual hierarchy. note that a data/visual node may be mapped to multiple visual/data nodes  e.g.  d1 and v1  or none  denoted by  /  . our bi-graph indexing not only preserves all the information captured in the original complex graph  figure 1a   but also partitions one complex graph into two simpler sub-graphs  figure 1b   which can greatly simplify the similarity measuring process. 
　　when loading all cases from the database to memory  improvise+ parses the xml document of each case and automatically builds all case indices  pdgraphs and pvgraphs . 
user request 
　　a user request submitted in xml format is also described as a graph similar to the case representation. figure 1 outlines a request for presenting the information of a city. specifically  it asks to display the relevant county  countyboundary   basic information of the city  name and location   the city gazetteer  population  agelnfo for 1 age groups  and an arrow button indicating morelnfo is available upon request   and 1 city amenities  name  location  and type  such as community golf courses and swimming pools. since users may not know every presentation aspect  the representation of a user request is often a partially specified graph with the majority of the visual elements left unspecified. for example  figure 1 does not specify a visual encoding for any data nodes except morelnfo. 
　　based on the characteristics of data relations  our algorithm automatically assigns matching priorities to different data relations in a user request to indicate that matching certain data relations well  e.g.  index in figure 1  is more important than matching others  e.g.  has-a . as described below  matching priorities aid us in evaluating the usability of a retrieved case and in selecting visual candidates. currently  we assign priorities by relation type. for example  a higher priority is given to presentation relations like index than to semantic relations like has-a. 
1 case retrieval 
　　the success of an interactive case-based system like ours  depends largely on the quality and speed of the case retrieval process. to ensure retrieval quality  we augment similarity measuring with adequacy evaluation that tests whether a retrieved case is usable in sketch synthesis. if a usable case cannot be found  we decompose cases and requests into sub-cases and sub-requests to facilitate the 

figure 1. a sample user request. 
retrieval of case fragments. in addition  we use a hierarchi cally structured case base to improve our retrieval speed. 
adequacy-guided retrieval 
　　using a quantitative similarity metric that we have developed  zhou et al.  1b   our algorithm first retrieves the top-matched case for a request. as a result  each data node and data relation in the request are associated with a 
　　computed similarity distance in the range of  1  1 . since our similarity model stresses the overall structural similarity between the request and the existing examples  a data node dr in the request may or may not acquire a match  d  v  from the top-matched case. here d is the data that matches dr  and v the visual mapping of d  is a potential visual candidate for encoding dr in the new sketch. if no match is found for dr  the recorded distance is 1. however  the top-matched case may be inadequate for creating an effective sketch for the following three reasons. accordingly  we formulate three adequacy criteria to evaluate whether a retrieved case is usable in sketch synthesis. 
　　first  a top-matched case may produce a good overall match but poor or no matches for certain data nodes in the request. this implies that certain data or a sub-set of data expressed in the request may not be well visualized in the new sketch as they could be. to ensure a good match for every data node  i.e.  a short similarity distance   our first criterion requires that the similarity distance for every data node of a request be below a threshold. after conducting a series of case retrieval experiments  we currently set the threshold to 1 on a  1  1  scale  which proves to be a good indicator for creating a quality new sketch. 
　　second  suppose that a top-matched case passes the above criterion. by the matching priorities set in the request  however the distances for more important data relations may be larger than those of less important ones. since matching priorities are used to select visual candidates during case composition  using such a matching result may alter the original intention of the request and produce an undesired 

   
sketch. therefore our second criterion states that for every data relation in a request  the higher its matching priority is  the shorter its associated similarity distance must be. 
　　third  even though a top-matched case passes the above two criteria  it may still not be adequate for synthesizing a new sketch. our synthesis starts with the visual candidates of data leaf nodes in a request and composes the higher-level visual nodes from bottom up using the lower-level visual nodes. however our top-down graph matching is a partial matching  which may not guarantee that every data leaf node in a request acquire a visual candidate  zhou et al.  1b . our synthesis would then fail due to a lack of basic building blocks. thus our third criterion requires that every data leaf node in a request obtain a visual candidate. it is not required to find visual candidates for intermediate data nodes from case retrieval  since theirs can be composed from those of their children. 
case and request decomposition 
　　it is rare to find an exact match for a user request from the case base  but it is quite common that a fragment of the user request matches well with a fragment of a case 
 mitchell  1 . to facilitate the retrieval of case fragments  we support case/request decomposition. 
　　case decomposition. to avoid creating a large search space  our challenge is to determine the granularity of subcases. based on the data and visual characteristics of a graphic example  zhou et al.  1b   we develop four heuristics to guide our case decomposition. 
　　1 . we extract independent and meaningful visual structures  which are schematic illustrations for conveying concepts and processes  winn  1 . for example  the table showing the city information  figure 1a  is considered as a sub-case. within a case  such a structure can be easily identified by the value  visualstructure  of its feature category. 
　　1 . we turn a case  e.g.  figure 1b  into a sub-case by trimming all its decorations  e.g.  coordinate axes and legends . these simplified sub-cases are good matching candidates for most user requests  which normally do not specify the data for creating visual decorations. 
　　1 . we extract all visual leaf objects along with their data mappings from cases  e.g.  v1 and d1 in figure 1b  to form a 
　　visual dictionary  zhou and feiner  1 . the dictionary is used to find matches for user requests that contain a single node. 
　　1 . we decompose a case by data relations. figure 1 shows two data relations  has-a and index  encoded in figure 
1 b   which lead to two sub-cases  figure 1a-b . in figure 1 b   a dummy node is also added to preserve a rooted graph structure for a fast graph matching  see below . 
　　for the sake of performance  we automatically extract all sub-cases during the case loading stage. 
　　request decomposition. unlike case decomposition  which is done once during the case loading stage  request decomposition occurs whenever a retrieved top-matched case fails our adequacy evaluation. to ensure the retrieval quality without incurring the expense of rematching  we extract only the failed fragments as sub-requests  while retaining the results for succeeded ones. here a failed fragment is the biggest possible rooted sub-graph that contains failed nodes excluding the root of the current request. suppose that every node in fragment a  figure 1  passes our evaluation  but a node  e.g.  aname  in fragment b fails. we then create a sub-request containing the whole fragment b with city as the root  while keeping the matching results of fragment a. depending on the matching results  the decomposition may be repeated until sub-requests contain a single node. the matched cases for these single-node requests can be found from our visual dictionary. 
　　since sub-requests break up the original structure of a request  it is always desirable not to produce too many subrequests. request decomposition however enables us to find desired case fragments from a set of heterogeneous cases as we have  where finding a maximal common subgraph may fail  borner  1 . unlike a static request decomposition used by other researchers  michelena and sycara  1   our decomposition is dynamically performed based on our adequacy evaluation results. 
improve retrieval speed 
　　as the number of cases grows  the cost of searching for a desired case increases. moreover  finding a graphic example that matches a user request best is a computationally intensive graph-matching process itself. specifically  we need to match two pairs of pdgraphs and pvgraphs between a case and a user request. by exploiting the rooted hierarchical structure of pd/pvgraph  we perform an ordered  top-town graph matching  zhou et al.  1b  to accelerate otherwise an arbitrary graph matching process  e.g.  matching two complex graphs similar to figure 1a . to further improve case retrieval speed  we reduce the search space by using a 
　　hierarchically structured case base. 
	clusters 1 in figure 1   at each level we search only one 
1 	art and creativity 　　instead of searching the case base linearly  we exploit the organization of the cases. we use a hierarchical clustering algorithm  duda and hart  1  to arrange all cases by their pair-wise distances computed using a similarity metric  zhou et al.  1b . figure 1 shows such a cluster hierarchy. starting with the two outmost clusters in the hierarchy  e.g.  
cluster that is most likely to contain the top-matched case. 
   to find a cluster to follow  we first select a representative for each cluster using a quick approximation. a representative is a case closest to the request by three meta properties of its pdgraph: the total number of nodes  the average number of levels  and the average number of nodes at each level. we then select the cluster whose representative produces the shortest similarity distance to the request by our similarity metric. the rationale here is that the top-matched case for a request is likely to be in the same cluster of cases that match the request well by both meta properties and our similarity metric. 
following the selected cluster  e.g.  cluster 1 in figure 
1  down the hierarchy  e.g.  clusters 1   our algorithm repeats the above process until it explores a leaf cluster. in our experiments  this cluster-guided search improves the performance over a linear search by a factor of 1. due to the approximation used  our method however is not guaranteed to find the top-matched case. unlike other structured case search  where cluster representatives are pre-selected in advance  borner  1   we dynamically compute representatives for each request to achieve a more accurate retrieval. 
1 case composition: sketch synthesis 
   as the result of a successful retrieval  each data leaf node of the request acquires at least one visual candidate. starting with the visual candidates of the leaves  our algorithm synthesizes a sketch from bottom up by creating visual candidates for higher-level data nodes and finally for the root. in this section  we address three challenges arising in sketch synthesis. first  we resolve visual candidate conflicts when a data node in the request acquires multiple candidates. second  to compose multiple retrieved cases  we use decision-tree learning to generalize existing visual compositions and to verify new compositions. third  we automatically infer visual decorations from existing cases  such as the coordinate axes and legends  to complete a visual sketch design. 
conflict resolution of visual candidates 
   within a user request  a data node may acquire multiple visual candidates from different case matching. for example  data nodes name and price appear in two sub-requests  figure 1a-b . it is most likely for both items to obtain multiple visual candidates as the two sub-requests are matched to different cases. to select a proper visual candidate  we currently use both the matching priority set in the user request and the distance calculated during similarity measuring. specifically  we first retain candidates that are acquired through matching the data relations with a higher priority. in the above example  we will keep the candidates for name and price acquired through matching the sub-request in figure 
1 b   since the priority for matching relation index precedes that of relation has-a  figure 1a . if there are multiple candidates by the same matching priority  we then select candidates that have produced the shortest distance during the match. should there still be multiple candidates left  our algorithm would choose a candidate randomly. 
generalizing and verifying visual composition 
   our sketch synthesis uses visual candidates acquired for the lower-level data nodes to create visual candidates for the higher-level nodes in the request. since visual candidates may be retrieved from different cases  their compositions may never exist before and new compositions are needed to piece them together. here we denote a visual composition  =   of n visual elements as: 
　　ej  ...  en= rc  where e  is the zth element  r is the composition relation  and c is the composed visual object. below is an example of a cartogram  a map-based presentation  composition: 
position  map =s  overlay cartogram. 
it composes a cartogram by overlaying a position element on top of a map element. in our approach  a new composition for an intended data node  e.g.  amenity in figure 1  is proposed using the composition information recorded in its children  e.g.  aname  during the case retrieval. specifically  in each data node that acquires a visual candidate v from the retrieved case  e.g.  v1 from figure 1a   we record the composition relation and category specified in vs parent  e.g.  v1 . as a result  for each retrieved visual candidate our algorithm records the possible compositions that the visual candidate has participated in. 
   however a proposed composition may not always be valid. here validity means that a visual composition must produce an effective visual design  mackinlay  1 . for example  the above cartogram composition is a valid composition  but composing a visual object by juxtaposing two horizontal position elements is not. without hand-crafting rules or pre-defining connectors  michelena and sycara  1   we use a decision-tree learning technique to automatically induce a set of classification rules from 1 visual composition samples extracted from our cases. by our visual composition definition  we describe each sample using n input features specifying n visual element categories  e.g.  position and map  and one target specifying a combined composition relation and category  e.g.  overiay cartogram . currently n is set to 1 since most of our samples contain 1 elements. if a sample contains fewer than 1 elements  the remaining features are set to null. we train c1  quinlan  1   a decision-tree learning algorithm  on the 1 samples using 1-fold cross-validation  a standard procedure when the amount of data is limited. we obtain 1 generalized composition rules with an overall classification error of 1%. we then use these rules to verify a new composition. 
   to compensate for the situation where there is a lack of visual composition samples  we introduce negative samples that are known invalid compositions to help identify invalid new compositions. similar to the above process  we use classification rules induced from the negative samples to verify invalid new compositions to be eliminated. after both positive and negative verifications  if there are still multiple proposed compositions we use the confidence factors generated in the decision-tree learning to select the most probably valid composition. without a sufficient number of composition samples  our approach may not always verify a composition correctly. that is why we involve users in the design process to help improvise-*- in its decision-making  figure 1 . 
inferring visual decoration 
   a sketch is incomplete without the necessary visual decorations  such as coordinate axes and legends  which can guide users to comprehend the information encoded in the 
graphic  wilkinson  1 . however in a request a user rarely specifies the data for creating such decorations  which our algorithm must infer. 
　　currently our inference is based on an assumption that visual decorations can be created using only data leaves in a request. according to visual psychology studies  a person tends to first perceive the global structure of a graphic  e.g.  a spatial map  then examine the details  a particular color or a position   goldsmith  1 . only when a person attempts to interpret the meanings of visual primitives  e.g.  the color code in figure 1b   visual decorations are needed  e.g.  the legend in figure 1b . hence visual decorations normally encode leaf data or their transformations. 
　　specifically  for each leaf l and its match  d  v  from a retrieved case c  we trace the visual mappings of the matched data node d in c. within case c  if data d is used to create visual decorations  our algorithm would create a 
　　visual decoration for l. in the user request. more precisely  if there exists a data-visual mapping pair  d'  v  in case c  where d' is d or a transformation of d  and v is a visual decoration; v becomes a visual decoration candidate for the new sketch. however  l may need to be transformed for creating r  since d' is often a transformation of d. suppose that a user asks to present the depth of different lakes  lakedepth   which happens to acquire a match  price  vertlength  from a retrieved case as in figure 1 b . here price  a domain  has been transformed into a range  minprice  maxprice  in creating the y axis. similarly  in the new sketch a y axis will be created for encoding the range of lakedepth converted from the lakedepth domain. 
1 an example 
here we demonstrate how a specific user request  figure 
1  is fulfilled. for this request  our algorithm first retrieves the top-matched case  which fails our adequacy test  as the similarity distance  1  for node gazetteer in fragment b is above the required threshold  1 . while keeping the matches for fragment a  we extract the whole fragment b as a sub-request with node city as its root  since we always attempt to find an overall good match for the bigger subgraph  e.g.  the sub-graph covering b instead of b1 . next  the top-matched case for fragment b is retrieved  where nodes in b1 pass the evaluation  but those in b1-b1 do not. subsequently  our algorithm treats fragments b1-b1 as two new sub-requests and finds matches for them. except nodes under fragments b1 and b1  all other data nodes have now acquired acceptable matches. eventually desired matches are found for the last two sub-requests generated for fragments b1 and b1. since b1 contains only one node  its match is retrieved from our visual dictionary. 
　　using the retrieved results  our algorithm synthesizes a new sketch from bottom up  figure 1a . it proposes new compositions to create visual candidates for shaded data nodes  while reusing retrieved candidates for others. specifically  a new composition is proposed for gazetteer  since the visual candidates for its children population  agelnfo  and morelnfo  are retrieved from different cases. in this case  a top-tobottom table composition is recorded for population during the retrieval. according to c1  this is a valid composition  thus it is used to create a table for conveying gazetteer with 1 items arranged from top to bottom: a text  a pie chart  and an arrow button. similarly  visual candidates are created for amenity  then for city  at last for the root. as a result  a new sketch is created for this request with an inferred legend for interpreting the type of amenities  figure 1b . 
　　if the user chooses to use a different set of cases  an alternative can be created for the same request  figure 1 . once a new sketch is created  it can be directly stored back in our case base as a new addition  since the generated sketch has a representation similar to other existing cases. 
1 system implementation and performance 
　　improvise+ is implemented using java and c++. we use java to implement all design components  including our case-based sketch generation algorithm. wc have implemented two rendering components  one in java1d for 1d graphics and the other in c++/open inventor/opengl for 
1d graphics. improvisr+ currently runs on win1/linux/ sgi. on a pc with a 1 ghz pentium 1 processor  it takes about 1 seconds to create the sketch shown in figure 1 b  from about 1 cases  each of which contains about 1 data nodes and 1 visual nodes on average. 

1 	art and creativity 　　we have also conducted several experiments to test the effectiveness of our approach. according to our user feed-
back  our case-based approach can provide more versatile and  creative  design suggestions  e.g.  figure 1  than a rule-based approach can  zhou  1 . moreover  involving users in proper design stages helps create a more tailored visual presentation. for example  by specifying different retrieval preferences  zhou et al.  1b   users can choose among different design alternatives  figure 1 vs. figure 1b . 
1 conclusions and future work 
   in this paper  we have presented a case-based graphic sketch generation algorithm with an emphasis on its three unique features and how they facilitate an efficient and effective sketch generation. first  we present an adequacyguided case retrieval method  which augments a similarity metric with a set of adequacy evaluation criteria to retrieve a top-matched case that is also usable in sketch synthesis. to facilitate the retrieval of case fragments  we also describe how to systematically decompose a case/request when a 
   usable case cannot be found. second  we explain how to enhance case retrieval speed by organizing cases into hierarchical clusters based on their similarity distances and by using dynamically selected cluster representatives. third  we show how to construct a new sketch through case composition  including case generalization and visual decoration inference  e.g.  inferring coordinate axes and legends . 
   currently  we arc working in two areas to improve improvise+. first  we are creating a gui that allows users to easily specify a request by  drawing  a graph similar to figure 1 without writing an xml document. second  we are developing more sophisticated interaction support  where improvise+ can automatically engage users in interaction based on context. for example  if improvise+ cannot find a valid visual composition using decision-tree learning  it may decide to solicit user inputs. 
acknowledgments 
   we would like to thank keith houck and alison lee for proofreading the earlier version of this paper. we would also like to thank shimei pan for useful discussions on casebased learning. 
