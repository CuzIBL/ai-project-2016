 
much of our commonsense knowledge about the real world is concerned with the way things are done. this knowledge is often in the form of procedures or sequences of actions for achieving particular goals. in this paper  a formalism is presented for representing such knowledge based on the notion of process. a declarative semantics for the representation is given  which allows a user to state facts about the effects of doing things in the problem domain of interest. an operational semantics is also provided  which shows how this knowledge can be used to achieve given goals or to form intentions regarding their achievement. the formalism also serves as an executable program specification language suitable for constructing complex systems. 
1 	introduction 
active intelligent systems need to be able to represent and reason about actions and how those actions can be combined to achieve given goals. much of this knowledge is in the form of sequences of actions or  procedures  for accomplishing these goals. for example  knowledge about kicking a football  performing a certain dance movement  cooking a roast dinner  solving rubik's cube  or diagnosing an engine malfunction  is primarily procedural in nature. 
　within ai  there have been two approaches to the problem of action and practical reasoning  with a somewhat poor connection between them. in the first category  there is work on theories of action - i.e.  on what constitutes an action per se  1  1  1 . this research has focused mainly on problems in natural-language understanding concerned with the meaning of action sentences. second  there is 
'also affiliated with the center for the study of language and information at stanford university. 
this research has been made possible in part by a gift from the 
system development foundation  by the office of naval research under contracts n1-c-1 and n1-c-1  and by the national aeronautics and space administration under contract nas1. the views and conclusions contained in this paper are those of the authors and should not be interpreted as representative of the official policies  either expressed or implied  of the office of naval research  nasa  or the united states government. 
work on planning - i.e.  the problem of constructing a plan by searching for a sequence of actions that will yield a given goal  1  1  1 - 1 . surprisingly  almost no work has been done in ai concerning the execution of preformed plans or procedures - yet this is the almost universal way in which humans go about their day-to-day tasks  and probably the only way other creatures do so. to actually search the space of possible future courses of action  which is the basis of planning  is relatively rare. 
　in attacking this problem  we first have to identify what it is that humans or other active systems do when performing a complex action. we postulate that such systems have some representation of a procedure for achieving given goals  or reacting to particular events  and that they can reason about and execute this procedure to achieve their aims. just as we might view intelligent systems as having  beliefs** about the world  we consider these systems to have  procedures  for acting in the world. and  just as for theories of belief  the problem here is to provide abstract models for these  mental entities.  we call these abstract models processes. 
　there are two aims to our work. one is to develop a theory suitable for building active intelligent agents. in that regard  the theory presented in this paper models only the simplest kind of agent - one with no preserved beliefs and with limited reasoning abilities. we define a declarative semantics for our formalism  as well as an operational semantics. together these provide a suitable semantics for simple action sentences in natural language and a method of practical reasoning about how to accomplish given goals. 
　the other aim is to provide a basis for the design of improved programming languages - in particular  languages that allow users to represent their knowledge about the behavior of systems declaratively  are amenable to verification  and operationally are flexible and responsive to environmental changes. in this sense  our work can be viewed as the basis for executable specification languages. 
　it is important to point out that the theory presented here is not just another variant of the standard logics for describing dynamic behaviors. in particular  there is no existing logic  temporal  dynamic or interval-based  known to us that can both  1  express the same complexity of action as the formalism proposed here  which can handle sequencing  conditional selection  nondeterministic choice  iteration  and hierarchical abstraction   and  1  be used to automatically generate behaviors for achieving goals and to form plans. in this sense  the approach here offers the same kind of advantages as prolog  but in a dynamic rather than static domain: it can be viewed as a logic describing properties of behaviors  or it can be used as a programming language for generating behaviors to achieve given goals. 
　furthermore  the model we use is based on nondeterministic procedures. this nondeterminism is essential for providing the kind of flexibility exhibited by intelligent systems. the model also allows for action failures and tests with side effects  both of which are necessary for handling most real-world domains. such a model would be very cumbersome to describe in any of the standard temporal or dynamic logics - indeed  we know of none that have attempted to do so. 
　a system based on the proposed representation has been implemented and is currently being used for an intelligent robot and for fault isolation and diagnosis on the space shuttle. an early version of an implemented system is described in georgeff and bonollo  and the latest work in georgeff and lansky   the more recent work includes many capabilities not decribed in this paper  including a database of preserved  beliefs  and more powerful reasoning abilities represented as metalevel processes. 
1 	processes and actions 
most previous work in representing actions has been based on state change models  1  1  1 . however  existing models can describe only a limited class of actions and are too weak to be used in dealing with multiagent or dynamic worlds. 
　some attempts have recently been made to provide a better underlying theory for actions. mcdermott  considers an action or event to be a set of sequences of states  and describes a temporal logic for reasoning about such actions and events. allen  lj also considers an action to be a set of sequences of states  and specifies an action by describing the relationships among the intervals over which the action's conditions and effects are assumed to hold. however  while it is possible to state arbitrary properties of actions and events  it is not obvious how one could use these logics to achieve  or form intentions to achieve  one's goals.1 
our notion of action is essentially the same as that of 
mcdermott and allen; namely  we consider actions to be 
	m.georgeff et al. 	1 
sets of sequences of world states. however  in modeling intelligent agents  it is convenient to consider not only states of the external world  but also various  mental entities   such as beliefs  goals and intentions. in the same way  it is important to be able to model not only the actions that occur in the real world  but the internal mental  procedures  that agents use to generate their external behaviors. we will call these entities processes  see  and  for some early work based on similar ideas   . 
　we assume that  at any given instant  the world is in a particular world state. a process is some abstract mechanism that can be executed to generate a sequence of world states  called a behavior of the process. the set of all behaviors of a process constitutes the action  or action type  generated by the process. in this paper we restrict our attention to sequential  nonconcurrent  processes. 
　each process is modeled by a labeled transition network  with distinguished start and finish nodes. the nodes of the network are called control points  and are labeled with state conditions. these conditions can be viewed as representing constraints on possible world states. each arc of the network is labeled by a goal  which can be considered to represent a particular type of behavior to be achieved.1 associated with each network is a purpose  which is the goal that will be achieved if the process is successfully executed. 
　a process is executed in the following manner. at any moment during execution  the process is at a given control point c. an outgoing arc a may be traversed if  1  the current state of the world satisfies the state condition labeling c and  1  the goal labeling a is successfully achieved. if no outgoing arc from c can be traversed  process execution fails. execution begins with control at the initial control point and succeeds if control reaches the final control point. 
　in some ways  a process may be viewed as just a convenient way of specifying actions. however  processes also allow us to make a distinction that is critical for practical reasoning - we can distinguish between behaviors that are successful executions of the process and those that are unsuccessful  or have jailed . since actions often fail to achieve their intended goals  it is important to be able to reason explicitly about the consequences of action failure. we thus need to be able to represent the behaviors that correspond to failed actions as well as successful ones. this is particulary important if the model is to be extended to handle multiagent and dynamic environments  e.g.  see  . similarly  in natural-language understanding  it is important to have a denotation for action sentences  such as  he was painting a picture**  that allows for action failure  even in mid-performance   he was painting a picture when killed by lightning  . 
the notion of action failure also allows us to represent 
1 m.georgeff et al. 

figure 1: david and goliath 
tests on world states as actions  without the introduction of knowledge or belief structures  cf.  . to test whether a particular condition is true  one need simply perform an action that can only succeed when the condition is indeed true.  of course  action failure cannot  in general  be equated with the falsity of the condition being tested.  
1 	process descriptions 
in this section we develop a formalism for describing processes and for reasoning about the behaviors they generate. each process description consists of a purpose description and a body. the body is a network isomorphic to the network of the described process. the state conditions labeling the control points of the underlying process are modeled by expressions which have as their denotation world states; the goals labeling the arcs of the underlying process are modeled by expressions whose denotations are behaviors  sequences of world states . the purpose description also denotes a set of behaviors. 
　a typical process description using the formalism is shown in figure 1. it describes a procedure for killing someone with a slingshot. 
　the process involves gathering stones  placing them in a pile  getting a slingshot  and then repeatedly taking up a stone and shooting it until the foe   person  is hit on the head. in this particular domain  hitting someone on the head with a stone hurled by a slingshot always results in that person's death. the procedure is nondeterministic and allows agents to gather as many stones as they wish  limited only by their ability to continue gathering them. the procedure is not guaranteed to be successful - it may fail if any one of the actions labeling the arcs of the network fails. however  if there are only a finite number of gatherable stones  the procedure is guaranteed to terminate. 
　it is important to note how the process description captures implicit knowledge of the problem domain. this knowledge is of two kinds: one concerning the validity of the killing procedure  the other heuristic. for example  hitting a person on the head with an object propelled from a slingshot will not always kill them  e.g.  if it's a cotton ball   but will if it's a stone  in this particular domain . thus  the validity of the conclusion depends critically on the first part of the procedure  which ensures that only stones are placed in the pile.  strictly  the procedure should also ensure that the pile is initially empty or contains nothing but stones.  
　the procedure also captures heuristic knowledge in that earlier actions may make subsequent actions more likely to succeed. for example  the slingshot may require a certain size and weight of stone; however  instead of this being represented as an explicit precondition of the shooting action  it is represented implicitly by the context established by the procedure. in this case  the assumption is that any stone that can possibly be gathered will most likely possess the appropriate characteristics. note that this does not affect the validity of the procedure; if a stone does not have the necessary properties  the action of shooting the slingshot will fail. 
　we now give a definition of the formalism. a process description is a tuple 

  a : e -  f associates an action description with each arc 
  g is an action description called the purpose of the process. 
　the state descriptions labeling the nodes are called  partial  correctness assertions; the one labeling the initial node is called the precondition of the process. the action descriptions labeling the arcs are called goal assertions. 
　we choose predicate calculus as the state description language. a state description can be viewed as denoting a set of states; namely  those in which it is true. we distinguish between local and global variables. informally  the interpretation of a local variable is fixed in the interval during which a given arc is transitted  but can otherwise vary. a global variable  on the other hand  has a fixed interpretation during the execution of the entire process.  local variables are needed especially in loops where it is necessary to identify different elements from one iteration to the next . a state description is any formula in this calculus in which all global variables are free and all local variables are bound. in the example of figure 1  global variables are prefixed by $ and local variables  assumed to be existentially quantified  by %. all correctness assertions are assumed to be true. 
　an action description consists of an action predicate applied to an n-tuple of terms. action descriptions denote action types or sets of state sequences. that is  an expres-
sion like  walk  a  b   is considered to denote the set of walking actions from point a to b. any sequence of states satisfies the action description if it is in the set so denoted. in section 1 we augment the action description language to include various temporal operators. 
1 	declarative semantics 
the declarative semantics of process descriptions is intended to describe what is true about the underlying system of processes and the world in which they operate. such a semantics says nothing about how such knowledge could be used to achieve particular goals - rather  it simply allows one to state facts about certain behaviors. 
　on an intuitive level  the declarative semantics is straightforward. the intended meaning of a process description p is that every behavior that satisfies the goal and correctness assertions for some path through the net also satisfies the purpose of p. alternatively  one may view the body of p as denoting a set of behaviors - namely  those that satisfy the goal and correctness assertions for some path through the net. then the intended meaning of p is that each behavior in the set satisfies the purpose of p. 
	m.georgeffetal. 	1 
　unfortunately  allowing only simple paths through the net will not do. for example  if a node has multiple outgoing arcs  we need to allow several of these arcs to be tried until one is found successful. this is exactly the sort of behavior required of any useful conditional plan or program; if a test on one branch of a conditional fails  returns false   it is necessary to try other branches of the conditional. the problem in this case is that an attempted test may change the state of the world. thus  paths through the network must allow behaviors that explicitly include failed attempts at realizing tests and actions as well as successful ones. 
　a formal definition of the semantics of process descriptions is given in ; here we will simply give an informal outline. the approach is similar to that used for most temporal logics. we first consider single states. a state s consists of a set of elements from a domain d together with relations and functions defined over these elements. assuming a fixed interpretation for each constant symbol in the language  a state interpretation i assigns to each variable in the language an element of d  to each n-ary predicate symbol an n-ary relation in d} and to each nadic function symbol an n-adic function in d. the truthvalue of a state assertion w in a state s with respect to a state interpretation / is defined in the standard way  variables ranging over elements of d . we can also view w as denoting the set of states in which w is true. 
　while state interpretations may vary from state to state in the course of a behavior  the interpretation of global variables must remain the same. for a process description p  a global variable assignment a is defined to be an assignment of an element in d to each global variable in p. similarly  for each arc in p  we have a local variable assignment that associates a value with each local variable used by the goal assertion of that arc. in the course of a behavior satisfying the goal assertion  its local variables may take on at most one value. a state interpretation / is said to be consistent with a given a  or β  if the assignment to global  local  variables in / is the same as their assignment in  . note that we do not require a fixed interpretation for predicate symbols or function symbols over the sequence of states in a behavior. we define a process instance to be a process description together with consistent global and local variable assignments. 
   following the discussion above  we consider the set of behaviors denoted by the body of a process instance as falling into either of two classes  one of which we will call the success set of the process instance and the other the failure set the success set represents all those behaviors that constitute successful executions of the underlying process; the failure set represents all those executions that fail somewhere along the way. 
1 	m. georgeff et al. 
　let p be a set of process instances and let n be a node in a process instance p. an element q of p is said to be applicable to an arc a emanating from n if its purpose is included in the set of behaviours described by the goal assertion of a. 
　the allowed behaviors starting at node n are those in which each applicable process instance at n is tried at most once until one succeeds or they all fail. * let succ n  a  be the set of behaviors consisting of some arbitrary number of unsuccessful attempts by applicable process instances  at most one per process instance  on the arcs emanating from n  followed by a behavior of an applicable process instance that succeeds for some arc a. each of these attempts  both successful and unsuccessful  must begin in a state that satisfies the correctness assertion at node n. similarly  let fail n  be the set of all behaviors that fail to reach a successor node of n  i.e.  behaviors consisting of failed attempts of all applicable processes. in this case  an attempt may fail because it cannot satisfy the correctness assertion at node n  or because the applicable process instance itself fails. 
　the success and failure sets for a node n  denoted s n  and f n  respectively  are then defined recursively as follows: 1 
1. if n is a final node  then s n  is the set of states satisfying the correctness assertion at n and f n  is the set of states that fail to satisfy the correctness assertion at n. 

　the success and failure sets of a process description p are then taken to be the success and failure sets  respectively  of the initial node of p. the semantics of p is that any behavior in the success set of p satisfies the purpose of p. 
as an example  consider the process networks shown in 
figure 1 where the arcs are labeled with applicable process instances. for a process instance p1 let  p  denote the set of its successful behaviors  and  p f the set of its failed behaviors. then the success and failure sett for each of the process networks in figure 1 are as follows: 
1 the deciiion to try each process instance at most once allows us to realiee the control constructs of standard programming languages; various alternatives are possible without substantially affecting the results presented here. 


figure 1: sample process networks 

　notice that backtracking upon failure occurs only up to the current node being exited  and no farther. 
　because process descriptions can be recursive  and because loops in process networks introduce self-reference into the definitions of s and f given above  a formal specification of the semantics of process descriptions requires a fixed-point construction. that is  for a given set of process instances p = p1... pn  we need to define a transformation t that maps n-tuples of pairs of success and failure sets into additional such n-tuples. the definition of t is based on the definition of success and failure sets given above. if one assumes a set of primitive tests and actions  the least fixed point of t applied to these primitives can be taken as the denotation of p1... pn. 
1 	operational semantics 
process descriptions provide a way of describing the effects of actions in some dynamic problem domain. but how can a system or  agent  use this knowledge to achieve its goals  that is  we currently have a knowledge representation that allows us to state certain properties about actions and what behaviors constitute what actions. we have not explained  however  how an agent's wanting something can provide a rationale for or cause an agent to act in a certain way. this is the basis of so-called practical reasoning . 
　one way to view the causal connection between reasoning and action is as an interpreter that takes knowledge about actions and goals as input and as a result performs certain acts in the world. an abstract representation of such an interpreter may be considered to be the operational semantics of the knowledge representation language. 
　if a system is to be able to achieve its goals  it must be able to bring about certain actions  and thus be able to affect the course of behavior. thus  we assume a system with certain effector capabilities. the actions that the system can effect simply by choosing to do so will be called primitive actions. the system must also be able to sense the world to the extent of determining the success or failure of the primitive actions. in addition  we assume the system has sensor capabilities for detecting satisfaction of all correctness assertions. 
　the system tries to achieve its goals by applying the following interpreter to applicable process instances. the interpreter works by exploring paths from a given node n in a process description p in a depth-first manner. to transit an arc  it unifies the corresponding arc assertion with the purposes of the set of all process descriptions  and executes those that unify  one at a time  until one terminates satisfactorily. if none of the matching processes terminate successfully  and all leaving arcs fail  the execution of p fails. at each node  we verify that the correctness assertion  c-assertion  is satisfied. 
function successful  p n  if  is-end-node n  then 
if  satisfied  c-assertion n   then 
return true 
else return false 
else 
arc-set :=  outgoing-arcs n  pr-a-set :=  processes-that-unify arc-set  do until  empty pr-a-set  
if  not  satisfied  c-assertion n    then 
return false 
pr-a :=  randomly-delete pr-a-set  pr :=  process pr-a  a :=  arc pr-a  if  successful pr  start-node pr   then 
return  successful p  terminating-node a   
end-do return false 
end-function 
　the function processes-that-unify takes a set of arcs and returns the set of processes that unify with some arc in 
	m. georgeff et al. 	1 
the set  along with the specific arc with which each unifies. the functions process and arc select out the process instance and corresponding arc from each element of this set. the function randomly-delete selects an element from a set  destructively modifying the set as it does so. the order in which selections are made is called the selection rule. the function return returns from the enclosing func-
tion  not just the enclosing do. the initial system goal is represented by a process description with a single arc labeled with the goal. 
　note that  if this theory were to form the basis of the reasoning capabilities of some real-world agent  we would probably want process descriptions to be invoked on the basis of particular facts becoming known as well as because particular goals have been established. a suitable organization for such a system would be to have a list of all applicable process descriptions - some goal-invoked and others fact-invoked - and at each stage of processing select one of these for execution . the above recursive implementation would have to be modified  but the semantics would remain essentially the same. 
　of course  it is important that the operational and declarative semantics be consistent with each other. the declarative semantics defines a set of behaviors for each process instance. the operational semantics also defines a set of behaviors for each process instance  but this set depends on the selection rule utilized in the above algorithm. let  p d be the set of successful behaviors for a process instance p as given by the declarative semantics  and let  p o r be the set of successful behaviors for p as given by the operational semantics for selection rule r. it is not difficult to show that 

this means that any behavior generated by the interpreter given above will satisfy the declarative semantics. however  the inclusion  in general  is strict. that is  the interpreter may not achieve some given goal even when  according to the declarative semantics  there exists a way to achieve it. but  assuming that all correctness assertions are directly testable  we do have the following: 
if a behavior a is in  p d  there exists a selection rule r such that s is in  p o r-
　this is the best one can really hope for when any particular selection may cause some possibly irreversible action. it means that  provided you are smart enough to choose the right selection rule  the above interpreter will achieve a goal if it is at all achievable. this highlights the importance of reasoning about the selection of applicable processes in any practical implementation  see also |1  . it also means that one can reliably plan to achieve goals and be guaranteed of finding a finite plan if one exists. 
　
1 	m. georgeff et al. 
1 	action descriptions 
so far  action descriptions have been restricted to simple action predicates. however  it is desirable to also allow a class of action descriptions that relate to conditions on world states. 
　we thus extend the action description language to include actions that achieve a given world state p  represented as !p   actions to test for p   p   and actions that preserve p  #p . we define these action descriptions more formally as follows. 
　we assume a fixed domain d and a fixed interpretation for constant symbols. let w be a state assertion  a an action description of the above form  and s = s1... sn a behavior. assume fixed global and local variable assignments and let all local interpretations / be consistent with them. we then have the following truth rules: 
1. !w is true in s if  for some local interpretation i  w is true in sn 
1.  w is true in s if  for some local interpretation /  w is true in s1. 
1. #w is true in s if  for all i  1   i   n  there exist local interpretations ii - such that w is true of all states in s or -iw is true in all states in 1. 
　to make effective use of such action descriptions we can use proof rules of the kind given below. we will use the notation  p   a  to mean that every successful behaviour associated with the process description p satisfies the temporal assertion a.  p f denotes failed behaviors. the symbols  ;  and t represent sequential composition and  nondeterministic  branching  respectively. 
some typical proof rules are as follows: 
conjunctive testing 

conjunctive achievement 

disjunctive testing 

disjunctive achievement 

　note that these proof rules are not the only ones  nor are they the strongest  that could be used. for example  in the rule for conjunctive achievement  we need not require that p be unaffected by  p1 ; all we need do is regress the goal !p through  p1  and set this as the goal of  p1 . however  since in most real-world cases it is difficult to regress conditions through processes  the rules given above prove to be most practical. 
　the declarative semantics with this extension to the language is standard. the operational semantics simply requires that the interpreter be modified to allow application of the proof rules when necessary. 
1 	conclusions 
this paper has presented a simple model for action and a means for representing knowledge about procedures. we have indicated the importance of reasoning about processes rather than simply histories or state sequences. a declarative semantics for the representation was provided that allows a user to specify facts about behaviors independently of context. we have also given an operational semantics that shows how these facts can be used by an agent to achieve  or form intentions to achieve  its goals. 
　this knowledge representation can also be used for planning. indeed  the operators of many standard planning systems  such as noah   deviser  and sipe   can be viewed as restricted forms of process descriptions. the fact that any behavior allowed by the declarative semantics can also be found using the operational semantics means that a planning algorithm that tried all possible selection rules would be  complete  - that is  it would find a solution if one existed. 
　by modifying the formalism so that failure sets allow full backtracking  single-state theorem proving of horn clauses becomes a special case. this modification would also include as a special case the realization of  backtracking through triangle tables   as proposed by nilsson . however  such modifications present practical problems of verification and efficiency  and would appear useful only in some special cases. 
　in some ways  the declarative semantics is surprisingly complex and would seem to indicate some undesirable properties of the representation. most of these difficulties arise from the need to model failed as well as successful behaviors. of course  if we could fully specify necessary correctness conditions independently of context  and test for them  failed behaviors would become irrelevant for practical reasoning; we could always test to make sure conditions were true when needed. but experience with programming languages  and indeed the real world  shows that this can often be impractical if not impossible. 
the formalism presented here can also be viewed as an 
　
executable specification language - that is  as a program-
ming language that allows a user to directly describe the behaviors desired of the system being constructed. the fact that the language has a denotational semantics allows facts about the behavior of the system to be independently stated and verified. the operational semantics provides a means for directly executing these specifications to obtain the desired behavior. in this sense the language has much in common with prolog  except that it applies to dynamic domains instead of static domains. 
　the system modeled in this paper has no database  and thus no storage for knowledge or beliefs. we have a practical implementation of a system that includes such a database  but have yet to formalize it. this introduces all the standard planning issues  such as the frame problem  and consistency maintenance . we also need to investigate concurrency  and extend the model to deal with it. the notion of process failure and correctness assertions play a particularly important part when multiple agents or dynamic environments are allowed  and bear some relationship to formalisms for concurrent program verification. some work in this direction is described by georgeff . 
