
we consider the problem of synthesizing a fully controllable target behavior from a set of available partially controllable behaviors that are to execute within a shared partially predictable  but fully observable  environment. behaviors are represented with a sort of nondeterministic transition systems  whose transitions are conditioned on the current state of the environment  also represented as a nondeterministic finite transition system. on the other hand  the target behavior is assumed to be fully deterministic and stands for the behavior that the system as a whole needs to guarantee. we formally define the problem within an abstract framework  characterize its computational complexity  and propose a solution by appealing to satisfiability in propositional dynamic logic  which is indeed optimal with respect to computational complexity. we claim that this problem  while novel to the best of our knowledge  can be instantiated to multiple specific settings in different contexts and can thus be linked to different research areas of ai  including agent-oriented programming and cognitive robotics  control  multi-agent coordination  plan integration  and automatic web-service composition.
1 introduction
imagine an intelligent system built from a variety of different components or devices operating  that is  performing actions  on the same shared environment. for example  consider the case of a blocks world scenario in which different kind or versions of robotic arms can move  paint  clean  dispose blocks  and so on. next  imagine that the central system possesses some information about the logic of these components or devices-e.g.  a particular arm type can paint or clean a block after picking it up  but another type of arm is only capable of painting blocks. however  the knowledge about these devices is partial in that their internal logic may potentially expose nondeterministic features. for instance  the system may have no information regarding the use of paint in a painting arm  and thus  it is always unable to predict whether the arm will run out of paint after a painting action. if it does  then the arm cannot be used to paint again until it is recharged. nonetheless  the central system has full observability on the state of the devices in question: after the arm is used to paint a block  the central system will come to know whether such arm ran out of paint or not  maybe via a sensor light . finally  the central system is also  partially  knowledgeable about the shared environment  in which all the components ought to execute. as with the devices  the system possesses a nondeterministic model of the real environment and has full observability on it too. the question then is: can the central system  always  guarantee a specific deterministic overall behavior by  partially  controlling the available devices or components in a step-by-step manner  that is  by instructing them on which action to execute next and observing  afterwards  the outcome in the device used as well as in the environment 
¡¡it is not hard to see that the above setting can be recast in a variety of forms. in the context of agent-oriented programming  1; 1   an intelligent agent may control the execution of a set of predefined nondeterministic agent plans in order to realize a desired deterministic plan-intention  which in turn  may have been obtained via planning  1; 1 . similarly  when it comes to plan coordination   one can think of coordinating or merging approximate models of multiple agents' plans into a global fully deterministic multi-agent plan. also  in the context of web-service composition  1; 1; 1  1 existing web services may be composed on the internet so as to implement a new complex web service. in all these cases  the challenge is to automatically synthesize a fully controllable module from a set of partially controllable existing modules executing in a partially predictable environment.
¡¡under this setting  the technical contributions of this paper are threefold. first  we formally define the problem within an abstract framework. second  we devise a formal technique to perform automatic synthesis of the fully controllable module. we show that the technique proposed is sound  complete  and terminating. lastly  we characterize the computational complexity of the problem and show that the proposed technique is optimal with respect to computational complexity.
1 the setting
let us start by defining the synthesis problem  that is the subject of our research. to that end  we develop an abstract framework based on  sort of  finite state transition systems.
environment we assume to have a shared observable environment  which provides an abstract account of the observable effect and preconditions of actions. in giving such an account  we take into consideration that  in general  we have incomplete information about the actual effects and preconditions of actions. thus  we allow the observable environment to be nondeterministic in general. in that way  the incomplete information on the actual world shows up as nondeterminism in our formalization.
¡¡formally  an environment e =  a e e1 ¦Äe  is characterized by the following five entities:
  a is a finite set of shared actions;
  e is a finite set of possible environment states;
  e1 ¡Ê e is the initial state of the environment;
  ¦Äe   e ¡Áa¡Áe is the transition relation among states:  holdswhen action a performedin state e may
lead the environment to a successor state e.
¡¡note that our notion of the environmentshares a lot of similarities with the so-called  transition system  in action languages . indeed  one can think of using that kind of formalism to compactly representthe environmentin our setting.
behavior a behavior is essentially a program for an agent or the logic of some available device or component. such a program however leaves the selection of the action to perform next to the agent itself. more precisely  at each step the program presents to the agent a choice of available actions; the agent selects one of them; the action is executed; and so on.
¡¡obviously  behaviors are not intended to be executed on their own  but they are executed in the environment  cf. above . hence  we equip them with the ability of testing conditions  i.e.  guards  on the environment when needed.
¡¡formally  a behavior b =  s s1 g ¦Äb f  over an environment e  is a characterized by the following entities:
  s is a finite set of behavior states;
  s1 ¡Ê s is the single initial state of the behavior;   g is a set of guards  which are boolean functions g :
e ¡ú {true false}  where e is the set of the environment states of e;
  ¦Äb   s ¡Ág¡Áa¡Ás is the behavior transition relation  where a is the set of actions of e-we call the g ¡Á a components of such tuples  the label of the transition;
  finally  f   s is the set of final states of the behavior  that is  the states in which the behavior may stop executing  but does not necessarily have to.
observe that  in general  behaviors are nondeterministic in the sense that they may allow more than one transition with the same action a and compatible guards evaluating to the same truth value.1 as a result  the central system  when making its choice of which action to execute next  cannot be certain of which choices it will have later on  since that depends on what transition is actually executed. in other words  nondeterministic behaviors are only partially controllable.
¡¡we say that a behavior b =  s s1 g ¦Äb f   over the environmente  is deterministic if there is no environmentstate e of e for which there exist two distinct transitions  s g1 a s1  and  s g1 a s1  in ¦Äb such that g1 e  = g1 e . notice that given a state in a deterministic behavior and a legal action in that state  we always know exactly which is the next state of the behavior. in other words  deterministic behaviors are fully controllable through the selection of the action to perform next  while this is not the case for nondeterministicones.
 runs and traces given a behavior b =  s s1 g ¦Ä f  and an environment e =  a e e1 ¦Äe   we define the runs of b on e as  possibly infinite  alternating sequences of the following form:  s1 e1 a1 s1 e1 a1 ¡¤¡¤¡¤  where e1 = e   and for every i we have that
 s  e  a +1 s +1 e +1  is such that:
  there exists a transition  ei ai+1 ei+1  ¡Ê ¦Äe; and
  there exists a transition  si gi+1 ai+1 si+1  ¡Ê ¦Äb  such that gi+1 ei  = true.
moreover if the run is finite  that is  it is of the form
  then.
¡¡apart from runs  we are also interested in traces generated by the behavior. a trace is a sequence of pairs  g a   where g ¡Ê g is a guard of b and a ¡Ê a is an action  of the form t =  g1 a1  ¡¤  g1 a1 ¡¤¡¤¡¤ such that there exists a run gi ei   = true
for all i. if the trace t =  g1 a1 ¡¤¡¤¡¤ g  a   is finite  then there exists a finite run  with.
¡¡the traces of the deterministic behaviors are of particular interest: any initial fragment of a trace leads to a single state in the behavior. in a sense  the deterministic behavior itself can be seen as a specification of a set of traces.
the system a system s =  b1 ... bn e  is formed by an observable environment e and n predefined nondeterministic behaviors bi  called the available behaviors. a system configuration is a tuple  s1 ... sn e  denoting a snapshot of the system: behavior bi is in state si and the environment e is in state e. we assume that the system has a specific component  called the scheduler  that is able to activate  stop  and resume the behaviors at each point in time.
the problem the problem we are interested in is the following: given a system s =  b1 ... bn e  and a deterministic behavior  called the target behavior b1 over e  synthesize a program for the scheduler such that the target behavior is realized by suitably scheduling the available behaviors.
¡¡in order to make this precise  we need to clarify which are the basic capabilities of the scheduler. the scheduler has the ability of activating-resuming one1 of the many available behaviors by instructing it to execute an action among those that are possible in its current state  taking into account the environment . also  the scheduler has the ability of keeping track  at runtime  of the current state of each available behavior.
technically  such a capability is called full observability on the states of the available behaviors. although other choices are possible   full observability is the natural choice in this context  since the available behaviors are already suitable abstractions for the actual behaviors  and hence there is no reason to make its states partially unobservable: if details have to be hidden  this can be done directly within the abstract behavior exposed  possibly making use of nondeterminism.
¡¡we are now ready to formally define our synthesis problem. let the system be s =  b1 ... bn e   where e =  a e e1 ¦Äe  is the environment and bi =
 si si1 gi ¦Äi fi  are the available behaviors. let the target behavior be b1 =  s1 s1 ¦Ä1 f1 .
¡¡a system history is an alternating sequence of system configurations and actions of the form
such that the following constraints hold:
  s1i = si1 for i ¡Ê {1 ... n}  that is  each behavior starts in its initial state;
  e1 = e1  that is  the environment starts in its initial state;
  at each step   there exists an i ¡Ê {1 ... n} such that  ski  gik+1 ak+1 ski+1  ¡Ê ¦Äi and for all  skj+1 = skj  that is  at each step in the history  only one of the behaviors  namely bi  has made a  legal  transition  according to its transition relation ¦Äi   while the other ones have remained still;
  at each step   we have that  ek ak+1 ek+1  ¡Ê ¦Äe  that is  the environment has also made a legal transition according to its transition relation.
	a scheduler program is a function p	:	h ¡Á a	¡ú
{1 ... n u} that  given a history h ¡Ê h  where h is the set of all system histories as defined above  and an action a ¡Ê a to perform  returns the behavior  actually the behavior index  that is scheduled to perform the action. observe that such a function may also return a special value u  for  undefined.  this is a technical convenience to make p a total function returning values even for histories that are not of interest  or for actions that no behavior can perform after a given history.
¡¡next  we define when a scheduler program is a composition that realizes the target behavior-a solution to the problem. first  we point out that  because the target behavior is a deterministic transition system  its behavior is completely characterized by the set of its traces  that is  by the set of infinite sequences of actions that are faithful to its transitions  and of finite sequences that in addition lead to a final state.
¡¡so  given a trace t =  g1 a1 ¡¤ g1 a1 ¡¤¡¤¡¤ of the target behavior  we say that a scheduler program p realizes the trace t iff for all  and for all system histories 
is defined below  such that in the last environment state  we have that and  is nonempty  where the set of system histories is inductively defined as follows:
  ht p1 = { s1 ... sn1 e1 };  is the set of-length system histories of the  such that:
  where  is the last system
configuration in h;
 is an action such that  with u  that is  the scheduler states that action
   system history h should be executed in behavior bi;  with true  that is  behavior bi may evolve from its current state to
 w.r.t. the  current  environment state e;
  that is  the environment may
evolve from its current state e to state;
 and  for  that is  only behavior bi is allowed to perform a step.
¡¡moreover  as before  if a trace is finite and ends after m actions  and all along all its guards are satisfied  we have that all histories in ht pm end with all behaviors in a final state. finally  we say that a scheduler program p realizes the target behavior b1 if it realizes all its traces.1
¡¡in order to understand the above definitions  let us observe that  intuitively  the scheduler program realizes a trace if  as long as the guards in the trace are satisfied  it can choose at every step an available behavior to perform the requested action. if at a certain point a guard in the trace is not satisfied in the current environment state  then we may consider the trace finished  even if it is not in a final state . as before  however  because the available behaviors nondeterministically choose what transition to actually perform when executing an action  the scheduler program must be such that the scheduler will always be able to continue with the execution of the next action no matter how both the activated behavior and the environment evolve after each step. finally  the last requirement makes sure that all available behaviors are left in a final state when a finite trace reaches its end with all guards satisfied.
¡¡observe that  in general  a scheduler programcould require infinite states. however  we will show later that if a scheduler that realizes the target behavior does exist  then there exists one with a finite number states. note also that the scheduler has to observe the states of the available behaviors in order to decide which behavior to select next  for a given action requested by the target behavior . this makes these scheduler programs akin to an advanced form of conditional plans .
1 an example
we now come back to our original blocks world example in order to illustrate the abstract framework developed in the previous section. the complete scenario is depicted in figure 1. the aim of the whole system is to paint existing blocks. blocks can be processed by cleaning and painting them. before processing a block  though  it is necessary to prepare it  for example  by moving it to a special processing location. furthermore  only after a block has been disposed  can another block be prepared for processing. finally  cleaning and painting may  sometimes  require resources  namely  water and paint  respectively: we assume there are two tanks  for water and paint  respectively  and that both are recharged simultaneously by pressing a recharging button.

figure 1: a painting blocks world scenario.
¡¡now  the desired target behavior t that we want to achieve is as follows. first  a block is prepared for processing. then  the block in question can either be painted right away or painted after being cleaned-some  dirty  blocks may need to be washed before being painted. note that the decision of whethera block needs to be cleaned lays outside of our framework. after a block has been painted  it is disposed. finally  the recharging button is pushed. see that this target behavior is  conservative   in that it always recharges the tanks after a block has been processed.
¡¡one can think of the above target behavior as the arm that one would like to have. however  such arm does not exist in reality. instead  there are only two different arms available. the first arm a  a cleaning-disposing arm  is able to clean and dispose blocks. the second arm b is capable of preparing  cleaning  and painting blocks. both arms are able to press the recharge button to refill the tanks.
¡¡so  the system is composed of the environment e and the two arms a and b shown in figure 1. let us now note a few interesting points. first  the environmente provides the  general  preconditions of actions in the domain  e.g.  dispose can only be executed after a prepare action . the environment also includes some information about the water tank: in e1 and e1  the water tank is not empty; and in e1 and e1  the water tank is indeed empty. notice that it is still conceivable to clean a block in state e1  by some method that does not rely on water. however  because arm a does use water to clean blocks  it can only do it when the environment is in fact in state e1. second  we observe that whereas only the second arm can prepare a block  only the first arm can dispose a block. lastly  the most interesting remark comes from arm b's internal logic  for which the system only has partial information. after painting a block  arm b may evolve nondeterministically to two different states: b1 or b1. intuitively  the arm evolves to state b1 as soon as the paint tank becomes empty; otherwise the arm evolves to state b1. once the arm runs out of paint  it can only clean blocks until the tanks are eventually recharged. notice also that  unlike arm a  arm b does not require the environment to be in state e1 to clean a block  as its cleaning mechanism does not rely on water.
¡¡we aim to automatically synthesize a scheduler program so as to realize the target behavior  t  by making use of the available behaviors  arms a and b  and considering the environment  e . see the next section.
1 the synthesis technique
we are now ready to investigate how to check for the existence of a scheduler program that realizes the target behavior  and even more  how to actually compute it. we start with some preliminary considerations on the computational complexity that we should expect. the result by muscholl and walukiewicz in   which can be easily rephrased in our framework  gives us an exptime lowerbound.
¡¡more precisely  let us call empty environment any environment of the form e =  a e eo ¦Äe   where e = {eo}
 i.e.  the  observable  environment has a single state   and ¦Äe = { e1 a e1  | a ¡Ê a}   i.e.  there are no preconditions on actions  nor actions have any effect on the environment . also  let us call deterministic guardless behavior any behavior of the form b =  s s1 {gtrue} ¦Äb f   where gtrue is the constant function returning always true  and ¦Äb is functional  i.e.  for each state s ¡Ê s and action a ¡Ê a  there is at most one state s such that . then  muscholl and walukiewicz's result can be stated as follows.
theorem 1  muscholl & walukiewicz 1  checking the existence of a scheduler program that realizes a target deterministic guardless behavior in a system consisting of an empty environment and a set of available deterministic guardless behaviors is exptime-hard.1
¡¡hence  checking the existence of a scheduler program in our general framework is at least exponential time. next  we show that the problem is actually exptime-complete  by resorting to a reduction to satisfiability in propositional dynamic logic  pdl . moreover  such a reduction can be exploited to generate the actual scheduler program which will be finite. in doing this  we extend the approach in   originally developed in the context of service composition to deal with empty environments and deterministic guardless behaviors. dealing with a non-trivial environment  and especially dealing with the nondeterminism of the available behaviors  requires solving same subtle points that reflects the sophisticated notion of scheduler program that is needed for that.
1 propositional dynamic logic
propositional dynamic logic  pdl  is a modal logic specifically developed for reasoning about computer programs . syntactically  pdl formulas are built from a set p of atomic propositions and a set ¦² of atomic actions:
		 
	r	 ¡ú	a | r1 ¡È r1	r1;r1 | r  |	  
where p is an atomic proposition in p  r is a regular expression over the set of actions in ¦²  and a is an atomic action in ¦². that is  pdl formulas are composed from atomic propositions by applying arbitrary propositional connectives  and modal operatorsand  r ¦Õ. formulameans that there exists an execution of r  i.e.  a sequence of actions conforming to the regular expression r  reaching a state where ¦Õ holds; and formula  r ¦Õ is intended to mean that all terminating executions of r reach a state where ¦Õ holds.
¡¡a pdl formula ¦Õ is satisfiable if there exists a model for ¦Õ-an interpretation where ¦Õ is true. checking satisfiability of a pdl formula is exptime-complete .
¡¡pdl enjoys two properties that are of particular interest for us . the first is the tree model property  which says that every model of a formula can be unwound to a  possibly infinite  tree-shaped model  considering domain elements as nodes and partial functions interpreting actions as edges . the second is the small model property  which says that every satisfiable formula admits a finite model whose size  in particular the numberof domain elements  is at most exponential in the size of the formula itself.
1 reduction to pdl
let s= b1 ... bn e  be a system  where e = a e e1 ¦Äe  is the environmentand bi =  si si1 gi ¦Äi fi  are the available behaviors over e  and let b1 =  s1 s1 ¦Ä1 f1  be the target behavior  over e as well . then  we build a pdl formula ¦µ to check for satisfiability as follows.
¡¡as actions in ¦µ  we have the actions a in e. as atomic propositions  we have:1
  one atomic proposition e for each state e of e  which intuitively denotes that e is in state e;
  one atomic proposition s for each state s of bi  for i ¡Ê {1 ... n}  denoting that bi is in state s;
  atomic propositions fi  for i ¡Ê {1 ...n}  denoting that bi is in a final state;
  atomic propositions execia  for i ¡Ê {1 ...n} and a ¡Ê
a  denoting that a will be executed next by behavior bi;
  one atomic proposition undef denoting that we reached a situation where the scheduler can be left undefined.
¡¡let us now build the formula ¦µ. for representing the transitions of the target behavior b1  we construct a formula ¦Õ1 as the conjunction of  for each s of b1 and e of e :
  for each transition ¦Ä1 such that g e  = true  encoding that the target behavior can do an a-transition  whose guard g is satisfied  by going from state s to state s;
  s ¡Ä e ¡ú  a undef   for each a such that for no
we have  with g e  = true. this takes into account that the target behavior cannot perform an a-transition.
¡¡for representing the transitions of each available behavior bi  we construct a formula ¦Õi as the conjunction of:
  the formula
 
where 
true    for each environment state e 
each s of bi  and each a ¡Ê a. these assertions encode that if the current environmentstate is e and the available behavior bi is in state s and is selected for the execution of an action a  i.e.  execia is true   then for each possible a-transition of bi with its guard true in e and of e  we have a possible a-successor in the models of ¦µ;
  s ¡Ä e ¡Ä execia ¡ú  a false  for each environment state e of e  and each state s of bi such that for no  and e  we have that  with g e  = true and
. this states that if the current environment state is e and bi  whose current state is s  is selected for the execution of a  but a cannot be executed by bi in e  then there is no a-successor in the models of ¦µ;
  s ¡Ä  execia ¡ú  a s  for each state s of bi and each action a. this assertion encodes that if behavior bi is in state s and is not selected for the execution of a  then if a is performed  by some other available behavior   bi does not change state.
¡¡in addition  we have the formula ¦Õadd  of general constraints  obtained as the conjunction of:
  for all pairs of states  and for i ¡Ê {1  ... n}  stating that propositions representing different states of bi are disjoint;
  highlighting the
final states of bi;
  undef ¡ú  a undef   for each action a ¡Ê ¦²  stating that once a situation is reached where undef holds  then undef holds also in all successor situations;
   undef true  for each a ¡Ê
a  denoting that  unless undef is true  if a is performed  then at least one of the available behaviors must be selected for the execution of a;
  execia ¡ú  execja for each   and each a ¡Ê a  stating that only one available behavior
is selected for the execution of a;
  stating that when the target behav-
¡¡ior is in a final state  so are all the available behaviors. finally  we define ¦µ as
init 
where init stands for e1¡Äs1¡Äs1¡Ä¡¤¡¤¡¤¡Äs1n  and represents the initial state of the environment e and of all behaviors bi  including the target   and u  which acts as the
master modality   is used to force to be true in every point of the model. note that u is the only complex program that appears in the pdl formula ¦µ. we can now state our main result.
theorem 1 the pdl formula ¦µ  constructed as above  is satisfiable iff there exists a scheduler program for the system s =  b1 ... bn e  that realizes the target behavior b1.
¡¡proof sketch .  if : pdl has the tree-model property. hence  if ¦µ is satisfiable then it has a model that is tree shaped. each node in this tree can be put in correspondence with a history  and from the truth value assignment of the

figure 1: the painting blocks scheduler program. b1 :  a recharge  means that arm b is in state b1 and action recharged is performed by arm a.
propositionsexecia in the node one can reconstructthe scheduler program.  only if : if a scheduler program that realizes b1 exists  one can use it to build a tree model of ¦µ. 
¡¡observe that the size of ¦µ is polynomially with respect to e  b1 ... bn and b1. hence  from the exptimecompleteness of satisfiability in pdl and theorem 1  we get the following result:
theorem 1 checking the existence of a scheduler program that realizes a target behavior b1 relative to a system s =  b1 ... bn e  is exptime-complete.
¡¡finally  by the finite-model property of pdl  i.e.  if a formula is satisfiable  it is satisfiable in a model that is at most exponential in the size of the formula   we get a systematic procedure for synthesizing the composition:
theorem 1 if there exists a scheduler program that realizes a target behaviorb1 relative to a system  b1 ... bn e   then there exists one that requires a finite number of states. moreover such a finite state program can be extracted from a finite model of ¦µ.
¡¡to end  let us return to our example of section 1. the corresponding pddl formula ¦µblocks  obtained as explained above  has a a finite model from which we can extract the scheduler program depicted in figure 1  after having projected out irrelevant propositions and applied minimization techniques to reduce the number of states . such scheduler realizes the target behavior t by appealing to the two available arms a and b. as one can observe  even in this simplistic scenario  the existence of a scheduler and its corresponding program is far from trivial. for instance  it is critical to make the correct decision on which machine must recharge the tanks at every step-such a choice would depend on how arm b evolves after painting a block. also  the scheduler must be able to terminate both arms in their corresponding final states whenever the target behavior is its final state t1.
1 conclusion
in this paper  we have looked at automatic synthesis of a fully controllable module from a set of partially controllable existing modules that execute in a partially predictable environment. the kind of problem that we dealt with is clearly a form of reactive process synthesis  1; 1 . standard techniques for such problems are based on automata on infinite trees  which however relay on critical steps  such as safra's construction for complementation  that have resisted efficient implementation for a long time . instead  we based our synthesis on a reduction to satisfiability in pdl  with a limited use of the reflexive-transitive-closure operator. such kind of pdl satisfiability shares the same algorithms that are behind the success of the description logic-based reasoning systems used for owl 1 such as fact  racer  and pellet.1 hence  its applicability in our context appears to be quite promising from a practical point of view.
acknowledgments the authors would like to thank daniela berardi  diego calvanese  rick hull  massimo mecella  and maurizio lenzerini for discussion and insights on the issues treated in this paper. the first author was partially supported by the the european fet basic research project fp1 thinking ontologies  tones . the second author was supported by the australian research council and agent oriented software  grant lp1 .
