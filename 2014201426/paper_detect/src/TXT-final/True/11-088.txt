ion as a basis one needs a computer representation  programming  monitoring and debugging system. on top of that must be constructed basic reasoning strategies. specialized representations and reasoning must be provided for common domains such as time  causality  planning  events and states  etc. one also needs linguistic knowledgee.g. syntax and parsing strategies  mophological rules  discourse structures. finally  a dialog system must have expert knowledge of the task domain itself  such as travel planning  medical diagnosis etc. although we intend to implement modules at all these layers  krl-l will only embody the first two. the designer of a dialog system will have to provide specialized knowledge  built in krl  for the rest of the layers. strengths and weaknesses 
a major strength of krl is that it is a self-descriptive system. because of the access compiler and data compaction mechanisms  this self description can be used to actually implement the system itself. this implies that the basis of the system is accessible to the user in a way that has not been true of other knowledge representations since lisp. 
a problem for krl is that our current representation of processes is weak. giving a sequence of instructions which an interpreter should follow in order is only one way of describing a procedure. we believe that it will be possible to develop a notion of factored description in which a procedure is described through multiple perspectives which may combine high level statements about the structure of the process  its results  conditions on various parts  ways it fits into goal structures  etc. we would like to apply the self descriptive power of the language to use the reasoning  matching and problem solving powers of krl as fundamental elements in our tools for designing  building  and working with krl programs. 
some general comments on semantic networks 
gary g. hendrix 
semantic networks come in many varieties  reflecting numerous independent developments. broadly speaking  any representation interlinking nodes with arcs could be called a semantic network  including the structures of quillian  1   simmons  1   norman and rumelhart  1   and hendrix  1 . 
nets differ in their expressive power and in the types of procedures designed to interpret them  but all share the feature that the structure used to encode information serves also as a guide for information retrieval. from a given node  nodes representing closely related objects  physical objects  events  situations  etc.  are found simply by following arcs  either incoming or outgoing  from the node to its neighbors. in this way  a network provides its own semantic cross-reference system. to the extent that the labels on arcs and nodes are meaningful to net-manipulating procedures  they provide semantic guidance to help traverse the net in search of information relevant to a task. 
invited panel-1: bohrow 
1 the problem of generating english expressions for internal symbols illustrates this important feature. given the information  g1 is a man.  and  boston is the hometown of g1   g1 may be expressed as  a boston man.  but how can the relevant information be found  using a network  the search from node g1 is straightforward. without the network's cross-index  much computation may be required. 
the indexing ability of networks is enhanced by introducing partitions  hcndrix  1   which allow parts of the net to be distinguished as if shown in different colors. to solve particular types of problems  only structures of an appropriate  color  are considered. 
a network  like other representations  including procedural code   is a passive structure which must be manipulated by an external agent. thus  a net-based computational system must include both a net and a net manipulator. unlike some systems that force a position on the procedural/declarative tradeoff  networks offer a spectrum of possibilities concerning how much knowledge is to be encoded in the net as opposed to the manipulator. 
for example  consider the statement si: vx p x  =  q x   
this information might be encoded procedurally in the manipulator so that if  for some k  p k  arises in the net  then q k  may be deduced. rieger  1   for example  encoded knowledge procedurally about how to draw inferences from the primitives of conceptual dependency. other workers have developed systems that seek to place maximum knowledge in the net  minimizing knowledge needed in the manipulator. one method for doing this  investigated by kay  1   shapiro  1   hendrix  1   and schubert  1   is to develop network formulations having the full expressive power of the predicate calculus  in addition to the practical advantages of indexing . the logically complete systems can encode statement si directly in the network  allowing them to reason about the statement itself. they may express it in english  or indicate who believes it  or use it in deductions.  procedural encodings are often only able to show q k  given p k .  the manipulator for a logically complete net may be a relatively simple deductive mechanism based on conventional theorem proving  but algorithms for manipulating nets may move beyond conventional theorem proving and use knowledge about procedures. defaults  fuzzy inference and resource-bound computation. 
given that the manipulator does not manipulate itself  moving knowledge from the manipulator to the net makes it available for inspection and is a step toward generalization and introspection. however  such  deproceduralization  generally reduces efficiency. a solution  which may introduce consistency problems  is to encode some knowledge both ways. declarative structures in the net may model procedures  including procedures in the manipulator   their hierarchical decomposition into substeps. the effects they impart when executed  and the relationships among these. the procedures  perhaps compiled from net representation  may be used to answer ground-level questions or to link to motor activities. descriptions of procedures  or of the knowledge they impart  may be used to answer meta questions. they may be manipulated to effectively execute the procedure  to express the sequence of procedural steps in english  to answer questions about the structure of the procedure  and to do planning. 
in building a network system to understand english discourse  all the knowledge about language and translation is typically placed in the language portion of the manipulator. the net  and the question answering portion of the manipulator  provide a model of the domain of discourse  which typically excludes language. but interesting new abilities arise if linguistic information moves to the net. the resolution of definite references is made easier if the discourse context  a linguistic notion  is encoded in the network  grosz. 1 . the processing of elliptical or quantified utterances is made easier by using the network to encode the relationships between syntactic units and the meanings they convey  grosz 1  hendrix 1 . if the lexicon is represented in the net  the system becomes capable of discussing the relationship between concepts and the words that express them. if the parser is represented in the net  the system may answer questions about its structure and about how it parses inputs. 
although semantic networks are a relatively old representation medium  they have been flexible in adapting to new innovations and hold considerable potential for future development 
owl 
william a. martin 
i assume the panel members share my belief that development of a comprehensive methodology for the representation of knowledge which can be embodied in a practical programming language is a key direction for al research at this time. owl. is distinguished from the other efforts in that it is based explicitly and in detail on the syntactic and semantic structure of english. in launching the owt project i determined to take seriously the whorfian hypothesis that a person's language plays a key role in determining his model of the world and thus in structuring his thought  owl is an attempt to explore whether language can also serve as a source of conventions for the development of a computer language. one advantage of this approach is that since owi. is so much like english  the english to owl and owl to english translations can be made more easily than is the case for the other systems. at the same time owl contains many of the same mechanisms of the other systems  so it may achieve this advantage without a corresponding loss   owl  stands for  one world language   reflecting the fact that the conventions of english provide a unifying framework within which each of us develops his thoughts. if this same unifying framework can indeed by transferred to a machine it can perhapsform a basis for achieving wider applicability of independently developed procedures and for absorbing into a computer the knowledge of individual english speaking experts. more immediately  since owt is based on english  our development team is accustomed to settling disputes over what may be equally good representation alternatives by appeal to english. 
the most novel aspects of owl are the structure of the semantic net  hawkinson. 1  and the approach to 
 reference . nodes of the owl semantic net are called  concepts . concepts are written as parenthesized expressions. that is  each node of the owl semantic net is an expression! in translating english to owl we establish a mapping between english sentences  phrases  word senses  and affixes and expressions. eor example  the owl concept corresponding to  the bucket  is  bucket'x the . concepts are stored uniquely  like lisp atoms  in the owt semantic net. each concept has a  reference list   which is like the property list of a lisp atom except that it contains singleton concepts instead of attribute/value pairs. 
the expression for any concept  c  is constructed from two other concepts termed the  genus  and  specializer  of c. 
the general form of the expression is  genus*meta-attribute-abbrcviation specializer . there are seven possible meta-attributes as shown in figure 1. 

invited panel-1: bobrow 1 

meta-altrlbute abbreviation 	example of use 	...definition and description of rusty's trip 


by convention  every concept inherits the information on the reference list of its genus  whenever that is not contradicted by information on the reference list of the concept itself. because of this convention it makes sense to think of concepts as being organized in a hierarchy  under  their genus. the primary role of the special i/er of a concepts. c. is to distinguish c from all other concepts having the same genus and meta-attribute. for example. bull distinguishes  dog*s bull  from all other species of dog. 
figure 1 shows an example of krl  bobrow and winograd  1 . the corresponding owl is in figure 1. 
  travel unit abstract 
               ...travel is the unit name. its category type is abstract  self  an event    ...description of the travel unit itself. 
...event. plane etc. are known units 
	 mode  or plane auto bus   	...cither plane or auto or bus 
... can fill the slot named mode  
 destination  a city    
 visit unit 	sperialization 	... a specific category of social interact ion 
 self  a sociallntcraction   
 visitor  a person   
 visitecs  setof  a person     
 fventl.v1 unit individual 	... a specific event described from two viewpoints 
 self  a visit with visitor - rusty ...the actor is the known unit rusty visilees =  items danny terry   ... items indicates at least 
danny 
 a travel with ... and terry are set elements mode - plane 
	destination= sanfrancisco }    	..sanfranciso is a known unit 
figure 1. krl-1 representation of a trip to san francisco 
...definition of the verb travel 
 travel =  trans.*s travel   
	 subject.: 	person  
 means.:  or plane  auto  bus   
 destination.: city   
...definition of the noun trip in terms of travel 
 trip -  tra el*x 	event-perffctivf-dfvfrbal-noun.   
...definition of the verb visit 
 visit =  interact-sociallvs -visit  
 subject.: person  
 object.: person   
....definition of the noun visit in terms of the verb 
 visit-event =  visitx event-perffctivedeverbal-noun.   
 eventi1 = 
    visitt  and danny  terry  *t rusty *x 
event-perfective-deverbal-noun. *!  no.*s 1   
  travels  means-byt plane  *t 
 destination-tot san-francisco   x 
event-perfextivfdeverbal-noun.   
figure 1. owl representation of a trip to san francisco 
to compare these  one needs to know that in owl   a b c   puts the concepts b and c on the reference list of concept a and has value a.  l = a  gives concept a the label l  which can then be used in referring to it. also  :  is a macro notation with  ci  c1: c1   expanding to  ci   c1*a ci  c1  . while the owl notation is somewhat more cumbersome than the krl  it has the advantage that it can be translated to english for debugging  as was done in  swartout 1 . 
it might also be interesting to compare owl with schank's conceptual dependency networks. figure 1 shows two sentences followed by the networks from  schank 1  and the corresnondim  owl. 
a  the man took a book. 
p o 	r 	- to 	-  	man 
schank: man  -  trans   book  -| 
-- from  - someone 
owl: 	 man*x thf / actt  purposf-to.t  causet 
	  trans.t 	 book*x 	a     t 	 dfstination-to.t 
-self      
b  i gave the man a book. 
p o 	r -- to - man 
schank: i  -  trans  book  -| 
- from  - i 
owl: 	i /  actt  purpose-tot  source. *t 
  trans.t book*x a  t  dest|nation-to.t man*x the       
figure 1. 	comparison of conceptual dependency and owl 
invited panel-1: bobrow 1 because owl exploits relationships of the type explored by the generative semantics branch of linguistics  both  take  and  give  are expressed in terms of trans in owl  just as in conceptual dependency. however  in owl  the differing point of view of the two expressions is retained at least in the owl expression output by the parser. in fact  owl sides with chomsky in determining the logical form of a sentence from its surface structure. we have  however  elected not to use the predicate calculus as a way of expressing ambiguities generally associated with quantifier scope. instead  we take a highly algorithmic view of the process of referent finding. consider the expression   old friend.  this is ambiguous: it can mean either a friend who is old or one with whom we have an old friendship. to get the first meaning   friend  is used to locate the concept friend  the description of friend is then used to locale possible referents of it; these in turn are filtered against the predicate old. to get the second reading   old  and  friend  are used to locate the concept of an old friendship  the description of this concept is then used to locate a referent. in owl. these two senses are expressed as  friend*r old  and  friend*t old  respectively. the ambiguous sentence 
betsy wants sam to read every book that sally wants him to read. 
which has been resolved by quantifier scoping can also be resolved like  old friend . to resolve 
every boy loves a girl on this block. 
we distinguish between  gfrl*x  a*s generic   and  girl*x  a*s particular    the generic and particular readings of  a girl  and again avoid explicit quantifier scoping. 
	predicate 	calculus 
	john 	mccarthy 
q. what are the most important premises underlying your approach to knowledge representation  the critical ideas  and major mechanisms used in your system  
a. at present i am trying to identify the facts about the world that must be used in solving various kinds of problems and the modes of reasoning available to find and validate proposed solutions. an important premise is that the epistemological problem of what knowledge is available to a problem solver with given opportunities to observe and compute is substantially separable from the heuristic problem of how then to decide what to do. in the present stage of research there is no  system  in the sense of a program  although i use our proof-checker to see what the reasoning looks like. it is also a premise  so far verified by experience  that first order logic  i.e. extended predicate calculus  is convenient for expressing these facts about the world. it should be emphasized that first order logic itself does not correspond to a language  it is rather a basic notation within which languages can be developed. thus if one first order language is found inadequate for some purpose  others with 
entirely different characteristics can be tried. 
q. if your representation were being used as a basis for a system which would conduct typed english dialogs with a user about some subject  what aspects would your knowledge representation make easiest; what aspects would best be handled by building additional mechanisms. 
a. predicate calculus representations of the knowledge expressed in english is feasible  but more difficult than has been realized in the past. the problem has nothing to do with the syntax of natural languages but with the dependence of the semantics on context. the best work so far in this direction is richard montague's  english as a formal language  and possibly some of the work of his followers. 
however  this work does not so far take into account much of what has been accomplished in al  and i would do many things differently. 
   while i do not expect to develop a running  advice taker  in the near future  i have thought a lot about it. 
while first order logic formulas in lisp notation would be used to represent some information  most information would be compiled into more purpose-oriented internal forms before use. first order logic might well be used for communicating information. 
none of this has much relation to kowalski's proposals 
 kowalski  1  to use predicate calculus as a programming language. i agree that this can be done  but i have not yet seen anything to convince me that it has many advantages as a programming language. 
q. what problem illustrates what you believe your system is best at  and is difficult for some representations  point out which of your premises and/or ideas make it possible to handle your problem cleanly. 
a. since i don't have a  system   it is difficult to respond precisely to the question  bul here are some things that 1 know how to do that i think will offer difficulty to the  systems  that 1 know about. 
1.  travel agents know what flights are available between two cities but don't know the gates from which the airplanes leave. they have general information about the air travel system . a system should be able to receive this fact  in some notation  on its input and know how to find out how to get somewhere  and know enough to ask the travel agent how to find the gate. 
1. when asked whether president carter is standing or sitting at this moment  a program should say it doesn't know  and when asked to think harder  it should say that more thinking wouldn't help  because  as far as its information goes  he could be doing either. this reply should not be made if the program has direct information about his posture. 
1. when told that mary has the same telephone as mike  that pat knows mike's telephone number  and that pat dialed 
mike's telephone number  the program should assent to the statement that pat dialed mary's telephone number  and express ignorance about whether pat knows mary's telephone number. 
1. when told the missionaries and cannibals problem in english or in first order logic  the program should behave differently hearing it as a puzzle and when hearing it when it believes it is silting by the river in a jungle. in the former case it should reject the possibility of a bridge across the river or a lack of oars for the boat. in the latter case  it should find a solution tentatively rejecting them  bul should admit them as possibilities. it needs entities like  a lack of oars  in order to answer questions like  what's wrong with the boal   and  is that all that is wrong with the boat  . 
my general approach is described in mccarthy and hayes 
 some philosophical problems from the standpoint of artificial intelligence   but most of what i have just said is based on three as yet unpublished memoranda  first order theories of individual concepts    minimal reasoning - a 
way of jumping to conclusions   and  ascribing mental qualities to machines . 
knowledge 	representation 	aspects of production 	systems* 
	allen 	newell 
  this research was supported by the defense advanced research projects 
agency under contract no. f1-c-1 and monitored by the air force office of scientific research. charles forgy. pat langley. john 
mcdermott  kamesh ramakrishna  and mike rychener share credit for the ideas here  but are not to blame for my expression of them. 
production system architectures  psas  exhibit too much diversity  both of structure and of purpose  to be considered as a whole. one class of architectures are described here  with roots in human problem solving  newell & simon  1  and cognitive architecture  klahr & wallace  1; newell  1   but under exploration as a general architecture for intelligent systems  rychener  1; rychener & newell  1 . a current realization is a ps language called ops  forgy & mcdermott  1   an outgrowth of several earlier cmu psas. 
basic architecture  except for input/output  
1. working memory holds a set of data elements  which arc list structures on atoms. it is a temporary memory  used for focussing attention  holding context  and communicating operands and results. 

invited panel-1: bobrow 1 

1. productions are condition-action pairs. the conditions are forms on working memory elements; the actions are unconditional sequences of additions to working memory  list operations on working memory elements  and constructions of new productions. 
1. production memory hold the set of productions. it is the only permanent memory  i.e.  all long term knowledge is stored as productions. 
1. the recognition-act cycle repeaiedly evokes a single satisfied production  thus producing a serial stream of actions. the cycle is taken as a basic cycle in a machine  so that many of them may be expected to occur in performing a task. 
1. conflict resolution is the selection within each recognizeact cycle of the production to evoke from the set of satisfied productions. it is not a locus of intelligent selection  but realizes basic system features  such as attention focussing  interruptibihty  instability control  mcdermott & forgy  1 . 
1. recognition match. under suitable match algorithms and conflict resolution rules  the cycle time is essentially independent of the sizes of production memory and working memory  although bilinear under the naive algorithm . the cycle time does depend on the actions taken by the evoked production  forgy  1; mcdermott  newell & moore  1 . 
such a match can be called a  recognition match   since externally the action appears to be  immediately recognized  rather than the result of extended computation. it is a necessary characteristic of the architecture. 
how is knowledge encoded  
1. no syntactic or structural rules  other than list structuring  govern the encoding of knowledge in data elements.  a systematic bias toward prefixing does come from the ops match  since it allows segment variables only for tails of data elements . 
1. homogeneous encoding: all knowledge in the ps is encoded in the same way  as productions. 
1. grain size: the production is the largest structural unit of knowledge recognized by the architecture. it may be taken as a conjunction of assertions  each action of the action side producing a new data element that may be used independently by other productions . larger units of data are to be composed of sets of productions  linked together implicitly through their conditions. 
lo.pss of any complexity appear to require a goal structure. goals are data elements and form a goal-subgoal means-ends network  by linkages through conditions  as per 1 . further experience might reveal alternatives to this organization  but probably not. 
what are the key features of the read  access  processes  
ll.the access mechanism of the psa representation is the recognition itself. its power is determined by the power of a recognition match. there is no adequate characterization of this power. the current logic admits: variables  negated elements  occurrence conditions  multiple conditions applied to the same element  and a single segment variable. indirect accessing occurs through a sequence of cycles. 
1.wide-band access: the totality of the knowledge is potentially available at any cycle  i.e.  all satisfied productions are candidates at each cycle .  note however that not all knowledge will be accessed when appropriate  since the access relationship is limited  per 1.  
1. no structural separations are enforced  eg  for contexts  for separate worlds  for protection .  this is a consequence of 1  but is worth stating separately.  
what are the key properties of the write  augmentation  processes  
1. simple addition. knowledge augmentation is achieved by creating productions and simply adding them to the set of productions in production memory. 
an important advance has been to attain conflict resolution schemes that admit this simple rule and do not require positioning the new production vis a vis existing productions  thus requring knowledge of the existing set  mcdermott & forgy  1 . 
1. the addition of any knowledge requires the specification of an access path  since the production is a condition-action pair. 
the power of the match governs the access relations that can be specified. thus the simple addition referred to in 1 is not as simple as possible  eg  simply a bin of knowledge items without any indexing ; the simplicity arises from having to attend only to the local context of the knowledge to be added and its expected use  not to its relationships with other knowledge. 
what about strengths and limitations  
1. psas are an interesting candidate for the architecture for human cognition. this is a strength for an architecture for general intelligence only if the  current  architecture can be refined to incorporate human solutions to obtaining general intelligence. 
1. psas are adequate  and comparable to other al langages  for programming the range of tasks that al reasoning programs have investigated  from heuristic search to the blocks world to simple natural language  rychener  1 .  this statement is appropriate here because doubts have been expressed on this score  psas seeming to be useful only for low level processing.  
1. viewed simply as an architecture to do a circumscribed al task  there seems no reason to use a psa unless  1  extremely high conditionally exists  which is what the wide-band access is responsive to  and  1  this access is too irregular to be realized by table-lookup schemes.  this assumes psas realized within current machine architectures where the recognition-act cycle imposes some cost.  
1.the greatest limitations lie not in what other representations already do well  but in attaining functions that seem to be latent in the current architecture  e.g.  the use of wide-band access to obtain serendipitous access of diverse knowledge  or the full exploitation of simple addition of productions by appropriate debugging and post-adaptation. 
conceptual dependency  
and knowledge structures 
roger schank 
these are the important premises underlying the knowledge representation theory comprised of conceptual dependency  scripts  plans  goals and themes and other knowledge structures  hence cd/ks . 
invited panel-1: bobrow 1 1. a knowledge representation  kr  should be language-free: that is  it should reflect the important properties of relationships inherent in the world rather than those inherent in the constructor of the kr's native language. 
the same event . one of the consequences of this premise is primitive actions  states  objects  etc. 
1. a kr should facilitate inference of implicit facts and events. cd/ks provides a canonical form for the representation of events and the intentions that motivate those events. stored with prototypical canonical forms are rules about reasonable inferences that can be made when those forms are recognized. in this way the representational structures in cd/ks control inference generation. 
1. a kr must provide standard event sequences  scripts and named plans in cd/ks  to match input events against so as to determine implicit events. the unique canonical representation used in cd/ks allows us to provide these standard event sequences with easily specificable recognition processes. if we had alternative representational possibilities in the same system we would have difficulty recognizing instances of inputs that triggered or matched our standard event sequences. 
1. a kr should provide different depths of detail in representation in a standardized way. in cd/ks there are those clearly specificable levels of representation: the intentional or planning level  the macro-event level for describing actions superficially  and the micro-cd level of describing the details that make up events. standard event sequences can work at each of these levels  but the distinction of what input triggers what level must be carefully maintained. 
1. a kr should facilitiate the process of mapping from a natural language into it and back out of it into a natural language. no information should be lost in this process  and the process itself should exploit the properties of the kr. any parsing system that fails to exploit the properties of the kr is losing available valuable information. 
1. a kr must be predictive. it must have available to it knowledge of standard packages of goals and their realization such that it can predict future inputs on the basis of past inputs. it must also have the ability to switch to bottom-up mode when predictions fail. 
ii. 
at the moment our english input and output system deals with newspaper stories. it handles all facets of the problem when the stories are relatively simple; that is we do question-answering  summary  paraphrase and translation. we are currently building programs to handle more complex domains  but it is clear that the problem at the moment is simply understanding what knowledge is being utilized in complex stories about complex domains. similarly in a conversational system  the problem is knowing what knowledge people have about the rules of conversation. 
our representation facilitates: 
 1  establishing causal connections 
because there are only a small number of types of connections and the total combination of primitive actions connected according to those types is still rather small; 
 1  recognition of intentionality behind actions 
this comes from the system of plans that underlie each action. it is thus possible to infer the plan that motivated a 
given event given some known goal of the actor of that event;  1  filling in implicit information 
our representational system has a system of slots and default fillers of those slots. thus  our system knows when it doesn't know something. 
one problem that we have been particularly concerned with lately is the construction of an adequate representational system for conversation. only some of the above mechanisms will be helpful in conversation. one of the things we need  and do not have at present  is an adequate model for the motivations of people when in interaction with other people. how much is appropriate to say when  how do you recognize the cues inherent in conversation that tell about what is appropriate in the conversation itself rather than those that just input event information  how do we represent such things  
hi. 
our system is quite good at inference  paraphrase  and translation into other languages. the last two are products of premises 1 and 1 in i. when the representation is language-free and unique  translation and paraphrase are facilitated. 
the core of the language understanding problem is inference. the system of primitive actions helped our understanding of the inference problem as illustrated by the margie system. scripts solved the inference cutoff problem inherent in margie and helped us to produce sam. sam is a reasonable model of story understanding and illustrates the power of cd/ks. the premise of predictive understanding and the predictive nature of cd/ks are what make sam tick. thus sam has problems with unexpected inputs. one of the serious problems for us then  is the ability to shift to bottom up processing when predictions fail. this is something that pam  a program that exploits goal and plan-based predictions  is intended to remedy. still  there are probably times when even these will fail. 1 don't know how we will handle such instances  but i do know that human processors have a tough time with them also. 
knowledge representation semantics 
brian c. smith 
within the artificial intelligence community there are numerous research projects involved in the construction of knowledge representation languages in addition to those represented here on this panel. each is trying to provide a congenial formalism  whose structure will both aid in the process of initially representing knowledge within an ai system  and also help in understanding the structures that result. although many of these efforts have met with a certain degree of success  none has taken firm hold. instead we are confronted with a large number of complex systems  with different structures  dealing with different issues  which 
are difficult to understand and difficult to compare. 
krs-i 	 smith. 	1 . 	a 	formal 	system 	of 	knowledge 
representation semantics  is an initial attempt to provide a 
coherent intellectual framework within which to understand systems of knowledge representation - a way to answer the question  what does all this mechanism mean  . the structure of krs derives from a consideration of what the act of representation means within the context of building computational models of intelligence. because it is being developed out of an interest not only in knowledge but also in active reasoning processes  the form of the semantic foundation that it provides differs from traditional theories of semantics. instead of being interested in issues such as completeness  soundness  decidability  etc.  krs instead provides a formal structure in which to talk about such issues as memory chunking  locality of access  focus of description  abstractions  appropriateness of interpretive belief  etc. 
   specifically  krs rejects the following three assumptions  that have traditionally been held as axioms of any formal theory of meaning: 

invited panel-1: bobrow 1 

1. the idea that statements or expressions by themselves have meaning. instead krs formalizes the idea that  meaning  is something which makes sense only in terms of an active process interpreting a system of symbols. 
1. the notion that  truth  is appropriate as a primitive semantic concept. this is not at all to say that the concept of truth is not important  but instead to reject its formalization as a binary and primitive notion  and also to reject the idea that deciding that truth of a sentence is the crucial aspect of uncovering its meaning. the truthfulness of a statement is instead seen to be a complex  subtle  contextual  and often useful description of that statement  which is neither primitive within the semantic theory  nor necessarily expressible in terms of the atomic symbols  true  and  false . 
1. the assumption that it is in general possible or appropriate to say anything absolute or certain about the structure of the world being represented. what is considered to be important instead is what people or processes believe; krs considers the only question that can be asked by a process to be what it believes  and also what   it believes that another process believes. 
the overall framework of krs-l is a formalization of 1  levels'* or viewpoints from which to understand a symbolic description  or piece of representational structure: 
1. a  message  level  which deals with the words or communication string on its own  without reference to the structure of the process that sent or received it 
1. an  intermediate  level  embodying what is traditionally thought of as the syntactic structure of a message. 
1. a  memory  level  formalizing notions of organization and accessibility. 
1. a  belief  level  dealing with the active conclusions and inferences that an interpretive process will come to  based both on its previous beliefs and goals  and also on the structure of the memory level. this can be thought of as short term memory  although part of krs-l is an account of how the issues dealt with at this level differ substantially from those of the memory level. 
1. an  external  level  capturing the notion that a representation is a representation of something ~ this is the level which the interpretive process believes that the memory structures represent. 
in addition to these levels  krs also gives a precise account of 
 layers of meta-description  to characterize the relationship that holds between two descriptions when one describes the other. the .substance of krs is a theory of the structure of  and the relationships between  these levels and layers  and of the role that an interpretive process can play within such a 
framework.  note that  level  and  layer  are technical words naming two orthogonal dimensions of the semantic framework.  
krs-l  the current version of the theory  deals only with the declarative structure of representational languages; although it identifies the place that an interpretive process must play in such a scheme  indeed formalizes the claim that you cannot understand the meaning of a symbol without understanding the processes that interpret that symbol   no attempt has been made to capture or describe the actual processing structures of an interpretive process. this is the direction towards which further work will be directed. 
krs and natural language semantics there is no doubt that the structure of natural language provides significant evidence of the structure of human thought. however krs is not specifically designed to be a theory of english semantics  for two reasons: 
1. krs-l is an attempt to be a theory of the semantics of computational knowledge representation languages  not of knowledge representation in the abstract. hence the current objects of study are languages such as krl  owl  semantic nets  etc.  rather than english 
1. as opposed to the philosophy of owl  there is no effort in krs to account for specifically linguistic behaviour. for example  the goal of krs is to make clean and precise all distinctions which seem cogent in identifying and solving subtle problems in terms of reasoning. just because such a distinction is not apparent in the structure of english sentences will not be taken as any reason not to formalize the distinction. 
krs and a description of the interpretive process: 
one of the motivations for building a structured model of knowledge representation semantics is to provide a framework within which to describe the behaviour of an interpretive process. in traditional computer languages such as lisp  there is a well-defined and precise notion of evaluation which the interpreter is carefully designed to implement. however as we build more complex description systems  this strict model of evaluation begins to break down. for example  consider a system such as macsyma  moses  1 ; one of the powers of that system is an ability to reason with symbolic descriptions  such as the  integral of x   without evaluating them. 
krs is designed to provide a model of an interpretive process; this model is the same as its characterization of any reasoning system. for example: suppose that an ai program is reasoning about a set of blocks on the top of a table. suppose also that this program is  connected  to that table top by a video camera and robotic arm. as the program goes about its business  it builds up internal memory representations about the state of the world on top of the table  develops hypotheses about possible actions that it might take  explores what it thinks the consequences of potential actions would be  etc. every so often  when it decides that it actually wants to do something  it reaches out and moves a block  or in some way changes the world about which it is reasoning. 
   one can draw a strong analogy between this program  and the interpreter that is running this program. in many ways their operations are very similar  except that where the domain of the blocks program is the table top  the domain of the interpreter is the program and representational structure of the blocks program. one can view it is a double-layered system  with the blocks program looking at the table and the interpreter looking at the blocks program. where the blocks program reasons about a block partly by having a description of that block  so the interpreter can be seen to reason about the description of the block by having a description of of this description. in other words  the krs characterization of intepretive process is of a reasoning system working at the meta layer. 
knowledge representation in aimds and its use in believer 
n. s. sridharan 
changing worlds 
most representation systems have shied away from dealing with updating of information and have concentrated on reasoning with ..gjyen. collections of facts and general 
knowledge  the strength of the mds and aimds systems is in having a systematic way of updating information. this allows one to adopt a  hypothesize and revise  paradigm in processing information in place of the more common search  methods that involve backtracking. 

invited panel-1: bobrow 1 

premises 
