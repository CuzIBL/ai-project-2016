 
in this paper we present a semantic theory of abstractions based on viewing abstractions as model level mappings. this theory captures important aspects of abstractions not captured in the syntactic theory of abstractions presented by giunchiglia and walsh . instead of viewing abstractions as syntactic mappings  we view abstraction as a two step process: first  the intended domain model is abstracted and then a set of  abstract  formulas is constructed to capture the abstracted domain model. viewing and justifying abstractions as model level mappings is both natural and insightful. this basic theory yields abstractions that are weaker than the base theory. we show that abstractions that are stronger than the base theory are model level mappings under certain simplifying assumptions. we provide a 
precise characterization of the abstract theory that exactly implements an intended abstraction  and show that this theory  while being axiomatizable  is not always finitely axiomatizable. we present an algorithm that automatically constructs the strongest abstract theory that implements the intended abstraction. 
1 	introduction 
abstractions and approximations are pervasive in human common-sense reasoning and problem-solving. abstractions have been used in a variety of problemsolving settings including planning  sacerdoti  1   theorem proving  plaisted  1   diagnosis  davis  1; genesereth  1; struss  1   compositional modeling  falkenhainer and forbus  1   constraint satisfaction  ellman  1   and automatic programming  lowry  1 . until recently there has been no unifying account of these disparate forms of abstractions. however  in the last few years  there has been an explosion of interest in understanding the underlying principles of abstractions and approximations  ellman  1; lowry  1; van baalen  1 . 
　a comprehensive theory of the principles underlying abstractions is useful for a number of reasons. such a 
1 	automated reasoning levy research.att.com 
theory can provide the means for clearly understanding the different types of abstractions and approximations used in past work. it can provide semantic and computational justifications for using abstractions and approximations. furthermore  such justifications can be used to automatically construct useful abstractions and approximations. finally  an understanding of different abstractions within a common framework can allow the transfer of techniques between disparate domains. 
　recently  giunchiglia and walsh have presented an elegant theory of abstractions that unifies past work and provides a vocabulary to discuss different types of abstractions  giunchiglia and walsh  1 . their theory characterizes abstractions as syntactic mappings between formulas of formal systems. they classify abstractions according to whether the set of theorems of the abstract theory are a subset  superset  or equal to the set of theorems of the base theory  td  ti  and tc abstractions  respectively . their theory is very good at capturing an important aspect of many abstractions  viz.  many abstractions result directly from syntactically manipulating formulas. moreover  problem solvers ultimately reason by applying inference rules to formulas  and hence understanding the properties of abstractions as mappings between formulas is essential. 
　however  viewing abstractions as syntactic mappings captures only one aspect of abstractions. consider the following example. 
example 1 predicate abstractions  plaisted  1; 
tenenberg  1  are a class of abstractions based on the observation that the distinctions between a set of predicates p1 ... pn in a theory are often irrelevant. an abstract theory can be constructed by replacing all occurrences of the pi's in the base theory by a single abstract predicate p. for example  consider the following base theory: 
japanesecar x  =  car x  
	europeancar x  	=  	car x  	 1  
toyota x  =  japanesecar x  
bmw x  =  europeancar x  
the 	distinction 	between 	japanesecar 	and 
europeancar is often irrelevant  e.g.  when trying to answer a query car a    and therefore these predicates can be replaced by foreigncar  yielding the following simpler abstract theory: 
foreigncar x  = ＊ car x  
	toyota x  =  foreigncar x  	 1  
bmw x  =  foreigncar x  
however  suppose the base theory also includes the following: 
	europeancar x  	=  	fast x  	 1  
japanesecar x  =  reliable x  
applying the same mapping to axioms 1 would result in the following: 
	foreigncar x  	=  	fast x  	 1  
	foreigncar x  	=  	reliable x  	 1  
however  adding these axioms to the axioms in  1  leads to false proofs  plaisted  1   which may be undesirable. for example  one can infer that toyotas are fast  and bmws are reliable-inferences not sanctioned by the base theory. 
　the syntactic theory of abstractions does distinguish between abstractions that yield false proofs  ti  and those that don't  td . however  it gives no guidance in comparing td abstractions to determine which is more natural. for example  the axioms in  1  and  1   when used independently  will not yield false proofs  but the former is more natural  considering the intended interpretation of foreigncar.1 nor does the syntactic theory tell us how to construct the strongest such abstraction. for example  we will see that adding the axiom 
     foreigncar x  =   fast{x  v reliable x    1  to  1  yields the strongest theory that removes predicates japanesecar and europeancar and still does not admit false proofs. d 
　the fundamental shortcoming of the syntactic theory is that while it captures the final result of an abstraction  it does not capture the underlying justification that leads to the abstraction. in this paper we present a semantic theory of abstractions that addresses this shortcoming. our theory is based on the idea that knowledge representation involves using formulas to capture an intended domain model. from this perspective  we argue that an abstraction should be performed in two steps: first  the intended domain model is abstracted and then a set of  abstract  formulas is constructed to capture the abstracted domain model. hence  we argue that the decision of what to abstract is made at the model level  using knowledge about relevant aspects of the domain   with the syntactic transformation being justified by this decision. in our example  the intended abstraction to the domain model is to replace the relations denoted by japanesecar and europeancar by one relation representing their union  denoted by foreigncar. as mentioned earlier  the strongest theory that implements this intended abstraction consists of the axioms in  1  and  1 . 
lnote that  since the axioms in  1  and  1  are mutually 
disjoint  the preorder c defined in  giunchiglia and walsh  1  provides no help in selecting between the two options. 
　we introduce a class of model increasing  mi  abstractions  a strict subset of td abstractions. like td abstractions  mi abstractions yield no false proofs. however  they have additional natural properties such as compositionality. we show that the abstract theory that 
precisely implements the intended model level abstraction  is exactly the strongest mi abstraction of a base theory. we show that if the base theory is axiomatizable  then so is its strongest mi abstraction. we present a procedure to automatically construct the strongest mi abstraction. our work generalizes tenenberg's treatment of predicate abstractions  tenenberg  1   and we disprove his conjecture that the predicate abstraction of a finite theory is always finitely axiomatizable. 
　abstractions that admit false proofs are commonly used to speed up problem solving by guiding search  e.g.  abstrips  sacerdoti  1 . we show that all such abstractions can be viewed as mi abstractions in conjunction with a set of simplifying assumptions. for example  in abstrips  we first make the simplifying assumption that a predicate of lower criticality can always be achieved without affecting predicates of higher criticality  and then we construct an mi abstraction by dropping the appropriate preconditions. this formalization is insightful because it shows that an abstraction will yield false proofs only when the simplifying assumption is violated. this enables us to evaluate the utility of an abstraction depending on the reliability of the simplifying assumption. 
1 abstractions as model mappings 
our theory of abstractions applies to any language with a declarative semantics  e.g.  propositional logic  constraint languages  first-order logic  modal logic. the declarative semantics of such languages is provided by interpretations of the language and the the notion of satisfaction. an interpretation  /  is a model of a set of sentences  e   denoted / i= e  if and only if / satisfies each sentence in the set. a set of sentences t1 entails another set of sentences t1  denoted t1 i= t1  if and only if every model of t1 is a model of t1. 
1 	model increasing abstractions 
let tbase and tabs  be sets of sentences in languages lbase and labt   respectively. what does it mean for tabs to be an abstraction of t base  if lbase and labs are the same language  natural definitions are possible  e.g.  tbase |= tabs is one such option . however  if lbata and labs ate different  such a direct comparison is not possible since l base and labs have no common interpretations. a comparison is possible only if there is a way of translating between the interpretations of the two languages. such a translation can be specified by an abstraction mapping  section 1 shows how to formally specify n : 
it : interpretations lba$e  -  interpretations labs   1  
the idea is that tt is a model level specification of how the interpretations of l base are to be abstracted to interpretations of labs   recall that we view abstractions as consisting of two steps: first  the intended domain 
	nayak and levy 	1 


1 	automated reasoning 

to use an mi abstraction of the base theory  under the simplifying assumption that different literals in a clause share no common variables  e.g.  a clause p x  v q x  is revised to the stronger clause p y  v q z . an mi abstraction of the revised theory is constructed using a ground abstraction that preserves all possible unifications. 
　in the above examples  the simplifying assumption is added to the base theory by simply adding in additional axioms. however  there are common situations in which the simplifying assumption is inconsistent with the base theory  so that merely adding in the simplify-
ing assumption makes the theory inconsistent. in such cases  adding a simplifying assumption to a base theory is better viewed as a belief revision operation: the base theory is revised to make sure that the simplifying assumption holds  while ensuring that the revised theory is consistent. the revised theory is then abstracted. 
example 1 most approximations in engineering involve simplifying assumptions that contradict the base theory. for example  consider two railroad cars connected by a linkage. say that the base theory describing the linkage models it as a spring with a very large spring constant  i.e.  as a very stiff spring . it is common to assume that such linkages are rigid  i.e.  the spring constant is infinite. clearly  the simplifying assumption that the spring constant is infinite is inconsistent with the base theory; the base theory must be revised by retracting the axiom specifying the large spring constant of the linkage  and then adding in the simplifying assumption. the revised theory can now be abstracted by combining the two railroad cars into a single  composite rigid body. the fitting approximations in  weld  1  are all of this form. ＆ 
　viewing abstractions as a combination of a set of simplifying assumptions and an mi abstraction has two key advantages. first  the simplifying assumptions underlying the abstraction are made explicit  and therefore can be used in reasoning  as has been done in compositional modeling  falkenhainer and forbus  1; iwasaki and levy  1  and diagnosis  davis  1; nayak  1b; struss  1 . second  we can show that an abstraction will yield false proofs only if the simplifying assumptions are inappropriate. in particular  a simple corollary of proposition 1 is that if an abstraction of a consistent base theory is inconsistent then it is because the simplifying assumptions are inconsistent with the base theory. this enables us to evaluate the utility of an abstraction depending on the reliability of the simplifying assumption. 
1 	abstracting first-order theories 
the semantic account of abstractions developed thus far applies to arbitrary languages with a declarative semantics  and to arbitrary model level abstraction mappings 1r. in this section we restrict our attention to firstorder languages  and show how abstraction mappings can be specified using interpretation mappings  enderton  1 . we use this development to precisely characterize the strongest mi abstraction of a base theory. we 
	nayak and levy 	1 

1 	automated reasoning 


	nayak and levy 	1 

that an abstraction is a model level mapping of the original theory in conjunction with a simplifying assumption. this difference is made clearer by the following comparison of td abstractions to mi abstractions. 
　since for every theorem of an mi abstraction    is in the base theory  all mi abstractions are td abstractions. however  mi abstractions are a strict subset of td abstractions. to see this  consider a base language with propositions p and q  and an abstract language with proposition r. consider a syntactic mapping that maps p to r and q to  the base theories and b1 = and the abstract theories 
         . clearly  a1 and a1 are td abstractions of b1 and b1  respectively. however   is inconsistent  while  is not. hence  it follows that this td abstraction is not compositional  and hence not an mi abstraction. 
　it is worth noting that the strongest mi abstraction of t base is not  in general  a tc abstraction. it is tc abstraction only if there is also an abstraction mapping p in the opposite direction  e.g.  the mappings between polar coordinates and rectilinear coordinates. in this latter case  the base and abstract theories are equivalent  and there is really no model level abstraction going on. however  a switch from one theory to another may still be motivated by computational considerations. 
　levy  has outlined another method for constructing mi abstractions. his method is based on identifying sentences in t base that are independent of the abstraction  and hence can be syntactically abstracted. intuitively  sentences of the form   or sentences that entail sentences of the form   are independent  and such sentences can be abstracted to a. identifying independent sentences can often be done easily  resulting in an efficient algorithm for constructing abstract theories. our theory of abstractions raises several directions for future work. first  it raises the question of finding restricted  but useful  settings within which the strongest mi abstraction is finitely axiomatizable and can be constructed efficiently. when the strongest mi abstraction cannot be constructed efficiently  an important issue is finding methods for constructing weaker  though still useful  mi abstractions. second  our theory of abstractions is only a logical account of the process  and does not address the issue of the computational benefits of using abstractions. a better understanding of when model level abstractions lead to computational savings is needed. third  we are developing probabilistic methods for reasoning about how likely it is that a simplifying assumption holds. 
