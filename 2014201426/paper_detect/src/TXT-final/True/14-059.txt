 
we describe an expert system that has been applied to the task of a p p l i c a t i o n design. users supply the system with problem s p e c i f i c a t i o n s   such as the required output data  and the system produces a graphic representation of the completed a p p l i c a t i o n in the form of a flow diagram. the application design task has forced us to consider two important issues in expert system a r c h i t e c t u r e : constraint processing and the e x p l i c i t representation of control flow. the r e s u l t i n g knowledge representation and control logic are discussed. 
	i 	introduction 
　　　computers are commonly used in a wide v a r i e t y of a p p l i c a t i o n design areas. building the a p p l i c a t i o n programs  however  is often a d i f f i c u l t and f r u s t r a t i n g task requiring the blending of both domain-specific and computer-specific expertise. it is frequently the case that the a p p l i c a t i o n problem expert is not a computer expert and must seek the help of appropriate computer professionals whose a v a i l a b i l i t y and s k i l l s may be l i m i t e d . this problem has received considerable a t t e n t i o n and work is proceeding along several paths in pursuit of an e f f e c t i v e s o l u t i o n  1  . 
　　　this paper presents an expert system which assists in preparing a well-formed d e f i n i t i o n of a desired a p p l i c a t i o n . this d e f i n i t i o n is presented in the form of a program flow chart showing the proper configuration of input devices  data processing functions  and output devices needed to produce the desired r e s u l t . the flow chart is developed from a knowledge base which includes representations of data transformations v a l i d w i t h i n the problem domain. for example  if the problem domain is p a y r o l l applications a transformation r e l a t i n g gr1ss pay to net pay would be represented in the knowledge base and would include references to data processing functions required to enact the transformation. 
　　　a notable feature of a p p l i c a t i o n d e f i n i t i o n is the dual nature of the expertise required; an e f f e c t i v e consultant must have knowledge of both the s p e c i f i c a p p l i c a t i o n domain   e . g .   p a y r o l l applications  and of more general a p p l i c a t i o n design p r i n c i p l e s . several i n t e r e s t i n g problems in expert system architecture have been encountered  especially in the areas of constraint processing and control flow. a discussion of these areas comprises the bulk of t h i s paper. we begin  however  with an elaboration of the task performed and a discussion of our choice of knowledge representation and constraint a r c h i t e c t u r e . 
i the task 
　　　figure 1 shows a flow diagram of a simple p a y r o l l a p p l i c a t i o n . the task of the system is to produce t h i s chart from an i n i t i a l statement of the desired program outputs. 
the system is expected to select appropriate devices and processing functions for the a p p l i c a t i o n and to i n f e r or obtain values for relevant application parameters   e . g .   f i l e names . the d r i v i n g mechanism for t h i s process is a search to find a sequence of known data transformations   e . g .   gross-pay to net-pay  which begins with device-available data and ends with the desired output data. transformation descriptions include knowledge of the processing functions required to e f f e c t the transformation. these functions may themselves introduce a d d i t i o n a l data elements i n t o the flow diagram. processing each element of the flow diagram u n t i l there are no unambiguous references to other elements w i l l produce a complete application d e s c r i p t i o n . 
　　　the consultation dialog involves the user in two ways. f i r s t   there is the requirement to obtain non-inferrable parameters such as application-name. second  the system e n l i s t s the user in the selection of s p e c i f i c elements of the application flow diagram whenever the a p p l i c a t i o n d e f i n i t i o n is inadequately constrained to permit an unambiguous  automatic s e l e c t i o n . this part of the consultation may be conducted at several l e v e l s   ranging from d i r e c t i n q u i r y for the i d e n t i t y of the element to the a c q u i s i t i o n of a p p l i c a t i o n constraints that may themselves i m p l i c i t l y permit the disambiguation of the element in question  1 i. 
i l l the knowledge base 
　　　the primary knowledge in the system is organized i n t o frame-like   1   1   objects w i t h a t t r i b u t e s . each element of the flow diagram is represented as a p a r t i c u l a r frame in the knowledge 
1 
base. specialization hierarchies   1  are employed and a r i c h set of i n t e r - o b j e c t references e x i s t s . the system has been programmed in apl and uses a knowledge e d i t o r to b u i l d the objects  called 
entities  	and t h e i r a t t r i b u t e descriptions 	 called slots . 
transformation - summary knowledge of the possible data-to-data transformations. tranformations reference many other elements in the knowledge base including data  what is transformed to what   
device 	 for input and output transformations   and 
function  the process that does the transformation . as an example  a data-access transformation could be defined to r e t r i e v e stored information. the p a r t i c u l a r function employed might depend on the f i l e structure of the data to be accessed. m u l t i p l e f i l e structures could then lead to a s p e c i a l i z a t i o n hierarchy of data-access transformations. 
　　　the flow diagram r e s u l t i n g from a p a r t i c u l a r consultation is represented in the same formalism and data structures as the s t a t i c knowledge i n i t i a l l y available to the system.  the i n i t i a l knowledge structure is called the s t a t i c knowledge base while the r e s u l t s of a p a r t i c u l a r consultation are called the dynamic knowledge base. as elements of the diagram are created they are associated w i t h the most specialized frame description appropriate to that element. for example  a data-access transformation element may be created without yet knowing which actual access transformation w i l l be employed. the constraint expression causing the creation is then re-evaluated in the context of any dynamically created data-access transformation elements. the resolution of constrained e n t i t y references  which is dependent on both the e n t i t y context for the resolution and on the dynamic state of the knowledge structure  has presented several challenges to the constraint resolution a r c h i t e c t u r e . 
iv the constraint architecture 
　　　recent work has highlighted the role of constraints in processing frame or semantic network knowledge.  see  for example    1   .   constraint processing has generally been used to l i m i t search space  p r i n c i p a l l y by applying constraints to a s t a t i c c o l l e c t i o n of objects with the hope of finding only a subset which meet the constraints. the constraints to be applied come from several sources  the most common of which are the knowledge base i t s e l f and values for s p e c i f i c parameters generated w i t h i n the consultation session. 

　　　the knowledge base includes the four types of e n t i t i e s described below. 
data - the domain s p e c i f i c data processed by the applications of i n t e r e s t . 
device - input  output  and storage devices which may be used in the a p p l i c a t i o n . devices are related to the data they can access or produce.  file data  for example  can only be referenced by a p a r t i c u l a r class of devices.  
function - existing  pre-programmed  processing routines which operate on data relevent to the problem domain. functions reference the data they process and produce. 
　　　constraint processing is employed in our system to control the traversal of the knowledge structures and the selection of e n t i t i e s for i n c l u s i o n in the flow diagram. 
 constraints are used in b u i l d i n g s p e c i a l i z a t i o n hierarchies  and in specifying references from one e n t i t y to another. it is commonly found that these inter-connections between e n t i t i e s w i t h i n s p e c i a l i z a t i o n hierarchies become more constrained as one traverses the s p e c i a l i z a t i o n paths; t h i s permits s p e c i a l i z a t i o n traversal over one type of object to i m p l i c i t l y constrain selection of a related o b j e c t .  knowing the data to be obtained  for example  w i l l often constrain the choice of 
access mechanism.  an element admitted to the flow diagram may be associated w i t h any l e v e l in a 
s p e c i a l i z a t i o n hierarchy; subsequent discovery of 
1 

additional 	constraints 	 either 	from 	user 
interaction or specialization of a related element  then permits association of this element with increasingly more specialized entities in the knowledge base. in general  a consultation is complete when a l l elements of the flow diagram are associated with leaves in the specialization hierarchies  and a l l references made by these elements have been admitted to the diagram. 
　　　the application design task required an extension to the concept of constraint processing as a static selection process. constrained entity references in the static knowledge base must produce instantiation of the appropreiate objects in the dynamic knowledge base  and cause the proper inter-entity references to be created. while it is possible for a single static reference to produce several dynamic instantiations  several instances a particular processing function  for example  it may also be the case that a suitable dynamic object already exixts and must be found when the constraining reference is resolved. since correct inter-connection is fundamental to the flow diagram problem  a mechanism was needed not only to be able to state the general interconnection constraints in the static knowledge base  but also to instantiate the specific interconnections of the dynamically created flow diagram. this mechanism is described below. 

with slotl 
is this-entity-name 
then the processing of these constraints in the static knowledge base should provide a general limitation of acceptable candidates while processing these constraints in the dynamic environment must force the specific interconnection references. to accomplish this  two architectural principles were established. 
1. references from one entity to another must cause the creation of a new dynamic object if the reference is from an existing dynamic object and the resolution is to a static object. 
1. when processing a constrained reference to a dynamic object  the constraints are imposed on the target  constrained  slot. 
principle  1  causes the creation of the elements of the flow diagram  once an i n i t i a l dynamic entity has been created. consider the case where an instance of entity a has been created and slotl of entity a is being evaluated. its resolution w i l l be a reference to entity b in the static knowledge base which will cause the creation of a dynamic instance of entity b  by principle  1 . the constraint expression in slotl of a  which further constrains slot1 of b to contain a pointer back to 
a  is now imposed on slot1 of entity b by principle 
 1 . this effects the correct interconnection by mutal reference required in the flow diagram. 
　　　several complications occur. to begin with  consider the case where the entity selection dictated by a constraint expression resolves to a l i s t of potential candidates. principle  1  requires that constraints be imposed on the dynamic object  but in this case no single object exists. we build a representation for this ambiguous object in order to record the constraint. these objects are used to represent the general class of entities that can satisfy the known constraints; the posting of new constraints may have the effect of redefining the class  to a subset  or of selecting a single entity from the class. this concept is critical to a consultation in which focus of attention can change before a fully instantiated form of the entity is determined. our constraint architecture has been designed to permit maximum f l e x i b i l i t y in representing classes of entities as the result of constrained searches. 
　　　another problem occurs in the mutual reference case described above. we find here that the processing of slotl in entity a requires the evaluation of slot1 of entity b which  in turn  requires the evaluation of slotl in entity a. a looping situation is established and needs to be detected and properly processed. this requirement was one of several that led us to extend our concepts of the control flow mechanism in the consultation system. 

v the control architecture 
       the sequence of processing steps and i t s implication on focus of attention has been recognized as a c r i t i c a l issue in expert system design 1 . in most systems  control flow logic is cast in programming  a formalism not famed for its transparency or ease of modification. in systems with programmed control flow  developing a natural and and correct consultation requires a careful knowledge design and familiarity with the internal control logic. the recognition that the overall strategy for knowledge processing may reflect domain-specific expertise  e.g.  when to look at what knowledge and what sequence of steps to follow  has led some architects to provide a formal knowledge representation for control  1 . this seems inherently correct and the system presented here reflects the authors' belief that control flow must be designed in a manner that permits modification by problem-domain experts  and that a suitable formalism must be found. 
       in our system the major processing is accomplished by a collection of primitive routines designed to operate on our frame-structured knowledge representation. examples of primitive routines are: 
create a dynamic object 
resolve slot semantics interact with users 
specialize a more general dynamic object 
these routines do not communicate directly with each other; if one primitive determines that another primitive should be executed  it interacts with a scheduling function to schedule the execution of that task. primitive routines to be executed are represented in an agenda which lists the identification of the primitive  the processing context in which it is to be run  and control information for the scheduling function. in our current implementation the agenda grows continuously with each new item scheduled and serves as our trace history information. primitives may be scheduled for either dependent or independent execution. dependent scheduling forces the complete execution of the scheduled primitive before the primitive requesting that scheduling is resumed. in the case of independent scheduling the order of execution is arbitrary. 
       both the ordering of execution of pending agenda items and the automatic creation of agenda items  depending on the dialog state  reflect expertise that should be modifiable by and transparent to the problem expert. to effect this  antecedent-driven production rules have been chosen to represent control knowledge. this choice was dictated mainly by our desire to permit non-programmers to enter and maintain expertise concerning the course  control flow  of a dialog. in particular  the current focus of attention for the dialog has often turned out to be properly a function of domain specific expertise rather than a 
       result of domain independent  general dialog processing. this observation led us away from approaches such as attached procedures and toward more formal knowledge representations. the control rules may be invoked at either the time a primitive is scheduled or when a primitive terminates  and may reference the current agenda information as well as the general dynamic state of the consultation. 
       as an example  consider architectural principle  1   stated earlier  concerning the creation of a dynamic object based on the results of slot resolution. this piece of control logic is dictated by the particular task domain  flow diagram creation  and is reflected in an appropriate rule which is processed at the termination of the slot resolution primitive. in a similiar manner  the control logic to properly evaluate the constrained mutual references  described in the previous section  and inhibit looping is reflected in rules processed within the scheduling function. specifically  when the agenda state reflects the occurence of a referencing loop the system forces the commitment to the mutual reference and processing continues. 
       both the debugging and the modification of control flow in our consultations has beer  greatly facilitated by this design. our experience  however  suggests several important future efforts. 
vi the system status and future work 
       in the current implementation the control rules are implemented as apl code; this is to be changed to a formal data representation for the rules  coupled with a rule processing inference engine. the current knowledge base has been developed for medical sensor-based computing applications  the payroll example in this paper was chosen for its widespread familiarity   but has not been subjected to use as a production tool in a suitable laboratory environment. sample dialogs have been run on limited test cases. 
       this system has been developed to ensure applicability to multiple task domains. to this end  generality has been introduced  e.g.  in the control architecture  that might not have been required otherwise. it is our intent to apply the system to another task domain. others we have considered include system configuration  and diagnosis  medical or otherwise . in this last case  we envision a major replacement of control rules to accomplish inferential diagnostic processing  as in mycin  1    through the formalism of frame instantiation. another interesting experiment would be to develop a molgen-like system 1   in which the control flow reflects a strategy of 'least commitment'  instead of our current system which adopts a strategy of 'greatest commitment'. once again  we envision the changes to be limited principally to the control rules. 

v i i conclusions 
