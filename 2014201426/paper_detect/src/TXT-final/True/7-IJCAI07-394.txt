
we describe a novel approach to incomplete information board games  which is based on the concept of metaposition as the merging of a very large set of possible game states into a single entity which contains at least every state in the current information set. this merging operation allows an artificial player to apply traditional perfect information game theory tools such as the minimax theorem.
we apply this technique to the game of kriegspiel  a variant of chess characterized by strongly incomplete information as players cannot see their opponent's pieces but can only try to guess their positions by listening to the messages of a referee. we provide a general representation of kriegspiel states through metaposition trees and describe a weighed maximax algorithm for evaluating metapositions. we have tested our approach competing against both human and computer players.
1 introduction
incomplete information board games are an excellent testbed for the study of decision making under uncertainty. in these games  only a subset of the current state of the game is made known to the players  who have to resort to various methods in order to find an effective strategy.
　kriegspiel is a chess variant in which the players cannot see their opponent's pieces and moves: all rules of chess stay  but the game is transformed into an incomplete information game. we have built a program called darkboard  which plays a whole game of kriegspiel searching over a game tree of metapositions. the preliminary results we have are quite encouraging.
　this paper is organized as follows: in the next section we describe the concept of metaposition. then we apply this concept to kriegspiel. in sect. 1 we show how we apply weighed maximax to metapositions; in sect. 1 we introduce an evaluation function for a game tree of metapositions. finally  in sect. 1 we describe some experimental results and draw our conclusions.
1 metapositions
the original concept of metaposition was introduced in  sakuta  1   where it was used to solve endgame positions for a kriegspiel-like game based on shogi. the primary goal of representing an extensive form game through metapositions is to transform an imperfect information game into one of perfect information  which offers several important advantages and simplifications  including the applicability of traditional techniques associated with these games. a metaposition  as described in the quoted work  merges different  but equally likely moves  into one state  but it can be extended to treat moves with different priorities .
　in its first formulation  a metaposition is a set of game states grouping those states sharing the same strategy spaces  legal moves  available to the player. a given move for the first player is guaranteed to be legal across every state in the set  or in none at all. if we consider the game tree from the point of view of metapositions instead of single game states  it is readily seen that the game becomes  nominally  one of perfect information. when the first player moves  the current metaposition  which coincides with the current information set  is updated by playing that move on all the boards  as it is certainly legal. the opponent's moves generate a number of metapositions  depending on the resulting strategy space for the first player. if the first player knew his new strategy space beforehand  he would be able to uniquely determine the new metaposition because different metapositions have  by definition  different strategy spaces associated to them.
　unfortunately  a player's strategy space is not known beforehand in such games as kriegspiel. there is  obviously  no way to find out whether a move is legal other than by trying it. therefore  an extension of the definition of metaposition is needed  refining the concept of strategy space. often  a move which is likely to be illegal on the referee's board is a good strategy for the player. illegal moves are the main mechanism for acquiring information on the opponent's piece setup. it makes little sense to discard their analysis only because the referee knows they are illegal.
a second formulation of metapositions is as follows.
definition. if s is the set of all possible game states and i   s is the information set comprising all game states compatible with a given sequence of observations  referee's messages   a metaposition m is any opportunely coded subset of s such that i   m   s.
　the strategy space for m is the set of moves that are legal in at least one of the game states contained in the metaposition. these are pseudolegal moves  assumed to be legal from the player's standpoint but not necessarily from the referee's. a metaposition is endowed with the following functions:
  a pseudomove function pseudo that updates a metaposition given a move try and an observation of the referee's response to it;
  a metamove function meta that updates a metaposition after the unknown move of the opponent  given the associated referee's response;
  an evaluation function eval that outputs the desirability of a given metaposition.
　from this definition it follows that a metaposition is any superset of the game's information set  though clearly the performance of any algorithm will improve as m tends to i . every plausible game state is contained in it  but a metaposition can contain other states which are not compatible with the history. the reason for this is two-fold: on one hand  being able to insert  opportune  impossible states enables the agent to represent a metaposition in a very compact form  as opposed to the immense amount of memory and computation time required if each state were to be listed explicitly; on the other hand  a compact notation for a metaposition makes it easy to develop an evaluation function that will evaluate whole metapositions instead of single game states. this is the very crux of the approach: metapositions give the player an illusion of perfect information  but they mainly do so in order to enable the player to use a minimax-like method where metapositions are evaluated instead of single states. for this reason  it is important that metapositions be described in a concise way so that a suitable evaluation function can be applied.
　it is interesting to note that metapositions move in the opposite direction from such approaches as monte carlo sampling  which aim to evaluate a situation based on a significant subset of plausible game states. this is perhaps one of the more interesting aspects of the present research  which moves from the theoretical limits of monte carlo approaches as stated  for example  in  frank and basin  1   and tries to overcome them. in fact  a metaposition-based approach does not assume that the opponent will react with a best defense model  nor is it subject to strategy fusion because uncertainty is artificially removed.
　the nature of the  opportune coding  required to represent a metaposition  a superset of the usually computationally intractable information set i  will depend on the specific game. as far as kriegspiel is concerned  we move from the results in  ciancarini et al.  1  on information set analysis in order to win a kriegspiel endgame. here the authors use the information set in order to recognize position patterns in the king and pawn versus king  kpk  endgame  however performing no search in the problem space.
　the first representation of kriegspiel situations using metapositions together with an evaluation function was given in  bolognesi and ciancarini  1  and  bolognesi and ciancarini  1 . their analysis is  however  limited to a few chosen endgame examples  such as king and rook versus king  krk . because of the small size of the game's information set in these particular scenarios  which is limited to the possible squares where the opponent's king may be   metapositions coincide exactly with the information set in the quoted papers  m = i . the present work deals with a generic full game of kriegspiel  with the opponent controlling an arbitrary number of pieces  and such an assumption is unreasonable.
　our approach to coding a kriegspiel metaposition is  essentially  the abstract representation of a chessboard containing both real pieces  belonging to the players and pseudopieces  ghost pieces that may or may not exist . trivially  a metaposition coded in this fashion represents a number of states equal to the product of the number of pseudopieces on each square. each square  therefore  has the following information attached to it.
  piece presence: whether the square contains an allied piece.
  pseudopiece presence: a bitfield representing the possible presence of opposing pieces at the given location. there are seven possible pseudopieces  and any number of them may appear simultaneously at the same square: king  queen  rook  bishop  knight  pawn and empty. the last is a special pseudopiece indicating whether the square may be empty or is necessarily occupied.   age information: an integer representing the number of moves since the agent last obtained information on the state of this square. this field provides the integration of some of the game's history into a metaposition in a form that is easily computable.
moreover  a metaposition will store the usual information concerning such things as castling rights and the fifty moves counter  in addition to counters for enemy pawns and pieces left on the chessboard. it is easy to notice that such a notation is extremely compact; in fact  each square can be represented by two bytes of data.
　a pseudopiece is  essentially  a ghost piece with the same properties as its real counterpart. it moves just like a real piece  but can move through or over fellow pseudopieces  except in specific cases. for example  it is possible to enforce rules to prevent vertical movement across a file where an opponent's pawn is known to be.
　a metaposition follows and mantains the following invariant: if a pseudopiece is absent at a given location  then no piece of that type can appear there in any state of the current information set. the opposite is not true  and because of their relaxed movement rules  pseudopieces may appear in places where a real enemy piece could not be according to the information set. this is equivalent to saying that i   m. a metaposition then represents a much larger superset of the information set  and in certain phases of the game  some pseudopieces can be found at almost every location.
1 updating knowledge
metapositions not deal with moves  but with pseudomoves and metamoves. a pseudomove represents the agent's move  which can be legal or illegal  and has an associated observation  a set of umpire messages sent in response to the move attempt . a metamove represents the collective grouping of all the possible opponent's moves  and it is associated to an observation  too. darkboard implements pseudo and meta by accepting a metaposition and an observation  with an updated metaposition being returned as the output. clearly  pseudo reduces the uncertainty by eliminating some pseudopieces  whereas meta increases it by spawning new pseudopieces.
　intuitively  meta does such things as clearing all pseudopieces on the moved piece's path and infer the position of the opponent's king from check messages; pseudo has every pseudopiece spawn copies of itself on every square it can reach in one move. it is readily seen that such operations maintain the i   m constraint that defines a metaposition. a number of optimizations are possible to improve their accuracy and therefore quality of play  but because of the loose nature of a kriegspiel metaposition  they are not required.
　as a metaposition represents a grouping of a very large number of positions which cannot be told apart from one another  it is clear that updating such a data structure is no trivial task; in truth  this process does account for the better part of the agent's computation time. updating an explicitly listed information set with a pseudomove would involve finding all the positions compatible with the outcome of that move  legal  not legal  check  etc.   discarding anything else  and applying the move to the compatible chessboards. updating a metaposition after a metamove would prove an even more daunting task  as we would have to consider each possible move for each possible chessboard in the set. again  this is a problem that can only be overcome through a suitable approximation  or by limiting the number of chessboards down to a manageable pool  as in  parker et al.  1  .
　it may appear strange that the heart of the program's reasoning does not lie in the evaluation function eval but in pseudo and meta: after all  their equivalent in a chessplaying software would trivially update a position by clearing a bit and setting another. however  the evaluation function's task is to evaluate the current knowledge. the updating algorithms compute the knowledge itself: thus it is important to infer as much information as possible in the process. in fact  one interesting point about this approach is that the updating functions and the evaluation function can be improved upon separately  increasing the program's performance without the need for the two components to have any knowledge of each other.
1 game tree structure
since a metaposition's evolution depends exclusively on the umpire's messages  clearly it becomes necessary to simulate the umpire's next messages if a game tree is to be constructed. ideally  the game tree would have to include every possible umpire message for every available pseudomove so that it can be evaluated with a weighed algorithm keeping into account the likelyhood of each observation. unfortunately  a quick estimate of the number of nodes involved rules out such an option. it is readily seen that:
  all pseudomoves may be legal  or they would not have been included by the generation algorithm   but most can be illegal for some game state.
  all pseudomoves that move to non-empty squares can capture  except for pawn moves   and we would need to distinguish between pawn and piece captures.
  most pseudomoves may lead to checks.
  some pieces may lead to multiple check types  as well as discovery checks.
  the enemy may or may not have pawn tries following this move.
a simple multiplication of these factors may yield several dozens potential umpire messages for any single move. but worst of all  such an estimate does not even take into account the possibility of illegal moves. an illegal move forces the player to try another move  which can  in turn  yield more umpire messages and illegal moves  so that the number of cases rises exponentially. furthermore  the opponent's metamoves pose the same problem as they can lead to a large number of different messages.
  on the opponent's turn  most pieces can be captured  unless they are heavily covered or in the endgame.   the king may typically end up threatened from all directions through all of the 1 possible check types.   again  pawn tries may or may not occur  and can be one or more.
for these reasons  any metaposition will be only evolved in exactly one way  and according to one among many umpire messages. this applies to both the player's pseudomoves and the opponent's hidden metamoves. there will be heuristics in place to pick a 'reasonable' message  and the more accurate this is  the more effective the whole system will get.
　as a consequence  the tree's branching factor for the player's turns is equal to the number of potential moves  but it is equal to 1 for the opponent's own moves. this is equivalent to saying that the player does not really see an opponent  but acts like an agent in a hostile environment.
　it should be noted that this is not the same assumption that minimax algorithms make when they suppose that player min will choose the move that minimizes the evaluation function. here we are not expecting the opponent to play the best possible move  but instead we assume an average move will be played  one that does not alter the state of the game substantially.
　as a side effect  because only one possible umpire message for the opponent's metamove is explored  the metamove can be merged with the move that generated it  so that each level in the game tree no longer represents a ply  but a full move.
　interestingly  the branching factor for this kriegspiel model is significantly smaller than the average branching factor for the typical chess game  seeing as in chess either player has a set of about 1 potential moves at any given time  and kriegspiel is estimated to stand at approximately twice that value  in theory; practice yields smaller values due to tighter defence patterns . therefore  a two-ply game tree of chess will feature about 1 = 1 leaves  whereas the kriegspiel tree will only have 1. however  the computational overhead associated with calculating 1 metaposition nodes is far greater than that for simply generating 1 position nodes  and as such some kind of pruning algorithm may be needed.
1 umpire prediction heuristics
 bolognesi and ciancarini  1   in tackling kriegspiel endgames  where the artificial player's moves have only three possible outcomes  silent  check  illegal  and having to choose one to expand upon  rely upon the evaluation function to pick the most unfavorable option. however  even such a modest luxury seems beyond reach in the present work due to both the number of options and their different probabilities. the only remaining way is for us to propose a set of hard-coded heuristics that work well most of the time  and make sure that they will work reasonably even when they are proved wrong. our player generates the umpire messages that follow its own pseudomoves in the following way.   every move is always assumed to be legal. most of the time  an illegal move just provides information for free  so a legal move is usually the less desirable alternative.   the player's moves do not generally capture anything  with the following exceptions:
- pawn tries. these are always capturing moves by their own nature.
- non-pawn moves where the destination square's empty bit is not set  since the place is necessarily non-empty. this encourages the program to retaliate on captures.
- after an illegal move  the agent may consider an identical move  but shorter by one square  as a capturing move.
  if any of the above apply  the captured entity is always assumed to be a pawn  unless pawns should be impossible on that square  in which case it is a piece.   pawn tries for the opponent are generated if the piece that just moved is the potential target of a pawn capture.
　on the other hand  the following rules determine the umpire messages that follow a metamove.
  the opponent never captures any pieces  either. the constant risk that allied pieces run is considered by the evaluation function instead.
  the opponent never threatens the allied king. again  king protection is matter for the evaluation function.
  pawn tries for the artificial player are never generated.
　the above assumptions are overall reasonable  in that they try to avoid sudden or unjustified peaks in the evaluation function. the umpire is silent most of the time  captures are only considered when they are certain  and no move receives unfair advantages over the others. there is no concept of a 'lucky' move that reveals the opponent's king by pure coincidence  though if that happens  our program will update its knowledge accordingly.
　even so  the accuracy of the prediction drops rather quickly. in the average middle game  the umpire answers with a non-silent message about 1% of the time. clearly  the reliability of this method degrades quickly as the tree gets deeper  and the exploration itself becomes pointless past a certain limit. at the very least  this shows that any selection algorithm based on this method will have to weigh evaluations differently depending on where they are in the tree; with shallow nodes weighing more than deeper ones  and even so  exploration becomes fruitless past a certain threshold.
1 the selection algorithm
now that the primitives have been discussed in detail  it is possible to describe the selection algorithm for the metaposition-based player. several variants on this approach have been developed  optimizing the algorithm for fast play over the internet chess club using such methods as pruning and killer-like techniques; this is its first and basic formulation.
　the whole stratagem of metapositions was aimed at making traditional minimax techniques work with kriegspiel. actually  since min's moves do not really exist  min always has only one choice  if we use the compact form for the tree  with each node representing two plies  the algorithm resembles a weighed maximax. maximax is a well-known criterion for decision-making under uncertainty. this variant is weighed  meaning that it accepts an additional parameter α （  1   called the prediction coefficient. the algorithm also specifies a maximum depth level k for the search. furthermore  we define two special values  ＼±  as possible output to the evaluation function eval. they represent situations so desirable or undesirable that they often coincide with victory or defeat  and should not be expanded further.
　defining mt as the set of all metapositions and mv as the set of all possible chess moves  the selection algorithm makes use of the following functions:
  pseudo:  mt 〜 mv  ★ mt  which generates a new metaposition from an existing one and a pseudomove  simulating the umpire's responses as described in the last section.
  meta: mt ★ mt  which generates a new metaposition simulating the opponent's move and  again  virtual umpire messages.
  generate: mt ★ vectormv  the move generation function.
  eval:  mt〜mv〜mt  ★r  the evaluation function  accepting a source metaposition  an evolved metaposition  obtained by means of pseudo   and the move in between.
　the algorithm defines a value function for a metaposition and a move  whose pseudocode is listed in figure 1. the actual implementation is somewhat more complex due to optimizations that minimize the calls to pseudo.
　it is easily seen that such a function satisfies the property that a node's weight decrease exponentially with its depth. function value  metaposition met  move mov  int depth : real begin
metaposition met1 := pseudo met  mov ;
real staticvalue := eval met  mov  met1 ; if  depth ＋ 1  or  staticvalue = ＼±  return staticvalue
else
begin
　　//simulate opponent  recursively find max.
metaposition met1 := meta met1 ; vector movevec := generate met1 ;
real best := maxx（movevec value met1  x  depth-1 ;
　　　　　　//weighed average with parent's value.
return  staticvalue*α +best* 1   α 
end
end.

figure 1: pseudocode listing for value function.
given the best maximax sequence of depth d from root to leaf m1 ... md  where each node is provided with static value s1 ... sd  the actual value of m1 will depend on the static values of each node mk with relative weight αk. thus  as the accuracy of the program's foresight decreases  so do the weights associated with it  and the engine will tend to favor good positions in the short run.
　parameter α is meant to be variable  as it can be used to adjust the algorithm's willingness to take risks  as well as our level of confidence in the heuristics that generate the simulated umpire messages. higher values of α lead to more conservative play for higher reward in the short run  whereas lower values will tend to accept more risk in exchange for possibly higher returns later on. generally  the player who is having the upper hand will favor open play whereas the losing player tends to play conservatively to reduce the chance of further increasing the material gap. material balance and other factors can therefore be used to dynamically adjust the value of α during the game.
1 an evaluation function for metapositions
the evaluation functions for chess programs have usually three main components: material count  mobility  and position evaluation. a metaposition evaluation function  however  does not work on a single chessboard  but on an entity representing billions of chessboards  and may need to introduce equivalent  but different concepts. for example  our evaluation function currently has three main components that it will try to maximize throughout the game: material safety  position  and information.
1 material safety
material safety is a function of type  mt 〜 sq 〜 bool  ★  1 . it accepts a metaposition  a square and a boolean and returns a safety coefficient for the friendly piece on the given square. the boolean parameter tells whether the piece has just been moved  as it is clear that a value of true decreases the piece's safety; statistically speaking  the risk of losing the piece being moved is much higher . a value of 1 means it is impossible for the piece to be captured on the next move  whereas a value of 1 indicates a very high-risk situation with an unprotected piece.
　it should be noted  however  that material safety does not represent a probability of the piece being captured  or even an estimate of it; its result simply provides a reasonable measure of the exposure of a piece and the urgency with which it should be protected or moved away from danger.
1 position
our player includes the following factors into its evaluation function:
  a pawn advancement bonus. in addition  there is a further bonus for the presence of multiple queens on the chessboard.
  a bonus for files without pawns  and friendly pawns on such files.
  a bonus for the number of controlled squares  as computed with a special protection matrix. this factor is akin to mobility in traditional chess-playing software.
　in addition  the current position also affects material rating  as certain situations may change the values of the player's pieces. for example  the value of pawns is increased if the player lacks sufficient mating material.
　an additional component is evaluated when darkboard is considering checkmating the opponent. a special function represents perceived progress towards winning the game  partly borrowed from  bolognesi and ciancarini  1   thus encouraging the program to push the opponent's pseudokings towards the edges of the chessboard.
1 information
one of the crucial advantages of using metapositions lies in the ability to estimate the quality and quantity of information available to the player. in fact  because we are operating with a large superset of the information set which necessarily incorporates the current true state of the game  to acquire information simply means to aim towards reducing the size of the metaposition's position set; therefore  an indicator based on size  for example  the sum of all the pseudopieces on the chessboard  can enter the evaluation function and the player will strive towards states with reduced uncertainty. an approch such as monte carlo cannot do this  as its belief state works on a small subset of the information set wherein each single state is dogma when evaluated.
　our player will attempt to gather information about the state of the chessboard  as the evaluation function is designed to make information desirable  precisely  it is designed to make the lack of information undesirable  by reducing a function  which we call chessboard entropy  e   satisfying the following.
  the function's value increases after every metamove from the opponent  that is  m1 = meta m1     e m1  − e m1 .
  the function's value decreases after each pseudomove from the player  that is  m1 = pseudo m1 x （ mv     e m1  ＋ e m1 .
　therefore  the chessboard entropy is constantly affected by two opposing forces  acting on alternate plies.
we can define Δe m x  m （ mt x （ mv as
e pseudo meta m x      e m   the net result from two plies. our program will attempt to minimize Δe in the evaluation function. in the beginning  entropy increases steeply no matter what is done; however  in the endgame  the winner is usually the player whose chessboard has less entropy.
　darkboard's algorithm for computing entropy revolves around the age matrix  encouraging the program to explore squares with a higher age value  meaning that they have not been visited in a long time . clearly  there are constants involved: making sure there are no enemy pawns on the player's second rank is more important than checking for their presence on the fifth rank.
1 experimental results and conclusions
we remark that the ruleset used for our program is the one enforced on the internet chess club  which currently hosts the largest kriegspiel community of human players. our metaposition-based kriegspiel player  darkboard  is currently  to the best of our knowledge  the only existing artificial player capable of facing human players over the internet on reasonable time control settings  three-minute games  and achieve well above average rankings  with a best elo rating of 1 which placed it at the time among the top 1 players on the internet chess club. we note that darkboard plays an average of only 1 tries per move  and therefore it does not use the advantage of physical speed to try large amounts of moves.
　darkboard defeats a random-moving opponent approximately 1% of the time. it defeats a random player with basic heuristics  a player which will always capture when possible but otherwise move randomly  approximately 1% of the time; the rest are draws by either stalemate or repetition.
darkboard won gold medal at the eleventh computer
olympiad which took place from may 1 to june 1  1 in
turin. the player defeated an improved version of the monte carlo player described in  parker et al.  1  with a score of 1.
　in view of these results  we argue that using metapositions to evaluate a superset of the current game state rather than a subset of it yields very encouraging results for those games with strongly incomplete information and an extremely large belief state.
