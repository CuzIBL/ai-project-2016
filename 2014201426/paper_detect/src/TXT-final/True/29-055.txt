 
recent work by kautz et al. provides tantalizing evidence that large  classical planning problems may be efficiently solved by translating them into propositional satisfiability problems  using stochastic search techniques  and translating the resulting truth assignments back into plans for the original problems. we explore the space of such transformations  providing a simple framework that generates eight major encodings  generated by selecting one of four action representations and one of two frame axioms  and a number of subsidiary ones. we describe a fully-implemented compiler that can generate each of these encodings  and we test the compiler on a suite of strips planning problems in order to determine which encodings have the best properties. we present an analytic framework that accounts for all previously reported non-causal encodings 1 including several novel possibilities. we parameterize the space of encodings along two major dimensions  action and frame representation. for twelve points in this twodimensional space  we list the axioms necessary for a minimal encoding  and we calculate the asymptotic encoding sizes. 
we describe an automatic compiler that generates all of these encodings. while it is difficult for a compiler to produce encodings that are as lean as the hand-coded versions of  kautz and selman  1   we describe typeanalysis and factoring techniques that get us close. experiments demonstrate these methods can reduce the number of variables by half and formula size by 1%. we run the compiler on a suite of strips-style planning problems  determining that the regular and simply-split explanatory encodings are smallest and can be solved 
1 	introduction 
despite the early formulation of planning as theorem proving  green  1   most researchers have long assumed that special-purpose planning algorithms are necessary for practical performance. however  recent improvements in the performance of propositional satisfiability methods  cook and mitchell  1  cast doubt on this conclusion. initial results for compiling bounded-length planning problems to sat were unremarkable  kautz and selman  1   but recent experiments  kautz and selman  1  suggest that compilation to sat might yield the world's fastest strips-style planner. 
   however  several open questions must be answered before concluding that sat-based planning dominates specialized algorithms. the experiments of  kautz and selman  1  used hand-crafted sat encodings  and while  kautz et al  1  describe methods for compilation  no one has reported experiments on automatically compiled problems and no one knows which encodings are best. the encodings used by  kautz and selman  1  included domain information that is inexpressible in the strips action language  e.g.  the fluent on is irreflexive and noncommutative ; to what extent is this information responsible for the speedup they observed  this paper addresses these issues: 
   *this research was funded in part by office of naval research grant n1-1  by national science foundation grant 
ir1  by arpa / rome labs grant f1-1  and by a gift from rockwell international palo alto research. 
fastest. 
1 	the space of encodings 
this section presents a framework that describes all of the a t & t encodings  except for the causal encodings  as well as some new alternatives. previous work has described individual encodings in a variety of ways  e.g.   direct    statebased   etc.   but we avoid these terms. instead we present a parameterized space with two dimensions: 
  the choice of a regular  simply split  overloaded split  or bitwise action representation specifies the correspondence between propositional variables and ground  fullyinstantiated  plan actions. these choices represent different points in the tradeoff between the number of variables and the number of clauses in the formula. 
  the choice of classical or explanatory frame axioms varies the way that stationary fluents are constrained. 
   our encodings use a standard fluent model in which time takes nonnegative integer values. state-fluents occur at evennumbered times and actions at odd times. all of the encodings use the following set of universal axioms: 
init the initial state is completely specified at time zero  including all properties presumed false by the closedworld assumption. 
goal in order to test for a plan of length n  all desired goal properties are asserted to be true at time 1n. 
   *the omitted  state-based  encodings can be obtained by resolving away the actions in our encodings  kautz et al  1j. 
	ernst  millstein  & w e l d 	1 




figure 1: the sizes of each axiom schema as a function of action representation. note that combinations whose entries are identical may have different sizes because the value of  is itself a function of action representation  see figure 1  

they permit parallelism. specifically  any actions whose preconditions are satisfied at time t and whose effects do not contradict each other might be executed in parallel. this kind of parallelism is problematic because it can create valid plans which have no linear solution. for example  suppose action a has precondition x and effect y  while action has precondition -y and effect -x. while these actions might be executed in parallel  because their effects are not contradictory  there is no legal total ordering of the two actions  which is problematic for non-instantaneous real-world actions. 
exclusion linearizability of resulting plans is guaranteed by restricting which actions may occur simultaneously. 
two kinds of exclusion enforce different constraints in the resulting plan: 
  c o m p l e t e exclusion: for each odd time step  and for all distinct  fully-instantiated action pairs  add clauses of the form  complete exclusion ensures that only one action occurs at each time step  guaranteeing a totally-ordered plan. 
  conflict exclusion: for each odd time step  and for all distinct  fully-instantiated  conflicting action pairs add clauses of the form  in our framework  two actions conflict if one's precondition is inconsistent with the other's effect.1 conflict exclusion results in plans whose actions form a partial order. any total order consistent with the partial order is a valid plan. 
   because we wish to consider the minimal encoding corresponding to each choice of action and frame representations  we will assume that conflict exclusion is used whenever possible. conflict exclusion cannot be exploited when using a split action representation  because splitting causes there not to be a unique variable for each fully-instantiated action. for example  with simple splitting  it would be impossible to have two instantiations of the same operator execute at the same time  because their split fluents would interfere. overloaded splitting further disallows two instantiations of different operators to execute at the same time. 
   the bitwise action representation requires no action exclusion axioms. at any time step  only one fullyinstantiated action's index can be represented by the bit symbols  so a total ordering is guaranteed. 
1 	optimizing axioms with factoring 
eight base encodings are generated by choosing among the regular  simple split  overloaded split  and bitwise action representations and choosing either classical or explanatory frames. unfortunately  choices that lead to a small number of variables  i.e.  the splitting strategies and bitwise  tend to explode the number of clauses or size of each clause. consider the at-least-one axiom  which is a disjunction of all fully-instantiated actions. substituting a conjunction of split or bitwise variables for each regular action literal produces a disjunctive normal form formula which blows up exponentially when converted to conjunctive normal form. with simple splitting  this axiom grows1 from n clauses of size a to clauses of size a  see figure 1 . 
   the formula blowup results from blindly substituting a complete conjunction of split variables for each action in the a= p e  frame  at-least-one  and exclusion axioms. factoring can dramatically reduce both the number of clauses and their sizes for simple and overloaded splitting. the idea is to use only a subset of the full conjunction for an action whenever possible. such a partially-instantiated action represents the set of all fully-instantiated actions consistent with it. the bitwise action representation does not admit an easy method of factoring because partial conjunctions of the bit variables are not useful unless a clever action numbering scheme is created. 
1 	f a c t o r i n g a =   p   e a n d frame a x i o m s 
the a= p e and frame axioms  which relate a single fluent to a single action  can make good use of partial action instantiations. for example  figure 1 shows the move operator and some of the a= p e axioms for one possible instantiation of the operator. ordinary simple splitting will transform the first axiom at the bottom of figure 1 into 

   a similar axiom is generated for all pairs of constants 1 and d for which move s b d t  is a consistent action. since two of the argument values are irrelevant for this axiom  the simpler axiom movearg1 b t  =  clear b t+1  can be used instead  eliminating the need to explicitly consider all |dom|1 values for moveargl and movearg1. 

¡¡¡¡1 contrast our definition of conflict with that of graphplan  blum and furst  1  and  kautz and selman  1 . unlike kautz and selman's parallel encoding  but like their linear one  our encodings have axioms stating that actions imply their effects; their parallel encoding prohibits effect-effect conflicts instead. 
1
    the number of logically independent clauses may be substantially smaller than this worst-case bound which results from naive conversion: some clauses may contain duplicated literals  and some clauses may logically imply others. our implementation eliminates these unnecessary literals and clauses. 
	ernst  millstein  & w e l d 	1 

figure 1: composition and worst case size of the encodings. the bitwise action representation yields the smallest number of variables  but the most clauses; regular actions are the exact opposite. all encodings init  goal  a p e  and frame axioms. any additional clauses are noted  and the total size for all clauses is given. the reported numbers are asymptotic numbers of literals  i.e.  the product of numbers of clauses and clause sizes . 
¡¡factoring a= p e axioms relies on this idea: when relating an action to a fluent  we need only include the parts of the action conjunct pertaining to the arguments that appear in the affected fluent. 
¡¡the technique extends easily to both classical and explanatory frame axioms. consider the classical frame example given in section 1. instead of naively splitting move a b c t  into moveargla t  movearg1 b 1 
movearg1 c f   we observe that the source and object of the move are irrelevant and generate 

¡¡this formula implicitly represents the set of all classical frame axioms relating the clearness of d to any move action having c as its destination argument. 
¡¡note that while the factoring optimization is crucial in practice  see section 1   it is equivalent to ordinary splitting in the worst case. in particular  when the arity of precondition and effect fluents is equal to the arity of the operator  no factoring is possible. 
1 	factoring exclusion axioms 
since pairwise exclusion clauses relate actions to other actions  instead of relating 
actions to fluents  the previous technique cannot be used. instead  we factor these axioms by noting that  rather than excluding whole actions from occurring simultaneously  we can independently exclude the values of each argument to an action. 
¡¡for example  factored exclusions of the move operator look like  -moveargt a t  v -moveargi 1   ranging over all arguments i and distinct constants a and 1. this ensures that at most one fully-instantiated move action is active at time t. by doing this for all operators  we ensure that only one instance  of each operator is active at time t. 
¡¡to complete the exclusion  we need to ensure that no two operators have an active instance at time t. this is accomplished by pairwise excluding all possible first arguments of each operator with one another. in other words  we add clauses 	for all distinct operators and and all  not necessarily distinct  constants a and 1. figure 1 shows how factoring reduces the asymptotic number and size of clauses as compared with unfactored split exclusion axioms. 
1 	factoring at-least-one axioms 
without factoring  the at-least-one axiom explodes into an exponential morass during the conversion to cnf. fortunately  it can be factored very easily  yielding the disjunction of all possible first arguments to all operators  i.e.  an 
1 	planning and scheduling 

1 	preventing partial action execution 
the previous three subsections show how to factor each part of the encoding. all three parts rely on the ability to refer to parts of an action instead of always referring to a complete instantiation of an action. however  the underlying assumption is that  whenever any part is instantiated  so is the rest of the action. 
¡¡for example  we would not want a factored frame clause to have any effect unless a full action implied by that frame was actually being executed at the current time step. otherwise  the frame could constrain the resulting plan  even though the action referred to by the frame is never fully executed. 
no-partial we add axioms which state that  whenever any part of an operator is instantiated  so is the rest. 
¡¡here are the partial action elimination axioms for the move operator: 

these axioms ensure that whenever any split fluent of move is true  then some complete instantiation of move is true. figure 1 shows the number and size of the resulting clauses. 
1 	the medic planner 
following the encodings described above  we have implemented a classical planner which accepts traditional1 inputs  initial state  goal formula  and strips action schemata  and returns a sequence of actions that will achieve the goal. the medic planner operates by compiling the planning problem into clausal form  solving the sat problem  and translating the satisfying truth assignment back into actions. depending on the switch settings  any of the sat encodings described above can be generated. thus the medic planner forms a unique testbed for exploring the properties of the different encodings. 
¡¡the architecture of the planner is shown in figure 1. action schemata are parsed using the preprocessor from the 
ucpop planner  penberthy and weld  1  and type optimization  see below  is performed. next  guided by the choice of action and frame representations  figure 1   the compiler creates a master axiom schema representing all action possibilities for one time step. the periodic axiom schema is instantiated multiple times  based on the plan length currently being considered. the output of this duplication module  combined with the initial state and goal specification  is simplified by pure literal elimination  unit clause propagation  and duplicate literal elimination using a fast  linear time  procedure  van gelder and tsuji  1 . the resulting clauses are solved using walksat  selman et a/.  1  or tableau  crawford and auton  1 . 
1 	o p t i m i z a t i o n s 
planning via reduction to propositional satisfiability is impractical without a number of optimizations which determine the truth values of fluents or limit the ground instantiations of actions. foremost among these are type optimizations. a type is a fluent which no action affects. 
   types can constrain operator instantiation by ruling out impossible ground versions. for instance  if a and b are the only blocks  we can prune any instantiation of the move operator  figure 1  which does not assign o to either a or b. when such preconditions are reflected in the operator instantiations  the types themselves need not appear in the final encoding; for instance  the block precondition would be removed from move. this mechanism is a generalization of the obvious one for handling equality and inequality constraints  which are special cases of types. 
   because of the usefulness of type information  we have explored methods of inferring types of arguments when operators do not specify them. suppose that block o  did not appear in the move definition in figure 1  but that whenever clear o  appears in an action's effect  for any variable o   that action's precondition contains the fluent block o . then no constant can become clear without being a block. 
if every constant which is clear in the initial conditions is also a block  we can deduce that every clear constant must be a block and add block o  to the move precondition. 
   similarly  inequality constraints can be inferred if a fluent appears both positively and negatively in an operator  since the two bindings cannot be identical. since the move operator of figure 1 has effects  and on o d   the sd constraint would be inferred if it were not already present. 
   an operator's instantiations can be further pruned by eliminating symmetric operator instantiations. for instance  if an operator a takes two arguments which are used identically  then there is no sense considering both of the bindings and  we arbitrarily select one of the possibilities. this analysis cuts the number of ground instantiations by about an order of magnitude for the refrigerator domain. 
   the m e d i c planner further reduces bindings and infers invariant fluents by enforcing a form of consistency. an approximation to the set of fluents that can be true  and also to 
those that can be false  is computed by an iterative dataflow analysis. the first approximation is the initial condition; at each step any fluents in the effects of actions that can fire  given the current approximations  are added to the sets. this process is guaranteed to terminate and is not tantamount to solving the planning problem since time is ignored  thereby permitting impossible situations  like the presence of a fluent and its negation. 
¡¡the cnf simplification step is also quite important  since it is fast and can reduce the formula size enormously. though cnf simplification operates without knowledge of the structure of the problem  its effects are similar to some of the optimizations listed above. for instance  it can do much of the type elimination described above. however  performing these steps earlier can reduce encoding time by a factor of four or more due to generation of smaller formulae. further  these optimizations can often allow the simplifier to reduce a formula more than it otherwise could. 
optimization and factoring 
factored action representations reduce the benefit of these type optimizations. when performing factored simple splitting  only unary types can be eliminated  since their effect is restricted to  and fully reflected by  just one of the newlyintroduced action predicate symbols. binary types such as  cannot be eliminated: consider a binary operator a which takes two non-equal arguments. given two objects a and b  only two instantiations are possible  but since the new action can each take 
either a or b as an argument  it is necessary to leave the axiom in the encoding to prevent the illegal argument combinations. 
¡¡overloaded action representations do not admit elimination of even unary types  since a single action fluent represents the nth argument to many different operators with different constraints. 
1 	searching for the m i n i m a l plan 
so far we have assumed that one is trying to find a plan of known length  but in general the plan length is not known in advance. the medic planner is capable of both linear and binary search on plan lengths.1 our encodings support the linear search strategy without any modification. to implement binary search for the minimal plan length  we include an explicit no-op  maintain  action when using classical frame axioms. this allows plans longer than the minimal length to succeed. 

figure 1: numbers of variables  clauses  and literals in simplified cnf formulas resulting from each of eight encodings  plus the satplan hand-encoding  sans domain-specific axioms . values reported as 1 are actually 1: that is  the cnf simplifier solved the problem. times ¡¡because walksat is stochastic  finding a minimal length plan requires a systematic solver such as tableau instead of  or in addition to  walksat. for even moderately-sized problems  however  tableau can take an unreasonably long time to verify that no solution exists.  such verification is moot less than one tenth second are reported as one tenth. 
when trying to find any satisfying plan rather than the shortest one.  
1 	experiments 
to test the various encodings  we encoded a suite of planning problems using each of the eight encodings. factoring was applied when split action representations were used. figure 1 plots the number of variables  clauses  and literals in the final simplified cnf formulae. 
¡¡figure 1 also reports walksat solution1 times  averaged over five runs   but note that timing data is hard to interpret. walksat is not always the fastest solution method. we used the suggested walksat flag settings from the satplan planner  but these flags might favor some encodings over others. the timings reported in  kautz and selman  1  are each minima over many walksat runs with varying parameter values. it is believed that solution time correlates with cnf size  
¡¡¡¡1 we do not report encoding or simplification times  which for medium and large problems are dominated by solution time. 
1 	planning and scheduling 
but automatically determining which solver flags are best for a particular problem is an open problem  selman et a/.  1   though progress has been made recently  mcallester et a/.  1 . 
¡¡from the asymptotic size bounds of figure 1 one would expect the bitwise encodings to have the smallest number of variables and the regular encodings to have the largest number of variables. surprisingly  neither expectation was fulfilled. 
1 	the smallest encodings 
the two smallest encodings are the regular and simply split explanatory encodings  and these encodings had quick solve times as well. these successes bring to light several interesting points about the relative merits of the encodings. 
¡¡first  it is clear that explanatory frame clauses are superior to classical frame clauses. explanatory frames are smaller because they only state what changes  rather than what does not change  when an action occurs. in general  we expect each action to affect relatively few fluents. 

   parallelism is also a big advantage  as shown by the success of the regular explanatory encoding . since parallel plans have shorter length  the formula contains fewer copies of the periodic axioms. additionally  conflict exclusion axioms are a subset of complete exclusions  which prohibit all pairs of actions. conflict exclusion only excludes pairs of actions that would not be otherwise excluded but should be in order to guarantee the existence of a linearization of the partial order plan returned. 
   it is quite surprising that the regular explanatory encoding has so few variables.  kautz and selman  1  dismiss this encoding as impractical. while its size can blow up prohibitively in the worst case  see figure 1   in practice the encoding maintains excellent variable and clause sizes. and it remains competitive even as problems increase in size  e.g.  problem sequence log1  logl  ...  loga . we suspect the compiler's type optimizations  which are handicapped by factored splitting  deserve the credit. 
1 	the largest encodings 
the two worst encodings are the regular and bitwise classical encodings. we have already mentioned the superiority of explanatory to classical frames. regular classical is outperformed by the two split classical encodings. worst-case splitting clause sizes can be much bigger than the regular encoding  but in practice factoring seems to keep the sizes competitive. splitting also may provide the simplifier with more flexibility  allowing it to deduce more  because it can reason about parts of actions instead of only about fullyinstantiated actions without hope of generalizing. finally  these encodings are also aided by the great decrease in the number of variables as compared with the regular encoding. 
   on the other hand  the bitwise encoding  which has the smallest number of variables before simplification  is the worst encoding of all. simplification is relatively ineffective on this encoding  as other encodings have fewer variables after the simplification phase. this may be related to the fact that bitwise uses one set of variables to encode all possible actions in the domain  thereby making it next to impossible for the simplifier to reason about the truth values of these variables. finally  the graph of number of literals points to the obvious blow-up that bitwise incurs in exchange for the small variable size. 
1 	comparison w i t h satplan 
although our encodings cannot be expected to be as compact as the hand-made satplan encodings  our best encodings are surprisingly competitive. the first seven problems of figure 1 include a ranking for the satplan direct encoding of the problem  from which domain-specific axioms  see section 1  have been removed for purposes of comparison. our best encodings actually outperform the satplan encodings on two of the smaller problems  as the simplification process is able to satisfy our formulas completely. as the problems get larger  the satplan encodings begin to dominate. however  our best automatic encoding appears to be always within a factor of two of the satplan size. 
1 	type optimizations 
type optimizations can substantially reduce formula size: figure 1 compares formula sizes with and without these optimizations. these numbers understate the benefits of the optimizations  because they do not include data for problems that were too large to solve without type optimizations 
regular simple-overloaded bitwise classical .1 .1 .1 .1 explanatory 1 .1 .1 .1 figure 1: ratio of simplified formula size with type optimizations to simplified formula size without. the numbers reported are averages over seven problems of the ratios for variables  clauses  and literals  which are always within .1 of the average and usually 
closer. c assical explanatory simple overloaded simple overloaded variables .1 .1 .1 .1 clauses .1 .1 .1 .1 literals .1 .1 .1 .1 figure 1: ratio of simplified formula size with factoring to simplified formula size without. 
but could be solved with them. the optimizations are critical for the classical encodings  cutting their size by about two thirds. however  these optimizations are much less effective on explanatory encodings. in fact  the optimizations appear to be superfluous for the regular explanatory encoding: the cnf simplifier obtains all of the type optimization benefits without considering the structure of the problem  using only the resulting formula. 
   these contrasts may be attributable to the way in which the simplifier interacts with the various encodings. classical encodings are much more constraining than explanatory encodings  because they explicitly enforce all truth values at time t -f 1 when an action occurs at time t. this rigidity may make it hard for the simplifier to reduce the encoding size  thereby relying more heavily on the type optimizations to make deductions about the encoding. the regular explanatory encoding  which uses conflict exclusion  is the most flexible of all of the encodings. therefore  it seems that any static optimizations that we make are easily teased out of the encoding by the simplifier. 
1 	factoring 
   figure 1 shows that factoring makes a big difference compared with unfactored splitting. while factoring does not reduce variable size at all in the base encoding  it does lead to small drops in variable size after simplification. factoring's big effects  however  are in clause and  especially  literal size. this is important  because this reduction is precisely the reason that we introduced the idea of factoring. although in the worst case  factoring has no effect  it is clear that factoring is critical in practice. 
1 	domain specific axioms 
   the  direct  encodings of  kautz and selman  1  provide hand-coded  domain-specific information which is impossible to specify in terms of strips actions but is natural when writing general logical axioms. for example  in their blocks world problems kautz et al. state that the relation on is both non-commutative and irreflexive  only one block may be on another at any time  every block is on exactly one other object  blocks can't be both clear and have something on them  and the table is never on anything. to determine how much  if at all  this additional information affected the planning problem  we removed these domain-specific axioms from the at&t encodings and compared the size and speed of the resulting sat problems. as figure 1 shows  eliminating the axioms decreased the number of clauses  but increased the number of variables  presumably because unit-clause and 
	ernst  millstein  & w e l d 	1 


figure 1: at&t's hand-coded domain-specific axioms led to more clauses  fewer variables  after simplification   and substantial speedup. each problem was run five times on an sgi indy with walksat settings: tries 1  noise 1  and cutoff set to the number of variables 

squared. solve-time standard deviations are reported as a. 
pure-literal simplification was less effective . without the domain-dependent axioms  the planning problems took substantially longer. these results suggest it would be useful to investigate whether a compiler could deduce some of these axioms automatically. we believe our type optimizations to be a good start at achieving this goal. 
1 	conclusions 
this paper makes several contributions: 
  we develop a simple framework that generates eight ma-jor encodings  which account for all of the non-causal a t & t encodings as well as several novel ones. in particular  the introduction of overloaded splitting and the bitwise representation  combined with the regular and simply-split encodings  creates a spectrum of choices highlighting the tradeoff between variable and clause sizes. 
  we describe an automatic compiler that takes classical strips planning problems and generates sat problems using all of the above encodings. our compiler includes many interesting features  including a type inference and optimization mechanism. 
  we use the compiler to perform an empirical analysis of tradeoffs in the space of encodings. we show that explanatory frames and conflict exclusion are dominant  and regular acton representation is surprisingly effective. 
   many exciting problems remain. clearly we need to better investigate the solve-time characteristics of the encodings. automatically generating domain-specific axioms  such as those in section 1  is a promising direction. we also hope to investigate additional type inference methods. there are also many hybrid encodings which would be interesting to explore. allowing inter-operator parallelism in the simplysplit explanatory encoding could take advantage of both of the best encodings.  as mentioned earlier  simple splitting prevents the possibility of parallel instantiations of the same operator  as their split variables will interfere.  another hybrid option is the addition of  action  variables  similar to those of overloaded splitting  to the simple splitting encoding. these extra variables can greatly compact many parts of a factored split encoding. a third hybrid would use bitwise representations for the split fluents of simple or overloaded split actions  avoiding the disadvantages of the bitwise action representation while reducing the number of variables. one can also imagine compiling part of a domain theory with one encoding and using a different encoding for other parts. finally  it would be interesting to automate the a t & t statebased encodings and to integrate their causal encodings into our framework. 
1 	acknowledgments 
jared saia  nick kushmerick  and marc friedman contributed to our implementation and testing framework. david smith made many insightful observations that led to 
1 	planning and scheduling 
a major reformulation of our encoding space. bart selman  david mcallester  and henry kautz engaged in helpful discussions and kindly provided their satplan code. jimi crawford provided tableau code. 
