comparison of methods for improving search efficiency in a 
partial-order planner * 
	r a g h a v a n s n n i v a s a n 	a d e l e e 	h o w e 
computer science department 
colorado state university 
fort collins  co 1 
	net 	{srinivas howe} cs 	colostate edu 

a b s t r a c t 
the search space in partial-order planning grows quickly with the number of subgoals and initial conditions  as well as less countable factors such as operator ordering and subgoal in teractions for partial-order planners to solve more than simple problems  the expansion of the search space will need to be controlled this paper presents four new approaches to controlling search space expansion by exploiting commonalities in emerging plans these approaches are described in terms of their algorithms  their effect on the completeness and correctness of the underlying planner and their expected performance the four new and two existing approaches are compared on several metrics of search space and planning overhead 
1 	i m p r o v i n g search e f f i c i e n c y in 
p l a n n e r s 
partial order planning is becoming a common method of planning unfortunately but hardly unexpectedly  the search space in partial order planning expands quickly as the problem size increases unfortunately but less expectedly search space expansion is dependent on a  anety of factors some of which are difficult to predict a problem that was solved in short order may be made impossible to solve in reasonable time simply by adding an innocuous looking new goal  by changing the ordering of goals or even by adding a few more objects to the problem initial state 
　more graceful degradation of performance can be achieved by identifying aspects of the planner most susceptible to the problem changes and developing methods to ameliorate the search space expansion this paper 
　　this research was supported by a national science foundation research initiation award #ria iri-1 and arpa-afosr contract f1-c-1o we also wish to thank the anonymous reviewers for their suggestions for im 
proving content and clarity 
1 	planning 
presents four new approaches for improving efficiency in a partial order planner by exploiting commonalities between proposed plane during two phases of planning flaw selection and plan refinement these approaches are described in terms of their algorithms  their effect on the completeness and correctness of the underlying planner and their expected performance when compared to two existing approaches finally the new and existing approaches are compared on several metrics of search space and planning overhead 
　the goal of this project was to determine why it could be so hard to design efficient problem descriptions  or ucpop  a partial order planner we found that what seemed like trivial problems could not be solved in reasonable time indeed minor variations on the same problem led to ucpop's being unable to solve the new problem using a variety of analysis methods we deter mined that the primary fault lay in ucpop's selection of flaws to repair and additions to the plan to repair the flaws three approaches have been used to enhance search in planning more sophisticated plan representations and reasoning  e g hierarchical planning and re source reasoning as in  tate et at   1 wilkins  1   domain specific control knowledge  through programmer intervention or machine learning  and improved search methods we focused on the third approach because jt requires the least change to the underlying planner 
　we used ucpop because it is an easily available  domain independent partial order planner  penberthy and weld  1  ucpop plans by iteratively selecting and repairing flaws in the current plan a flaw is repaired by adding steps and constraints to the plan the search control strategy decides which partial plan to select for expansion in general  u  pop gives good results on small domains and problems in which subgoals are in dependent for problems with interrelated subgoals or those requiring arithmetic  ucpop often does not hnd a solution even with very large search limits 
   the least cost flaw repair  lcfr  strategy  joslin and pollack  1  improved search control in ucpop by selecting the flaw with the minimum repair cost the repair cost of a flaw is defined as the number of plans 

generated to repair it open conditions and threats are treated alike the main drawback of lcfr is the overhead incurred for flaw selection the total time spent in planning with lcfr can be more than that for ucpop  even though ucpop examines far more plans than lcfr however  lcfr reduces the search space more than other flaw selection strategies  peot and 
smith 1  
　a variant on lcfr  qlcfr  joslin and pollack  1   assumes the cost of un-repaired flaws to be constant over time it caches the results of estimating flaw repair costs and uses the cached cost as the estimate in subsequent flaw selection qlcfr reduced the overhead of lcfr  but at a cost of solving fewer problems 
1 	s i m i l a r f l a w s a n d l c f r   t e m p l a t e s   
lcfr is expensive because it estimates separately the cost of repair for every flaw in ever  potential extension to the current plan however  in most problems flaws can be similar they involve the same type of condition and are amenable to repair by the same fix for example  flaws in the blocks world domain are commonlj of the form  on 'x 'y'  or  clear  x  the resolution of any flaw of these forms is likely to be the same  e g   add an action to move the indicated block   hence  we can expect the cost of flaw repair to be roughly the same for flaws with similar forms 
　c onsequently  we exploit the similarity in flaws to reduce the number of repair cost estimates to be made in particular we assume that at a particular stage of plan refinement  the repair cost is the same for all similar flaws other than this approximation  repair cost is the same as that of lcfr scheme 
　qlcfr also approximated the repair cost of flaws by estimating once and re-using the estimate the difference between our approach and qlcfr is that qlcfr cached the estimate and re-used it in subsequent plan refinements rather than applying it to similar flaws at the same point in plan refinement our approach allows recenlly acquired information to be incorporated in 
estimating cost 
　the first step towards deciding how to change a developing plan is to identify and group together identical open conditions in the plan two open conditions are said to be similar if they have the same predicate for example   prad 1  x  and  predl  y  are similar a set of similar open conditions with predicate p are said to form a template p all of the open conditions in a plan can be grouped into a set of templates 
　we assume that when open conditions are similar the order in which they are selected for repair does not matter thus  the repair cost of a template is estimated by finding the repair cost of the first member of the template 
　this approach approximates only the cost of open conditions threats are not easily grouped because they do not involve variable bindings thus  similar threats often do not have similar resolutions and are often resolved as a side effect of repairing some other flaws consequently  a uniform repair cost would not be a reasonable approximation of the actual costs 
　open conditions are considered only if a plan does not have any threats if a plan has threats  the one with the minimum repair cost is selected  otherwise  the first member of the template with the minimum repair cost is selected 
1 	expected performance 
we expected that the average number of plans examined before finding a solution in this scheme should be comparable to that of lcfr  while the overhead should be much less than that of lcfr overhead is defined as the number of extra plans created in service of estimating flaw cost since only a subset of the open condi tions are evaluated in the templating approach  on the average its overhead should be less than that of lc fr however in the worst rase  the templating approach can incur more overhead than lcfr when the estimate for one member of the template does not generalize to the rest potentially causing additional backtracking empirical performance is reported in section 1 
1 	correctness and completeness 
because only flaw selection is modified the correctness and completeness of uc pop is maintained by the templating approach 
1 	templates w i t h repair reuse 
with templates open conditions are grouped to estimate repair cost we extend this idea to the next step selecting  or reusing  similar actions to add to repair similar flaws consequently  given that an action is added to the plan to repair a flaw of a particular type  another instance of the same action can be added  at the same time  to repair another flaw of the same type this sense of reuse is much more limited and local than what is typicallv meant by plan reuse  eg    kambhampati and hendler  1    it is constrained to reusing the occasional step within a plan being developed 
　consider a plan p with a set of flaws f f can be grouped into a set of templates t = {t1 t1} tm  each t  consists of a set of similar flaws let tmin  1   mm   m  be the template with the minimum repair cost the first flaw in the t m i n set  /min. 1  is selected for repair  and a set of new plans p' are generated let p's be a subset of p' such that each plan in p1 includes a new plan step for repairing fmin 1 for each plan in pi  a set of new plans are generated in which some of the flaws of type t m i n a r e repaired by adding another instance of an action added f o r r m i n | 
　two values are returned the plans in which all flaws of type tmim are repaired by adding the same type of 
	srinivasan and howe 	1 

action  and the plans  in which some but not all flaws are repaired this way we require the second value to facilitate backtracking as with the basic templating scheme  not all flaws of a similar type require the same cost or action for repair  e g   some might be satisfied bv initial conditions  consequently  the first set of plans are added to the search queue and the second set is stored in the event oflater backtracking 
1 	expected performance 
two opposing factors were expected to affect the performance as measured by plans examined and overhead if reuse is successful most of the time  then both plans examined and overhead will be less  however  if new threats are introduced due to reuse  repairing them will cost more in terms of plans examined as well as overhead the worst case will occur when an early attempt to reuse is inappropriate  leading to considerable backtracking as a consequence  we expected the success of this approach to be highly problem/domain dependent 
1 	correctness and completeness 
any newly added plan step may introduce threats for each of the flaws in template t m i n   a se' of new threats could be introduced however  all of these introduced threats w ill be detected thus  the final solution will still be correct in addition the backtracking facility insures that if a solution exists  it will eventually be found consequently  completeness and correctness are maintained 
1 	probabilistic reuse 
templating and reuse can be viewed as approaches in which plan repair reuse is applied with probability 1 and 1 respectively because we suspect that plan repair reuse is not always the best strategy  and cannot currentjy recognize when it is and is not the best strategy   we can define an approach in which reuse is applied with some probability p 1   p   i intuitively  some p exists for which the performance will be better than that of templating or reuse this value can be determined empirically obviously  the value of p depends both on the problem and domain we hypothesize that p should be small non-zero value  and so determined it empirically for all tests  the same value of p  1 was used 
1 a d d i n g a n e w construct to the plan language   b a n g - u c p o p   
the previous approaches all altered the control of plan expansion within the planner only one alternative is to make the plan language more expressive of constraints known by the user a simple constraint is that multiple inclusions of the same operator within a single plan should be instantiated to different objects within the environment this hard constraint us a simple form of the resource reasoning included in more sophisticated planning systems 
1 	planning 
　we developed this approach to address problems discovered when analyzing the behavior of ucpop in truck world  hanks et a/  1   a simulator of trucks moving cargo between different destinations  ucpop fails  i e   could not find a plan even given a large search space  on apparently simple conjunctive subgoal problems in truckworld a typical example is 'bring 1 fuel drums from outside the truck and fill the fuel tank   because the size of the search space increased dramatically with the order and number of identical subgoals  we hypothesized that the number of identical fuel drums needed and available might lead the planner to starch unnecessarily for the right binding of fuel drums in the right order 
　we studied the behavior of ucpop in truckworld bv collecting execution traces of ucpop working on truckworld problems with similar conjunctive sub-goals us ing clip  anderson et a/  1   an instrumentation tool for defining and running data collection routines in a simulated environment   we collected data on what plans were generated  how certain open conditions were repaired what threats were considered  and what van able bindings wen used 
　we analyzed the data with a variety of methods from simple eyeballing through dependency detection 
 howe and cohen  1   and determined that in effect  ucpop was searching in circles trying the same variable bindings over and over again for example consider the problem of picking up two identical fuel drums from a world which has five such drums to repair the first open condition  i c   picking up the first drum   a set of five possible plans are generated for the second drum  a similar set of plans is generated  with one of them trying to reuse the first step to get the first drum this results in a threat next  ucpop tries binding a new value for the first flaw it continues to try pairs of identical bindings before it finds two unique binding values that can repair both the open conditions most of the search time is wasted in trying the same values for variables that require different values thus  the plan language needs a construct to indicate to ucpop that it should use different variable bindings for certain variables  so that it can converge on the solution much faster 
1 	scheme d e s c r i p t i o n 
for this scheme  a new language construct which creates a  special variable is introduced bindings of such a variable are treated differently  in particular  the plan ner will ensure that if a binding value is needed for the special variable it will differ from that used in all previous instances of this operator in the current plan moreover if more than one of such bindings are possible  only one plan using exactly one value ls created  plans for other possible unique values are saved in the event of backtracking 
a special variable is denoted by the prefix ' '''  hence  

 define  operator pick-drum  parameters   ant   pos   arm  precondition  and  outside  ann  
                      drum-it pos  amt   effect  and  not  drum-at  pos  ant   
	 amount-in-am 1arm 	1amt    
figure 1 ucpop operator for truck world that illustrates the use of a bang variable  1 'pos 
the name sang- ucpop for this approach  bang variables art treated differently only during binding currently  only one such variable per plan operator it al lowed  in order to minimize the complexity of resolving which variable binding resulted in a threat another re striction is that two operators that clobber each other should not use the same type  as defined by the plan domain  of special variable 
　special variables have a curious but useful side effect on repairing threats for example  given two instances o    1 and os  1 of the same operator o   and let ps he the special variable parameter in its operator  then the new scheme ensures that unique values will be used for p  in q 1 and o   1 under the normal planning process  an unsafe link may be introduced due to o   1  but now there is no threat hence  the planner marks this threat as bogus and removes it this saves time that otherwise would be wasted on resolving such threats 
   figure 1 shows an example of an operator which uses a bang variable the operator comes from the truckworld domain and is one of the operators needed to refuel a truck the bang variable   pos  indicates the portion at which the fuel drum is stored multiple fuel drums are typically required to refuel a truck thus a plan may include multiple instances of this operator each referring to a different fuel drum in a different location bang is ideal for this situation because we do not wish to attempt to pick up the same fuel drum repeatedly during refueling we can only gainfully empty it once 
　unlike the other approaches this approach required considerable change to the algorithm for linking in new actions to plans to expedite backtracking the algorithm caches alternative unique variable bindings and search control maintains two search queues when a planning failure occurs  it moves a plan from the most recent backup list into the primary search queue and continues the modified algorithm is shown in figure 1 
　plan language constructs for restricting 1earch space are available in some hierarchical planners for example  1-plan1  tate ti al  1  uses condition types which allow the domain writer to restrict selection of actions as well as to bind variables the 'onlv use for query' condition type of o-pian1 resembles the bang scheme but differs in the situations for which it is the best approach the bang scheme is most effective when the plan-linkjng open-cond  step  current  plan-list = null more-plans = null 
  let v be the variable in open-cond to be bound 
while binding-exists v  if  special-vanable v   find a binding not used in other instances 
b = unique-binding v    tf a binding can be found generate plans if  b '= null  
current = make-plan b open-cond current  
else current = null 
  add to plans for backtracking if  plan-list ' = null  more-plans = add  current  more-plans  current = null 
else   find a binding with normal methods b = binding v  current = make-plan b open-cond current  
if  current '= null  
plan list = add current plan-list  
return current plan and list for backtracking 
return plan-list  more-plans 
figure 1 algorithm for linking in new plan actions under the. bang-ucpop approach 
number of binding values is large and no one is preferred only use for query cannot be applied in specific actions and does not look for previous bindings used 1 other instances of the current action an over indulging 1plan1 condition type can result in the planner throwing away valid plans  whereas bang stores all plans for later backtracking i he bang scheme can be modified to selectively recognize bang variables at the problem level in 1-plan1  the condition type information is built into the domain specification 
1 	expected performance 
best case performance in terms of number of plans examined  occurs when problems have identical conjunctive subgoals and when the first variable bindings do not need to be retracted later the worst case performance occurs when the unique values selected early do not satisfy all the subgoals  thus requiring backtracking this approach 's expected to do much better than other ap proaches for domains with many possible bindings lo the same variables  as in the motivating truckworld example in other cases  this approach may incur additional backtracking and thus additional computation because the new constraint does not help 
　the major drawback of this approach is that it requires user intervention the user must know when to use bang variables in a domain description  e g   when it is expected that problems will contain multiple conjunc-
	srinivasan and howe 	1 

tive sub-goals involving the same types of objects  
1 	correctness a n d completeness of 
a p p r o a c h 
to make sure that we have not violated the correctness and completeness of the underlying planner  we need to prove that when special variable operators are used  every answer is a correct solution to the planning problem and that if a solution exists it will eventually be found the proof consists of three parts 
1 even though the algorithm is limited to only one binding value for a special variable  backtracking is still permitted and thus completeness is preserved 
1 when special variables are bound to values from goal terms  then correctness is preserved 
1 when special variables are bound to particular unique values  marking threats as bogus when they are due to different instances of the same special variable operator does not affect correctness 
the correctness and completeness of ucpop has already been proven  penberthy and weld  1   so we will show that all these cases are reducible to ucpop if ucpop cannot find a solution  e g if enough unique values do not exist   then neither can our modification a complete proof is beyond the scope of this paper  see  srinivasan and howe  1  for details   but we can provide a sketch of each part 
part 1 backtracking if a special variable is included in a new plan refinement  then the inclusion will cause a single new plan to be added to the search queue with all other possible plans being put onto a 'reserve  queue should later plan refinements led to a failure  then the next possible plan from the reserve queue can be moved into the search queue and plan refinement continued from there thus  no potential plans have been pruned irretrievably backtracking and thus completeness is preserved 
part 1 goal terms when special variables are bound to values from goal terms then no searching needs to be done for variable bindings thus  the operator incorporating the special variable is treated just like other operators  and correctness  as in the original scheme  is preserved 
part 1 bogus threats in ucpop threats are detected when two conditions in the current plan have the same predicate  e g   the  clear  condition from blocks world  in bang-ucpop  if the threat involves a special variable that was not bound as part of the goal term  whose correctness was proven in part 1   we know that no such threat actually exists because the two conditions have been instantiated to different variables therefore  such a threat can be marked as  bogus  this does not 
1 	planning 
affect backtracking because if the variables are not special then the normal rules of binding in ucpop hold 
1 	c o m p a r i s o n of a p p r o a c h e s 
in this paper  we have defined four extensions to two current approaches  vanilla ucpop and lcfr in ucpop  for controlling plan search in a partial order planner we expected the new approaches to perform significantly better than lcfr or ucpop in some domains/problems the goal of the comparison was to determine which of the six approaches works best in some common planning problems 
　three performance metrics were collected number of plans examined before reaching a solution  overhead incurred in terms of the number of plans created for flaw selection  and cpu time on average  we expected that the four new approaches  templating  reuse  probabilistic reuse and bang-ucpop would compare favorably to lcfr on plans examined but would have less overhead and so require less cpu time a complete report of results in provided in  srinivasan and howe  1  
1 	e x p e r i m e n t design 
the six approaches were tested on 1 problems in ten domains the same set of problems without any modification is used for all versions most of the problems are from the example domains provided with ucpop and tested in joslin and pollack s research with lcfr four of the problems are from the truckworld domain  hanks et al 1   all of which require picking up fuel drums  the four differ in the number of subgoals and arm positions in all the domains some of the operators were modified to include a special variable parameter for bang-ucpop because most of the domains are small in size  only one special variable operator was used all tn als were run on the same sparc ipx workstation in the same version of common lisp 
　for all cases  the search limit was restricted to 1 plans examined a failure was reported only when no possible plan could be found within that limit 
1 	results 
the results are reported in tables 1 thru 1 table 1 presents the number of problems within each domain that were solved by each approach the domains were blocks world  a   truck world  b   robot domain  c   
monkey and banana  d   briefcase world  e   russell's 
the world  f   fridge domain  g   strips world  hi 
office domain  i   and others  j  table 1 lists the average number of plans examined by each approach in problems within each test domain  this corresponds to how much of the space was explored during plan refinement table 1 lists the average number of plans created for flaw selection  which included those created to estimate cost  for each approach in each problem domain  ucpop and bang are not included because they do not 

table 1 average cpu time in seconds  all problems 
　in terms of overhead  the performance of the probabilistic reuse scheme is usually lower or comparable to the approaches other than bang this implies that if proper criteria  mostly likely domain and problem dependent  for reuse can be determined then the search space can be reduced greatl  
　bang-ucpop incurs no overhead  its cpu time is the minimum in all but three domains however  it appears 

table 1 average overhead number of plans created for all problems 
create any plans for flaw selection finally as a crude estimate of both factors incorporated in the previous two measures and those not average c pu time is provided in table 1 
　table 1 shows that lcfr solves the largest number of problems however  the four new approaches solve all but one or two of those solved by lcfr all approaches solve considerably more problems than ucpop 
　in terms of number of plans examined  we expected the performance of the four new approaches to be comparable on average to lcfr and better than ucpop the data  in table 1  shows that the average case performance is comparable in about half the domains  with the 'best  average  numbers in boldface  for each domain distributed among the approaches in all but a few cases  lcfr and the four new cases offer either a comparable number of plans examined or a reduction over ucpop 
　while plans examined was expected to be comparable or worse than lcfr  we expected the overhead 1o be significantly lower for the new approaches in fact  the overhead  table 1  and cpu time  table 1  data suggest that lcfr is quite costly in comparison to the other approaches for problems with no solution  lcfr expends the most effort before reporting a failure all other approaches report failure as early as possible only in the blocks world problems does lcfr out-perform the other approaches 
to be problem dependent  rather than specifically domain dependent and so should be applied based on the type of problem rather than applying it for every problem in the domain the primary cost of bang-ucpop is the storage of certain nodes to allow back tracking if the unsmtability of certain plans can be detected very early  the search space explosion to support backtracking can be controlled 
　our template scheme assumes that the order in which similar open conditions are selected for repair does not matter we tested this assumption by running experiments in which flaw selection from a template is randomized the results showed no significant difference between open conditions selected randomly versus simply taking the first flaw from the template 
1 	conclusion 
not too surprisingly  no one approach seems to be best  solving all possible problems as efficiently as possible each solution seems to have its pros and cons  favor ing some domain or problem within a domain though lcfr is able to solve many problems with far fewer plans examined than ucpop  the cost of doing so  in terms of overhead  can be quite high the four approaches described in this paper solved more problems than ucpop  almost as many problems as did lcfr  and usually incurred far less overhead than lcfr additionally  the results of bang-ucpop suggest that flaw selection alone is not adequate for efficient planning 
　however  these approaches and this comparison are barely a first step we need to model why different approaches work better in different domains and problems such models will help determine which approaches to 
	srinivasan and howe 	1 

apply in which situations and to design new methods for example from the execution traces of ucpop  we observed that reordering sub-goals or operators in the domain strongly affects the amount of search required to solve problems in particular  some orderigs lead quickly to a solution while others appear to cricle a flaw selection strategy partly eliminates this problem  but at great expense if we can identify what plans or orderings will lead to cycles  then we can modify plan refinement to prune those plans early in the planning process 
　the two limited reuse approaches performed well on problems with related sub-goals one simple improvement to probabilistic reuse could be to make the probability a function of number of flaws in the plan with reused steps for example  if the number of threats introduced by applying reuse is more than that introduced by solving the minimum cost flaw  the probability of reuse should be reduced a better way is to use more knowledge about the domain and problem to decide on step reuse rather than applyig reuse with some probability we should be able to identify long sequences  sub-plans  and solve similar flaws together rather then considering them separately for example  in truckworld  when the truck tries to pick up fuel drums to fill its fuel tank it can pick up other objects it needs since the sequence of steps are same 
　considering the time reported to solve even a simple problem the problem of scaling up to larger problems is daunting based on this small exploration of methods for improving plan generation efficiency we need additional methods for constraining the search space in partial order planning and language constructs to incorporate known constraints most importantly  we need to know how domain dependent problem characteristics lead to inefficient exploration of the search space 
