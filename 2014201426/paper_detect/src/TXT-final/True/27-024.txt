 
inductive logic programming  ilp  is often situated as a research area emerging at the intersection of machine learning and logic programming  lp  this paper makes the link more clear between ilp and lp  in particular  between ilp and abductive logic programming  alp   1 e   lp extended with abductive reasoning we formulate a generic framework for handling incomplete knowledge this framework can be instantiated both to alp and ilp approaches by doing so more light is shed on the relationship between abduction and induction as an example we consider the abductive procedure sldnfa  and modify it 
into an inductive procedure which we call sldnfai 
keywords 	inductive 	logic 	programming  	abductive 
logic programming  incomplete knowledge  intensional knowledge base updating  theory revision 
1 	i n t r o d u c t i o n 
it is often argued that the use of - a subset of - first order logic as a representation language situates inductive logic programming  ilp  at the intersection of logic programming and machine learning the research in 
ilp ib concerned with the derivation of logic programs from  positive and negative  evidence in the presence of background knowledge characteristic for this approach is the use of induction  i e   a form of synthetic reasoning that infers general laws from observations  muggleton and de raedt  1  reviews theoretical results  implemented systems and practical applications in this area two major problems tackled in ilp are predicate learning and theory revision the former is concerned with the induction of rules for an undefined or partially defined predicate from examples  whereas the latter concerns the updating of a theory  a logic program  when it is inconsistent with newly incoming information prototype systems are - amongst others - the predicate learnera mis  shapiro  1   foil  qumlan  1   golem  muggleton and feng  1   clint  de raedt  1   and the theory revision systems rx  tankitvanitch and shimura  1   kr-focl  p bieani and brunk  1l  and ruth  ade et al  1  
　in the area of logic programming  lp  abduction has been recognised as an important form of non-monotonic reasoning it ib a form of synthetic reasoning  which - as opposed to induction infers explanations for observed facte  according to known  general  lawh abduction has been shown useful for fault diagnosis  charmak and mcdermott  1   planning and temporaj reasoning  denecker et al  1  and knowledge assimilation  kakas and mancarella  1   and it has also been successfully applied in intensional knowledge base updating approaches such as  bry  1    kakas and mancarella  1  and  guessoum and lloyd  1  a critical survey on the extension oflogic programming to perform abductive reasoning can be found in  kakas et al  1  
　in this paper we argue that both abduction and induction are different  yet related forms of reasoning on incomplete knowledge they are both forms of hypothetical reasoning and attempt to  complete  the knowledge by proposing additional hypotheses however  they differ in the sort of hypotheses 
　according to the  declarative semantics   a logic program can be seen as a bet of definitions for a number of concepts this interpretation is already present m clark's work on completion semantics  clark  1  under clark's interpretation  a program consists of a set of possibly empty definitions for all predicates  predicates are defined by enumerating exhaustively the cases in which they are true under this interpretation  a problem with the use of logic programs for knowledge representation  is that an expert needs to provide complete definitions for all predicates in many applications  such complete information is not available a natural solution ib to extend the logic program formalism such that only a subset of the predicates is to be defined while other predicates can be left undefined in addition  partial knowledge about these undefined predicates can be given using fol axioms the role of these fol axioms is intimately tied to the representation of uncertainty when a number of concepts cannot be defined  then other  less precise information may be available which can be represented as a set of assertions e g   if the predicates father/1 and mother/1 are declared as being undefined  the axiom mother x  v father x   - parent x  expresses the weaker partial knowledge that it cannot be the case 
	ade and denecker 	1 
that someone is a parent without being a mother or a father 
　the actual procedures for  completing  incomplete knowledge developed in the alp and ilp area  are as to be expected - quite different the alp approaches construct hypotheses in the form of ground facts for the undefined predicates these factb are seen as the description of a scenario that explains a given observation as opposed to this  ilp systems in general - even in case of a specific-to-general search - disallow facts the hypotheses they generate are sets of rules that express general - scenario independent - information on the undefined predicates ab such an alp approach is appropriate when the expert has great confidence in his general knowledge  but wants to find a concrete explanation for an observation on the other hand  an ilp approach is more appropriate when the expert searches for general rules that compact the positive and negative evidence  and that later can be reused to classify new examples 
　a first step towards integration of techniques from both domains was taken by  de raedt and bruynooghe  1  de raedt and bruynooghe argue that - when reformulated within a logical framework - both intenbional knowledge base updating and predicate learning are instances of the belief updating problem as a proof for this claim they present an adapted version of shapiro's mis system in which techniques from both parent domains are integrated these ideas were later further elaborated and implemented in the theory revision system ruth  ade et al  1  
　the contribution of our work is that we reformulate the alp and ilp approaches as instances of a generic version of bry's framework  bry  1  for intensional knowledge base updating in doing so we show that there is a clear relationship between inductive and abductive reasoning moreover  this setting enables ub to introduce inductive reasoning into an abductive schema  thus resulting in a betting which one could call abductive inductive logic programming  ailp  as an example we transform a typical abductive procedure  namely sldnfa into a new procedure sldnfai  sldnfa-with-
induction  by enhancing it with a general-to-specific procedure for inducing clauses furthermore  this enhancement could also be beneficial for the ilp approach  since sldnfa is a procedure for normal clauses  whereas the ilp setting used to be restricted to definite clauses 
　this paper is organized as follows in section 1 we introduce a generic framework that formalizes different forms of hypothetical reasoning on incomplete knowledge in section 1 we map both the alp and ilp approaches to this framework  and discuss the similarities and differences in section 1 we elaborate an abductive procedure for ilp  by introducing inductive reasoning into the abductive procedure sldnfa finally  in section 1 we formulate our conclusions 
1 	p r o b l e m f o r m a l i z a t i o n 
intuitively one can outline the problem of handling in complete knowledge as follows given is a logic program p  which is declaratively read as the descnption of the problem domain one part of this program is regarded 
1 	learning 

　in  bry  1  a non-horn theory jv for the metapredicate new is defined in terms of operations on the object program facts and clauses in definition 1 we give a 'generic' version of this theory  in that we replaced the actual operations on the object program by the predicates eval.pos-atom and cvalneg.atom that are to be instantiated the rules rely on a meta-predicate clause that ranges over the clauses of c p  defining the 
predicates that are not in u{p  more specifically  define clause p  as the meta program consisting of factb clause a  - b  for each rule a ＊*- b in c p  and of facts undefined a  for all atoms a containing a predicate of u{p  
definition 1 an update of a logic program p u a set of expressions of the form eval pos atom a  or eval neg atom a  where a is an atom d 
definition 1 lei p be a logic program and u an -update of p the procedure update is a function that n aps p and u to a logic program  such that the following correctness criterion is fulfilled 
1 	a b d u c t i o n versus i n d u c t i o n 
in this section we diacuss the alp and ilp approaches in terms of the generic problem setting of figure 1 and the rewrite rules for the meta-predicate new 
1 	a l p 
in general  abductive reasoning is concerned with the construction of explanations for observations using general laws these explanations are expressed in terms of a predetermined set of predicates  called abducible predicates moreover  most alp approaches require the explanations to be a set of ground facts first  this restricts the number of possibilities  and becond  in alp one is interested in constructing a concrete scenario rather than general rules as a consequence updates of a logic program p are restricted to removing and inserting ground facts for the abducible predicates 
　in the formalization of the previous section this means that alp regards the logic program p as having a fixed part  consisting of c{p  and i p   and the set u p  containing the names of the abducible predicates all of c p  belongs to the complete part  the incomplete part defining the predicates of u{p  is empty once evidence e is given  it is translated into operations on the abducible predicates 
1 


　a call to the meta-predicatc induce has the following effect first it ia checked whether there is a clause in c{p  that covere the atom a1 if this is the case  nothing needs to be done else  a clause is constructed that covere the atom a and that ib consistent with the negative evidence been so far we formulate the requirements for such a clause only in a very general way  since each approach has its own particular way of implementing the induction of a clause for example in a specificto-general approach one would start with a most spe-
cific clause  which can then later be generalised  whereas a general-to-specific approach would rather construct a most general clause covering the example and consistent with the negative evidence 
　the meta-predicate refine is called when a negative example is covered by one or more clauses in the partial definitions for the inducible predicates in that case these clauses are refined  1 e   made more specific  such that they no longer cover the negative example making a clause more specific is usually done by adding one or more literals to its body  although this is not the only way to implement refine e g   mis  shapiro  1  just removes the whole clause  and if necessary  replaces it later by a more specific clause 
1 	discussion 
taking a closer look at the rules  1 alp   1 alp   l ilp and {1 ilp  one can see some important similarities in the reasoning mechanisms of the alp and ilp approaches consider for example the rules  1 alp and  1  i l p the first disjunct of the right hand side looks very much the same reduction of a goal via resolution with a clause of p the main difference of course lies in the second disjunct of the rules  namely in the metapredicates abduce and induce the meta-predicate abduce reasons on the level of ground facts  whereas the meta-predicatc induce is concerned with definite horn clauses however  there still is a certain analogy in these predicates induce first backtracks over the possibly incomplete definition of the inducible predicate  and only if the atom is not covered a new clause in induced most abductive systems realise abduce by just inserting the atom as a new fact  but there exist more sophisticated abductive approaches that also first backtrack over the 
1 a clause c covers an atom a if p u {c}  = a 
1 	learning 
already abduced atoms  and only abduce a new fact when unification fails 
　notice that an analogue duality can be found in the rules  1 alp and  1 llp the first conjunct of the right hand side expresses that once a negative atomic goal unifies with the head of a clause  the instantiated body should not be true in pnew the second conjunct expresses what should be done when the negative goal contains a predicate p of u{p  the difference between the alp and the ilp approach lies in the fact that in alp one must avoid unification with the abduced atoms for the predicate p  whereas in ilp one must avoid coverage by the  induced  clauses for p 
1 s l d n f a i a n a b d u c t i v e p r o c e d u r e for ilp 
in this section we consider the abductive procedure  sldnfa  denecker ti a   1   and show that replacing the reasoning on the level of ground facts by an inductive reasoning schema  transforms it into an inductive procedure  which we call sldnfai 


its variables by bkolem constants - and adding the result to  in order to solve problems with unification with skolem constants  classical unification is extended in a first phase  extended unification treats skolem constants as variables  in a second phase  it bkolemnes the terms bound to the original skolem constants this ib illustrated in example 1 

   the predicate avoid.unification  which handles the case where an abductive atom a is selected in a negative goal q  is more complex one must compute the failure tree obtained by resolving the goal with each of the abduced atoms in   a problem is that the final a may not be totally known when a  s selected sldnfa solves this by interleaving the computation of the failure tree with the construction of  this is implemented by storing for each negative abductive goal the triplet where q is the negative abductive goal  aq is the abductive atom belected in and is the set of abduced atoms that have been resolved with q when a new fact is abduced  the stored goal is retrieved and is resolved with the new fact 
　finally  sldnfa has a special negative unification procedure for handling the case where skolem constants occur in negative goals we will not go into detail on this procedure we just mention that it produces expressions of the f o r m t e r m as constraints on the generated 
solutions 
　in  denecker  1  the sldnfa procedure is formalized and it is proven to be sound w r t completion semantics comp a.s a completeness result it 
ib proven that if the computation terminates  then sldnfa generates at least all minimal solutions 
1 	a simple inductive procedure 
we design a simple inductive procedure which can be seen as prototypical for a general-to-specific incremental ilp approach to predicate learning in termb of the 
formalization of section 1  our procedure handles the following problem 
given 

   'note that in a classical hp setting  under fol  emanticb should entail the positive examples and should be consistent with the negative examples when is a as representation language we use functor-free  linked horn clauses the procedure starts with an empty hypothesis and handles the examples incrementally clauses in are represented as couples of the form  c  coverage   where c is a clause and coverage is the set of positive examples encountered so far that are covered by c the clauses of c p  denning predicates of u{p  are considered to belong tc  their coverage is initialised to the empty bet we use a set n to htore the negative examples handled bo far 
　we now specify how the predicates induce and refine are implemented in our inductive procedure the predicate induce is called when a positive example is encountered when it is already covered by one or more of the clauses in h  it is added to the coverage of each of these clauses when the example is not covered by the current h  a most general clause is constructed that covers the example  and does not cover any of the negative examples in n the actual construction of such a clause goes as follows the procedure starts with a clause with an empty body  and with as head a variabilized version of the positive example this very general clause is then gradually refined until it does not cover any of the negative examples in the current n refining a clause is done either by unifying two distinct variables  or by adding a literal to the body the arguments of this literal should be distinct variables  with at least one variable in common with the original clause the predicate can be any predicate of p 
the meta-predicate refine is called for handling a negative example if the example is covered by one or more clauses in h  each of these clauses is refined auch that it no longer covers the negative example next it ib checked for each of these refined clauses which examples in their coverage are no longer covered the examples that are no longer covered by any of the clauses in h are then again added to e 
1 	introducing induction in sldnfa sldnfai 
the basic idea is to maintain the overall structure of the sldnfa procedure and to replace the abduction of the set of ground facts a by the induction of a set of clauses h using the inductive procedure of section 1 for doing bo  we will consider positive abductive goals as positive examples  and negative abductive goals as negative examples1 the set h is initialized with the clauses of c p  defining predicates of u p   with an empty coverage for each of these clauses as in sldnfa we use sets pg and ng to store positive and negative goals for a posit ve abductive goal  sldnfai extends - if necessary - with a new clause that is consistent with the negative examples encountered so far these negative examples are stored in the set n interleaving the computation of the failure tree for a negative abductive goal 
definite program  this is equivalent with  under least herbrand model semantics entails both the positive and the negated negative example! 
　　1  a positive  reap negative  abductive goal is an atom for an abduncible predicate  selected in a positive  reap negative  goal 
1 

and the construction of the set a is replaced by refining h each time a new negative example is encountered we clarify this idea by illustrating sldnfai on a small example 
example 1 consider the following fault diagnosis problem for lamps 

the predicate conn to empty battery is inducible note thai this implies that clause  1  is not necessarily com plete and correct the following enumeration describes how sldnfai operates in order to make the initial query succeed in each step we indicate the operation and the updated datasiructures 

1 	learning 
　let us for the bake of comparison discuss how sldnfa would have operated on the same example first  sldnfa would not take into account clause  1   since it assumes that initially there is no definition for the abducible predicates the first three steps in example 1 stay the same for sldnfa in step 1 howevet  sldnfa would abduce the atom conn-to-empty-battery  with sk1 a skolem constant  and add it to a step 1 and 1 stay the same as for sldnfai  but step 1 is again different since conn-to -empty.battery  is a negative abductive goal  unification with eonn-to.empty.battery { should be avoided therefore sldnfa adds the constraint sk1  the result is that sldnfa has abduced that lamp l1 has an empty battery sk1 which is different from b1 
　which of both solutions - i e   the one produced by sldnfa or the one produced by sldnfai - is prefer able of course depends on the actual problem situation  i e   whether one is interested in general rules  or in a concrete scenario 
　finally  we want to make two important remarks concerning sldnfai first  we claim that in a  degenerate  case  sldnfai reduces to the inductive procedure of section 1 indeed  when sldnfai is given as initial query the conjunction of all positive and negative examples  it will behave as the inductive procedure we described  and produce a set of clauses that covers all the positive examples  and none of the negative examples 
　and second  we claim that by using the sldnfa approach  sldnfai provides an elegant way of extending ilp approaches to handle normal clauses the use of completion - as in sldnfa - allows to extend the covers relation in a straightforward way to cope with negated atoms in the body of clauses this approach was also taken by  taylor  1  in their extension of a particular generalization operator  nl absorption  towards normal clauses in an inductive learning context moreover  since sldnfa can cope both with positive and negative goals  it functions in a very natural way as an example generator for both positive and negative examples for the inducible predicates  as can be seen in example 1 
1 	c o n c l u s i o n s 
in this paper we have made the link more clear between alp and ilp we have argued that both induction and abduction are different  yet related forms of hypothetical reasoning on incomplete knowledge on the one hand  abductive procedures complete this incomplete knowl edge by hypotheses containing ground facts such a solution is appropriate when one has confidence in the available general laws  and one is interested in finding a concrete scenario that explains certain observations on the other hand  inductive procedures produce general rules to complete the incomplete knowledge this is interesting in case one is interested in compacting the positive and negative evidence  and in later reusing the rules for classifying new examples 
　borrowing ideas of bry's setting  bry  1  for inten sional knowledge base updating  we have developed a generic framework that formalises the problem of com-

pleting incomplete knowledge in thin framework a 
declarative expression of an update of a logic program p resulting in a logic program pne w is a set of logical formulas using a meta-predicate new that applies on atoms and negated atoms a set of rewrite rules translates these formulas into operations on the object level program 
　next  we mapped our framework both to the alp and ilp approaches in doing so  more light is shed on the relationship between abduction and induction as an illustration we considered the abductive procedure sldnfa of  denecker and de schreye  1   we reformulated this procedure as an instantiation of our generic approach and showed that this enabled us to replace in a straightforward way the abduction of ground facts by a general-to-specific procedure for inducing clauses we call the resulting procedure sldnfai  1 e   sldnfa extended with induction finally  we claim that this enhancement of sldnfa can also be beneficial for the ilp 
approach  since sldnfa works with normal program clauses  whereas ilp is restricted to definite clauses 
　as a general conclusion we can say that our paper has established a clear relationship between alp and ilp we pointed out that it is worthwhile transferring results and techniques from one domain to the other e g   ilp could benefit from formal and theoretical results obtained in alp  whereas alp could benefit from inductive techniques to alleviate the restriction to abducing only ground facts we are convinced that the first promising results achieved in this paper suggest that further research on this issue can lead to interesting results 
acknowledgements 
we wish to thank maurice bruynooghe  gunther sablon and luc de raedt for their comments on earlier versions of this paper  and for the inspiring discussions research for this paper was partially supported by the esprit bra nr 1  ilp  we are also grateful to the anonymous reviewers for their encouraging comments 
