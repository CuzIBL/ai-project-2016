 
most natural language parsers require their input to be grammatical. this significantly constrains the search space that they must explore during parsing. parsers which attempt to recover from extragrammatical input contend with a search space that is potentially much larger  since they cannot necessarily prune branches when grammatical expectations are violated. in this paper we discuss the control structure of the experimental multipar parser  which directs its search by exploring potential parses in order of their degree of grammatical deviation/ 
1 introduction 
 most natural language processing systems parse their input by searching through a space of partial parses. they operate this way because  even though complete utterances alone or in context may be quite unambiguous  natural language is highly ambiguous locally. for instance  individual words can be ambiguous in their meaning or part of speech  e.g.  bank    or components of utterances can fit together in more than one way  e.g.  look at the man with the telescope  . a parser's search space for a given input is defined by the relevant set of local ambiguities. a search succeeds if a globally acceptable parse is found that accounts for all the input. there are various techniques to reduce search in parsing  including looking ahead to resolve local ambiguities   or ignoring local alternatives that are inconsistent with domain specific semantic constraints |1  1 . however  no techniques can completely eliminate search from natural language parsing. 
 the search problem becomes much worse if we require a parser to cope with extragrammatical input. for practical natural language interface systems  this requirement is a real one . such interfaces must contend with the grammatical errors that inevitably arise when people use natural language interactively. moreover  they also must cope with input that is correct  but outside their domain restricted grammars.1 we use the term flexible parser for a parser that can handle extragrammatical input. 
　the major search problem in flexible parsing lies in the criterion for identifying failing branches of the search - normally the violation of some syntactic or semantic expectation. while parsers that require grammatical input can employ this constraint to prune the search tree  flexible parsers must act more cautiously. if a 
　candidate parse violates an expectation  it may mean that the candidate parse is incorrect and should be abandoned  or it may mean that the input really does violate the parser's expectations in the way that has been detected. in the latter case  the parser should not abandon the branch  but should try to recover from the deviation and complete the parse along that branch. 
 one approach to this problem is to abandon a search branch only when the flexible parser has run out of correction techniques to apply. this  in effect  enlarges the grammar of the parser to cover not only the inputs originally considered grammatical  but also those that can be recognized by any combination of available recovery methods. although straightforward  this approach is unlikely to produce acceptable results. first  given the range of possible recovery techniques   the search space will quickly become unmanageably large. second  the recovery techniques may generate spuriously corrected  parses of grammatical input. finally  the described approach provides no way to distinguish between parses that involve widely varying degrees of correction  e.g. simple spelling corrections versus hypothesization of entire phrases . 
 what is needed  then  is a control structure that allows the normal criterion of extragrammaticality to cut off failing searches  but also accommodates the application of recovery techniques to reactivate failed search branches if no grammatical parse can be found. moreover  the recovery techniques should be ordered across all search branches according to the degree of ungrammatically their use implies  i.e. the simpler ones  like spelling correction  must be tried in all branches of the parse before the more complex and unlikely ones  like missing word insertion  are tried in any branch. 
 this paper presents a control structure which satisfies these goals. the next section describes the control structure from the point of view of the programmer constructing a parser that uses it. section 1 discusses some efficiency issues that arose in implementing the control structure. 
1 a programmer's view of the control structure 
 the control structure described in this paper was developed in the context of a restricted domain parser consisting of a collection of caseframe instantiation strategies. we have previously used the phrases multi strategy  and entity oriented  to describe this approach. there is no space here to describe this parser  called multipar  in detail. the most important characteristic of multipar from the control structure point of view is that its caseframe interpretation strategies are programmed directly  rather than being driven by a declarative formalism such as a transition network. we will refer to the person who writes strategies as the strategy programmer. in some sense  the strategy programmer is the user of the control structure. 
each strategy is an expert at parsing certain types of constructs. 
strategies cooperate by calling upon each other to parse sections of the input sentence. when a strategy encounters particular difficulties  violated expectations  while parsing its input  several 

at&t bell laboratories scholar 
   this research was sponsored in part by the air force office of scientific research under contract afosr 1. 
options are typically available. the options always include simply 
　 we use the term grammar broadly here to cover the semantic expectations used by many restricted domain systems in addition to syntactic ones. 

reporting failure  but may also include recovery methods to resolve the violated expectation. the multipar control structure provides the programmer with a method of specifying the alternative ways of proceeding  and indicating how much of a deviation each option would represent  without requiring him to schedule the investigation of the options explicitly. this scheduling is taken care of by the control structure automatically 
　the construct provided1 by the control structure to specify alternative ways of proceeding in the face of violated expectations is the split statement a split statement splits the computation into parallel branches --- one branch for each option. for each branch  the programmer specifies a flexibility increment indicating the degree of grammatical deviation implied by producing a successful parse via that branch. for instance  if a violated expectation could be resolved by a spelling correction or by hypothesizing a missing word  these two options would be specified as different branches of a split. the control structure would then pursue the two options independently. however  the spelling  correction option would have a lower flexibility increment than the missing word hypothesization  and so it would be pursued first. if it led to a complete parse  the missing word hypothesization would never be tried. 
a stylized example of a split statement is: 
 split  +1 actiona  
 +1 actionb  
　　　　　　　　　　 +1 actionc  ....  execution of this split statement produces a three-way branch in the search tree. action a has a zero flexibility increment  implying no grammatical deviation along this branch. actions b and c have flexibility increments of 1 and 1 respectively. this means that actions b and c would be scheduled for later investigation  while action a would be pursued immediately. 
　the system maintains a global current flexibility level whose value is equal to the flexibility level of the least deviant partial parse that remains to be investigated. in this way  the control structure can guarantee that parses are attempted in strict flexibility order and can generate all anc' only parses at the lowest flexibility level at which a global parse succeeds. in particular  if a grammatical parse can be found  then all and only grammatical parses will be generated. 
 it is important to note that the flexibility level of a parse is the sum of all flexibility increments of all split statement branches used to achieve the parse. in terms of the stylized example above  this means that other branches in entirely different parts of the tree may be tried between trying actions b and c. it also means that actions b and c may be tried  even if action a succeeds locally  so long as the parse fragment produced by action a does not participate in a complete global parse. this global comparison of the sums of the local flexibility increments is crucial in ensuring that recovery techniques are attempted in order of drasticness across the entire search space of a parse. it also ensures that improbable combinations of recovery techniques are not applied if simpler parses can be found. 
 another advantage provided by the split statement is that recovery actions can be closely integrated with the normal parsing process. instead of having a separate recovery phase that occurs independently of normal parsing  recovery actions occur within the local context of strategies. therefore  only recovery actions appropriate to the context need be applied. this is important for recovery strategies such as spelling correction  where availability of the local context can provide information that constrains the range of possible corrections. 
 let us now look at a less stylized use of split. the following algorithm is a simplified version of the strategy multipar uses for parsing imperative sentences. 
imperative caseframe strategy 
1. find the head verb of the sentence. 
1. retrieve an unmstantiated caseframe for the action associated with this verb. 
1 identify the semantic type of the syntactic direct object. call the nounphrase strategy to find an object of that type at the begining of the unparsed segment. 
1. determine the unnued marked cases and split 
1 alternative!: recognize next word as a casemarker for an unfilled marked case; attempt to fill that case with the remaining segment. 
+ 1 alternative 1: hypothesize that a case marker for an unfilled marked case is missing; attempt to fill the case with the remaining segment. 
1. if sentence has not been completely parsed  go to 1. 
 let us assume that multipar is being used as the front end to a mail system  and that the user has just composed a message to be sent. to parse a command such as  mail message to 
paul cmua   the strategy would first identify  mail  as the head verb  and send as its corresponding action  and then call the nounphrase strategy to recognize a potential msg-object as the direct object. assuming this lower level strategy parses 
 message  correctly  the imperative strategy then reaches the split statement. at this point  two branches of the search tree are created with flexibility levels equal to the sum of the currentflexibility-level  which is 1  and the corresponding flexibility increments. the branch corresponding to alternative1 is scheduled by the control structure at flexibility level 1  1 plus 1 . the branch corresponding to alternativel still has flexibility level 1  1 plus 1   and so it continues immediately. alternativel would successfully recognize  to  as a marker for send's destination case  and call a lower-level strategy to parse ''paul cmua  as the msg-destination. thus  this branch of the parse succeeds and the other branch spawned by the split is never tried. 
 a common error in spontaneous input is to omit case markers  so let us suppose now that the input reads  mail message paul cmua . as before  after  message  is recognized as the direct object  the split statement is encountered. however  this time alternativel reports failure. if the control structure finds no other branches of the tree suspended at flexibility level 1  the current flexibility level   it will look for suspended branches at higher flexibility levels. in our present example  it will find the branch suspended earlier at level 1. the current flexibility-level is set to 1  and computation is restarted at alternative1. this means that the imperative strategy will now hypothesize that a case-marker has been omitted  and will try to parse  paul cmua  as one of the unfilled cases for send. when  paul cmua  is recognized as a possible msg-destination  the input will have been completely accounted for  and the parse would be the same as for the first example.1 notice that this recovery action is specific to the violated 

multipar is implemented in common lisp. 

   a complete interface system might want to confirm its interpreptation with the user. 

expectation of finding a case marker. because the action is context-dependent  it would have been more difficult to achieve in a completely separate recovery phase 
 even with this simple example  it will be clear that the size of the search tree can grow rapidly when recovery is attempted. if 
 paul cmua  qualified as both a msg-source and a 
msg-destination  altemative1 above would have to split again  and two alternative corrected parses would be produced. then too  paul cmua might be the name of a misspelled message-
header. exploring this alternative would be the responsibility of one of the strategies called while parsing the direct object. note that spelling correction can potentially generate many alternatives  especially if words in the parser's lexicon can be considered as potential misspellings of other words in the lexicon  perhaps the user intended  make  instead of  mail  . 
 these examples may make clearer the importance of exploring all potential parses at lower flexibility levels before any of those at higher levels. witness the computational expense inherent in recovering a missing case marker  i.e. trying all unfilled cases. if there is still a possibility that branches of the search requiring less drastic recovery techniques might yet succeed  they must be attempted first. for example  the sentence  mail message should be saved  will be recognized by a strategy for declarative sentences that is invoked in a branch parallel to the imperative strategy. since this branch succeeds at level 1  it should be examined in its entirety before the imperative strategy attempts to hypothesize a missing case marker 
 this best-first order of exploring the search tree implies that grammatical parses will be discovered relatively quickly.  a disadvantage  of course  is that ungrammatical  but recoverable parses may be produced significantly more slowly.  equally important  the use of flexibility levels imposes a partial order on deviant parses  so parses that are highly undesirable will never be discovered if better alternatives exist. for example  a parse with two spelling corrections will not be generated if a parse with a single spelling correction can be found. at times  the ordering may be rather arbitrary  e.g. is a missing case marker worse than a 
 single spelling mistake  . however  such arbitrary judgments tend to overconstrain the search rather than underconstrain it  which seems appropriate. 
1 implementing the multipar control structure efficiently 
 in order for the control structure outlined in the previous sections to be of practical use  it must implement the best-first search in an efficient manner  and it must be convenient for the strategy programmer to use. in this section we outline some of the engineering considerations that proved to be crucial in achieving these goals. 
  usability: multipar consists of many communicating strategies  each of which may involve a complex computation. the control structure provides a standard interface for one strategy to call upon another and controls the pseudo parallel exploration of the search tree. an important attribute of the control structure is its unobtrusiveness; the strategy writer is provided with a small set of facilities for executing strategy calls and parallel actions 
  efficient context re-creation: to return to an alternative on the agenda  the local context at the split statement must be re-created. rather than saving the complete state of the computation  context recreation is effected by re-executing the local strategy from its inception. this seemingly inefficient mechanism is quite practical due to two factors: most scheduled alternatives are never attempted during a 
s. mintonetal. 1 
typical parse  and a caching mechanism is used to store substrategy results. 
  sharing strategy results: it is often the case that parallel branches will duplicate each other's work  since they may differ only in a few respects. this is especially true when recovery actions are initiated  since the number of branches tends to grow dramatically as higher flexibility levels are reached. because of this  the mechanism for caching substrategy results has a dual purpose. in addition to enabling rapid context re-creation  it makes the overall operation of the parser more efficient by allowing strategies to share results.1 for example  to recover from a missing case marker  the lower-level case filler strategy has to be called once for each case that could possibly be filled. each time it is called it may have to operate somewhat differently 
depending on the constraints for that case  e.g. call a namerecognizing sub strategy or check to see whether the input can be found among current message headers . however  much of the work may be identical in each instance  and so caching produces considerable savings. 
1 conclusion 
 all natural language parsers must perform some search  but when a parser is intended to handle ungrammatical as well as grammatical input  its search space becomes very large. the control structure described in this paper allows a large  complex search space of this kind to be explored in an orderly manner. efficiency is improved by a caching mechanism that takes advantage of the significant amount of redundancy present in the search space. the control structure provides convenient facilities for specifying the search space  while automatically performing the bookkeeping necessary for an efficient search. 
 we have built a version of multipar that parses natural language commands to an operating system. experience with both grammatical and deviant sentences in this domain suggests that the control structure adequately fulfills the requirements for a flexible parser outlined earlier. 
1 acknowledgements 
 we thank jaime carbonell for his help and participation in all phases of this project. 
