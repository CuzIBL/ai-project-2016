 notion of a problem-reduction method  with the following example chosen from the domain of symbolic integration. 
	i n t e g r a l - o f - a - s u m m e t h o d 	: 

the above method decomposes the problem of integrating a sum of two functions into a set of subproblems  that of integrating each of the summands. using the terminology introduced earlier  
the problem p is the integral the two subproblems p1 and p1 are respectively  
and the combinator c is addition. 
c. u s i n g verification as a basis for 	generalisation 
　　we now introduce the idea of using verification as a basis for the generalization of problem-reduction methods from instances. we represent an instance of the application of a problemreduction method as an ordered pair of states  x y ; x represents an instance of the class of problems to which the method can be applied  and y represents the composition of some set of subproblems whose solution implies the solution to the original problem x given such an instance of an unknown problemreduction method as a pair of states   x   y     the generalisation problem that we address in this paper consists in determining this general method from the instance. as a first step towards the generalization  the program verifies that the solution to the composition of the subproblems  y  implies the solution to the original problem x. the second  and final  step involves the central idea underlying the vbl technique  the unknown method can be determined by generalizing the problem-states x and y  retaining only those features of these problem-states that were im-
portant 	for 	the 	purpose 	of 	verification. 
　　the idea of using verification as a basis for a learning technique  is related to similar schemes used in other analytical learning techniques  specifically goal-directed learning |1   explanation-based learning   1  and constraint-based generalization  1 . all these learning techniques are similar in that they first generate an explanation or proof  here  a verification  of why the given training instance  here  instances represent applications of problem-reduction methods  satisfies a particular goal  here  the goal is showing that the decomposition of the problem instance was a correct one   and then they generalise the instance  here  forming a new problem-reduction method  using the constructed explanation or proof to constrain the generalization. 
d . 	o u t l i n e o f the paper 
  in section 1  we state the generalisation problem for inferring problem-reduction methods from examples. 
  sections 1 and 1 contain two detailed examples of the application of vbl to the task of inferring problemreduction methods in circuit design and symbolic integration. 
  finally  in section 1  we summarise by viewing v b l from a number of different perspectives  outlining some of its limitations and describing some work in progress on them. 
	s. mahadevan 	1 
ii the generalisation problem for inferring problem-reduction methods 
a. statement of the problem 
　　before proceeding to give domain-specific examples of vbl  as we will be doing in sections s and 1  it is important that we state the generalisation problem that this paper addresses  in domain-independent terms. figure ii-1 provides such a statement. 
figure i i - 1 : the  ieneralizaiion problem for inferring problem-reduction methods 
  given -
o a language of instances of problems. 
o a language of generalizations of problems. each generalization in this language describes some class of problem instances. 
o a single positive instance of a problem-reduction  which is composed of the following pair. 
1. specification of a problem p in the instance language. 
1. specification of a set of subproblems p. in 
the instance language and a combinator c. 
o some domain theory  in the form of a set of transformations  which can be used to verify assertions of the form -- the solution to the composition of the set of subproblems p. implies the solution to the problem p. more formally  such assertions can be stated as 

  d e t e r m i n e -
o description of a problem-reduction method in the generalisation language that is consistent with the observed instance; this is computed by generalising the specifications p and p.  using the verification of the above assertion to constrain the generalisation. 
b. discussion 
　　the domain theory required by vbl  in order to construct a proof or verification of the assertion in figure ii-1  is a set of transformations; each transformation can be viewed as a primitive problem-reduction method  and new problem-reduction methods can be viewed as being obtained by composing these primitive methods together in a specific manner. forming a new problemsolving method by composing together a sequence of primitive methods is a general strategy  which has been used as the basis for many earlier techniques  1  1. in the next section  we will provide an example from circuit design  which illustrates how we use this approach to infer new problem-reduction methods. 

1 	s. mahadevan 
i i i l e a r n i n g p r o b l e m - r e d u c t i o n m e t h o d s for c i r c u i t design 
　　in this section we describe an application of v b l to the task of acquiring problem-reduction methods for circuit design. we begin by formulating circuit design as a problem-reduction process. we then focus on a particular problem-reduction method for designing a small class of circuit specifications  first describing the method itself  and subsequently  in a number of detailed steps  showing how it may be acquired from a single training instance. 
a. circuit 	design as p r o b l e m r e d u c t i o n 
　　in order to view circuit design as a problem-reduction process  we need to specify the various; components that constitute the problem-reduction model. the language of instances of problems corresponds to the functional specifications of circuits; these define the mapping between the input and output signals of a circuit   for example  the output of an adder equals the turn of its inputs.  the initial state is the functional specification of a circuit to be designed  the final state is an implementation of the circuit specification in terms of a set of primitive components  and a problem-reduction method is one that decomposes a given circuit specification p into specifications pi of a number of interconnected ttmpicr circuits  submodules  the language of generalisations of problems enhances the expressive capabilities of the instance language  by including the ability to specify arbitrary boolean functions as part of functional specifications **** we thus view the problem of learning problem-reduction methods in circuit design  as an instance of the more general problem of inferring problem-reduction methods from examples. 
b . a n 	d l u s t r a t i o n 	o f p r o b l e m - r e d u c t i o n 	i n 	c i r c u i t design 
　　for the sake of concreteness in the discussion of the v b l technique  we need to consider a simple example of a problemreduction method in circuit design  and phrase the remainder of the discussion in terms of this example. we first describe the method itself  and then provide an example of its use. 
　　figure iii-l provides a simple example of a problem-reduction method that suggests one plausible way of implementing a conjunction of any two boolean expressions the left-hand side  lhs  of the problem-reduction method describes the class of specifications to which it can be applied. the right-hand side  rhs  of the method suggests both a decomposition of the specification in the lhs into specifications for a set of submodules  and also a way of interconnecting them. 
　　a training example that represents an instance of the above method is given in figure iii-1. in this example the circuit being designed is a product-of-sums circuit whose specification p is as given in the figure. the context here is that of a learning apprentice system  which being ignorant of the above general method for implementing a conjunction of two boolean expressions  may suggest using an a n d gate and two or gates as one way of implementing the circuit specification p. the user steps in at this point  and disregarding the system's suggestion  provides his preferred way of implementing the specification p  which is to use a set of nor gates interconnected as shown in figure iii-1. 
       f o r reasons of clarity in tbt ensuing discussion of the learning method  we adopt a simplified representation of functional specifications of circuits. specifically  this representation omits any reference to attributes of signals such as timing' and sncoding.  provides further details of this representation. 
the learning apprentice views the user-supplied example as representing an instance of the application of an unknown problem-reduction method  and sets itself the task of inferring the general method. the general problem-reduction method that is inferred from the training instance in figure iii-1  is the one we described earlier  in figure iii-1. in the next few paragraphs  we provide a detailed description of the use of vbl in determining this general method. 

c. step 1: forming the composed specification 
　　the first step in the process of inferring a general problemreduction method from a training example is verifying the correctness of the decomposition for the given example. in circuit design  this corresponds to ensuring that the function computed by the decomposed circuit meets the original circuit specification. before attempting to construct a proof of correctness  we must have some way of determining the function computed by the decomposed circuit. it is to this matter that we turn to next  in our discussion of vbl. 
* bool-fn1  abort represents an arbitrary boolean function. 

s. mahadevan 	1 


circuits function from its structure this composed specification  can be computed by a simple substitution process  and is determined by the relationships between signals at various points in the circuit. for example  we can obtain a relationship between the output signal and the inputs of the product-of-sums circuit in figure ii1  by substituting for x and y in the specification p1  their relationships to the input signals described in p1 and p1 carrying this out  we obtain the following composed specification for the product-of-sums circuit 

   several remarks may now be made  in connection with our definition of a composed specification  which are of importance to the generalization process that follows. 
  in general  the composed specification will be a reexpresscd version of the original specification. this is due to constraints on the possible structures that primitive circuits  problems  can take. for example  in vlsi design  since circuits naturally invert their inputs  specifications in terms of and and or boolean functions must often be reexpressed in order to obtain implementations using combinations of nand and nor gates. thus  since we must show that the composed specification implies the original specification  this motivates the need for a verification of the correctness of a decomposition. 
  the form of the composed specification depends on the structure of the decomposed circuit  problem . we will make use of this property  when generalizing each of the submodule  subproblem  specifications. 
d. step 1: the process of verification 
   having obtained the composed specification of a decomposed circuit  problem   the next step in the vbl technique is to construct a proof of the correctness of the decomposition. that is  we need to verify the truth of the following assertion  which we repeat from figure ii-1  and which states that the composed specification must imply the original specification. 

for the product-of-sums circuit example  by substituting its composed and original specifications in the above expression  we obtain the following assertion  whose verification is the topic of this section. 

if we are only concerned about verifying arbitrary assertions of the above form  it is clear that there exists considerable latitude in the choice of an appropriate scheme for verification. many such schemes have been developed by researchers interested in circuit verification . however  since we view verification as only a means to our end of wanting to infer problem-reduction methods  any scheme we choose must meet the following additional requirement - it should be possible to use the proof conwe now describe a verification scheme satisfying the above requirement we construct the proof as a sequence of transformations  which will yield the original specification when applied to the composed specification each such transformation  which can be viewed as a primitive problem-reduction method  is specified by its precondition - the class of specifications to which it can be applied - and its postcondition  which describes the result of applying the transformation. constructing a verification as a sequence of such transformations satisfies the above requirement  since it enables us to determine from the sequence a generalisation of the circuit specifications p and pi  using constraint propagation. two examples of transformations that we 
will use in the current example are given below. 

using the scheme mentioned above  we now provide  for the product-of-sums circuit example  a verification of the correctness of the user-suggested decomposition in figure iii-1. 

in summary  we have now cast the problem of verification as one of a search for a sequence of transformations  which will produce the original specification when applied to the composed specification.**** 

1 	s. mahadevan 
e. step 1: determining the generalized composed specification 
   in order to infer a new problem-redurt ion method from the given training example  we need to compute both its precondition  the if part   and its postcondition  the then part . if we regard the original and composed specifications as instances of the precondition and postcondition of the new method  then clearly  the next step consists in generalising these specifications; furthermore  as we mentioned earlier  we would like to constrain the generalisation using the proof of the correctness of the decomposition. 
   in this section we describe how  given the verification proof as a sequence of transformations  the composed specification may be generalised using a restricted version of a well-known technique  constraint backpropagatton cbp . cbp is a technique for determining the domain of a sequence of operators that produces some constrained range of states |1|. in our case  transformations can be viewed as operators  but we have no constraint on the range except that it match any arbitrary functional specification  which we denote by   since we are learning arbitrary problem-reduction methods  and not sequences that lead to  solved  states  as in  1j.  the domain of the sequence  in our case  is a generalised composed specification that will produce  upon application of the sequence  a corresponding generalised original specification. 
   the problem with using weakest precondition techniques to compute the domain of a sequence is that  in many cases  dis-
junctive expressions are produced. in particular  disjuncts arise whenever sequences contain operators that were applied to only a part of the expression representing the problem state. for example  in the verification sequence above  the first application of the remove-double-negation transformation was to a subexpression matching its precondition. disjunctive expressions cause two kinds of problems. first  since the number of disjuncts can grow exponentially in the length of the sequence  storing all of them is a non-trivial issue. second  even if all the disjuncts could be stored  it is quite likely that some of the disjuncts represent initial situations in which the sequence is an inefficient one to use.  for example  we have observed this problem crop up when using goal regression to compute the weakest precondition of a plan; some of the disjuncts represent initial states in which the plan is a very inefficient one to apply.  
   we illustrate below a simple solution to this problem that uses information regarding how transformations were applied  in particular  their bindings   from the verification of the training instance  to prune out some disjuncts during the cbp process.  for example  the expression  not  not  not  not  bool-fn      is a valid domain description of a sequence of two removedouble-negations  which is not generated in the cbp computation below.  
computing the generalized composed specification 

   to begin with  the expression  bool-fnl  above is produced by intersecting the range of the first remove-double-negation transformation  any boolean function  with the range of the entire sequence   any-func-spec  . installing this expression as the second argument to the and expression  the original specification   as we have done above  reflects the context in which this transformation was used in the forward direction 
 during verification . in the first step above  we backpropagate  bool-fnl  over this transformation  keeping the expression surrounding it unchanged. similar remarks hold for the occurrence of  bool-fn1  above  and for the backpropagation over the second transformation. finally  backpropagating over demorgan's does not present a similar problem  since its range intersects onto the expression back propagated over the first two transformations.***** the generalised composed specification itself is of little use to us; what we really need are generalisations of the specifications of the submodules  in general  subproblems  that constitute the product-of-sums circuit in figure iii-1. these generalised specifications are shown below.** 
generalised specifications of the submodules in figure 
iii-1 

comparing the generalised submodule specifications in figure iii-1 with the submodule specifications given in figure iii-1  we see that the important feature of the two submodule specifications p1 and p1  the two input nor gates in figure ii1   which enabled the verification to carry through  is that they both be the negation of some boolean function. 
f. step 1: determining the  generalized original specification 
   in this section  we describe methods for generalizing the original specification  given that the generalized composed specification has already been computed. one simple method involves storing the variable bindings generated while computing the generalised composed specification  for example  the subexpression  or lnput1 input1  was replaced by  bool-fnl    and applying these substitutions to the original specification. another method  which illustrates better that the composed and original specifications form the domain and range of a sequence of transformations  involves  as we show below  reapplying the transformation sequence to the generalised composed specification. 
　***** although implementing this procedure has been an easy task  attempts at formalising it have not yet been successful. 
　**figuring out the generalisation of each submodule specification from the generalised composed specification is straightforward  provided some bookkeeping was done while forming the composed specification in the first place. 


comparing the generalised original specification - the last expression in the above sequence - with the original specification p in figure ii1  we see that a generalization of the original specification has been achieved from a conjunction of disjunctions to a conjunction of any boolean functions. 
g. step 1: f o r m i n g the n e w p r o b l e m - r e d u c t i o n m e t h o d 
　　we showed above how the original specification p and the submodule specification p. could be generalized the final step is to form a new problem-reduction method that is based on these generalised specifications. it is clear that the generalized original specification will form the precondition  or lhs  of the new problem-reduction method. also  the postcondition  or rhs  of the new method can be formed from the generalized submodule specifications and the combinator c. for our present example  the new problem-reduction method that is inferred  from the training instance in figure iii-1  is the one given in figure iii-1. 
i v 	learning problem-reduction 	m e t h o d s for 	symbolic integration 
　　in this section we will briefly illustrate how the same v b l technique can be used to learn problem-reduction methods in symbolic integration. this will provide some justification for our claim that vbl is general technique  and can be applied to more than one domain. further details of the steps sketched below are described in  1s|. 
a. symbolic integration as p r o b l e m - r e d u c t i o n 
　　we begin by viewing the process of integration in terms of problem-reduction. to this end  note that the language of instances of problems in symbolic integration is the language of integrals of mathematical functions. the language of generalizations of problems includes the ability to specify arbitrary functions as part of integrals. problem-reduction methods here are the standard rules of integration *** we may thus view the problem of learning integration methods from examples  as an instance of the more general problem of inferring problem-reduction methods from examples. 
b . a n 	i l l u s t r a t i o n 	o f p r o b l e m - r e d u c t i o n 	i n 	symbolic i n t e g r a t i o n 
　　consider the following example of a problem in symbolic integration  and a way of decomposing the problem. 

***such as the one we described in section l.b. 
	s. mahadevan 	1 
the original problem p has been decomposed above into two subproblems  p1  which is  and p1   which is 
the combinator c above is addition the generalisation problem here lies in determining a general method  by generalising the specifications p and p.  which could produce the above decomposition. in the next few paragraphs  we summarise the main steps involved in inferring the general method  
	from 	the 	above 
training instance. 
c. steps1: f o r m i n g the composed specification a n d 
v e r i f i c a t i o n 
　　here  unlike the circuits domain  we do not need to construct the composed specification  since the combinator  addition  specifies that explicitly. we can proceed directly to the verification step. 
　　we now describe what verification means in symbolic integration. we can make use of the following result  which asserts that if the derivatives of two integration problems are shown to be equal  then the solutions to the two problems are identical.  the reasoning is that if the derivatives of two functions are equal  then they differ at most by a constant. two solutions to an indefinite integration problem which differ by a constant are both instances of a more general family of solutions  f x  + a constant.  we may thus take as the problem of verification in symbolic integration  the task of showing that the derivative of the composed specification is equal to the derivative of the original specification. given the above result  this will imply the equivalence of the original specification and the composed specification. as earlier  we can proceed to verify instances of problem-reductions using a sequence of transformations  except in this case transformations correspond to rules of differentiation. an example of such a transformation  which would be useful in verifying the above problem-reduction instance  is given below. 
d e r i v a t i v e - o f - a - s u m 
p r e c o n d i t i o n : 	p o s t c o n d i t i o n : 

d. step s: d e t e r m i n i n g the general composed 
specification 
     given a verification of a problem-reduction in symbolic integration as a sequence of transformations of the kind shown above  we can use a procedure completely analogous to the one described earlier in section 1 to determine the generalized composed specification as earlier  we have to restrict the cbp procedure in order to avoid generating disjuncis sing this procedure  we will obtain the following generalized composed specification  
	this 	with 	the 	composed 
specification we see the generalization that has been achieved. 
♀ . step 1 : d e t e r m i n i n g t h e generalised o r i g i n a l 
specification 
　　having obtained the generalized composed specification  the generalised original specification can be determined  once again  in either of the two ways described in section 1. that is  we may use the bindings obtained during the cbp computation of the generalised composed specification  or reapply the sequence of transformations used in the verification to the generalised composed specification. using either of these two ways  we will obtain the following generalised original specification  

1 	s. mahadevan 
f. step 1: forming the new integration method 
   finally  given the generalised composed and generalised original specification as above  we can form the new integration method by defining the latter to be its precondition and the former to be its postcondition. this is shown below.**** 
new method: 

v conclusions 
a. different perspectives for viewing v b l 
   we begin summarizing the vbl technique by viewing it from a number of different perspectives. 
　　vbl as learning problem-solving methods: vbl can be described as a general technique for learning problem-solving methods. as it is an analytical generalization technique  one of its nice features is that it produces justifiable generalizations |1|  as opposed to empirical generalization techniques  such as described in   which rely primarily on detecting syntactic similarities among training instances. 
vbl at forming macros: another way of thinking about what 
vbl does is by viewing each problem-reduction method as being constructed as a macro of the sequence of transformations used in the verification. in this sense vbl seems similar to earlier work on plan generalization systems like strips   but operating in the problem-reduction space  as opposed to the state-space. on the other hand  it is important to note that any proof technique for generating verifications can be used  provided  of course  that it meets the requirement that we imposed in section 1   and using a sequence of transformations is just one such scheme. 
　　vbl at learning plant circuit design may be viewed as a planning problem. from this perspective each submodule becomes a planning method  and a circuit becomes a network of such methods. given a particular plan used in a specific situation  one can generalize it by generalizing the class of situations in which exactly the same plan could be applied  which is what macrops did |1|. |1  shows how this may be done for circuit design. 
this highlights an interesting new feature of vbl  which is the ability to generalize plans by generalizing the individual methods in the plan. for example  in section 1  the specification of the nor gate was generalized to a negation of any boolean function  which really represents a class of possible submodules  for eg.  a nand gate . thus  we can describe vbl as a technique for generalizing plans by generalizing the subgoals achieved by the individual methods constituting a given plan. 
b. limitations of the technique 
   we must now make clear some important requirements that need to be fulfilled in order to apply vbl to some given domain. we summarize below some of these requirements.  describes  in more detail  problems that are anticipated in using this and other related techniques in real-world situations. 
　　underlying domain theory : the success of the v b l technique rests on its capability to construct a proof of the correctness of a decomposition  which implies the existence of a strong underlying theory of the domain  such as circuit analysis . most of the theory that is needed  for example  the transformations and the ability to propagate constraints  we assume are part of a know ledge-based system on top of which the learning apprentice will be designed. while this is true for the specific 
learning 	apprentice system 	l e a p   	there are domains  	such 	as 
well-log interpretation  where the lack of a strong underlying domain model prevents the successful application of pure analytical generalisation methods . this in turn motivates the need for an empirical component in the overall learning system. 
　　adequacy of the verification technique: one important question  which directly affects the usefulness of v b l   is - how hard is it to verify arbitrary problem decompositions  it might be that a very large number of transformations are needed to cover a wide range of problems. one related issue  which we have not discussed in this paper  is the existence of multiple ways of generating verification proofs for example  an alternative scheme for verifying the product-of-sum circuit example is that of truth trees   which has certain desirable properties  such as guaranteed termination   making the issue of control an easy one; however  these properties hold only for the restricted class of combinational circuits. more generally  we believe that construct-
ing verification proofs as a sequence of transformations is a weak but general way of approaching the verification problem. by exploiting the properties of the particular domain  such as the functional specifications of the product-of-sums circuit being boolean expressions   we may be able to come up with more powerful  and more restricted  schemes for verification. 
c. f n t n r e research 	topics 
　　we now describe some avenues for further research that we are currently exploring. 
　　extending weakest precondition techniques: one of the problems that we described earlier had to do with the appearance of disjunctive expressions during the cbp computation some of the disjuncts  we said  correspond to initial situations in which it is correct  but not efficient  to use the sequence. it seems that we need more powerful analytical tools in order to learn the class of situations in which it is efficient to use a macro  as opposed to when it can be used . work is in progress on formulating this problem within the framework of goal-directed learning |1   by providing the system with an explicit definition of the  class of states in which it is efficient to apply a macro   and having this aid the generalization process. 
　　extending the notion of verification: although we have formulated the problem of verification as one of finding a sequence of transformations  it is important to note that the concept of verification is more general  and  in the extreme  it could be viewed as a restricted form of theorem-proving   the assertion being proved is the invariance property of problem-reduction methods.  also  the connection between work on proving circuits correct  and that of generalizing problem-reduction methods seems an interesting one to pursue. in particular  we need to state more 

　****note that this is exactly the integral-of-a-sum method that we illustrated in section i.b. 

precisely the additional requirement that we imposed on proof techniques for verification - that they focus on those features that were important in order for the proof to work. 

	s. mahadevan 	1 
v i 	a c k n o w l e d g m e n t s 

　　1 thank the following people for their contributions to the form and content of this paper tom mitchell  for many ideas and for greatly improving the presentation of the paper. saul amarel and natesa sridharan  for their careful reading of a draft. 
lou steinberg and other members of the rutgers a i / v l s i project  for many useful discussions. smadar kedar-cabelli  prasad tadepalli and rich keller  for many interesting discussions on analytical learning techniques. 
