 
　　　casap attempts to create a more flexible knowledge-based system for performing actions. it is based on the combination of a procedural representation of actions  and an information retrieval subsystem used to dynamically obtain all information required to perform an action. it is argued that such a combination eases the specification of new actions and increases their a b i l i t y to obtain  from a wide variety of possible environments  the information they require. 
　　　a simple example demonstrates this f l e x i b i i i t y . 
introduction 
　　　the effort to build intelligent programs has received a great deal of interest for a number of years. the early attempts were of the theorem proving type characterized by the logic theorist 1 j  which attempted to implement the rules of propos-i tional calculus. using these rules the system attempted to move from a stated set of axioms to a theorem to be proved by a generalized search technique. this system was the genes is for the later general problem solver  gps    1   . gps applied a series of user specified operators to move from the i n i t i a l state to the goal state as determined by rules of applicability of those operators and as directed by a difference table to eliminate differences between the current situation and the goal state. 
　　　both systems are essentially table driven and represent an attempt to build a single general purpose problem solver capable of accepting valid operations in a wide variety of domains and using them to move from i n i t i a l to goal states. the problem with such attempts has been that the general mechanisms contained within them for deciding in what order to apply the operators to make progress towards the goal have not been adequate for the problems under investigatlon. also  specific knowledge about how to proceed in a particular domain has been d i f f i c u l t to state in a general form for such systems. 
this research is supported by the advanced research projects agency under contract no. dahc1 c 1  arpa order no. 1  program code no. 1 and 1. 
　　　these d i f f i c u l t i e s with general problem solvers led to a second approach centered around the incorporation of specific knowledge about how best to operate in a particular domain. since this knowledge was not well codified  these systems represented it in the most general way known! i.e.  in terms of programs. experience with systems of this type led to the development of planner  as a way of systematizing some common aspects of this approach. these common aspects include provt sions for backtrack!ng  provisions for the dynamic update and maintenance of a data base  and pattern directed invocation   i . e .   routines are invoked not by name  but by the results they promise to deliver. the promise is pattern matched against the current subgoal and is invoked if the match is satisfied  the procedural analog of the difference table in gps. 
　　　these systems have traded increased operational power for loss of awareness. because the knowledge is represented procedurally  the system is less capable of using it deductively or in determining what the consequence of particular actions may be. 
　　　casap represents a combination of these two approaches! the procedural representation of knowledge together with the general mechanism for assembling the information required for actions or inferences. 
　　　there are two main problems with the procedural approach. the f i r s t is the concurrent transfer of both control and data between routines. typically  when a routine is invoked  the data that it is to process is also passed to it as part of the invocation. thus  the caller needs to know what data is requlred by the called routine. such an organization is much too r i g i d . all that the caller should know about the called program is the result that it promises to deliver. since routines are to be invoked on the basis of the result that they promise to deliver  if for one reason or another they are inapplicable in a given situation  then they will inform the caller of this and alternative action can be taken. it shou d therefore be the responsibility of the called program to obtain the information it requires. 
　　　towards this end  some systems keep the data in a common global data base which is directly accessible by all routines. hence  any routlne can get at whatever data i t requires. this  too  is an unacceptable solution; for it requires too wide a d i s t r i b u t i o n of the knowledge of how and where to find informatlon  and unnecessarlly complicates each of the routines in such a system  
　　　we propose instead. in casap  to place a single informatton retrieval routine between any routine requiring data and the global data base i t s e l f . thus  a l l each routine requires is the knowledge that it needs a certain piece of information which it then requests from the information retrieval package. knowledge about the data base is thus centralized in a single routine. 
　　　the second major problem with the procedural approach is the polntwlse applicability of procedures. either one procedure or another is active  but not both. this greatly limits the a b i l i t y for two or more procedures to perform actions in a coordinated way. the closest thing we have to a solution for this problem are the demons which exist in various systems. these demons watch for certain events. in either the control or data spaces  and when such events occur  invoke an associated routine which then gets control. this allows for more dispersed and low level interactions between various routines toward a coordinated goal  but does not. in f a c t   lead to coordinated actions. 
　　　if viewed in this manner  casap does not address this issue at a l l . however  from a different standpoint  what we desire is the a b l   i t y for one routine to influence the behavior of another routine  that i s   to set up constraints or suggestions which are dynamically used to modify the behavior of the invoked routines as directed. 
　　　casap  in a limited way  performs such modifications by u t i l i z i n g a context which is established and maintained by the information retriever  and used whenever information is required. thus  the information obtained at any point  in response to a quest!on  is dependent upon the context that has been previously set up. through this mechanism an invoking routine can establish the context in which the request for information from invoked routines w i l l be answered and thus changes the perceived state of the world for that routine. 
　　　this mechanism i s   however  quite limited from two standpoints. f i r s t   it only deals wlth informatlon that the invoked routine requires in a particular s i t u a t i o n . 
information which is not needed by the invoked routine has no way of influencing the behavior of such a routine. secondly  it is an information-based context and not an action-based one. hence  it only plays a part when i nformation is required and not when actions are being performed. with these restrictions in mind  however  ft is a step in the direct ion of a system which u t i l i z e s context for the interpret/on of actions and information dynamically required. 
　　　it is our belief that moving from essentially macro based languages to languages that are essentially context dependent for the interpretation of both actions and data is the next major needed advance in programming languages. 
system organization 
　　　casap represents our attempt to test these ideas in an operational way and has demonstrated  in a very limited way  the f e a s i b i l i t y . if not the p r a c t i c a l i t y   of such an approach. 
　　　organizationally  casap was predicated on the principle that there would be no subroutines in casap programs  the system i t s e l f was implemented by standard technique ; that there would be no hard  well-defined interfaces between the specification of act!ons to be accomplished; and that information would flow among the processing components as required by the particular example  rather than as preplanned. thus  both the decision of what actions to i n i t i a t e   and how and where the information for those actions is obtained  is dynamically determined while the system is in operation. 
　　　the system logically consists of three parts: an interpreter responsible for carrying out i n l t l a t e d actions; an information retrieval part responsible for obtaining and putting into usable form the information required by i n i t i a t e d actions and/or the user; and finall  a modification component responsible for altering an action to f i t it into a dynamic context. currently the modification component is null and the system has been constructed so as not to invoke this function. 
　　　as part of this experiment we wanted to investigate the build-up and use of commonly used concepts in a natural way. hence  we have decided to use english as the way of specifying the actions  the concepts  and the information input to the system. however  to avold concentration on parsing of natural language  all input to the system was pre-parsed by the author  although it s t i l l 
contained the original english words. 
　　　each input by the user was examined to see whether it was a concept or fact to be added to the data base  or the i n i t i a t i o n of an action. in the former case the concept or information was merely stored in the data base 
in the input form. commands  however  caused the system to determine which action should be invoked. this is done by pattern directed invocation centered around the verbs. that 
i s   the system f i r s t determines what actions it knows about in the data base that correspond  either directly or by inference with the specified command word  verb . a second level of applicability check is made to see if the action is appropriate for the current situation. 
　　　if any such actions are appropriate  the system selects one and applies its d e f i n i t i o n . this process is repeated u n t i l one of the primitives of the system is applied. these prlmltlves cons!st of the set manipulating routines of insert  remove  create  and destroy which enable the system to add  delete or modify attributes and/or their values to objects in such sets. as the specifications 
of the o p e r a t i o n s are being a p p l i e d   contexts are being b u i l t u p   which enable the i n f o r m a t i o n r e t r i e v e r t o locate the relevant data for the operations to be performed. 
system 	operation 
       l e t ' s consider some examples from the p r o t o c o l in t h e appendix. a l l the examples in t h i s paper w i l l be drawn from the domain of card games  and p a r t i c u l a r l y from the game of h e a r t s . the system knows nothing about e i t h e r c a r d s   c a r d games  or the game of hearts i n i t i a l l y but merely the idea of ordered sets and the manipulations p r e v i o u s l y indicated as be! ng p r i m i t i v e . 
       we begin by t e l l i n g the system t h a t a hand is a set of cards ordered by s u i t and c a r d value and then t e l l i t the o r d e r i n g r e l a t i o n s h i p both f o r s u i t s and for the card values by e x p l i c i t l y naming the values of each of these a t t r i b u t e s in o r d e r . then we t e l l the system t h a t a l l p l a y e r s have a hand  and ask it to c r e a t e a player which we are going to c a l l player 1. the system creates such a p l a y e r   n o t i c e s that a l l players have a hand  and t h e r e f o r e   c o n s t r u c t s w i t h t h a t created p l a y e r   a set which is to be i t s hand  which the system knows w i l l be composed of c a r d s . we s i m i l a r l y then c r e a t e two other players named player 1 and player 1. then we c r e a t e f i v e c a r d s . having now primed the system  we are ready t o s t a r t i n v e s t i g a t i n g i t s behavior in c a r r y i n g out a s e r i e s of a c t i o n s . we begin w i t h the command   i n s e r t card   in the hand of player 1   . the   i n s e r t   p r i m i t i v e a c t i o n i s a p p l i e d and obtains both the object it is to i n s e r t and the set in which it is supposed to do the i n s e r t i o n by asking questions of the i n f o r m a t i o n r e t r i e v e r . i n t h i s case  the r e q u i r e d i n f o r m a t l o n is immedlately a v a l i a b l e ; and no problems are encountered in t h i s e x e c u t i o n . however  when we ask the system to then i n s e r t card 1 in the hand of player 1  the system f i r s t f i n d s out which card and in which set the o b j e c t is supposed to be i n s e r t e d . then  in the process of doing the 
 i n s e r t l o n   it discovers that t h i s set is o r d e r e d . it determines that the primary o r d e r i n g r e l a t i o n s h i p i s s u i t . since there already is a c a r d in that s e t . it must discover the r e l a t i v e o r d e r i n g between those two cards on the basis of the s u i t a t t r i b u t e . t h e r e f o r e   it attempts to f i n d out the s u i t of the c a r d it is now i n s e r t i n g . an i n t e r n a l quest i on is formed f o r the i nformati on r e t r i e v e r   which looks through the c u r r e n t context and the data base  but c a n ' t discover the v a l u e of t h i s a t t r i b u t e   and so   asks the u s e r . the user responds t h a t l t s a h e a r t . the system then continues o p e r a t i o n of the i n s e r t p r i m i t i v e   but sees t h a t it must a l s o f i n d the s u i t of the already i n s e r t e d card so t hat a comparison may be made. again a q u e s t i o n is formed  and again the i n f o r m a t i o n r e t r i e v e r asks the user. the user responds t h a t t h e s u i t of card 1 is a diamond. because the two s u i t s are d i f f e r e n t   the system can 
order them p r o p e r l y ; and card 1 is c o r r e c t l y i n s e r t e d in the hand of player i. 
       notice t h a t we have invoked the same r o u t i n e t w i c e . i n the f i r s t case  the only i n f o r m a t i o n t h a t it needed was the primary objects that were manipulated - the o b j e c t to be inserted and the object in which the i n s e r t i o n was to be done. in the second case  those same pieces of i n f o r m a t i o n were needed; and in a d d i t i o n   two other pieces of i n f o r m a t i o n were r e q u i r e d : the s u i t s of the two cards that were being i n s e r t e d   so that the o r d e r i n g could be p r o p e r l y maintained. 
       thus  the amount of i n f o r m a t i o n r e q u i r e d by t h i s r o u t i n e - o r   in f a c t   any r o u t i n e   is context dependent. this is one of the main reasons why we want such i n f o r m a t i o n to be dynamically obtained through the i n f o r m a t i o n r e t r i e v e r package  rather than being passed down or discovered by i n d i v i d u a l examination of a global data base. 
       to belabor the p o l n t even f u r t h e r   suppose we now i n s e r t another c a r d   and when the system asks us what the s u i t of that card i s   we t e l l it that it is also a h e a r t . since there is already a c a r d   which }s a h e a r t   in the hand  it must o b t a i n f u r t h e r i n f o r m a t i o n to resolve the c o n f l i c t . by examining the o r d e r i n g r e l a t i o n s h i p s p e c i f i e d w i t h hands  i t f i n d s that t h i s r e l a t l o n s h l p is the card v a l u e . the i n s e r t r o u t i n e must then discover the card value of both the new card being i n s e r t e d   and the o l d card w i t h which there is a p a r t i a l c o n f l i c t . 
       skipping ahead in the p r o t o c o l i a f t e r p u t t i n g the players around in a c i r c l e by means of a r e l a t i o n c a l l e d   t o the l e f t o f     we reach an i n t e r e s t i n g command  each player passes the highest h e a r t   .  for ease of 
explanation we w i l l now deviate s l i g h t l y from the protocol in the appendix.  
       once the system has obtained the r e l e v a n t a c t i o n s   of which there might be s e v e r a l   it sees which of them are a p p l i c a b l e to the given s i t u a t i o n on the basis of t h e i r a p p l i c a b i l i t y to the objects described. in the c u r r e n t example  the system had a v a i l a b l e a d e s c r i p t i o n of how to pass a c a r d . to t e s t the a p p l i c a b i l i t y of t h i s a c t i o n   an i n t e r n a l question was generated as to whether the highest heart was a c a r d . the i n f o r m a t l o n r e t r i e v e r examined the data base  and found that heart was the value of the s u i t a t t r i b u t e of the object c a r d . therefore  it assumed t h a t highest heart was a d e s c r i p t i v e term being used for card which is the highest h e a r t . hence the d e s c r i p t i o n of how to pass a card was invoked. 
       the i n t e r p r e t e r r e t r i e v e d the p r e v i o u s l y s p e c i f i e d d e f i n i t i o n of  pass a c a r d     which i s :  remove it from your hand and place it face down on the t a b l e in f r o n t of the player to your l e f t       i n f r o n t of  was taken to be a s p e c ! f l c l o c a t i o n on the t a b l e for each p l a y e r   . the i n t e r p r e t e r then invoked the remove o p e r a t i o n by p a t t e r n d i r e c t e d i nvocatlon. thl s o p e r a t i o n is one of the p r i m i t i v e s of the system c o n s i s t i n g of a l l the set manipulation o p e r a t i o n s . to perform the remove o p e r a t i o n   the o b j e c t s which  remove  manipulates must be a v a i l a b l e . it obtains these through the i n f o r m a t l o n r e t r i e v a l package  but f i r s t forms a q u e s t i o n to discover from which set the o b j e c t s are being removed. the i n f o r m a t i o n r e t r i e v e r discovers 

that !t is  your hand  and that there exist many hands in the data base. thus  your  is used to determine which one is being specified.  hand  is looked up in the data base and is found to be owned by  player.  thus  your  refers to a particular player. 
st nee 	it 	is 	not 	further 	spec!fled  	the 
information retriever assumes that the particular player is the one who is in context  that ts  the one selected earlier by the interpreter as part of the iteration of the  each player...  command. thus  the information retriever returns to the interpreter the specific set that has been referenced. next  a quest i on is formulated within the remove package to discover which object from that set is to be removed. again the question is formulated and the information retriever  working through the context stack  finds that the object is the card being passed  and that the card being passed is the hi ghest heart. at this poi nt the informati on 
retriever computes which is the highest heart within the context of the previously selected set  i.e.  the highest heart is computed on the basis of the hand in question and not the highest heart in the deck. 
　　　as one can see  the success of the i nterpretation of this particular example is c r i t i c a l l y dependent upon the order in which the questions were asked; but the knowledge that they should be asked in this particular order  namely  finding the set f i r s t and then the object within the set is part of the intelligence of the remove package  not part 
of the 	general 	intelligence 	of 	the 	system 
i t s e l f . 
　　　however  the remove routine is actually a l i t t l e b i t more general than indicated. had the i nformation retrieval package not been able to find a specific set for the remove operation  then the question would have been asked as to whether the object being specified was a named object or a computed object. if it was a named object  then the question of which set would have been re-asked in the context of those sets that contain the specific object in question. in the current example the object was a computed one; and 
hence  the strategy would have f a i l e d . 
conclusion 
　　　it is important to note at this point the f l e x i b i l i t y that has been demonstrated by this admittedly simple example. the correct interpretation of the command was accomplished 
by the combination of the following:  information in the data base which allowed us to determine that the highest heart was an instance of card; the context set up by a d e f i n i t i o n of one of the operatons used in carrying out that command  namely  the context established by the set specification in the d e f i n i t i o n ; and the intelligence incorporated in the system at the lowest level in the order in which the remove package dynamically obtalned i ts parameters. the combination of these elements in an environment that dynamically obtalns information as required has produced an instance of the f l e x i b i l i t y that people seem to have in locating and u t i l i z i n g information as opposed to the 
1 
users passtwho player which each object card sult hearts  which lowest   sys: what is the means of pass  
	user: 	pass object card:*1 means remove object 
*1 from hand whjch your then insert  object * l   t n hand of player whlch-lsto-the-left of player    
	sysj 	what is the means of lowest  
users lowest means card-value most small sys* input accepted user: stop 
