	session 1 	automatic programming 
automatic program synthesis ik second-order logic 
jared l. darlington 
gesellschaft fur mathematik und datenverarbeitung 
bonn  germany 
accordingly  we have 
1  




in the application of second-order logic to program synthesis we have so far found no need for an equivalent of the elimination r u l e   nor do we need an i t e r a t i o n rule since by d e f i n i t i o n this applies only to languages of order higher than two  see pietrzykowski and jensen1 for the formal d e f i n i tions of these r u l e s   . huet1 also dispenses with these l a t t e r two rules  but in a way that preserves deductive completenees. our algorithm is actually an incomplete one for w-order  rather than just second-order  logic  the essential r e s t r i c t i o n being that  since the u n i f i c a t i o n of f j   x .   x     . .     x   and b proceeds by trying to match the xi with well-formed pieces of b  b must act u a l l y contain well-formed pieces of the same type 
as the xi. our program has in fact proved some theorems of order higher than two  such as the example in section 1 of pietrzykowski's and jensen's paper1 . 
¡¡¡¡¡¡the generation of resolvents  l i k e the u n i f i c a t i o n algorithm  is based on the f i r s t - o r d e r prooedure  in that the substitutions generated in the course of unifying two l i t e r a l s are applied to the disjunctively connected  remainders   that i s   l i t e r a l s not being resolved on  of the two clauses being resolved  the one important difference being that lambda-normalisation is applied during the substitution prooess in order to eliminate lambdafunations from the resolvent wherever possible. the order of generating resolvente is based on the 
 s-l resolution  method for f i r s t - o r d e r logic of 
kowalski and kuehner1  and is essentially a   d e p t h - f i r s t   search strategy with resolution only on f i r s t l i t e r a l s of clauses  but with the aid of a set of reductive rules that perform algebraic simplifications or transformations on the clauses generated. among the problems solved by our program are the construction of snobol programs for computing the faotorlal function and for i t e r a t i v e d i v i s i o n ! the computer printouts are given f o l lowing the t e x t . by way of explanation  axioms cl1 - cl1 are equivalent to those given in the t e x t   but with the order of l i t e r a l s changed and with some implications expressed in terms of conjunction and negation  for more effective a p p l i cation of   f i r s t - l i t e r a l resolution  and for ensuring that the resulting proofs w i l l be linear. cl1 in each of the examples formulates the problem  h and n are input variables  and j and k are output variables. in example 1  cl1 says that if there is a state s1 in whioh k has the same value as j i where j has the same value as n   i n other words  if k has the same value as nt   then s1 is an answer. in example 1  cl1 says that if k has the same value as h -  jn n  where the value of k is less than that of n  in order wordb  if 
h ¡ö j .n + k  k  n  in s1  then s1 is an answer. both of these examples were taken from manna and waldinger1. of the reductive rules exhibited by the examples  rule 1 transforms  x+1 ! into 
  x !   .   x + 1   ; 	rule 	1 transforms x -   y+1 .z xinto 
{x - y.z  - 	z; 	rule1 reduces 1.x  x.o or 1 	to 
1| rule 1 reduces x or 1 to 1t rule 1 reduces 1+x  x+1 or x-1 to x  and rule 1 is a  frame  rule that reduces in ldert x. x1   e. s1   to in ident x1 x1   s1   provided that s1  does not affeot  x. or x1. host of these rules are purely ad hoo and are chosen with the particular examples in view; for serious program synthesis one would need a more systematically organised algebraic a i m p l i f i e r . f i n a l l y   there is a routine called  ansprist  that polishes up the answer and prints it out in the correct shobol line-by-line format  though it may be noted that the sample programs are not as  simple  as they could be. running times for examples of this general type are three to f i v e minutes on the ibm 1 at the gmd in bonn. the theorem-proving program  like the programs generated  is coded in sh1l-1* apart from line divisions  the output is an exact transcript i o n of the computer printouts. 
