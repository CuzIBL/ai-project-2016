
although even propositional strips planning is a hard problem in general  many instances of the problem  including many of those commonly used as benchmarks  are easy. in spite of this  they are often hard to solve for domain-independent planners  because the encoding of the problem into a general problem specification formalism such as strips hides structure that needs to be exploited to solve problems easily. we investigate the use of automatic problem transformations to reduce this  accidental  problem complexity. the main tool is abstraction: we identify a new  weaker  condition under which abstraction is  safe   in the sense that any solution to the abstracted problem can be refined to a concrete solution  in polynomial time  for most cases  and also show how different kinds of problem reformulations can be applied to create greater opportunities for such safe abstraction.
1 introduction
planning  even in the very restricted case of the propositional strips formalism  is  in general  a hard problem  in fact  it is pspace complete; bylander  1 . but not all planning problems are hard: in fact  it has been shown that in many of the benchmark domains frequently used to evaluate planning systems  a plan can be found by simple procedures running in low-order polynomial time  helmert  1b . in spite of this  the problems are not easy for domain-independent planners. that is not to say that planners can not solve problems in these domains - many recent planners scale up fairly well - but what determines the difficulty of a particular planning problem for a given planner is often not the intrinsic complexity of the problem  but more the size and structure of the problem encoding. this discrepancy between the essential complexity of the problem being solved and the accidental complexity  i.e.  the difficulties added to the problem as a result of the way the problem is formulated  the tools adopted for solving it  etc.  is not unique to automated planning1.
　we investigate some transformations aimed at reducing the accidental complexity of planning problems  mainly by abstracting away parts of the problem that are easily solved. abstraction has a long history in ai planning  and it has been shown that it can reduce problem-solving effort exponentially  knoblock  1   but also potentially increase the required effort  ba：ckstr：om and jonsson  1  . methods of abstracting  decomposing or  factoring  planning problems have attracted renewed interest recently  e.g. sebastia et al.  1; domshlak and brafman  1 .
　we focus on  safe  abstraction  i.e.  on finding conditions under which solutions to an abstracted problem are guaranteed to be refinable into a concrete solution. in most abstractions we consider  refinement of an abstract solution is a polynomial-time operation  though  in the worst case  the generated plan may be exponentially longer than the shortest plan . we also show examples of how  difficult  problem formulations can make safe abstraction impossible  and suggest some methods to  automatically  reformulate problems to make them more amenable to abstraction.
　due to space restrictions  proofs and detailed algorithm descriptions are omitted from the paper  but will be provided on request.
1 representation
a domain-independent planner is - indeed must be - presented with an encoding of a planning problem in a problem specification formalism. our starting point is the standard propositional strips representation but  like several researchers have recently done  we also consider an alternative representation based on multi-valued  rather than propositional  state variables  jonsson and ba：ckstr：om  1; edelkamp and helmert  1; helmert  1b . in this representation  a world state assigns to each of a set of variables  {v1 ... vn}  a value from a finite domain di. each action is described by a pre- and a postcondition  which are partial assignments over the set of variables. the postcondition is interpreted as an assignment: on execution of the action  the variables mentioned in the postcondition are changed as indicated and variables not mentioned keep their values.

ality of a program or algorithm  while the accidental complexity is the  complexity overhead  caused by inadequate tools or languages  making simple solutions difficult to state.
 c 
figure 1:  a  causal graph for a simple logistics problem;  b  and  c  domain transition graphs of two problem variables. edges in the dtg in figure  c  are annotated with the preconditions of the corresponding actions on other variables.
　the multi-valued state variable representation is expressively equivalent to propositional strips and can be constructed from the strips representation by making use of state invariants of a particular kind  namely sets of atoms with the property that exactly one atom in each set is true in every reachable world state. several methods for automatically extracting such  exactly one  invariants from strips encodings have been proposed  e.g. edelkamp and helmert  1; scholz  1; helmert  1b .
　we also make use of two kinds of graphs that summarise some structural properties of a planning problem: the causal graph of a planning problem is a directed graph whose nodes correspond to problem variables  multi-valued or propositional  and that has an edge from iff some action that has an effect on v  has a precondition or effect on v . in particular  the causal graph contains a bidirected edge between any pair of variables such that there exists an actionthat changes both simultaneously. the domain transition graph  dtg  of a  multi-valued  variable v is a directed graph whose nodes correspond to the values in the domain of v and whose edges correspond to actions that change the value of the variable: the graph has an edge fromif there exists some action whose precondition includes v = v and whose postcondition includes.
　to illustrate  consider a very simple transportation problem: two packages  pkg1 and pkg1  can be loaded in and unloaded from a truck  which can move freely between some locations  a  b . the multi-valued variable representation of this problem has a variable loc truck   with values { at truck a    at truck b }  and a variable loc  p  for each package  p  with values { at  p a    at  p b    in  p truck }. note that values in the variable domains correspond to atoms in the strips encoding of the problem. the causal graph and domain transition graphs of two variables are shown in figure 1.
1 abstraction
the idea of hierarchical abstraction in planning is to solve the problem first in an abstracted version  in which only the  critical  aspects of the problem are considered and the  details  are ignored. because these  details  are not taken into account  the solution to the abstract problem may not be a valid plan. the next step is to find  in the non-abstracted version  a plan to  bridge the gap  between each step of the abstract plan. solving the abstract problem is generally easier  as is filling in the missing details because the plan fragments needed to bridge consecutive steps in the abstract plan are typically short. this can be done recursively  with each  bridging plan  successively refined through a number of abstraction levels.
　in an ideal abstraction hierarchy any solution at a higher level of abstraction can be refined into a solution at the next lower abstraction level by only inserting some actions   fill in the details    that is  without changing the solution as it appears at the more abstract level. this is the downward refinement property  as defined by bacchus and yang . when this property does not hold  the abstract solution found by a planner may not be refinable to a concrete solution  forcing backtracking to generate a new solution at the higher abstraction level.
　knoblock  has proposed an efficient procedure for automatically generating abstraction hierarchies satisfying a weaker property  called ordered monotonicity: in such a hierarchy  there exists at least one abstract plan that can be refined into a concrete plan  if the problem is solvable . knoblock's procedure constructs a graph over the atoms in the planning problem  essentially the causal graph  and computes the tree of strongly connected components of this graph which is then topologically sorted to yield a hierarchy. the procedure can equally be applied to the multi-valued variable representation of a problem  resulting in the same hierarchy. in the transportation problem described above  the resulting hierarchy considers at the most abstract level only the location of one package; at the next  the other package as well; and only at the concrete level  the location of the truck.
　if every  refinement problem   i.e.  the subproblem solved when refining a plan down one level in the abstraction hierarchy  is known to be solvable  then clearly any abstract plan can be refined. this is the case in the example transportation problem: as the variable loc truck   representing the location of the truck  can change from any value to any other value  whatever the state of the other variables and without changing any of them  it is always possible to refine an abstract plan for moving the packages by inserting actions to move the truck to appropriate locations.
   more generally  the downward refinement property can be ensured by abstracting only when some sufficient condition for the solvability of all  relevant refinementproblemsis met. this idea  termed  safe abstraction  was recently introduced by helmert  1a   as an improvement of the fast downward planner1. to formalise safe abstraction  define the free domain transition graph of a variable v as the subgraph of the dtg containing only the edges due to actions that do not have any pre- or postcondition on any other variable. a value is free reachable from value v iff there is a path from  in the free dtg of v . helmert's condition for safe
variables:actions:b1: {1  1}inc1:b1: {1  1}pre: b1 = 1b1: {1  1}post: b1 = 1init: b1 = 1 inc1:b1 = 1 pre: b1 = 1  b1 = 1b1 = 1post: b1 = 1  b1 = 1goal: b1 = 1 inc1:b1 = 1 pre: b1 = 1  b1 = 1  b1 = 1b1 = 1post: b1 = 1  b1 = 1  b1 = 1figure 1: a small instance of the binary counter planning problem.

	 a 	 b 	 c 
figure 1:  a  the causal graph of the problem in figure 1.  b  the dtg of variable b1;  c  the free dtg of b1.
abstraction is that the free dtg forms a single  strongly connected component i.e.  that every value is free reachable from every other value. this condition  however  is unnecessarily strong: for downward refinement to be ensured  it is sufficient that any value of the variable that is required to refine an abstract plan is free reachable from every value that the variable may take on as a consequence of that plan. let the externally required values of variable v be those values that appear in the precondition of some action that changes a variable other than v and let the externally caused values of v be those values that appear in the postcondition of some action that changes a variable other than v   plus the value of v in the initial state.
theorem 1 if all externally required values of v are strongly connected in the free dtg and free reachable from every externally caused value of v   and the goal value of v  if any  is free reachable from each externally required value  then abstracting v is safe  i.e.  preserves downward refinement .
checking the safe abstraction condition and refining each step in an abstract plan are both polynomial in the size of the domain of the state variable  which corresponds to the number of atoms that make up the variable. the principle is straightforwardly transfered to components of more than one variable  but at exponentially increasing computational cost since the  domain transition graph  of such a component is the abstract state space of all variables in the component.
　to illustrate the difference that the weaker condition makes  consider a planning problem involving a binary counter that can only be increased  in steps of one: the problem description  in multi-valued variable form  for a small instance is shown in figure 1. variables b1  b1  b1 represent the bits of the counter. figure 1 shows the causal graph of the problem  and the dtg and free dtg of variable b1. the free dtg of variable b1 is not strongly connected; however  the only externally required value is 1  a precondition of inc1 and inc1  and a goal  and the only externally caused value is 1  and since 1 is indeed free reachable from 1  variable b1 is safely abstractable. moreover  abstracting away b1 makes the transition from 1 to 1 in the domain of b1 free  and thus b1 also safely abstractable in the same way; following the abstraction of b1 also b1; and so on.
　note that the causal graph of the problem  shown in figure 1 a   forms a single strongly connected component. thus  knoblock's abstraction procedure applied to this problem yields only a single abstraction level  comprising the entire problem. the causal graph summarises all possible causal dependencies in a planning problem  recall that it has an edge between variables iff there exists some action that changes v  and depends on or changes v  . the free dtg condition  on the other hand  focuses on what is possible to achieve independently of other variables.
1 reformulation
typically  there are several ways that a planning problem can be encoded in a specification formalism  such as strips. it is widely recognised that different problem formulations may be more or less suited to a particular planning system or technique. although the abstraction conditions discussed in the previous section rely on the causal and domain transition graphs  which are considered to be  structural  features of a problem  they too suffer from such encoding sensitivity. ideally  a planner should be able to accept any problem formulation  and if necessary reformulate it in a way more suited to the planners needs. sometimes  such reformulation is possible by exploiting structure in the problem description.
　as an example  consider the well known towers-of-hanoi problem. this problem was used by knoblock  to demonstrate the construction of an effective abstraction hierarchy. figure 1 a  shows the encoding used by knoblock: it represents the position of each disc by the peg that the disc is on and has a different action for moving each disc. figure 1 b  shows a different encoding of the domain  introduced by bonet & geffner . in this formulation  the position of each disc is either on a peg  with noting beneath it  or on a larger disc  and there is a set of additional atoms to represent that a disc or peg is  clear   has nothing on it . the same action moves each disc.
　both encodings are correct  in the sense that they capture the essential constraints of the original problem  but they differ in their properties. figure 1 shows the corresponding causal graphs  for the strips representation of the two problem formulations . the causal graph for knoblock's formulation consists of three strongly connected components  each contains atoms relating to the position of one disc   forming a tree  and thus a three-layered abstraction hierarchy. the causal graph for bonet's & geffner's formulation  however  has only a single connected component. thus  knoblock's procedure does not find any abstraction hierarchy in this formulation of the problem; neither does the safe abstraction condition defined above. for finding safe abstractions  a
atoms:
 on  disc  peg 	 disc = large  medium  small
 peg = peg1  peg1  peg1
actions:
 move-small  p1  p1 : pre:  on small  p1  add:  on small  p1  del:  on small  p1 
 move-medium  p1  p1 : pre:  on medium  p1    not  on small  p1     not  on small  p1    add:  on medium  p1  del:  on medium  p1 
 move-large  p1  p1 : pre:  on large  p1    not  on medium  p1     not  on medium  p1   
　　　 not  on small  p1     not  on small  p1    add:  on large  p1  del:  on large  p1 
 a 
atoms:
 on  disc  pos 	 disc = large  medium  small
 pos = peg1  peg1  peg1  or any smaller disc
 clear  pos 
actions:
 move  d  p1  p1 : pre:  can-go-on  d  p1    on  d  p1    clear  d    clear  p1  add:  on  d  p1    clear  p1  del:  on  d  p1    clear  p1 
 b 
figure 1: two different strips encodings of the towers-ofhanoi problem.
problem formulation with less  coupling   fewer mutual dependencies  between variables is generally better. how can bonet's & geffner's strips formulation be rephrased - automatically - so as to be if not identical to knoblock's formulation  then at least as good for this purpose 
　the atom  clear  d  in the second encoding is actually equivalent to the statement   x on x  d   i.e.  the atom acts as an  abbreviation  for a more complex condition. this equivalence is simply a restatement of an  exactly one  invariant  the same kind used to construct the multi-valued variable representation of the problem . for example  { clear large    on medium large    on small large } is such an invariant; thus   clear large  is true exactly when   on medium large …   on small large  holds  and consequently can be re-

	 a 	 b 
figure 1: causal graphs of the two formulationsof the towerof-hanoi problem shown in figure 1.

figure 1: causal graph for the capacity restricted transportation problem.
placed by the latter in action preconditions and in the goal1. performing such substitutions it is possible to eliminate all clear atoms from action preconditions  and once these atoms do not appear as preconditions  or goals  they can be removed from the problem entirely.
　in the present example  however this is not enoughto make the problem hierarchically abstractable. to obtain such a formulation  it is necessary to invent new propositions abbreviating certain conditions  and substitute these into action preconditions and effects. for example the relevant conditions for the medium disc are  on medium  peg ‥   on medium large … on large  peg    for each  peg.
　eliminating atoms based on  exactly one  invariants is a simple operation  easily automated. however  each invariant gives rise to several possible - mutually exclusive - substitutions  and chosing which - if any - should be applied to arrive at a better problem formulation is not so easy  and automating the introduction of new abbreviating atoms even more difficult. also  while the substitution is polynomial in time  it may introduce complex action preconditions  which may require exponential space to compile away.
1 composition
let us return to the simple transportation problem in section 1  but add a capacity restriction on the truck: it can carry at most one package at a time. this is naturally encoded with a new variable  in truck   with values { empty truck    in  p truck }  for each package  p1. the causal graph of the new problem is shown in figure 1.
　the variable loc truck  is safely abstractable as before  but the variables representing the locations of the packages are now dependent  via the in truck  variable  so the abstracted problem does no longer nicely decompose. the variable in truck  could be eliminated by reformulation as described in the previous section  using the invariant fact that  empty truck  is equivalent to   in pkg1 truck  …   in pkg1 truck   but this does not remove the coupling between variables loc pkg1  and loc pkg1 .
　however  in this problem  unlike the towers-of-hanoi problem above  the coupling between variables loc  p  and in truck  is  transient . assuming the goal is to move package  p to some location  not to leave it in the truck   the abstract plan consists of two steps: loading  p at its initial location and unloading it at the goal location  recall that the location of the truck has been abstracted away . although the actions in this plan change both variables  the plan as a whole does not: in truck  =  empty truck  holds both at the start and end of it  and only loc  p  changes permanently. moreover  the intermediate state visited by this abstract plan is  uninteresting   in the sense that the only actions that can be taken in this state that could not also be taken in the state before or after the plan are the one that completes the plan and one that just undoes the effects of the first. thus  the two actions in the plan can be replaced by a single action  with the compound pre- and postconditions of the sequence  without affecting the solvability of the problem  and performing this replacement for all such sequences breaks the coupling between the two variables.
theorem 1 let c be a condition on two or more variables  let a be the set of all actions whose effect includes c1  and let b be the set of actions whose precondition includes c. if c does not hold in the initial state; c is either inconsistent with or disjoint from the effects of every action not in a; the postcondition of every action in a is either inconsistent with or disjoint from the goal condition; and every action not in b whose precondition is consistent with c is commutative with every action in a“b  then replacing the actions in a“b with one composite action for each executable sequence a b1 ... bk  where k  1  a （ a and each bi （ b - excluding sequences with no effect - is safe  i.e.  preserves solution existence .
if the safe sequencing condition holds for every effect c involving some pair of variables v1 and v1  and if the effects of each of the new composite actions change at most one of v1 and v1  this replacement removes the causal coupling between the two variables due to simultaneous change. there may still be causal dependencies between them due to some action changing one having a preconditionon the other: if such dependencies exist in both directions  nothing is of course gained by making the replacement.
　collapsing a sequence of actions into a single action has also been proposed by junghanns & schaeffer   in the context of solving the sokoban puzzle  in the form of what they call  tunnel macros . these sequences correspond to moves in a tunnel  where there is only one  productive direction of movement and also satisfy the criterion of having  uninteresting  intermediate states  the condition c in theorem 1 can be thought of as defining a  tunnel  in the state space of the planning problem . however  tunnel macros in sokoban serve a different purpose  viz. to reduce search depth  and are not restricted to actions that cause coupling between variables. likewise  botea et al.  show that adding macro actions to a planning problem can improve the efficiency of search  and  in some cases  heuristic accuracy; interestingly  so can removing macros  haslum and jonsson  1  . yet  the procedure they propose for generating macros may be adaptable to our purpose as well.
	domain	simplification

grippersolved.logisticssolved.moviesolved.mysterynone.mprimenone.gridminor  ゛1% less atoms .blocksworld  1 ops minor  1 - 1% less atoms elevator  strips solved.freecellnone.depotsminor  1 - 1% less atoms .driverlogminor  1 - 1% less atoms; small instances solved .roverssignificant  1 - 1% less atoms .satellitesolved.airportsome  1 - 1% less atoms .pipesworldnone.promelanone.psr  small varied  1 - 1% less atoms .figure 1: simplification obtained by current techniques on planning problems from different domains.
1 conclusions
abstraction and decomposition  or  factoring   can be very powerful tools for reducing the accidental complexity caused by encoding a planning problem in a general problem specification formalism  such as strips. we have shown how the applicability of these methods can be widened  by formulating a weaker condition for safe abstraction and by applying different reformulations to make problems more amenable to abstraction.
implementation & current results
the techniques described above  together with the action set reduction method proposed by haslum & jonsson  and standard reachability and relevance analysis1  have been implemented  though with some limitations: safe abstraction of more than one variable is limited by a bound on the size of the composite dtg  reformulation is restricted to atom eliminations with a simple replacing condition  and composition to sequences of length two. the strategy is to try each technique in turn  iterating until no more simplifications are made. in spite of the restrictions  some operations are still too timeconsuming  and therefore disabled  in some domains. also  different methods for finding invariants in some cases result in different multi-valued variable encodings  some of which are more suited to simplification than others. thus  the system is not completely automatic.
　table 1 summarises the  best achieved  result of attempting to simplify a collection of planning domains  comprising most of the domains from the 1st  1nd  1rd and 1th planning competitions. many of these encode very simple problems  and indeed in many of them  those marked  solved  in the table  repeated abstraction removes the entire problem  so that these problems are solved without search  except for the simple refinement searches carried out in the dtg of individual variables  the logistics and elevator domains are solved in this sense also with helmert's safe abstraction method . for remaining domains  simplification is roughly measured by the reduction in problem size and a subjective estimate of the  complexity  of the part that remains  for example  in the grid domain  only some irrelevant objects are removed; though this cuts down size significantly  it's viewed only as a  minor  simplification . how problem simplification affects the performance of different planners is a far more complicated question  for example  for  depots problems the - very minor - simplification drastically improves the accuracy of ff's heuristic  resulting in significant speedup  while for one problem time increases and for remaining problems it has no effect .
open problems
most interesting to note among the results  however  are the failures  that is  domains that model essentially simple problems  but which the current suite of techniques fail to simplify  such as the blocksworld  schedule and psr domains. what methods are needed to effectively deal with these domains  one observation is that our current techniques make very little use of knowledge about the particular problem instance. in the blocksworld domain  for example  every variable potentially interacts with every other variable  making the problem difficult to abstract or decompose  but the interactions that actually need to be considered in the solution of any given problem instance are typically few. much use has been made of the causal graph to analyse planning problems  but it is  as noted above  only a very coarse summary of potential interactions. the weaker abstraction condition yields a more fine grained view but still takes into account many possible  not actually relevant  interactions.
　the current implementationworks on a grounded propositional or multi-valued  problem representation  which makes some steps computationally expensive. applying these and other techniques in a first order setting  and to domain formulations using adl constructs  is an important future development. also  as noted above  the choice of transformations to apply is not fully automatic. this is a hard problem  where we see a potential for learning to play an important role.
acknowledgements
hector geffner  adi botea  malte helmert and the ijcai reviewers have all contributed ideas  advice  discussions and helpfull comments on various drafts of this paper. nicta is funded through the australian governements backing australias ability initiative  in part through the australian research council.
