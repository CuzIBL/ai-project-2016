 
many planning problems exhibit a high degree of symmetry that cannot yet be exploited successfully by modern planning technology. for example  problems in the gripper domain  in which a robot with two grippers must transfer balls from one room to another  are trivial to the human problem-solver because the high degree of symmetry in the domain means that the order in which pairs of balls are transported is irrelevant to the length of the shortest transportation plan. however  planners typically search all possible orderings giving rise to an exponential explosion of the search space. this paper describes a way of detecting and exploiting symmetry in the solution of problems that demonstrate these characteristics. we have implemented our techniques in stan  a graphplan-based planner that uses state analysis techniques in a number of ways to exploit the underlying structures of domains. we have achieved a dramatic improvement in performance in solving problems exhibiting symmetry. we present a range of results and indicate the further developments we are now pursuing. 
1 introduction 
stan  long and fox  1  is a planner  based on the architecture of graphplan  blum and furst  1   that uses a range of static state-analysis techniques to enhance its planning performance  fox and long  1 . these techniques work by giving the planner insights into the underlying structural features of the domain  and of problem instances in that domain  and making them accessible to exploitation by the planner. one of the characteristic features of problems in many domains is their underlying symmetry. a problem exhibits a high degree of symmetry if there are many functionally identical objects that cannot be usefully distinguished. for example in a construction world  in which there are hundreds of nails in a box  planners would quickly become lost in the search between alternative nail permutations in the solution of a construction instance. this search is wasted since all nail permutations are effectively equivalent. where symmetry occurs in a problem it can be exploited in a very powerful way by treating all symmetric objects as indistinguishable. this allows the planner to avoid considering plans that differ  from those already considered  only in the specific symmetric objects referred to or in the order in which symmetric objects are manipulated. 
　in this paper we describe an algorithm for exploiting object and action symmetries that have been automatically extracted from a problem description. symmetry is a feature of problems  rather than of domains  although some domains naturally give rise to highly symmetric problems. our symmetry mechanism has been implemented in stan and has yielded dramatic performance improvements across a variety of problems from standard benchmark domains. despite the improvements that can be observed from our results we are not yet exploiting all of the symmetry that is available in a problem that displays symmetric structure. we explain why this is the case and discuss an extension to our current approach that will overcome this limitation. 
1 static symmetry detection 
symmetry analysis is a static analysis process that is independent of the planning architecture that will exploit the detected symmetries. thus  although stan is a graphplan-based planner and the algorithm for exploiting symmetry is graphplan-dependent  the processes by which symmetry is detected in a problem description are entirely graphplan-independent. this is in keeping with our philosophy of providing planner-independent static analysis tools for extracting implicit structure from domain and problem descriptions which is then available  for exploitation by planners  to reduce search during plan construction. 
　the static analysis is in two phases. in the first phase groups of symmetric objects are automatically extracted from a problem description given as the initial and goal states expressed in the language of strips  fikes and nilsson  1 . for our purposes we define symmetric objects to be those which are indistinguishable from one another in terms of their initial and final configurations. for example  in the gripper domain  ball  and ball1 can 
　
be considered symmetric with one another if  in the initial state  balk and ball1 are both at rooma and  in the goal state  balk and ball1 are both at roomb. when constants appear in operator schemas they are abstracted  generating additional initial conditions which can only be satisfied by those constants. for example  the appearance of the constant ball1 in an operator schema gives rise to the additional precondition ball1 x   which can only be satisfied by ball1 using a newly created initial state condition balli  balli . this ensures that constants with special roles in operators cannot be mistakenly seen as symmetric to other objects in the domain. 
　our strategy is to begin by identifying pairs of symmetric objects to form the bases of symmetry groups  and then to extend these groups by adding other objects from the same types. types are inferred automatically by the type inference module  tim  of stan  fox and long  1 . type information reduces the search involved in building the object symmetry groups because objects of different types cannot be symmetric with one another and can be immediately excluded from comparison. 
　this analysis is sensitive to the specification of initial and goal states. symmetry can be unnecessarily lost if redundant information is included in the problem specification. for example if  in the initial state  the left and right grippers are free and in the goal state nothing is specified regarding either gripper  then the grippers will be determined to be symmetric objects. however if  in the goal state  it is specified that the left gripper is free  but nothing is specified about the right gripper  then the left gripper will be assumed to have special properties that make it asymmetric to the right gripper even though  in fact  both grippers will be free by the time all of the balls have been transferred. although this might make the symmetry analysis seem fragile  its sensitivity is actually one of its strengths. any divergence in the states of objects is interpreted as evidence that they should not be treated as entirely indistinguishable. except in the case where apparently distinguishing information is actually redundant this interpretation is correct. 
　the second stage in the process is the identification and grouping of symmetric actions: any actions whose parameters are drawn from the same collections of symmetric groups are themselves symmetric. for example  pickup balli rooma right  is symmetric with pickup hall1 rooma left  but not with pickupfbalk roomt  left  because rooma and roomb are not symmetric. we produce action symmetry groups by pairwise comparisons of these action instances. 
1 the use of symmetry by stan 
the exploitation of symmetry in stan is dependent upon the graph construction and search techniques common to planners based on the graphplan architecture. graphplan uses constraint satisfaction techniques to search a layered graph which represents a compressed reachability analysis of a domain. the layers correspond to snapshots of possible states at instants on a time line from the initial to the goal state. each layer in the graph comprises a set of facts that represents the union of states reachable from the preceding layer. this compression guarantees that the plan graph can be constructed in time polynomial in the number of action instances in the domain. the expansion of the graph  from which solutions can be extracted  is partially encoded in binary mutex relations computed during the construction of each layer. stan implements an efficient representation of the graph in which a wave front  long and fox  1  further supports its compression. in graphplanstyle planners the search for a plan  from layer k  involves the selection and exploration of a collection of action choices to see whether a plan can be constructed  using those actions at the kth time step. if no plan is found the planner backtracks over the action choices. 
　the objective of the analysis and exploitation of symmetry is to reduce the number of action choices that are searched. thus  when stan backtracks over an action choice it avoids considering symmetric alternatives since a symmetric alternative to a given action instance can never make more progress than that action instance. for example  in the gripper domain  if no plan to transport n balls to rooma can be found  ending at layer k  by dropping balln from the right gripper  then no plan will be found  ending at layer i  by dropping balln from the left gripper. handling symmetry correctly involves a number of subtleties. for example  when a specific object in a symmetry group has been selected for a particular role in the plan it is no longer symmetric with the other objects in the group because it can now be distinguished from those other objects on the basis of the particular roles it plays. in our mechanism the symmetry of an object is broken as soon as it can be distinguished from the others in its group. on backtracking over an action choice we reinstate the symmetry of the objects whose symmetry was broken on selection of that action. we need both layer-dependent and layer-independent information to support the correct maintenance of action symmetry in the plan graph. a pseudo-code description of the graphplan-style search algorithm of stan  highlighting the modifications necessary to exploit object and action symmetries  is given in figure 1. the basic algorithm should be familiar to readers conversant with the graphplan algorithm. the bold typeface is used to indicate the extensions to the basic algorithm necessary to support the use of symmetry. the mechanism is nonheuristic and does not have to be manually selected or deselected when the planner is presented with specific domains  as is the case with some of the domain analysis techniques discussed in the literature  nebel et al.  1 . the effects of the symmetry machinery on search completeness  which are benign  are discussed below. the overhead associated with the symmetry mechanism is discussed along with the empirical results below. 
　there are two key data structures involved in the correct exploitation of symmetry in stan. one of these is 
	fox and long 	ssi 
　
lb search from layer in with goal set gs: 
if gs is empty 
then search from layer in - 1 with the goal set constructed from 
           all preconditions of actions selected at layer in if no plan is found then reset tried groups at layer in - 1; backtrack to last choice point; 
else return completed plan; 
else consider first goal  g  goal set  gs: if g is still unachieved at layer in then for each action  a  which can achieve g at layer in: 
if symmetry group for a already tried 
then continue to next action; choose action a to achieve g; 
increment brokensym entries for symmetric parameters; 
if searching from in with gs   {g} yields a plan 
then return the completed plan else retract action a; decrement brokensym entries for symmetric parameters; 
mark action symmetry group as tried; 
continue to next action; 
when all actions have been tried  fail at this point in search and backtrack; 
else search at in with gs   {g}; if a plan is found then 	return the plan else 	fail at this point and backtrack. 
f i g u r e 1: core graphplan-style search algorithm indicating modifications for symmetry-exploitation 
layer-independent and one layer-dependent. the layerindependent structure  brokensym  is a vector of integers  one entry for each domain object in a symmetry group of more than one object. every time an action is applied the entries corresponding to the objects in the action instance are incremented. a non-zero entry indicates that the corresponding object is no longer symmetric. when an action is retracted the appropriate entries are decremented. the entries are not binary because a sequence of actions might need to be retracted in order to restore the symmetry of an object. the layer-dependent data structure is an array of matrices  triedgroups  one matrix for each group of symmetric actions  recording which action symmetry groups have been tried at that layer. the number of dimensions of a matrix is equal to the number of symmetric parameters referred to by actions in that symmetry group. the matrices can be allocated during graph construction. their sizes are known at action instantiation  but they cannot be allocated at that time because it cannot be known how many layers there will be or which symmetric groups will be represented at each layer. the size of each dimension is one more than the number of objects in the corresponding collection of symmetric objects. the extra entry plays an important role in recognising symmetric actions as the following example shows. 
　suppose that drop balli roomb  left  is applied at some layer n + 1. if pickup  ball1 rooma left  is considered at layer n we would like to avoid considering pickup ballsfrooma left ' since balk 1 and 1 are symmetric so the two pickups should be considered as symmetric even though the symmetry of the left gripper has been broken. on the other hand  we want to try pickup ball1 rooma right   because the use of the left gripper at layer n + 1 might have been the cause of the failure of the first pickup. if we simply mark pickups at rooma as having been tried we will not try pickup ball1frooma right   which would lose completeness. if we don't mark pickups then we will try pickup ball1 rooma left  as well  which we do not want to do since this would lose the advantages of symmetry. the matrix allows us to identify the remaining symmetry in an action instance. in the above situation we mark pickup * rooma left  as tried  where   stands for an arbitrary argument to the pickup instance  so we will not try pickup balls rooma left   but will try pickup ball1 rooma right . because the symmetry of ball  was broken at layer n+1  so that pickup balli roomafleft  is not symmetric with the other pickups  this action instance will also be tried. the   argument represents the collection of objects with unbroken symmetry in the appropriate object symmetry group. the extra entry in the matrix is used to record the status of the action symmetry group with the corresponding argument set to *. 
　the way these two data structures are used is as follows. on the point of choice of an action we check to see whether the symmetry group  to which the action being considered belongs  has been tried. if it has  we reject the action with no further search. otherwise we mark all of its symmetric arguments as broken by incrementing the appropriate entries in brokensym. during action instantiation the indices of these arguments in the brokensym vector are recorded within the action instances  making access to the vector very efficient. 
　on backtracking through an action choice following failure  we decrement the appropriate entries in brokensym and mark the action symmetry group as tried at the current layer. this is done by indexing into the appropriate matrix at the entry corresponding to the particular configuration of broken and unbroken symmetric arguments in the instance. if an argument is unbroken the index 1 is used on that dimension  representing the marking of the whole object symmetry group corresponding to the   argument discussed above. otherwise the number of that object within its symmetry group  starting from 1  is used as the index. since the arguments of an action are fixed when the action is instantiated  and the positions of the symmetric arguments  within their respective symmetry groups  are fixed during initial symmetry analysis  much of the work involved in identifying the correct indices is done once and for all during construction. this makes access to the matrices very efficient so that the marking and unmarking of symmetry groups represents a negligible overhead. 
　when backtracking through a layer the entire collection of matrices at that layer is reset to enable subse-
　
quent exploitation of symmetry to be unaffected by earlier search. no-ops do not break the symmetry of their arguments  because they do not cause the states of their arguments to change  and we treat each no-op as symmetric only with itself. 
　the symmetry machinery described in this paper does not yet deal with all of the symmetry that is there to be exploited in a problem. when search begins  all objects that can be identified as symmetric will be available for exploitation as symmetric objects. however  as search progresses  from the goal state towards the initial state  object symmetry is broken for increasing numbers of objects so that there is little  or no  symmetry left to exploit in the final search layers. this happens because we cannot yet recognise intermediate domain states at which the symmetry of objects could  in principle  be refreshed. in the gripper domain  as more balls are moved into their final state  more alternative action instances become asymmetric and hence available for  useless  consideration during search. in this domain balls can be in any one of four states: at rooma  at roomb or held in the left or right gripper. each of these alternatives potentially represents a symmetry state for balls. only the first two of these symmetry states are interesting since only one ball can be held by any gripper at any time. we would like to be able to fully exploit these two symmetry states for balls. at present the mechanism only identifies the balls as symmetric whilst they are in their goal room because graphplan planners search backwards from the goal state. if we could recognise being in the start room as a symmetry state for the balls we could refresh their symmetry as we progressed towards the initial state. in other domains there may be multi-state symmetries to exploit  involving many different symmetry states. 
　despite the fact that we only exploit part of the symmetry in a problem we still obtain huge improvements in performance in the solution of inherently symmetric problems. in domains  such as gripper  in which there is exponential growth in the search amongst symmetric choices  and in which objects have more than one symmetry state  we only obtain benefit from one of these symmetric states. in gripper we obtain roughly a 1 per cent speed up. we have designed a modified gripper domain to demonstrate the kinds of performance enhancement we obtain in a single symmetry state  and to indicate what improvements can be expected from full exploitation of symmetry. our experiments in this  and other domains  are described later in this paper. 
1 symmetry and search completeness 
given a set of goals at layer k in the plan graph  stan will try alternative non-symmetric action combinations in the search for a plan. if a combination fails to lead to a plan then the symmetry group of the action choice that caused the failure will be marked as tried and no subsequent combinations considered will contain any action in the tried symmetry group  even though some other combination containing that action choice might actually lead to a plan. the desired action will be successfully selected at laycfr in combination with no-ops to achieve the goals that were successfully achieved at layer k. for example  suppose that actions have been tried at layer fc  and that o - belongs to symmetry group 1. then 1 will be marked as tried at layer k. if fails the desired combination  suppose it is will not be found at layer k because it contains 
an action in a tried symmetry group. this combination will be found across layers k and k + 1  since  will be tried at layer 1 and no-ops used to achieve the remaining goals achieved at layer 1. we therefore lose parallel optimal plan completeness but retain sequential optimal plan completeness. it is possible to construct problem instances in which the number of additional layers that have to be constructed outweighs the advantages of exploiting symmetry. we are therefore working on an extension to the symmetry mechanism to enable actions to be retried at a level if the search context in which they were last tried has changed. 
1 experimental results 
we have two objectives in presenting the following data: to show the advantage that the symmetry mechanism gives in solving symmetric problems and to demonstrate that no significant overhead is paid when there is little  or no  symmetry to exploit in a problem. 
　stan is implemented in c + + and the following results were computed on a sparc-1 under unix. the results demonstrate the advantages obtained by the use of our symmetry machinery in solving a selection of problems from the gripper domain  the simple tsp domain  a travelling salesman problem on complete graphs   the ferry domain and a modified gripper domain. all but the last of these are standard benchmark domains. the modified gripper domain is used to demonstrate evidence supporting our hypothesis that failure to exploit more than one symmetry state reduces our advantage proportionally with the number of symmetry states in the domain. we produced the modified gripper domain by forcing pickups to be done in rooma  the start room  and drops to be done in roomb  the destination room . as can be observed  the exploitation of ball and gripper symmetry in this domain yields an exponential advantage over that obtained in the unmodified gripper domain. 
　the data for the ferry domain  shown in figure 1  illustrates the benefits to be obtained from the exploitation of the symmetry of cars that must be transported from a single source to a single destination. the ferry domain is similar to the gripper domain in having two symmetry states for the cars  only one of which is currently being exploited by our machinery. because of the unexploited symmetry state the performance of stan with symmetry is still deteriorating exponentially  although the exponent is so much smaller than in stan without symmetry that it does not become a problem until the instances are very large. our analysis leads 
	fox 	and 	long 1 
　

f i g u r e 1: comparison between stan with symmetry and stan without symmetry in the university of washington ferry domain 
　

f i g u r e 1: comparison between stan with symmetry and stan without symmetry in the carnegie mellon university tsp domain 
　
us to conclude that exploitation of the remaining symmetry state will give us an exponential improvement in performance. this conclusion is supported by the gripper experiments detailed below. 
　the simple tsp domain  involving traversal of a fully connected graph  gives rise to problems that are  in principle  trivial but that are beyond the capabilities of most graphplan-style planners because of the n factorial permutations of the n cities to be visited. these permutations are all symmetric and figure 1 shows that stan with symmetry is able to exploit this feature and solve instances in linear time. in this domain stan exploits an additional form of symmetry not yet discussed in this paper. this is goal symmetry  which arises when two or more goals are expressed using the same predicate and arguments from the same object symmetry groups. when two goals are symmetric and can only be achieved at the rate of one per layer  because of observed interactions between their potential achievers  stan imposes an arbitrary ordering between them and does not search alternative orderings. this feature of certain domains is automatically detected by stan using the invariant inference machinery discussed in  fox and long  1 . putting the two ways of exploiting symmetry together yields substantial benefits in domains that feature this particular invariant. 
　the unmodified gripper domain is the standard version designed by the ipp team and used in the aips-1 planning competition1. there are two symmetry states to exploit but we currently exploit only one of them. by modifying the domain  so that balls can only be picked up in the source room and dropped in the destination room  we dramatically reduce the significance of the symmetry state in which the balls are in the source room. this allows us to focus on the benefit obtained by exploiting the one symmetry state without being swamped by the cost of not exploiting the remaining one. looking at figures 1 and 1  we can observe an exponential speed up obtained by suppressing the significance of the 

f i g u r e 1: comparison between stan with symmetry and stan without symmetry in the ipp team's gripper domain 
second symmetry state. this strongly supports our hypothesis that a full exploitation of all of the symmetry available within a family of problems can yield an exponential improvement in the performance of the planner. 
　finally  we present evidence using the logistics domain to demonstrate that the overhead of the symmetry machinery is negligible when there is no symmetry in a problem or when the symmetry cannot be effectively exploited. in the first case the data structures needed to support symmetry are not gven constructed so the overhead during search amounts to a single comparison confirming that there is no symmetry available for use at the points of action selection  retraction and backtracking over layers. in the second case the data structures are built  initialised and maintained to no positive effect. to explore problems with this character we constructed a family of logistics problems involving the transportation of a number of packages from a single source city to a single destination city using a single airplane. we call this version of logistics the one-dimensional logistics domain. the packages are symmetric and the individual operator schemas yield separate action symmetry groups. however  in this family of problems there is no 
　

f i g u r e 1: companion between stan with symmetry and stan without symmetry in the modified gripper domain. stan without symmetry was terminated after 1 hours on the 1 ball problem. 

figure 1: comparison between stan with symmetry and stan without symmetry in the one-dimensional logistics domain 
interesting search involved in solving them so the maintained data structures play no useful role. as can be seen from figure 1 the overhead in building and maintaining these structures is insignificantly low. 
1 further developments 
there are two important lines of further development under investigation. the first concerns the need to distinguish different search contexts in which symmetric action combinations can be considered. as discussed in section 1  failure to manage contexts leads to the loss of parallel optimal plan completeness and the loss of any efficiency advantages in certain carefully constructed examples. we are experimenting with un-marking tried symmetry groups when backtracking over earlier actionselection choices. in the example considered in section 1  the group s would be un-marked when backtracking over the choice of o1  on the grounds that the selection of an alternative to o1 creates a different context in which o  might be usefully reconsidered. 
　the second line of development concerns the identification of symmetry states which would enable a fuller exploitation of both object and action symmetries. in order to pursue this we are examining the object statetransition networks which are generated automatically by t i m as part of the type inference process. examination of these networks indicates the possible states that objects of the associated type can inhabit. the brokensym structure  in our current implementation  is replaced by a data structure which records  for each object and for each symmetry state that object can inhabit  whether the symmetry of the object is currently broken in that state. thus  the symmetry of objects can be restored as they traverse their state-transition networks. the information stored in the new data structure is level-dependent  reflecting the fact that state transitions are made by applications of actions. we expect the added overhead of initiating and maintaining the new data structures to be far outweighed  in problems where symmetry is significant  by the advantages obtained from being able to refresh symmetry as search progresses back from the goal state. 
1 conclusion 
in this paper we discuss a way of exploiting the symmetry that is inherent in many planning problems to circumvent much of the search that makes these problems intractable using current planning technology. we have described the algorithm in terms of the modifications made to the basic graphplan-style search procedure of stan. our results demonstrate the significant improvements obtained by detecting and using symmetry during the planning process. stan with symmetry  stan version 1  is available for experimental purposes from the stan web page1. 
