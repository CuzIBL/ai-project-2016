prism: a parallel inference system for problem solving 
	simon kasif 	madhur kohli 	jack minker 
department of computer science  university of maryland  college park  md 1 
　　　
1. 	introduction 
　　　prism  a parallel inference system   for parallel execution of problems  has been implemented on zmob  rieger  . prism is an experimental tool for the development of distributed ai problem solvers and is based on logic programming. familiarity with logic programming  kowalski   is assumed. 
　　　in conventional programming systems the logic and control of an algorithm are combined making it d i f f i c u l t to separate or to modify control without affecting the logic. logic as the specification language  is neutral with respect to control and specifies only the problem semantics. the method of how the problem is to be solved is external to the logic specification. thus  a primary issue in achieving a parallel system is developing an effective control specification that exploits parallelism. prism permits us to specify the problem independently of the control and allows us to experiment with alternative control possibilities for the same problem. 
　　　the basic tasks identified in the execution of a problem are: management of the search space; management and retrieval of procedures  deductive axioms ; management and retrieval of assertions  facts  or knowledge ; and interaction with the problem and control specifier  user . 
　　　prism consists of three functionally distinct sets of machines. the lntenslonal database machines  idb  unifies a goal with a l l procedure heads with the same name. the extensional database machines  edb  function as a distributed relational database machine and provide fast access to function-free ground assertions. the problem solving machines  psm  manage the search space. the psm is the major portion of prism and is where the cont r o l specification is primarily interpreted. in this paper we describe the psm and i t s support of the control facilities provided in prism.  see kasif  for further details and references on prism . 
1. control issues 
1. goal tree and control issues 
　　　a goal tree is generated in the problem solving process. the tree consists of a set of nodes  where each node consists of a set of goals. subgoals in a node may be characterized as dependent or independent of one another  a subgoal is dependent if its execution must await the successful execution of another subgoal in the same node. it is independent otherwise. an acyclic partial order expresses such a relationship among subgoals. at any stage of the execution of a node  a l l independent subgoals may be executed asynchronously. however  goals which are candidates for simultaneous execution must be treated specially if they share unbound variables. there may be several assertion/procedure heads which match a selected goal. any procedure head which matches a goal can potentially lead to-solving that goal  independent of other matching procedure heads. all matching procedure heads are therefore candidates for asynchronous execution. thus one may specify that certain alternatives need be explored only if other alternatives have failed or that some alternatives are more likely to succeed than others. all possible asynchronous operations may be executed on autonomous machines. 
1. prism control facilities and language 
　　　prism provides the ability to specify partial order for the execution of every goal and procedure body. the partial order on goals expresses dependencies among subgoals within a goal. the order is specified by a notation as illustrated by: 

the procedure head is on the left of the arrow  while the body is on the right. the body consists of a set of goals  separated by commas and formed into groups by properly nested pairs of parentheses and brackets. all groups of goals enclosed by parentheses  must be executed in a left-to-right sequence. groups of goals enclosed in brackets may be executed independently of other groups in the same set of brackets. 
　　　prism provides a notation for specifying both a recommended and a forced ordering of procedures. consider the example: 

the integers represent a recommended order of execution. the asterisked integers represent a foroed ordering. the f i r s t two procedures  priority=1  may be executed simultaneously. the third procedure  priority=1  is less likely to succeed but may also be executed in parallel with the f i r s t two  or before them if the problem solver so decides. however  the fourth procedure  priority=*1  cannot be executed unless the preceding procedures have been completely executed. a default ordering is provided by prism when the procedures are not numbered. 
1. the problem solving machine  psm  
1- 	the role of the psm 
　　　the central task of the psm is to manage the search space. the complete separation of logic  the problem specification  and control  the strategy of solving the problem  allows f l e x i b i l i t y while executing the program. not only can the search strategy be varied dynamically  but due to the inherently non-deterministic nature of logic programs  several mutually exclusive possibilities may be explored simultaneously. the psms permit this inherent parallelism to be exploited during problem solving. 
　　　i n i t i a l l y a goal  which represents the problem to be solved  is sent by the host to zmob and is read by some psm. this psm places the goal as the root of a proof tree. 
　　　at any given instant in the problem solution process the search space administered by each psm consists of a tree of goal nodes. the root of the tree is the original goal with which the psm was initiated. the successor of any nodes in this tree is the resolvent obtained by resolving program clauses with some atom in the parent node. when an atom is expanded  several program clauses which represent alternative ways to solve the problem  may resolve with i t . these alternatives lead to branching in the search tree  or branches . nodes in the tree can be in one of five states: the empty node; a failure node; an open node not yet selected for expansion; an active node selected for expansion  but not yet fully expanded; and a closed node which has been fully expanded. 
　　　at any stage the psm must select an open node from the search tree  and then select one or more atoms from this node. this selected atom is sent to an idb and/or an edb for expansion. while the idb and/or edb are working on this atom  the psm can transfer its attention to other nodes in the 
search tree. 	an atom sent to 	the 	idb 	may 	unify 
with one or more procedure heads. all corresponding bodies are sent baok to the psm which initiated the search  either one at a time or a l l at once. when more than one procedure body is returned for a given atom  several mutually exclusive subgoal nodes are generated. these mutually exclusive goals can then be solved independently in separate machines. thus each psm can dynamically initiate another psm machine  if one is available. as with the goal transmitted by the vax to a psm  the goal transmitted from one psm to another becomes a root of a goal tree in the new psm whose parent is the sending psm. each psm can independently develop and manage subtrees of the search spaoe generated by the goal node transmitted to the psm. each psm 
s. kasif et al. 1 
is autonomous except for knowledge of the parentchild relationship. when a goal assigned to a psm is completely solved it transmits the solution or failure to i t s parent psm. the parent of the psm that contains the original goal is the host  vax  machine. 
1. 	control in the psm 
1.1 . 	control specification support 	- 	selection process 
　　　the selection procedure determines the control strategy of the system. the user is permitted to specify guidelines to direct the selection process. the selection procedure has four main functions: node  clause  selection  atom selection  procedure selection and psm creation. 
node selection: any node not fully expanded is a candidate for selection. a fully expanded node is a node whose selected atom has been expanded and a l l leaf nodes descended from the node are either failure nodes or null clauses. a non-fully expanded node may be either an active or an open node. an active node is one from which one or more atoms have been selected for expansion  but is not fully expanded. an open node is one from which no atom has yet been selected for expansion. 
atom selection is concerned with selecting a atom  for expansion  from a selected node in the search tree. there are several system and user defined constraints that affect atom selection. 
　　　as defined in section 1  the user can specify which atoms in a node may be executed in parallel and which must be done in sequence  i.e. a partial order on the execution of the atoms. these user specified constraints limit the atoms which can be selected at any stage. only atoms which do not depend on any other atom or those for which the atoms they depend on have already been solved are candidates for selection. 
　　　in addition to user-defined orderings  certain orderings are implied by the node structure i t s e l f . two basic ways in which the contents of a node dictate the ordering on atom selection are: dependent atoms  and special predicates. two or more atoms in a node are said to be dependent when they share variables. in this case what is desired is the f i r s t  or all  binding s  which cause the atoms to succeed. this can be accomplished either by processing the atoms in parallel and then intersecting the sets of bindings for the shared variables  or by finding a binding which satisfies one predicate and then substituting it in the others and determining if they succeed with that binding  nested loops method . in either method a special and node is generated with the dependent atoms as i t s c h i l dren and one of the above techniques applied. special predicates are a set of language supplied predicates whose semantios dictate that certain other predicates in the clause must be fully solved before these system defined predicates may be invoked. 
　　　onoe user and system defined constraints 	have been satisfied  a set of atoms whioh are candidates for selection w i l l remain. 	the atom seleoted 	from this 	set 	w i l l be seleoted based on user or system 1 s. kasif et al. supplied heuristics. 
procedure selection is concerned with choosing which procedure body should be given the highest priority when several bodies match an atom. this decision is made exclusively by the idb. 
psm selection  is concerned with the decision of when to initiate another psm with a subproblem. whenever a branching of the search tree is induced by either multiple alternate subproblems  1rbranches  or by independent conjunctive subproblems  and-branches   this branch becomes a candidate for execution in another psm machine. the actual process of determining when a new psm is initiated is discussed below. 
1.1. 	psm creation 
　　　the decision of when to initiate another psm with a subproblem is not an easy one. if the subproblem is too small  a large amount of overhead would be incurred to solve i t . if the subproblem is too large  the parent psm may complete before the child and remain idle until i t s children complete. in general it is not possible to determine how complex a subproblem i s . thus no attempt is made to determine the complexity of a subproblem  in the i n i t i a l system. instead a new psm is i n i tiated every time a branching of the search tree takes place  and a psm is available. at any given instant  there may be several active branches within a psm  and thus several candidate nodes may be sent to other machines. in this case a l l or only some of these nodes may be shipped out. this is determined by the user or by system supplied heuristics. 
　　　in order to reduce idle time  machines which have completed their alloted task are permitted to accept fresh queries  as follows. if no further processing can be done then either a l l possible answers for the goals this psm was invoked with have been found  or a l l paths resulted in failure  or a l l paths local to this psm have been fully explored and there are some children of this psm which have not yet completed their work. when a l l answers have been found or a l l paths have failed  this information is transmitted to the parent of this psm  and the psm state is restored to one in which a new query can be accepted. when a l l local paths have been explored and some chidren psms are s t i l l active  a data structure is constructed which contains enough information to reconstruct the complete answer from the information in this psm and from the answers from the currently active children psm. once this data structure is constructed  the local proof tree is destroyed and the psm state is restored to permit a new query to be accepted. 
　　　in this manner psms are not kept idle in case they complete before their children do. this also allows a psm to be its own ancestor if so desired. 
1.1. 	and/or parallelism 
　　　the existence of multiple bodies that match a selected atom result in the formation of an or-node with each of these bodies as a child. since these children are independent of eaoh other they may be exeouted in separate machines. 
　　　and-parallelism arises when a conjunction of two or more atoms appear in a node. independent atoms that do not share variables are executed in parallel and result in the creation of an andbranch. 
1.1. 	handling negation 
　　　the not meta-predicate defined in most sequent i a l logic programming is an implementation of negation-by-failure  clark 1 . this is not well defined when one or more of the arguments are unbound variables. the behaviour of the not metapredicate can be anomalous in the case where a l l arguments are not constants. the semantics of negation is extended to handle atoms with variables as arguments by creating a set of bindings for which the atom fails and assuming the negation of 
the atom holds for precisely this set of bindings. 
1 . 	acknowledgements 
　　　the work was supported by afosr grant 1 and nsf grant mcs-1. 
1. 	