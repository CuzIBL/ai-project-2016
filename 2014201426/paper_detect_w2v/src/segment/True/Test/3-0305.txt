case planning much work planning planning loop lean heavily proposes generating plan decoupled verifying describes planner calculus illustrating sort plan show strength weakness sketch beginning validation plan done offline vast majority work planning deal planning generating goal concerned planning plan even concerned planning plan loop clear planning admits difficult even bulk work planning biundo survey also perspective plan viewed planning kind synthesis manna waldinger notoriously difficult reasoning correctness loop term correctness termination mathematical induction algebra difficulty word like difficulty planning size long plan main even difficult done away sabbatical york toronto rwth aachen universita sapienza south wale sydney simon fraser vancouver grateful host institution wonderful teaching administration sabbatical rock stephan biundo plan interactive process inference opinion well citation omitted carried automatic tell automated planning hopeless perhaps faced intractable reasoning look compromise forego correctness theoremproving generating plan traffic loop nonnegative decreasing item proving resulting plan come much weaker plan validation need done separately mind sort cognitive robotics lesperance expect user tell robot considerable nondeterminism left robot deal runtime part nondeterminism form declarative goal theywill requireplanningon part robot plan relative mission robot main contribution generating plan loop rest motivating plan searching system kplanner novel generates loop kplanner limitation work beginning foundation motivating wish chopping tree putting away sardina disposal primitive chop tree tree away observe insoluble know tree away told tree time plan chop chop chop told tree time insoluble look sensing reiter telling tree plan case look chop case look chop endc endc told tree eventually repeatedly look plan loop case look exit chop next endc endl call plan treechop case goal achievable plan like handle case plan sufficient robot move plan exactly mean plan convenient variant robot levesque primitive sensing finite sensing robot robot nothing primitive robot robot ignoring primitive sensing robot case robot obtaining sensing continuing robot replacing occurrencesof exit rest next loop robot repeatedly body terminates exit next going continuation formal robot calculus levesque plan robot form recursion fluents precise sense robot inclusion five primitive universal levesque planning goal find robot achieves planning going planning like tree chopping unknown quantity must dealt fluents dealing distinguished call planningparameter property even plan time loop goal word loop deal unknown unbounded planning parameter tree chopping planning parameter chop fell tree domain planning parameter generating plan proving work correctness termination work find plan loop user generating plan possibly containing loop provably user testing test plan step also provably plan foolproof plan tree chopping work fails user specified smallest plan satisfies plan plan desired plan well encounter undesired planner planning user specification list primitive fluents characterizing goal precondition sensing user also identifies parameter supply plan done reasonably efficiently test plan testing plan also done reasonably efficiently even practice date even time spent plan work planner kplanner prolog main module plan tester plan evaluator used evaluator look suffices note need able handle task determining true legality task determining regression reiter need able incorporate putative sensing keeping track date maintain history consisting pair sensing sensing need able sensing history date tree chopping know look sensing history legal chop testing plan plan testing need achieves goal need simulate sensing confirm goal satisfied case plan achieves goal history initially empty hold history precondition hold achieves history case precondition hold sensing achieves history loop unwinds achieves history unwinding loop occurrencesof exit replaced occurrence next replaced loop observe unwinding loop plan loop come generating plan generating plan generating variant progressive planning plan achieves goal find plan achieves goal history initially empty hold primitive precondition satisfied maybe criterion sensing find plan achieves plan sensing sensing find plan achieves history plan case list step remaining sensing impossible care plan previousstep unwindingof loop loop well generating loop plan loop going come universal suggested generationprocedureabove comefrom sequentialand conditionalplans work plan tree chopping case look case look chop chop case look endc care endc endc sensing sensing impossible plan remains substitution care substitution plan unwinding loop replace care robot chop plan obtains unwinding conclusion also returned plan tested case successfully idea practical must quickly plan match unwinding loop unwinding unwinding guessing loop prolog unwind unwind hold loop loop unwinds hold replacing unwinding exit exit next next case case loop loop subl subl subl prolog code unwind unwinds call passing simplified code easy confirm plan prolog care desired plan generating loop turned alternative enumerating plan containing loop practical even plan planner kplanner specification user variant indigolog giacomo levesque sardina calculus mccarthy hayes reiter user supply nine prolog indigolog fluents kplanner indigolog fluents epistemically take vassos sensing disadvantage demolombe parra take closed boolean operator quantifier atomic arbitrary prolog goal fluents evaluated replacing fluents prolog possibly true goal succeeds fluents true goal succeeds fluents prolog user fluent sensing arbitrary primfluent declares fluent primaction declares sensing sensing prim fluent prim fluent tree prim fluent chop prim chop prim look prim chop look true init init tree init tree stored true chop tree true chop tree true chop chop chop settle look tree true reject look chop true settle look chop true parm fluent chop init parm chop init parm test chop specification tree chopping precondition init hold precisely settle getting reject getting final part used planning parameter generating testing parmfluent fluent planning parameter initparm test planning parameter tree chopping formalize tree chopping fluent chop planning parameter handle testing deal fluent sufficient keep track call chop full specification tree chopping tree initially tree fluent chop like sometimes nondeterministic prim fluent prim fluent unknown fluent prim incr prim test diff incr true test true incr settle test reject test diff init parm fluent init parm init parm test counting literature look settle look chop know chop chop impossible show kplanner next suffice find counting turn involving counting accumulator unknown primitive incracc accumulator testacc sense accumulator goal make accumulator specification fluents last planning parameter kplanner kplanner work deepening plan sufficient generating work testing many omitted note goal nothing specification said anything progressive planning serious disadvantage need able test goal satisfied need goal analytic searching turn much searching unbounded binary tree target precisely primitive node type sense goal plan incr loop case test exit incr incr incr next endc endl incr arithmetic node target node leaf node node left child push node left child node moment thought convince reader storage push push onto stack stack popped sensing rest specification fluent much like chop node type know node type leaf trickier answer node left explore left branch rightmost branch tree node type target reflected reject node type leaf stack last getting leaf reject stack move last insoluble nice plan note kplanner generates loop believe nesting work loop clearly scope planner know planner automated plan camp case planning repeated probability probability true repetition outcome plan like probability trying pick block haddawy find good bonet geffner independence untenable tree chopping goal target plan loop case node type exit loop case exit next endc endl push next push left next endc endl searching binary tree clear replace even clear probability counting approachis cimatti planning cast finite system tree chopping willing ignore planning parameter work perfectly four instantly planning parameter forced cyclic never loop counting depend planning parameter thus outside scope well kplanner limitation scale well grows even seemingly easy getting good bowl bonet geffner need plan loop like good need plan consisting copy plan strung sequentially sensing tell good compact force kplanner long plan well size plan time good unwound backtracks week clear unless forward filtering bacchus kabanza kplanner practical plan loop break next dish case sniff dish exit discard dish next endc endl transfer dish bowl getting good bowl cognitive robotics sketched suited difficult easy quickly find nice getting arbitrary good bowl sensing determines kplanner good synthesizing plan loop correctness construct plan simultaneously proving correctness know plan nonetheless plan work planning parameter testing guaranteed work looking hard free lunch sketch promising stand goal call planning satisfies sensing tell valueof done legal statebut sensing last sufficient going also used ensures loop depend tree chopping counting chop incracc hand nowhere near planning robot occurrence plan proved adapting idea pumping lemma classical automaton suggests variant kplanner user testing testing plan counting occurrence plan pass test guaranteed applies planning believe like restrictive expect able testing planning armed suitable primitive robot turing machine conclusion generating plan loop tied proving correctness generating plan determining plan unwinding plan loop testing unwinding plan loop also handling loop step reduce planning benefit planner petrick bacchus winding unwinding loop kplanner fairly obvious anything reduce legal plan considerably deepening legal plan size must going next side showing planning planning remains seen strengthened planning planner work acknowledgement thanks gerhard lakemeyer fahiem bacchus helpful comment text
