inferring lisp procrams david shaw william swartout cordell artificial intelligence laboratory stanford stanford california infers recursive lisp pair synthesized recur synthesis auxiliary user session operation heuristic outlined acknowledgement wish thank richard waldinger doug lenat fruit valuable held early work also grateful editorial assistance avra cohn made preparation draft part agency part california california graduate fellowship many automatic goal facilitating specification specification user supply sample infers plausible inductive inference also explored licklider hardy inference task inference trace biermann grammatical inference feldman horning reder horning biermann feldman blum blum describes infers recursive lisp pair able infer list transformation recursive step list left producing part step pair produced step recursive subfunction sublists successive step main appends briefly outline synthesized determines part produced step recursion sublist produced step assumed subhst produced subfunction thus synthesize subfunction generating specification describes subgoal subfunction specified synthesized recursively returning synthesis main find remaining step recursive call foimrd resulting code embedded properly conjoin recursive step terminating realized synthesized satisfies specification unfoitunately synthesis simply realize acceptable user trivial synthesis scheme realize breaking constituent atom recombining atom mechanically form desired scheme specified synthesized trivially pair synthesized noted synthesize involving counting operation sort list termination null test thus last list synthesized equality test atom find list specified also fall outside synthesized tried convey feeling reach precise characterization attacked work determines nonrecursive realization target construct nonrecursive synthesis realized nonrecursive construct synthesis involving recursive construct attempted recursive lisp synthesized part remainder recursive call considering specification segment produced recursive step remainder produced recursive call refer initially produced segment head remaining segment recurrate dividing head recurrate synthesize code head attempted goal subgoal specified pair head appearing ignore part head realization subgoal distinguish head recurrate divide adjacent illustration variant divide indicated successive procedure procedure major substantially predecessor conjecturing separation comparing successive discovers major aftei postulate separation case pair serial procedure must fact proceed backward list heuristic used scanning determination used synthesis procedure grouping detet mining scanning able reduce synthesis task simpler subgoals head recurrate must realized resulting block code combined code terminating subgoal form must formulated used subtask must carefully avoid possibility implausible synthesis form parent goal broken subgoal goal realizing spawn subgoal realizing heuristic used break parent attack subtask exactly head realization recursive synthesis auxiliary junction must synthesized case call auxiliary head realization code recurrate realization synthesizes recursive call tail cdrs embedded postulated clue involving propagation recurrate head recurrate successfully realized conjoined ppend forward head realization joining case backward scanning recurrate realization resulting body code embedded termination terminaiiun form tail returned work story synthesis nonrecursive synthesis allowed realized simply decomposing construct break limitation prevent synthesis implausible breaking primitive combining mechanically realize nonrecursive synthesis realized composition precisely synthesized recursion restriction nonrecursive synthesis userspecified synthesized wjll importnt nonrecursive synthesis argrail represents composition nonrecursively synthesized call auxiliary form rectnsive list note head recursive call interchanged recurrate recursive realization identification head recurrate recall procedure used locate major successive initially grouping separation size increased examine procedure loims template comparing appearing case form template stand differing segmentation postulated fact inaccurate guess segmentation upon scanning atom appearing equality atom atom template representing unequal atom relationship differing atom thus template successor list template analyzed size comprised template used predict relationship predict appearing successor instantiated template resulting instantiated template fact agrees appearing template predict fourth thus divide head recurrate somp specification major detected heunstics case head remaining recurrate yield template prediction separation thus assumed separation employed work reasonably well must emphasized tney universally synthesized heuristic noted must sometimes scanned backward left proper separation chooses scanning noting front list propagate toward front back tend assumes head list case reverse scanning used distinguish head recurrate scan backward realizing head review work done scanning heuristically noted adjacent scanned procedure locating site major part step recursion head distinguished part produced successive recursive call recurrate major apparent default separation assumed atom appearing head distinguished must synthesize code head evaluated toplevel call implicitly code recursive call recurrate mentioned head realization subgoal specified user specified task target couise head list head realization subgoal trivial case list reasonable subgoal inputoutput pair head exactly trivial nonrecursive realization head thus specified subgoal head realization subgoal must broken realize head case fails accomplish subgoal creates subgoal subpart illustrate subgoal trying realize head synthesize subfunction satisfying realized thus generates subgoal eventually successful synthesis twoargument auxiliary generates subgoal decomposing heuristic note atom list head recurrate atom head diitinguishers head lealization subgoal head distinguishes head recurrate thus remainder removing head distinguisher unless none atom head passing broke constituent atom head realization succeed nonrecursively sort dangerous admitting possibility implausible synthesis danger motivation selective continuing synthesis main summarize synthesis subf unction goal synthesizing specified spawn head realization subgoal template mauhnig head subgcul recurrate thrn decomposes discarding atom fail head adjusts cdrs thus synthesized reursive embedded assumed atom beginning fail recurrate unfortunately fails many pair atom propagate weak heuristic used synthesis entirely recursive call synthesized segmentation querying user case user asked recursive call fact realizes recurrate user specifipd identifier substituted formal used recursive call response evidence faulty segmentation head recurrate leading revised conjecture regarding scanning size recurrate head recurrate realized conjoins resulting piece code analyzed forward scanning head realizing code joining funrtion head must beginning reverse scanning used head must head realization deciding used case backward scanning joining also head accoidance usual must acknowledged heuristic yield incorrect terminating herwise target resulting block code embedded call user specified name list lambda resulting system evaluated list fact yield user verification user testing conclusion interlisp david shaw revised william swat tout session past year formal conducted user actually specified seems specification valuable role play facilitating specification clear believe specification automatic system lisp synthesized shorthand name list user specification name evaluated list
