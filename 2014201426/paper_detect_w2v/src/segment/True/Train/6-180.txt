framework graph open closed list keep track frontier interior node sparse closed list fraction expanded node need stored closed list preventing duplicate extraction work closed list korf make wider graph dijkstra open list node frontier closed list keep track expanded node closed list fiinctions optimal path reconstructed tracing pointer backwards goal node node graph node reached path recognized reached path prevent duplicate storing expanded node closed list quickly memory willing give recognize node reached path rbfs linear korf prevent duplicate storing expanded node reinefeld marsland miura ishida graph many duplicate path inability prevent duplicate lead poor fortunately expanded node closed list eliminate duplicate node form graph prevents previously closed node revisited adopted pair korf korif work memory dynamic hirschberg myers miller expanded node stored closed list alternative extraction closed node optimal path memory preserve node middle path divide employing recursively reconstruct optimal path memory distinct phase phase goal node phase reconstruct optimal path closed list korf korf extra open node even node open list form prevents leak back closed open list preserve expanded node closed list reconstruction much closed removed memory thus call sparse closed list graph show flexible memory background closely bidirectional dcbs korf frontier dcfs korf alignment used dynamic quence hirschberg myers miller perspective brief alignment refer alignment alignment protein computational biology segment alignment inserting maximize formalized lattice aligned node lattice thus grows polynomially exponentially dynamic outperform admissible heuristic node lattice need examined find optimal alignment ikeda imai lermen reinert node must examined memory bottleneck memory helpful frontier bidirectional dcbs korf frontier dcfs korf memory dcbs bidirectional dcfs unidirectional korf find unidirectional refer dcfs rest dcfs reduces memory storing frontier node interior node open list closed list closed list dcfs must avoid duplicate node extract optimal path avoiding duplicate node particularly case alignment combinatorially many path node node test duplicate pitiful word korf used alignment even duplicate reported poorly yoshizumi avoid duplicate node dcfs prevent leaking back closed prevent closed node node list forbidden operator list operator neighbor predecessor successor node node operator forbidden operator used successor node prevents node closed removed memory complication arises case directed graph directed graph node predecessor also successor node expanded removed memory predecessor inserted open list regenerated predecessor node expanded prevent dcfs modifies open list node expanded generates successor node predecessor node even path predecessor node legal path predecessor node infinite prevent expanded legal path make reconstruct path dcfs modifies node node past midpoint node path halfway goal node completed dcfs know middle node optimal path reconstruct path recursively solves subproblems optimal path node middle node middle node goal node recursive reconstruction idea hirschberg limitation korf show dcfs grow polynomially size grid alignment acknowledge exponential branching case open list much closed list storing closed list save much fact alignment exponential npcomplete aligned branching size open list dwarf size closed list aligning five motivated size open list align prune open node lead optimal ikeda imai node yoshizumi turn difficult combine dcfs size open list creating inefficiency even leak back closed combine dcfs size open list partially expanded node yoshizumi beneficial case node partially expanded node closed turn reduces dcfs node eligible removed memory show size open list prune open node optimal enhanced ikeda imai reduce closed node idea combining dcfs promising introduces difficulty recall dcfs generates predecessor node expanded even path predecessor node pruned open list path ever extra node open list cluttered useless node never removed directed graph property successor node disjoint predecessor graph alignment inefficiency pruning open list directed graph property undirected graph pruning node open list also leak back closed time node best path pruned path forbidden operator node lost pruned node previously closed difficulty combining dcfs size open list limitation limitation worth mentioning overhead storing list forbidden operator node overhead slight alignment overhead grows grows recall operator branching alignment dcfs incoming well outgoing edge list forbidden operator thus edge incident node korf dcfs alignment rest node take storage storage list forbidden operator exponentially fact dcfs mulitple alignment disappears rest adopts used dcfs simpler compatible size open list storing list forbidden operator node illustration relationship kernel interior frontier dcfs entirely eliminate closed list sparse closed list many closed node removed memory note interior closed node partitioned disjoint subset call node kernel interior interior node node path kernel pred predecessor node node make transition node graph directed undirected basically kernel node predecessor node interior closed node node interior node describing node predecessor node interior node mathematically illustrates relationship kernel interior note node enter kernel node kernel remains node kernel eligible removal memory prevent duplicate intuitive explained closed node reachable node closed node volume graph encompasses node node outside volume reach node inside volume passing node thus storing node closed list storing volume pseudocode smgs graph procedure expandnode assumes directed graph pseudocode expandnode pointer memory undirected graph midpoint node memory pointer plus relay node memory copy midpoint node many node pruning closed list must able efficiently distinguish kernel interior prune node kernel recall node kernel predecessor closed identify node keeping track unexpanded predecessor node call node initially predecessor node graph minus predecessor node successor node open closed list decremented line procedure expandnode negligible time overhead node time checking closed node zero remove closed node memory dcfs dijkstra exactly like dijkstra sens memory exhausted invoke procedure pruneclosedlist memory procedure prune node closed list step ancestral pointer node predecessor pruned line reconstruction relay node closest node path line updating ancestral pointer accordingly line make node relay node prevent pruned step kernel node pruned unless node relay node pruning step line updating ancestral pointer node followed pruning creates sparse path dense path reconstructed terminates path reconstruction fact closed list pruned unless memory close exhausted mean overhead reconstruction avoided memory resource adequate case exactly like dijkstra optimal path extracted closed list pruned optimal path reconstructed invoking graph smgs recursively sparse path extracted line tracing pointer backward goal dense path reconstructed pair consecutive node node predecessor line tail line call recursively pseudocode expandnode undirected graph goal node dense path tail line dcfs worth noting dcfs divide subproblems recursion divide subproblems extra flexibility relay node ancestral pointer dcfs middle node node divided subproblems subproblems reconstruction fact relay node spaced half tradeoff sparseness interior reconstruction pruning open list pruning closed list combined pruning open list pruning node open list optimal creates difficulty dcfs difficulty predecessor node disjoint successor alignment illustrated directed graph directed graph node predecessor successor node dcfs leak back closed open list pruned unfortunately graph best path node pruned path erased node pruned node decremented zero much memory closed list suggest inefficiency minor dijkstra searching optimal alignment panel show pruning closed list panel show pruning panel show sparse path undirected graph noted dcfs also leak back closed open list pruned make minor modification explained undirected graph pseudocode show expandnode procedure directed graph give pseudocode expandnode procedure undirected graph undirected graph decremented closed node open node thus pruning open node distorting fact pseudocode used directed graph also directed graph considering predecessor node well successor node overhead undirected graph successor node predecessor idea node closed list prevents closed node open list relay node reconstruction storing node middle node path idea separately dcfs dcfs open list combined relay node dcfs able divide path piece flexible potentially reconstruction relay node also dcfs delay pruning closed list memory full used dcfs independently forbidden operator used forbidden operator sometimes node duplicate open closed list computational follow computational illustrate dijkstra work showing solves pairwise alignment challenging aligning actgat tgactgc cost zero match unit substitution unit twodimensional grid column correspond optimal alignment corresponds optimal path node corner goal node corner horizontal vertical move correspond diagonal move correspond substitution match show dijkstra memory full closed list pruned assumes memory node show explored memory full time cell node closed node highlighted bold italic closed node identified kernel node pruned show pruning memory full time closed list pruned kernel node removed memory freeing memory continued show memory goal node cell corner expanded thick dashed arrow arrow drawn thin dashed line ancestor pointer pruning also open list pruned know cost optimal alignment node pruned open list progress storing seven node note pruning node open list interior alignment tested series challenging alignment dcfs used ultrasparc workstation gigabyte displayed identical test domain used korf alignment cost averaged trial domain memory limitation memory pruning open list ikeda imai yoshizumi also unable closed list open list fill memory case many closed node pairwise heuristic used alignment heuristic weak resulting many node closed node long like path correspondingly long reconstruction relay node recursion relay node make divide path subproblems dividing half reconstruction come expense memory extra relay node seen comparing relay node relay node divide path piece extra memory extra relay node classic tradeoff forbidden operator closed node pruned soon predecessor waiting predecessor closed pruning node combine forbidden operator outperforms memory explanation next real protein cost matrix widelyused biologist aligning five pool protein used mcnaughton memory enhanced ikeda imai prune node open list well open node safely combined pruning statistic seqs seqs seqs node mbytes relay node node mbytes node mbytes forbidden node mbytes enhanced node mbytes enhanced node mbytes enhanced node stored node thousand memory storage pairwise heuristic open list give enhanced enhanced slightly node memory forbidden operator make node also emphasize show time enhanced time enhanced mean enhanced memory enhanced need prune closed list identical adjusted minimize memory memory evaluating drawback node size aligned apparent used align seven protein around protein used yoshizumi high give rise accurate heuristic make much align even expand node generates node domain extra node open list serious node time bigger node list forbidden operator slower memory aligning node seven time node relative size double thereafter show enhanced pruning open list much pruning closed list nevertheless enhanced worse enhanced sparsememory improves complement memory perspective happens combine yoshizumi cutoff zero minimize memory seven protein mbytes memory much time overhead slightly memory node partially expanded node closed pruned stored node slower partially expanded node pruned note combined enhanced consistently memory time complication duplicate crucial nevertheless benchmark undirected graph used korf test used memory used used memory used enhanced used memory used enhanced best used memory used also tested combined enhanced unable prevent leak back closed noticed many node reexpansions interestingly used memory used aggressive pruning domain node overhead managing open closed list outperforms undirected graph exponentially many duplicate path enhanced best conclusion graph build idea work size closed list combined size open list pruning size open list dramatically exceed size closed list alignment four five flexible potentially reconstruction last behave exactly like enhanced dijkstra reach memory remove node closed list thus virtually overhead unless memory overhead reconstruction compensated memory acknowledgment thank reviewer helpful comment work part career grant nasa grant
