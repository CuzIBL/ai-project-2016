probably huge four area production rule processing data base supporting identification inconsistent subgoals artificial intelligence planning periodic labeled tableau system modal data compact huge answering subset superset used successfully system enabled planner track planning competition effectively oriented database stressed need richer data type student enrolled enriched database supersets subset find student taking supersets need student passed answer retrieving prerequisite subset machine learning highly concerned utility learning learning cost satisfaction exceed system achieved learning good learning effectively match form precondition production rule decide rule precondition subset describing artificial intelligence planning concerned constructing achieves goal plan scheduled even simplest form bylander planning exponential effectively prune million goal constructed searching plan know goal never satisfied case subset goal previously unsatisfiable modal formalized labeled tableau sometimes confronted infinite branch tableau termination need identify periodic label gore form deal stored data sometimes seems trivial handle difficulty come dimension million handle huge dynamically changing ubtree fast answering data varying cardinality ubtree data node ubtree represents tree node marker node ubtree simply node seen forest note speaking tree node neither tree node ubtree name unlimited branching tree data tree tree lookup tree tell subset stored lookup tree determines subset lookup tree determines supersets relies existence ordering possibly forest creates path path series tree node ordered ordered forest initialized root node forest look remember ordered inserted path previously inserted node node implying serted creates path node last node represents marked path note consequently node show forest tree evolves ordered lookup show stored forest used answer decides simply reach node make simplification ubtree deal possibly empty hoffmann koehler tree marked path money travel cost tree node find node marked path succeeds subset ongoing recursive remaining formal node match node path succeed endif else call next tree remaining endwhile failed fail lookup initially previously ordered forest crucial ubtree money fraction excluded subset need half tree rooted node node note node heuristic node next node node tried also used fact used unnecessary branch tree stored node left back fail away case reach marker work terminating identifying marker subset work node reach money pass node representing subtree ordering satisfaction node time find node path path ending node answer initially ordered forest parameter answer initialized empty upon termination show retrieve supersets done path comprise path possibly disconnected subpath answer initialized ordered forest parameter tree preceding tree possibly node whole node corresponds possibly need find node remaining left succeeded node reached yield superset need continued node property ubtree soundness completeness lookup forest ubtree constructed iteratively inserting lookup succeeds stating soundness completeness lookup proven analyze runtime reexamine perspective find node match node recursive parameter afterwards work hand node match simply skip continues prom recursive node visited lookup node visited probability node consequently visited node obviously proven recursion probability probability path open node tree node size noticed rule determining unsatisfiable goal planning thus searching node much checking inclusion node visited dominated node forest maximal ordering tvymg find supersets whole consequently node tree forest exactly iteratively inserted distinct node worst case containing contained empirical demonstrate effectiveness ubtree planning system koehler hellerstein workload ubtree domain atom characterize domain comprises domain finite subset stored goal constructed planning note workload dynamic empty ubtree goal plan planning system monotonically growing containing difficult make distribution planning system parameter characterize size ubtree distinct atom stored node forest storage cost trivial data simply representing separately answered process show parameter forest size planning domain blocksworld part briefcase part hoffmann koehler ubtree grows reflected storage cost linear sometimes case possibly exponential degree indicated size ubtree illustrate runtime reflected searched node size note logarithmic scale visited node size size logarithmic scale averaged succeeding failing visited node size size logarithmic scale lookup case succeeds need significantly time retrieve subset must fail fact runtime case linear size size throughout never visited node case tends logarithmic size size varied domain sometimes clearly even satisfaction clearly logarithmic probably exponential degree size node lookup averaged show picture looku investigated domain turn decrease happens supersets size tends linear note logarithmic scale scale node lookup jsups averaged work deal planning subset test considers size size blum furst obviously done linear time test must inherently incomplete ubtree test linear time practice despite exponential database tree hellerstein pfeffer mean answering superset handling subset ubtree spread node tree leaf node node supersets size child node effectively guide handle subset inverted tree used tree complement base serious node need recomputed inserted even stored leaf complement supersets parent node grow impractically ubtree avoids optimized rete forgy handle production rule doorenbos indexing precondition rule ubtree match stored indexing precondition ubtree deal ground atom thus null activation rule node activated precondition satisfied rete ubtree ground rule conclusion ubtree optimized interested keeping pruned tree constructed finite fixed domain implicit bitmap reduce memory consumption time lookupjsups ordering area likelihood appearance ordering minimizes tree node simply high likelihood appearance thereby storage cost
