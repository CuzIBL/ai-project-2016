machine compact rapid lisp machine compact compiled code encoding scheme potentially applicable data well machine also data permit convenient dynamic storage allocation recursive procedure operation data type time compile time mismatch machine plague implementor manipulation structured neither usual satisfactory interpretive system easy build compiler hard force implementor user sacrifice valuable feature sake many machine compiled code also occupies much structured alternative machine code closely resembles major machine used burroughs successor machine execute algol year microprogrammed processor continuing decline cost processor hardware prompted sort successful unsuccessful venture describes machine interactive system lisp reader unfamiliar lisp consult weissman excellent primer next voluminous manual also machine referred microlisp name connote code compactness microprogrammed data type lisp many data type atom usual property affix datum type lisp vast majority data pointer atom wasteful leave room word plus datum datum cell consequently datum pointer referenced storage allocated quantum quantum hold data type type pointer address pointer chief drawback scheme plus must allocate word hold lead frequent garbage collection circumvents part permanently storing consecutive cell returning pointer allocating microlisp reasonably data stack binding type identifying pointer long take consumption allocated lisp system permit user packed data microlisp made inexpensive machine absence lisp cited choosing computation peripheral rest worth noting scheme even lends compilation usual case control binding microlisp stack control binding allocates frame frame control frame name binding pointer name frame hold pointer frame bookkeeping funarg lisp construct data comprising binding primitive creates descriptor pointing specified frame long accessible descriptor frame continues descriptor also user construct cooperating process coroutines stack linear burroughs recognizes kind access load duality actually data well treated systematically microlisp systematizes normal load argl argn mode argl argn newvalue setq also obvious setfq argl argn newvalue quote name evaluates everything else rplaca lambda setfq semantics frame frame binding desired name none consult nobind unbound access pointer frame caller pointer control funargs microlisp compiled lisp actually searching searching pointless relative frame compiler accessed indexing searching never rebound compiler force bypass repeated referenced wasteful microlisp time repeated thereafter microlisp binding frame half word frame name microlisp frame pointer name scheme prog open lambda constitute body made subfunction prog time frame entered microlisp scheme slow free name core want scan name time word holding binding help type elsewhere frame thus real code machine take attitude must convenient word address tends fraction half devoted memory address microlisp take fact lisp make address used name used microlisp name eliminates need syntactic device eliminates need sublists scope delimiters thus microlisp code representing postfix form byte name name actually name come prog free everything else binding free pointer true binding searching binding frame pointer frame searching process match free follow pointer step desired microlisp lisp structured header give former determines size frame determines header precedes code also byte address byte address adjusted downward size datum pointer accommodate usual memory word block arrangement memory computing name atually paragraph const gvar ivar fvar must supplied datum hold name represents supplied last machine remove constructing frame primitive name four obtaining eventually pushing onto frame severs frame incorporation frame const simply push datum gvar push name datum trap nobind ivar indexed datum push frame byte fvar free work take pointer true binding pointer stack nearest binding pointer primitive operation returning byte real opcodes microllsp followed displacement parametric next byte byte dstore followed ordinary specially followed opcodes also word opcodes word parameter byte word bracket word bracket data stack stored ivar gvar binding replaced fvar addressed binding replaced const trap specifies stack specifies dstore followed addrx addrxx serve address parameter address remove item stack copy push stack onto stack apparent selectq stack replaces setarg item next item remove stack retains squeezing control jump opcodes followed parameter byte interprete complement address displacement opcode adjusted eliminate meaningless byte displacement jump jump byte relative tjump test stack jump datum true fjump inverse tjump jump ntjomp like tjump jump cond clause lacking consequent test cond typejump bottom give type selects jumping true false stack removed jump jump type gotoself jumping stack conclusion comment microlisp consistently size compiled nicrolisp compiler size part compiler former bulky code lisp remored code size microlisp compactness achieved expense many feature compiler microlisp machine comparable data microprogrammed preparation microlisp machine permit unambiguous decompilation feasible machine closely resembles code compiler machine must rearrange suppress extensively interpretive system reconstruct text indenting nesting prompted investigate type feeling intelligence memory much disinclination spend time contemplating alternative machine real need deal hope experience lisp minicomputer fraction cost kind announcement machine encouraging regard realizing hope lisp system compressing data well user packed data compiling data careful microlisp reveals encoding scheme work essential idea eliminating pointer forcing successive data physically consecutive eliminating pointer associating operand operator sublist subexpression compressing atom atom
