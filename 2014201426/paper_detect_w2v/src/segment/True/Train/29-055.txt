work kautz tantalizing evidence classical planning efficiently propositional satisfiability stochastic resulting truth assignment back plan explore transformation framework generates eight major encoding selecting four frame axiom subsidiary compiler encoding test compiler suite strip planning encoding best property analytic framework previously reported encoding novel possibility parameterize encoding major dimension frame twelve twodimensional list axiom encoding calculate asymptotic encoding size automatic compiler generates encoding difficult compiler encoding lean kautz selman typeanalysis factoring close demonstrate reduce half size compiler suite planning determining regular explanatory encoding smallest despite early planning proving long assumed planning practical propositional satisfiability cook mitchell cast doubt conclusion compiling planning unremarkable kautz selman kautz selman suggest compilation yield fastest planner open must answered concluding planning dominates specialized kautz selman used encoding kautz compilation reported automatically compiled know encoding best encoding used kautz selman domain inexpressible strip fluent irreflexive noncommutative extent responsible address funded part office naval grant foundation grant arpa rome grant gift rockwell palo alto fastest encoding framework describes encoding causal encoding well alternative work encoding statebased avoid term parameterized dimension regular simply overloaded bitwise specifies correspondence propositional ground fullyinstantiated plan tradeoff clause classical explanatory frame axiom varies stationary fluents constrained encoding fluent time take nonnegative evennumbered time time encoding universal axiom init specified time zero property presumed false closedworld goal test plan desired goal property asserted true time omitted encoding resolving away encoding kautz ernst millstein size axiom schema note identical size permit parallelism precondition satisfied time contradict parallel kind parallelism problematic plan linear precondition precondition parallel contradictory legal ordering problematic exclusion linearizability resulting plan guaranteed restricting simultaneously kind exclusion enforce resulting plan exclusion time step distinct pair clause form exclusion ensures time step guaranteeing plan conflict exclusion time step distinct conflicting pair clause form framework conflict precondition inconsistent conflict exclusion plan form consistent plan wish encoding frame conflict exclusion used conflict exclusion exploited splitting splitting impossible instantiation operator execute time fluents interfere overloaded splitting disallows instantiation operator execute time bitwise exclusion axiom time step fullyinstantiated ordering guaranteed optimizing axiom factoring eight base encoding choosing regular overloaded bitwise choosing classical explanatory frame unfortunately lead splitting bitwise tend explode clause size clause axiom disjunction substituting bitwise regular literal disjunctive normal form blow exponentially converted conjunctive normal form splitting axiom clause size clause size blowup blindly substituting frame exclusion axiom factoring dramatically reduce clause size overloaded splitting idea subset full represents consistent bitwise admit easy factoring unless clever numbering scheme frame frame axiom relate fluent make good instantiation show move operator axiom instantiation operator ordinary splitting transform axiom bottom axiom pair move consistent irrelevant axiom simpler axiom clear used eliminating need moveargl conflict graphplan blum furst kautz selman kautz selman parallel encoding like linear encoding axiom stating imply parallel encoding prohibits conflict logically clause substantially naive conversion clause duplicated literal clause logically imply eliminates unnecessary literal clause ernst millstein composition worst case size encoding bitwise yield smallest clause regular opposite encoding init goal frame axiom clause noted size clause reported asymptotic literal clause clause size factoring axiom relies idea relating fluent need part conjunct pertaining affected fluent extends classical explanatory frame axiom classical frame naively splitting move moveargla observe move irrelevant implicitly represents classical frame axiom relating clearness move note factoring optimization crucial practice ordinary splitting worst case arity precondition fluents arity operator factoring factoring exclusion axiom pairwise exclusion clause relate relating fluents used axiom noting excluding whole occurring simultaneously independently exclude factored exclusion move operator look like ranging distinct ensures move time operator operator time exclusion need operator time accomplished pairwise excluding operator word clause distinct operator necessarily distinct show factoring reduces asymptotic size clause unfactored exclusion axiom factoring axiom factoring axiom explodes exponential morass conversion fortunately factored yielding disjunction operator planning scheduling preventing subsection show part encoding part rely refer part referring instantiation part instantiated rest want factored frame clause unless full implied frame actually time step frame constrain resulting plan even referred frame never axiom part operator instantiated rest elimination axiom move operator axiom fluent move true instantiation move true show size resulting clause medic planner encoding classical planner accepts goal strip schema goal medic planner operates compiling planning clausal form satisfying truth assignment back switch encoding thus medic planner form testbed exploring property encoding architecture planner schema parsed preprocessor ucpop planner penberthy weld type optimization next guided frame compiler creates master axiom schema representing possibility time step periodic axiom schema instantiated time plan duplication module combined goal specification simplified pure literal elimination unit clause propagation duplicate literal elimination fast linear time procedure gelder tsuji resulting clause walksat selman tableau crawford auton planning reduction propositional satisfiability impractical optimization truth fluents ground instantiation foremost type optimization type fluent affect type constrain operator instantiation ruling impossible ground block prune instantiation move operator assign precondition reflected operator instantiation type need final encoding block precondition removed move obvious handling equality case type usefulness type explored inferring type operator block move clear precondition fluent block clear block clear also block deduce clear must block block move precondition inferred fluent positively negatively operator binding identical move operator inferred operator instantiation pruned eliminating symmetric operator instantiation operator take used identically sense considering binding arbitrarily possibility ground instantiation magnitude refrigerator domain planner reduces binding infers fluents enforcing form consistency fluents true also false dataflow step fluents fire process guaranteed terminate tantamount planning time ignored thereby permitting impossible like presence fluent negation simplification step also fast reduce size enormously simplification operates optimization listed much type elimination step reduce encoding time four optimization simplifier reduce optimization factoring factored reduce benefit type optimization factored splitting unary type eliminated restricted reflected newlyintroduced binary type eliminated binary operator take instantiation take leave axiom encoding prevent illegal overloaded admit elimination even unary type fluent represents many operator searching plan assumed trying find plan plan medic planner capable linear binary plan encoding linear modification binary plan explicit maintain classical frame axiom plan succeed clause literal simplified resulting eight encoding plus satplan sans axiom reported actually simplifier time walksat stochastic plan systematic tableau walksat even tableau take unreasonably long time verification moot tenth reported tenth trying find satisfying plan shortest test encoding encoded suite planning eight encoding factoring used plot clause literal final simplified also walksat time averaged five note data hard interpret walksat fastest used suggested walksat flag satplan planner flag favor encoding reported kautz selman many walksat varying parameter believed time correlate size encoding simplification time medium dominated time planning scheduling automatically determining flag best open selman progress made mcallester asymptotic size expect bitwise encoding smallest regular encoding largest surprisingly neither expectation fulfilled smallest encoding smallest encoding regular simply explanatory encoding encoding quick time well success bring relative merit encoding clear explanatory frame clause superior classical frame clause explanatory frame expect affect relatively fluents parallelism also success regular explanatory encoding parallel plan shorter fewer copy periodic axiom additionally conflict exclusion axiom subset exclusion prohibit pair conflict exclusion excludes pair excluded existence linearization plan returned surprising regular explanatory encoding kautz selman dismiss encoding impractical size blow prohibitively worst case practice encoding maintains excellent clause size remains competitive even size logl loga suspect compiler type optimization handicapped factored splitting deserve largest encoding worst encoding regular bitwise classical encoding mentioned superiority explanatory classical frame regular classical outperformed classical encoding splitting clause size much bigger regular encoding practice factoring seems keep size competitive splitting also simplifier flexibility deduce part fullyinstantiated hope generalizing encoding also aided great decrease regular encoding hand bitwise encoding smallest simplification worst encoding simplification relatively ineffective encoding encoding fewer simplification phase fact bitwise encode domain thereby next impossible simplifier truth graph literal obvious bitwise incurs size satplan encoding compact satplan encoding best encoding surprisingly competitive seven ranking satplan encoding axiom removed best encoding actually outperform satplan encoding simplification process able satplan encoding dominate best automatic encoding satplan size type optimization type optimization substantially reduce size size optimization understate benefit optimization data type optimization regular overloaded bitwise classical explanatory ratio simplified size type optimization simplified size reported seven ratio clause literal closer assical explanatory overloaded overloaded clause literal ratio simplified size factoring simplified size optimization classical encoding cutting size optimization much explanatory encoding fact optimization superfluous regular explanatory encoding simplifier obtains type optimization benefit considering resulting attributable simplifier interacts encoding classical encoding much constraining explanatory encoding enforce truth time time rigidity make hard simplifier reduce encoding size thereby relying heavily type optimization make deduction encoding regular explanatory encoding conflict exclusion flexible encoding seems static optimization make teased encoding simplifier factoring show factoring make unfactored splitting factoring reduce size base encoding lead drop size simplification factoring clause literal size reduction precisely introduced idea factoring worst case factoring clear factoring practice domain axiom encoding kautz selman impossible term strip natural axiom block kautz irreflexive block time block exactly block clear something never anything much affected planning removed axiom encoding size resulting show eliminating axiom decreased clause increased presumably ernst millstein axiom clause fewer simplification substantial five time indy walksat noise cutoff squared deviation reported simplification axiom planning took substantially suggest investigate compiler deduce axiom automatically believe type optimization good achieving goal conclusion make contribution framework generates eight encoding encoding well novel overloaded splitting bitwise combined regular encoding creates spectrum highlighting tradeoff clause size automatic compiler take classical strip planning generates encoding compiler many feature type inference optimization compiler empirical tradeoff encoding show explanatory frame conflict exclusion dominant regular acton surprisingly many exciting remain clearly need investigate encoding automatically generating axiom promising also hope investigate type inference also many encoding explore parallelism simplysplit explanatory encoding take best encoding mentioned splitting prevents possibility parallel instantiation operator interfere overloaded splitting splitting encoding extra greatly compact many part factored encoding bitwise fluents overloaded avoiding disadvantage bitwise also imagine compiling part domain encoding encoding part automate statebased encoding integrate causal encoding framework acknowledgment jared saia nick kushmerick marc friedman contributed testing framework david smith made many insightful planning scheduling major reformulation encoding bart selman david mcallester henry kautz engaged helpful kindly satplan code jimi crawford tableau code
