give mechanically converting easy converting recursion high operation flowchart main transformation recursion removal eliminating subexpressions combining loop replacing procedure call body introducing assignment overwrite cell garbage collection automatic improving system developing able system clear system convert probably transparent revers clear tortuous siven competent able system system built around hope encourage user formulate term domain leave system task efficiently work partly inspired minsky homily form recommended good area intelligence work also influeneed dijkstra idea structured differing investigation took collection prooedures ambler burstall aimed transparent operation used transformation collection high procedure code operation intersection nilset consset minus operation burstall collins popplestone main feature note lisp lisp concat join lisp append operation must structured term user system powerset operation look produced much procedure powerset term system well archy system eliminates gain hierarchy four process seemed recursion removal eliminating redundant computation merging subexpressions combining loop replacing procedure body causing reuse data reduce storage garbage time devised give applicable domain rule equivalence domain reproduce automatically incorporated handwritten domain system process take recursive convert mediate imperative imperative recursive permit assignment data system must property commutati operation used form recursive subexpressions compound operation occurrence algebraic equivalence extract constructed duce elaborate proving used even xrked code recursion removal system oonvert recursion gram operation process paid semantics operation recursion process applicable recursion rule giving algebraic operation used considerable investigation translate recursive achemas achemas garland luckham know lisp compiler make idea translation schema preserve primitive translation preserve schema primitive obey algebraic follow cooper gave translation interested translation translation schema maintain equivalence seem weak practical translation type computation resulting rearrangement computation recursive step case save time storage overhead stacking factorial tree grown recursive call redundancy calculated node system computation well fewer overhead fibonacci system recursion removal four part translation rule rule recursive schema primitive schema primitive primitive possibly extra restriction satisfied schema recursive determines recursive schema rule find substitution prover seek substitution legitimate rule satisfied control smallest disjoint subset call vice versa subset subset separately find translation rule applies subset matohing prover translation form find find substitution take primitive also primitive lambda darlington coded lucidity translation rule recursion schema cooper equivalence computation darlington semantic automatic thesis machine intelligence edinburgh ernst newell generality carnegie pittsburgh pennsylvania simon heuristic compiler simon siklossy prentioe hall jersey burstall topor communication boyer moore proving lisp memo computational edinburgh sheridan arffiimetic translatorcompiler fortran automatic coding system rohl note compiling arithmetic february hopgood compiling mnnographe macdonald london american elsevier york
