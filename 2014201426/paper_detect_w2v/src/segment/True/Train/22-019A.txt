flow control redundancy trace exploited suitably abstracted reuse transformation caching partially evaluates control flow network formed automatically incremental specification show straightforward inefficient lisp conjunctive match automatically transformed rete network understandable elegant automatically incremental network conjunctive establish criterion planning chart parsing consistency maintenance analogical reasoning caching exploiting redundancy computation reusing previously system cache experience learned time intelligent interactive system repeated data persistent intelligent interactive system data straightforward persistent system inefficient base relevant potentially reusable computation discarded identified computational redundancy flow control redundancy exploited work part grant medicine pittsburgh trace flow procedural control recursive like lisp explicit tree dynamic procedure call tool caching transformation caching partially evaluates reuses control applicability prototype eval lisp executable show help conceptual implementational derivation statesaving incremental network illustrate fixed callgraph reverse flow computation data flow moving thus driven incremental data rigidly preset utility demonstrated transform inefficient lisp conjunctive classic rete match forgy also demonstrates automatic transformation prototype eval showing indicating conjunctive match lisp mechanically alternative network join topology transformation spend minute modifying month engaged network suggesting uniquely suited potentially persistent system differs ordinary data caching baer control data stored caching pugh cache network trace observes remove control dependence graph ferrante diminish control flexibility introducing transformation show transform rete network caching caching transformation arbitrary network defining establishing network motivate control flow cached netwoik mechanic transformation construct operate data sequenced control data evaluator lisp eval also partially control proceeds traversing control evaluating data lisp control recursion data list traversal lisp code tree recursively eval node tree network operate traversing acyclic network reside network node control netwoik link link directed graph encode ordering node netwoik traversal guaranteed ordering belong network enumeration topological ordering knuth assures node visited exactly predecessor visited data leaf computation propagate network node computation locally stored node memory node memory predecessor node network computation stack frame recursive usual netwoik persists finite differencing paige reduce redundant computation node incremental node memory divided buffer network overhead linear idagi node edge hoover propagating leaf keeping newly node buffer memory topological ordering assures node recomputed exactly perlin made subset leaf memory persists computation need propagated transitive closure subset affected iaffectedi idagi recomputation directed coupled finite differencing incremental price inflexible control network restricted form block despite limitation network find extensive incremental spreadsheet sketched conjunctive cast network form dependency inheritance consistency maintenance reasoning doyle incremental grammar caching control flow control futamura fixed yield callgraph interactive pose interactive characterizes interactive control cached network reuse encoded node node allocated memory control flow recorded edge applying data leaf graph traversal respecting node ordering edge execute network operationally partially evaluated illustrated transformation caching transformation loosely coupled step step assembles subgraph collect network resulting cached network used reused data cache pedagogical perlin caching build construction take text procedure employ auxilliary data cache used assembly final also step cast graph node caching proceeds step step trace formed node resulting represents step trace formation facilitated controlflow cache recording step node used chart parsing winograd exploiting posted cache help reduce computation dynamic lisp passively cache succession branch full call tree regardless resulting callgraph capture time step caching assembling thus evaluated partially evaluated preserved step caching connects graph step resulting step operationalizes usable data graph node augmented requisite buffer memory reusing callgraph network directing graph partially ordered node enumeration node memory data cache computation incremental finite differencing effected buffer memory intracycle computation differentially intercycle memory collecting caching transformation completed collecting cache like cache employ cache spreadsheet conjunctive matcher prefix merging network allocating resource detemiining stay cache removed cache collecting cache resulting network used reused data cache propagate network employing buffer memory propagation memory correctness network traversal control enumeration topological sort completes transformation finite network demonstrate workability caching lisp evaluator eval transforms lisp eval lisp representing label denoting step cache node specifies label node type lambda containing execute node computation predecessor node recursively node predecessor eval computation arrive label node lisp abstracted eval unevaluated substitute execute eval lisp code tree delayed done recursively caching control node labelled also network structuresharing merging network traversal toolkit cached network demonstrated efficacy transforming lisp specification incremental network rete rete network caching rete incremental used production system conjunctively many many excellent extensively studied varied also good caching transformation illustrating nontrivial cache callgraph cache rule rule system production system match control data rule test memory come slowly varying data rule test match rule firing serve modify practice form rule conjunctive containing test restricting matchable instantiation rule satisfying rule test rule evaluator must match rule combinatioas forming instantiation applies test producing filtered instantiation production system persistent maintain finite experientially derived rule data interactive also inefficient rule data instantiation grows exponentially fact conjunctive rule minton fraction rigidly applying rule data perhaps incremental data computation rule rule test test test computationally subprogram observe match test data conjunctive matcher programmable control caching incremental transforming rule rete network illustrate caching generating rete network specification stan specified inefficient auxilliary cache match capturing control flow usable incremental network processed data cache merges conserve done test sharing node test prefix combined form trie data construction rete network rule lisp rule specifies fixed test match conjunctive match match formulated control memory filter match lisp serial processor impose fixed ordering rule test examines ordered ordering test associate test perlin last examines arrange test match testing test subset test subset test grouped alpha test beta test ktuples many lisp code filter iteratively recursively transformation style clarity match linear recursion match data match test data test test data join preceding beta rest rest alpha match take preordered test data merges filter recursive call linearly recursive note test match test deposited locally filtering control made data auxilliary subset satisfying test operates pair step eval matchitcsts label match save rule test cache used match growing call tree linear spine test localized node step free data attached turning call tree step graph rule match completed memory intracycle buffer specialized graph reused bottomup network filtering domain filtered buffer memory traversal data computes filtered instantiation subset node memory initially continually tool linearly recursive conjunctive matcher computing instantiation incremental network computing rule match surprising show rete network beta join topology isomorphic match collecting rule system comprised finite rule form rule match cache cache conserving cache merge network matcher unchanged proceeding data node merged prefix sharing test succession merging node trie depicted alpha discrimination beta join trie classical rete match network modifying lisp test tail recursively illustrates readily desired network topology lisp specification cache traversal rete network match rule cached callgraphs memory intracycle buffer intercycle memory node used data cache preserve match computation memory incrementally deleted memory alternate join topology caching generates rete network family junctive matcher match lisp specification changing name cached node many join topology specified automatically constructed also cache merging besides prefix sharing rete linearly structured call graph alternative cache beta join node miranker call graph binary tree stolfo long linear problematic rete exploring assessing join topology rapid prototyping tool topology custom tailored learning parallelism recursive computation floating arithmetic file access control data uninteresting intelligent system precomputed user mundane concrete goal computationally difficult control modification reuse conceptual framework planning schank retrieved step replayed analogical reasoning carbonell extend retrieval transformation retrieved plan caching cache simply unraveling tree time rete take role enabling dynamic contextfree parsing graph node represents firing grammar production cache chart past firing constrain rule firing recorded node rule system form trace rule rule data dependency consistency maintenance exploring alternative reasoning form network utilizing data cache ground incrementally propagated traversal caching persistent process maintain cache cache augmented modified time cached sufficient redundancy compiled callgraph cache network rule trace representing arbitrary rule morphology cached network abstracted network node chunk mitchell trace reformed network sufficient operationality reused cache resulting system laird compiled rete network gain many persistent process comprised inheritance network automatically cached callgraph process successive subset classification window system thought caching inefficient painter redisplay accrue data inside window window redisplay applicable persistent interactive intelligent system comprised weaker partially evaluated need long manageable caching succeed finite alternatively skewed distribution probabilistically manageability extending rete match disjunction introduced conjunctive rule much redundancy control flow weaker redundancy effectively exploited copying conflict resolution work transfonnation reexamine many network impartially evaluated preserved rete case reformulation network lead clearer specification guaranteed transfonnation perlin effected abstracted network conversely clear specification redundancy guaranteed property simply empirically route improving possibility refining classic incremental network redundancy reexamining inefficient architecture reusable redundancy developing persistent interactive process precise inefficient sufficient controlflow redundancy transformation succeed conclusion caching transformation simpler many modem compilation nonetheless mechanically transform sufficient redundancy highly incremental counterpart chief practical rapidly testing network ordinary demonstrated rete intelligent system computation must rely viable extent system redundancy control evolve time help intelligence suggest caching reuse applicable broad area acknowledgment jaime carboneu much assistance idea peter david steier milind tambe also contributed idea evolutioa
