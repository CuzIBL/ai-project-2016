connection graph reasoning recursive rule donald mokay stuart shapiro york buffalo amherst york abatraot raouralva rule parent ancestor ancestor vary uaaful proving natural languaga retrieval system many system causing loopa requiring many copy made snip snap inference package reouralva rulas raouralva rule oauaaa connection data answer cycling stop soon desired answer produoed answer produoed resource exceeded work aupportad part foundation grant raouralva rule parent anoestors ancestor naturally infaranoe system used proving natural languaga undaratandlng transitive ancestor ancbstor ancestor inheritance rulaa circular limb limb equivalence receive ptrans ocourranoaa raouralva rule raouralva rulaa system implementors inference system naive chaining loop like parser raouralva grammar soma system raouralva rule onoe incomplete system build tree like data containing branch depend time recursive rule theae build struoture langth branohaa problematic ayatama eliminate reouralva rule deriving data baaa implication reouralva rulaa apaclal paaa normal infaranoe dona avoid circular equivalence system blaok simmons chester surprisingly recursive rule many intelligence mlcroplanner fuzzy prolog differing baalc well formed loopa procedure clause used terminology mlcroplanner sensitive assertion equivalently retrieval subgoal interaot make collection incomplete logically implied data baae assertion derivable beoauae system loop typioal ancestor mentioned previously mlcroplanner like ayntax consequent consequent ancestor goal ancestor ancestor goal introduces deduce instanoea ancestor assertion data baaa rule pick regardless reuses progress enter loop mlcroplanner primitive thunique uaad previously entered binding doaa regress recursive user must inolude possibility uaer fact uaad recursively happen olroular equivalence inadvertently introduced collection fuzzy suffers compound operator thunique noted apparently fuzzy need recursive procedure lefalvre communication thunique simulated fuzzy pure prolog also oontain thunique primitive recursive rule properly procedural semantics seme prolog declarative semantics prolog primitive mode recursive clause user prolog snip rule stored indexed data base asked system retrieves relevant rule build connection graph derive answer rule stored data base semantic network used declarative system differ data base system distinction extensional intensional data base rule stored data base distinguish base ancestor stored well rule defining ancestor inferenoe system restrict hand side rule oontaln derived need reoognlze graph exit connection graph viewed reduction graph root code represents rule reduction operator partly influenced kaplan system node representing node subproblem node representing subproblem parent node reuse extant node avoid extant node subproblem produced extant node made extant node cancelled employed handle reourslve rule seen size resulting graph depend time recursive rule used describes snip handle recursive rule system relevant abbreviated cmitted neither match routine retrieves unifiable logioal connective sneps snip connection graph clause interconneotlvity graph used resolution proving system answering system connection graph collection predloate calculus unifiable linked edge labelled unifying substitution system inference impose edge thea systeas whloh resolution rule inference predloate oaloulus clause forum complementary joined edge linked system clause form connective calculus edge link instanoe antecedent unlflable consequent system backward chaining forward chaining edge asserts show ever deduoed used match operation specifies slightly form labelling edge directed edge linking node target node labelled target binding binding used show consisting five rule labelled rule remainder form universally quantlfed horn clause snip edge labelled pair target binding souroe binding souroe node edge target node head edge edge labelled target snip match edge remainder ooncerned last form actiive connection graph connection graph connection graph edge link labelled target binding binding graph flow edge analogy rule producer consequents consumer antecedent rule edge opposite edge binding play role target binding flow binding translates consequent reasoning system asked deduoe instanoes deduoe instanoes deduced thus rule used rectangle enclose antecedent double consequents rectangle represents request deduoe instanoes empty consequent part eaoh rule labelled rule labelled label arbitrary reader infer anything construction label remainder expands connection graph target binding binding operate binding flowing target binding binding binding subset connection graph produced binding allowed paaa binding uaed switch produoea binding send binding must mapped continuing binding passed next encounter switch switch binding operation binding case yield binding oontext deduoe back chaining ground rule request request next step goal node goal node match find unify ground binding match answer goal node match antecedent consequents rule consequent rule rule target binding switch containing binding goal node process creating goal node antecedent rule step process repeated rule ground goal node need oreated suffice remainder describes find adequate extant goal node extra previously goal node goal node rule goal node checked namely unifiable antecedent rule goal node thus goal node match matched antecedent marked pointer newly goal node pointer link antecedent goal node goal pointer like edge eaoh goal pointer marked target binding binding goal node goal pointer goal node goal node pointed used goal node process recall request goal node match match tuples consequents rule rule switones goal pointer oreated beoause matoh antecedent rule continuing expand anteoedents picking expand whichever picked constructed picked ohecked goal pointer none goal node match tuples antecedent goal pointer goal node also goal pointer goal node draw goal pointer dashed line labelled target binding souroe binding match show part goal pointer step remaining target consequents rule rule next goal node oreated goal pointer thus instanoe goal unifies goal pointer binding rule instanoe necessarily compatible binding goal target binding goal pointer identical binding identical goal rule instanoe interested subset namely whioh note goal node also term creating goal node edge reused must switched binding binding assures goal node swltoh considering binding pair binding term discarding binding pair inverting remaining pair yield binding switch discarding pair term inverting yield show swltoh expanded goal node goal pointer established antecedent goal node goal node superseded goal node eventually goal node superseded erased consumer superseded goal node consumer goal node switch superseding node consumer stated rule consume antecedent consequents ignored constitutes basically alternative binding yield lnstanoe prefer alternative inference need extra match operation mentioned superfluous communication rule unify edge binding need communicated edge connection graph mentioned rule rule rule pair rule binding rule lnstanxes identity binding binding binding pair binding used restrict rule generating requested word used rule keep inference focussed lnstanoes rule linked switch goal node separation target binding rule work relying binding switching oontexts target binding producer used consumer goal node production site lnstanoes consumer goal node indexed antecedent goal pointer rule recursive rule form unlflable antecedent mean goal node used creating goal node recursive ancestor rule rule calculus ancbstor ancestor ancestor parent ancestor remainder ground parent bill john parent john mary ancestor ancestor john mary ancestor mary sarah ground never node match edge ground rule omitted request lnstanoes ancestor inference proceeds creating goal node request creating rule rule whloh consequent creating goal pointer antecedent rule show lnstanoes produoed term goal next goal node collect produoed flow encounter request consumed goal node previously produced thus binding representing ground ancestor bill ancestor john mary ancestor mary sarah stored consumed request picking rule expand expanded derived stored goal node creation goal node insignificant reuse ancestor goal ancestor goal pointer binding thus goal pointer target binding identical rule binding used accomplished giving consumer ancestor antecedent switch binding produced consumer processing antecedent consumed ancestor goal node data collector data collector consumed never previously produced goal node consumer previously produced consumer also consumer receives produced goal node fact data collector never twice protects snip getting loop prohibiting passing around next trying goal node ancestor goal pointer target binding binding rule instanoe identical consumer switoh stored produced consumer binding antecedent produoe consumer produoed produoe goal node parent call goal pointer parent match resulting ground instanoes show matched instanoes stored produoed consumer antecedent satisfied binding next passed produoed produced request consumer passing switch binding arrives ancestor bill mary produced previously pass consumer turn produoes previously produoed binding consumer produced slnoe rule expand inference terminates demonstrates recursive rule productively used loop loop encountered oould produced oontalns opposed continually trying recursive ancestor rule also demonstrates accessing data stored goal node consumer property goal node acting data collector suggests rule instanoes binding waiting sufficient consumed binding snip connective scheme rule instanoes produoe consequents note kind indirectly recursive rule well recursive rule resulting connection graph directed graph neither tree directed aoyclic graph size snip recursive rule connection graph feature connection graph recursive rule handled goal node data oolleotors data collector never answer data oollector consumer consumer data colleotor time iimmediately previously oollected data localized switch dynamically data flow around graph producer used consumer goal node indexed antecedent matched goal
