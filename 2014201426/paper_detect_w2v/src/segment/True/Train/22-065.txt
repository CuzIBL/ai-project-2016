well transformation major drawback folding eureka step invent procedure folding driven transformation aimed suffering inefficiency repetition identical subcomputations analysed locate repeated subcomputations used control transformation automated regarded explanation learning clocksin clausal specification horn clause started construct term yield represents fibonacci yield term clocksin term find subterms fold term graph subterm graph hypothetical dataflow fixing unpractical fibonacci harmful case term series dimension matrix discrete fourier transform regularity resulting graph striking easy extend hard come recursive procedure parameter computing suited automation deriving recursive procedure address inefficiency repeated subcomputations lemma kowalski tabulation bird give yield optimal algorithmic looked transformation burstall darlington used fold step eureka step invention procedure area machine learning explanation learning mitchel jong mooney behaviour explanation learning pointed harmelen bundy explanation learning used control process extends idea used control transformation process argue suited automation also case subcomputations identical seem feasible next give automation finish work well computing fibonacci yield tree subgoals relevant part subtree goal twice computation avoid repetition achieved fibonacci extra subgoal realised transformation unfolding occurrence goal factoring eliminate undesired clocksin show derive dataflow graph clausal exhibiting redundancy recomputing identical subgoals time graph derived substantially clausal frozen clocksin idea control transformation subcomputations identical computation investigating relaxed tower hanoi computation subgoals form hanoi move hanoi move structurally identical name generalisation hanoi yield execute call take copy successfull unify copy call copy call explanation transformation ebpt borrows idea explanation learning mitchell jong mooney carthy also form guided unfolding relationship studied harmelen bundy ebpt applies guided unfolding realises also guided folding consequently modify prooftree also shavlik jong restructures prooftree case repeated rule observe restructuring prooftree essential truly operational also borrowed idea area transformation maintaining completeness system derive rule base never remove rule rule quickly find redundancy size area transformation equivalence rule used remove rule address also studied area transformation transformation darlington burstall burstall darlington served framework transformation major wide debray pelhat loopmerging gregory debray proietti pettorossi avoiding redundant computation gregory fronhofer komorowski venken compilation control gregory bruynooghe schreye bruynooghe closely major drawback hard automate degree automation inversely proportional size transformation deal system transformation depend user gregory control sato heuristic transformation proietti pettorossi mainly guide unfolding lemma eureka folding deal transformation well user supplied proper directive control heuristic transformation full automation fronhofer also studied eliminating inefficiency occurrence subcomputations prooftree computation scanned bottom identical subcomputations subcomputations diverge made generalise subcomputations generalisation eureka automation classic avoid redundancy identical subcomputations tabulation bird survey lemma kowalski idea build answer call encountered consulted stored answer used transformation also assert time consuming acknowledgement belgian fund schreye belgian
