take fixed expressed inductive step transforms augmenting system fixed handled automatically need proceduralizc algebra motivation synthesizing nonrecursive fixed synthesis synthesis efficiently solves real practical utility database derived system metaphor lead intuitive thus link synthesis illustrated illustrates idea classified domain sort list processing derive synthesizing domain background form throughout degree left hand side satisfying operation calculating flight city time determining circuit connecting none couched algebra ahol studying powerful data ullman ahol postulated noted fixed calculus codd constructed inductively inductive rule ahol occurrence optimization automatically synthesizing like form transformation database algebra preserved take fairly sophisticated user wrig grounded resolution robinson naqvi henschen derived slight abuse link zloo also framework intuitive explanation simpler calculus thus database containing father parent asking kind ancestor person stated comment assumed universally quantified like prolog pere base occurring database instantiated represents retrieval request thus parent read parent parent tuples fourth purposefully obscure incomplete ancestor highlight distinction handling prolog system work assertion also assertion fact putting prolog system infinite computation proceed intuitive need system work assertion form problemsolving system solvable instantiated evident replaced view thus replaced problemsolving system obvious match head match assertion substitution thus replaced body namely father subproblem solvable fact yield answer collect ancestor replaced body substitution yield ancestor parent proceeding subproblem ancestor solvable parent yield substituted back failed subproblem ancestor subproblem asked process repeat captured step retrieve father tuples answer ancestor stack stack assign retrieve parent retrieve father also stack collect tuples retrieved father ancestor step system match head side assertion match succeeds replaced subproblems body assertion substitution subproblems head assertion match system make naqvi henschen queue inserted computation remove yield primitive subproblem father ancestor parent ancestor residue thus residue father inductive residue parent form differ inductive residue used call specified step driver lead form left used elucidated stated hypothesize generates subproblems examination subproblem solvable eval eval eval eval form form answer briefly answer logically implied process resolution sound answer clearly cyclic stack must empty kind cyclicity reflexivity recognized slight case elaborate termination test remembering derivation yield termination case naqvl henschen transformation identifying clause connectivity graph unification admit case representing recursive well case eval part loop expanding recursive part give preference operation join time obviously codd
