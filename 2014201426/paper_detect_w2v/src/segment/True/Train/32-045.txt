highlight inefficiency graphplan backward eliminated learning backtracking graphplan demonstrate effectiveness augmentation describing empirical show dramatic loox well benchmark seven domain graphplan blum furst classical planning four five competing system planning competition graphplan mcdermott extending graphplan thus seems experience learning backtracking graphplan backward explaining failure tree propagating explanation upwards tree kambhampati propagation failure explanation intelligent backtracking storing failure explanation pruning node graphplan rudimentary form learning call memoization graphplan brand learning weak explicit failure explanation failure node node explained kambhampati eliminates opportunity dependency directed backtracking also adversely affect utility stored memo part young investigator award laboratory planning initiative grant army aasert grant afosr grant grant thank maria derek long terry zimmerman amol mali biplav srivastava comment work planning scheduling give graphplan intelligent backtracking learn memo applicable technically generalizing jumping prosser work graphplan backward empirically graphplan hard unsolvable benchmark used kautz selman well four test domain show fold next background graphplan backward inefficiency backtracking learning used normal graphplan motivate need describes graphplan empirical demonstrating usefulness augmentation work conclusion work review graphplan graphplan blum furst seen disjunctive forward planner kambhampati interleaved phase forward phase data incrementally backward phase searched extract plan alternating list list show zeroth list planning graph introducing precondition list domain dummy persist list precondition introduced list constructed introduced planninggraph maintains dependency link used illustrate graphplan precondition list list planninggraph construction also computation propagation mutex propagation statically interfering precondition inconsistent labeled mutex mutexes propagated forward propagation rule curved line mutex phase checking corresponds goal none mutually exclusive supporting make sure precondition satisfied thus subgoal recursively supporting selecting find infeasible mutually exclusive backtrack find mutually exclusive previously stymied backtrack undo graphplan chronological backtracking whereby indication inefficiency failure assign nothing assignment chronological backtracking vain hope averting failure lead wasted case turn find backtrack continue forward impasse mutex backtrack continue goal tracking remaining pair marked mutually exclusive backtrack need back abandoned away grown goal goal done graphplan make memo lect list signifying fact failed goal supporting goal hope ever subgoals mutually exclusive backtrack goal scuttle recursively away help remembered memo call process indication remembering precondition subgoals even probgoals succeeds trying assign simultaneously reach nothing subgoals introduced mittal falkenhainer inefficiency graphplan backward motivate need review graphplan backward pinpoint inefficiency base planning graph memo stored backtracking continues chronological fashion trying reassign indication inefficiency caused chronological backtracking really role failure encountered assigning spawn backtracking scheme graphplan considers reassigning subtle reassigning going avert failure work kambhampati memo cated connection backward phase remembered memo graphplan satisfaction much chance dynamic satisfaction goal taking ested part failure also unless port goal keep matter reassigned considering assignment assigns going avert failure bottom continue backtracking kambhampati alternative memoize backward fails graphplan extends planning graph backward graph improving backward graphplan backward augmented full fledged eliminate inefficiency pointed informally explanation failure leaf node regression propagation leaf node failure explanation interior node failure explanation line kambhampati backward seen adapting jumping prosser generalizing work graphplan backward seen form dynamic satisfaction parallel framework kambhampati form mutually recursive procedure former call assign pick selects recursively call remaining invoked empty call initiate next illustrate retrace pick assign assign violate mutex explanation failure node false derived explanation failure thus stated explanation mutual exclusion hold long take conflict directed prosser remaining explanation compactly term conflict reach find assignment conflict initialized assignment inconsistent mutually exclusive assignment conflict conflict expand find informally conflict seen incrementally maintained explanation failure indicating conflict kambhampati planning scheduling graphplan backward enhanced find mutually exclusive supporting practice conflict backtrack passing conflict essence conflict shorthand failure explanation kambhampati worth noting revisited assignment preceding conflict strip disjunctive clause graph next implicative clause part mutual exclusion conflict keep name last clause denoting essence assignment causing failure assign considering assignment dependency directed backtracking maintaining conflict transparent dependency directed backtracking kambhampati failed assign backtracking need fashion jump back taking part conflict case avoiding considering alternative thus avoiding inefficiency backward easy sound causing failure thus avert failure continuing backtracks backtrack conflict absorbed conflict absorb conflict conflict assign remaining next assign find mutex thus conflict backtrack flict backtracking reach conflict absorbed conflict giving rise combined failure step illustrates conflict incrementally expanded collect failure backtrack conflict absorb conflict rent conflict backtracking reached backtracking must undoing assignment step memoization regression memoization backtrack conflict memo conflict memo memo shorter thus stored normal graphplan anything regression backtrack need convert conflict refers conversion process regressing conflict kambhampati essence regression step computes smallest supporting spawned activated dcsp term conflict case conflict memo farthest gone even memo supporter case responsible supporting need case heuristic computing regression prefer help conflict regress pick motivation rule keep failure explanation compact thus motivation rule deeper dependency directed backtracking note heuristic aimed improving affect soundness completeness heuristic applies also requiring even case regression regressing thus backtracking conflict jump back away conflict avoids inefficiency done normal backward backtrack conflict absorbed backtracking continues procedure repeated memoize memo backtrack graphplan extend memo capture failure rediscover able discover failing goal despite fact mutex goal memo couple regarding stored memo graphplan memo stored hash backward reach satisfied consults hash stored memo terminated compact memo goal going exactly match stored memo stored memo subset goal sufficient declare goal failure word memo checking routine graphplan need modified subset goal stored memo naive enumerating subset goal checking hash turn costly need data tree rymon koehler koehler seeming tree data ubtrees storing memo efficiently subset goal stored memo kambhampati empirical unless noted time minute spare ultra allegro lisp compiled time time used checking memo btks backtracks done parenthesis next name list time step avln avfm memo failure detected stored memo regarding memo serve failure explanation find goal subsumes stored memo failure explanation regress back process valuable opportunity back jumping also learn compact memo note none normal memo stored graphplan memo declare goal failing memo exactly goal case regression goal jumping learning kambhampati empirical seen backward maintaining updating also noted avoid inefficiency graphplan backward augmentation soundness completeness property kambhampati remaining make practice empirical answer graphplan code minor also subset memo checking code koehler comparative benchmark kautz selman lisp graphplan done marie peot subsequently david smith planning scheduling well four domain domain block rocket logistics domain gripper domain ferry domain traveling salesperson domain tower hanoi specification well domain publicly show statistic time backtracks made normal graphplan graphplan runtime reduction solvability note dramatic upto seven domain tested also note backtracks reduces significantly consistently push solvability horizon many unsolvable even hour time reduction memo also show memo stored graphplan decreased substantially employed memo column avln logistics ferry domain relative reduction memo domain well correlated seen domain note block domain show also reduction fact memo show essence normal graphplan failure embedded many many sized goal storing memo time incurring increased backtracking cost thus wonder normal graphplan badly graphplan utility stored memo lisp system configuration amounted hour real time garbage collection time eral memo normal graphplan fewer memo column labeled avfm give ratio failure discovered memo memo seen rough utility stored memo note utility consistently memo used discover failure time memo normal graphplan lisp graphplan done many optimization nagging doubt dramatic somehow dependent moderately optimized lisp used thankfully also maria derek long stan system stan highly optimized graphplan fared well aifs planning competition resulted dramatic system work graphplan blum furst experimented memoization subset memoization keep memo memo used declaring failure stored memo subset goal subset checking costly experimented subset memoization subset sized goal mentioned koehler koehler subset memoization subset checking storing memo data hash subset memoization well kambhampati mixed best nowhere near achievable easy memo checking time data generating storing long memo dependency directed backtracking stored memo utility significantly thus offering dramatic kambhampati describes sketch dynamic satisfaction kambhampati graphplan dynamic seen idea conclusion work motivated need graphplan backward graphplan also analyzed empirical demonstrate significantly enhance graphplan benchmark seven domain fact encountered turned drain graphplan work forward checking dynamic ordering graphplan show time kambhampati success graphplan part high degree redundancy planning graph zimmerman kambhampati investigate even aggressive exploiting redundancy planning also studying utility relevance learning bayardo schrag well memo transfer
