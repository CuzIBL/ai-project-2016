optimization eliminate recomputation caching reusing analyze automating deciding computation safe cache transforming rest make safe choosing cache maintaining optimized code extends work caching considering side data edits acceptability caused caching explores make explicit depend prototype incorporates many optimizing hand indirectly process optimized difficult maintain ideally like maintain unoptimized machine take care optimizing free simpler understandable code unnecessarily computation optimized away done degree optimizing compiler show done exploiting compiler namely caching storing reusing computation caching thought trading time cost used storing benefit time spent recomputing caching also reduce storage cost eliminating extra allocated recomputation caching thought form learning insofar tends time caching considerable marsh lenat bird anderson neches rosenbloom applicative specialized production system chose investigate interlisp teitelman toward constructed prototype memoize installs cache interlisp address rutgers hill busch campus brunswick jersey defense agency view conclusion contained representing official opinion darpa government person agency operation installing cache trivial transformed cache indexed interlisp conveniently done adviseing transformed actually computes look cache thus save expense recomputing cost storing accessing cache equivalence criterion used stored cache test imagine memoize refer transformation memoizing also talk memoizing fragment memoized rewriting defining memoizing computation cached folding defining memoizing deciding part memoize trivial memoizing substantial modification rest memoize greatly facilitated tightly integrated interlisp masterscope analyzer match compiler advise interlisp forced confront many arise simpler yield automatic rest safety maintaining optimized safety optimization safe optimized accomplish unoptimized case memoizing used think ensuring safety straightforward memoizing fragment analyze make sure memoizing yield view naive equivalence mind beholder solely looking code caused memoizing actually desirable real memoizing preserve equivalence acceptable safety property fragment rest fragment memoized safety memoizing term acceptability unmemoized ignore arise mostow cohen nondeterministic safe recompute retrieve inappropriate relies memoized potentially benefit automated memoizing permit simpler style unacceptable unimportant beneficial user intent instrumented time spent machine memoizing defeat hand goal find eliminate bottleneck memoizing desirable even illustrates acceptable infallibly inferred code specification supposed derivation code specification acceptable even absence fairly reliable guess made default conservative safe inefficient refrain memoizing memoizing affect time cost preferably time cost acceptable safety case embedded system storage clearly influence acceptability side eliminated caching eliminating recomputation caching eliminates side recomputation memoize considers preclude caching user confirmation computation side memoized side time computation invoked clear screen memoized even fragment indispensable side memoized sometimes move code side outside fragment code outside scope memoize sometimes eliminating side caching actually eliminated user care even rejoice memoizing print message time eliminated break computation generates user caching save trouble fixing eliminated computation print answer caching usefully reduce questionanswering burden user answer indexed used prevent memoize asking repeatedly identifying side computation difficult memoize masterscope identify indirect side fragment assist user deciding safe memoize fragment memoize side path indirect side invoked side evaluating constructed runtime eval masterscope predict smashing data rplaca putprop putd convenient regard like time form clock viewed allocation oons also side separately eliminating infinite recursion introduced memoizing concern infinite recursion memoized code cached computation stored creates empty cache completes computation fill cache lookup ever retrieves empty mean absence caching computation invoked parameter entered infinite recursion case retrieval code halt warns user describes handle case alters parameter introducing extra computation memoized invoke user code unmemoized arbitrarily memoize must take care avoid evaluated entering body memoizing evaluated unnecessarily wrong memoizing call listp break even unmemoized memoize refrain memoizing nlambda conditionally introduced folding fragment folding listp listp folding twice side need twice allocation eliminated caching reusing recomputing mean call memoized data unmemoized constructed copy viewed returning substitute unmemoized substitute acceptable made elsewhere case allocation eoness allocation affect insofar affect data reuse safety caching problematic allocation memory iterate memory implicit constrain memoized cache passed memoized cache cached copy constrain reuse substructure code depend acceptable obvious identify unfortunately declaring keeping consistent changing code imposes kind burden maintaining documentation assist user bearing burden machine happens computation unmemoized code masterscope inadequate data flow derived installing cache experimentally memoized recomputes even stored comparing stored recomputed detects reuse reusing smashing detected storing copy well comparing smashed copy depend interim used allocation must reused sometimes correctness reuse substructure unmemoized satisfies memoized cached returned copy returning data used name memoized node caller want modify copy reused call copy rely property memoizing save time reusing copy besides time recomputing consumer test succeeds much data canonicalized case sometimes equivalence nothing relies returned unmemoized case cached reused even relaxing equivalence test cache closely idea reuse cached mostow cohen particularly case safely retrieve obvious fewer need disadvantage cache lookup equivalence criterion slower slower hand canonicalizing permit test elsewhere optimization tactic masterscope also rely canonicalizing caching safety simply term unmemoized code must reused sometimes reuse part returned time used incompatible caller smash next want used memoizing reuse caching interfere memoized made copying cached returning much need full copy list copying suffice much safe copy part substructure copy copying operation terminate circular time cost defeat caching introduced memoizing seen safe caching must made code memoized memoizing transformation introduces code make code assumes part code cache lookup memoized infinite recursion familiar implementors like break advise memoize assumes cache altered corrupts retrieve reasonable cache built caching unmemoized cache also incorporates trojan horse data passed returned memoized user code retains pointer worry smashing line reasoning used show absence danger generality cache never smashed certainly case smash pass memoized returned prevent copy incorporating cache case mostow cohen tempted smash incorporates part smash cache copy protect caller smashing returned allocation introduced copying must acceptable canonicalizing acceptable equivalence criterion access part smashed done smashed case smashing cache cache never cache identity lambda smashing invalidate cache cache ieave modified acceptable substitute modified list affected operation reorder list masterscope done anyway hand must watch smashing done user break transforming make memoizing safe safety memoizing transformation variant make copy naturally much done willing part code memoized copy caller smash caller make copy memoized safely copying obstacle caching side safety memoizing side safety eliminating side invoked indirectly make memoizing safe spite side remaining show transformed prevent retrieval rendered obsolete side affect cache viewed smashing memoized data explicit passed parameter implicit accessed free property list atom even view data form smashing smashing cell implicit explicit really view reaction dependence treat like explicit conversely explicit well memoized substructure actually accessed computation part actually used cache safely indexed part discrimination tree test relevant part worthwhile computation ignores data idea dealing dependency cooperation part cache invalid cache affected something detecting reacting cost safe recompute scheme cache discard cache computation memoized many time computation invocation computation passed procedure containing computation computation corresponds block cache block discarded block exited empty cache memoized response side smash cache implicit discard cache response side smash implicit used affected recomputing finite differencing paige koenig side well sophisticated describes weaker reduces recomputation requiring detecting identifying cache invalidate restoring cache validity make memoized respond side must identify operation transform something cache affect triggering done degree selectivity degree sophistication understood modify primitive lowest lisp structuresmashing primitive rplacd seta altered trigger desired response catch structuresmashing operation many invalidate cached actually used memoize modify identify modify cache depend advised take modify invocation sometimes invocation affect cache cache sensitive seto affect case invocation transformed take memoize masterscope find invocation interlisp trigger code around also respond operator invoked interactively user memoize hook interlisp markaschanged savesetq identify suspect cache noticing identify affected cache done degree expense long side thinking invalid expense reduce expense brute force great great expense memory cell accessed cached computation cell used cache depend done memoize static sometimes modification possibly affect cache memoized operation affect masterscope recognizes dependence installs code react masterscope miss dependency aliassing smashing affect memoize relies identify code affect implicit dynamic dependency recording code access altered runtime static precise cache depend case memoize relies user code smash accessed case dependency computation cache retrieves turn data data ever invalidate turn invalidate thus need dependency cache data static dynamic dependency memoize decides heuristically predict dependency statically dynamically dependency static masterscope determines reasonable invalidate cache changing liable affect dependency property recorded dynamically static sufficiently precise memoized getprop dynamic tell atom color cached relied masterscope static cache suspect atom color mostow cohen dependency memoize static find invoked cached computation masterscope determines high accessed getd memoize dynamic static lack case invalidated cached identified potentially invalid something must done prevent retrieved cache depend obvious simply ever recomputed anyway computing memoized access data smash deleted empty time smashing shoot foot eventually invocation next watch recursion deleting suspect wasteful depend cached computation null relative effectiveness eager recomputation suspect avoiding deletion cache depend suspect recompute nothing else need done depend depend suspect process repeat dependency dependency finite acyclic process guaranteed terminate eager recomputation safe computation never occurred unmemoized describes hazard memoized eager recomputation zero even never evaluated zero memoize know side never listp safe eagerly recompute restrictive asks eager recomputation safe propagation exoneration suspicion alternative prevents retrieval invalid avoids unnecessary recomputation marker propagation depend data marked must recompute depend indirectly data marked need recompute depend recomputed cost marker propagation case eager recomputation also marked need recompute encountered depend need marked marked must recompute subsequently retrieved duly recomputed marked stored depended marked must recompute mostow cohen marked need recompute retrieved made exonerate recomputing checking supporting marked returned suspect retrieve recursively exonerated recomputed exoneration process aborted recomputed supporting must retrieved used computation must recorded retrieving unsafe case eager recomputation propagation avoids unnecessary recomputation recomputed data cache recomputed uncached computation computation safe cache mean worthwhile cache installed safety caching thus decide computation cache part cache maximize cache memory size degree sharing long stored unavailable garbage collection time rate retrieval replaces recomputation cost cache lookup frequency side render cache suspect cost responding cache lifetime cache take time predicting entail predicting influence heuristic estimating ultimate test cache view heuristic identifying promising memoize heuristic decide cache collect statistic cache rate frequency much time spent computing cached data used user machine decide cache keep computation cost time execute long operation take many time invoked latter quantity like many time loop relative frequency branch depend runtime data distribution hard predict analytically kant memoize heuristic computational cheap lisp classified individually memoized cheap user recursive containing loop call cheap classify compiled unavailable memoize user instrument interlisp breakdown postpone classifying data rate rate cache predicted prion characterization made static deciding part computation cache memoize intuitive rate computation decrease variability rate decreasing changing used computation rate decreasing frequency invalidate cached rate decreasing cache parameter domain parameter type boolean parameter take rate decreasing parameter worth caching subexpressions fewer parameter worth caching well rate mapping reduce variability used rate computation cached mapping term rate cache cache composite computation form mapping parameter rate rate masking variability path must cache well indexed choosing cache maximize rate used cached computation treated explicit cache parameter implicit made maximize rate tend recur used cache conversely explicit parameter stable many successive call returning former well treated call going parameter memoizing memoize heuristic classifying treat outside memoized parameter everything else heuristic work well encountered longish list worth refining treat flag parameter cost eagerness suspicion relative cost scheme responding side depend tradeoff unnecessary recomputation unnecessary propagation marker propagation scheme subset computation unmemoized good case subset worst case computation plus overhead marker propagation cache never marked need recompute must recompute absence caching overhead worst proportional computation must adjusted slightly depend changing piece marked must recompute time piece even propagation time adjustment piece proportional frequency time depend eager recomputation scheme safe risk recomputing unnecessarily never retrieved need turn unchanged scheme avoids overhead propagating marker mixed even cache time memoize decides predicting relative cost history suspect cache computation take time choosing scheme illustrates recurring caching cost alternative scheme heuristic degraded well offset eliminating cost recording history maintaining memoized code optimizing automatically manually tends make harder maintain optimization violated obvious analogous recompilation user maintain unoptimized code reoptimize grossly inefficient sort exploratory sheil illustrated memoize evolution repeated deciding edit resuming inserting reoptimization phase edit wasteful mostow cohen massive reoptimization timeconsuming wasteful extent simply reinstalling identical cache reoptimization automatic expense user answer wasteful extent answer scratch mean discarding cache even invalidated edit recomputed hand want inefficiency unoptimized code something like incremental recompilation user edit memoized code machine help user whatever keep safe cache affected edit edits affect caching cache invalidated memoized unsafe memoize cache cease optimally costeffective unmemoized worthwhile memoize memoize worry case unsafe memoize cache removed memoize considers failure deal last case affect edited safety easy editing affect safety caller edited memoize find memoized warns cache safe harder identify cache affected editing noticed straightforwardly modified memoized access affected case sophisticated data flow matter good tool intent implicit code speeding reusing cost used memoizing process recorded depend property well user answer memoize cache kind dependency incompletely caching invalidated anywhere changing call indirectly call remembering user answer property answer implicit mind user barring breakthrough mostow cohen conclusion tried systematically analyze caching deciding part safe memoize transforming rest make safe choosing memoize maintaining optimized code extends work caching considering side data beneficial edits insight gained transformation like memoize leaf unchanged make acceptable acceptable safety cost viewed deciding rearrange computation cached uncached part binary memoize deep optimized involving undecidable ever smashed depend implicit rely returned eliminating recomputation detects form infinite recursion scheme detecting preventing assault cache scheme identifying invalidated heuristic computational exploitation mapping rate reduce cost maintaining cached cache safety face edits memoize constitutes contribution sort misinterpreted serf demonstration many practical tool evaluated statistic distorted extensive bookkeeping caching arbitrarily high memoized evaluating real tool applying sample applying tool nothing much simpler tool mind main memoize exploratory vehicle opportunity exposed greatly insight caching insight concern work extend memoize tool originally hoped process installing cache interlisp made automatic much clearly obstacle achieving ideal acknowledgement like thank bill swartout asking good balzer suggesting
