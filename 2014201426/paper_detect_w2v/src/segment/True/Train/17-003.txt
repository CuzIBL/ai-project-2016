match stored plan template unaccountable stored plan parsed plan transforms statically representing variant student inductive unanticipated transforms establish equivalence stored plan rejected buggy unanalyzable formal automatic debugging katz manna extends incorrectness mean correcting incorrect synthesized inductive insufficient establish correctness altered inductive derived synthesizing inductive determining alter difficult date shapiro trace pure prolog isolate presence procedure trace incorrect user supply correctness trace violation well founded relationship corrected synthesizing clause searching perturbation buggy clause murray user debugs synthesis plan parsing debugging debugging talus acceptable variability student robustness debugging process relying student assist debugging formal verification debugging correction stored student parsed collection slot property recursive partially enumerate recursively data slot representing recursion type tree list recursive call termination task role main constructor facilitates robust process semantic feature enumeration role task code talus talus talus best competing stud stored node part mapping student stored competing mapping missing superflu student reduce student extra stored student missing paired parent task role dissimilarity mapping pair contributes penalty differen slot penalty mapped missing extra alternative algorith extensionally intensionally solut transforms illustrates talus debugs stud matched stored binary represents nonterminal representing test terminal representing termination recursion recursive call term must true false reach terminal node term governing node term governing terminal node case case talus symbolically evaluates student stored functi termination recursk formal case test true false case splitting resulting returned talus returned student stored assumed case prover used case computational equivalence correction talus debugs student code fragment comparing stored code fragment considering talus tentatively replaces student code stored code code fragment functionally altered code fragment remaining talus applies debugging procedure recursively replaced remain tried stored code fragment replaces student code fragment annotated edited brevity middle tutorial session student lisp task memtree determines atom leaf defun memtr flat defun flat atom flat flat defun listp list buggy memtree task talus must recognize student used memtr flat parsed student talus know memtree task explores tree separately atom tree memtreeflatten flattens tree determines atom resulting process used student matched stored flat flatten memtr memtree transform transforming flatten mcflatten match flat talus selects student stored flatten memtree comprise memtree mapped student flat memtr talus stored transforms transform closely student thus mcflatten replaces flatten call mcflatten replace call flatten transform call simultaneously logically inverted talus formal matched heuristic take data type flat mcflatten memtr memtree talus debugs student comparing stored matched talus matched flat flatten transformed flatten mcflatten match flat stored mcflatten defun mcflatten tree answer atom tree tree answer mcflatten tree mcflatten tree answer facilitate talus replace buggy student code stored code code normalized replacing stored formal name student permuting formal match student defun flat atom flat flat examining stored talus determines case atom true atom true comparing student stored case case atom case stored student hint look used flat atom flat flat flat flat conjecture checked conjecture disp rover counterexample counterexample stored binding formal stored task conjecture evaluates true counterexample believed definitely false conjecture believed passed boyer moore prover formal verification conjecture previously normalized stored conjecture formally proved student code case believed conjecture fails conjecture false lemma succeed missing conjecture believed proven boyer moore prover fail absence lemma happens buggy replaced stored code fragment buggy detected practical elegant accept true conjecture believed conjecture disprover talus relies formal weakened practical improves markedly debugged conjecture disprover need lemma missed counterexample invalid conjecture hand never buggy true conjecture difficult formally checked conjecture disprover correction conjecture invalid talus debugs student code minimally altering student code conjecture talus student stored specification correction debugging enforcing verification student stored atom true talus student code replacing student code fragment case stored code fragment debugged code defun flat atom flat flat debugged comparing stored normalized defun nlistp talus generates conjecture student stored logically nlistp nlistp list nlistp list nlistp conjecture last indicating talus corrects defun listp list remaining memtr omitted illustrated debugging combine heuristic formal heuristic used merely enhance fundamentally inexact difficult formally robust presence conjecture formally tested formal equally talus relying fixed rewrite rule establish computationally full prover capable inductive brought bear equivalence established implication heuristic formal talus variability student automatic robust debugging debugging skill intelligent tutoring system teach acknowledgement elaine rich bruce porter mark miller miller invaluable assistance presentation
