describing inverse upon taking pure lisp automatically deriving computes inverse differs heuristic invert conditionals many inverse find feeding ming specification like root supplying inversion debugging erroneous like step backwards trace transforming domain well multiplying back domain need find inverse transformation suggested inver sion unfortunately suffer defect mccarthy suggests test find inverse computationally infeasible inverse dijkstra inverting symbolically inductive assertion loop korf suggests automatically assertion recursion derived guaranteed well founded gone inverting prolog differs inverting prolog procedural declarative inverting procedural thus also prolog reverse necessarily true suggests assertion automatically heuristic find inverse terminate inverse case inverse inverted maclisp able derive inverse append reverse unary negation recursively unary negation case korf unable find inverse existence recursive clause inversion usual inverse unfortunately lend well inversion lisp true thus intuitively think inverse call hand extend also converse hold thus true taking inversion inverts list inverts list simultaneously hold inverse also simultaneously hold note relationship symmetric inverting inverse list list turn dummy need attempting invert need inverse primitive operation inverting lisp fact inverts inverts used arithmetic list manipulation lisp eppstein inversion inversion fact composed left side side precondition fact precondition hold left side side four operator move precondition inversion contraction want invert append want find call append unfortunately many pair produced append thus need auxiliary distinguish ignores call flength call append name irstn lastbutn give append cond null firstn lastbutn firstn append firstn lastbutn flength cond null firstn flength firstn lastbutn atom left side correspond call side correspond call unbound fact precondition left side atomic goal precondition empty side atomic atom introduced transformation atom side fact thus name inverse name inverse fact precondition side transformation fact part precondition operator replaces fact side fact case true case false applying fact note four fact precondition null firstn null firstn precondition combined merely sake brevity final inverse need path took think precondition like replace inverse true exactly heuristic inversion many precondition seems analytic find precondition case zero null precondition precondition operator note simply replaced occurrence precondition derive useless fact derivation taking come transformed derivation inversion pulling side fact left process mechanical complicated step time call addl call side fact invert call subl case inverted fact invert fact inversion done knew inverse must also invert recursive call recursive call inverse case replace fact fact inversion step fact part fact note also call match exactly recursive call made impossible inversion inversion side atomic made atomic inversion cone goal remaining task remove precondition achieved contraction operator inversely take fact opposite precondition identical side combine fact left side evaluating left side precondition true must careful accept precondition term inverse come precondition contraction goal precondition framework inversion also need heuristic used framework precondition heuristic many recursion sort data type system type divided data type system type major subset zero pair main type system form lattice thus also need type bottom belongs type thus anything type type mapping type type simplicity actually done addl subl addl list inverted list inverse used inversion calculate type relaxation process type bottom evaluating type defining type arrive assignment type iterate type iteration iteration type zero base clause bottom recursive clause combine type zero iteration give base clause type recursive clause type zero iteration type thus final type eppstein complicated recursion preliminary type recursive clause type many iteration type lattice type system precondition done looking fact identical left side identical precondition precondition wish replace true fact false calculate type side fact intersection type bottom replace precondition test membership left side type thus append zero fact precondition true zero false work main obstacle inversion inability heuristic find precondition fruitful heuristic inverted arithmetic list processing tailor accordingly inversion append auxiliary append recurs linearly simply recursive call sufficient work done automatic need auxiliary automatic need detected thought transformation gone idea system operator used domain inversion applicable transformation system incorporated system acknowledgement like thank advisor rich korf many helpful suggestion sponsored part foundation student fellowship defense agency
