system system abductive reasoning framework abductive computational abductive term tightly coupled process reduction process highlevel process demonstrate versatility stemming declarative good computational behaviour system declarative incremental modular refinement extra domain scale computational framework last clear abduction play central role addressing artificial intelligence diagnosis poole console planning missiaen kakas shanahan assimilation belief revision inoue sakama pagnucco coordination ciampolini kowalski sadri intensive learning muggleton mooney essential feature abductive fact formalized declarative close link emerges declarative reasoning abduction despite abduction benefit easy system abduction computationally practical size system abductive reasoning framework abductive kakas denecker kakas framework declarative rule classical sentence work examine possibility developing declarative framework suitable computationally viable practical scale principled computational formalizes abductive term interleaving process reduction abductive linked tightly construction validate approachwe carried system test computational behaviour domain flexibility framework incorporate modular computationally enhancing test extend computationally extra domain satisfaction planning system competition follow system aclp system kakas sldnfac denecker schreye bringing feature system main system fact abductive computation made explicit possibility form parameterized heuristic coupled process deterministic propagation computation declarative abduction declarative hand closely abduction stem fact declarative describes domain task filling missing informationfrom pertaining goal hand framework incompletely specified describingthe problemis goal satisfied computing representing abductive task abduction assumes data carrier term framework abduction need expressing declarative missing incomplete time framework practical improving computational effectiveness framework combine representational expressiveness computational flexibility abductiveconstraint aclp framework integrates abductive framework briefly review framework formalize view case denecker extending classical inductive consisting disjoint type open abducible abductive triple dicates appearing head rule ground abducible atom open abductive view term part rule represents definitional determines term open rule represents case head true exhaustive enumeration case open abducible indirectly weaker assertional enumerates missing open abductive build giving ground open abductive finite domain also equality term formal scope abductive task abductive consisting literal abductivesolution explanation ground abducible atom answer substitution consistent generic defines abductivesolution term givensemantics semantics defines entailment abductive inductive semantics coincides semantics gelder valued rest adopting semantics abductive give ground open turn extends abductive give part representing planning domain open defining finite domain problemwhere truck fact form abductive computation abductive seen process reduction abducible hypothesis open finite domain framework computation reduction hypothesis also reduction effectively abductive hypothesis made need remain true satisfaction possibly goal used reduction next subsection merely passive evaluated reduction used actively reduction affect enables reduction pruned early remains satisfiable abductive inference reduction derivation rewriting process give brief formal computational restriction form abductive imposed sentence must transformed classically sentence form literal also denial goal also simplify presentation rule form implicitly versally quantified referred free literal free occurring head occurring body rule homogeneous form term head rule equivalently derivation type literal possibly free goal denial goal form literal free abducible atom goal atom open atom derivation consisting literal goal denial goal rewriting derivation proceeds selecting literal goal applying suitable inference rule yielding main inference rule rewrite rule separated rule open rule open abduced atom atom universally quantified atom universally quantified universally quantified successful derivation terminates goal form abducible atom atom goal denial containing open atom resolved abduced atom satisfiable derivation flounder universally quantified literal denial derivation succeed flounder fails note negation failure simply rule denial atom final successful derivation substitution assigns ground term free satisfies substitution substitution satisfiable successful derivation abductive final successful derivation substitution pair abductive abductive abductive closely puted abducible hypothesis made computation atom restricted computation play central role carrying abducibles also controlling abductive many computation viewed process constructinga fromthe abductive take abducible extends differently turn around guide make abductive abductive computation deterministic propagation goal suspend goal goal goal exit ground computation phase deterministic propagation goal rewriting goal left resulting computation phase expose collect computationand propagate construction necessarily imposed made iteration step checked satisfiability phase grows computation enables early ensuing failure made committing exposed deterministic phase suspended process explicit handling computation parameterized form heuristic type heuristic used type computation rule rewriting goal rewrite rule denial last rewrite rule type phase denial goal subsidiary phase deterministic propagation ensuing criterion tightness finite domain form heuristic criterion criterion concern goal preferring goal deterministic abducibles denial form possibility exploring phase computation examines left suspended namely goal form heuristic amongst possibility computation repeat process lead goal terminates successfully labeling thus grounding abductive many informed leading backtracking thus computational also facilitates heuristic helping parameterize make parameter computation degree examined satisfiability construction possibility full whole grows costly part maybe unnecessary hand incomplete late inconsistency possibility localizing latest induces form dynamic reflects extend hand help minimize computation satisfiability carried test computational behaviour affected extending system sicstus finite domain experimentation tool test datastructures form indexing abducibles used datastructures parameter abductivesearch form heuristic used checking satisfiability construction specification finite domain phase reduction satisfaction graph coloring scheduling confirm deterministic time overhead cost reduction show sample graph coloring graph coloring planar graph constructed time time find abductive time ground labeling reported done linux machine memory size abductive grounding graph coloring size node abductive grounding reduction whole specification done step backtracking abductive construction time abductive clearly size metainterpreter slower prolog used carried planning abductive computation tested latest planning competition domain block logistics next show system block domain used specification move moving block onto time planlength time domain logistics domain specification functors calculus used futhermore specification layered compact high logistics domain aips strip derived high show system used plan plan final time goal achieved column abduced describing plan blank system unable find time plan plan separated phase high plan step expands high plan time high time time time took finite domain incomplete branch unsatisfiable marked tried satisfiability none successful parameter domain size last column high plan decreasing maximal numberof time satisfiability checkfails insatisfiable consequence reasonable time investigating satisfiablity sldnfac aclp reliable robust incomplete derivation failing find main system separation inference easy experimentation degree deterministic propagation work conclusion abductive system used bottom computation iwayama satoh tabling alferes andrewritingrules fung kowalski kowalski system aclp system sldnfac ourknowledgethe abductive system paid computational abduction extensively control abductive enhance computational behaviour work answer gelfond lifschitz connection established satoh iwayama semantics framework admits type computation construction abductive corresponds respective computational instructive systematic system declarative abductive parametrized reflect type cooperation heuristic used system parametric heuristic incorporated computational behaviour framework heuristic planning bonet geffner abductive computation improvementof underlyingcomputational framework declarative framework clearly aiming framework complementaryline developmentof framework concern providea programmingenvironmentwhere user incrementally refine problemin modular declarative abduction emerging modeling possibility extra declarative control enhance computational alferes alferes pereira swift abduction tabled dual proceeding bonet geffner bonet geffner planning heuristic proc european planning ciampolini ciampolini lamma mello torroni abductive agent lnai console console portinale theseider dupre compiled guide abductive diagnosis ieee transaction data denecker kakas denecker kakas abductive denecker schreye denecker schreye sldnfa abductive procedure abductive denecker denecker extending classical inductive proceeding fung kowalski fung kowalski procedure abductive gelder gelder ross schlipf gelfond lifschitz gelfond lifschitz classical negation disjunctive database computing inoue sakama inoueand sakama abductive framework nonmonotonic proceeding page iwayama satoh iwayamaand satoh computing abduction expectation kakas kakas kowalski toni role abductionin gabbay hogger robinson handbook volume page oxford kakas kakas michael mourlas aclp abductive abductive kowalski sadri kowalski sadri system annals mathemathics artificial intelligence kowalski kowalski toni wetzel suspended fundamenta informaticae missiaen missiaen denecker bruynooghe chica abductive planning system calculus computation mooney mooney integrating abduction induction machine learning abduction induction essay integration page kluwer academic muggleton muggleton learning inductive pagnucco pagnucco role abductive reasoning process belief revision thesis dept sydney poole poole goebel aleliunas theorist reasoning system default diagnosis frontier essay page satoh iwayama satoh iwayama computing abduction proc page shanahan shanahan abductiveevent calculus planner comparative preference torsten kewen wang institut informatik universit potsdam postfach potsdam germany torsten kewen interested semantical underpinnings preference handling framework answer explore literature formal mean furnish series characterization gain insight relationship precise characterization term fixpoints preservation translation former semantics preference latter furnishes numerous preference literature systematic structural leading solid semantical underpinnings address shortcoming comparative distinguished preference handling selective remaining answer semantics selective insofar preference distinguish explore literature namely brewka eiter delgrande wang investigation adopts characterization literature shed relationship characterization term fixpoints preservation translation former semantics preference latter furnishes perspective view axiomatization regarded construction process view semantical characterization tell respective preference handling also view investigation preference handling remain excludes like rintanen step outside reasoning applies also sakama inoue preference literal investigated gelfond remains advocate addressed framework baader hollunder brewka originally default familiarity answer semantics gelfond lifschitz finite rule form literal atom negation literal rule head head body body body body rule reduct rule head reduct relative literal body literal closed head logically closed consistent literal negation smallest literal logically closed closed literal answer deal consistent answer generating rule answer body gelder note operator operator monotonic fixpoint alternating fixpoint semantics captured distinguishing fixpoints statically ordered pair irreflexive transitive priority preferred alternating fixpoints answer preference reduction default negation reduction inapplicable addressing conflict mean preference conflict rule simultaneously resolved turning conflict resolution must characterized rule blockage rule body body eliminated head body hold case pursued wang characterizing preferred answer default baader hollunder brewka activeness literal ordered rule pair body wang ordered literal head rule head consistent idea rule settled rule prerequisite never derivable defeated derived body rule head head operator accordingly alternating transformation fixpoint alternating fixpoint note monotonic analogy gelder semantical framework ordered term alternating fixpoints type semantics investigated wang answer alternating fixpoints also fixpoints preferred regular maximal alternating fixpoints preferred alternating fixpoint prefix distinction illustration ordered baader hollunder observe admits answer argued baader hollunder answer observe note preferred compiling preservation translation ordered delgrande used ensures resulting admits answer statically ordered answer enumeration head body head make property explicit answer grounded rule sequel property weakened preference stipulates hriiii compatible property lastly comparable rule never blocked rule answer grounded grounded generating namely violates translation integrates ordering also treating ordering dynamic fashion propositional said dynamically ordered pairwise disjoint term serving name rule propositional atom preference atom name bijective assigning rule name simplify sometimes abbreviate statically ordered asserting thus captured containing preference atom fact expressed want sense answer rule defeated ahead done rule rule need able rule rule defeated rule case literal answer literal body answer detecting blockage rule atom introduced atom introduced case rule controlling rule atom introduced informally concludes rule rule rule case blocked formally dynamically ordered pairwise distinct propositional atom translation ordered delgrande dynamically ordered trules wherer rbody head body dynamically ordered capturing four rule applicability blocking rule rule encodes handling preference rule quantifies rule dealing dynamic preference preference vary answer rule pairwise dependency rule view preference ordering pair rule derive fails hold true derive indicating potentially note many dealing preference obtainable changing specification delgrande literal answer answer sequel refer answer synthesis last exposed characterizing preferred answer despite characterization turn prefer answer characterizing fixpoint bijective mapping rule rule head rule rule head accordingly rule head mapping bijective distinguishing occurrence literal statically ordered literal head rule rule consistent manifest higherranked rule effectively presence head rule matter supplied rule nicely illustrated answer answer replacing alternative characterization answer statically ordered consistent literal answer answer last dealt answer next show applying operator gelder operator statically ordered consistent literal thatfor literal translation semantics appeal alternating fixpoint idea characterizing showing characterized term preservation statically ordered answer enumeration head head head body head head head preservation clearly weaker groundedness rule well rest answer rule note satisfies neither complement dealt interestingly weaker groundedness integrated translation last prerequisite head eliminate rule preference handling process head derived showing implementable system statically ordered consistent literal answer answer analogy stronger opening avenue semantics statically ordered consistent literal literal brewka eiter preference preference brewka eiter brevity omit simply answer reader referred brewka eiter differs construction answer separated verifying preference interestingly verification done evaluating rule separately constructed answer rule putatively lead removed inference process made explicit brewka eiter filtering transformation head body answer answer distinguishing answer former neither dpreferred also note answer shed fixpoint characterization ordered literal head thatr andr rule head consistent predecessor manifest activeness tested fact unprovability prerequisite rule make construction answer break avoided answer tested replacing captured mean preservation statically ordered answer enumeration body head head differs predecessor drop groundedness expressed corresponds groundedness disconnected preservation fact observe answer answer grounded relaxed rule head opposed also integrates illustration answer rule handled weaker counterpart statically ordered consistent answer answer delgrande answer last stipulates must answer dropped case case rely property relationship tried clarify structural respective homogeneous characterization examined insight relationship observe treat blockage rule rule blocked prerequisite never derivable body derived unrelated rule reflected identity arguably sensible lead loss preferred answer like read manifest lead relationship answer show converse hold interestingly relationship wand fact weakening dropping weakening thus answer show converse hold summarizing letting statically ordered hierarchy induced decreasing groundedness preference dpreference full compatibility weakened abandoned nicely reflected evolution notably groundedness ultimate distinguishing demonstrated fact prerequisitefree necessarily lead preferred answer witnessed degree groundedness preference make conclusion preference seems pervasive come reflected numerous enhancing preference despite little paid structural sameness leading solid semantical underpinnings work step systematic preference elaborated upon originally heterogenous alternative characterizing preferred answer term fixpoints preservation axiomatic uniformity deeper answer preferred clarification relationship subtle revealed investigated yield answer tight preference groundedness equivalence fixpoint operator operator correspondingly transformed open avenue preference handling alternating fixpoint issuing semantics dynamic preference semantics unifying acknowledgement work grant baader hollunder baader hollunder prefer default terminological default proc brewka eiter brewka eiter preferred answer artificial intelligence brewka eiter brewka eiter prioritizing default holldobler intellectics computational kluwer brewka brewka priority specificity default pereira pearce proc springer delgrande delgrande schaub tompits compiled preference proc ecai gelfond lifschitz gelfond lifschitz classical negation deductive database computing gelfond gelfond reasoning prioritized default pereira przymusinski springer rintanen rintanen specificity default proc morgan kaufmann sakama inoue sakama inoue representing priority maher proc gelder gelder alternating fixpoint negation system wang wang zhou alternating fixpoint priority proc conf computational springer answer prioritized maluszynski proc reasoning infinite stable piero bonatti tecnologie milano crema italy bonatti tool nonmonotonic reasoning handle finite domain normal finitary domain infinite credulous skeptical entailment stable semantics computable finitary characterized dependency computationally simulate arbitrary turing machine compactness defining finitary sense automated nonmonotonic reasoning finitary propositional firstorder finite propositional decidable consequence recursively enumerable computationally missing automated reasoning nonmonotonic focussed finite propositional formalism reasoning recursive data infinite domain list tree time lost limitation reasoning time emerging base base fragment nonmonotonic case circumscription expressed finite missing default autoepistemic normal stable semantics regarded fragment finitary open default autoepistemic reasoning infinite domain main feature finitary domain infinite nontheless credulous skeptical reasoning ground decidable form compactness hold finitary computationally turing machine simulated finitary finitary dependency graph sense dropped compactness guaranteed anymore preliminary characterize subprogram ground finitary property expressiveness completeness skeptical resolution calculus introduced bonatti originally formulated finitary thereof finitary brief sketch credulous reasoner finitary work omitted limitation preliminary reader familiar classical lloyd normal hereafter simply rule form atom literal usual head body rule mean occurrence ground instantiation transformation herbrand usual ground atom removing rule containing literal removing remaining rule literal stable herbrand credulously resp skeptically entailed satisfied resp stable dependency graph labelled directed graph vertex ground atom edge rule head occurrence body edge labelled scope atom positively resp negatively directed path dependency graph even resp negativeedges callconsistent atom negatively oddcycle mean dependency graph edge coincides absence stable dung normal splitting lifschitz turner atom containing atom occurring body rule head rule head bottom remove rule containing atom false remove remaining rule containing normal lifschitz turner splitting splitting normal stable stable relevant subprogram investigate decidability undecidability strict subset suffices decide credulous skeptical entailment intuitively inference rule affecting inconsistency form instability goal relevant universe subprogram relevant universe ground ground atom dependency graph path atom occurring graph relevant subprogram ground rule head belongs consisting rule note rule head belongs also atom belong next splitting coincides proved lemma ground stable stable part stable splitting splitting lifschitz turner stable stable atom stable part stable atom occurring oddcycle belong consequently dependency graph wellknown dung stable splitting stable ground credulously entail skeptically entail credulously entail stable lemma stable atom occurring must truth consequence credulously entail conversely credulously entail stable lemma stable must agree valuation part mean credulously entail completes demonstrate skeptically entail skeptically entail credulously entail credulously entail finitary consequence recursively enumerable domain infinite finitary finitary hold node dependency graph node positively negatively finite finite node dependency graph classical recursive data list tree append reverse term occurring body rule also head strict subterms head property clearly entail satisfied used embedding cholewinski eiter gottlob gottlob formulated involving atom rule elsewhere used false rest finitary illustrated credulously entail ground goal encodes satisfiable rule finitary skeptically entailed encoded consequence encoded straightforwardly finitary computability finitary ground goal finite compactness classical infinite inconsistent inconsistent finite subset nonmonotonic enjoyed finitary unstable kernel subset property downward closed atom occurring rule head stable compactness finitary stable finite unstable kernel ground atom lemma followsthat stable stable clearly downward closed finite stable finite unstable kernel decidability inference hereafter inference finitary subsection deal ground goal credulous skeptical inference decidable finitary ground goal deciding credulous consequence deciding skeptical consequence decidable credulous resp skeptical consequence credulous resp skeptical consequence finite stable finite time inference decidable existentially quantified goal semidecidable finitary goal deciding credulous consequence deciding skeptical consequence credulously skeptically entailed grounding substitution credulously skeptically entailed latter decidable grounding recursively enumerated existential entailment potentially infinite recursive decidable test terminates entailed strict existential entailment undecidable minimality expressiveness next inference finitary relaxation thereof next show sense credulous skeptical inference satisfying note locally stratified trivially violate locally stratified credulous skeptical inference coincide semantics gelfond lifschitz schlipf finitary decide turing machine terminates fixed tape arbitrary turing machine vocabulary recall overwritten next specifies head reader entailed finite computation configuration tape finite tape list representing finite tape left head reverse reversed finite tape head satisfies note recursive call preserve tape encoded head ground atom atom directed path dependency graph next dropped inference anymore precisely inference deciding termination arbitrary turing machine turing machine tape goal recursively constructed satisfies skeptically entail terminates sketch consist plus rule represents blank satisfies violated infinitely many ground atom clearly grounding substitution goal derived subprogram clause blanklist terminates time stable goal derived containing consisting propositional occurring skeptically entail terminates turing machine tape goal recursively constructed satisfies credulously entail terminates propositional occurring clearly credulously entail stable stable terminates next modification keep track computation modified extra final tape prof finitary computationally showing turing machine simulated suitable finitary turing machine tape finitary goal recursively constructed grounding substitution terminates encodes final tape computation deciding finitary entail existentially quantified goal decidable resolution calculus resolution calculus skeptical stable semantics introduced bonatti resolution calculus proved soundness hold extend completeness finitary finitary ground skeptical consequence literal skeptical goal successful skeptical derivation answer substitution tuple deciding termination turing machine tape ground skeptical consequence also skeptical consequence finite completeness bonatti ground skeptical derivation lifting lloyd skeptical derivation answer substitution finitary stable rule show successful skeptical derivation skeptical conclusion empty answer substitution mean skeptical consequence restricted type introduces subgoals hypothesis atom occurring contradiction rule replaces side goal negation hypothesis intuitively goal proved showing hypothesis hand side satisfied failure rule rewrite goal negating resolution rule hypothesis treated fact success rule removesgoals nothing left usual empty goal help resolution calculus normal finitary turing kind rule used inconsistency restriction finitary normal finitary partitioned disjoint subset finitary rule form note restriction rule ground rule depend infinitely many ground atom violated skeptical resolution calculus sense finitary skeptical consequence form literal finitary finitary ground credulous inference mean skeptical inference finitary credulous inference resolution calculus credulous automated reasoner powerful automated reasoner upon stable smodels niemela simon eiter internally engine operate ground embody smart instantiation routine routine form reasoning seems difficult extend instantiation routine deal finitary ground goal relevant ground finite subprogram subset thereof rest engine need modification soundness completeness preserved used extend applicability automated reasoner modification core reasoning work time fragment stable semantics explored atom main contribution summarized recalling finitary computationally deal enjoy compactness inference finitary characterized dependency graph sense dropped inference semidecidable proved skeptical resolution calculus finitary finitary sketched engine nonmonotonic reasoning deal finitary extending stable work finitary contributes nonmonotonic classical engine deal ground smart instantiation routine remove rule noted referee idea reduce cost instantiation latter idea evidence feasibility suggested referee goal restricted type contradiction rule failure rule resolution hypothesis success rule contradiction rule resolution resolution hypothesis success rule skeptical derivation theoretic tool work comprises pretty axiomatizations hilbertstyle system levesque sequent calculus olivetti bonatti olivetti axiomatizations default autoepistemic firstorder perhaps adapting introduced infinitary milnikel rosati decidable nomonotonic reasoning mknf investigated cenzer sufficient existence recursively enumerable stable identified stable skeptical credulous reasoning acknowledgment grateful referee deep careful review precious suggestion bonatti olivetti bonatti olivetti sequent calculus skeptical default proceeding lnai page springer verlag bonatti bonatti resolution skeptical stable semantics automated reasoning preliminary cenzer cenzer remmel vanderbilt locally proc lnai page berlin springer verlag cholewinski cholewinski marek mikitiuk truszczynski experimenting nonmonotonic reasoning proc furbach nerode proc lnai berlin springer verlag dung dung stable semantics eiter gottlob eiter gottlob disjunctive nonmonotonic proc eiter eiter leone mateis pfeifer scarcello deductive system nonmonotonic reasoning gelfond lifschitz gelfond lifschitz stable semantics proc iclp page gottlob gottlob nonmonotonic computation levesque levesque know autoepistemic artificial intelligence lifschitz turner lifschitz turner splitting proc page lifschitz lifschitz computing circumscription proceeding page lloyd lloyd foundation milnikel milnikel nonomonotonic monotonic thesis cornell niemela simon niemela simon smodels stable wellfounded semantics normal olivetti olivetti tableau sequent calculus entailment automated reasoning rosati rosati nonmonotonic reasoning proc lnai page berlin springer verlag schlipf schlipf expressive semantics proc proving proving splitting backtracking alexandre riazanov andrei voronkov manchester integrating splitting rule prover highly beneficial splitting proving explicit case employ backtracking difficult affect whole system cheap splitting backtracking case form core tableaubased proving refute clause reduce task refuting simpler justified show false separately case necessarily satisfying satisfying saturation proving adopted case form splitting formulated propositional case inference rule clause clause inference rule proving modify clause removing clause rule make clause refute must separately refute propositional case rule unit resolution give inference system refutation system organised exploring branch refutation partially grant epsrc faculty manchester also partially award splitting branch procedure backtracks proceeds branch call procedure explicit case propositional derivation combine splitting rule resolution branch depicted tree node clause branch clause clause inference rule shaded moment ignore label edge case splitting rule formulated propositional case restriction clause rule combined inference rule like resolution paramodulation combined resolution give procedure fragment fermuller cost naive backtracking high clause thousand clause memory backtrack practice prover weidenbach explicit case clause history used clause history also help intelligent backtracking analyzing history actually used contradiction belong exploited branch waiting list popped back waiting list upon backtracking complication caused simplification unit equality belonging branch illustrated left picture derivation splitting unit resolution simplification used clause occurrence left branch clause simplified replaced left branch clause branch mean kept branch simplification side picture provers maintain term literal clause splitting maintainance retrieval branch else branch former case retrieval take splitting history latter case maintainance case work upon backtracking backtracking provers nontrivial provers splitting backtracking weidenbach alternative explicit case provers overhead call splitting backtracking idea splitting backtracking formulated mark branch tree literal take propositional mark left branch branch propositional dealing branch simply clause branch label used branch inference rule replaces clause clause hard argue splitting preserve unsatisfiability clause formally splitting explicit case branch dealing clause simplification left branch corresponds simplification prefer give simpler clause show splitting backtracking simulate sense explicit case simulate parallel case branch exploited simultaneously easy splitting backtracking firstly intelligent backtracking free secondly simplification rule move clause branch thus avoiding repeated work branch also recall resolution splitting rule namely binary hyper splitting naming show simulate splitting literal show simulate explicit case blocking maximal clause full clause variance checking clause variant clause show clause variant graph isomorphism carried vampire collection preliminary fixed countable arity disjoint used name clause alternatively identifier branch call clause literal sometimes clause disjunction literal occurring clause clause universal closure clause clause nonempty proper subset trivial clause empty note clause subset consisting literal clause trivial trivial maximal note maximal subclause literal also obvious maximal clause resolution splitting work saturation procedure calculus ordered resolution recall nonground ordered resolution rule rule calculus bachmair ganzinger simplification term usual literal nonempty clause literal subset literal literal maximal literal ordered resolution rule unifier atom clause literal clause literal used simplification ordering splitting backtracking formulate splitting backtracking soundness binary splitting binary splitting rule clause clause nontrivial atom occurring binary splitting rule inference rule also binary splitting binary splitting rule preserve satisfiability also consequence reverse redefining introduced binary splitting rule regarded name optimization binary splitting reuse name optimization formalized binary splitting naming naming nonempty clause property variant clause clause nontrivial also naming binary splitting rule naming inference rule also modification binary splitting rule naming splitting introduces clause splitting simply replace clause give illustrates binary splittings naming clause nontrivial binary splitting derivation binary splitting naming derivation preservation satisfiability case binary splitting naming difficult formulate preservation satisfiability natural inference system clause property inference preserve inference system binary splitting naming derivation clause satisfiable repeat take arguing show converse note consequence applying inference system hold applying binary splitting naming also obvious clause note adapted modified splitting modified true clause show consequence inference system natural restrictive completeness resolution bachmair ganzinger inference system kind rule clause implied clause removal clause implied clause easy inference system preserve hyper splitting rule binary splitting hyper splitting clause hyper splitting rule clause clause nontrivial occurring neither clause hyper splitting rule inference rule also naming hyper splitting rule naming inference rule hyper splitting repeatedly binary splitting hyper splitting naming preserve satisfiability exactly binary splitting literal simulation explicit case splitting inference rule splitting part inference system inference system binary resolution superposition simplification ordering literal atom inference system clause kind blocking parallel extending arbitrary clause clause blocking blocking clause blocking clause clause containing literal maximal literal clause containing literal literal literal maximal literal note case solely literal difficult literal literal clause simply speak blocking blocking blocking also time splitting rule newly introduced atom atom previously introduced splitting show resulting inference system simulates extent explicit case nonsimplifying inference rule call label branch literal mark edge branch transform clause used derivation splitting clause branch label branch obtaining clause show nonsimplifying inference branch also transformed clause simplicity resolution rule clause unifier literal resolution inference label branch transformed clause blocking hard argue transformed clause literal rule hard argue label branch observe happens literal belong investigated branch simplicity leftmost branch labelled clause branch literal take clause inference rule clause resolution clause literal clause empty clause leftmost branch labelled blocked inference contradiction leftmost branch soon contradiction unblock clause resolving obtaining thus nearly correspondence explicit case system binary splitting backtracking correspondence firstly simplification rule behave slightly secondly done splitting backtracking belong branch branch show derivation binary splitting blocking corresponds derivation preserve enumeration inference literal front clause mean simplicity remove subsumed clause pure literal inference derivation explicit case copy clause branch clause left branch derivation binary splitting remains even finish left branch parallel parallel clause parallel clause clause form clause clause empty selects exactly literal selects empty maximal literal word parallel make clause ignoring literal difficult literal literal simply speak parallel parallel parallel ignores splitting history clause thus give parallel branch subsumption resolution splitting serious splitting backtracking productively combined simplification rule subsumption resolution bachmair ganzinger subsumption resolution case binary resolution resolvent subsumes parent clause subsumes clause substitution clause subsumed clause removed subsumption resolution inference rule clause substitution rule subsumption resolution resemblance subsumption rule applicable subsumes thus subsumption modified pair clause subsumption resolution applicable subsumption resolution simplification rule clause replaced clause independently literal subsumption resolution combined splitting give literal moved branch clause derivation binary splitting blocking subsumes explicit case clause belong branch left branch splitting branch subsumption resolution replace clause corresponds moving branch subsumption resolution even stronger variant coincides clause subsumption resolution followed subsumption replaced noting belongs branch putting save resource explicit case splitting backtracking repeat inference branch show subsumption resolution splitting case give condensing clause condensing joyner clause said clause condensing proper subset subsumes clause disjoint variant clause clause condensed binary splitting replace clause clause subsumption resolution clause yield clause subsumes clause thus binary splitting subsumption resolution give condensing splitting naming splitting naming variant provethat checking clause variant graph isomorphism clause variance clause variance pair clause answer variant clause variance polynomialtime graph isomorphism full practice variant vampire clause variance code tree indexing voronkov riazanov voronkov code tree used forward subsumption hard modify clause variance splitting backtracking vampire riazanov voronkov nonunit clause form come tptp sutcliffe suttner list reuse schumann fischer equality equality splitting backtracking branch rewriting rule replaces clause clause clause simplification rule simplification unit equality splitting branch explicit case procedure viewpoint cheap rewriting note branch rewriting hour equality separately used resource riazanov voronkov experimentally proved superior splitting used vampire splitting used parameter hyper splitting parallel binary splitting equality equality naming naming branch rewriting branch rewriting letter used mean parallel branch rewriting naming used splitting splitting binary splitting blocking used intel processor used time minute splitting solves splitting splitting vampire splitting equality equality show comparative parameter equality pair labelled column labelled mean naming branch rewriting equality parallel naming equality conclusion derived equality vampire splitting weaker vampire splitting equality stronger naming parallel splitting branch rewriting strongest naming believe splitting backtracking considerably optimized insight splitting bachmair ganzinger bachmair ganzinger resolution proving robinson voronkov handbook automated reasoning volume page elsevier fermuller fermuller leitsch hustadt tammet resolution procedure robinson voronkov handbook automated reasoning volume page elsevier joyner william joyner resolution procedure july riazanov voronkov riazanov voronkov resource resolution proving preprint manchester october riazanov voronkov riazanov voronkov partially adaptive code tree guzman brewka pereira artificial intelligence european jelia volume lecture note artificial intelligence page malaga spain springer verlag riazanov voronkov riazanov voronkov vampire system siena italy june ijcar schumann fischer schumann fischer retrieval practical proc automated page lake tahoe november ieee sutcliffe suttner sutcliffe suttner tptp release automated reasoning voronkov voronkov anatomy vampire procedure code tree automated reasoning weidenbach weidenbach afshordel brahm cohrs engel keen theobalt system ganzinger automated automated deduction volume lecture note artificial intelligence page trento italy july unsearchmo eliminating redundant backtracking forward chaining proving lifeng faculty aichi prefectural aichi japan introduces eliminate redundant forward chaining proving much keep consequent atom branch tree case unnecessary clause used forward chaining invoking unnecessary forward chaining clause nearly linear exponential anymore sense unsearch show powerful forward chaining proving automated reasoning artificial intelligence proving calculus attracting much robinson loveland manthey unsatisfiable subset clause show unsatisfiable show unsatisfiable obviously shorter forward chaining used reasoning clause mean need violated clause help find refutation obvious invoking unnecessary clause explode exponentially satchmo satisfiability checking manthey potentially inefficient violated clause forward chaining addressing utilizing intelligent relevantlike clause forward chaining ramsay refined loveland satchmore work partially japanese ministry education sport culture artificial intelligence promotion foundation japan eliminating redundant searching unnecessary clause used forward chaining intelligent backtracking indicated mainly suitable clause forward chaining take much overhead cost decide clause suitable stricter checking overhead cost certainly fails complicated case fact clause recognized relevant selecting practically unnecessary refutation made word irrelevant clause relevancy test illustrated eliminating redundant searching intelligent backtracking consequent atom forward chaining clause used forward chaining useless reasoning backtracking clause unnecessary remaining processing clause consequence abandoned take little overhead cost find irrelevant clause compatible former introduced marking consequent atom contributed derive antecendents irrelevant forward chaining clause mixing consequent atom branch tree make redudant introduces node tree indispensable consequent atom derive refutation node marked thus show refutation unsatisfiable clause unsearching acronym unsearchmo word forward chaining proving satchmo familiarity relating satchmo manthey satchmore loveland well briefly reviewing presentation checking unsatisfiability mean implicational clause form refer implicit antecedent clause antecedent atom implicit disjunction referred consequent clause consequent atom clause empty consequent clause mean false clause empty antecedent consequent part fact horn clause antecedent atom true clause divided subset backward chaining decidable horn clause consisting clause fact horn clause user forward chaining remaining clause goal atom proven logically follow clause hand ground atom ground atom atom utilizes forward chaining clause satchmo clause must hold rangerestricted soundness refutation decidable horn clause ground atom disjunction ground atom satisfiable derived else unsatisfiable ground clause said satisfiable satisfiable unsatisfiable else violated clause satisfiable find clause satisfiable consideration clause satisfiable satchmo construct clause trying clause reasoning made satchmo clause graphically illustrated tree abbreviated hereafter node initially root node ground consequent atom initially empty leaf node node process branch terminates instantiated ground violated clause clause process terminates satisfiable tree constructed satchmo consequent atom violated clause child node node taking node node call procedure recursively augmented ground consequent atom node ground consequent atom branch terminate leaf node mean satisfying atom lead refutation anyway word node said unsatisfiable node root node unsatisfiable creating node atom asserted reasoning database hand node proven unsatisfiable atom retracted database node proven unsatisfiable reasoning process backtrack parent node propositional clause tree satchmo obvious satchmo made redundant fact refutation derived subset consisting clause clause violated clause used satchmo recognized relevant satchmore tree satchmore redundant intelligent backtracking seen consequent atom retracted reasoning database node tree proven unsatisfiable violated clause used forward chaining node tree node hold child node consequent atom useless reasoning time retracted database node proven unsatisfiable useless construct tree node tree constructed node deriving tree goal node know node proven unsatisfiable made node unsatisfiable remaining process showing node unsatisfiable process consequent atom removed hand clause constructing tree node decide consequent atom reasoning obviously consequent atom asserted used derive goal antecedent violated clause mark asserted consequent atom contributed derive goal antecedent violated clause consequent atom derive goal deriving tree goal give clause consequent atom established forward chaining goal deriving tree goal tree constructed root node node tree constructed clause unifier child node atom ground substitution ground atom child node repeat procedure recursively empty leaf leaf atom hold derived leaf successful deriving leaf decidable constructed successful deriving leaf consequent atom contributed derive atom listed successful deriving leaf clause leftmost node deriving tree goal derive goal construct checking clause unsatisfiable node initially root node consequent atom initially empty leaf node node mean node proven unsatisfiable mark consequent atom listed successful deriving node instantiated ground violated clause clause process terminates unsatisfiable violated clause mark consequent atom listed successful deriving node node node taking node call procedure recursively augmented consequent atom useless backtracking node leaf node mean process pruned away hand marked case node proven unsatisfiable clause branch atom used forward chaining marked branch atom used forward chaining marked proven unsatisfiable parent node proven unsatisfiable backtrack node retract time know marked reasoning useless reasoning violated clause node unnecessary prune away process made remaining consequent atom backtracks node know also marked reasoning violated clause root node unnecessary accordingly stop process remaining consequent atom tree constructed unnecessary clause unsearchmo mark asserted consequent atom contributes derive thea antecendent violated clause consequent atom contributed unnecessary violated clause also marked improving marking work asserted consequent atom marked contributes derive goal tree constructed tree constructed clause antecedent violated clause verified distinguishing consequent atom branch tree mismark consequent atom refutation unnecessary branch tree useless branch case isatchmo also possibly make redundant propositional clause tree leftmost node labeled clause violated used forward chaining deriving clause refutation marked process consequent atom sibling atom sibling atom made obviously process node unnecessary consequent atom branch node useless branch node mean refutation node made consequent atom made root node redundant process consequent atom eliminated process made leftmost node also unnecessary strict unavoidable unless consequent atom parent node child node atom process node last clause forward chaining wellknown nondetermination proving distinguish manage consequent atom branch tree loss generality violated clause node consequent atom relative derive consequent atom relative node reasoning procedure processing node proven unsatisfiable useless node proven unsatisfiable parent node proven unsatisfiable know unsearchmo node proven unsatisfiable consequent atom deriving refutation node established consequent atom node constructed node proven unsatisfiable node proven unsatisfiable proven unsatisfiable clause refutation node clause ably violated consequent atom derive antecedent refutation refutation made node consequent atom refutation made node splitting node also concludingly case consequent atom derived consequent atom deriving antecedent hand node proven unsatisfiable useless clause unnecessary refutation made node word refutation node also made node clause thus consequent atom deriving refutation node exactly case derived removed database make node proven unsatisfiable proven unsatisfiable exactly consequent atom node proven unsatisfiable node useless consequent atom derived obviously consequent atom contained branch beginning useless refutation made node also useless unsatisfiable seen consequent atom last atom consequence violated clause next sibling atom processing fewer consequent atom refutation clear consequent atom node derived keep consequent atom refutation forward chaining proving prover unsearchmo construct checking clause unsatisfiable node initially root node consequent atom initially empty leaf node node mean node proven unsatisfiable consequent atom node consequent atom listed successful deriving leaf established instantiated ground violated clause clause satisfiable violated clause node taking node call procedure recursively augmented consequent atom useless backtracking node node consequent atom node established hand consequent atom established case node proven unsatisfiable clause tree constructed unsearchmo redundant eliminated correctness unsearchmo difficult unsearchmo branch tree constructed satchmo satchmo show clause unsatisfiable unsearchmo certainly show show completeness unsearchmo hand indicated asserted consequent atom useless time retracted reasoning database parent node able proven unsatisfiable remaining process show parent node unsatisfiable removed loss soundness omitted lack easy unsearchmo prolog code omitted also lack clause benchmark tptp sutcliffe suttner clause satchmo satchmore mean case gave test satchmo satchmore satchmore termination intel workstation unsearchmo work initially clause used forward chaining substitution antecedent satisfiable branch node clause substitution node derived consequent atom established node tree constructed unsearchmo clause derived clause tution node node derived consequent atom node node refutation derived clause substitution clause used forward chaining node last refutation derived node child node simultaneously consequent atom refutation node node consequent atom node constructed distinguish consequent atom branch find marked process made repeated also answer reasonable time node consequent atom unsearchmo find useless refutation clause node parent consequent atom derived sibling node abandoned consequent atom node backtracking repeatedly continues node consequent atom established unsearchmo process made node also made sibling node node consequent atom violated clause node happens unsearchmo backtracks parent node consequent atom surprisedly empty consequent atom refutation unsearchmo simply backtracks root node clause unsatisfiable help distinguishing consequent atom branch unsearchmo take find intel workstation conclusion introduced eliminate redundant backtracking forward chaining proving much redundant branch pruned away unnecessary backtracking reasoning violated clause forward chaining repeated invoking unnecessary nonhorn clause effectively eliminated powerful forward chaining proving prune away unnecessary branch unnecessary clause used forward chaining violated clause forward chaining used decided checking incorporate relevancy checking satchmore testing introduced obvious disjunction database eliminate redundant forward chaining prover also forward chaining used give wide automated reasoning work prover test benchmark tptp sutcliffe suttner clear helped yahya yahya unit hyperresolution tableau automated reasoning chao simajiri seki itoh satchmore checking computing satchmo automated reasoning loveland loveland mechanical proving elimination loveland loveland reed wilson satchmore satchmo relevancy automated reasoning manthey manthey satchmo prover prolog proceeding intl conf automated deduction ramsay ramsay generating relevant automated reasoning robinson robinson resolution comput mach sutcliffe suttner sutcliffe suttner http tptp proving structured sheila mcilraith eyal amir gate wing stanford stanford motivated answering structured commonsense proving structured subtheories minimally literal consequence specializing case resolution batch concurrent proving restricts subtheories exploiting polarity literal minimize reasoning exploiting focused incremental consequence compiles subtheory sublanguage proven soundness completeness provers becoming increasingly prevalent reasoning commonsense base commonsense exemplified cycorp high performanceknowledgebase hpkb system developedby stanford system comprise thousand axiom embodying loosely coupled subject domain mathematical domain automatedtheoremprovers commonsensetheories highly structured lending improving reasoning used mean exploiting reasoning bayes satisfaction csps reasoning case system laboratory convert graphical treestructured node tree represents subproblem loose coupling subproblems inference done locally node propagated node inference thus prof linear tree worstcase exponential node leverage idea sound proving propositional propositional partitioned subtheories minimally coupled sharing vocabulary sometimes partitioning user reasoning time partitioning induced automatically reasoning automated partitioning partitioning depicted graph node represents subtheory represents vocabulary subtheories proving locally subtheory relevant propagated sound entailment maximize effectiveness proving must minimize coupling node tree reduce passed minimize inference node case soundness completeness partitioned minimizing message sent inference extend applicability reasoning procedure modify resolution reasoning procedure lyndon interpolation reduces size communication connecting considering polarity literal minimize reasoning focused incremental consequence also compiling partitioned propositional sublanguage proven soundness completeness reasoning procedure consequence specified sublanguage omitted reasoning framework adopted extend soundness completeness minimize inference partitioning axiom built literal axiom partitioning induces graphical call intersection graph node intersection graph represents node linked edge edge labeled replacementsshare refer communication intersection graph edge empty label illustrates propositional clausal form side partitioning displayed intersection graph appeared partitioned intersection graph messagepassing reasoning take partitioned graph entailed procedure consequence consequence finder reasoning graphical node pass concluded adjacent node communication adjacent node node path node containing recall consequence opposed nontautological consequence sentence subsume prime implicate consequence finder message sent graph step computes strict node graph partitioning partitioned graph dist shortest path node dist dist procedure partitioning graph describing connection concurrently consequence consequence axiom provena derive subsuming initially derive inconsistency forward illustrates resolution consequence finder seen partitioning reduces inference step precluding resolution axiom residing showed reasoning reduces significantly size communication sound property graph consequence finder used graph tree properly labeled proper labeling partitioned said proper labeling subtheories side edge true intersection graph tree properly labeled drink part resolve generating onpump pump clause passed boiler boiler steam onboiler steam steam clause steam passed steam teabag drink steam hotdrink drink drink asserting pump boiler boiler transforms intersection graph tree properly labeled tree note proper labeling intersection property used bayes consequence finder sublanguage graph completeness axiom consequence finder consequence soundness completeness partitioned arbitrary propositional tree properly labeled reasoning procedure soundness completeness improves upon soundness completeness consequence finder consequence communication case restrict consequence even reasoner completeness axiom consequence finder tautology observe reasoner lconsequence also closed subsumption consequence finder restricting consequence consequence designated sublanguage inoue completeness consequence reasoner completeness restricted clausal reasoner must arbitrary refines restricting propositional clausal requiring reasoner soundness completeness partitioned propositional clause tree properly labeled reasoning procedure reasoner show reasoning inference resolution specialize consequence finder resolution widely used reasoning automated deduction consequence clausal form disjunction unquantified literal resolution rule consequence linear resolution variant resolution resolution rest devoted explaining four subroutine used procedure send message clausal propositional clausal graph properlylabeled tree label functionand also clausal unskolemization skolemization message passed fourth refinement avoids unskolemization propositional case subroutine simply done resolution employed sound case care illustrate case resolution generates clause also implicitly prof procedure partitioned graph clausal form concurrently resolution clause resolvent ressend proven resolution forward need send send communication ground case completeness consequence clausal resolution completeness full also reflected slightly craig interpolation applies resolution addressing communication everyconnectedset soundness completeness case subroutine simply done system consist many many computationally inefficient leading many unnecessary irrelevant deduction step arguably compelling addressing resolution infer existential send proper skolemize clause ressend replacing eliminates unnecessary work receiving process conservatively replacing existentially quantified unskolemization reverse skolemization generalizes simplifies precludes inclusion vocabulary thus resolution lconsequence unskolemizing procedure skolemizing give combined procedure message procedure used readily upholding soundness completeness supplied subroutine replaces skolemizes resulting inclusion procedure unskolemize treating skolem subsumed clause skolemized axiom subroutine unskolemization procedure clause must entail quantified quantified entail case avoid quantified replacing unskolemize skolemize process procedure procedure term subexpression term replace nondeterministicallya pair marked unifiable unify occurrence unify marking marked collect marked side sign occurring replace fresh fresh nondeterministically pair unify occurrence subroutine unskolemization step procedure correspond step procedure simplifying procedure differs unskolemizing procedure step stop replacing skolem existentially quantified replaces nondeterminism step used unified term completeness soundness completeness partitioned propositional clause tree properly labeled sentence applying sketch soundness completeness follow show sentence implying completeness implied thus sound restricted sentence submitted translation soundness completeness applies case provethat enoughsentences quantified applying clause step step marking converted existentially quantified quantification ordering quantifier consistent rule process done step step kind quantified quantified exactly step generates clause entail thus clause entail clause unskolemizing clause entail sentence implied sound clause consequence clause conservative resolution readily used preservingcompleteness linear resolution directional resolution lock resolution semantic resolution used treatment minimizing node coupling polarity communication relevant inference step improves exploiting polarity constrain communication lead reduction message passed adjacent thus reduction size reasoning predicated lyndon interpolation craig lyndon interpolation sentence sentence positively negatively positively negatively referred interpolant need send clause literal used inference step partitioned graph concluded show positively show negatively show positively need send message procedure polarize take partitioned tree graph lyndon interpolation label graph polarity positively negatively edge label appeared also respective edge soundness completeness partitioned arbitrary propositional tree properly labeled polarize reasoning procedure darwiche restricted polarity propositional equivalentto propositionalsymbols polarity throughout assigning truth exploitation polarity propositional constraining inference step applicable broader procedure polarize partitioning tree rewrite negation front literal negation normal form vertex separated constraining communication exploiting polarity case polarity minimizing inference maximize effectiveness proving must minimize inference node soundness completeness propositional consequence deduction step leading consequence skipping deduction step propositional case prime implicate finder excellent survey skipping ordered linear resolution kernel resolution finder directional resolution propositional case incremental finder find consequence entailed defining completeness incremental analogous rest graphical specialized consequence reasoning previoussections reasoner preserve soundness completeness significantly inference step used procedure unless noted propositional consequence finder fail terminate even decidable case compilation compile take partitioned tree properly labeled compiled partitioned composed consequence lcommi communication prime implicate finder used compilation particularly propositional case used sound finder step compile compilation produced compile worst case size lcommi clause produced minimize communication lcommi much consequence expect compiled guaranteed fairly static cost compilation amortized many compilation compilation procedure compile partitioning tree proper labeling lcommi sound finder placing compilation partitioned tree properly labeled lcommi lcommi compiled compile compiled concurrent proving well proving take possibly compiled partitioned tree properly labeled focused relevant consequence pass conclusion partitionwith algorithmis verysimilar bucket elimination preserve soundness completeness exploiting focused soundness completeness clause propositional finder procedure compiled partitioning properly labeled tree describing connection compiled replace uncompiled decreasing finder exhausted consequence consequence provenb derive subsuming initially derive inconsistency step applying final take possibly compiled partitioned tree properly labeled incremental communication relevant incremental consequence pass used sound lconsequence preprocessing step case compiled propositional prime implicates consequence simply picked consequence used sound incremental finder step preserve soundness completeness propositional case exploiting focused soundness completeness clause propositional finder step incremental finder step concurrentmp liconsequence incremental applying work numberof reasoningsystems type reasoning exploitation used bayes work distinguished procedure compiled partitioning properly labeled tree describing connection compiled replace uncompiled finder exhausted consequence implicates concurrently incremental consequence provenb derive subsuming initially derive inconsistency concurrent probabilistic independence take role reasoning work significantly distinguished work csps reasoning partitioned message passing well propositional area proving work parallel proving survey combining system parallel proverimplementationsare guided lookahead subgoals decompose dynamically message sent provers parallel heuristic decide message relevant prover look independence repeated much reasoner clear deciding message sent work combining system procedure suitable nondeterministically instantiate newly connecting restrict convex disjunction intuitionistic flowing back forth reasoning consequence finder provers restriction besides finiteness work formalizing reasoning survey proving structured viewing contextual interacting unfortunately explicit expressive consequently focused propositionallogic much reasoningwork focused checking getfol exploited proving structured subtheories minimally literal consequence specializing case resolution batch concurrent proving restricts subtheories exploiting polarity literal attempted minimize reasoning exploiting focused incremental consequence compiles subtheory sublanguage proven soundness completeness contribute addressing reasoning efficiently structured commonsense acknowledgement wish thank ijcai reviewer thorough review alvaro pierre marquis helpful comment relationship work work consequence part darpa grant navy grant darpa grant akman surav step toward formalizing magazine amir triangulation treewidth manuscript submitted publication http amir mcilraith reasoning proc page morgan kaufmann baader schulz free bledsoe ballantyne unskolemizing memo mathematics texas austin bonacina hsiang parallelization deduction analytical automated reasoning boyer locking restriction resolution thesis mathematics texas austin chadha plaisted consequence unskolemization proceeding volume lnai page pietrzykowski nonredundant reversed skolemization craig linear reasoning form herbrandgentzen darwiche utilizing semantics graphbased proc aaai page dechter pearl tree clustering scheme processing proc aaai dechter rish directional resolution davisputnam procedure revisited proc page morgan kaufmann consequence compilation restricted proc aaai page aaai denzinger dahn cooperating provers bibel schmitt automated deduction volume page kluwer giunchiglia getfol manual getfol dist genoa http inoue linear resolution consequence artificial intelligence jensen lauritzen olesen bayesian updating recursive graphical computation computational statistic quarterly completeness derivable axiom thesis california berkeley lyndon interpolation calculus pacific mathematics marquis consequence defeasible uncertain reasoning volume handbook deafeasible reasoning uncertainty system page kluwer mcilraith amir proving structured full dept stanford minicozzi reiter note linear resolution artificial intelligence nelson oppen simplification cooperating procedure system rish dechter resolution automated reasoning robinson resolution slagle interpolation resolution calculus july proving answer experimenting heuristic answer wolfgang faber nicola leone inst informationssysteme wien mathematics univ calabria wien austria rende italy faber leone gerald pfeifer inst informationssysteme wien wien austria pfeifer answer novel paradigm highly declarative disjunctive expressive even high heuristic branching literal criterion determining literal assumed true computation dramatically affect system heuristic fair deal little work heuristic done extend framework heuristic successfully employed system experimentally heuristic system respective benchmark domain show evidence couple promising heuristic criterion sensibly outperform heuristic answer declarative area nonmonotonic reasoning expressive classical negation disjunction allowed head rule nonmonotonic negation body rule semantics work austrian fund grounded precise sense answer gelfond lifschitz idea answer computational answer correspond answer find lifschitz assignment color node graph adjacent node color node edge fact unary binary admissible coloring graph rule node graph colored yellow forbids assignment color adjacent node minimality answer node color thus correspondence answer graph answer answer encoded propositional thanks nonmonotonic disjunction negation failure lifschitz importantly encoded used eiter high expressivenessof answer come price high computational cost worst case make system difficult task nevertheless done system best system eiter smodels niemela simon also system extent ccalc mccain turner east truszczynski quip egly core system produced subjected answer system employ procedure procedure used heuristic branching rule branching literal criterion determining literal assumed true computation fundamentally procedure dramatically affect system work done developing heuristic comparing alternative heuristic hooker vinay anbulagan freeman little work done system aware heuristic heuristic system couple heuristic successful nondisjunctive system extend framework disjunctive experimentation heuristic heuristic system respective benchmark domain show evidence couple promising heuristic criterion sensibly outperform heuristic nevertheless conclusive work heuristic step hopefully stimulate work heuristic strongly build answer formal semantics answer disjunctive datalog negation background gelfond lifschitz eiter disjunctive rule classical literal atom possibly preceded disjunction head body body body operator like system body rule disjunctive datalog also finite rule usual atom rule ground propositional answer semantics consistent answer originally gelfond lifschitz herbrand universe appearing herbrand base appearing possibly preceded literal said consistent literal complementary literal contained rule rule applying substitution ground instantiation answer ground instantiation step lifschitz answer give reduction reduction answer ground literal consistent closed literal head true literal body true answer inclusion closed reduct transform ground ground deleting rule body false deleting body remaining rule answer answer answer computation main step computational process system refer particularly computational engine system used also system like smodels employ procedure answer step computation system eliminates generating ground instantiation hard part computation ground instantiator heart computation sketched roughly answer stability subsequently verified isanswerset verifies applying isanswerset true computation stopped false modelgenerator boolean inconsistency boolean detcons false inconsistency atom undefined isanswerset undefined ground atom heuristic modelgenerator true else modelgenerator computation answer modelgenerator parameter empty answer true answer false procedure employed call detcons literal deterministically inferred literal upon inconsistency unit propagation procedure employed peculiarity inference answer detcons inconsistency atom heuristic criterion modelgenerator atom play role branching like good atom crucial system next heuristic criterion branching atom heuristic throughout ground fixed heuristic criterion dynamic heuristic heuristic branching rule heuristic literal taking true computing consequence literal intepretation resulting detcons consistent automatically false heuristic evaluated heuristic branching rule adopted system satz anbulagan framework rule undefined literal occurring unsatisfied word unsatisfied rule shrink truth assumed propagated thus prefers literal introducing unsatisfied rule intuitively high unsatisfied rule preferred creates stronger intepretation contradiction anbulagan combine atom complement favour roughly avoid failure lead satz combined atom atom heuristic prefers atom heuristic take else heuristic heuristic inspired branching rule smodels well system simon atom true false intepretation maximizes size resulting intepretation minimizes atom left undefined intuitively minimizes size remaining undefined atom simon smodels heuristic cautiously maximizes precisely preference relationship atom atom heuristic take worthwhile noting heuristic smodels intuition sophisticated unfortunately centered around property unstratified negation framework smodels heuristic framework disjunctive heuristic heuristic used system even naive heuristic benchmark changing branching rule test system peculiar property answer supportedness true atom answer rule body true true atom head system must eventually converge system keep much step computation system unsupportedtrue atom atom true miss supporting rule faber mbts rule must true answer give thus system true rule unsupportedtrue removed supporting rule supporting rule literal atom atom occurring head exactly unsatisfied rule heuristic considers prioritized favor atom yielding fewer atom lead counter heuristic considers rule satisfied precisely atom atom heuristic heuristic considers atom literal take happens atom lead failure heuristic heuristic balanced heuristic also complement atom evaluated heuristic atom heuristic work precisely considers primed counter best atom benchmark heuristic chose couple benchmark blocksworld planning hamiltonian path strategic company best researched used many transforming back domain propositional conjunctive normal form literal propositional satisfiable consistent literal papadimitriou classical formalism propositional rule ensures complement true clause literal literal hamiltonian path hampath classical npcomplete area graph undirected graph vertex edge node graph path passing node exactly graph specified node specified unary tuple solves hampath node reached guess take path blocksworld classic planning domain oldest block desired goal reach goal moving block time block block time step show time step move block block goal restriction refer erdem faber encoding strategic company stratcomp cadoli holding owns company good company jointly control modelled mean produced company jointly company sold good produced company sold holding afterwards company strategic belongs strategic company satisfying answer natural correspond strategic checking company strategic done brave reasoning answer containing cadoli produced company company jointly company benchmark data tool selman kautz selman kautz size kept ratio clause near crawford auton hampath tool patrik simon used smodels simon http size node node blocksworld employed erdem system step augmented step permutation stratcomp size company company five company company company benchmark data http freebsd machine main memory binary produced conclusion displayed graph graph horizontal axis parameter representing size vertical axis time expressed size heuristic straightforward optimization time reported graph meaningful comparing relative heuristic allowed time graph line heuristic stop allowed time heuristic heuristic allowed time hampath stratcomp heuristic native heuristic system combine heuristic complementary atom worst case terminate benchmark stratcomp stopped heuristic satz heuristic behaves well stratcomp benchmark fastest fastest show behaviour hampath considering unsupportedtrue literal seems crucial heuristic surprisingly good balanced heuristic heuristic literal combined dramatically improves heuristic solves nearly stopped heuristic best heuristic stratcomp importantly hampath beat heuristic relevant behaviour heuristic undefined atom controversial behaves well hampath stop node beaten even naive heuristic confirms find proper heuristic smodels framework disjunctive concluding observe heuristic heuristic significantly native heuristic system dramatic confirms even careful branching rule system step hope work follow proposing heuristic system blocksworld time hamiltonian path time strategic company time cadoli cadoli eiter gottlob default ieee tkde crawford auton james crawford larry auton crossover artificial intelligence march east truszczynski east truszczynski datalog egly egly eiter tompits woltran reasoning task quantified boolean aaai eiter eiter gottlob mannila disjunctive datalog transaction database system september time eiter eiter faber leone pfeifer declarative system logicbased artificial intelligence kluwer erdem erdem planning computational unpublished draft http faber faber leone mateis pfeifer database optimization nonmonotonic reasoning faber faber leone pfeifer pushing goal derivation computation freeman freeman propositional satisfiability thesis pennsylvania gelfond lifschitz gelfond lifschitz classical negation disjunctive database computing hooker vinay hooker vinay branching rule satisfiability automated reasoning anbulagan anbulagan heuristic unit propagation satisfiability ijcai lifschitz lifschitz foundation csli publication stanford lifschitz lifschitz answer planning mccain turner mccain turner satisfiability planning causal morgan kaufmann publisher niemela niemela stable semantics paradigm annals mathematics artificial intelligence papadimitriou christos papadimitriou computational sagonas swift warren freire system efficiently computing wellfounded semantics selman kautz selman kautz simon simon extending stable semantics thesis helsinki finland graph characterization computation answer thomas linke institut informatik universitat potsdam postfach potsdam germany linke give graph characterization answer normal show correspondence answer coloring block graph lead alternative paradigm answer computing graph coloring like computing answer work answer semantics gelfond lifschitz established alternative declarative semantics originally gelfond lifschitz stable semantics gelfond lifschitz answer dimopoulos niemela reasonably computing answer smodels niemela simon eiter system like deres cholewinski quip egly also able answer deal formalism system well deal answer term atom literal view namely characterizing computing answer term rule intuitively head rule answer none call rule answer easy block contributes thus analogously block answer lead strictly precisely block rule block graph answer characterizedas block graph node block graph rule colored color representing rule block graph quadratic size block graph serf data need background deal normal used negation failure rule form atom rule fact rule part part head body body rule rule usual referred prerequisite body atom referred body atom said rule form normal rule fact rule rule atom closed smallest atom closed reduct relative atom atom answer reduct lifschitz reduction observe posse answer throughout term answer stable rule form grounded enumeration rule atom generating rule relates groundedness generating rule answer lemma atom answer grounded lemma characterizes answer term generating rule observe take rule show generalize normal body atom also real restriction need graph terminology directed graph pair finite nonempty vertex directed graph vertex predecessor analogously successor path finite subset path path directed graph need kind labeled graph directed graph labeled zero distinguish path graph occurring additionally call even even block graph coloring formal rule block rule hold maximal grounded block graph directed graph vertex kind observe maximal grounded capture rule block rule also gather groundedness restriction rule maximal grounded part block rule groundable rule maximal grounded subset rule empty show block graph block graph coloring acolorings block graph subset rule grounded fact hold block graph mapping hold hold hold grounded block graph rule intuitively answer colored specifies rule colored grounded blocked rule rule colored grounded blocked rule capture intuition rule answer block graph need lemma hold hold hold equivalence stated lemma acoloring lemma welldefined sense assign exactly color node main hold block graph answer answer computing coloring correspond answer computation hold mapping pair disjoint refer ping tuple vice versa parameter procedure indicated node uncolored node colored node color propagated show procedure color pseudo code procedure color list mapping node propagate fails fail fails propagate fails fail else else color succeeds exit else color succeeds exit else fail procedure color procedure mapping parameter fail node fails color time fact colored basically color take mapping uncolored node coloring node done choosing uncolored node trying color case failure color color node also fails color fails node used backtracking selects uncolored node hold fails ensures node grounded observe fails color node grounded rule recursive call former recursion color node propagated propagate coloring node color checked allowed done propagate mean color fails propagation propagating colored node prune thus reduces make exponential part propagation essential part propagate sufficient correctness completeness deal four propagation case node colored color propagated node colored propagate color node propagating give correctness propagate color test hold block graph mapping hold rule contributes answer colored case node colored colored take word blocked rule intuitively colored blocked colored consequence rule fact rule grounded blocked rule last postulate rule derived rule mapping propagate fails show propagate propagate procedure propagate list mapping node propa fails fail else propc fails fail propb fails fail propd fails fail procedure propagate propagation case case four procedure used propagate propb procedure propb node mapping node node hold fail propagate procedure propb determines hold test node colored node uncolored colored color propagated propb fails colored next node procedure remaining propagation case analogously uncolored node colored propagation color recursively propagated propagate mapping answer answer undefined node answer mapping exactly answer formulate hold mapping propagate succeeds mappingafter propagate propagate neither discard introduces answer mapping justifies node used lead answer backtracking color correctness completeness color hold block graph mapping acoloring demonstrate color computes block graph invoke color propagate propagating case recursively give updating uncolored node possibility next hold namely updating recursive call color color node propagated propagate propagation case color recursively propagated case give lead empty fails invoking backtracking mean last recursive call color fails color case thus case show normal body literal normal restriction rule atom appearing transformation linear size normal transformed rule interpret kind normal form lemma obviously hold lemma normal atom answer answer exactly atom atom occurring straightforward extend normal call rule rule ornodes observe hand modify block graph stay distinguish kind node hand procedure deal consequently extend know blocked case extend hold nevercontainany andnode propagation case propagate color color case integrated propagate gelfond lifschitz show classical negation normal atom introduced also suitable computing answer classical negation additionally janhunen handle disjunctive work directed graph used node graph atom dependency graph network doyle rule graph atom used atom graph rule dimopoulos torres brignoli serious drawback deal answer semantics exponentialsize rely equivalence need exponential fact block graph graph rule papadimitriou sideri linke schaub default case default aforementioned graph essential blocking computing answer practical block graph also used tool linke schaub imply answer clearly color like smodels like procedure main color determines answer term generating rule smodels construct answer term literal rule atom rule responsible atom belonging answer additionally responsible rule groundedness rule head groundedness generating rule procedure conclusion main contribution block graph tool block graph seems suitable investigation many answer semantics wellfounded semantics answer kind graph coloring alternative answer computing need give demonstrate practical usefulness used cholewinski hamiltonian path graph concerning time prolog time month comparable suggests used reflects deal exponential part unfortunately smodels give informationabout concentrated comparing smodels smodels nomore show graph surprisingly turn reasoning system nomore well growing size need smodels also seen show time hamiltonian need time smodels fair graph need twice graph node node circle graph node much time smodels need even smodels nomore nomore backtracking prolog smodels backtracking highly specialized computing answer applies smodels nomore time indproblems sparc processor work also think integrate backward propagation propagating color definitely fact also node node colored block graph also used replace incoming outgoing investigate heuristic procedure next aggoun prototype http acknowledgement like thank schaub besnard wang konczak anger commenting work partially german foundation nichtmonotone inferenzsysteme verarbeitung konfligierender regeln aggoun aggoun chan dufresne eclipse user manual release eclipse http brewka brewka nonmonotonic reasoning foundation commonsense cambridge cambridge brignoli brignoli costantini provetti characterizing computing stable case proc conf cholewinski cholewinski marek mikitiuk truszczynski experimentingwith nonmonotonic reasoning proc conf cholewinski cholewinski marek truszczynski default reasoning system deres proc morgan kaufmann publisher dimopoulos torres dimopoulos torres graph default dimopoulos dimopoulos nebel koehler encoding planning proc european conf planing toulouse france springer verlag doyle doyle truth maintenance system artificial intelligence egly egly eiter tompits woltran reasoning task quantified boolean proc eiter eiter leone mateis pfeifer scarcello deductive system nonmonotonic reasoning furbach nerode page springer verlag gelfond lifschitz gelfond lifschitz stable semantics proc conf gelfond lifschitz gelfond lifschitz classical negation proc conf gelfond lifschitz gelfond lifschitz classical negation deductive database computing janhunen janhunen niemela simon unfolding partiality disjunction stable semantics cohn guinchiglia proc linke schaub linke schaub alternative foundation reiter default artificial intelligence ramakrishnan smolka alternating fixed proc conf tool construction system lisbon portugal springer verlag niemela simon niemela simon smodels stable wellfounded semantics normal furbach nerode proc springer niemela niemela stable semantics paradigm annals mathematics artificial intelligence papadimitriou sideri papadimitriou sideri default artificial intelligence proving framework declarative specification thomas eiter michael fink giuliana sabbatini tompits institut informationssysteme abteilung wissensbasierte systeme technische universitat wien favoritenstrasse vienna austria eiter michael giuliana tompits updating base representedas programshave generic framework declarative specification built upon extends lups specification incorporates framework agent flexibly react upon arriving suitable base framework compiles mean generic translation instantiated term concrete thus flexible tool adaptive reasoning agent updating base realization intelligent agent agent situated changingenvironmentandmust adjust base classical base nonmonotonic base like alferes eiter inoue sakama default williams antoniou updating deal incorporation rule rule base accordingly lead declarative semantics broaden alferes lups consist command command permit term removing rule command stating rule true must eliminated limitation lups mentioned formalism handle conceived handling unknown arrive evolves fact lack possibility agent react upon arrival like arrival fact bestbuy shop removed address declarative framework agent agent receives term rule adjusts accord consisting declarative main contribution summarized generic framework instantiated facilitated layered evaluated agent belief command need next compiled rule incorporatedto bottom updatedknowledge base serving semantics determines belief declarative generalizing lups feature importantly access incoming facilitated retract told removed base like belief command lups thus enables flexible handling simply recording skipping uninteresting applying default analyze property framework answer semantics eiter property concerning maintenance explored framework realization framework agent system subrahmanian evidence viable tool developing adaptive reasoning agent preliminary reader familiar elps gelfond lifschitz rule head body stand default negationand negation literal atom rule constructible elps adopt view semantics elps mapping associate rule intuitively consequence instantiation semantics satisfies elementary property reasonable semantics satisfies hold property fied semantics eiter coincides semantics inheritance buccafurriet semantics elps usual ground herbrand universe ground complementary pair literal consistent answer reduct deleting rule body default literal removing default literal body remaining rule gelfond lifschitz collection answer rejection rule answer answer collection answer semantics extends answer semantics eiter describes characterization semantics term elps answer answer posse answer belief rule true drop subscript ambiguity arise slight abuse literal generic framework updating afterwards belief step executable command compilation semantics belief step around framework formal agent collection finite rule informally describes communicated rule agent witness collection fact subset atom fixed base intuitively describes evolution agent base request agent incorporate base adapt belief procedure adapting belief arrival illustrated informally step evolution belief want term executable command afterwards previously compiled transformation generalizes specification lups alferes depend belief note lups provision feature make suitable rational reactive agent capable filtering incoming command refer rule rule form assertion retraction rule expressed command conditioned proviso belongs belief command lups alferes plus command ignore skip unintended incorporated base conditionin form substituted list note lups rule expressed dependency command also extend permitting rule literal command ranging universe belief syntactic safety checked name capital letter finite mean rule incorporated base specified rule ignored command retract force rule deactivated assertion retraction supposedto persist inertia subsequentsteps precise command made clear next agent selecting shop merchandise base rule fact time stamp shop sale site queried default serve site queried true consistent fact ground rule form stating shop sale date time stamp well informally repeatedly confirms sale date revoke remove previously ended sale time stamp also keep time stamp remove simply sale shop ignored semantics semantics depicted step executable command belief belief groundedversionof overthe underlyingthe givenupdate sequenceand receivedevents step thus form mantically interpret ordinary rule collection rule exclude contradictory command executable command step answer grounding negation executable command actually stable gelfond lifschitz answer answer agent must commit command suitable returning answer returning atom atom used signaling encountered inconsistency filtered restricting outcome next compilethe executablecommands serving belief realized mean transformation generic adapted mapping introducedby alferes suitable naming rule enforcing rule name inductively fined executable command atom persistent command command compilation belief executable command belief reconsider answer compiled seen belief property property particularupdatepolicies definitionof answer eiter explained stress property also satisfied instantiation like dynamic alferes note property empty never belief independentof thus static unconditional assert rule contained incorporated thus empty thus removal rule growth agent base modular construction transformation rule fact repeatedly inserted addressed next removal rule base lemma hold rule property hold repeatedly removing rule lemma thus purge base remove duplicate rule well deactivated retracted rule history contraction relevant possibility case agent history belief step merely step call factual assert assert fact case compilation simplified thus construction fact hold lemma fact thus assert history contraction factual assert compiled simplified lemma show hold investigation hold subject computational briefly address reasoning stratified ciated rule form stratified replacing default negation stratified answer thus redundant cost must unknown answer thus cautious reasoning mode clearly answer deciding conp stratified fact answer semantics computable oracle ground rule ground deciding completeness case unknown fact assert strat stratified stratified hold dynamic intuitively explained iteratively step polynomially many must construct time rule step feasible time oracle thus polynomially computable oracle decided oracle call updating stratified fact preserve decidability explains cidability case computing lexicographically maximal unknown nondeterministically guessed verified time lead conp implementational elegant straightforward realization agent subrahmanian developing agent build agent legacy code package operates arbitrary data thus accordance generic framework committing semantics semantically executable command engine like package updating querying base accessed returning belief list rule belief modeled code call atom atom true returned true negation command body code specified term list code call atom thus like parameter introduced rule list code call atom belief semantics agent reasonable stable prescribes agent thus represents executable command accord respectiveaction executionaffects computation eiter work conclusion spirit work database adbs dynamic database specified rule triggered adbs declarative semantics rule time fire possibly causing successive baral lobo declarative characterization adbs term reduction calculus also compiled well lifschitz turner base depend tailored planning reasoning reactive specification emulated literal belief investigating relationship framework concerning area lobo extends serf reactive response collection rule associating seems thus expressive embeddings remain explored feature atom telling actually part activated access extensional part rule term involving literal fixed atom access rule combined command remove rule involving thus conveniently expressed expressive base conceivable requesting reasoning task possibly taking temporal evolution expressing true concluding generic framework extends represents convenient declarative specification also fruitfully used exploring part ongoing acknowledgement work partially austrian fund grant alferes alferes pereira przymusinska przymusinski lups updating proc lnai springer alferes alferes leite pereira przymusinska przymusinski dynamic nonmonotonicknowledgebases baral lobo baral lobo formal characterization database proc lncs springer buccafurri buccafurri faber leone disjunctive inheritance proc eiter eiter fink sabbatini tompits consideration proc lnai springer eiter eiter fink sabbatini tompits declarative agent proc symp adaptive agent system york aisb gelfond lifschitz gelfond lifschitz stable semantics proc gelfond lifschitz gelfond lifschitz classical negation disjunctive database computing inoue sakama inoue sakama updating abduction proc lnai springer lifschitz turner lifschitz turner representing transition system proc lnai springer lobo lobo bhatia naqvi proc aaai marek truszczynski marek truszczynski revision subrahmanian subrahmanian eiter bonatti kraus ozcan ross heterogeneous agent system williams antoniou williams antoniou revising default proc morgan kaufmann updating proc abduction abductive procedure rewriting fangzhen computing hong kong alberta clear kowloon hong kong edmonton alberta canada abduction kakas mancarella rewriting system answering generating explanation show soundand stable semantics sound answer semantics free work reasoning abduction background abduction normally want consistent abducibles propositional background abducibles explanation reiter kleer poole konolige literal consistent abduction investigated perspective eshghi kowalski kakas mancarella satoh iwayama influential abduction kakas mancarella stable semantics atom standing abducibles kakas mancarella abductive explanation subset answer also stable satisfies propositional propositional literal atom propositional must term subset ordering case argue fact answer semantics negation none atom head rule really mean literal also minimality conditionin literal never comparable term subset abductive explanation make sense problematic practice abductive explanation kakas mancarella abductive explanation manage case explanation looking tempting prefer abductive explanation like propositional mentioned make sense take abductive explanation literal implied answer semantics minimize atom case preferring problematic negation boat used cross river leaking leaking bucket scoop boat axiomatized someone crossed river clearly explanation boat leaking person bucket term kakas mancarella abductive explanation abducibles closer look preferred explanation mean literal preferred want part explanation necessarily want want negation failure abducibles make want best explanation justify completing literal turn correspond abductive explanation kakas mancarella kind justification turn work well preferred explanation explanation explanation motivates abduction revisited normal rule form atom propositional default negation answer semantics gelfond lifschitz standing abducibles loss generality none abducibles head rule hypothesis mean consistent literal case hypothesis atom hypothesis really assignment hypothesis hypothesis said explanation answer atom hypothesis said explanation explanation hypothesis said explanation explanation explanation hypothesis clearly explanation explanation well explanation none deleted continue explanation also explanation take hypothesis propositional hypothesis explanation explanation explanation explanation succinct explanation clear hypothesis explanation abductive explanation kakas mancarella none abducibles head clause abductive explanation kakas mancarella explanation sense kakas mancarella abductive explanation explanation seen abductive explanation enumerating impossible even domain explanation much importantly like explanation propositional relevant computationally hard explanation scratch explanation hypothesis said explanation must explanation explanation explanationmust extensionof explanationsin find explanation propositional reasoning recall literal prime implicant subset literal entail hypothesis explanationof prime implicant rest rewriting system generating explanation abducibles extend system abducibles show rewriting system generates case exactly loop system reasoning goal rewrite system ground clark equivalence atom head rule default negation replaced literal exactly rule head empty idea goal rewriting completed used rewrite rule left rewritten call literal rewriting completed rewrite rule goal goal also referred goal goal resulted literal rewriting goal derived goal goal negation appearing front atom said term introduced kunen convenience goal achieved transformation rule like goal transformed suitable form literal rewriting changing semantics loop handling rewriting goal terminates proved proved goal rewrite system type rewrite rule programrules literal rewriting simplification rule transform simplify goal loop rule handling loop simplification rule simplificationsubsystem formulatedwith loop handling mind keeping track literal goal resulted rewriting central formalizing goal rewrite system rewrite rewrite literal literal derived goal rewrite abbreviated essential goal form goal rewrite literal proving call simplicity automatically replaced literal correspondingrewrite automatically replaced note literal derived goal rewrite leading literal goal uniquely rewrite literal last goal rewrite simplification rule goal literal consistent inconsistent simplification system nondeterministic transformation system primed rule symmetric case rule equivalence side rule merges consistent make failure prevent generating inconsistent literal even proved note goal goal tautology classic well lead neither proved goal rewriting loop system sufficient rewrite focusing left part goal loop rule literal rewritten goal rewrite thus loop rewrite loop classifying case loop determining outcome rewrite semantics hand four case rewrite loop loop atom literal also atom loop literal literal also even loop case loop literal note sign sign type loop caused loop type loop must treated differently semantics turn need rewrite rule handle four case loop rule rewrite loop loop loop even loop apparently loop literal rewritten loop rule proved proved neither proved goal rewrite system property summarize rewrite zero rewrite step goal involving literal rewriting literal applying simplification rule subformula applying loop rule loop literal call subsequence rewrite part rewrite goal goal rewrite system triple goal rewrite rule rule simplification rule loop rule rewrite goal rewrite system like term rewrite system dershowitz jouannaud everywhere terminating step terminating step subgoal depend history rewriting desirable property rewrite system property termination confluence rewrite system posse property canonical system canonical system final rewriting goal rewriting rewriting simplification system terminating literal rewriting generates rewrite clear goal rewrite system terminating finite goal normal form rewritten rule goal rewrite system finite rewrite finite rewrite normal form goal rewrite system confluent rewrite rewrite goal rewrite system finite confluent goal rewrite system sound stable case rewrite system abduction next rewrite system abduction abducibles abducible literal abducible counterpart rewriting framework abduction straightforward framework clark abducibles abducible goal remain unless eliminated simplification rule like rewrite rewrite rewrite abducible literal rewrite rewrite system abducibles show sound stable semantics przymusinski answer semantics answer also stable sometimes answer answer assign truth stable true undefined adopted yuan ground default negation propositional derivation default negation treated atom stable maximal fixpoint applies twice satisfying atom undefined notationally represents undefined answer also stable case fixpoint finite goal rewrite system soundness literal rewrite abducible literal consistent stable completeness atom literal stable rewrite loop loop literal loop also dung wellknown loop stable answer coincide show goal rewrite system exactly loop goal rewrite system rewrite abducible literal consistent loop arbitrary boat clark abducibles rewriting terminates step explanation prime implicants disjunction explanation work traditionally programmingproof procedure abstractly term derivation refutation termination hand separation semantics completeness stated resorting termination completeness rarely guaranteed hand separation also procedure deal nonground undecidable even answer loop handling semantic sound procedure thus distinct feature work loop handling termination semantics completed used answering abductive procedure console denecker schreye fung kowalski procedure semantics certainty mode reasoning computing binding existential goal true indented case reasoning mode brave establishing true work closely procedure procedure eshghi kowalski sound ground stable giordano besides loop handling termination extent goal rewriting system simulates nontrivial incurs backtracking backtracking simulated rewriting disjunction loop negation handled flat rewrite feature plus loop handling made formalize system rewriting system benefiting property term rewriting literature also distinguishes rewrite system fung kowalski seems remarkable form nonmonotonic reasoning rewriting area little connection previously illustrate feature questionwhether answer reasoning must must contradiction note reasoning need remember previously case exactly done twice backtracking conclusion reached rewriting proving ground goal idea derived goal ground obviously rule body also head ground goal rewritten ground goal domain restricted niemela instantiated domain head resulting also next domain restricted framework abduction computing successor axiom causal logistics domain truck package know truck package time package truck truck move package truck initially package initially package truck initially truck moving package moving truck package truck moving truck taol taol paol paol rule axiom rule causal rule package truck package truck rest frame axiom frame axiom help taol truck initially elsewhere instantiated finite loop rewrite system note omitted domain body rule refer thus domain restricted need instantiated fourth sixth rule domain abducibles show time false true true package must initially inside truck moved truck computation took true package initially inside truck piii varies like time hardest took minute system alternative computing mentioned abductive explanation kakas mancarella actually computing abductive explanation clause satoh iwayama fact correspondence abductive explanation answer answer smodel generating answer many answer case answer roughly half hypothesis even like know moment answer work extending work rewriting restricted decidable extend form abduction straightforwardly extending rewriting system accordingly acknowledgement like thank ilkka niemela helpful satoh comment work part grant council hong kong competitive earmarked grant work carried mainly visit hong kong academia sinica taiwan
