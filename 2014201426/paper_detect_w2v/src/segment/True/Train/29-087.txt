heart many optimization procedure powerful pruning propagation rule case construction rule decreasing best find optimal packing branching rule well decreasing best powerful pruning rule derived remaining subproblem constructed modular arithmetic decompose show pruning rule overhead runtime whilst significantly hardest runtime magnitude demonstrate propagation rule built lookahead pruning rule optimization procedure built branching rule good pruning propagation rule derived remaining subproblem combinatorial construct optimization procedure korf demonstrated convert partitioning branching rule optimization procedure korf concluded combinatorial namely took good made long continues eventually optimal korf test closely packing decreasing best epsrc award thank paul shaw shortfall korf optimization procedure also benefit pruning rule terminate unproductive line propagation rule branching forced identify pruning rule derived remaining subproblem constructed modular arithmetic decompose pruning rule need cheap test overhead runtime whilst significantly node explored pruning rule harder constrained show propagation rule derived pruning rule derive pruning rule domain partitioning knapsack pruning reasoning modular arithmetic pack equally sized leaving empty parity tell impossible size unit clearly impossible pack even leave empty generalize reasoning base suggests optimization procedure construct branching rule good pruning propagation rule remaining subproblem combinatorial involving modular arithmetic able decompose suggest pruning propagation packing explore korf chose packing good packing optimization procedure packing practical many business like post office real packing economical slatford yeadon scheduling processor allocation fabric cutting vlsi circuit size delay modeled packing packing sense garey johnson packing subproblems encountered partially full show many like partitioning seen packing packing spare garey johnson decreasing best best packing best next fullest accommodate exceeding simply sort decreasing best largest thereby packed guaranteed asymptotically time optimal best time optimal garey johnson branching rule optimization procedure packing follow korf convert decreasing best branching rule decreasing best optimization procedure computes need tree exhausted packing incremented relaxes sufficiently make packing easy sorted decreasing packed branching rule branching rule made decreasing best pack next fullest accommodates make optimization procedure must decide branching rule backtracking natural full branching rule thus pack next fullest accommodates backtracking unused branch terminates successfully packed branch terminates unsuccessfully force backtracking next packed next exceeds largest unused avoid duplicating branching rule pack unused never open consequence packed worst case packing explores packing pruning rule packing imposes decompose take modulus base base show operation binary base used little extra cost spare distributed construct containing dummy find packing strictly take modulus side base unfortunately know give left hand side worst derive fact applying repeatedly left hand side give summation gent walsh pruning term represents contribution expect spare term represents need contribution reach time zero packing impossible prune packing spare zero parity need parity zero pack packed contribute unit spare need packed pruning reflects zero pack checking efficiently make modulus used base many computation base reused next digit digit reuse calculated made operation longhand subtraction slightly fact show simply initialise merely node backtracking modulus indicating decremented combine initially find base node subtraction longhand base decremented borrow digit borrow cbmod operation node thus subtraction case operation decrementing incrementing backtracking divided decrement decrement take logn time practice take machine operation thus checking base overhead modular pruning affect make practical natural base base used reported take binary modulus cheap need subtraction longhand borrow computing mcgeoch pack twice size drawn pack exploratory test show difficulty worst case sample packing size took node branch data suggests difficulty dependent spare modify predetermined spare parameter spare construct packing pack leave spare distributed final need give spare assign throw away experimented spare broadly spare spare rest restrict spare overhead modular pruning cdbf practice give scatter plot node searched find optimal packing time modular pruning leave spare packed prune base coded lisp network identical alpha processor graph pruning overhead runtime regression node suggests overhead decline nearly linear graph also practice node searched proxy time node searched time pruning rule reduce significantly show mean node searched find optimal packing packing spare packed cheeseman phase transition constrainedness varies pack extra hardest packing tend phase transition inbetween median percentile effectiveness pruning rule prune mean time pruning despite overhead effectiveness pruning rule also packed modular pruning reduces significantly harder runtimes reduce magnitude even phase transition took mean node searched size modular pruning pruning rule node searched time overhead conclusion pruning rule overhead reduces significantly hardest runtime magnitude tree explore exhaustively like ilds korf systematically explores made branching heuristic ilds undo branching mistake high tree little cost well taking pruning propagation rule pruning multiply packing modulus pruning opportunity test hypothesis plot median percentile node searched pruning derived multiplying varying show modular pruning reduction regular pruning possibility reduce node searched reduction shorter runtimes harder modular pruning modular pruning propagation rule propagation rule branching forced davis putnam satisfiability procedure davis putnam unit propagation rule assigns truth unit clause forced rule contributes significantly effectiveness davis putnam procedure propagation rule constructed suitable pruning rule gent walsh modular pruning davis putnam procedure also empty clause pruning rule prune empty clause unit propagation rule merely empty clause pruning rule unit clause looking ahead instantiate false empty clause pruning rule fire assign true precisely unit clause propagation rule unit clause assign true construct propagation rule pruning rule packing identical fashion base propagation rule pack largest modulus test pruning reject prune reject pack relevant cost base show median percentile node searched propagation rule despite overhead reduction shorter runtimes harder cdbf modular pruning modular pruning propagation domain subset subset target subset garey johnson packing pruning subset meet target impossible find subset confirmed zero partitioning garey johnson partitioning packing assumed construct pruning applies middle constructed partitioned remaining packing give pruning boumd note term fixed break agrees intuition able deduce modular arithmetic fill derived inexact partitioning necessarily construct extra dummy unit knapsack also target knapsack knapsack reach target exceeding garey johnson simplicity case wish find subset packing spare work korf converted greedy partitioning branching rule optimization procedure korf pruning rule korf used analogue pruning rule modular pruning mcgeoch extensive best decreasing decreasing best mcgeoch decreasing gave packing empty packing tended statistical excess distribution tends packing asymptotic scheme papadimitriou modular arithmetic reduce grain size replaced quantum size knapsack cryptosystem merkle hellman receiver deciphers encoded message multiplying knapsack taking modulus give knapsack rapidly brickell communication cited lagarias odlyzko suggested difficult cryptographic knapsack many converting modular bright describes parallel sack modular arithmetic eliminating part conclusion main contribution pruning propagation rule packing closely pruning rule constructed decomposing modular arithmetic incorporated rule optimization procedure decreasing best showed pruning rule overhead runtime whilst significantly hardest runtime magnitude demonstrated propagation rule built lookahead pruning rule many identify good base pruning contribution make packing pruning many like subset partitioning knapsack modular arithmetic constructing pruning propagation rule combinatorial involving propagation rule lookahead pruning rule fourth optimization procedure domain construct branching rule good pruning propagation rule derived remaining subproblem
