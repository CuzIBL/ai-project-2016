show node ordering combined parallel window quickly find nearly optimal show node ordering node window process simultaneously cost threshold combine idea parallel window node ordering process parallel window used find nearly optimal quickly optimal optimality time heuristic artificial intelligence eight puzzle relative fifteen puzzle eight puzzle frame containing numbered tile empty legal operator slide tile horizontally vertically adjacent blank blank task rearrange tile configuration desired goal configuration real presidential young investigator award grant chris ferguson helped derive limitation pure window produced felderman othar hansson draft review substantially andy mayer also contributed much work done machine equipment grant ucla hewlettpackard work done intel hypercube tool traveling salesman shortest simply tour city visited heuristic hart node cost path node cost reaching goal node arrive cost path goal pass node work expanding next node goal node guaranteed optimal lowest cost heuristic never cost cheapest path goal practice practical exponential memory limitation overcome korf work iteratively searching iteration branch last node path exceeds cost threshold iteration threshold iteration heuristic succeeding threshold exceeded threshold successive iteration continue goal node memory linear optimal case node ordering node reduce time serial time last iteration time iteration final iteration pure parallel window processor look threshold simultaneously time final iteration show node ordering pure parallel window retains good ameliorating describing ordered parallel window analyze parallel window perfect ordering empirical data showing high high parallel window reader referred powley node ordering obvious time last iteration child hope node goal reached perfect ordering scheme goal iteration goal node case time last iteration exponential linear simplest type node ordering explore child node static heuristic node ordering show compensate overhead incurred ordering sophisticated form node ordering node child node frontier node node equivalently decreasing beneficial node ordering main intuition behind scheme expect accurate analogy fixed feel confident tomorrow shop mechanic feel confident brought yesterday rule node probably know work studied think node tree explored motivation node ordering goal left beneficial node ordering also reduces time find goal node expanded final iteration lead goal threshold subtree node must explored fact picking frontier node iteration reduce size subtree beneath node magnitude stay must correspondingly decrease decrease reaching goal decrease goal node thus node tend subtrees iteration even node ordering goal left node explored find goal thus combine reduce node must explored unsuccessfully goal analogous searching buried treasure island probability treasure well cost simon goal maximize treasure minimize cost find thus find quickly also minimize time spent digging empty hole node ordered goal located node checked time minimizing node explored incorrect fortuitously case ordering maximizes limitation serial node ordering even good node ordering dramatically decrease time spent last iteration iteration goal iteration must completed node explored best goal rightmost node unordered case leftmost node ordered case unordered explores goal iteration frontier ordered explores path goal iteration best case reduction node unordered case powley heuristic branching formally frontier node threshold note even perfect ordering unordered happens leftmost goal perfect ordering goal unordered case percentage frontier perfect ordering powley korf node ordering ideal ordering scheme iteration done frontier node iteration ordering collected data korf node ordered unordered case ordered case node final iteration unordered case unfortunately ordering impractical must iteration requiring exponential memory inordinate ordering overhead reflects best achieved save frontier dynamically reorder iteration node frontier deepest path achieved searching recorded frontier node searched decreasing path corresponds used parallel ordering node ordering empirically unordered ordered ordering scheme moderate difficulty korf ratio node unordered case node ordered case practical mitigated overhead ordering ordering slower serial million million node minute hewlett packard workstation resulting worthwhile ordering scheme domain branching next complementary improving overcome limitation serial ordering pure parallel window idea parallel window process threshold window simultaneously hoping find threshold explored sequentially optimal optimality guaranteed completing shallower threshold best goal window originated game baudet kumar game tool tree baudet parallel aspiration parallel window fundamentally process threshold iteration goal iteration unfortunately time dominated time last iteration even parallel next pure parallel window limitation pure moment pure find optimal best elapsed time relative process optimal threshold searched analyzed goal powley show relative approximately heuristic branching fraction frontier node must searched find goal case rightmost goal reduces represents lowest pure parallel window goal midway infinity time window find leftmost goal insignificant time find leftmost goal depend goal time goal iteration pure parallel window density find optimal optimal identical processor optimal threshold threshold past optimal goal located fraction frontier goal find must explore time frontier node find goal heuristic branching goal shifted left exploring many optimal density optimal density expect find density domain puzzle density optimal density threshold past optimal puzzle ratio goal density optimal goal density threshold past optimal threshold past optimal ratio size unable data believe even thus density also affect time parallel window find domain relatively high density window parallel window node ordering interestingly limitation strength node ordering pure window complementary node ordering time iteration final iteration efficiently conversely pure parallel window final iteration incurs cost iteration suggests combine pure parallel window node ordering refer simply parallel window parallel window process work process expands root node relatively fixed frontier node process identical fixed frontier process threshold window process chooses node threshold completing node process leaf node searching node additionally path node leaf node also recorded used ordering process selects unsearched node searched process broadcast ordering process message node path threshold ordering process also save copy ordering process process next threshold searched ordering message process message deepest threshold process picking unsearched node process beneath path rest node process find process searching shallower threshold best continues optimal verified verification optimally completing threshold optimal thus time optimal verifying optimality find quickly optimal optimality exit verified optimal find good quickly computing optimal perfect ordering time find case perfect ordering make exponential find linear time ordering completed threshold perfect ordering completed threshold process receives ordering restarts threshold processor alternatively optimal process threshold find find ordering threshold ordering perfect find frontier node threshold call node ordering powley korf node ordered thus node node find goal process interrupted restarts receives ordering process searching interrupted process searching shallower time time shallower tree grows exponentially asymptotic time long take find time time ordering process plus time process node time dominated time unordered time dominated time ordering note ordering help ordering process ordering threshold must completed time minimized balance best case optimal applies optimal process process time need process process soon ordering process completes sooner achieved process ordering process leapfrog tool process process thus process sufficient find time note process delay process threshold thus time find process optimal happens process density optimal density find reduce time hand process threshold relatively density process unproductive shallower domain want window even benefit deeper window decrease parallel window many processor effectively desired window achieved extra processor used window processor threshold korf ordered node serial processor ranging time find difficult used take long processor processor consistent case calculated heuristic branching branching measuring reduction node tell much branching serial find time parallel serial time parallel best case expect heuristic branching relative processor reduction heuristic branching believe monotonically decrease difficult extra process help process process reduces time density consistency reduction lends parallel window reduces exponential give idea seven hewlett packard workstation node million million node difficult hour billion node processor move optimal minute million node process processor elapsed real time corresponds minute million node time processor process take relative seven processor optimal twelve move optimal mode move optimal optimal puzzle move optimal indication strength also korf variant optimality sacrificed make move fixed time sense unfair currentposition move made instructive processor varying horizon node processor removing half case shorter case move case move case show dominated thus competitive term conclusion effectiveness node ordering improving time iteration conversely window process simultaneously iteration time final iteration combining node ordering window sharing ordering process make find nearly optimal quickly continues past find increasingly optimal guaranteed time exhausted real quick optimal resource make predict resource apriori must plausible parallel window
