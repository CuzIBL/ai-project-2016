analyzes frontier multiobjective framework frontier multiobjective formal property multiobjective adequate monotone heuristic systematic graph proceduresare classified former take optimality prune path never lead recorded dijkstra hart pruning drastically reduce path explored graph memory exponential memory linear case consideration exponentially path like korf rbfs korf carried retain benefit path pruning keeping reasonable memory frontier korf reported successful sense multiobjective much computationally demanding scalar counterpart particularly memory practical limiting multiobjective route planning alechina logan domain planning refanidis vlahavas reported queue size limiting resorted scheme numberof alternative multiobjective multiobjective case stewart white mandow perez cruz multiobjective harikumar kumar dasgupta multiobjective rbfs analyzes frontier multiobjective framework scalar frontier monotone property heuristic discard unnecessary node achieving memory explained node deletion criterion multiobjective deletion criterion broader property describes scalar frontier examines multiobjective introduces frontier formal propertiesand conclusion work outlined scalar frontier shortest path stated locally finite labeled directed graph node labeled cost node goal node find cost path node scalar like build tree rooted node best path node node expanded kept list closed node waiting kept list open node keeping closed list make memory exponential node serve firstly path node cost path tree best path kept pruned drastically reduce path need explored closed node path goal node reached path quickly recovered tree functionf rank open node selects node cost path stored tree heuristic cost node goal node satisfies monotone property node optimal path monotone heuristic optimizes simplifies path pruning path closed node pruned straightaway closed node ever back open frontier make interested cost optimal goal node reached optimal optimal path graph searched undirected also heuristic monotone frontier keep benefit path pruning drastically memory idea memory open list closed list expanded node frontier keep vector used operator node vector neighboring node reached operator accessible node initially vector time node expanded successor reachable unused operator recall node optimal path node mean path ever never need back open neighbouring node operator reach form marked used pruning path reach even actually never reached path safely removed memory frontier relaxed make korf relaxed compromising admissibility frontier monotone heuristic rule frontier mimic node admissible multiobjective frontier multiobjective multiobjective stated locally finite labeled directed graph node labeled node goal node find cost path node main distinguishing feature multiobjective fact cost vector induce preference dominance vector vector rank vector anddominates dominance vector vector nondom vector mandow perez cruz frontier multiobjective refinement stewart white memory behaviour build acyclic graph rooted nondominated path node path node cost reaching nondominated path kept dominated pruned keep node cost vector path reaching explored expanded open path explored made tuples heuristic nondominated cost vector path goal node path cost heuristic vector selects open path heuristic vector nondominated open goaln cost keep track goal node cost nodominated time dominated alternative filtered open proceeds open empty multiobjective many nondominated path reach node cost vector stored dominates memory node play minor role regrettably nondominated path node prevent nondominated path enter even monotone heuristic used stewart white lemma note even vector cost expanded path discarded consideration need kept prune dominated path reaching expandednodes preventsa trivial scalar frontier multiobjective case determining nondominated path node central frontier frontier multiobjective scalar counterpart find adequate criterion node cost vector expanded path safely deleted memory previously explained straightforward monotonicity providethe property scalar nondominated cost vector frontier node deleted memory node frontier vector operator deletion flag expanded flag deletion node deletion nondominated path marking used operator node deletion path leading expanded operator successor leading marked pruning path leading even actually node deletion node deletion actually deleted memory checked iteration step note node must frontier even reached alternative newly path dominated cost step node discarded really path need kept frontier case operator marked severe multiobjective frontier cost vector deletion cost vector stored memory dominates memory consumption cost vector deletion node marked deletion removed memory step additionally time path cost vector removed discarded step rationale behind cost kept prune dominated path node marked deletion neighbouring node mark operator path ever reach virtue node marked deletion cost vector well node actually deleted show sample graph multiobjective cost node loss generality heuristic used heuristic vector criterion path node deletion real cost vector heuristic vector open path sense differently initially node open frontier path initialization node frontier open list pair empty goaln cost termination open empty goal node goaln nondominated cost cost path alternative open heuristic open dominated cost marked deletion remove else move recording eliminate open dominated alternative path successor node cost calculate path dominated cost node frontier ifthen else ifgm nondominatedin prune vector dominated ifthen frontier node frontier expanded marked deletion deletion mark deletion successor mark operatoras marked deletion remove frontier back step frontier multiobjective dominates open vector deletion deleted fact deleted memory operator marked show trace node frontier graph showing path iteration path cost cost deleted open closed labeled node path told nondominated path broken arbitrarily iteration path path deletion nondominated path reach descendant closed path must remain memory iteration nondominated path deletion fact deleted marking operator nondominated path ever reach cost closed path dominates cost open path node deletion deleted cost vector path leading dominate open path deletion never expanded must remain memory iteration path deleted memory iteration path deleted whole node deleted well iteration path nondominated path path recorded cost goaln open path dominated filtered removed open iteration remaining open path recorded terminate node reached nondominated cost property provesthat mimic terminates nondominated cost goal node cost marked deletion nondominated path trivial deletion marked iteration node reach iteration must alternative open iteration letbe cost marked replaces monotonicity heuristic scalar frontier monotonicity real cost analogous korf never regenerates node deleted frontier path sample frontier node path cost operator dashed node deleted sample contradiction node regenerated path nodewas deleted deletion expanded deleted must regenerated expanded regenerating contradicts node regenerated must never deleted expanded must frontier recall graph undirected marked deletion operator marked path leading ever regenerate contradicting regenerated rule expands node induction stronger iteration open alternative true iteration open alternative path iteration exactly open alternative rule open alternative succesor reached cost vector open alternative dominated bygm eliminated path dominated cost calculated case node graph made dominated vector eliminated behave node unconditionally frontier open alternative ignored open alternative open alternative terminate open alternative empty performthe path heuristic monotone mean mimic even heuristic used note frontier find optimal heuristic node deleted open node ensures optimal path deleted node test cost vector time cost vector time cost vector time cost vector time cost vector time cost vector time test test carried grid node size cost grid used heuristic test reported multiobjective intentionally relatively size show memory time latter difficulty iteration path difficulty note logarithmic scale statistic summarized storage cost vector fastest barely distinguishable scale extra frontier step time overhead time requiredby algorithmis well exponential time linear fact simplest minute overhead significantly delaying frontier evey iteration overhead branching memory cost vector normally tiny fraction memory show time memory plain labeled suggests responsible memory becoming increasingly difficulty iteration memory cost vector difficulty iteration scale time difficulty iteration delayed memory time conclusion work considers frontier multiobjective framework regrettably monotone heuristic trivial scalar frontier multiobjective case determination safe criterion deletion expanded node cost vector turn criterion proven preserve admissibility multiobjective even used show memory significative make alternative time overhead deletion criterion greatly loss memory multiobjective frontier fill tradeoff work formal make multiobjective domain also work
