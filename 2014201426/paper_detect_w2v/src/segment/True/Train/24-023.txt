extends shapiro inference system synthesizing refinement operator clause upon prolog skeleton prolog control flow prolog practice shapiro system introduced skeleton familiarize reader terminology inference system equipped refinement operator contrasted shapiro strength weakness applying skeleton synthesizing prolog inductive learning counterexample artificial intelligence concern case inductive learning synthesizing prolog incremental inductive inference shapiro synthesizing shapiro inference system removal false clause inability goal true find clause justify truth goal anyone experimenting quickly discovers easy learn synthesized difficulty scope system traced refinement operator used clause employed clause refinement operator influence upon scope system focal refinement leon sterling dept case western reserve cleveland ohio operator refinement operator work decomposing prolog skeleton prolog control flow prolog practice shapiro refinement operator clause time operator refinement clause fact time learn clause refinement operator clause checking previously refuted clause refrain repeating mistake equipped operator inference system skeleton misst misst refinement operator phase phase match data skeleton control flow skeleton accomplished creating template synthesized skeleton phase enhances skeleton applying checked correctness type hard impossible learn easy learn system examine implication cite area inference system inference system incremental inductive inference counterexample horn clause clause counterexample true tree used faulty clause removed explained clause clause refinement operator major system oracle know truth falsity ground learned refinement operator determines type prolog learned refinement operator shapiro specialized generating clause definite clause kirschenbaum sterling grammar operator operator operator synthesizing type generalised refinement operator misst need access successfully synthesize type target supplied user type mode used instantiated guide clause creation goal goal clause instantiation specified type mode part database list instantiation type list instantiated refinement operator instantiate removing instantiate list instantiate head clause list possibility case list head list tail instantiate head clause list possibility case list head list tail unify goal generates goal test goal head specialized clause refinement operator goal clause goal substitution true shapiro eager lazy adaptive eager find clause goal user truth goal body powerful sense fact synthesize obvious drawback numerous user lazy behaves opposite goal true checking hypothesized clause lazy powerful eager requiring assistance user adaptive like lazy adaptive user learning acquisition goal checking fact goal also checking fact body clause kind synthesized seen append synthesized eager repeat loop allowed tree default used possibly empty horn clause background goal target true repeat read next counterexample list true false repeat derive fact false find false clause remove horn clause representing hypothesis impossible derive fact true refinement previously untried clause fact clause horn clause neither test entered horn clause forever skeleton idea stepwise refinement used clear well structured wirth collection prolog literature lacking stepwise enhancement missing kirschenbaum sterling lakhotia sterling stepwise enhancement delivers structured procedural prolog attempted isolate control flow embody skeleton skeleton extra computation applying call yield combined desired regarded skeleton repeat process final refinement made process repeated stepwise enhancement manipulating recursive data prolog strength handling recursive data naturally partitioned skeleton control flow skeleton constitute block need process list want skeleton want process list find skeleton need mentioning slight modification base case skeleton skeleton computation built upon characterization skeleton term control flow conceived term goal accomplished counting list node tree goal reduction tree prolog practice like feature build upon calculate traverse find list variant calculate type arithmetic operation skeleton extra goal intuitively think skeleton control done data skeleton make explicit control flow follow consequence restriction induction prolog nondeterministic predetermined control flow separation control flow main idea extra synthesis skeleton kirschenbaum sterling misst clause prototype misst system restricted list data skeleton choosing list recurse upon determining reasonable base case made knowing oracle answer posed system also presence detailing allowable clause creation skeleton target testing updating like generality head clause even worse goal body clause reasonable possibility skeleton list many possibility quick clearly show arity skeleton used skeleton case skeleton come head clause skeleton skeleton poorly skeleton misst mode unify extra head clause type unify type incompatible exclusive type used used restriction used clause like avoid clause binary accomplished opposite predl tell kirschenbaum sterling switched symmetry want clause clause identical last recursive call recursive skeletal clause recursive last goal used creation clause pruning redundant clause sense meta term machine learning background preference criterion bias learned skeleton creation phase thought describable restricted hypothesis kind bias utgoff collect sought upon goal head list calculate mentioned upon goal clause head list combined applying collect skeleton list remaining case head list never list generates remainder misst fact target prolog creates skeleton mentioned turn enhancement module clause remove incorrect clause counterexample supplied clause final thus skeleton creation enhancement module learned misst synthesize list used type collection last restriction overcome clear slow system used prefix suffix append sublist nonmember subset parenthesis name refers used prolog sterling shapiro also used intersection code learning acquisition code intersection code case exemplifies collect unfortunately misst upon also remove redundant clause learned prefix demonstrates unwanted removing redundant clause computationally practically avoiding redundant clause take hypothesized clause form clause selecting base clause plus recursive clause proven clause repeat base case base case also recursive clause redundant prefix suffix append easy system learn surprisingly append easy learn refinement operator give high priority expanding unifying list misst append nontrivial learn clause refinement operator clause feed system counterexample weed inappropriate clause subset difficult misst learn learned produced produced subset infinite loop misst recognize default numerous clause tested slow process nonmember synthesized took memory synthesis even goal synthesized code subset subset subset subset prolog comprised fourth clause easy learn caused fail learn subset even eager employed memory refinement operator used give priority expanding goal clause expanded difficult learn call numerous goal subset make nonmember nice feature misst seen synthesis nonmember previously system user interact system time made list clause free user system clause generalize target goal previously synthesized weakness misst volume clause produced removal duplicate clause produced misst asserted hypothesized clause operation system duplicate clause removed feed system counterexample weed inappropriate clause judicious counterexample system modify misst keep clause list processed time combinatorial explosion clause restriction made misst expanded goal body clause restriction made impossible synthesize remove repeated list restriction removed explode clause believe work upon learning introduced skeleton truly bottleneck misst need form relationship list list recursed upon something else minimize skeleton think skeleton creation started process learning misst difficulty know started learning system skeleton learning exercise captured misst reduce clause requiring much user user give recursed upon clause half promising insight structuring skeleton creation work deviile specification overlap misst also extra multiplicity deville induction scheme also relevant modifying skeleton shifting weaker bias utgoff heuristic deciding exactly modify skeleton creation process need work done muggleton buntine framework prolog induction introduces supplied inverting resolution tool used weaken bias time know usefull skeleton thank prose stimulating conversation work leon sterling part grant
