a task-independent experience-gathering scheme for a problem-solver 
j. r. quinlan 
computer science department 
   carnegie-mellon u n i v e r s i t y p i t t s b u r g h   pennsylvania u.s.a. 

a b s t r a c t . a scheme f o r a l l o w i n g a problem-solver t o improve i t s performance w i t h experience i s o u t l i n e d . a more complete d e f i n i t i o n of the scheme f o r a p a r t i c u l a r problem-solving program is g i v e n . some r e s u l t s showing the e f f e c t i v e n e s s of the scheme are r e p o r t e d . 
key words. p r o b l e m - s o l v i n g   h e u r i s t i c search  d e p t h - f i r s t   c l a s s i f i c a t i o n o f o p e r a t o r s   o r d e r i n g of o p e r a t o r s . 
i n t r o d u c t i o n 
       it is not at a l l c l e a r how a problem-solver should improve i t s performance as it s o l v e s   or f a i l s t o s o l v e   the problems presented t o i t . i t is c l e a r   however  that such improvement is necessary if problem-solvers are ever to compete succ e s s f u l l y w i t h human beings. moreover  the improvement cannot be r e s t r i c t e d to r o t e l e a r n i n g of r e s u l t s ; what is needed is some equivalent of a human b e i n g ' s a b i l i t y to detect analogies between problems. this paper o u t l i n e s one scheme that has been implemented and tested f a i r l y e x t e n s i v e l y . although d e t a i l s are given f o r a p a r t i c u l a r problem-solving system  the general philosophy is a p p l i c a b l e to most d e p t h - f i r s t problem-solvers. 
       a problem  in t h i s c o n t e x t   is a t r i p l e cons i s t i n g of a state  a goal and a set of operators  a s t a t e is some o b j e c t : a w e l l - f o r m e d formula  a 
       p a t t e r n or somesuch. a goal describes some hypot h e t i c a l s t a t e or set of s t a t e s . each operator 
maps some set of s t a t e s i n t o another s e t . a solution to a problem is a sequence of operators t h a t maps the given s t a t e i n t o another s t a t e that 
matches the g o a l . for example  a s t a t e could be an a l g e b r a i c expression  a goal another a l g e b r a i c expression  and the operators r u l e s f o r changing expressions i n t o equivalent expressions. a s o l u t i o n would then be a schoolboy-type demonstration that the s t a t e and goal expressions are equiva l e n t . this d e f i n i t i o n of problems and s o l u t i o n s c l e a r l y includes h e u r i s t i c search problems.1 
       figure 1 shows a p a r t i a l o u t l i n e of a depthf i r s t method f o r f i n d i n g s o l u t i o n s t o such problems. for any  sub problem  s g r  a set a of operators is s e l e c t e d   one or more of which may h o p e f u l l y lead to a s o l u t i o n . each of the opera t o r s is t r i e d u n t i l one leads to a s o l u t i o n or the set is exhausted. many e s s e n t i a l mechanisms have been omitted from t h i s s k e l e t o n   p r i n c i p a l l y how the set of operators is s e l e c t e d   what new problem is t r i e d when an operator is chosen  and what happens when a subproblem is solved. these vary from system to system  and  w h i l e they are c r i t i c a l to the performance of any system  the experience-gathering scheme is independent of t h e i r form. 
given a problem   s t a t e a goal g operators r  proceed as f o l l o w s : 
1. if 1 matches the d e s c r i p t i o n g  r e p o r t success on t h i s problem. otherwise  s e l e c t a subset a of r; these are the operators to be t r i e d . 
1. if a is empty  r e p o r t f a i l u r e on t h i s problem. otherwise  choose an operator x in a and delete x from a. 
1. attempt a new problem based on the current problem and operator x. if f a i l u r e is reported on t h i s new problem r e t u r n to step 1. 
figure 1. 	skeleton of d e p t h - f i r s t problem-solver. 
       such a problem-solving schema could make use of 'experience* in a number of ways. the two obvious ones are to guide the s e l e c t i o n of the set a of operators to t r y   and to choose which opera t o r x in a to t r y next. the s e l e c t i o n of the set a  however  is t y p i c a l l y performed by some a l g o r i t h m which i s not s u f f i c i e n t l y f l e x i b l e t o a l l o w 
m o d i f i c a t i o n by e x p e r i e n c e . 1 the scheme given here is based on the second a l t e r n a t i v e . each operator x in a w i l l be assigned a w e i g h t   d e t e r mined from past experience  which represents an estimate o f how l i k e l y i t i s t h a t t r y i n g x w i l l lead to a s o l u t i o n of the problem  1yg r . when choosing an operator from a  the one w i t h the highest weight w i l l b e t r i e d f i r s t . 
       the f i r s t question i s   where i s t h i s weight to come from  we would l i k e to have weights assoc i a t e d w i t h operators in the context of problems. in any i n t e r e s t i n g task environment  the operator and problem spaces are l a r g e   i f not i n f i n i t e ; i t is c l e a r l y i m p r a c t i c a l to associate a weight w i t h every p o s s i b l e operator-problem p a i r . the way out adopted here is to c a t e g o r i z e operator-problem p a i r s   and associate a weight w i t h each c l a s s . the weight assigned above to x w i l l then be the weight associated w i t h the class i n t o which the p a i r  x   s g r   f a l l s . whenever a problem is s o l v e d   the t a b l e of weights associated w i t h the classes w i l l be adjusted in an attempt to correct any mistakes in the order operators were t r i e d . 
       the c r i t i c a l f a c t o r here i s the c l a s s i f i c a t i o n of the p a i r  x   1 g r  . one reasonable approach would be to look at how easy it would be to apply a: to e   i . e .   to get the s t a t e i n t o the domain of the o p e r a t o r     and how much the use of x would advance s towards g. suppose we had a measure q y z  of the ' s i m i l a r i t y . of s t a t e y to goal 1  and t h a t t h i s measure took on one of n p o s s i b l e v a l u e s . then the approach would c l a s s i f y 
-1- x s g r   	by examining q s  'x should be applioable'  and q x s  g *. in fact  the simplest such categorization is used; two operator-problem pairs f a l l into the same class i f f each of the above similarities is the same for both pairs. 
　　　the next section is an amplification of the above for the fortran deductive system  fds .1 1 for this system it is possible to develop a taskindependent similarity measure  and thus a taskindependent classification scheme. 
a more detailed look 
　　　at this point it becomes necessary to discuss some details of fds so that a more complete treatment of the experience-gathering scheme for this system can be given. 
　　　states are represented as trees with a symbol at each node  where a symbol is a binary or unary connective  free variable or constant. 	each possible node position on such a tree is numbered as follows: the root of the tree is numbered 1  and the right and l e f t successors of node n are numbered 1nc+l  1n+1 respectively. 	figure 1 shows two states with the number of each node in parentheses beside the symbol**. 

	figure 1. 	two states. 
　　　goals are represented as strings of conditions  each of which is of the form 'node n should be the symbol q' or 'the subtree whose root is node n should be identical to the subtree whose root is node m'. each of the above is called a condition on node n. 
*1 may not be in the domain of x. in this case an estimate of x s  is used. 
**for the examples given in this section  the notation of elementary algebra w i l l be used. 
　　　rewriting rules take the form yi=z  where y and z are states. a rewriting rule informs the system that any instance of y can be mapped into the corresponding instance of z. each rewriting rule defines an i n f i n i t e number of operators of the form 'use rule number m to rewrite the subtree whose root is node w1 for any non-negative n. the above operator w i l l be written 1 m n  . 
　　　the domain of an operator 1 i j  can be described by a goal g isj  as illustrated in figure 1. first  a rewriting rule  number t  say  is 

given  then the goal which is satisfied by a state i f f that state lies in the domain of 1 i 1 . the f i r s t state 1 in figure 1 satisfies g i 1   the state 1 i 1  s  into which 1 i 1  maps 1 is shown. 
　　　let 1 be a state  g a goal. a condition  on a node rri  in g is satisfied by a if 
i. 1 satisfies a l l conditions in g on nodes 
from which node m is descended  and 
ii. 1 has the property required by the condition. 
for example  consider the second state of figure 1 and the goal 	g i 1  	of figure 1. 	the f i r s t condition is satisfied  since there are no conditions on antecedents of node 1 and the symbol at node 1 
is 	f - ' . 	the second condition is not satisfied  for although i above is true  node 1 is not the symbol ' + ' . 	finally  the third condition is not satisfied  even though the subtree whose root is node 1 is identical to the substate whose root is node 1. 	requirement i above is not met  since the second condition is not satisfied and node 1 is a descendant of node 1. 
　　　the definition of states  goals and operators in this section is more restrictive than the corresponding concepts presented in the introduction; within this limited framework we can define a 

-1-

reasonable function q e1g  to measure the similari t y of state s to goal g. actually  the word 'measure* is too strong; a l l that is needed for the purpose of classification is to know whether q ab   and q o d  are equal  i . e .   whether the two states are equally similar to their respective goals. such an indicator is much easier to develop than a true measure. 
　　　we could say that  are equal i f 
i. goals b and d have the same number of conditions  and 
i i   the number of conditions of b satisfied by a is the same as the number of conditions of d 
satisfied by c. 
this does not f i t the description of similarity given in the introduction  since there is an i n f i n i t e number of possible values of  due 
to the way fds is set up  however  goals with more than five conditions are rare. taking account of this  requirement i is relaxed to allow goals with similar numbers of conditions to be lumped together  and ii is changed to specify roughly equal proportions of conditions satisfied. let x be the number of conditions in g  n the number of these satisfied by s  and y the ratio values 1 through 1 are assigned to q s g  as shown in table 1. note that these values are to be used 

only to establish equal similarity; if q a b  is greater than q o d  it does not follow that a is more similar to b than c is to d. 
　　　suppose now that the 1 classes of operator-problem pairs are numbered 1 through 1. two pairs are to f a l l in the same class i f f their states are equally similar to the goals of applying the operators  and the resulting states are equally similar to the problem goals. 	putting this another way  the operator-problem pair 
 1 i j j 	 1 g b j 	f a l l s in class 
where  if e does not satisfy is a synthetic state which looks like the result of using o   t   j   to rewrite some state. if 1 i j  were selected to solve the problem  s g r   the weight assigned to 1 ijj  would be the weight associated with the above class. fds goes one step further; it uses this weight as a base for determining a final weight  but the discussion of this process lies beyond the scope of this paper. 
　　　the experience-gathering  then  consists of adjusting the table t of weights associated with the classes. when a problem is solved  each step of the solution is examined to see whether any operators were tried before the 'correct' one  the one in the solution . if this is the case  the weights associated with the classes of the incorrect operators are decreased  while the weight associated with the class of the correct operator is increased. the adjustment formulae appear in 1. 
　　　two comments ought to be made here. first  the classification rule uses only the similarity 
measure defined above. this  in turn  is defined in terms of properties shared by a l l states and goals in fds. thus the classification mechanism is task-independent  in the sense that it is defined for any problem which can be presented to fds. since fds is a general-purpose system  this feature was a c r i t i c a l factor in the design of the scheme. 
　　　the second comment is really a query: given that the classification is defined for an arbitrary problem  is it appropriate  saying that two operators in the context of a problem f a l l in the same class is asserting that  in this scheme  they are equally likely to lead to a solution. this is a strong statement. if the classification has no connection with reality  adjusting weights associated with classes is unlikely to produce anything except random behavior. on the other hand  if significant improvement results then the classification scheme may represent a useful way to categorize operators in the context of problems. the question of the appropriateness of the scheme is best answered  then  by examining some results of i t s use. 
results 
　　　the performance of fds in four task environments w i l l be summarized. each of these consists of an ordered set or block of problems to be solved in sequence. in about half the cases the problems are theorems to be proved. a brief description of the blocks is given below; a complete definition appears in 1  some of the problems have been presented to human beings  who find them non-trivial.1 
　　　block 1 contains fifteen problems in an algebra pertaining to flowchart equivalence developed by sanderson.   the problems are taken from this thesis.  i n i t i a l l y there are twenty-six rules  but  as each theorem is proved  it is retained as a new rewriting rule. figure 1 shows the given rules  the theorems  and a sample proof of the f i r s t theorem. for convenience  states are represented in conventional bracketed notation rather than as trees. 
block a consists of eighteen theorems of 

-1-


elementary algebra concerned with the manipulation of binary addition and subtraction. there are six rules given and  as before  each theorem proved is added to the l i s t of rules. 
　　　block h is composed of twenty-five problems in lexical pattern recognition in a generalized form of that found in ledley . there are twenty rules defined throughout. 
　　　block p is a statement of a well-known puzzle. a philosopher is walking in a land peopled exclusively by goodies  who only t e l l the truth  and baddies  who always say the exact opposite of the truth . coming up to two of the residents of this land  our philosopher asks the way to the library. one mutters something u n i n t e l l i g i b l e   and the other says   he says east. he's a baddie.  which way should the philosopher go  in the formulation used there are eight rewriting rules. 
for an individual problem  the performance of 
fds w i l l be measured by efficiency  	the ratio of the number of states in the solution to the number generated while searching for i t . if a problem is solved with 1% efficiency  then there is not 
much wrong with the ordering of operators for t r i a l ! for a block  the performance measure w i l l be the average efficiency on the problems in that block. 
　　　the f i r s t set of experiments is designed to demonstrate that the scheme allows fds to improve i t s performance on a given block of problems. successive passes are made through the block  as follows. each weight is i n i t i a l i z e d at 1 and the problems of the block solved in sequence with the adjustment of weights suppressed; this is called pass 1   the average efficiency on pass 1 represents the performance of fds with no re-ordering of selected operators.  any problems retained as rules are then forgotten  and pass 1 is made permitting the adjustment of weights. any rules kept are again discarded  but the adjusted table of weights is retained  and pass 1 is made. the above is repeated u n t i l pass 1 is finished. since nothing changes between passes except the table of weights  any improvement must be due to the 'experience' represented by this table. 
　　　the results of this set of experiments are summarized in table 1. notice that  even with no 

experience  the average efficiency on each block is quite high. fds incorporates a powerful algorithm for selecting operators and screening out useless ones  and the order in which it discovers operators gives some clue to the order in which they ought to be t r i e d . the ordering  and hence the efficiency  s t i l l improves significantly on the series of passes; on pass 1  sixteen of the eighteen problems of block a are solved with 1% efficiency. although only four tasks have been explored to this length  comparable improvements have been noted in a l l the dozen or so tasks presented to the system. 
　　　but the concept of experience is stronger than this. solving problems in some area should allow the system to solve new problems better. in other words  experience should be transferable from one set of problems to another set in the 

-1-

same task environment. generally  this turns out to be the case with this scheme. consider  for example  the last five problems of each of the blocks s  a and h; call them blocks 1 '   a' and h'. we w i l l compare the average efficiency with which fds solves each of these subblocks using two different tables of weights: e  the table of pass 1  and e'  that obtained during pass 1 through the block after a l l but these problems have been solved. note that these tables of weights contain no experience from any of the problems in the subblocks. table 1 shows that  for blocks a and #  

solving a l l but the last five problems of each significantly helps the solution of these last five. 	for block s the improvement is very slight. the last five problems of block s1 however  are different from the preceeding ones  they a l l have two 	s's . 	in this case  then  a notable improve-
ment was not to be expected. as a further test  a relatively d i f f i c u l t algebra problem was presented to fds. with no experience  the system  on an ibm 1 dcs  was unable to solve it in an hour. 
on the other hand  when the experience from block a was given to fds  it found a solution in five and one half minutes. 
　　　some incomplete experiments have been made to test whether this form of experience is transferable  not from one set of problems to another within the same task  but from task to task. it has been found that this is sometimes useful  but that in most cases the improvement is insignificant. one interesting point which has emerged from these experiments is that it is possible to combine tables obtained from several tasks; the resulting synthetic table leads to better performance averaged across a l l the tasks than any of the individual tables from which it was formed. 
conclusion 
　　　on the basis of the experiments performed with the scheme  it seems f a i r to say that it works. this is encouraging when one considers the simple-mindedness of the approach. while it could only benefit from a more powerful measure of simil a r i t y   the basic idea of classifying operators in the context of problems seems to be appropriate. 
