
streamlined constrained reasoning powerfully boosts the performance of backtrack search methods for finding hard combinatorial objects. we use so-called spatially balanced latin squares to show how streamlining can also be very effective for local search: our approach is much faster and generates considerably larger spatially balanced latin squares than previously reported approaches  up to order 1; the previous best results could only generate solutions up to order 1 . we also provide a detailed characterization of our streamliner and solution topology for small orders. we believe that streamlined local search is a general technique suitable for solving a wide range of hard combinatorial design problems.
1 introduction
the idea underlying streamlining constraints  gomes and sellmann  1  is simple but powerful: in order to increase the effectiveness of propagation   streamlining constraints  partition the solution space into different portions with different global properties. since in general the streamlined constraints are not implied by the original problem constraints  the resulting search and solution spaces are subsets of the original spaces. gomes and sellmann showed the effectiveness of streamlined constraints for solving hard combinatorial design problems  in particular spatially balanced latin squares  sbls  defined in section 1 . using streamlined backtrack search methods  they solved considerably larger sbls problem instances than with local search: up to order 1  while a local search method applied to the original problem could only generate solutions up order 1.
　this paper shows how streamlining can also be effective for local search. we note that while the addition of streamlining constraints is straightforward in backtrack search methods  it is not always the case for local search methods  since constraints are in general enforced via the objective function. the key is to consider streamlining constraints that lead to an alternate neighborhood representation. we applied streamlined local search to the problem of generating spatially balanced latin squares. our streamliner defines a basic swap neighborhood as a column permutation of the input latin square. this provides additional interesting structural properties  making our local search procedure scale up considerably better than previously reported approaches. we solve instances up through order 1; the previous best results could only generate solutions up to order 1. moreover  our streamliner provides useful intuitions on a construction for spatially balanced latin squares. we believe that streamlined local search is a general technique suitable for finding objects with intricate combinatorial constraints.
1 spatially balanced latin squares
a latin square of order n is an n by n grid where each of the n1 cells in the grid is assigned one of n symbols such that each symbol appears exactly once in each column and each row. creating a latin square is by no means difficult. we can define a cyclic construction as an order n latin square where the element in row i and column j has the value  i + j  mod n  see figure 1 . the first row will have all the symbols in order:  1 1 ... n . each subsequent row is the same as the previous row with all the values shifted one location to the left  wrapping the first element to the end. thus  the second row will be  1 ... n 1 ; the third will be  1 ... n 1 ; and so on. note that the columns follow the same pattern: the first column is  1 1 ... n t; the second is  1 ... n 1 t; and the third is  1 ... n 1 t.
　one challenge comes in generating spatially balanced latin squares  sbls  where the sum of the distances between two symbols across all rows is constant for all pairs of symbols. first  we define di j k  to be the distance between symbols j and k in row i. this distance is calculated as the absolute difference of the column indices of where symbols j and k appear in row i. for example  if row i were  1 1 1   then di 1  would be |1   1| = 1. then we can define the total distance d j k  to be
	.	 1 
a sbls requires that all pairs of symbols have the same total distance:
	 i 1= j k 1= l : d i j  = d k l .	 1 
sbls are useful for agronomic field experiment design  van es and van es  1  and are compelling constraint satisfaction problems because of their high degree of structure. as
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
	 a 	 b 
figure 1:  a  a cyclic latin square  order 1 .  b  a sbls where  j k : d j k  = 1.
shown in  gomes et al. for all j 1= k in any sbls  implying that no sbls exist for orders n such that n mod 1 = 1.
1 streamlined local search
gomes and sellmann showed that a standard local search approach performs remarkably poorly at finding sbls. we hypothesize that this is due to the enormity of the search space and the global nature of the constraints. the search space is so big and the solutions are so few that the odds of local search finding a solution are very slim for all but the smallest orders. if we can cleverly restrict the search space to a small subspace which contains a higher density of solutions  we can increase the odds that local search will find a solution.
　consider the subspace resulting from starting with a latin square and restricting the search space to be a column order permutation of the original square. that is  take a latin square and swap entire intact columns to permute the order in which the columns appear. since this reordering of the columns will never make the square non-latin  all symbols will appear in all rows and in all columns exactly once   we can try permuting the column order to make the latin square spatially balanced. note that the space of column permutations of a particular latin square is vanishingly small compared to the entire space of latin squares. the goal is to find an initial latin square such that this small subspace is dense with sbls. cyclically constructed latin squares empirically provide such a subspace.
　if the initial latin square is generated by the cyclic construction  some structural properties can be exploited to speed the search. first  observe that there will be at most 
unique values of the total distance among the  pairs of symbols. to see this  define dmod j k  = min |j   k| |j   k + n| |j   k   n| .  1 
cola b c d ea- x y y xb- - x y yc- - - x yd- - - - xe- - - - -thus  dmod j k  is the distance between symbols j and k in symbol space  modulo the number of symbols  n . for example  for an order 1 latin square  dmod 1  = 1 because the shortest path from 1 to 1 is by counting 1 1  revealing a distance of 1. similarly  dmod 1  = 1 because the shortest path from 1 to 1 is by counting 1 1  revealing a distance of 1. examining the cyclic construction reveals that pairs of symbols with identical values of dmod j k  will have identical values of d j k   even if the column order is permuted. thus since there are  different nonzero values of dmod j k   there are at most  different total distances between pairs of symbols for any column order permutation of the cyclic a b c d e	a e c d b
1 1 1 1	1
1 1 1 1	1
1 1 1 1	1
1 1 1 1	1
1 1 1 1	1
	 a 	 b 	 c 
figure 1:  a  a cyclic latin square  order 1 .  b  a column permutation of the cyclic latin square. note that no matter how the
columns are reordered 
d 1  = d 1  = d 1  = d 1  = d 1  =
   |a   b| + |b   c| + |c   d| + |d   e| + |a   e| and d 1  = d 1  = d 1  = d 1  = d 1  =
|a   c| + |b   d| + |c   e| + |d   a| + |e   b|
 c  a matrix showing how the intra-column distances contribute to the pair distances. the 1 pairs of symbols correspond to group x   1    1    1    1    1   and group y   1    1    1    1    1  .
construction. as an example  if we check the total distance between symbols 1 and 1  we do not need to check the distance between any other consecutive symbols  i.e.  1 and 1  1 and 1  and so on because they will all have identical values  see figure 1 . next  note that since the columns always remain intact no matter how their order is permuted  we need only store the first row as we search for sbls. from the first row  we can calculate the d j k  corresponding to each of the  possibly distinct d j k . we also observe that we can fix the first column to be headed by symbol 1 without decreasing our probability of finding a solution: there will be an equal number of solutions with 1 heading the first column as with any other number.
　these observations naturally lead to a gradient descent algorithm. first  we define the imbalance of a square to be
	imbalance .	 1 
that is  the imbalance is the sum over all pairs of how far from ideal spacing the total spacing of the pair is. starting with a random permutation of the first row  we swap the location of two symbols such that it decreases the imbalance of the square. when we reach a local minimum  we randomize and try again.
algorithm 1 sbls streamlined local search
1: generate a latin square of order n by the cyclic construction
1: randomly permute the order of the columns
1: select a column and try swapping it with every other column
1: keep the swap which minimizes the imbalance
1: if stuck  then randomize the order of the columns
1: repeat from step 1

　finally  we note that we can generate solutions which are symmetric across the main diagonal. since spatial balance is defined as the sum of distances within rows  swapping intact
1 1 1	1 1 1	1 1 1
1 1 1	1 1 1	1 1 1
1 1 1	1 1 1	1 1 1
1 1 1	1 1 1	1 1 1
1 1 1	1 1 1	1 1 1
1 1 1	1 1 1	1 1 1
	 a 	 b 	 c 
order	1	1	1	11 1	1	11-1cp1	1ss1 1 1 1	1kcs1	11kcccp1e-1e-1e-1e-1e-1.1.1.1.1 1 1 1k 1k「1k「1mtable 1: solution times are given in seconds. cp  ss  and cs are the times to find the first solution via standard constraint programming  symmetric streamlining  and composition streamlining as reported by gomes and sellmann  as run on a 1 mhz pentium iii machine. cccp is the cyclic construction column permutation method presented here. times given are the mean time to find a solution averaged across several independent runs on a 1 ghz pentium iii machine. note that although our processor was only twice as fast  our performance is orders of magnitude better. note that the largest solution from previous methods was only order 1  while our method can find solutions up to order 1. additionally  no previous method had found solutions for orders 1 and 1.figure 1:  a  a cyclic latin square  order 1 .  b  the same cyclic latin square with the columns permuted to form a sbls.  c  the same sbls as in  b   but with the rows reordered the same as the columns to make a symmetric sbls.
rows will not affect the balancing. if we reorder the rows in the same way as the columns  the solution will become symmetric across the main diagonal and spatially balanced in terms of both the intra-row and intra-column distances  see figure 1 .
1 empirical results
the best performance on finding sbls was reported by gomes and sellmann   so we compare our results to theirs. our streamlining is much simpler than theirs and performs dramatically better. they could only generate solutions up to order 1  and were unable to find solutions for orders 1 and 1 . we have generated sbls for all possible orders up through 1. times in seconds are given in table 1.
　we also tried using our streamlining with complete backtrack search. while it improves performance over previous methods  the local search method presented here performs considerably better. in addition  we tried composing solutions from smaller cyclic latin squares using local search  but the performance was slightly worse than the simple streamliner presented here.
　although we have only discussed permuting the columns of the cyclic construction  in principle  we could permute the columns of any latin square in an attempt to find sbls. however  most arbitrary random latin squares  such as those generated by jacobson and matthews   cannot be permuted to be spatially balanced. this observation is remarkable  given that cyclic constructions are much more imbalanced than an average random latin square. for instance  the imbalance of an order 1 cyclic latin square is 1 while the imbalance of a typical order 1 random latin square is only around 1.
　through exhaustive enumeration  we analyzed the solution space of sbls for small orders. interestingly  we found that for orders 1 and 1  all the sbls can be generated by row permuting and/or one-to-one symbol remapping  that is change all instances of symbol i to symbol j  symbol k to symbol l  and so on  the sbls obtained as column permutations of the cyclic construction. however  for higher orders  there exist some solutions which cannot be derived in that way. we are currently studying the topology of the solution space for higher orders trying to identify relationships among solutions. we are also studying the matrix of distances  as in figure 1 . we believe that the characterization of solution relationships and the distance matrix provide valuable clues for the design of a construction for generating sbls of arbitrary size.
1 conclusions
we describe a competitive streamlined local search approach for generating sbls. we believe that streamlined local search is a general technique  effective for finding objects with intricate combinatorial properties. we hope that this work will inspire other researchers interested in solving hard combinatorial design problems.
