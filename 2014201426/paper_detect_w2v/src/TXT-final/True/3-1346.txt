
we investigate the properties of logic programs with aggregates. we mainly focus on programs with monotone and antimonotone aggregates  lpam a programs . we define a new notion of unfounded set for lpam a programs  and prove that it is a sound generalization of the standard notion of unfounded set for aggregate-free programs. we show that the answer sets of an lpam a program are precisely its unfounded-free models.
we define a well-founded operator wp for lpam a programs; we prove that its total fixpoints are precisely the answer sets of p  and its least fixpoint  is contained in the intersection of all answer sets  if p admits an answer set . wp¦Ø    is efficiently computable  and for aggregate-free programs it coincides with the well-founded model.
we carry out an in-depth complexity analysis in the general framework  including also nonmonotone aggregates. we prove that monotone and antimonotone aggregates do not increase the complexity of cautious reasoning  which remains in co-np. nonmonotone aggregates  instead  do increase the complexity by one level in the polynomial hierarchy. our results allow also to generalize and speedup asp systems with aggregates.
1 introduction
the introduction of aggregates atoms  kemp and stuckey  1; denecker et al.  1; gelfond  1; simons et al.  1; dell'armi et al.  1; pelov and truszczynski ¡ä 1; pelov et al.  1  is one of the major linguistic extensions to answer set programming of the recent years.
¡¡while both semantic and computational properties of standard  aggregate-free  logic programs have been deeply investigated  only few works have focused on logic programs with aggregates; their behaviour  their semantic properties  and their computational features are still far from being fully clarified. a recent proposal for answer set semantics is receiving a consensus  faber et al.  1 . however  unfounded sets and the well-founded operator  van gelder et al.  1   which are important for both the characterization and the computation of standard lps  leone et al.  1; simons et al.  1; calimeri et al.  1; koch et al.  1; pfeifer  1   have not been defined in a satisfactory manner for logic programs with aggregates. moreover  the impact of aggregates on the computational complexity of the reasoning tasks has not been analyzed in depth.
¡¡this paper makes a first step to overcome this deficiency  improving the characterization of programs with aggregates  for both declarative and computational purposes. the main contributions of the paper are as follows.
  we define the notion of unfounded set for logic programs with both monotone and antimonotone aggregates  lpam a programs . this notion is a sound generalization of the concept of unfounded sets previously given for programs without aggregates. we show that our definition coincides with the original definition of unfounded sets of  van gelder et al.  1  on the class of normal  aggregate-free  programs  and shares its nice properties  like  e.g.  the existence of the greatest unfounded set .
  we provide a declarative characterization of answer sets in terms of unfounded sets. in particular  answer sets are precisely unfounded-free models of an lpam a program.
  we define a well-founded operator wp for logic programs with aggregates  which extends the classical well-founded operator  van gelder et al.  1 . the total fixpoints of wp are exactly the answer sets of p  and its least fixpoint is contained in the intersection of all answer sets. importantly   is polynomial-time computable.
  we analyze the complexity of logic programs with arbitrary  also nonmonotone  aggregates and fragments thereof. both monotone and antimonotone aggregates do not affect the complexity of answer set semantics  which remains conp-complete  for cautious reasoning . nonmonotone aggregates  instead  do increase the complexity  jumping to the second level of the polynomial hierarchy for space limitations  some proofs are sketched.
1 logic programs with aggregates
in this section  we recall syntax  semantics  and some basic properties of logic programs with aggregates.
1 syntax
we assume that the reader is familiar with standard lp; we refer to atoms  literals  rules  and programs of lp  as standard atoms  standard literals  standard rules  and standard programs  respectively. two literals are said to be complementary if they are of the form p and not p for some atom p. given a literal l   .l denotes its complementary literal. accordingly  given a set a of literals   .a denotes the set
{ .l | l ¡Ê a}. for further background  see  baral  1; gelfond and lifschitz  1 .
set terms. a  lpa  set term is either a symbolic set or a ground set. a symbolic set is a pair {vars : conj}  where vars is a list of variables and conj is a conjunction of standard atoms.1 a ground set is a set of pairs of the form ht:conji  where t is a list of constants and conj is a ground  variable free  conjunction of standard atoms.
aggregate functions. an aggregate function is of the form f s   where s is a set term  and f is an aggregate function symbol. intuitively  an aggregate function can be thought of as a  possibly partial  function mapping multisets of constants to a constant.
example 1  in the examples  we adopt the syntax of dlv to denote aggregates.  aggregate functions currently supported by the dlv system are: #count  number of terms   #sum  sum of non-negative integers   #times  product of positive integers   #min  minimum term  undefined for empty set   #max  maximum term  undefined for empty set 1.
aggregate literals. an aggregate atom is f s    t  where f s  is an aggregate function   ¡Ê {=     ¡Ü   ¡Ý} is a predefined comparison operator  and t is a term  variable or constant  referred to as guard.
example 1 the following aggregate atoms in dlv notation  where the latter contains a ground set and could be a ground instance of the former:
#max{z : r z  a z v  }   y
#max{h1 : r 1  a 1 k i h1 : r 1  a 1 c i}   1
an atom is either a standard  lp  atom or an aggregate atom. a literal l is an atom a or an atom a preceded by the default negation symbol not; if a is an aggregate atom  l is an aggregate literal.
lpa programs. a  lpa  rule r is a construct a :  b1 ¡¤¡¤¡¤ bk  not bk+1 ¡¤¡¤¡¤  not bm. where a is a standard atom  b1 ¡¤¡¤¡¤ bm are atoms  and m ¡Ý k ¡Ý 1. the atom a is referred to as the head of r while the conjunction b1 ... bk  not bk+1 ... not bm is the body of r. we denote the head atom by h r   and the set
{b1 ... bk  not bk+1 ... not bm} of the body literals by b r .
¡¡a  lpa  program is a set of lpa rules. a global variable of a rule r is a variable appearing in a standard atom of r; all other variables are local variables.
safety. a rule r is safe if the following conditions hold:  i  each global variable of r appears in a positive standard literal in the body of r;  ii  each local variable of r appearing in a symbolic set {vars : conj} appears in an atom of conj;  iii  each guard of an aggregate atom of r is a constant or a
global variable. a program p is safe if all r ¡Ê p are safe. in the following we assume that lpa programs are safe.
1 answer set semantics
universe and base. given a lpa program p  let up denote the set of constants appearing in p  and bp be the set of standard atoms constructible from the  standard  predicates of p with constants in up. given a set denote the set of all multisets over elements from x. without loss of generality  we assume that aggregate functions map to i  the set of integers .
example 1 #count is defined over  #sum 
#times over  and #max are defined over .
instantiation. a substitution is a mapping from a set of variables to up. a substitution from the set of global variables of a rule r  to up  is a global substitution for r; a substitution from the set of local variables of a symbolic set s  to up  is a local substitution for s. given a symbolic set without global variables s = {vars : conj}  the instantiation of s is the following ground set of pairs inst s : {h¦Ã vars  : ¦Ã conj i | ¦Ã is a local substitution for s}.1a ground instance of a rule r is obtained in two steps:  1  a global substitution ¦Ò for r is first applied over r;  1  every symbolic set s in ¦Ò r  is replaced by its instantiation inst s . the instantiation ground p  of a program p is the set of all possible instances of the rules of p.
example 1 consider the following program p1: q 1  ¡Å p 1 . q 1  ¡Å p 1 . t x : q x  #sum{y : p x y  }   1. the instantiation ground p1  is the following:
q 1  ¡Å p 1 .t 1 : q 1  #sum{h1:p 1 i h1:p 1 i} 1. q 1  ¡Å p 1 .t 1 : q 1  #sum{h1:p 1 i h1:p 1 i} 1. interpretations. an interpretation for a lpa program p is a consistent set of standard ground literals  that is i    bp ¡È  .bp  such that i ¡É  .i =  . a standard ground literal l is true  resp. false  w.r.t i if l ¡Ê i  resp. l ¡Ê  .i . if a standard ground literal is neither true or false w.r.t i then it is undefined w.r.t i. we denote by i+  resp. i   the set of all standard positive  resp. negative  literals occurring in i. we also denote with i¡¥ the set of undefined standard literals w.r.t i. an interpretation i is total if i¡¥is empty  i.e.  i+¡È .i  = bp   otherwise i is partial.
¡¡an interpretation also provides a meaning for aggregate literals. their truth value is first defined for total interpretations  and then induced for partial ones.
¡¡let i be a total interpretation. a standard ground conjunction is true  resp. false  w.r.t i if all its literals are true. the meaning of a set  an aggregate function  and an aggregate atom under an interpretation  is a multiset  a value  and a truth-value  respectively. let f s  be a an aggregate function. the valuation i s  of s w.r.t. i is the multiset of the first constant of the elements in s whose conjunction is true w.r.t. i. more precisely  let i s  denote the multiset  t1 | ht1 ... tn :conji¡Ês¡Ä conj is true w.r.t. i  . the valuation i f s   of an aggregate function f s  w.r.t. i is the result of the application of f on i s . if the multiset i s  is not in the domain of f  i f s   = ¡Í  where ¡Í is a fixed symbol not occurring in p .1
¡¡an instantiated aggregate atom a = f s    k is true w.r.t. i if:  i  i f s   1= ¡Í  and   ii  i f s     k holds; otherwise  a is false. an instantiated aggregate literal not a = not f s    k is true w.r.t. i if  i  i f s   =1 ¡Í  and   ii  i f s     k does not hold; otherwise  a is false.
¡¡if i is a partial interpretation  an aggregate literal a is true  resp. false  w.r.t. i if it is true  resp. false  w.r.t. each total interpretation j extending i  i.e.    j s.t. i   j  a is true w.r.t. j ; otherwise it is undefined. example 1 consider the atom a = #sum{h1 : p 1 i h1 : p 1 i}   1 from example 1. let s be the ground set in a. for the interpretation i = {p 1 }  each extending total interpretation contains either p 1  or not p 1 . therefore  either i s  =  or i s  =  1  and the application of #sum yields either 1   1 or 1   1  hence a is true w.r.t. i.
minimal models. given an interpretation i  a rule r is satisfied w.r.t. i if the head atom is true w.r.t. i whenever all body literals are true w.r.t. i. a total interpretation m is a model of a lpa program p if all r ¡Ê ground p  are satisfied w.r.t. m. a model m for p is  subset  minimal if no model n for
p exists such that n+   m+. note that  under these definitions  the word interpretation refers to a possibly partial interpretation  while a model is always a total interpretation.
answer sets. we now recall the generalization of the gelfond-lifschitz transformation for lpa programs from  faber et al.  1 .
definition 1   faber et al.  1   given a ground lpa program p and a total interpretation i  let pi denote the transformed program obtained from p by deleting all rules in which a body literal is false w.r.t. i. i is an answer set of a program p if it is a minimal model of ground p i. example 1 consider the following two programs:
p1 : {p a : #count{x : p x }   1.}
p1 : {p a : #count{x : p x }   1.}
ground p1  = {p a : #count{ha : p a i}   1.} and ground p1  = {p a : #count{ha : p a i}   1.}  and interpretation i1 = {p a }  i1 =  . then  ground p1 i1 = ground p1   ground p1 i1 =    and ground p1 i1 =   
ground p1 i1 = ground p1  hold.
¡¡i1 is the only answer set of p1  because i1 is not a minimal model of ground p1 i1   while p1 admits no answer set  i1 is not a minimal model of ground p1 i1  and i1 is not a model of ground p1  = ground p1 i1 .
¡¡note that any answer set a of p is also a model of p because ground p a   ground p   and rules in ground p    ground p a are satisfied w.r.t. a. monotonicity. given two interpretations i and j we say that i ¡Ü j if i+   j+ and j    i . a ground literal ` is monotone  if for all interpretations i j  such that i ¡Ü j  we have that:  i  ` true w.r.t. i implies ` true w.r.t. j  and  ii  ` false w.r.t. j implies ` false w.r.t. i. a ground literal ` is antimonotone  if the opposite happens  that is  for all interpretations i j  such that i ¡Ü j  we have that:  i  ` true w.r.t. j implies ` true w.r.t. i  and  ii  ` false w.r.t. i implies ` false w.r.t. j. a ground literal ` is nonmonotone  if it is neither monotone nor antimonotone.
¡¡note that positive standard literals are monotone  whereas negative standard literals are antimonotone. aggregate literals may be monotone  antimonotone or nonmonotone  regardless whether they are positive or negative. nonmonotone literals include the sum over  possibly negative  integers and the average.
example 1 all ground instances of #count{z : r z }   1 and not #count{z : r z }   1 are monotone  while for #count{z : r z }   1  and not #count{z : r z }   1 they are antimonotone.
¡¡we denote by lpma  lpaa/lpna  the fragment of lpa where only monotone  antimonotone/nonmonotone  aggregates are allowed; lpm aa allows for both monotone and antimonotone aggregates.
remark 1 observe that our definitions of interpretation and truth values preserve  knowledge monotonicity . if an interpretation j extends i  i.e.  i   j   then each literal which is true w.r.t. i is true w.r.t. j  and each literal which is false w.r.t. i is false w.r.t. j as well.
1 unfounded sets
in this section  we extend the notion of unfounded sets  given in  van gelder et al.  1  for aggregate-free programs  to the framework of lpa ma programs. let us denote by s1 ¡È¨b  .s1 the set  s1   s1  ¡È  .s1  where s1 and s1 are sets of standard ground literals.
definition 1  unfounded set  a set x of ground atoms is an unfounded set for an lpa ma program p w.r.t. i if  for each rule r ¡Ê p having the head atom belonging to x  at least one of the following conditions holds: 1. some antimonotone body literal of r is false w.r.t. i  and 1. some monotone body literal of r is false w.r.t. i ¡È¨b  .x.
example 1 consider the following program p:
r1 : a 1 : #count{h1:a 1 i h1:a 1 i h1:a 1 i} 1. r1 : a 1 . r1 : a 1 : #count{h1:a 1 i h1:a 1 i h1:a 1 i} 1.
and i = {a 1  a 1  a 1 }. then x = {a 1 } is an unfounded set w.r.t. i p  since condition 1 holds for r1. also {a 1 }  and {a 1  a 1 } are unfounded.
¡¡we can show that definition 1 generalizes the one given in  van gelder et al.  1  for aggregate-free programs.
theorem 1 for an aggregate-free lpaa m program p  definition 1 is equivalent to the one of  van gelder et al.  1 .
¡¡thus  definition 1 is an alternative characterization of unfounded sets for standards literals. in fact  while condition 1 of definition 1 does not exactly cover the first one in  van gelder et al.  1   condition 1 catches all cases of the second in  van gelder et al.  1  and those  lost  by condition 1. this separates positive and negative literals  allowing to distinguish between the behavior of monotone and antimonotone literals.
theorem 1 if x1 and x1 are unfounded sets w.r.t. an interpretation i for a lpaa m program p  then also x1 ¡È x1 is an unfounded set w.r.t. i for p.
proof sketch. for condition 1 of def. 1  observe that
i ¡È¨b  . x1 ¡È x1  ¡Ü i ¡È¨b  .x1. therefore  if a monotone literal ` is false w.r.t. i ¡È¨b  .x1  then it is false w.r.t.
i ¡È¨b  . x1 ¡È x1 . symmetrically for x1.	1
¡¡by virtue of theorem 1  the union of all unfounded sets for p w.r.t. i is an unfounded set. we call it the greatest unfounded set of p w.r.t. i  and denote it by gusp i .
proposition 1 let i and j be interpretations for an lpaa m program p. if i   j  then gusp i    gusp j . proof sketch. follows from remark 1  since i ¡È¨b  .x  
j ¡È¨b  .x.	1
1 answer sets and unfounded sets
in this section  we provide a couple of characterizations of answer sets in terms of unfounded sets.
definition 1  unfounded-free interpretation  let i be an interpretation for a program p. i is unfounded-free if i¡Éx =   for each unfounded set x for p w.r.t. i.
¡¡the next lemma gives an equivalent characterization of the unfounded-free property for total interpretations.
lemma 1 let i be a total interpretation for a program p. i is unfounded-free iff no nonempty set of atoms contained in i is an unfounded set for p w.r.t.i.
proof sketch. if i is not unfounded-free  an unfounded set x for p w.r.t. i s.t. x ¡É i 1=   exists. then  an unfounded set.
theorem 1 a model m is an answer set of an lpaa m program p if and only if m is unfounded-free.
proof sketch. if m is a model and x   m is a non-empty unfounded set w.r.t. m  then it can be shown that m ¡È¨b  .x is a model of pm  hence m is no answer set. on the other hand  if m is an unfounded-free model but not an answer set  a model n of pm s.t. n+   m+ must exist. we can show that m+   n+ is an unfounded set. 1
¡¡now we give another interesting characterization of answer sets. a total interpretation is an answer set if and only if its false literals are unfounded.
lemma 1 a total interpretation m is a model for p iff  .m  is an unfounded set for p w.r.t. m. proof sketch. the result follows from the fact that
m ¡È¨b  .  .m  .
theorem 1 let m be a total interpretation for a program p. m is an answer set iff  .m  = gusp m .
proof sketch. can be shown using lemmata 1 and 1 and
theorem 1.	1
1 well-founded semantics
in this section we extend the wp defined in  van gelder et al.  1  for aggregate-free programs to lpaa m programs. then  we show that the answer sets of an lpaa m program p coincide exactly with the total fixpoints of w .
¡¡we start by providing an extension toprograms of the immediate consequence operator tp defined in  van gelder et al.  1  for three-valued interpretations of standard logic programs.
definition 1 let p be a lpaa m program. define the operators tp and wp from 1bp¡È .bp to 1bp and 1bp¡È .bp  respectively  as follows.
tp i  = {a ¡Ê bp |  r ¡Ê ground p  s.t. a = h r  and b r  is true w.r.t. i} wp i  = tp i  ¡È  .gusp i .
theorem 1 let m be a total interpretation for a program p. m is an answer set for p iff m is a fixpoint of wp.
proof sketch. m  =  .gusp m  holds by virtue of theorem 1  m+ = tp m  can be shown using lemma 1 and
definition 1.	1
¡¡the wp operator is clearly monotone on a meet semilattice  and it therefore admits a least fixpoint  tarski  1 . this fixpoint can be computed iteratively starting from the empty set  and approximates the intersection of all answer sets  if any .
theorem 1 given an lpam a program p  let {wn}n¡Ên be the sequence whose n-th term is the n-fold application of the wp operator on the empty set  i.e.  w1 =    wn =
wp wn 1  .	then  a  {wn}n¡Ên converges to a limit
  and  b  for each answer .
proof sketch.  a  follows from the monotonicity of wp and the finiteness of bp.  b  holds since all atoms computed by tp belong to any answer set and because of theorem 1. 1 from theorem 1 and 1  the following easily follows.
corollary 1 if wp¦Ø    is a total interpretation  then it is the unique answer set of p.
¡¡the following proposition confirms the intuition that definition 1 extends the wp operator  as defined in  van gelder et al.  1  for standard programs   to lpam a programs.
proposition 1 let p be an aggregate-free program. then the wp operator of definition 1 exactly coincides with wp operator defined in  van gelder et al.  1 . corollary 1 on aggregate-free programs  coincides with the well-founded model of  van gelder et al.  1 .
¡¡moreover  there are simple cases where wp¦Ø    captures the intended meaning of the program.
example 1 consider the following program p:
a 1  :  #sum{h1 : a 1 i h1 : a 1 i}   1. b :  not a 1 . a 1  :  b. b :  not c.
we have wp   	=	{not c}  then wp {not c} 	=
{b  not c  not a 1 }  then wp {b  not c  not a 1 }  = not not a a ¦Ø .
it	here is total  is an answer set for p.
1 computational complexity
we first show the tractability of the well-founded semantics for lpm aa   and we then analyze the complexity of answer set semantics for general lpa programs. we consider the propositional case  hence  throughout this section we assume that programs are ground.
theorem 1 given a ground lpm aa program p: 1. the greatest unfounded set gusp i  of p w.r.t. a given interpretation i is polynomial-time computable; 1. wp¦Ø    is polynomial-time computable.
proof sketch. we define an operator ¦µi from bp to bp as follows: ¦µi y   = {a |   r ¡Ê p with a = h r 
s.t. no antimonotone body literal of r false w.r.t. i ¡Ä all monotone body literals of r are true w.r.t. y    .i }. the sequence ¦Õ1 =    ¦Õk = ¦µi ¦Õk 1  is monotonically increasing and converges finitely to a limit ¦Õ¦Ë  for which ¦Õ¦Ë = bp   gusp i  can be shown. furthermore  each application of ¦µi is polynomial in our setting1  and also ¦Ë is polynomial in |bp|. from this  the result follows. 1
¡¡this result has a positive impact also for the computation of the answer set semantics of logic programs with aggregates. indeed  as stated in theorem 1  wp¦Ø    approximates the intersection of all answer sets from the bottom  and can be therefore used to efficiently prune the search space.
¡¡we next analyze the complexity of the answer set semantics of general lpa programs. in  faber et al.  1   the authors have shown that arbitrary  including nonmonotone  aggregates do not increase the complexity of disjunctive programs. however  nonmonotone aggregates do increase the complexity of reasoning on or-free programs.1
theorem 1 cautious reasoning over lp is complete.
proof. membership follows directly from the results in  faber et al.  1 . concerning hardness  we provide a reduction from 1qbf. let ¦· =  x1 ... xm y1 ... yn : ¦µ  where w.l.o.g. ¦µ is a propositional formula in 1cnf format  over precisely the variables x1 ... xm y1 ... yn. observe that ¦· is equivalent to   x1 ... xm y1 ... yn :  ¦µ  and that  ¦µ is equivalent to a 1dnf where every literal has reversed polarity w.r.t. ¦µ. let the lpprogram ¦°¦· be:
t xi 1  :  #sum{v : t xi v  }  = 1. t xi  1  :  #sum{v : t xi v  }  = 1. t yi 1  :  #sum{v : t yi v  }  = 1. t yi  1  :  #sum{v : t yi v  }  = 1.
for each	original ¦µ  we add: unsat :  ¦Ì li 1  ¦Ì li 1  ¦Ì li 1   where ¦Ì l  is t l  1  if l is positive  and t l 1  otherwise.
the query not unsat  holds for ¦°¦·  iff ¦· is satisfiable. 1
¡¡monotone and antimonotone aggregates  instead  behave as in the disjunctive case  not causing any complexity gap.
theorem 1 cautious reasoning over lpam a is co-npcomplete.
proof. hardness follows from the co-np-hardness of cautious reasoning over normal  aggregate-free  logic programs  marek and truszczynski ¡ä 1; schlipf  1 . for membership  we guess a total interpretation m  and check that:  i 
a ¡Ê m  and  ii   .m  = gusp m   by theorem 1 m is then an answer set . by theorem 1  the checks are feasible in polynomial time.	1
1 related work
to our knowledge  the only other work in which the notion of unfounded set has been defined for programs with aggregates is  kemp and stuckey  1 . however  their definition ignores aggregates in the second condition for unfounded sets. for the program a 1 : #count{x : a x }   1. the well-founded model of  kemp and stuckey  1  is    leaving a 1  undefined. our well-founded model is { a 1 }. most of the results reported in this paper do not hold for unfounded sets as defined in  kemp and stuckey  1 .
¡¡there have been several attempts to define well-founded semantics for programs with aggregates  not relying on unfounded sets. several early approaches which are defined on a limited framework are discussed in  kemp and stuckey  1 . in  van gelder  1  a semantics is defined by compiling aggregates to rules with standard atoms. this approach was generalized in  osorio and jayaraman  1 . in any case  this strategy works only for certain classes of programs. in  ross and sagiv  1  an operator-based definition is given  which also works only on a restricted set of programs. in  pelov  1  a well-founded semantics has been defined based on an approximating operator. since this definition is substantially different from the one in this paper  we leave a comparison for future work.
¡¡other works attempted to define stronger notions of wellfounded semantics  also for programs with aggregates   among them the ultimate well-founded semantics of  denecker et al.  1  and wfs1 and wfs1 of  dix and osorio  1 . whether a characterization in terms of unfounded sets can exist for these semantics is not clear  and even if such generalized unfounded sets would exist  it is likely that some of the theorems in this paper will no longer hold  given that these semantics assign truth or falsity for more atoms.
¡¡in  ferraris  1  it was shown that the semantics of smodels programs with positive weight constraints is equal to answer sets as defined in  faber et al.  1  on the respective fragment. since by theorem 1 wp¦Ø    approximates answer sets of  faber et al.  1   wp¦Ø    can be used also as an approximating operator for the respective smodels programs. indeed  we can show that the atmost pruning operator of smodels  simons et al.  1  is a special case of the ¦µi operator  defined in the proof sketch for theorem 1 .
1 applications and conclusion
the semantics of logic programs with aggregates is not straightforward  especially in presence of recursive aggregates. the declarative and fixpoint characterizations of answer sets  provided in sections 1 and 1  allow for a better understanding of the meaning of programs with aggregates  and provide a handle on effective methods for computing answer sets for programs with  recursive  aggregates. in particular  the operator wp¦Ø    can be used first to compute what must be in any answer set. later in the computation  it can be used as a pruning operator and for answer set checking  as described in  koch et al.  1; pfeifer  1  .
¡¡furthermore  since loop formulas encode unfounded sets  lee  1   our results should be adaptable also to satbased asp systems  all of which rely on loop formulas.
¡¡the complexity results make a clear demarcation between aggregates from the computational viewpoint  which is very useful to pick the appropriate techniques to be employed for the computation. the well-founded semantics of lpam a is efficiently computable. answer set semantics is in co-np for lpam a  while nonmonotone aggregates bring about a complexity gap  and cannot be easily accommodated in np systems.
¡¡a main concern for future work is therefore the exploitation of our results for the implementation of recursive aggregates in asp systems.
