 
uniform is an ai programming language under development based upon augmented u n i f i c a t i o n . it is an attempt to combine  in a simple coherentframework  the most important features of lisp  actor languages such as act 1 and smalltalk  and logic programming languages such as prolog. among the unusual a b i l i t i e s of the language is i t s a b i l i t y to use the same program as a function  an inverse f u n c t i o n   a predicate  a pattern  or a generator. a l l of these uses can be performed upon concrete  symbolic  and p a r t i a l l y instantiated data. uniform features automatic inheritance from m u l t i p l e 1uper classes  f a c i l i t i e s for manipulation of programs  a l i m i t e d a b i l i t y to determine program equivalence  and a u n i f i c a t i o n - o r i e n t e d database. 
	i 	a language based upon unification 
　　uniform is based upon the idea of an extensible u n i f i c a t i o n procedure. a l l programs are extensions to the u n i f i c a t i o n process. u n i f i c a t i o n plays the roles of pattern matching  evaluation  message passing  inheritance  and symbolic evaluation. in the process of u n i f y i n g the f a c t o r i a l of 1 with an integer n  n is unified with 1. the concatenation of x and the l i s t  c d  u n i f i e s with the l i s t  a b c d     r e s u l t i n g in x being unified with the l i s t  a b   . unifying the nth element of the l i s t of a l l prime numbers with 1 results in n unified with 1. unifying the reverse of a l i s t of variables x and y with a l i s t z  u n i f i e s z with a l i s t of y and x. unifying a member of set x with a member of set y yields a member of the intersection of x and y. unifying a description of red chairs with a description of b i g chairs produces a description of b i g red c h a i r s . and so on. 
　　a. u n i f i c a t i o n what it is u n i f i c a t i o n was invented for use in resolution theorem provers  1  and has since been used in a few programming languages. two well-known examples are prolog which is a programming language based upon r e s o l u t i o n theorem proving  1  and qlisp  1 . in these languages u n i f i c a t i o n is only one f a c i l i t y among others. in uniform u n i f i c a t i o n is augmented so that no other mechanism such as r e s o l u t i o n   automatic-backtracking  or evaluation is needed. 
　　u n i f i c a t i o n is the process of generating the most general common instance of a set of 
   *the research reported herein was supported by the swedish board for technical development  stu . descriptions. it is implemented as a process that returns a   u n i f i e r   which if applied to any of the o r i g i n a l descriptions produces the sought a f t e r instance. in the most common case  the u n i f i e r is simply an environment describing variable bindings and it is applied to a description by s u b s t i t u t i n g i t s values for the variables in the d e s c r i p t i o n . 
as an example * 
  u n i f i e r - o f  foo x 	'a r  
                  foo 'b y r     produces 	    u n i f i e r 	 x 	'b  	 y 	' a       	which 	if substituted 	into 	either 	description 	produces 	the instance     f o o 	'b 	'a 	r     . 	u n i f i c a t i o n 	is defined to 	produce 	the 	most 	general 	instance which means that 	the 	instance 	produced 	must 	unify 	with 	a l l other possible 	instances. 
　　pattern matching  which has played such a large r o l e in most ai languages  is a special case of the u n i f i c a t i o n of two descriptions. the pattern is a description containing variables which is matched against a description without any variables. if the match succeeds  the u n i f i e r produced is a set of match bindings which when substituted into the pattern produces the other d e s c r i p t i o n . 
　　u n i f i c a t i o n has many advantages over pattern matching. there is no d i s t i n c t i o n between patterns which bind variables and patterns which use the value of v a r i a b l e s . this allows the meaning of a pattern to be determined dynamically and is c r u c i a l in using programs in multiple ways and d i r e c t i o n s . 
　　patterns can be matched against patterns. this is important for dealing with p a r t i a l information. it is also useful in determining if one pattern is a special case of another. uniform uses u n i f i c a t i o n t h i s way so that by default more s p e c i f i c knowledge is used f i r s t . 
　　the order in which sub-problems  recursive c a l l s to unify  are made does not affect the outcome. this gives the implementation a freedom of optimization not possible in most pattern matchers. p a r a l l e l implementations of u n i f i c a t i o n which could take advantage of the p a r a l l e l hardware of the future are also possible. 
    as in lisp  uniform follows the convention that constants are numbers or are quoted and variables are unquoted symbols. 
b. how unification is augmented in uniform unification is a syntactic process. its only concern is that forms have the same  head   their arguments unify  constants are equal and recursively that bindings unify. it cannot unify the sum of x and 1 with 1 by unifying x with 1. uniform's augmented unification leaves it up to the forms involved to unify as they see f i t where the traditional syntactic unification process is used only as a default. except for a small set of primitive types this augmentation is described in uniform by the user. 
   the only constraint upon augmentations to the unification of two descriptions is that the resulting unifier produce equivalent descriptions when applied. for example  the unifier describing x as 1 produces 1 and the sum of 1 and 1 when applied to 1 and the sum of x and 1. either the sum of 1 and 1 is considered equivalent to 1 or else the augmentation that produced the unifier is invalid. 
　　a few of the primitive forms stretch this view of unification. for example  the primitive form   print   w i l l unify with anything and as a side effect the other form w i l l be printed. the primitive   ground   w i l l either unify with any constant or w i l l eventually f a i l if the other is a variable or contains variables that are never bound. there are primitives for dynamically creating unification variables and forms  primitives for escaping to lisp's eval  a theoretically unnecessary  yet very useful  primitive   for forcing sequentiality  critical in situations involving input-output or other side effects   for determining if two things are the exact same object  lisp's eq  c r i t i c a l when dealing with circular structures and important for efficiency   and for the logical connectors  and    or   and  not . without this small set of primitives  unification would not be adequate as the sole basis of a programming language. 
　　uniform's augmented unification not only has the unusual features of delegating to the forms involved but is based upon a new very parallel algorithm. sub-unifications of corresponding arguments are computed independently and the resulting unifiers are unified. a unifier is either a set of bindings or a set of possible unifiers whose members are computed only upon need. this mechanism replaces the automatic backtracking in prolog and qlisp. in addition  when the descriptions cannot be unified the algorithm produces failure descriptions which are used internally and by the user for debugging. unification is also used to implement the occur check and the  ground  primitive. the algorithm is described further in  1 . 
c. how uniform uses augmented unification 
the top level 	loop of uniform is  	analogous 	to 
lisp  a  read unify print  loop. the user types a form which is unified with previous user assertions. if the relation is either  =   are they unifiable   or  unify   what is the most general common instance   then the unification algorithm is applied to the arguments. if the unification fails  it looks in the user's assertions for possible paths between the two descriptions and follows such paths in a shortestf i r s t manner.* the steps of a path are typically described using the  =  relation which declares that its arguments are unifiable. if an assertion has constraints  a body  they are checked. if the unification is successful the unifier produced is applied to the user's problem and the resulting instance is printed. 
here is a short sample session: 
user: 	 unify  foo x   foo 'a   
uniform:  foo 'a  
user: 	 =  plus x 1  1  
uniform:  =  plus 1  1  user:  =  foo 1   foo 1   uniform: 
 or ;the problem is one of the following: 
 failure 'arguments-do-not-unify  foo 1   foo 1   
 failure 'constants-do-not-unify 1   
   the other action a user can take is to extend unification by presenting assertions. for example  the following is how unification can be extended to handle factorial: 
 assert  =  factorial 1  1   
 assert  =  factorial n  
   n  factorial  - n 1      
　　the f i r s t assertion extends unification so that anything which unifies with factorial of 1 is unifiable with anything which unifies with 1. the second clause states that anything that unifies with factorial of anything also unifies with anything which unifies with the product of that anything and factorial of one minus that anything. the  n  in the second clause is universally quantified. 
　　this definition of factorial can be used in many ways as illustrated below. how this is realized is described in  1 . an example of its use as a function is: 
user: 	 =  factorial 1   integer n   
uniform:  =  factorial 1   integer 1   
　　if we unified   factorial 1   with  n  in the above example then  n  would have been unified with   factorial 1   instead of 1. the use of  integer  gives the user greater control of the unification at the price of having to type variables. to alleviate this the type  primitive  can be used which unifies only with primitive types. use of the  primitive  type corresponds to evaluation in lisp. 
   our description of factorial can be used as an inverse function  or a pattern which matches only integers which are factorials  by unifying   factorial n   with ground forms. the value of  n  or a failure description is computed reasonably efficiently due to some cleverness in the general description of    . factorial of a constant can be used as a pattern without necessarily being evaluated. in unifying   factorial 1   with 
　 shortest-first differs from breadth-first in that the system maintains a data structure so that it knows the minimum length of a l l possible paths between two types of forms and tries the shortest ones f i r s t . 

1  a constraint that 1 be a divisor of 1 is generated after 1 steps and causes immediate failure. 
	d. 	what is interesting about unification 
i am developing uniform both to produce a simple yet powerful ai language and to explore unification. unification is interesting not only as a basis for computation but as a source of insight into questions about specialization  generalization  object merging  inheritance and multiple super classes. 
   traditional unification is concerned with creating the most general syntactic instance of a set of descriptions. class and instance is defined purely in terms of the form of the descriptions. the more instantiated versions of a class are its instances. from an ai point of view  the semantic  not syntactic  instances are what is interesting. a description of a particular equilateral triangle is a semantic instance of the prototype equilateral triangle  regular polygon  triangle  closed figure  line drawing  geometrical figure and so on. the semantic unification of regular polygons and triangles should produce equilateral triangles. unification not only generates an instance of two descriptions but produces a unifier  a description of a viewpoint under which the two descriptions are the same. for syntactic unification  the viewpoint is an environment giving bindings and constraints to the variables in the descriptions. a view of polygons and triangles that makes them the same is a description of equal-sidedness and threesidedness. a viewpoint is not the same as the instance. an equilateral triangle is more than equal-sided and three-sided  it is also a closed geometrical figure. attaining this kind of semantic unification is a direction this research is headed. 
　　as another example consider the unification of two t r i v i a l lisp programs:  cons head tail  with   l i s t f i r s t second . the instance of the two programs can be described in two ways  as  cons f i r s t   l i s t second   and as   l i s t first  car t a i l     . what is often of more interest than the instance is the viewpoint  or unifier  which produced i t . in this example  the viewpoint identifies   f i r s t   with  head     t a i l   with     l i s t second    and  second  and   car t a i l     . 
   unification can be used to dynamically determine who is an instance of who. suppose descriptions x and y unify to produce a common instance z. if z equals x but not y  then x is an instance of y. 
   unification is a process that provides some insight into not only classes and instances but also equivalence. the unifier of two equivalent descriptions is an empty environment. if the unifier of two descriptions is an environment which only binds variables to variables  then the two description are equivalent except for variable names. 
   the augmentations of unification in uniform are almost always stated as equivalences between programs. for example  consider a definition of 
 append  in uniform  
 assert  =  append    back  back   
 assert  =  append  cons f i r s t rest  back  
 cons first  append rest back     
   occasionally an augmentation of unification w i l l explicitly describe an instance. 	this is expressed as a second-order unification as illustrated in the 
following example  
 assert 
 =  unify  a-divisor-of n   a-divisor-of m   
 a-divisor-of  greatest-common-divisor m n     
   this example is computationally interesting since can be used in appropriate cases to intersect virtual sets very efficiently.   a-divisor-of 1    for example  is logically  but not computationally  equivalent to   a-member-of  set 1 - 1 - 1 - 1 
-1   . 
   the dual of the unification process is generalization. unification finds the most general description which is a specialization of some descriptions  while generalization finds the most specific description which has as specializations the descriptions. surprisingly generalization of two descriptions can be implemented using the unifier of the descriptions. when a unifier is just a set of bindings  it is used in a backwards fashion to substitute constants for variables. generalization is more complicated when different variables are bound to the same constant or when the unification fails. this is described further in  1 . 
   generalization is well-known to be a useful process. winston's program which learned the concept of an arch by generalizing structural descriptions is a classic example. one of my goals is that a program such as winston's would be significantly shorter and simplier  if written in uniform. much of the program would augment generalization beyond syntax in a similar manner to how unification is augmented currently in uniform. 
   e. unification and circularity another of uniform's extensions of unification is in the handling of circularity. traditionally unification is defined to perform an  occur check  on every variable binding. the check causes a failure if a variable is bound to something which contains that variable  ever comes to contain that variable in the future  or recursively is bound to some structure which contains variables that fail the check. because of the expense of making such a check most implementations of prolog do not make the check. 
　　in uniform's augmented unification  the user can specify for each type of form whether the occur check should be performed. for example   plus  does not perform the check since there is nothing wrong with unifying x with the sum of x  y and z provided the sum of y and z can unify with 1. without the check the system needs to be able to unify circular structures. in the following example  cons  does not do the check. the variable 

x is bound to  a  consed with itself while y is bound to  a  consed with a cons of  a  and itself. the two structurally different infinite lists of  a s unify successfully. 
 and  unify x  cons 'a x   
 unify y  cons 'a  cons 'a y    
 unify x y   
what is difficult about unifying  x  and  y  above is avoiding an infinite recursion. by being careful about the order in which sub-forms are unified it is possible to avoid this. intuitively  the algorithm assumes that a unification will succeed before working on the sub-unifications so that if the same problem appears again it w i l l succeed immediately without causing further recursions  1 . 
   occur checks can also be used to prevent certain types of inconsistencies. consider the following example from peano arithmetic: 
;a successor of any x is greater than x 
 assert     successor x  x   ;is there a y greater than its successor  
   y  successor y   
　　if one considers binding ny  to   successor  successor y    an inconsistency  then  successor  should perform the occur check to prevent i t . another view is that  y   as an infinite number of applications of  successor   is a representation of infinity. infinity is greater than  and also less than  its successor. 
	ii 	relationships with other languages 
　　uniform was designed and developed with the i n i t i a l goal of incorporating the most important features of lisp  act 1  and prolog into a single coherent framework. future plans include the incorporation of the notions of descriptions  frames  and experts as found in  1   constraints as in  1   partial evaluation as in  1   and quasiparallelism and graphics as found in director  1 . my basic research strategy begins with the belief that many existing languages and systems contain very general and powerful facilities  but each one has only a small subset of the union of these f a c i l i t i e s . furthermore  a simple coherent union of these facilities is both possible and desirable. boley's research on the fit language shares this research strategy  1 . fit  however  is based upon a generalized notion of variables  assignment  pattern matching and demons. 
	a. 	uniform and lisp 
uniform  having been built upon maclisp  in a t r i v i a l sense incorporates a l l of lisp's abilities. there is a primitive for interfacing directly with 
lisp. of course  using this primitive one loses the ability to run programs symbolically or backwards. 
   the more important way in which uniform incorporates lisp is the ability to write uniform programs that look very much like lisp. for example  one can write  append  in uniform as follows  
 assert 
 r  append front back  
 cond   null front  back  
  cons   f i r s t front  
 append  rest front  back       
this 	program does 	not 	mean the 	same as 	the corresponding lisp program. it states an equivalence not an evaluation step. unification does not have eval's sense of direction or notion of simplification. instead of evaluation  a form is unified with a variable constrained to be of a particular data type such as integer or s-expression or constrained to consist of only primitive data types. this corresponds closely to lazy evaluation in lisp. lacking the control information implicit in lisp  uniform's interpreter is in general slower. in return the append program above can be executed symbolically  used in pattern matching  run backwards  append any kind of l i s t   and be used in judging program equivalence. 
   the reason the  append  program looks like lisp is that the primitives  null    first    rest   and  cond  can be written in uniform. the primitives of lisp that currently are difficult to write include those that perform side-effects such as  setq    rplaca  and array operations. it is possible to implement them fairly straightforwardly in uniform  but the implementation is unacceptably inefficient. essentially a cell is represented as a l i s t of its previous values where the last cons contains the current value and a variable for future bindings. other possibilities for implementing side-effects in uniform are to use tail-recursion optimization or reference counts to know when it is safe to re-use the current structure rather then copy. this shortcoming of uniform is an active area of research. 
　　the most essential property of lisp  the ability to run large programs efficiently is lacking in uniform. a compiler is planned and it is hoped that it will produce acceptable code. compilers for smalltalk  1   director  1   and prolog  1  contain relevant techniques as do compilers based upon partial evaluation such as the one for the lima pattern matcher  1 . another area of research that hopefully w i l l lead to an acceptable level of efficiency is work within logic programming languages for describing and using control or meta-level information  1 . 
	b. 	uniform and actor languages 
computer languages based upon computational entities called  actors  offer modularity  parallelism  f u l l extensibility of both data and functions and a simple but powerful computational semantics. an early version of uniform was attempted in act 1  1   a language that takes the idea of actors to the extreme. many of the facilities of act 1 would have been available in uniform  including its excellent primitives for describing concurrent computation. unfortunately the current implementation of act 1 is too slow to build a practical interpreter upon i t . 
　　act 1 is a message passing language based upon the convention that actors be able to respond to  eval  and  match  messages. uniform can be viewed as a language in which forms pass  unify  messages between themselves and their parts. as we saw in the previous section  unification subsumes evaluation. unification clearly subsumes the match messages in act 1 since pattern matching is just the special case of unification where one of the forms contains no variables. 
1 
　　one of the important features of actor languages is the a b i l i t y to describe a new data structure and have old programs use it without m o d i f i c a t i o n . this is a consequence of the fact that programs depend only upon the behavior of data in response to messages. a l i s t is any actor which can answer   f i r s t   and   r e s t   messages. the analogous statement about uniform is that a l i s t is any form that can unify with   cons x y     . for example  suppose we want to define a new kind of l i s t which i n t e r n a l l y is represented by two l i s t s   one for the o r i g i n a l members and one for those deleted. the advantage of these  delete l i s t s   is that deletion becomes a very cheap and pure operation in return for a l i t t l e overhead on other operations. 
they can be defined as follows in uniform: 
 assert 
 =   d e l e t e - l i s t deleted  cons f i r s t rest   
	  r u l e s 	f i r s t 
  member deleted  
; i s already deleted so skip it 
	  d e l e t e - l i s t deleted 	r e s t     
	     	;otherwise the f i r s t element is ok 
	 cons 	f i r s t 
	  d e l e t e - l i s t 	deleted 	r e s t             
　　this is a l l that is needed to run any program that works on l i s t s since it provides a path from   d e l e t e - l i s t   to  cons . if we describe how to delete items for   d e l e t e - l i s t   it w i l l be used before the delete operation defined for  cons . notice that t h i s way of implementing l i s t s as anything that can unify with a  cons  of two variables subsumes the inheritance mechanism in languages l i k e smalltalk and director. uniform 
always t r i e s f i r s t the shortest path between two s t r u c t u r e s . the path to delete l i s t ' s delete operation is shorter than one through cons's delete so it is followed f i r s t . of course sub-classes are possible. i f x - l i s t s only unify d i r e c t l y with y - l i s t s which unify with z - l i s t s   then d e f i n i t i o n s of operations upon x - l i s t s w i l l be used before those for y - l i s t s which in turn w i l l be used before z - l i s t ' s d e f i n i t i o n s . 
　　this same mechanism works for multiple super classes. if we define how horizontal-dashed-lines u n i f y with h o r i z o n t a l - l i n e s and with dashed-lines then operations upon either one can be applied to horizontal-dashed-lines. since uniform follows shortest paths f i r s t   the multiple super classes are searched in a b r e a d t h - f i r s t fashion. 
　　one very important part of some of the actor languages is the user definable control structures and a b i l i t y to compute in p a r a l l e l  1   1 . this is a serious deficiency of uniform. the plan is to add such information as advice to the i n t e r p r e t e r as to how to go about doing the u n i f i c a t i o n s . this approach is similar to one taken in metalog  1 . the appeal of separating logic from control is that a user can develop and test the logic or competence of a program before adding control information to improve i t s performance  1 . also d i f f e r e n t uses of the same program may be helped by d i f f e r e n t c o n t r o l information. 
　　c. uniform and logic programming in recent years a number of logic programming languages have appeared. most notable is prolog  a programming language which resembles planner  1 .  one of prolog's major improvements over planner is i t s use of u n i f i c a t i o n .   programs in prolog are axioms in the f i r s t - o r d e r predicate logic r e s t r i c t e d to horn clauses. programs are executed by a resolution theorem prover. what is special about prolog is that it is intended as a general purpose programming language meant to compete with compiled lisp as well as with planner-like languages. the objection to logic as being an excessively constrained manner of reasoning is i r r e l e v a n t to i t s worth as a programming language. one would not want to build ai programs upon an 
  i n f o r m a l   lisp. the objection to logic that it is not concerned with control over the use of knowledge is a serious one. there are many advantages however  to having a programming language based upon logic with a separate control component for improving performance such as ic-prolog or metalog  1 . 
　　when compared with lisp  prolog has many advantages and a few very serious disadvantages. prolog shares with uniform the a b i l i t y to use the same program in many ways. for example  the prolog d e f i n i t i o n of  append  can be used not only to compute the result of appending two l i s t s together but can also be used as a predicate to v e r i f y that the r e s u l t of appending two l i s t s is a t h i r d l i s t   as a generator of pairs of l i s t s that append to a p a r t i c u l a r l i s t   as a way of f i n d i n g the difference between two l i s t s   and as a generator of t r i p l e s of l i s t s such that the f i r s t two append to form the t h i r d . 
　　prolog has a few other features which lisp lacks. among them are the a b i l i t y to compute with p a r t i a l l y i n s t a n t i a t e d structures  a convenient way to handle multiple outputs  and the use of pattern matching instead of e x p l i c i t l i s t construction and s e l e c t i o n . on the negative side  prolog implementations are the r e s u l t of a much smaller implementation e f f o r t than the major lisp d i a l e c t s and correspondingly lack good programming environments  i/o f a c i l i t i e s   adequate a r i t h m e t i c   and the l i k e . attempts to embed prolog in lisp 
  e . g . 	qlog 	 1   	may 	a l l e v i a t e 	t h i s . 	among 
prolog's more fundamental problems are a dependence upon automatic backtracking  a lack of user control over search  and a lack of an e f f i c i e n t substitute for impure operations. 
　　uniform was developed with the goal of capturing and improving these positive aspects of prolog. uniform supports a l l the uses of a d e f i n i t i o n that 
prolog does and an additional 	few 	for example  
uniform's 	d e f i n i t i o n 	of 	 append  	is 	equivalent 	to 
prolog's and can also be used as an implementation of segment p a t t e r n s . 1 in a d d i t i o n   it is a l l the knowledge about  append  the system needs to answer questions about program equivalence. 
   *for example  the uniform description  append   l i s t x    l i s t x  y ' center  y   or equivalently using read macros  x x y 'center !y   matches a l i s t whose f i r s t and second elements are the same and the rest of the l i s t has the symbol  center  in the middle surrounded by equal l i s t segments. 

1 

   for example  work is under way ao that uniform can successfully unify the following for a l l lists x and y. 
 s  append  reverse x  y  
 reverse  append  reverse y  x    
　　in uniform one can augment the unification of relations other than the  a  relation and so can write in prolog's relational  as opposed to a functional  style. the following is a uniform program for defining the  grandparent  relation  which can be used as the  grandchild  relation too . 
 assert  grandparent-of grandchild grandparent  
;the above is true if the following holds 
 parent-of a-parent grandparent  
 parent-of grandchild a-parent   
   the program says that two variables are in the grandparent relation if a child of the f i r s t variable unifies with a parent of the second. as in prolog the variables  grandparent  and  grandchild  are universally quantified and  a-parent  is existential  by virtue of not being in the  head  . 
	i l l 	a detailed example 
as a simple example that exemplifies many of 
uniform's features let us consider an implementation of association l i s t s . it is a typical example of how the same program can be used to construct a data structure and to compute with the same data structure. besides reducing the amount of programming it makes it impossible for the accessing programs to be based upon a mistaken notion of how the structure is constructed. 
   the following is an implementation of association l i s t s : 
 assert association is in the front of the l i s t 
 =  association-of key 
                  cons   l i s t key value  rest   value   
 assert ;otherwise  cdr  down the l i s t 
 s  association-of key  cons f i r s t rest   
 association-of key rest    
　　this program can best be understood by seeing how it can be used. first let us build a l i s t of associations between objects and colors. we can associate sky with blue in a l i s t colors by unifying   association-of 'sky colors   with the symbol  blue . the variable  colors  is unified with  cons   l i s t 'sky 'blue  rest-1  or in an alternative syntax       s k y 'blue  !rest-1  . in other words   colors  is a l i s t whose f i r s t element is a l i s t of  sky  and  blue  and the rest is an unbound variable. if we next associate grass with green and ocean with blue  the  colors  l i s t will be bound to     s k y 'blue!  'grass 'green   'ocean 'blue  !rest-1 . were we to add any of the associations already in colors it would succeed without making any new bindings. 
　 extending prolog to allow a functional style of programming would not be too d i f f i c u l t  1 . more d i f f i c u l t would be to support these functional definitions in unification. 
the association l i s t can be used in many ways. 
if 	we 	associate 	grass 	with 	the 	variable 
 grass-color   it w i l l be bound to green. or if we associate the variable  blue-thing  with blue  blue-thing w i l l be bound to sky. if that falls later or other alternatives are desired  then 
blue-thing w i l l be unified with ocean. 
　　if that alternative fails  a weakness of logic programming is revealed. the problem of unifying  association-of blue-thing colors  with 'blue is interpreted as  is it possible that blue-thing is associated with blue and if so how . if we reject an answer it is interpreted as  is it possible in some other way . if an association l i s t  ends  with a variable  then the answer is always yes. the f i r s t answer was  yes if blue-thing is sky   the second answer was  yes if blue-thing is ocean  and the next answer was  yes if colors is 'sky 
'blue   'grass ' green   *ocean 'blue   blue-thing 'blue  frest-1  . in other words   yes  if colors is an association l i s t with the variable blue-thing 
associated with blue . 
　　this problem was revealed when in answer to the question  what can be blue  uniform replied   the sky  the ocean and any blue thing . it was the question that was at fault  not the answer. it should have been  what is known to be blue . this cannot be expressed in logic programming languages  without finding and binding a l l the variables in colors to unique constants . uniform has a primitive relation to distinguish the two interpretations. the primitive  known  marks the incoming unifier so that a failure results if any of its unbound variables are unified. 
　　a strength of uniform is that one can define and use an association l i s t which has variables in i t . dealing with partial knowledge is very important in 
ai. one can express  for example  that john's apple is either red  green or yellow by associating john's apple with a variable for the color of 
john's apple and unifying that variable with the disjunction of red  green  and yellow. later if we learn more about the color of john's apple we can specify it further  in the meanwhile we can use what is known about his apple. 
	iv 	conclusions and future research 
   a surprising result of this research is that unification  a process of generating the most general instance of a set of descriptions  can be such a powerful basis for a programming language. unification unifies the essence of lisp  act 1  and prolog into a simple coherent framework. 
	uniform is 	far 	from complete.* 	some 	of 	the 
1 　 at the time of this writing  the implementation does not run a l l the examples in this paper. the unification algorithm and its primitive types  the path following  and the top-level works and is capable of running examples such as  append    association-of   and  grandparent . factorial  the  rules  primitive  and the  known  primitive do not work yet. examples involving them have been hand-simulated. 
major avenues of future research follow. 
　　developing and incorporating the dual of u n i f i c a t i o n   generalization  into the language. the d u a l i t y between u n i f i c a t i o n and generalization is s t r i k i n g and the a b i l i t y to implement them both 
using the same mechanism is surprising. 
　　a shortcoming of uniform and prolog is t h e i r i n a b i l i t y to use negative information. in the previous example of association l i s t s we cannot prevent a key from having more than one a s s o c i a t i o n . uniform w i l l be extended to be able to use the f o l l o w i n g : 
 assert 
	 not  = 	 association-of 
key 
	 cons   l i s t key value  	r e s t     
	 not 	v a l u e         
this would cause the u n i f i c a t i o n to f a i l if the key is found but the values do not u n i f y . negative information can be used in a default strategy which concurrently t r i e s to unify two descriptions and to show that they are not u n l f i a b l e . 
　　in the process of u n i f i c a t i o n a variable may acquire m u l t i p l e constraints. as a default  uniform simply conjoins them. if later an attempt is made to give the variable a value  then the c o n s t r a i n t s disappear if the value s a t i s f i e s them  otherwise it f a i l s . inconsistent constraints do not cause f a i l u r e unless there is an attempt to use them. if the constraints have a unique solution then only that value can unify with them  but the system does not compute that value. the u n i f i c a t i o n of constraints appears to be a natural place to use some of the constraint s a t i s f a c t i o n techniques found in steele and sussman's constraint system  1  and the xprt system  1 . 
　　we have explored the u n i f i c a t i o n of descriptions of programs. exploring the u n i f i c a t i o n of other complex structures such as frames  s c r i p t s   and u n i t s should be equally valuable. much of what systems such as frl  xprt  sam and krl do is match complex declarative structures with others. u n i f i c a t i o n   a more general and powerful process than pattern matching  promises to be very useful for dealing with these structures. 
　　as has been pointed out elsewhere   1  among others  there is much to be gained by separating the control and logic components of an algorithm. uniform programs have much less control information in them than equivalent lisp or act 1 programs. a general search strategy is used as a default so that the factual or competence component of programs can be developed and tested without the added complexity of being concerned with e f f i c i e n c y . the e f f i c i e n c y can be put in l a t e r and kept l e x i c a l l y separate from the rest of the program. a compiler is planned which w i l l be experience in using uniform is lacking. 	concurrent with the research suggested above  uniform needs to be tested by w r i t i n g large complex programs in i t . in t h i s respect uniform is way behind lisp e t . 	a l . 
