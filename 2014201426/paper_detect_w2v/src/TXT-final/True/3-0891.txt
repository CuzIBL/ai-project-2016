
bin-completion  a bin-oriented branch-and-bound approach  was recently shown to be promising for the bin packing problem. we propose several improvementsto bin-completionthat significantly improves search efficiency. we also show the generality of bin-completion for packing and covering problems involving multiple containers  and present bin-completion algorithms for the multiple knapsack  bin covering  and min-cost covering  liquid loading  problems that significantly outperform the previous state of the art. however  we show that for the bin packing problem  bin-completion is not competitive with the state of the art solver.
1 introduction
many np-hard problems involve packing some set of discrete objects into multiple containers   bins  . in one class of problems  the objective is to pack some items into a set of containers without exceeding the containers' capacities. in a related class of problems  the goal is to cover a set of containers by filling them up to at least some minimal level using a set of items. when both the containers and the items are modeled as one-dimensionalobjects  possibly with an associated cost/value function   we refer collectively to these problems as one-dimensional  multicontainer packing and covering problems  or multicontainer packing problems in short. multicontainer packing problems are ubiquitous  and model many ai applications including the allocation and rationing of resources or tasks among a group of agents  as well as operations research problems such as cargo loading and transport.
　the most widely studied instance of a problem in this class is the bin packing problem: given a set of items  numbers   and a fixed bin capacity  assign each item to a bin so that the sum of the items assigned to each bin does not exceed the bin capacity. for example  given the set of items 1  1  1  1  1  1  and a bin capacity of 1  we can assign 1  1  and 1 to one bin  and 1  1  and 1  to another  for a total of two bins. this is an optimal solution to this instance  since the sum of all the items  1  is greater than 1  and hence at least two bins are required.
　in this paper  we consider complete algorithms for finding optimal solutions to multicontainer packing problems. multicontainer packing problems are generally strongly np-hard  garey and johnson  1   including all of the problems covered in this paper . therefore  state of the art  complete algorithms for finding optimal solutions are based on branchand-bound. in contrast  note that single-container problems such as the classical 1 knapsack problem are weakly nphard  and pseudopolynomial time dynamic programming algorithms exist  c.f.  kellerer et al.  1  .
　previous branch-and-bound algorithms for these problems have tended to be  item-oriented . for example  the classical algorithm for bin packing is the martello and toth algorithm  martello and toth  1 . items are considered one at a time. each node in the search corresponds to a decision regarding the assignment of an item to some non-full container. in contrast  bin-completion is a  bin-oriented  branchand-bound strategy  where a node represents an assignment of a set of items to a single container. in addition to standard branch-and-bound pruning methods  a combinatorial dominance criterion is used to prune search.
　this paper begins by reviewing the previous work on bincompletion. we then propose several improvements  including a generalization of the nogood pruning method proposed in  korf  1  that significantly improves search efficiency. we demonstrate the generality of the bin-completion approach by presenting new bin-completion algorithms for the multiple knapsack  bin covering  and min-cost covering problems that significantly outperform the state of the art algorithms.
1 bin-completion
bin-completion is a bin-oriented branch-and-bound strategy that exploits dominanceproperties to reduce the search space. for clarity  we describe the bin-completion algorithm and our extensions in the context of the bin packing problem due to its familiarity and simplicity  although the focus of our empirical work is on other multicontainer problems.
　a feasible set is a set of items whose sum satisfies the capacity constraint  i.e.  does not exceed the bin capacity . we say that a feasible set or bin assignment is maximal if no additional item can be added to the set without making the set infeasible. the items are sorted in decreasing order of size. we then generate maximal  feasible sets that include the largest item. if thereis morethan onesuch set  the search may branch at that point. each node of the search tree  except the root node  represents a complete  feasible assignment of items to a particular bin. the children of the root represent different ways of completing the bin containing the largest item. the nodes at the next level represent different complete  feasible sets that include the largest remaining item  etc. the depth of any branch of the tree is the number of bins in the corresponding solution. bin-completion is a branch-and-bound algorithm. it starts with an upper bound  such as the bestfit decreasing solution  and applies a lower-bound heuristic function to prune the search. rather than assigning items one at a time to bins  it branches on the different maximal  feasible sets that can be assigned to each bin.
　the key to making bin-completion efficient is the use of a dominance criterion on the maximal  feasible sets that allows us to only consider a small subset of them.
　let	and	be two feasible sets. if the elements in	can be partitioned into subsets  and these subsets can be matched to the elements of	such that the sum of the elements in each subset doesn't exceed the corresponding element of	  then set	dominates set	. in other words  if the elements of	can be packed into bins whose capacities are the elements of	  then set	dominates set	. for example  let and let	. partition	into the subsets	 	  and	. since 1 + 1 	  and	  set	dominates set	. given all the feasible sets that contain a common element   only the undominated sets need to be considered for assignment to the bin containing . the reason is that if we complete the bin containing	with a dominated set  then we could swap each subset of items in the dominated set with the corresponding element of the dominating set  and get another solution without increasing the total number of bins.
　this dominance criterion was proposed by martello and toth  martello and toth  1   and was used in their branchand-bound algorithm for bin-completion. however  their branch-and-bound algorithm was item-oriented  and they only exploit this dominance property in a limited way. in particular  they take each item   starting with the largest element  and check if there is a single assignment of one or two more elements that dominates all feasible sets containing . if so  they place with those elements in the same bin  and apply the reduction to the remaining subproblem. they also use dominance relations to prune some element placements as well. korf's bin-completion algorithm  korf  1  makes much greater use of the martello-toth dominance criterion. in particular  when branching on the completion of any bin  it only considers undominated completions.
　historically  the first bin-completion algorithm we are aware of was proposed by christofides  mingozzi  and toth in 1 for the liquid loading problem  which we call the min-cost covering problem  see section 1   christofides et al.  1 . although their algorithm performs a bin-oriented branch-and-bound which considers only undominated completions  they use a much weaker dominance criterion  see section 1 . however  subsequent research in branch-andbound algorithms for multicontainer problems focused on item-oriented approaches  and the bin-completion approach was apparently not investigated further until recently.
　the bison algorithm for bin packing by scholl  klein  and jurgens  scholl et al.  1  is a hybrid algorithm that integrates a suite of complex lower bounding procedures  upper bounding heuristics  and a branch-and-bound algorithm. the branch-and-bound component of bison is a bin-completion algorithm where each node corresponds to a maximal  feasible bin assignment. a very limited form of the martello-toth dominance criterion is applied  as follows. if a maximal  feasible bin assignment has a pair of items that can be replaced by single unassigned item without decreasing the sum of the assignment  then it is dominated  and this node can be pruned. korf implemented a bin-completion algorithm for bin packing using the full martello and toth dominance criterion  and showed that it significantly outperformed the martello-toth item-oriented branch-and-bound algorithm  korf  1 . further improvements were achieved by using a more efficient algorithmfor generating the undominatedbin assignments  and nogood pruning  see below   korf  1 .
1 extensions to bin-completion
1 nogood dominance pruning
suppose we have a bin packing instance with the numbers 1 1 1 1 1  and bin capacity c=1. let represent a bin assignment at depth . 1 1 and 1 1 are two undominated feasible bin assignments  and thus
　　　　and are two possible assignments of the bin  node  at depth 1.
　korf  korf  1  proposed the following nogood pruning technique. after exhausting the subproblem below the assignment   and while exploring the subproblem below the assignment   assume we find a solution that assigns . we can swap the from with the from   resulting in a solution with and and . however  we have already exhausted the subtree below   and therefore  we can prune this branch because it is redundant.
　in general  given a node with more than one child  when searching the subtree of any child but the first  we don't need to consider bin assignments that assign to the same bin all items used to complete the current bin in a previouslyexplored child node  except for the largest element. more precisely  let be a set of brother nodes in the search tree  and let be the sets of items used to complete the bin in each node  excluding the first item assigned to the bin  which is common to all the brother nodes.
when searching the subtree below node	for	: for all
       we exclude any bin assignment that  1  includes all the items in in the same bin  and  1 swapping from with the items in results in two feasible bin assignments. by rejecting these bin assignments as redundant  the number of node generations is reduced.
　we now propose an extension to this idea that allows pruning even more nodes  which we call nogood dominance pruning  or ndp. suppose that after exhausting the subproblem below the assignment   and while exploring the subproblem below the assignment   we consider the assignment . we can swap the from	with the	from	and end up with a solution with the	and	.
however  according to the martello-toth dominance criterion  is dominated by   and we have already exhausted the search below the node with the subtree under   so we can prune the search because it is not possible to improve upon the best solution under	.
　in general  given a node with more than one child  when searching the subtree of any child but the first  we don't need to consider assignments that are dominated by a bin assignment in a previously-explored child node. more precisely  when searching the subtree below node for   we exclude any bin assignments that are dominated by the items in   for . note that an assignment dominates itself. thus  no bin completion below node can be dominated by the items in   for .
　nogood dominance pruning is strictly more powerful than korf's nogood pruning. any node pruned by nogood pruning will be pruned by ndp  but not vice versa. of course  since ndp must detect dominancerelationshipsas opposedto equivalence relationships  ndp will incur more overhead per node compared to nogood pruning. our current implementation propagates a list of nogood sets along the tree. while generating the undominated completions for a given bin  we check each one to see if it is dominated by any current nogood. if so  we ignore that bin-completion.
　since the size of the nogood list increases with depth  and we compare each bin-completion against each nogood  the per-node overhead of ndp increases with depth. this means that pruning at the bottom of the tree  where pruning has the lowest utility  is more expensive than pruningat the top of the tree  where pruning has the highest utility . a simple strategy which address this issue is depth-limited ndp  where ndp pruning is applied only at nodes down to the ndp depth limit . at nodes below the depth limit  korf's original nogood pruning technique is applied.
　in this section  we have described nogood pruning and ndp in the context of the bin packing problem. adaptations of the technique for the multiple knapsack and bin covering problem are straightforward  given the dominance criteria used for these other problems.
1 further modifications to the search algorithm
in korf's algorithm for bin packing  at each node  the undominated feasible bin assignments are generated  and sorted according to decreasing sum. the algorithm branches on the completions according to the sorted order. in other words  a largest-sum-first value ordering heuristic is being applied at each node.
　an issue with enumerating all undominated completions and applying value ordering is that computing the undominated sets is itself np-complete. korf  korf  1  gives an algorithm that generates all and only undominated bincompletions  without the need to generate dominatedcompletions as intermediate results. let be the average number of items that fit in a container. the time to generate all undominated feasible assignments of a bin increases with . this is not an issue for bin packing  where problems with large tend to be easily solved using heuristics such as best-fit decreasing. the solution found by the heuristic often equals the lower bound  and therefore no search is required  and hence there is no need to compute undominated completions. however  for the other three problems we considered  we have observed that it is much less likely that heuristics will match the optimistic bound and allow termination without search  and we have found that for instances with high   the algorithm would either take a very long time to complete  or not terminate within a reasonabletime limit because it was spendingan inordinate amount of time computing the set of undominated completions at each node. another significant drawback of completely enumerating the undominated bin assignments at each node is the memory required to store all of them.
　an alternative approach is to start to go down the search tree and explore the children of a node without first enumerating and sorting the children. in cases where a good optimistic bound  i.e.  lower bound for bin packing  and upper bound for bin covering and multiple knapsack  is available  and it takes relatively little search to find an optimal solution  this approach can result in significant speedups compared to the original scheme of generating all completions before going further down the search tree.
　on the other hand  we have observed that the valueordering strategy used to sort the undominated children of a node has a significant impact  and if we simply traverse the search tree depth-first without first enumerating and sorting the children  we lose the benefits of ordering the search tree according to the value-ordering heuristic. the negative impact of this can be alleviated by a hybrid strategy that generates a small number of children  applies the value-ordering heuristic to these  then recursively calls bin-completion on the remaining subproblem. we call this the hybrid incremental branching strategy.
　note that even in the absence of an explicit value ordering strategy  the algorithm used to generate the undominatedchildren  for each problem  we use an adaptation of the algorithm given by korf  korf  1   imposes an implicit ordering on the undominated assignments. we are currently evaluating various combinations of hybrid incremental branching and various value ordering strategies  and the choices reported in this paper for value ordering strategies and the number of undominated assignments generated at once in hybrid incremental branching are preliminary.
1 the multiple knapsack problem
the multiple knapsack problem  mkp  is a generalization of the classical 1 knapsack problem. consider bins of capacities . and a set of items that have a weight and a profit . the goal of the mkp is to assign some subset of the items to each bin such that:  1  each item is assigned to no more than one bin  and  1  the sum of the weights of the items assigned to a bin does not exceed the bin's capacity  and  1  the total profit of the items that are assigned to a bin are maximized. for example  suppose there are two bins with capacity 1 and 1  and 1 items  1   1   1   1   where the first element of each pair is the weight of the item and the second element is the profit of that item. the optimal solution to this mkp instance is to assign  1  and  1  to the bin with capacity 1  and the item  1  to the bin with capacity 1. the mkp has numerous industrial applications. for example  the problem of loading vehicles with cargo selected from items in order to max-
imize the value of the transported items is a mkp instance.
1 the mulknap algorithm
the state of the art algorithm for the mkp is pisinger's mulknap algorithm  pisinger  1 . mulknap is a branch-andbound algorithm  where each node represents a decision as to which bin to place an item into  or to leave it out entirely. there are several well-known upper bounds for the mkp. recent algorithms  including mulknap  rely on the solution of the surrogate relaxed multiple knapsack problem  smkp  instance  martello and toth  1   which is a single-container 1 knapsack problem where the items are the same as for the original mkp instance  but there is a single container whose capacity is the sum of the capacities of the containers in the original mkp instance. although the 1 knapsack problem is also np-complete  weakly npcomplete  since there is a pseudopolynomial algorithm   this upper bound computation is very fast in practice. at each node  mulknap attempts to validate the upper bound for the remaining subproblem by distributing the set of items chosen as the solution for the smkp into the bins. if such a distribution is possible without violating the bin capacities  then the upper bound has been achieved  and we can backtrack without further search down the current branch. the distribution is done by solving a series of subset-sum problems. first  the smallest knapsack is filled as much as possible with the items from the smkp solution. then the second smallest is filled with items from the remainder of the smkp solution  and so on. again  while this entails the solution of subset sum instances  it is fast in practice  takes less time than the upper bound computation using the smkp . in addition  mulknap also incorporates techniques for reducing the problem instance at every node  as well as tightening the capacity constraints. see  pisinger  1  for details.
1 bin-completion for the mkp
we define a dominance criterion for the mkp as follows: in a feasible bin assignment for a bin with capacity   the sum of the item weights is no more than .
let	and	be two feasible assignments.	dominates if	can be partitioned into	subsets	such that each subset	is mapped one-to-one  but not necessarily onto  to
　  an element of   and for all    1  the weight of is greater than or equal the sum of the item weights of the items in   and  1  the profit of item is greater than or equal to the sum of the profits of the items in .
　our bin-completion algorithm for mkp uses the same upper bound and reduction techniques as mulknap. our current implementation uses a hybrid incremental branching strategy  see 1  that generates two undominated children at a time  then uses a value ordering strategy that sorted them according to descending order of profit sums.
　we evaluated our mkp algorithm using the same 1 classes of instances used by pisinger  pisinger  1 . we considered:  1  uncorrelated instances: and are uniformly distributed in    1  weakly correlated instances: uniformly distributed in  1  and randomly distributed in     such that    1  strongly correlated instances: uniformly distributed in  1  and
             and  1  multiple subset sum instances: uniformly distributed in  1  and . the bin capacities were set as follows: the first capacities were uniformly distributed in
for	. the last capacity	is chosen as
to ensure that the sum of the capaci-
ties is half of the total weight sum  if the first capacities exceeded half the total weight  the instance was discarded . for each problem class  1 instances were generated for various values of and . trivial instances were discarded as in  pisinger  1 . the class of uniform  random instances that require the most search for branch-and-bound solvers appear to be generated when is relatively low  pisinger  1; martello and toth  1 . thus  the ratio for the mkp appears to be a critical parameter that determines search difficulty. pisinger has shown that for problems with high ratio  mulknap is highly effective  solving very large instances almost instantaneously with little or no search  when ranged from 1 to 1  and ranged 1 or 1 . on the other hand  small ratios between 1 result in the hardest problems. we therefore focus on these hard problems.
　on each instance  we ran mulknap  bin-completion  and bin-completion with nogood dominance pruning  bc+ndp . for comparison  we used pisinger's mulknap code  available at his website  1 compiled using the gcc compiler with -o1 optimization settings. our bin-completion code was implemented in common lisp.1 table 1 shows our results. all experiments were run on a 1ghz amd athlon. each algorithm was given a time limit of 1 seconds to solve each instance. the fail column indicates the number of instances  out of 1  which could not be solved by the algorithm within the time limit. the time and nodes column show the total time spent and nodes generated on the successful runs  excluding the failed runs. thus  the most important indicator of performance is the number of failed runs.
　both bin-completion and bc+ndp significantly outperform mulknap  with the difference in performance becoming more pronounced as problem size was increased. this indicates that bin-completion is asymptotically more efficient than mulknap for this class of problems. bc + ndp consistently outperforms bin-completion by a significant margin with respect to the number of nodes searched  and significant improvements in success rate and runtimes are observed for the larger problems sets. similar results were obtained when the items had weights and profits in the range  1   as
mulknapbin-completionbin-completion + ndp m n failtimefailtimenodesfailtimenodesuncorrelated instances
11111111111111111-11111-111weakly correlated instances
1111111-1111111111-11111-111strongly correlated instances
1111111-1111111111-11111-111subset sum instances
11111111111111111-11111-111table 1: multiple knapsack results.  times are in seconds .
well as the range  1 .
1 the bin covering problem
suppose we have items with weights   and an infinite supply of containers with quota . the bin covering problem  also known as the dual bin packing problem  is to pack the items into containers such that the number of containers that contain sets of items whose sum is at least is maximized. that is  the goal is to distribute  or ration the items among as many containers as possible  given that the containers have a specified quota that must be satisfied. note that the total weight of the items placed in a container can be greater than .
　bin covering is a model for resource or task allocation among multiple agents where the goal is to maximize the number of agents who fulfill some quota. it is also a model for industrial problems such as:  1  packing peach slices into cans so that each can contains at least its advertisednet weight in peaches  and  1  breaking up monopolies into smaller companies  each of which is large enough to be viable  assman et al.  1 .
1 the labbe ＞ laporte  and martello algorithm
the state of the art complete algorithm for the bin covering problem is by labbe＞  laporte  and martello  labbe＞ et al.  1 . we shall refer to this as the llm algorithm. llm is a branch-and-bound algorithm. the items are sorted in decreasing order of size. each node represents a decision as to which bin to put an item into  or to leave it out entirely. at each node  lower bounds based on combinatorial arguments are computed  and the remaining subproblem is reduced using two reduction criteria  see  labbe＞ et al.  1  . at the root node  a set of heuristics is applied in order to compute a lower bound. as with the bin packing problem  c.f.  korf  1    many instances of the bin covering problem require
nlabb＞ebin-completionbin-completion + ndpfailtimefailtimenodesfailtimenodes1 instancesper row1111111111111111111111111111 instancesper row1n/an/a1111n/an/a1111n/an/a1111n/an/a111table 1: bin covering results.  times are in seconds .
no search  and can be immediately solved at the root node when the heuristics described in  labbe＞ et al.  1  compute a lower bound that equals the upper bound.
1 bin-completion for bin covering
we define a dominance criterion for bin covering as follows.
let and be two feasible assignments. dominates if can be partitioned into subsets such that each item is mapped one-to-one  but not necessarily onto  a subset   such that for all   the sum of the item weights of subset is greater than or equal to the corresponding item  i.e.   covers   .
　to see that this dominance criterion gives a valid pruning criterion  suppose a solution to a bin-completion instance assigns to a bin. if we exchange the items in for the corresponding subsets of   then this would result in a valid solution that satisfies at least as many bins.
　as with llm  we apply lower bounding heuristics at the root node  and apply the same upper bounds used in llm  labbe＞ et al.  1  at each node. we use a hybrid incremental branching strategy that generates two undominated children at a time  then using smallest-sums-first value ordering to order them.
　we compared our implementation of bin-completion for the bin covering problem with our implementation of the llm algorithm both implementationswere in commonlisp and run on a 1mhz pentium 1 . we generated 1 random instances for each set  where the items were chosen uniformly in the range  1   and the quota was 1. we ran our implementations of llm  bin-completion  and bin-completion + ndp on each instance  with a time limit of 1 seconds per instance. we also compared the two bin-completion variants on larger instances of 1 items  using sets of 1 random instances. table 1 shows our results. again  we show the number of failed runs that timed out before solving the instance  as well as the time spent and nodes generated  excluding the failed runs. bincompletion significantly outperformed llm. the increasing gap in performance as problem size increases suggests that bin-completion is asymptotically more efficient than llm. for the harder problems  bin completion + ndp significantly outperforms bin-completion.
1 min-cost covering
we define the min-cost covering problem  mccp  as follows. given a set of bins with quotas   and a set of items with weights and costs   assign some subset of the items to each bin such that  1  each item is assigned to no more than one bin   1  the sum of the weights of the items assigned to a bin is at least the bin's capacity  i.e.  the bin is covered  as in bin covering   and  1  the total cost of the items that are assigned to the bin are minimized. this problem has also been called the liquid loading problem  christofides et al.  1   because it was originally motivated by the following industrial application: consider the disposal or transportation of different liquids  e.g.  chemicals  that cannot be mixed. if we are given tanks of various sizes  each with some associated cost  the problem is to load the liquids into some subset of the tanks so as to minimize the total cost. note that here  the  liquids  correspond to containers  and the  tanks  correspond to the items.
1 christofides  mingozzi  and toth  cmt  algorithm
the previous state of the art algorithm for the min-cost covering problem is an early version of bin-completion by christofides  mingozzi  and toth  christofides et al.  1 . the main difference between their algorithm and the bincompletion algorithm described in section 1 is their use of a different dominance criterion. the christofides et al. dominance criterion  cmt criterion  is as follows. a set of items dominates another set if is possible to map one-toone to  but not necessarily into  by a function such that
	  and	.
　note that the cmt criterion only considers mappings between single elements of and   whereas the dominance criteria we have described above for bin packing  mkp  and bin covering considers mappings between elements of and subsets of .
　christofides et al. empirically evaluated a number of lower bounds for the mccp. they found that the best bound was computed by solving single-container mccp problems  one for each of the bins  where all items were available for the single-bin mccp problem. each single-bin instance was solved using a simple branch-and-bound algorithm. the lower boundis the sum of the optimal values for the singlecontainer mccp problems. this is essentially a lower bound derived by relaxing the mccp constraint that each item can be assigned to at most one bin.
1 bin-completion for the mccp
our new bin-completionalgorithmfor the mccp is similar to the christofides et al. algorithm. the major difference is that we use the following dominance criterion. a set of items
dominates another set if can be partitioned into subsets such that each item is mapped one-to-one  but not necessarily onto  to a subset   and for all    1  the weight of is less than or equal to the sum of the item weights of the items in   and  1  the profit of item is less than or equal to the sum of the profits of the items in
   . the cmt dominance criterion is a special case of this criterion  where for all .
　we evaluated our bin-completion algorithm and the cmt algorithm using the same classes of problem instances that we used for the mkp  section 1 . for each problem class 
1 nontrivial instances were generated for various values of and . the purpose of this experiment was to evaluate the relative impact of each component of bin-completion  that is:  1  the type of dominance criterion used   1  whether nogood pruning was used  and  1  whether nogood dominance pruning was used.
　on each instance  we ran  1  cmt1: the cmt algorithm as presented in  christofides et al.  1    1  cmt1: the cmt algorithmextendedwith nogoodpruning  1  bc1: bincompletionusing ourdominancecriterionbut without nogood pruning   1  bc1: bin-completion using our dominance criterion and with nogood pruning   1  bc1: bin-completion using our dominance criterion and ndp. for all algorithms  a hybrid incremental branching strategy that generated 1 children at a time was used  and the children were ordered in increasing order of profit sums.
　table 1 shows our results. all experiments were run on a 1ghz pentium iv. each algorithm was given a time limit of 1 seconds to solve each instance. the fail column indicates the number of instances  out of 1  which could not be solved by the algorithm within the time limit. the time and nodes column show the total time spent and nodes generated  excluding the failed runs. as shown by the data  each component of bin-completion has a significant impact. although our dominance criterion requires much more computation per node to compute than the simpler cmt criterion  the performance is significantly improved. the nogood pruning strategy significantly improves performance for both the algorithm based on the cmt dominance criterion  as well as our dominance criterion. finally  bc1  which uses ngd is results in the best performance. we also tested an item-oriented branch-and-boundalgorithm that uses the same lower bounding procedure  but found that it performed even worse than the cmt algorithm on all of the test instances.
1 bin packing
we implemented our extended bin-completion algorithm for the bin packing problem  and summarize our results below. for further details  see  fukunaga  1 .
cmt1cmt1bc1bc1bc1 m n failtimefailtimefailtimefailtimefailtimeuncorrelated instances11111111-1-1-1111111111111111-11-11than one higher than the optimal value  c.f.  wa：scher and gau  1  . in addition  rounding heuristics applied to fractional lp-solutions often yields the optimal  integral solution. the combination of a very tight lp lower bound and good upper bounding procedure result in very little search being performed for almost all problem instances. this domain-　extending korf's algorithm  korf  1  with ndp and a value ordering based on minimum cardinality  with ties broken according to decreasing sum of item weights  resulted in significant speedups over korf's algorithm on uniform random problem instances  as well as the class of  uniform  or-lib1 instances of 1 items  for the same experiments described in korf's paper  korf  1 . in addition  extending the algorithm further by applying randomizedrestarts  gomes et al.  1  resulted in significant speedups compared to korf's algorithm on the  triplet  instances from orlib. for example  our extended algorithm  implemented in common lisp and executed on a 1ghz athlon  solves all 1 of the triplet instances from or-lib within 1 seconds combined  whereas korf's algorithm  implemented in c and executed on a 1mhz sun ultrasparc  failed to solve any weakly correlated instances
11111111-1-1-1111111111111111-111111-1-1-11strongly correlated instances
11111111-1-11111111111111111-1111subset sum instances
11111111-1-11111111111111111111111-1111table 1: min-cost covering problem.  times are in seconds .
of the twenty 1-item instances  and failed to solve 1 of the 1-item instances given a 1 minute time limit per instance. see  fukunaga  1  for further results.
　however  our bin-completion solver was not competitive with the state of the art  which is currently a branch-andprice integer linear programming solver by belov and scheithauer  belov and scheithauer  1 . belov and scheithauer  belov and scheithauer  1  provide a new benchmark set of 1 very hard bin packing instances; they solved most of these within seconds  although some took hours. our current bin-completion code could not solve any of the 1 instances  given 1 minutes per instance. they also report that the largest triplet instances from or-lib  triplet-1  were solved in an average of 1 seconds per instance  1 seconds total  on a 1ghz amd athlon xp.
　furthermore  belov was kind enough to run a set of one hundred  1-item  uniform  random instances that we generated with items in the range  1 1  and a bin capacity of 1 1 for us. his solver solved all of these instances in less than 1 second each at the root node  i.e.  without any search   using rounding heuristics based on the linear programming lp solution  whereas our best bin-completion solver required 1 seconds and searched 1 1 nodes.
　recent branch-and-price approaches for bin packing such as the solver by belov and scheithauer  see  de carvalho  1  for a survey of others  use a bin-oriented branching strategy  where decisions correspond to the instantiation of one or more complete bins. at each node  a column generation procedure is used to compute the lp lower bound. they derive much of their power from a very accurate lp lower bound based on a cutting stock formulation of bin packing  gilmore and gomory  1   which has been observed to almost always give the optimal value as the lower bound  and has never been observed to give a value that is more specific branch-and-price lp-based approach does not seem to generalize straightforwardly to the mkp and mccp  in part due to the differences in the granularity of the objective function. while it is possible that a similar branch-and-price approach could be applied to the bin covering problem  we are aware of no such approach in the literature.
　for completeness  we have applied a straightforward  integer-linear programming approach to the mkp  mccp  and bin covering problems. we applied the gnu glpk integer linear programming solver to the mathematical programming formulations of these problems  but not surprisingly  these performed very poorly in comparison with the domainspecific algorithms described in this paper.
1 related work
the multicontainer packing problems we studied in this paper can be formulated as constraint programming problems. in one possible formulation  the variables correspond to bins  and the values of the bins correspond to unique  feasible bin assignments  this is similar to the integer linear programming formulation of the cutting-stock problem  gilmore and gomory  1  . for example  given items with weights let be the variable representing the first bin with capacity 1. the domain of is the two singleton sets and .
　given this constraint programming formulation  it can be seen that the pruning techniques based on nogoods described in section 1 are closely related to techniques proposed forconstraint programming. nogoodpruningidentifies and prunes nodes by detecting whether the bin assignment for the current node contains a nogood. this is very similar to nogood-based techniques for pruning symmetric solutions proposed by fahle  schamberger and sellmann  fahle et al.  1  and focacci and milano  focacci and milano  1  
　the ngd technique proposed in this paper is similar to the nogood dominance pruning technique proposed by focacci and shaw  focacci and shaw  1  for constraint programming  who applied their technique to the symmetric and asymmetric traveling salesperson problem with time windows. see  focacci and shaw  1  for a full description of their technique.
　both methods attempt to prune the search by proving that the current node at depth   which represents a partial variable solution   is dominated by some previously explored -variable partial solution  nogood   .
　the main difference between the two methods is the approach used to test for dominance. focacci and shaw's method extends to a -variable partial solution which dominates . they apply a local search procedure to find the extension .
on the other hand  our ngd method starts with a partial 
 -variable solution and tries to transform it to a partial solution such that   the subset of including the first variables  is dominated by . we do this by swapping the values of the th and th variables in to derive   and testing whether is dominated by .
　for efficiency  the current implementations of both nogood dominance pruning methods are weak  in the sense that if is dominated by   the procedures will not necessarily detect the dominance. focacci and shaw rely on an incomplete  local search to find the extension . we only consider transformations involving two variables  but to fully exploit the dominance criterion  we would need to consider transformations involving all variables .
1 conclusions
this paper makes two main contributions: first  we proposed extensions to bin-completion to improve its performance  including nogood dominance pruning  which generalizes korf's nogood pruning method. second  we demonstrated the utility and generality of bin-completion by applying it to three new problems: the bin covering problem  the multiple knapsack problem  and the min-cost covering problem. we proposed new dominance criteria for these problems  and showed that our bin-completion solvers significantly outperform   the previous state of the art on hard instances  in some cases by orders of magnitude with respect to runtime . for these three problems  our nogood dominance pruningtechnique significantly reduced search effort and runtimes. the comparison of our bin-completion algorithm to the early bin-completion algorithm by christofides et al. for the mccp showed that our new dominance criteria resulted in significant performance improvements.
　finally  we revisited the bin packing problem and showed that our extensions significantly improvedthe performanceof bin-completion for some standard benchmarks. however  we found that bin-completion is not competitive with state of the art solvers for bin packing based on the cutting stock problem formulation.
　while we have focused on four particular multicontainer problems in this paper  there are many similar problems involving the assignment of objects to multiple containers where similar dominance structures can be exploited. examples include the generalized assignment problem  multiprocessor scheduling  and the segregatedstorage problem. given our results  maximally exploiting powerful dominance criteria in a bin-completion framework appears to be a promising future direction for such multicontainer problems.
1 acknowledgments
thanks to gleb belov for running his solver on some of our bin packing test instances  and to the anonymous reviewers for helpful comments. this research was supported by nsf under grant no. eia-1.
