ion: 
two criteria for localized planning 
a m y l laneky lise c getoor 
recom technologies/nasa ames research center 
artificial intelligence research branch 
ms 1  moffett field  ca 1 
	laskyoptolent arc masa gov 	getooroptolemy 	arc ia1a gov 

abstract 
localization is a general-purpose representational technique for partitioning a problem into subproblems a localized problem-solver searches several 
smaller search spaces  one for each subproblem unlike most methods of partitioning  however  localization allows for subproblems that overlap - 1 e multiple search spaces may be involved in constructing shared pieces of the overall plan in this paper we focus on two criteria for forming localizations scope and abstraction we describe a method for automatically generating such localizations and provide empirical results that contrast their use in an office-building construction domain 
1 	introduction 
over the years  many researchers have focused on the use of abstraction to reduce search costs for planning and other types of problem-solving  1  1  1  1  1  1  abstraction techniques restructure a problem and the problem-solving process into a set of  abstraction levels   at the top level of abstraction  a problem is described at its most coarse-grained level of detail each successive level is made more concrete by incrementally adding information to the problem description the use of abstraction can improve problem-solving performance if the solution found for an abstract level serves as a good starting point for problem-solving at the next level of detail thus  abstraction may be viewed as a heuristic for ordering which pieces of a problem are solved first  and which later 
　our work also focuses on partitioning a problem to improve problem-solving  in our case  planning  performance our technique  localization  restructures a planning problem by partitioning its components into regions semantically  each region defines a  region of interaction  consisting of a subset of the overall problem requirements and action-type descriptions that are related in some way a problem's regional structure then forms a basis for partitioning the overall planning apace 
1 	planning 
into a set of smaller spacea  one for each region each space is focused on constructing a plan fragment that contains region actions and satisfies region requirements 
　for example  consider the localization depicted in figure 1 for a building construction domain this partitioning is based on mixed criteria level of detail  contractor agents  and building-structure each box represents a region and contains the names of action types within that region's frame of reference some boxes also contain other boxes - those of their subregions each region would be associated with the requirements pertaining to its action types or the action types of its subregions for example  problem solving for painter would focus strictly on painting activities and requirements in contrast  region rooma would focus on the decomposition of high-level activities into lower-level e l e c t r i c i a n and painter activities for rooma 
　there are at least two ways in which localization differs from traditional uses of abstraction for planning first  localization more strictly partitions the frame of reference for problem solving  region requirements are satisfied only with respect to a region plan fragment  not the entire global plan in contrast moat abstractionbased frameworks conduct reasoning globally at the lowest level of detail 
　second  localized search can accommodate complex region structures instead of being confined to partitionings composed of  levels   the regions comprising a localization may take on nearly any configuration - dis-
joint  hierarchical  overlapping indeed  since regions may overlap  localized problem-solving typically flows back and forth among the regional search spaces  usually  to cope with region interactions  rather than searching a sequence of problem levels the localized search algorithm maintains consistency between these search spaces and the plan fragments that they generate  and also guarantees that all regional requirements are ultimately satisfied  1  1  
　in contrast  a traditional abstraction-based planner can revisit a planning level only via backtracking be-

cause of this  abstraction researchers have focused on devising partitioning techniques that guarantee minimal interaction between levels  thus minimizing backtracking  unfortunately  however  real-world problems do not often lend themselves to neat partitioning  as a result  levels tend to collapse 

figure 1 a construction problem localization 
　as our sample domain illustrates  many criteria can be used to form a localization indeed  one criteria is abstraction  a region could be formed to correspond to each abstraction level localized search would then proceed from one region-level to the next  as in traditional abstraction-based planning one focus of this paper is to show how knoblock's method for generating abstractionbased partitionings  can be used to automatically generate abstraction-based localizations  even for nonstrips-based planning frameworks as in knoblock's work  our method yields a partitioning that guarantees monotonicity in the planning process if a solution exists for a particular region  level   it can be found by refining a solution found at the preceding region  level   without disturbing established requirements a region partitioning based on this form of abstraction will thus yield a search process that visits each region space only once  except for backtracking  
　another interesting criterion for localization is scope - 1 e the relevance of problem requirements to specific portions of the plan scope-based partitionings typically correspond to the natural structural characteristics of a problem for example  when planning how to construct a building  some problem requirements will be relevant only to plumbing activities and others only to electrical activities alternatively  requirements might be clustered on the basis of building structure - e g   rooms and 
floors  again  see figure 1  
　localizations based on scope usually do not guarantee monotonic consideration of region requirements region search spaces may be visited more than once  even without backtracking for example  in the scenario depicted in figure 1  we might begin by constructing a high-level plan in region high-level these high-level activities might then be further refined on a room-by-room basis the planner might start by planning electrical and painting activities for rooma  then plan out plumbing activities for roomb  and finally return to painting activities for roomb  thereby causing a return to the paintar search space  although they may not guarantee monotonicity  scope-based localizations can provide powerful search reduction benefits  often surpassing those obtained using abstraction 
　the primary goal of this paper is to demonstrate how localization can improve problem solving and  in particular  how scope and abstraction serve as criteria for localization we begin in sections 1 and 1 by describing the localized planning architecture of the collage planner  1  1  and the kinds of search improvements that localization can provide next  sections 1 and 1 discuss how scope and abstraction can be used as criteria for generating localizations in particular  we describe how the loc localization generator was used to generate scope and abstraction-based localizations tor collage finally  in section 1  we provide empirical results that contrast the utility of a variety of localizations for an office-building planning domain we also contrast our results with those obtained using sipe-1 on the same domain  1  1  
1 	localized planning 
collage differs from traditional planners in two key ways its use of localization to partition the planning search space and its use of non-traditional plan construction methods in this section we provide a short description of both for a more thorough description see  
　intrinsic to collage is the notion of planning as constraint satisfaction each collage problem description includes a set of action types and a set of constraints the planner's task is to create a plan consisting of actions of the types provided that satisfies all problem constraints each plan  or plan fragment  consists of actions  relations between actions  forming a partial ordering   and binding requirements on actionparameters that have been imposed as a result of the planning process 1 
　in contrast to strips-based action descriptors   a 
　collage action-tvpe description simply provides an action name and the types of its parameters for instance  
action-type 
　　 insert-socket 's.iocket  w wall *l loc  defines an insert-socket action type a specific instance of this type might be  insert-socket socketl wall1 loc1  
　rather than being denned in terms of state-based goals and preconditions  collage problem requirements are defined in terms of action-based constraints such constraints focus on desired forms of action instantiation  action relationships  and action-parameter binding requirements for example  consider the constraint 
   1a csp-network  on action-parameter-variable* is embedded in the plan and maintained as part of the planning process 
1 

 before 
 paint-wall  p paint  w wall  
    insert-socket  s socket  w wall  l loc   this requires that each insert-socket action be temporally preceded by a paint-wall action at the same wall  1 e a wall must be painted before sockets are finally in serted in a strips-based framework  this requirement would be stated in terms of a state-based precondition for lnsert-socket actions collage includes an extensive library of action-based constraint forms that can be utilized the advantages of action-based represen-
tation and its relationship to state-based representation are discussed at length elsewhere  1  1  
　each constraint c is associated with three types of mechanisms that it inherits from its constraint form a check method  a set of fix methods  and an activator  along with an initial activation setting  the role of a check for c is to test whether or not c is satisfied by a plan whenever a check is applied  it returns a list of bugs - descriptions of the ways in which c is violated the fix methods for c implement the various possible plan  repairs  that will satisfy these bugs for example  the check for our sample constraint would return all insert-socket actions that have no appropriate preced-
ing paint-wall action for each such action  the fixes would either find an existing paint-wall action for the same wall and make sure it precedes the insert-socket action  or alternatively  would create a new such action 
　the purpose of c's activator  and initial activation setting  is to indicate when c may be violated some constraints   l e   collage's analogue to  goals'  are initially active when planning begins others can be violated only by the addition of actions into the plan thus  c's activator is a set of action types if any instance of one of these types is added into the plan  c will be  triggered  or activated for consideration by the planner for instance  the constraint above is activated by the addition of insert-socket actions 
　in addition to describing action types and constraints  a collage problem description also specifies how these types and constraints should be partitioned into regions this partitioning may take on nearly any desired structure  the only restriction is that region-subregion relationships form a dag once specified  collage utilizes the regions and their constraints to drive planning search instead of backward- or for ward-chaining on goals and preconditions  as a traditional planner would  collage searches a localized constraint satisfaction search space  see figure 1  the planning space for each region r is focused on constructing a region plan fragment  planr  that contains actions of the types in r or any of r's descendant regions at the end of planning  plan r must satisfy all of r's constraints 
　search control for each region is governed by an agenda-based mechanism constraints may be activated by the addition of actions into the plan  placed on a constraint agenda  and later handled by the region search mechanism a region agenda is used to regulate control 
1 	planning 

flow between regions it keeps track of which regions have been activated for further planning  i e which regions have active constraints  agendas may also be associated with heunstics that determine the order in which activated constraints and regions are chosen 
　since regions may share subregions  and thus  region plans may share subregion plans   plan changes made by a fix in one region may activate constraints in other regions as a result  planning will typically flow back and forth between regions  necessitating careful consistency maintenance among the region planning spaces collage's consistency maintenance algorithms are described in  analytical and empirical results for localized search  1  1  have demonstrated that significant search-cost reduction can be obtained  and up to exponential savings in domains that require substantial backtracking however  because of the need for consistency maintenance  localized reasoning can be complex there is a tradeoff between focusing the application of constraints as narrowly as possible and the cost of keeping all of the region spaces consistent a good localization balances both factors 
1 	improving search costs 
nearly alt ai problem-solving systems conduct search with respect to some object of interest - be it a plan  schedule  or model typically  each search node is associated with a current value for the object and each arc is associated with an operation that transforms the object in some way for example  in a planning search space  each search space node is associated with a plan and each arc is associated with a plan construction operation that adds new actions  relations  or variable bindings into the plan given this kind of framework  planning search costs can be improved in at least three ways 

1 reducing ike coat of each arc operation one way to do this is to tune algorithms to problem requirements another way is to reduce the size of the plan being considered at each node 
1 using search heuristics good search heuristics can result in less backtracking and may also improve solution quality 
1 reducing the size of the implicit search space  typically by removing redundant or irrelevant nodes and arcs one way of doing this is to eliminate from con-
sideration those operations that are irrelevant to the plan at a particular node  or those that would otherwise be considered elsewhere in the search space  to the same effect 
localization may be viewed as a technique for tackling aspects of all three kinds of improvements by definition  localized search applies each planning operation  constraint fix  only to a region plan - the portion of the overall plan that the constraint is  relevant to   since the cost of plan-construction operations is often related to plan size  e g   the cost of temporal closure and csp binding-propagation   applying operations to smaller plan fragments can reduce planning cost in our experience with collage  this type of savings alone has yielded significant gains 
　one of the major contributions of abstraction is that it is a good search heuristic - indeed  one that guarantees monotonic consideration of domain requirements although localization does not  in general  provide such guarantees  it too serves as an excellent search heuristic one reason is that domain constraints are tackled on a region by region basis by default  collage ad dresses all activated constraints within a region before moving to another region's search space by design  the constraints within the same region tend to be the ones  most related  to one another  they constrain each other most tightly  thus  localization can lead to a constraint ordering that tends to resolve conflicts as rapidly as possible since localized search proceeds according to how constraints activate one another during planning  it also serves to focus planning on the most relevant constraints and plan fragments at each point in the search process 
　localization can also be viewed as a way of reducing the size of the otherwise global space  since only regional constraints are considered at each search node constraints associated with other regions are  less relevant   so removing them from consideration eliminates redundancy within the search space   other regions' constraints can be tackled later with  usually  no sub-
stantial effect on the form of the final plan 
1 	localization criteria 
until recently  collage users were required to describe how action types and constraints should be partitioned - i e localization was based on a user's intuition about problem structure we are now exploring how localizations can be generated automatically using loc  a localization generator developed for collage for the remainder of this paper  we will focus on two criteria we have examined abstraction and scope 
1 	abstraction-based localization 
knobloek's method for generating planning abstraction levels for strips-based frameworks is based on an analysis of problem goals and operator descriptors  a partially ordered graph of state literals is derived  wherein an arc from literal li to literal ul indicates that li must be at the same or higher level than ul the strongly connected components of this graph form the abstraction levels a total ordering of these components determines the order in which these levels are planned  each focused 
on achieving the literals comprising its level the significance of knobloek's technique lies in the fact that plan operators introduced to achieve literals at each level are guaranteed not to conflict with operators introduced at higher  preceding  levels 
　how can this method be adapted to collage's action-based planning framework  or to other types of problem solving   looking at the graph construction process in more detail  one notices that it is based on an activation relationship between literals l e how achiev-
ing a literal l  can activate or lead to achieving ul the result is a partitioning in which literals on a particular level cannot lead to   activate   planning for literals on preceding levels 
　knoblock's method can be adapted to collage by making the analogies in the table below in knobloek's framework  each plan-construction operation is focused on achieving a particular literal in collage  each operation is focused on satisfying a constraint just as achieving literal ii may lead to achieving literal l1  satisfying constraint c  may lead to satisfying c1 

　thus  to find an abstraction based localization for collage  one must focus on the activation relationships between constraints from the syntactic description of each collage constraint  we derive the types of actions it can add into a plan given the activators for each constraint  another set of action types   we then derive a constraint activation graph  where an arc from constraint c1 to constraint c1 indicates that c1 might activate c1 we then find the strongly connected compo1 

nents of this graph each of these components is used to form a planning region consisting of the constraints for that component using region-agenda heuristics  these regions are searched in an order consistent with the activation graph 
1 	scope-based localization 
another important criterion for localization is the scope or relevance of constraints to various portions of a plan determining the precise scope of an action-based constraint is simple the action-types relevant to a constraint can be syntactically derived from its description a problem's  most localized  or most finely-grained localization consists of a region for each action-type and a region for each constraint each constraint-region includes  as a subregion  each of the action-type-regions it refers to this forms a two-tiered localization structure  with action-type regions below a layer of constraintregions however  this structure usually manifests a great deal of overlap  since many constraints may refer to the same action-types 
　starting with this  most localized  partitioning  scope-based localizations can be created by merging and restructuring regions in a variety of ways for example  if constraints cl and c1 are relevant to exactly the same set of action types  the cl region should be merged with the c1 region alternatively  if c1's action types are a subset of cl's action types  the c1 region should be made a subregion of the cl region notice that these transformations do not enlarge c l ' s and c1's scope of application with respect to the emerging plan they merely optimize a localization by reducing the number of unnecessary regions and the need for consistency maintenance 
　as another example  consider the following  more heuristic  scenario suppose that cl is relevant to action types {a1 a1 a1 a1  a1} and c1 is relevant to {a1  a1  a1  ab  a1} the scope of these two constraints are similar  but not identical however  it might be worthwhile to merge the two constraint regions together  the scope of application of both cl and c1 would be slightly increased  but the amount of regional interaction would be reduced alternatively  suppose that c1 is relevant to {a1  a1  ab  a1  in this case  we might decide to make the c1 region a subregion of the cl region this would reduce region interaction and would increase the scope of cl  to include ag   but would not increase the scope of c1 
　often  scope-based and abstraction-based localizations are similar after all  if two constraints are relevant to the same action types  they usually bear some activation relationship to one another however  these two 
criteria are not identical for example  suppose that cl is relevant to { a l   a1.a1}  has activator set { a l   a1}  and can add actions of types {al  -a1} similarly  suppose that c1 is relevant to {a1.a1  a1}  has activator set {a1 a1}  and can add actions of types {a1 a1} clearly  the scope of these two constraints is different 
1 	planning 
yet since they can activate one another  via a1 and a1   they would be placed in the same region in an abstraction-based localization 
　how can scope be used in a strips-based framework1 using our analogy  constraint literal  action operator   we see that the scope of a literal is the set of operators relevant to it this set can be derived from the problem description for each predicate p  find those operators that  add    delete  or have a literal of type p u s precondition a strips-based planner localized according to scope would test the modal truth criterion for p only with respect to the plan operators that are  relevant  to p collage'b predecessor system  gemplan  1  1  localizes state-based reasoning in just this way 

to create an abstraction-based localization  we use the method described in section 1 to find the set of activation-based clusterings of constraints starting with the  most-localized  localization  loc applies a merge transform to each cluster of corresponding constraint regions  yielding a set of regions corresponding to the set of abstraction levels 
　generating interesting scope-based localizations is a bit more challenging we have identified eight distinct scope-based uses of the three basic transforms  four of which are described below 
  remove regions which serve no purpose if a child region rc has only one parent rp and either rc has no constraints  or rp has only one child  re  and no action types of its own  then subsume rp  rc  

  merge children regions with identical scoping fvnc tionahty if {r1 rn} have exactly exactly the 
same parent regions and have no constraints of their own  then merge {r1 rn}  
  merge parent regions with identical scoping func-tionality if {r1 rn  have exactly the same subregions and no action types of their own  then merge{{rl rn}  
  scoping hierarchy if the subregions of re form a subset of the subregions of rp and rc has no action types of its own  createhierarchy rp rc.  
the transforms above do not alter the scope of constraint application  they merely optimize a partitioning by removing unnecessary regions the other four transforms are heuristic versions of the tranforms above they have more relaxed application requirements and tend to remove excessive overlap at the expense of increasing constraint scope we are currently developing evaluation criteria for controlling their use 
1 	experimental results 
in order to compare the effects of our localization criteria on planning performance  we conducted a suite of experiments in an office-building construction domain that was also the subject of a study using sipe-1  we developed three localizations that make use of the abstraction-based and non-heunstic scope-based transforms described in section 1 the first  scoped  is the result of applying the scope-based transforms to the  most localized  localization  l the second  abstracted  is the result of applying the abstraction-based merges to l in this domain  its structure remains identical to l  except for one very large region  resulting from the need to merge several constraints that potentially activate one another finally  a third localization  abstracted-scoped  results from applying the scope-based transforms to abstracted this localization combines the two criteria of scope and abstraction within a single localization it contains the same large region as abstracted  but removes some unnecessary regions and regional overlap 
　each of these localizations was applied to the same suite of problems  for buildings ranging in size from one to ten floors with identical floor plans on each floor we also conducted tests with a hand-crafted localization  user-specified  and with a global localization  global abstracted the latter consists of a single region containing all action types and constraints  and utilizes a constraint-ordering heuristic to simulate the effect of imposing abstraction levels on the bearch process that is  the constraints are applied in an order that conforms with the constraint clumps used in abstracted  however  they are applied within a global search context rather than & localized search context 
　the graph below shows total run-time for all five test scenarios as well as for sipe-1 on the same domain one obvious conclusion is that scoped performs best the most important factor is that this localization manifests less unnecessary regional collapse than abstracted and abstracted-scoped in particular  due to potential constraint activation relationships  the abstraction-based localizations contain a very large region containing all actions involved in constructing the office-building frame since temporal closure is one of the expensive operations in this domain  closure over large region plans can be quite costly an important reason why scoped  and user-speeified  performs so well is that it generates fewer closure relations  though the skeletal temporal structure of the plans generated by all of the localizations was the same  since localized planning generates only locally derivable closure relations  localizations with smaller regions have cheaper closure costs 
　although scoped performs best  notice that globalabstructed outperforms both of the abstraction-based lo-
calizations  as well as sipe-1  in the long run although global abstracted performs completely global planning 
operations  whereas abstracted and abstracted are at least somewhat localized   in the end the latter two are unduly weighed down by the need to perform consistency maintenance thus  they poorly balance the increasedpartitioning vs consistency maintenance tradeoff 
　it is also interesting to note that our hand-crafted localization for this domain  user specified  is nearly identical to scoped indeed  scoped surpasses the performance of user specified these facts support the viability of loc as an automatic localization generator also of import is the performance of collage relative to that of sipe-1 although these results are admittedly for entirely different planners implemented on different hardware  it is clear that the slope of the collage curves  even global abstracted  increase much more slowly than that of the sipe-1 curve this result is the best proof we have to date of the relative efficiency and scalability of action-based  in contrast to strips-based  planning  even without the use of localization 

1 

1 	conclusions 
this paper described localization and localized search techniques for partitioning a planning problem into subproblems and searching a set of smaller  though possibly interacting  subproblem spaces since localized search can cope with complex  overlapping localization structures  it provides a powerful mechanism for coping with real-world planning problems and since it is a generally applicable technique  we believe localization has great potential for other types of problem-solving as well 
　a key focus of this paper was on the kinds of search cost improvements that localization can obtain in particular  we concentrated on two criteria for localization abstraction and scope abstract ion-based localizations are derived from constraint-activation information scope-based localizations are based on the relevance of constraints to specific pieces of the plan we described how loc  an automatic localization generator  can be used to generate localizations based on both criteria in empirical tests we showed that scope-based localizations attained the best results 
　future work with localization and loc will focus on feeding information about the planning process and the form of the final plan back into loc  enabling it to improve a localization by analyzing planning behavior for example  currently  loc applies transforms solely on the basis of the problem description - e g the potential scope  or activation  of constraints however  during planning  specific constraints may actually be applied to much narrower portions of the plan similarly  different applications of the same constraint may be focused on different portions of the plan  e g the same electrical constraint might be applied to activities on different floors  we would like to extend loc to include splitting transforms  thereby allowing constraints to be applied in narrower contexts one excellent candidate for focussing the splitting process will be the actual parameter bindings assigned to plan variables another motivation for utilizing feedback is to guide the application of heuristic scope-based transforms for example  if consistency maintenance costs are particularly high for certain regions  they would be good candidates for merging 
acknowledgments 
thanks to john allen  rich keller  rich levinson  barney pell and the members of the fia-spot reading group for useful comments and stimulating discussions 
