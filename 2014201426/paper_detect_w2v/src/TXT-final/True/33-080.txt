 
the advantages of a multi-strategy  construction-specific approach to parsing in applied natural language processing are explained through an examination of two pilot parsers we have constructed. our approach exploits domain semantics and prior knowledge of expected constructions  using multiple parsing strategies each optimized to recognize different construction types. it is shown that a multi strategy approach leads to robust  flexible  and efficient parsing of both grammatical and ungrammatical input in limited-domain  task oriented  natural language interfaces. we also describe plans to construct a single  practical  multi-strategy parsing system that combines the best aspects of the two simpler parsers already implemented into a more complex  embedded-constituent control structure. finally  we discuss some issues in data base access and update  and show that a construction-specific approach  coupled with a casestructured data base description  offers a promising approach to a unified  interactive data base query and update system.1 
1. introduction 
　providing robust natural language interfaces to interactive computer systems is a rapidly growing concern in natural language processing. much of the work in this area has focused on parsing problems that arise in applied natural language processing  and in particular  on mechanisms to exploit strong domain-dependent semantic constraints. past work in this area includes lifer   sophie  1  1   lunar   and planes . other investigators have concentrated on handling the performance errors that inevitably occur in spontaneously-used language  hayes and mouradian   weischedel and black   and kwasny and sondheimer  . ungrammatical input was also a major concern of colby in the parry system   and wilks 
  in parsing input with non standard semantic relations. all of these efforts  .however  have followed the paradigm of applying a uniform parsing procedure to a uniformly represented grammar  failing to exploit domain specific constructions and not always using the powerful domain semantics to best effect. although the parsing procedures were flexible enough to deal with certain forms of ungrammatical input  they were limited by having to use the same uniform techniques on all types of construction  and 
this research was sponsored jointly by the defense .advanced research 
projects agency  dod . arpa order no 1. monitored by the air force 
avionics laboratory under contract f1-c 1. and by the air force office of scientific research under contract. f1 c1 the views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies  either expressed or implied  of the 
defense advanced research projects agency  the air force office of scientific 
research  or the us government hence could not take advantage of specific features of individual construction types. moreover  a uniform-grammar approach requires that domain semantics be coerced and simplified to fit a predetermined mold  thus limiting the scope and utility of taskspecific knowledge in the parsing process. 
　our objective in this work is to produce task oriented  natural language interfaces that are robust  flexible  and efficient. therefore  we plan to develop  refine  and test a number of different mechanisms  each designed to perform its own particular task reliably and efficiently. we intend to exploit all possible tools at our disposal in creating a system capable of selecting the tool best suited for the job at hand. thus  we advocate a  tool-chest  of parsing and representational techniques for the parser to apply  rather than trying to design a single multi purpose tool. this objective differs from both cognitive modelling approaches  e.g.   and elegant linguistic solutions  e.g.   where integration  in the former  and uniformity  in the latter  are primary considerations. 
　we have argued elsewhere  1  at some length in favor of parsing strategies  grammar representations  and domain semantics that are construction-specific rather than uniform. in other words  we argued that for each type of construction in a language  there should be a specific formalism for representing constructions of that type  plus a specific procedure for applying instances of each type of construction to the parsers input. the parser would switch among the various parsing strategies dynamically depending on the input. examples of what we mean by construction type include case constructions  e.g. in imperative commands and the macro structure of noun phrases with postnominal modifiers   conjoined constructions. positional constructions such as simple noun phrases  and non standard constructions such as names  times  and addresses. 
　rather than reiterating our reasons for advocating a construction specific approach  we list below the main benefits claimed for such an approach  and refer the reader to  1  1  for full justifications. 
1   different constituents of a given construction can serve quite different functions and exhibit radically different ease of recognition. in a case construction  for instance  the case markers carry information about relations  whereas the case fillers describe the objects being related; also the case markers are typically drawn from a limited set of possibilities and are consequently much easier to recognize than the case fillers  which typically exhibit much more variety. construction specific parsing techniques are able to capitalize on these distinctions when ungrammatical input is present. for example  a failed parse of a case construction may be restarted by scanning the input for one of the easily recognized case markers  thus temporarily skipping the incomprehensible segment. 
  because complicated constructions  such as case constructions  can be represented and applied as a whole to the input  rather than being split up over a number of rules or network segments as in a uniform-'grammar approach to parsing  problems that arise with ungrammatical instances of case constructions can be dealt with by a strategy that can take into account any fragments of the construction that have already been parsed. thus  if certain cases have been recognized and instantiated  the troublesome segment in the input need only be matched with the uninstantiated cases. this enables the parser to apply much stronger semantic constraints and structural expectations  thus easing the burden on the syntax and case-selection processes  1 . 
  a construction-specific approach allows highly efficient parsing of grammatical input by providing an excellent framework for the application of the strong typing constraints characteristic of limited domains. 
  regardless of the structure being parsed into  structural ambiguities will sometimes arise from the input. a construction specific approach provides two powerful mechanisms to handle ambiguity: 1  strong semantic constraints from the application domain rule out most common ambiguities. 1  when ambiguities arise  often due to ellipsed or ungrammatical utterances   the construction specific approach facilitates an explicit and localized representation of ambiguity  without duplication of unambiguous parts of the input. this is a tremendous aid to an interface in presenting the user with a request for clarification. the request can be focused on the precise nature of the problem that the system experienced with the input  and the system is in a better position to understand elliptical responses from the user . 
  a construction-specific approach also helps in the definition and development of languages for limited domain interfaces. because the constructions dealt with are those that are 
 natural1 for the task domain  a language definition expressed in terms tied closely to the structure of the task domain can be interpreted directly by construction-specific strategies without the need for an intermediate  time consuming  compilation phase into a uniform-grammar formalism. this greatly speeds the testing of the many small changes that inevitably have to be made in the course of developing a language  and so makes the language designer's job significantly easier. 
   in this paper  we examine two small parsers we have constructed in order to illustrate some of these benefits  and to serve as stepping stones to the construction of a larger parsing system  which will integrate all the features we have mentioned. the first of these simple parsers shows the power of a construction specific approach in processing ungrammatical input; it is oriented around case constructions  and uses the distinctive characteristics of such constructions to deal with grammatical deviations in an extremely robust fashion. the second parser is a good illustration of the advantages of switching between parsing strategies dynamically; by combining only three very simple parsing strategies  it is able to deal with a surprisingly wide range of input. we go on to discuss combining the advantages of these two  essentially  toy   parsers into a single  useful multi-strategy parsing system. we also discuss further advantages of a construction-specific approach when it is used in an interface for accessing and updating data bases. 
1. the caspar parser 
　in this section we examine caspar  a small parser we constructed as an illustration of the power of a constructionspecific approach in dealing with ungrammatical input. it also turned out to provide a very efficient way of recognizing grammatical input in the class of domain specific languages for which it was designed. 
   caspar was designed to provide a natural language command interface to an interactive computer system. since an imperative is a natural way to issue system commands  caspar was designed to recognize simple imperative verb phrases  i.e. imperative verbs followed by a sequence of noun phrases possibly marked by prepositions. examples for an interface to a data base keeping track of registration for college courses include: 
cancel math 1 enroll jim campbell in english 1 transfer student 1 from physics 1 to comp sci 1 
the imperative verbs identify the system commands and the noun phrases provide their arguments. such constructions are classic examples of case constructions; the verb or command is the central concept  and the noun phrases or arguments are its cases. considered as surface cases  the command arguments are either marked by preposition  or unmarked and identified by position such as the position of direct object in the examples above. 
　in line with in the construction-specific approach we .are advocating  caspar was given two quite distinct parsing strategies: 
  a strategy to identify the appropriate case frame and activate its case markers and filler-patterns to deal with the rest of the input utterance. 
  a strategy to recognize individual constituent case filters and markers  including the verb  noun phrases in the role of case fillers  and prepositions in the role of case markers. 
the first of these strategies is dominant in the sense that it decides where in the input the second  more detailed  recognizer should be applied and what it should try to recognize when it is applied. the second strategy is a simple linear pattern matcher. this is just what is needed for verbs  prepositions  and simple object descriptions such as those in the examples above  but it is inadequate for more complicated kinds of object descriptions  and in particular  for object descriptions that are themselves case constructions as in: 
cancel the classes taught by solway on tuesday 
this deficiency is what relegates caspar to the realm of toy systems. however  see  for the design of a multi strategy parser that can deal with nested case constructions. 
   while caspar is just an experimental system  the flexibility and robustness obtained by providing separate parsing strategies for the two different construction types it recognizes  case and fixedorder linear patterns  is quite striking. the types of grammatical deviation that can be dealt with include: 
  unexpected and unrecognizable  to the system  interjections as in: tstqts1enroll student 1 in i think cs 1. 
  missing case markers: enroll jim campbell economics 1. 
  out of order cases: 
in economics 1 jim campbell enroll. 
1 　　the reason for including these particular extraneous characters wilt be easily guessed by users of certain computer systems 
  ambiguous cases: transfer jim campbell economics 1 english 1. 
combinations of these ungrammaticalities can also be dealt with. 
　caspar achieves this degree of robustness by exploiting certain specialized characteristics of case constructions; most importantly  it takes advantage of the differences between case markers and case fillers. case markers are typically drawn from a small set of words or phrases  and are thus much easier to recognize  or spelling correct  than case fillers  which have much more variety. this ease of recognition of case markers makes it practical for caspar to scan the entire input for them  and thus to locate and parse the corresponding case fillers; interjections and out of order cases are dealt with in this way. caspar also keeps track of which cases have been filled  and thus cuts down on the number of filler types that it has to try when a segment of input must be parsed without the guidance of case markers  for instance  if some case markers have been omitted. neither of these heuristics are available to the more uniform parsing procedures of weischedel and black  1 . or kwasny and sondheimer  1    or of our own flexp parser   simply because there is no convenient way for these parsers to represent or make use of the information that case markers are much easier to recognize than case fillers or that most cases can be filled only once. exactly how these heuristics operate  along with other details of how caspar is tailored to case constructions  can be seen from the following description of caspars parsing algorithm. 
　caspar has two parsing strategies: a case-oriented strategy and a linear pattern matching strategy. the case oriented strategy controls the operation of the pattern matching strategy  which in turn actually recognizes words from the input. the linear pattern matcher may be operated in anchored mode  where it tries to match one of a number of linear patterns starting at a fixed word in the input  or in scanning mode  where it tries to match the patterns it is given at successive points in the input string until one of the patterns matches  or it reaches the end of the string. the case-oriented parsing strategy operates in the following way. 
1. starting from the left of the input string  apply the linear pattern matcher in scanning mode using all the patterns which correspond to commands. if this succeeds  the command corresponding to the pattern that matched becomes the current command  and the remainder of the input string is parsed relative to its domain specific case frame. if it fails  caspar cannot parse the input. 
1. if the current command has an unmarked direct object case  apply the linear matcher in anchored mode at the next1 word using the set of patterns appropriate to the type of object that should fill the case. if this succeeds  record the filler thus obtained as the filler for the case. 
1. starting from the next word  apply the pattern matcher in scanning mode using the patterns corresponding to the surface markers of all the marked cases that have not yet been filled. if this fails  terminate. 
1. if the last step succeeds  caspar selects a marked case the one from which the successful pattern came. apply the matcher in anchored mode at the next word using the set of patterns appropriate to the type of object that should fill the 
   1 the word after the last one the pattern matcher matched the leat time it was applied. 
case selected. if this succeeds record the filler thus obtained as the filler for the case. 
1. go to step 1. 
unless the input turns out to be completely unparsable  this algorithm will produce a command and a  possibly incomplete  set of arguments it is also insensitive to spurious input immediately preceding a case marker. however  it is not able to deal with any of the other ungrammaticalities mentioned above. dealing with them involves going back over any parts of the input that have been skipped by using the pattern matcher in scanning mode. if  after the above algorithm has terminated  there are any such skipped substrings  and there are also arguments to the command that have not been filled  the pattern matcher is applied in scanning mode to each of the skipped substrings using the patterns corresponding to the filler types of the unfilled arguments. this will pick up any arguments which were misplaced  or had garbled or missing case markers. if one of the arguments matched in this way could fill more than one slot  a special representation is used for caspar's output indicating the ambiguity without duplicating unambiguous parts of the parse this representation  which has advantages in formulating requests to the user to resolve the ambiguity  is described in more detail in . 
　the grammar description that caspar uses is tied very closely to the structure of the domain. for each possible command to the underlying system  the grammar definition contains a list of the linear patterns which can be used to refer to that command  plus a list of arguments to the command. for each argument the definition gives the type of domain object that should fill that argument  plus the linear patterns used as surface case markers to signal the argument  or an indication that the argument is an unmarked case such as the direct object . the grammar definition also gives the linear patterns needed to recognize each type of domain object. see section 1 below for an example of a grammar definition in a similar style  and for a discussion of how a construction-specific approach to parsing fits well with a grammar definition that is tied closely to domain structure. this point is also discussed in . this form of grammar definition fits naturally into a description of the underlying interactive system as a whole. such a description can be used to control other aspects of a cooperative and graceful user interface   see  for more details of other work we have done in that area. 
　while simplistic in many ways  caspar shows the power of a construction-specific approach to parsing  both in the range of grammatical deviations it can handle  and in the efficiency it displays in straightforward parsing of grammatical input. this efficiency is derived from the limited number of patterns that the pattern matcher has to deal with at any one time on its first application  the matcher only deals with command patterns; on subsequent applications  it alternates between the patterns for the markers of the unfilled cases of the current command  and the patterns for a specific object type. also  except in postprocessing of skipped input  only case marker and command patterns are employed when the pattern matcher is in its less efficient scanning mode. the more difficult to recognize object descriptions are processed in the more efficient anchored mode. this efficiency is sound evidence that such a constructionspecific approach is a good way to bring the powerful semantic restrictions available in limited domains to bear on the parsing of both grammatical and ungrammatical input. 

1. the dypar parser 
　as a related investigation of the practical feasibility of dynamic strategy selection by a domain oriented parser  we also developed the dypar1 system. dypar has a kernel control module to select the appropriate parsing strategy as a function of the expected input structure  plus three parsing strategies to select among  each with its own grammatical and/or semantic knowledge encodings  and global data structures to share information. the control structure  strategies  and linguistic knowledge representations are augmented with domain specific semantic knowledge bases. thus  the same kernel parser may be applied to different domains if a detailed  domain specific  semantic knowledge base is provided. 
　whereas the central focus of caspar was to exploit domain semantics and construction specific case frames for processing some types of malformed input  dypar was built to explore issues of user interaction and multi strategy synthesis in the context of a working parser. more explicitly  our objectives for developing dypar were threefold: 
  test the feasibility of a multi-strategy approach. 
  investigate a simple data base task requiring interaction and feedback between the system and the user. 
  eventually integrate the best features of caspar and dypar into a robust  construction specific  multi strategy parser. 
　in encoding domain semantics  we found that some information can be expressed more naturally and parsimoniously in one form  e.g.  linear patterns   while other information is best expressed in other forms  eg  equivalence transformations or semantic grammar productions . to illustrate this point  we attempted to encode all the knowledge in dypar as a pure semantic grammar. this task has more than tripled the size of the task-specific knowledge base  and we have not yet finished  nor do we intend to finish  the conversion. the primary reason for the increase in size is that much of the information must be stated with a high degree of redundancy and often in an awkward  roundabout manner when it is coerced into a uniform  context-free representation. therefore  the primary lesson one can draw from the dypar effort is that multi-strategy parsing is tractable in practice and moreover can perform the work of single strategy approaches with much greater economy of programmer effort.1 
1. parsing strategies in dypar 
dypar combines three parsing strategies: 
  a context-free semantic grammar component  grouping domain information into hierarchical semantic categories useful in classifying individual words and phrases in the input language  similar to the lifer semantic grammar mechanism . 
  a partial pattern match component  represented as pattern action rules. the patterns may contain individual words  semantic categories  from the semantic grammar   wild 
　　dynamic parsing is still in its infant stages  requiring frequent changes in its software 
cards  optional constituents  register assignment and register reference. this method enables the semantic grammar nonterminal categories to be applied in a much more effective context-sensitive manner than in a pure context-free grammar recognizer. 
  equivalence transformations map domain dependent and domain-independent constructs into canonical form  requiring a fraction of the patterns and semantic categories that would otherwise be needed. if a phrase-structure can be expressed in several different ways  while retaining the same meaning  it is clearly beneficial to first map it into canonical form  rather than being forced to include all possible variants in every context where that constituent could occur. 
　below we give an example of each type of linguistic information used in dypar. in order to understand these examples  a few notational conventions must be introduced:  brackets  denote a non-terminal semantic grammar symbol. a word starting with an exclamation mark  e.g.. {register  denotes the name of register. a vertical bar  |  denotes disjunction in a pattern. a # in a pattern matches a single word. an asterisk     matches an arbitrary sequence of words. the construction  jregister pattern  assigns whatever matches the pattern to the register specified. a question mark     before a constituent in a pattern indicates that constituent is optional. 
　dypar  as we see in the dialogue below  is the front end of a semantic network data base update and query system. therefore  its domain knowledge consists of language constructs relevant to this task.'first  consider a fragment of its semantic grammar: 
 info-req  -    what-q  |  inf1-req1   
 inf1-req1  -     polite   inf1-req1  
1 what-q   
 inf1-req1  -   tell  me-us   about | 
give  me-us  | print | type  
this fragment  together with the rewrite rules for the other nonterminals above  e.g.   bepres   whose rewrite is alt the presenttense conjugations of the verb  to be   recognizes the initial segment of information request queries such as:  what is ...    tell me what is ...    tell me about...    would you give me ..   etc. 
now  consider a pattern-match rule: 
   det   ival #   be-pre$    det   iprop  #  of   det   inam #    dpunct   
＊  
 ltm-store inam ival iprop  
this rule recognizes sentences such as:  felix is a friend of fido   or  reagan is president of the usa   and passes the information 
to the data base manager for consistency checking and storage. in order to pass the information gathered in the pattern match process  the registers are assigned appropriate values. for instance  in the second example  inam is assigned  usa   iprop is assigned  president  and ival is assigned  reagan . 
the equivalence transformations also use the pattern matcher. 
for instance  consider the following simple  but useful  transformation: 
    i s l     iw1  nominal    poss   !w1  nominal    !s1      ip  punct    
::  
 nconc isl 1  list 'of  iw1 is1 tp  
this transformation maps possessive constructions into attributevalue constructions  which we chose as canonical. for instance  tell me about the vax-1's performance.  is mapped into  tell strategies. however  these parsers are only first steps in exploiting the multi-strategy approach to develop real-world  robust  natural language interfaces. in terms of sophistication. dypar straddles the boundary between an advanced toy and a rudimentary realapplications system. one direction of continued development would be to enhance its pattern matcher  build additional general transformations  and augment its language interface to serve as a medium in which to express extensions to the grammar by a 
domain expert  not necessarily a natural language expert . a first step in the direction of automating and simplifying user extensibility has been taken in the nano klaus system . 
　our research is focused in a direction different from  but complementary to  the one taken in nano klaus. since the performance obtained by integrating several parsing strategies has  for both caspar and dypar  proven more effective than the application of any single strategy  we intend to extrapolate by including additional parsing strategies in future parsers. as a step along this road  we have designed a flexible control structure  that integrates case instantiation with other parsing strategies discussed in this paper  together with additional constructionspecific strategies. as in caspar  the case oriented strategy is the dominant one. we expect this new design to provide a quantum jump in the range of applicability of our task-oriented parsers. moreover  techniques such as expectation-driven disambiguation  1 . developed in non-applied natural language work  can now be brought to bear in real-world applications. the reason why case frame parsers have not been developed in taskoriented domains is that  while they capture general principles admirably and can bring detailed semantic knowledge to bear  they are not well suited to recognizing specific idioms  compound nouns and the like. however  the addition of partial pattern matching  ideally suited to detecting idiomatic expressions  integrated with case frame instantiation and other parsing methods should provide a high degree of generality without sacrificing robustness. 
　graceful interaction with the user is an important goal for any natural language front end whose users may be unfamiliar with computers  more details on our broader efforts towards this goal are given in  1  . people invariably produce ungrammatical utterances  leave out words  add interjections  and use terms outside the vocabulary of any system. it is essential that a realworld system  fail soft  in such circumstances  and interact with the user to enable graceful recovery. we saw a simple examples of this in dypar  and more mechanisms are discussed in  1j. the expectation setting provided by a case system incorporating domain knowledge may prove a more powerful tool to minimize failure than mechanisms based on relaxing grammatical rules or pattern matching requirements. 
　consider  for instance  a file management system where a user may type 
transfer the flies in my directory to the accounts directory. 
it is fairly clear to us humans that the user meant to type  files   even if we know perfectly well that  flies  is a legitimate word in our vocabulary.1 a case frame system knows that the object case of the transfer command  as applied to the file-management domain  requires a logical data entity  which  flies  is not. observing this violated semantic requirement  it can proceed to see whether by spelling correction  morphological decomposition  

or detecting potential omissions it can map  flies  into a known filler of that case. here  spelling correction works  given a very restricted pool of candidate words satisfying the semantic requirements   and the system can proceed to inform the user of its correction  allowing the user to override if need be . 
　a striking advantage of our mixed-strategy approach is that the top-level case structure  in essence  partitions the semantic world into categories that can legitimately fill specific cases. the power of the approach derives from these top-down case-frame expectations significantly constraining bottom-up pattern matching. thus  when a pattern matcher is invoked to parse the recipient case of a file transfer frame  it need only consider patterns  and semantic grammar constructs  that correspond to logical locations inside a computer. this form of expectationdriven parsing in restricted domains has two important advantages from the point of view of robustness: 
  many spurious parses are never generated  because patterns yielding potentially spurious matches are never tried in inappropriate contexts.  
  additional knowledge  additional patterns  grammar rules  etc. can be added without a corresponding linear increase in parse time  since the case-frames focus only upon the relevant subset of patterns and rules . thus  the efficiency of the system may actually increase with the addition of more domain knowledge  in effect enabling the case frames to restrict context even further . this behavior makes it possible to build the parser incrementally without the ever-present fear that a new extension may make the entire parser fail due to unexpected application of that extension in the wrong context. 
　we conclude this section by reiterating the central theme of our investigations: integration of multiple construction specific parsing strategies is a powerful organizing principle for robust  task-oriented natural language interfaces. 
1. advantages for data base interfaces 
　a further advantage of multiple construction-specific parsing techniques and grammar representations arises in the case of interfaces for accessing and updating data bases. most current data base interfaces that use natural language are concerned purely with data base access rather than update  though see kaplan  for some discussion of the problems involved in the latter activity. the typical approach of such interfaces has been to translate a users natural language questions about the contents of a data base into a formal query language which is then interpreted by a program specific to the particular data base to produce the required answer. the answer is then expressed to the user in some more or less natural format. the translation into the formal query language can be done directly from the input  as is the case in ladder  1   or indirectly via a syntax tree of the input as in lunar . 
　while this arrangement is fine for pure data base access  it is less than optimal if a mixture of access and update is desired. the problem is that the structure of the query languages employed does not mirror the structure of the data base being queried. this means that an access request and an update request of essentially similar form will result in radically different parses. in turn  this means that constituents which are identical at the language level must be parsed in radically different ways depending on whether they are in an access or an update request. 
　to make this point concrete  consider the following two requests that might be presented to an interface to a data base concerning college courses: 
who is the instructor of physics 1  
change the instructor of physics 1 to be solway. 
translating the first input into a typical1 formal query language might look something like: 
 for  x in courses  
 and  =  dept x  economics   =  number x  1   
 list  instruc x    
a corresponding translation for the update request1 on the other hand might be: 
 for  x in courses  
 and     oept x  economics   =  number x  1   
 change-instruc x solway   
while the representation of  economics 1  is the same in both cases  the treatment of  instructor  is quite different. in the access example  it is encoded into the access function  instruc  and in the update example  it turns into the update function  change-instruc. the reason for such radically different treatment is a desire to make the ouery language independent of the structure of the data. for example the relations between courses and their departments  numbers  and instructors could be contained in one file  or in three separate files. by making no assumption about the structure of the data  and just using neutral functions like instruc and chang instruc which assume that there is a relation between course and instructor  but nothing about the way it is represented  the query language avoids dependencies of this sort. 
　however  adopting a query language of this type has unfortunate consequences for a parser that must recognize both access and update requests. clearly  it would be desirable for such a parser to use the same grammar rules to recognize  the instructor of economics 1  in both examples above  but the target representation makes this quite inconvenient. because  instructor  has to be translated in two quite different ways  it is most natural to control the parsing of the phrase from a higher level  so there would probably be rules1 that recognized complete phrases like: 
 tell-me   instructor  of  course  
 change   instructor  of  course  to  person  
　　these examples are actually patterned after  though not identical to  the language employed by woods in the lunar system  1 . which is one of the more easily human readable of the query languages that have been used most db query languages adopt a similar  if mote cryptic  formalism for instance. cooasyl  queries are stated in a imeaiized form whose content resembles that of our example above kaplan  1 . however  first translates queries into a intermediate formalism  satisfying some but not all the features of the representation we propose in the following pages  before generating the cryptic cooasyl query form 
1 
　　we do not consider here  non obvious  interpretations for update requests like those discussed by kaplan  
g 
　　the exact form of the grammar representation  network or pattern  is unimpoitant here  just the idea that phrases of this type would be recognized as a whole 
and turned them into internal representations like the ones above. in order to be able to recognize patterns like   instructor  of  course   or better still   slot  of  structure   without regard to whether they were part of an access or update request  one would have to represent output from the parser something like: 
 requesttype: access slotspec:  slot: instructor structure: 
 type: course oept: physics number; 1 
 requssttype: update slotspec:  slot: instructor structure: 
 type: course oept: physics number: 1  
updatevalue: solway 
here the representation of  the instructor of economics 1  is the same for both the access and update requests. 
　this form of representation has the advantages we have described for parsing. a potential objection  however  is that the representation presumes too much about the structure of the data base. we do not believe that this objection is valid because the assumptions made are only about the logical structure of the data base from the user's point of view  rather than its detailed organization into files  etc any relational data base would certainly fit into the slot and filler  property list  style of representation we have used  and other forms of logical organization could also be accommodated. in addition  the work in ladder  shows how an abstract intermediate representation is very useful when several data bases of different detailed structure are involved  and the above style of representation should serve splendidly for that purpose. 
　so far  nothing we have said in this section makes the construction-specific approach to parsing preferable to the uniform approach  with respect to data base interactions. there would be nothing to stop a uniform parser producing the kind of representation we are advocating for update and access requests just as well as a construction-specific one could. the primary advantage of construction-specific parsing here involves describing the relation between the logical structure of the data base and the input language. as we noted in the introduction  since the specific constructions dealt with can be those  natural  for the task domain  when using a construction-specific approach  the input language can be defined in a way that is tied closely to the slot and filler structure of the objects of the data base. to be more precise  the input syntax for the description of a given kind of data base object can be expressed in terms of the fillers for slots of that object type embedded in whatever kind of construction is natural for describing such an object. as an example of the kind of language definition we have in mind  consider the following three complementary syntax definitions for descriptions of a course. 
 syntaxtype: nounwithcases 
head:  course section class  postcases:  instructor: 
 by  taught by   given by   
department:   held in   number:  numbered  
 syntaxtype: possessivecases namedcases: 
 instructor: 
    instructor teacher  faculty member   department:  department  
	 syntaxtype: 	slotpattern 
pattern:  department number  
without going into great detail  the first syntax definition above says that a construction type of nounwithcases may be used to describe a course. this means that it may be described by a head noun  a list of alternatives is given   optionally preceded by a determiner  part of the construction definition   followed by a sequence of descriptive cases. these cases are defined as a property list indicated by postcases. the indicators  instructor  department  etc  are slot names of the object type  and the values are a list of possible case markers for that case  both single words and linear patterns of words . for instance   taught by  can signal the presence of an instructor description. the fact that instructor is a slot of course  and the syntax for fillers of that slot are recorded elsewhere. the second syntax definition gives a listing of the slots of course  and the words used to describe them. from this information  a phrase like  the instructor of  course   can be parsed. finally  an alternative syntax for course of   department   number   is given. we have already developed a similar kind of language definition formalism for command interface applications  we intend to extend this work to interfaces that access and update data bases. for instance  the noun-phrase head and the case markers can be represented by more complex patterns that may include nonterminals from a semantic grammar    similar to the mechanism used  in a less discriminating fashion  in the dypar system. 
1. conclusion 
　the goal of this paper has been to explain the advantages of a multi strategy  construction-specific approach to parsing in applied natural language processing  largely through an examination of two  toy  parsers that we have constructed. the construction-specific multi strategy approach exploits prior knowledge of expected constructions  domain semantics  and strategies optimized to recognize each construction type. the two parsers demonstrated clear advantages for the constructionspecific approach in parsing both grammatical and ungrammatical input. we intend to construct a single  practical  multi strategy parsing system that combines the best aspects of both simpler systems in a more complex  embedded constituent control structure. finally  we discussed some issues in data base access and update  and showed that a construction-specific approach  coupled with a case-structured data base description  offers a promising approach to a unified  interactive data base query and update system. 

