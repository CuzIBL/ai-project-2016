 
one view of expert system development separates the endeavor into two parts. first  a domain expert  with the aid of a knowledge engineer  articulates a procedure for performing the desired task in some external form. next  the knowledge engineer operationalizes the external description within some computer language. this paper examines the nature of the processes that operationalize natural task descriptions. we exhibit a language based on a computational model of problem spaces for which these processes are quite simple. we describe the processes in detail  and discuss which aspects of our computational model determine the simplicity of these processes.1 
1. introduction 
viewed abstractly and somewhat simplistically  figure 1  top   one fundamental paradigm of expert system development starts with a domain expert who articulates the means of performing the task in some language t. a knowledge engineer then comprehends the task knowledge expressed in t  resulting in a conceptualization of the knowledge in terms of the task domain td. next  the knowledge engineer maps the task knowledge from the terms of td to the terms of some computational domain cm  called a computational model . finally  the knowledge engineer composes a set of statements that express the computational conceptualization of the task in a computer language l. together  the comprehension  domain mapping  and composition are referred to as operationalization of the task knowledge. this description does not imply that all task knowledge is articulated before operationalization begins. in practice  these phases are 
this research was sponsored by the defense advanced 
research projects agency  dod   arpa order no. 1 under contract f1-c-1  and monitored by the air force avionics laboratory. the research was also supported in part by digital equipment corporation. the views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies  either expressed or implied  of the defense advanced research projects agency  digital equipment corporation  or the u.s. government. highly interleaved and incremental. the processes described apply to individual knowledge fragments  not to the body of task knowledge as a whole. 
   t must be a language that both the domain expert and the knowledge engineer are familiar with  and that permits clear and concise description of the task knowledge. thus  t is usually a natural language. in the remainder of this paper we assume that t is english. operationalization remains a task for humans  rather than computers  because natural language comprehension is routine for humans but is much too difficult to perform automatically. further  operationalization remains a task for knowledge engineers  rather than domain experts  because the latter rarely are skilled in the use of computer languages. thus  this paper assumes a human knowledge engineer and an appropriate level of language skills in t and in l  it also assumes that the description of task knowledge in t does not pose its own difficulties by being a confusing or obscure text . the remainder of this paper focuses on the third component of operationalization: the conceptual mapping from the task domain to the computation domain. 
   by separating the notion of a language from the domains it describes  we see that improving the state of the art in expert system development is not simply an issue of making language improvements. we may modify a language so that it describes its domains more perspicuously  but the fundamental conceptual mismatch between the task domain and the computation domain remains. this conceptual mismatch accounts for most of the difficulty of operationalization. if the processes that perform the mapping are complex and open ended  then operationalization will be a difficult intellectually-creative task. if these processes are simple and routine  then design of expert systems will be routine. different computational models could require quite different processes  and thus could present quite different degrees of difficulty. 
this paper illustrates this thesis by describing pscm 
{problem space computational model   a computational model with a small set of clearly-describable operationalization processes  figure 1  bottom . pscm is a computational model of problem spaces based on the soar architecture  laird  newell & rosenbloom  1  
laird  1 . taql {task acquisition language  is the language  l  that is based on pscm; it has a compiler that 
	yost and newell 	1 

converts systems described in taql into soar  hence into running expert systems. only three types of processes are required to operationalize an english task knowledge description into taql: identification  representation and communication  each of limited character and complexity  given adequate language skills in english and in taql . 
   section 1 describes pscm. section 1 describes the operationalization processes. section 1 describes taql and gives a brief example of operationalization. section 1 discusses the role of the computational model in determining the operationalization processes. 
1. the computational model 
a computational model is a set of entities  some of which perform operations on other domain entities. thus a computational model has two kinds of domain entities: structural entities  and functional entities. structural entities are the basic objects in the domain. functional entities perform operations on structural entities. some entities may be both structural and functional. for example  in the computational model underlying lisp  certain lists may be treated as either programs or data. 
   pscm is a computational model of problem spaces abstracted from the soar problem solving architecture. in pscm  as in soar  all tasks are represented as finding a desired state in a problem space. 
　table 1 lists the entities that comprise pscm. the first row of the table lists the structural entities: tasks  problem spaces  states  and operators. tasks are particular problems to be solved. problem spaces are organizing structures that group related knowledge. states consist of the data objects relevant to the task. operators manipulate states with their associated data objects. the rest of the table lists the functional pscm entities. they are grouped by the structural entity with which they are most closely associated. in the rest of this paper  these structural and functional entities are collectively referred to as pscm components. 
   each pscm component has a set of aspects that must be defined for the component to be meaningful. for example  an operator proposal component has three such aspects: which problem space the component belongs to; the 
1 	machine learning 
conditions under which the operator should be proposed; and the operator object to be proposed  expressed in terms of objects in the current problem-solving context. 
　a task is represented as a collection of interacting problem spaces  each of which performs some portion of the task. problem spaces interact in a variety of ways. for example  one problem space may implement an operator invoked in another problem space. during problem solving  problem spaces are situated within a goal hierarchy. whenever a new goal is created  problem solving proceeds in that goal as follows: 

　subgoals are generated whenever problem solving in the current problem space cannot proceed until another problem space has performed some subtask on its behalf. for example  when the available operator selection components do not uniquely determine which operator should be applied next  pscm creates a subgoal to choose one of the candidate operators. 
　problem solving in pscm proceeds in general without knowledge of a global control structure for the task. rather  pscm assembles a solution dynamically through the application of a sequence of localized problem-solving components. some sets of pscm components may lead pscm to exhibit the behavior produced by a well-known problem solving method. other sets of components may exhibit no easily-characterizable global behavior. however  pscm admits problem-solving methods that influence the overall behavior of an entire set of components. such method-based behavior is easily produced  but is not required. 
　while pscm and soar are both computational models of problem spaces  pscm describes tasks at a higher level of abstraction than soar. soar expresses problem space computations in terms of concepts such as productions  

working memory  preferences  and impasses. pscm abstracts away from these architectural mechanisms and describes problem spaces in their own terms.1 
1. the operationalization processes 
the processes that operationalize english descriptions of domain knowledge into a given computational model are determined by the computational model. as displayed in the lower half of figure 1  the operationalization of english task knowledge into taql is produced by a knowledge engineer who comprehends the knowledge description  maps the comprehended task concepts to components of pscm  and composes a set of taql language statements expressing those pscm components. for pscm  the mapping between domain and computational model performs three functions: identify a pscm component; represent a data object; and communicate some information from one pscm component to another. 
　in general  while the operationalization processes themselves are determined by the computational model  their instantiation and application to a given knowledge description is strongly determined by the forms of expression used in that description. for pscm  we can make an even stronger statement: for descriptions of realworld tasks expressed naturally and in their own terms  the operationalization processes yield a set of pscm components that directly model the forms of expression used in the description. in other words  to a large extent  the processes involve not design and creative reformulation  but comprehension and re-expression of english knowledge descriptions in the terms of pscm. 
this is particularly true for the identification and representation processes. the remainder of this paper explicates this claim. 
　to begin  we describe the three processes in more detail.1 let e denote an english description of the task knowledge for a particular task. the first function to be performed is to identify pscm components in e. all types of pscm components are identified at this stage  including organizational components such as problem spaces; dataobject components that make up the problem solving state; 
   soar also provides a learning mechanism  chunking . pscm does not. 
and problem-solving methods  which determine the behavior of an entire set of pscm components. the identification proceeds by labeling paragraphs  sentences  or phrases in e with the pscm components that will encode the knowledge in those parts of e. in essence  it involves segmentation of the text in e. 
　the labels are assigned based on comprehension of the functional roles of parts of e. for example  a description of how to perform some subtask would be labeled with the name of an operator to perform that subtask  and would be classified as an operator-implementation component. components created for related subtasks are grouped into problem spaces. a method is identified when e describes behaviors that match the behaviors known to be produced by the method. a structure that is the target of some action described in e is identified as a data object  part of a state . the identification of a data object may be further refined by classifying it as an instance of an abstract data type: such an identification is made when e describes manipulations of the identified data object that match the computational operations defined on the abstract data type. 
　after identification  the next function to be performed in the operationalization of e is to represent data objects. the identification process yields a conceptualization of the task knowledge in terms of abstract problem spaces. at this stage  most of the procedural structure of the final pscm solution has been determined. tasks have been assigned to operators  related subtasks have been grouped into problem spaces  and the relationships among problem spaces have been determined at an abstract level. the interactions among operators within a space are also known at an abstract level. however  the interactions among problem spaces and operators cannot be completely determined until data representations have been selected. immediately after identification has completed  objects are still in terms of the task domain  except for the occasional appearance of abstract data type terms. 
　data representatioas require raw materials out of which they can be constructed. the choice of raw materials depends to some extent on what is appropriate for the computational model. for example  representations built from machine-level units such as bytes  e.g.  records and arrays  have proved appropriate for the computational models underlying conventional programming languages such as c and pascal. for pscm  the representations are in terms of attribute/value structures  which have 
	yost and newell 	1 

historically proved useful in computational models for expert systems  e.g.  ops1  forgy  1   and are used in soar. 
　the representations of data objects described in e are developed in the same way as the pscm components were assembled. that is  the attribute/value structures are not so much designed as they are identified from the structure of their descriptions in e. thus  if e mentions a backplane with nine slots  it might be represented as an object of class backplane with a slots attribute whose value is 1. these structures can be hierarchical. for example  if e mentions individual backplane slots and their widths  the backplane object may be given a slot attribute  the value of which is an object of class slot having a width attribute. in the cases where the abstract data type of an object has been identified  representation is even easier: it is assumed that the knowledge engineer is skilled in the expression of common abstract data types in the terms of pscm; thus  creativity is not required. 
   once the representation process has been completed  the operationalization of e in pscm is almost finished. most of the interactions among pscm components are known by the time the identification process completes  and the components need only be restated in terms of the chosen attribute/value representations to become operational in pscm. however  since the components were identified at an abstract level  before data representations were known   some of these components may now need to be modified or refined. 
　this fine-tuning of interactions is the province of the communicate process. communication comes in two forms: inter-space communication  and inter-operator communication. both forms of communication are driven by the need to make available the information operators must have to apply correctly and in the proper order. 
   the abstract problem space descriptions classify the connections among problem spaces. for example  they may state that the problem space in a subgoal implements a specific operator in the superspace. however  they do not indicate in any detail what information in the current goal needs to be made available in the subgoal  or what information produced by the subgoal needs to be returned to the supergoal when the subgoal exits. the communicate process fills in the details of this inter-space communication. 
   data objects are copied to a subgoal to make them readily available to the problem space operating in the subgoal  or to any of its subspaces. this is particularly important for data objects that are modified by operators in the subspace. data objects are copied from a subgoal to the superspace either to make a result available to operators in the superspace  or to preserve the value of a data object for a future invocation of the same problem space or one of its subspaces. 
　inter-operator communication must be refined in two situations: 
1. when an operator needs data in a form other 
than the form created by the operator that produces the data* 
1. when an operator needs data that was available at some point during prior computation  but that would not otherwise be preserved in the current state. 
　the first situation can be resolved by either modifying the operators involved so that they represent the data in the same way  or by introducing a new operator or elaboration component that translates between the two forms. the second situation can be resolved by modifying operators that had access to the required information in the past so that they make this information part of their result states  thus preserving it for future use. 
1. the taql specification 
the operationalization processes described in section 1 map task knowledge from the terms of the task domain into the terms of pscm. the final requirement in the operationalization is to express these computational model structures in a formal  compilable language: namely  taql. 1 the stages of the complete operationalization process are displayed graphically in the left-hand column of figure 1  we will describe the rest of that figure below . 
taql directly reflects the structure of pscm. thus  a 
taql specification consists of a set of taql constructs  called tcs  each of which describes some aspect of a 
pscm component. a common lisp program compiles 
tcs into soar productions. when loaded into soar along with a small set of runtime support productions  these productions implement the task described by the tcs. this compilation is fully automated and very efficient: it does not take noticeably longer to load a file of tcs than it does to load the productions generated by those tcs. 
   each tc is a list consisting of the tc type and a name for the tc instance  followed by a list of keyword arguments. each keyword specifies some aspect of the related pscm component. an operator-proposal tc appears at the bottom of figure 1. in terms of pscm  the aspects that must be defined for an operator-proposal component are the problem space it applies in  the operator object to be proposed  and the conditions under which the operator should be proposed. these aspects are specified directly in the propose-operator tc as the values of the :space  :op  and .when keywords  respectively. data is represented in taql using attribute/value structures of the form produced by the representation process during operationalizati on. 
　we now provide a detailed example of the operationalization of a small piece of english task 
     1see the taql user manual  yost  1  for a more detailed description of taql than is given here. 
1 	machine learning      1the current version of taql makes no attempt at graceful syntactic forms  as the emphasis so far has been on the operationalization processes. 
description. the domain is computer configuration  as performed by the r 1 /xcon expert system  mcdermott  1 . rl was coded in ops1. several years ago  the unibus-configuration subtask of rl was recoded in soar 
 rosenbloom  laird  mcdermott  newell & orciuch  1 . rl-soar is an expert system of about 1 rules. since its creation  it has served as a testbed for a number of efforts within the soar project. 
　we have produced an english description of the unibus configuration task  and have realized this task in taql by applying the operationalization processes to that description. figure 1 illustrates how the operationalization processes apply to a small piece of the description. the two english sentences at the top of the figure express when specific instances of an action  backplane cabling  should be performed. this is exactly the kind of information a pscm operator-proposal component expresses. thus  the identification process yields two operator-proposal components  one for each of the two cable lengths. only the component for cables of length ten is shown in detail in the figure. next  the representation process applies to the conditions in the abstract component  and also to the operator object that is to be proposed. a straightforward mapping from the english description of the abstract component yields the attribute/value representations shown.1 
　the condition that determines whether or not the backplane has been filled with modules is naturally expressed as a test for the presence of a 
 modules-configured attribute on the state. however  the operationalization of the modules-into-backplane operator  which fills the backplane1  does not generate this information. thus  the communication process must build a link between the modules-into-backplane and cable-bp operators. it does so by modifying modules-intobackplane to return the required modules-configured attribute  in addition to any other actions the operator already performs. 
　before leaving this example  we say a few words about how r1-taql compares to r 1-soar. for the comparisons given here  we use an updated version of rl-soar that reflects the task-oriented conceptual structure of unibus configuration more closely than the original rl-soar did.1 
   both ri-taql and rl-soar use the same seven problem spaces. r 1-taql has 1 tcs  and ri -soar has 1 hand-coded soar productions. the 1 tcs compile into 1 soar productions. a more useful measure of size is the number of words in each description  where a word is defined to be the smallest unit that has meaning to the taql compiler or to the soar production compiler. 
1
   part of the representation of the configuration structure is determined by other parts of the rl english task description  not shown   and is simply reused here. 
   this operator is described in a part of the rl description not shown here. 
1
this was the joint work of amy unruh and gregg yost. 
words include attribute names  variables  and parentheses  among other things. the english description of rl has 1 words; r 1-taql has 1 words  and rl-soar has 
1 words. thus the number of words in rl-taql is 1% of the number of words in rl-soar  a significant reduction. 
1. the role of the computational model 
we have described pscm and taql  a computational model and associated language that require only simple processes of operationalization. existing practice takes the creation of expert systems to be a difficult task  although the development of knowledge acquisition tools and expert system shells has simplified the task for some classes of systems at the expense of generality in the tool  clancey  1  mcdermott  1 . much of this difficulty resides in operationalization  although articulation of domain knowledge  which is outside the scope of this paper  clearly contributes as well. 
　the desirable course would be to describe the operationalization processes for existing expert system specification languages  and compare them with the processes for taql. however  this course is not presently feasible  because the operationalization processes for other languages cannot yet be specified. all that is known is the overall complexity of the language in practice. for example  common lisp  a standard  highly effective  general purpose system-building language  still requires substantial effort when used to build medium-sized expert systems. but to give the operationalization processes for coding expert systems in common lisp would be to describe how to do program synthesis of very substantial and complex programs - well beyond current understanding. that operationalization processes can be described when they are simple  as they are for taql  does not imply that they can be described when they are more complex. 
   however  some things can be said. for most specification systems  the basic computational model is some variant of procedural semantics: data types with associated sets of operations  on top of which is provided a set of procedural control constructs  built out of the notions of execution  sequence  and conditionally. production systems  object-oriented programming  conventional programming  and a number of other schemes are all variations on this theme. all such specification systems require specifying such things as programs  methods  strategies  reasoning schemes  executives  etc. for simple applications  this may be easy  but as the complexity of the application grows this becomes a genuine program design task. the operationalization processes for using these languages must include some way to synthesize the required methods  executive organizations and so forth. let us call this operationalization process method-design. 
method-design is not required for operationalizing into 
taql. this is surely a major factor in the simplicity of its operationalization processes. some of the reasons for this are presented in section 1: the mutually supporting problem space structure of pscm provides the 
	yost and newell 	1 
organization into which local control knowledge can be placed without having to design any methods or higherlevel organizations. in this respect  pscm differs from rime  bachant  1   a programming methodology based on problem spaces and in some ways similar to pscm. in rime  each problem space is required to specify a single method that will determine the course of problem solving in that space. in pscm  as in soar   method-based behavior is an emergent phenomena of localized problem-solving decisions. 
　of course  methods can be quite useful. once coded  they can be reused in similar tasks by simply modifying a few bits of domain knowledge. methods determine the behavior of an entire set of problem solving components  and they can provide very concise specifications in appropriate situations. however  if the desired task behavior does not very closely match the method's behavior  it can be quite difficult to force the task to fit the method. the key point here is that pscm provides the 
1 	machine learning 
flexibility to either use methods or not  depending on which is most appropriate in a given situation. taql does provide a set of methods  which can be used when appropriate. however  only one situation occurs in rltaql where the use of a method  limited depth-first search  is more appropriate than a customized set of components. an important result of our work is that the nature of the pscm operationalization processes facilitates the selection of appropriate sets of these customized components. 
1. conclusions 
this paper has exhibited a computational model and associated formal language for which the processes of operationalizing naturally-expressed expert system task knowledge are quite simple  in particular avoiding methoddesign while having a quite general scope. our explicit focus on the processes that transform from the task domain to the computation domain is a departure from much of the expert system specification literature. many efforts are 
involved with the invention of new formal languages and the description of the processes  sometimes quite complex  by which those languages are reduced to some previouslyknown operational computing system  for example  gist  london & feather  1  and kee  filman  1  . while such work is both interesting and useful  it is often left to the reader's intuition to see why it might be easier to use the new language rather than some existing language. our study of the processes that construct taql specifications from an informal english description of task knowledge is an attempt to articulate these intuitions for a particular computational model  pscm . 
   our future work will proceed along two paths. first  we plan to build a tool that helps a knowledge engineer carry out the pscm operationalization processes. the knowledge engineer will bring natural english descriptions of task knowledge to the tool. the tool will help select and apply appropriate iastances of the identification  representation  and communication processes  ultimately producing a taql implementation of the task. we will evaluate the effectiveness of our tool with respect to existing tools over a wide range of tasks. 
　we do not believe it will be possible in the near future to fully automate operationalization in a general-purpose expert system development tool  and we will not attempt this. the language skills required are well beyond the state of the art. many research effort resolve this problem by limiting the generality of the tool. we take a different approach. our tool will leave the language skills with a human knowledge engineer  who can perform them routinely. we focus instead on the aspect of operationalization people find most difficult: mapping knowledge from task domain terms to computational terms. the pscm operationalization processes that have been the focus of this paper seem sufficiently limited that a computer can provide strong guidance in their application. 
　the second path we intend to explore is more theoretical. now that we have some understanding of the operationalization processes for taql  we want to discover what aspects of the underlying computational model determine the simplicity of these processes. as discussed in section 1  that pscm does not require method-design is one such aspect. however  there are surely others we have not yet identified. we also want to explore whether the processes we have identified apply to tasks substantially larger than the unibus configuration task  and  if not  we want to explore what higher levels of organization might be required for large tasks. 
acknowledgments 
we wish to thank amy unruh  for rewriting much of rlsoar to correspond to our english description of the task; 
erik altmann  thad polk  and milind tambe  three taql users who have provided much valuable feedback; paul rosenbloom  for his comments on earlier drafts of this paper; and john mcdermott for helping us understand the rl task  for his insights into the nature of the expert systems development  and for his continued assistance. 
