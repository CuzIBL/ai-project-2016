 
fold-unfold is a well known program transformation technique. its major drawback is that folding requires an eureka step to invent new procedures. 
in the context of logic programming  we present a technique where the folding is driven by an example. the transformation is aimed at programs suffering from inefficiencies due to the repetition of identical subcomputations. the execution of an example is analysed to locate repeated subcomputations. then the structure of the example is used to control a fold-unfoldtransformation of the program. the transformation can be automated. the method can be regarded as an extension of explanation based learning. 
1 	introduction. 
in  clocksin 1   a technique is presented for translating clausal specifications of numerical methods into efficient programs. the horn clause program started from does not compute the result but constructs a term which  after evaluation  yields the result  e.g.  1 + 1  + 1 represents the second fibonacci number . executing the program for a specific input  n  yields a specific term. clocksin analyses this term to find common subterms and folds the term into a graph structure where each subterm occurs only once. this graph structure can be considered as a program for a hypothetical dataflow computer. fixing the input is unpractical for fibonacci  but less harmful for more complex cases  e.g. the number of terms in an approximation of a series  the dimension of a matrix equation  the number of points in an n-point discrete fourier transform . 
　　the regularity of the resulting graph structures is striking. for a human  it is easy to extend them to a larger n  and it is not so hard to come up with a recursive procedure where n is a parameter computing the same value with the same efficiency. the purpose of this paper is to describe a method  suited for automation  deriving such recursive procedures. 
　　some general techniques are known to address the inefficiencies due to repeated subcomputations e.g. lemma generation  kowalski 1  and tabulation techniques  bird 1 . such techniques give some improvement but do not yield the optimal algorithmic behavior looked for. the fold-unfold transformation technique  burstall & 
darlington 1  could be used  but the fold step requires a eureka step  the invention of new procedures. 
　　in the area of machine learning  explanation based learning  mitchel et al. 1   de jong & mooney 1  has been developed to improve the problem solving behaviour of programs. the similarity between explanation based learning and partial evaluation has been pointed out  van harmelen & bundy 1 . however  the point of explanation based learning is that the example is used to control the partial evaluation process. 
　　our method extends this idea  an example will be used to control the fold-unfold transformation process. we argue that the method is suited for automation. also extensions to cases where subcomputations in the original program are not identical but similar seem to be feasible. 
　　in the next section we give some examples; the third section discusses the automation of the method and we finish with a discussion of possible extensions and of related work. 
1 examples. 
our first example is about the well known and simple problem of computing fibonacci numbers. the program:. 

　　executing a query  e.g. fib  1 f1  yields a proof tree with common subgoals  the relevant part is shown in fig.l. a subtree for the goal fib  1  appears twice. an efficient computation should avoid this repetition. this can be achieved by adding 1  the third fibonacci number as extra output argument to the subgoal fib 1 . this can be realised by a fold-unfold program transformation. by unfolding fib 1  we obtain both occurrences of fib 1  in the same goal statement and we can use factoring to eliminate the undesired one. 







1 discussion. 
 clocksin 1  shows a technique to derive an efficient dataflow graph from clausal programs exhibiting redundancy by recomputing identical subgoals several times. the graph is derived for a constant value of one of the inputs. in this paper  we go substantially further  we have shown a technique to obtain an efficient clausal program for the above class of programs. moreover  the program can be executed for any value of the input which is frozen by clocksin. the idea underlying the method is to use an example to control an unfold-factoring-fold transformation of the program. 
　　the method as presented requires that subcomputations are identical in the example computation. we are currently investigating whether this condition can be relaxed. a simple example is the towers of hanoi problem. in an example computation one gets subgoals of the form hanoi  1  peg a  peg c  peg b   ...moves   and hanoi  1  peg c  peg b  peg a   ... moves    where proofs are structurally identical  only the names of pegs are different. the least general generalisation hanoi  1 x y z  ...   still yields the same proof structure  so one can execute that call  take two copies of its successfull instance and unify the first copy with the first call  the second copy with the second call. 
	our 	explanation 	based 	program 	transformation 
 ebpt  borrows ideas from explanation based learning  ebl   mitchell et al. 1   de jong & mooney 1   kedan-cabelli & mc carthy 1  as it is also a form of example guided unfolding. the relationship between partial evaluation and ebl has been studied in  van harmelen & bundy 1 . our ebpt not only applies example guided unfolding but realises also example guided folding and can introduce new predicates. consequently  it can modify the structure of the prooftree. also  shavlik & de jong 1 a b  have developed a method which restructures the prooftree in case of repeated application of the same rule. 
　　it is interesting to observe that restructuring the prooftree is essential to obtain truly operational predicates for the examples we have shown. 
　　we have also borrowed ideas from the area of program transformation. an interesting aspect is the problem of maintaining completeness. traditional ebl systems derive new rules and add them to the knowledge base but never remove old rules. for certain queries  the new rules may allow to quickly find a first solution  but the amount of redundancy and the total size of the search space increases. techniques from the area of program transformation allow to prove the equivalence between sets of rules. in ebl this could be used to remove old rules with a bad performance. 
　　the problem we address has also been studied in the area of program transformation. the unfold/fold transformation method of darlington and burstall  burstall & darlington 1  has served as a general framework for almost every source-level transformation technique proposed for logic- or functional programs. the major advantage of the method is its wide range of applications. these include the introduction of tail-recursion  e.g.  debray 1    pelhat 1    loopmerging  e.g.  gregory 1    debray 1    proietti & pettorossi 1    avoiding redundant computations  e.g.  gregory 1 ..  fronhofer 1    partial evaluation  e.g.  komorowski 1    venken 1   and the compilation of control information  e.g.  gregory 1    bruynooghe et al. 1    de schreye & bruynooghe 1  . closely related to this advantage  is the major drawback of unfold/fold : the method is hard to automate. in general  the degree of automation obtained in any of the applications above is inversely proportional to the size of the class of unfold/fold transformations it can deal with. 
　　systems designed to support a large class of transformations  either depend on: 
  user interaction  e.g.  gregory 1    
  a user-provided control program  e.g.  sato 1    
  a set of heuristics and global transformation strate-gies  e.g.  proietti & pettorossi 1   
mainly to guide the unfolding  to provide lemma's that can be applied and to generate the new predicates and their definitions  eureka's  on which the folding can be performed. as such  the techniques described in these three papers can deal with the transformations described in this paper as well  but only under the assumption that the user has supplied the proper directives  control program or heuristics. in contrast with the above  the technique proposed here focuses on a more specific class of transformations. in exchange  we obtain full automation. 
　　 fronhofer 1  has also studied the problem of eliminating the inefficiencies due to the occurrence of similar subcomputations. the prooftree of an example computation is scanned bottom up for identical subcomputations. at points where the subcomputations start to diverge  an attempt is made to generalise the two observed subcomputations. this generalisation requires an eureka ; possible automation is not discussed. 
a classic approach to avoid redundancy due to identical subcomputations is the use of tabulation  see  bird 1  for a survey  or lemma generation  kowalski 1 . the idea is to build a table with answers computed so far. when a new call in encountered  the table is consulted and the stored answer is used when already present. however  it is more a programming technique than a method for program transformation. also  in logic programming  building the table requires the use of assert which is very time consuming. 
acknowledgements. 
m.bruynooghe is supported by the belgian national 
fund for scientific research. d.de schreye is supported by the belgian iwonl-irsia under contract no. 1. 
