 
     planning for real-time applications involves decisions not only about what actions to take in what states to progress toward achieving goals  the traditional decision problem faced by ai planning systems   but also about how to realize those actions within hard real-time deadlines given the inherent limitations of an execution platform. determining how to arrange actions in a sequence such that timely execution is guaranteed within constraints is a manifestation of the scheduling problem. all cases of the scheduling problem in any domain of nontrivial complexity are difficult to solve  np-hard . to more efficiently solve the real-time plan scheduling problem  we propose and analyze an iterative feedback/constraint relaxation method in which a scheduler and planner iteratively interact to efficiently develop a well-utilized schedule which includes as many planned actions as possible. this method has been successfully implemented within the cooperative intelligent real-time control architecture  circa . 
1 	introduction 
generating plans for the control of a real-time system is an extension of the traditional ai planning problem. actions must be determined to guide the system from one state to the next  eventually reaching the goal state  as in standard planning. however  unlike traditional planning  these actions are time and resource dependent: they must be executed subject to the limitations of a particular execution platform within hard real-time deadlines to assure that the system is successful in achieving its goals. plans need to fit the abilities of the execution system. 
   from the real-time perspective  this  fit  means that the demands of plan execution be schedulable on the system. 
scheduling is an np-hard problem  requiring that the scheduler have knowledge about what the system being scheduled can and cannot do. meanwhile  the planning process  which is also np-hard  attempts to generate demands on the system that will accomplish goals. a modular  agent-oriented approach to the overall problem is to couple separate planning and scheduling components  where each applies its own expertise and together they allow the system to achieve its goals reliably within its inherently bounded range of capabilities. 
   decoupling planning from scheduling cannot be complete  however. viewed as a configuration task  stefik  1   it is not the case that the selection of the component pieces of the plan can be done independently of trying to arrange them within the constraints of the execution system. more generally  the problem requires iteration between developing alternative plans and evaluating the schedulability of those plans  until an executable plan that maximally accomplishes goals is found. the obvious question  then  is what knowledge should be passed between these component agents during this iteration to guide the search into promising areas. 
¡¡¡¡in this paper  we detail the development of scheduler feedback mechanisms intended to support the iterative formation of real-time guaranteed control plans. unlike prior work in this field  garvey et al  1  we propose a cooperative protocol in which a scheduler makes state-space search modification suggestions to the planner as opposed to presenting multiple schedules for acceptance based on various criteria. iterative scheduler/planner feedback as described in this paper is generally applicable to any system which can be mapped to a planner/scheduler agent-oriented model. we have implemented and tested our feedback mechanisms in the context of a particular system  the cooperative intelligent real-time control architecture 
 circa   musliner et al.  1   applied to automated aircraft control in flight simulation  atkins et al  1   a domain which demands strict real-time response. 

'this research was supported under nsf grant iri-1. 
	mcvey  et al. 	1 

1 	iterative real-time planning/scheduling 
the process of planning can be thought of in three distinct stages: projecting combinations of modeled features forward in time to find reachable states  selecting actions to manipulate this set of reachable states  and determining constraints on those actions  such as timing requirements  necessary to ensure desired changes to reach a goal state or avoid failure states. real-time execution  on the other hand  deals with determining the current state of the system  finding an action for the system to take  if any   and executing the action within timing constraints. 
   determination of the reachable system state set involves expanding a combinatoric search space  however  and is infeasible for a real-time system to detect and react to each state. instead  since there are typically far fewer actions than states  each expanded state can be classified by the particular action which should be taken in that state. the real-time system may then execute a single task for each action rather than a task for each state. 
   since these actions are typically time dependent  meaning that execution must be completed before a certain deadline to guarantee system transition into the new desired state  tasks must be explicitly allocated resources on the execution platform. in most real world domains  the set of tasks often requires more resources than are available  forcing the system to either fail or consider trade-offs. 
   the process of making trade-offs must be done carefully to cause sufficient pruning of tasks to make scheduling feasible while avoiding over-extensive pruning  which causes under-utilized schedules and sub-optimal goal achievement. to minimize the risk of over or under pruning the task space  the knowledge of both the scheduler and planner must be brought to bear. we propose a method of iterative negotiation in which the planner first generates its  best  plan in terms of accomplishing goals. the scheduler then schedules the plan if possible  otherwise informing the planner that a new plan must be tried. the process repeats as necessary until a successful schedule is constructed. 
   an iterative scheduler feedback protocol must specify what information will be contained within request and feedback messages. this depends on the division of knowledge maintained between the planner and scheduler. the planner is an expert at determining which tasks must be performed subject to which constraints to solve the global problem at hand  while the scheduler is an expert at manipulating the tasks into a specific order such that constraints are not violated. ideally  one would like the scheduler to know only how to manipulate tasks into a sequence which does not violate constraints  while a planner knows about the global problem at hand and the tasks required to solve the problem  but not the details of how to organize the tasks into a schedule. for scheduler feedback 
1 	planning and scheduling 
to work effectively  however  the two must share some knowledge. how much knowledge should be shared and how to represent this shared knowledge is not clear. it is undesirable and impractical for the planner to share everything it knows about the global problem with the scheduler  garvey et al.  1   and vice versa. 
   the major question which remains  however  is the exact nature of the feedback provided by the scheduler such that the planner's search is guided rather than relying on extensive blind generate and test cycles. if the planner were allowed to consider schedulability constraints during the process of planning  the question of feedback would be of no concern since only schedulable plans would be generated. however  all advantages of modularity would be lost  and the solution obtained would likely be sub-optimal due to the impracticality of conducting the exhaustive search required to find a well-utilized schedule during planning. 
   alternatively  the planner could allow the scheduler to automatically explore variations of the task request  returning the best possible schedules for pre-defined criteria  garvey et al.y 1 . however  dropping  adding  or changing the timing of a task could change the whole topology of the reachability graph  creating the need for increasing and/or decreasing the importance of many other tasks. this would be acceptable if the planner identifies and indicates tasks that are nearly independent and preferable. 
   finally  the scheduler could provide feedback to the planner which actually guides the search of the planner. this feedback would suggest how much less  or more  should be demanded in the task request list. since it has knowledge of excess available resources or particular conflicts which cause infeasibility of scheduling  the scheduler is in a good position to base such a suggestion upon this information. this final approach has been taken in our implementation within circa. 
1 circa background 
circa's realization of real-time ai emphasizes allowing the planning algorithms to be intelligent about real-time rather than forcing them to be intelligent in real-time  musliner  1 . circa's approach is achieved by separating the architecture into three distinct modules  figure 1 : the planner  scheduler  and the real-time subsystem  rts . the planner includes a domain-specific knowledge base and a planner which generates 'test-action pairs  or  taps  analogous to the tasks discussed above. 
these taps are constructed based on transitions  goals  and actions modeled in the knowledge base. 
   the planner begins with a known  set of  initial state s  and searches a discrete  feature  value  paired state space via modeled transitions in a best-first  descending probability  manner. as the search progresses  each state is assigned a probability calculated from the probabilities of its ancestors 

figure 1: the circa system. 
and transitions leading to the state  atkins et al.  1 . a cut-off threshold probability is used to limit state expansion. actions are chosen by the planner to preempt any temporal transitions to failure  and hard real-time 
 required  taps are developed for these actions.  if-time  taps are also constructed to pursue non-critical goals specified in the knowledge base. these taps do not require real-time constraints since they need not be guaranteed to preempt transitions to failure. 
   once the planner builds a complete list of required and if-time taps  the scheduler attempts to form a packed  no idle time  periodic schedule in which each required tap is executed at least fast enough to meet its deadline. a successful schedule  which guarantees failure avoidance to the level of the probability cutoff threshold  is then transferred to the rts  where it is executed until a new schedule is available. if scheduling is unsuccessful  an iterative process of feedback and re-planning is begun until a successful schedule is developed. 
1 the test action pair  tap  
a tap is implemented as a class within the scheduler with the following fields: test  action  worst-case-execution-time  separation-constraint  and utilization. the test and action slots contain strings which specify execution functions. the execution of a tap involves first evaluating the test  which if satisfied  causes the paired action to be executed as well. the worst-case-execution-time  wcet  is the time that both the test and action together require to complete in the worst case. circa builds plans and schedules based on worst case execution times to make real-time guarantees. 
   a separation constraint  similar to a period in periodic scheduling literature  liu and layland  1  but subtly different  is calculated for each tap which is to guarantee failure avoidance. critical transitions to failure are modeled to occur with a minimum delay time of d seconds  therefore it is only necessary that a tap designed to preempt the failure execute at least once every d seconds  not precisely every d seconds  periodic   musliner  1 . 
   the utilization of a tap measures the minimum fraction of cpu time the tap requires. it is defined as the ratio of its worst case execution time to its maximum separation constraint. the scheduler uses this information to determine if scheduling is certainly infeasible before attempting any scheduling  or to determine appropriate feedback in the event that scheduling is unsuccessful. 
1 the if-time server 
using techniques from  musliner et a/.  1   we have implemented the scheduling of an if-time tap server to use slack resources available in a schedule. when executed  this server executes if-time taps in a prioritized fashion.1 the use of the server is preferrable to individually inserting iftime taps into the schedule because the scheduler would require explicit domain-specific knowledge about the priorities of the less critical if-time tasks. instead  when the schedule is executed on the rts  free time gained when actions require less then their worst case execution times is distributed among if-time taps using whatever scheduling policy the if-time server employs. the wcet of the server accounts for this tap selection time plus the largest wcet of any if-time tap  thus the server is a guaranteed task. 
¡¡¡¡since the server does not preempt a transition to failure  it does not have an a-priori separation constraint. to insert it into the schedule as tightly as possible  a binary-like search is conducted through the server's possible utilization space. the utilization of the server can range from zero through one minus the total utilization of the required taps. the initial utilization for the first search iteration is simply set to the average of these upper and lower bounds. as an additional mechanism to aid rapid convergence  the search itself is not quite binary: a factor equal to one minus the utilization of the required taps is used to partition the search intervals  whereas a binary search would use a factor of 1. in testing with 1 random scheduling requests  this heuristically aided binary search converges faster than or as fast as binary search in 1% and 1% of the cases respectively. 
1 	feedback scheduler design 
1 the base scheduler 
schedules are built based on a separation constrained method of scheduling described in  musliner  1 . the scheduler simulates the execution of a dynamic scheduler by maintaining a time counter and iteratively incrementing it as taps are chosen for execution. at each iteration  the tap with the shortest slack time is initially chosen to be executed. the slack time is defined as the difference between the taps separation constraint and the current time minus the time when the tap was last chosen for 
     1 currently  priority is given to the least-recently executed if-time tap  yielding a round-robin strategy. 
	mcvey  et al. 	1 
execution: 

if any other tap  tap  can execute within the slack time of the originally chosen tap: 

it will be selected for placement in the schedule instead. if the slack time of any tap is less than zero at any point  the tap's deadline is violated and scheduling fails. 
   after all taps are present in the schedule  the scheduler continues its simulation until a valid periodic subsequence containing all taps can be extracted as the final schedule. 
1 the schedule manager 
a scheduler capable of providing meaningful feedback must have authority to manipulate and retry scheduling the requests it receives from the planner. given this capability  the scheduler can use the difference between a satisfiable request and over-constrained request to provide more accurate feedback to the planner. 
   we have augmented the original circa scheduler with a new rule-based system known as the schedule manager  or  manager   which directs the processing of all planner scheduling requests. depending upon the request  the manager may perform a variety of actions: schedule a request  modify some constraints in a request  modify parameters which govern behavior of the core scheduling algorithm  calculate appropriate feedback  and transmit a valid schedule or feedback. 
   after each scheduling attempt on a request  the manager invokes rules which determine what should be done next based on the result code s  returned from the attempt  any error conditions  instructions received from the planner  and scheduling strategies in the rules. the result codes are: 
  schedule-with-server 
the original scheduling request from the planner with the if-time server was successfully scheduled. 
  schedule-too-lax 
the schedule found is under-utilized. 
  sched-no-server 
the required taps specified by the planner were successfully scheduled  but the if-time server could not be scheduled. 
  partial-sched-with-server 
some of the required taps specified by the planner were successfully scheduled  along with the server. 
  partial-sched-no-server 
this result is the same as the previous one  except no if-time server could be inserted into the schedule. 
  no-schedule 
the planner's original scheduling request could not be scheduled  and no relaxations were allowed. 
  no-partial-schedule 
the scheduler could not satisfy either the planner's original request  or any subsequent legal relaxed request. 
   failure to generate a schedule which meets the original request from the planner will generate an error condition which indicates the specific constraint violation that occurred  along with tap s  which caused the violation. the manager then returns either a suggested probability threshold or relaxes constraints and tries scheduling again. 
   a new probability threshold recommendation is made based on a heuristic-guided binary search  similar to that described earlier for if-time server scheduling  between the minimum  maximum  and current threshold used by the planner. it is calculated using the priorities and utilizations of recently attempted schedules. when the planner adopts an increased probability threshold  the state search space is pruned  causing the separation constraints of the taps to be increased and/or the removal of some taps from the scheduling request. either of these effects trades off some degree of system completeness for reductions in the difficulty of constructing a feasible schedule. a decrease in the threshold has the opposite effect  causing more states to be expanded  smaller tap separation constraints  and possibly more taps in a scheduling request  increasing system response capabilities and scheduling difficulty. 
   if the rule invoked by the manager instead suggests relaxing the constraints on the current scheduling request and trying again  one of the two methods discussed below will be employed. 
trading off the wcet of the if-time server 
initially the execution time of the if-time server is defined as the maximum of the if-time tap execution times. 
while this guarantees that if the server is scheduled  each iftime tap will have a chance to execute  it is an extremely restrictive choice  forcing the scheduler to either allow all possible if-time taps  when the schedule was successful  or none  when the schedule was not successful . 
if a conflict occurs between the server and a required 
tap  the manager can reduce the execution time of the server to the greatest if-time tap wcet value possible which removes the conflict. chances are still good that time will be available to execute any if-time taps precluded from the server since schedules are built using worst case execution times. 
priority scheduling 
another way of incrementally relaxing the request from the planner is to selectively remove required taps from the 

1 	planning and scheduling 

request a schedule request with the tap combination of the next highest total priority is attempted. differences 

between the original request and a successful partial schedule are used by the scheduler to provide more accurate feedback to the planner. the manager does not require further instruction from the planner during this process. 
   the priority of a tap is originally set by the planner to be proportional to the average of the probabilities of the world states from which that tap might be executed. these priorities serve as an approximate representation of the planner's search space  isolating the full complexities of the domain from the scheduler. 
1 scheduler/planner messages 
the planner transmits scheduling requests consisting of tap data and instructions for making scheduling trade-offs to the scheduler. the planner can currently select among two different primary instructions to the scheduler: 
  schedule-these-taps 
this instruction is followed by parameters which govern the scheduling process and scheduling data about the taps. data for each tap may include worst case execution time  separation constraint  and priority. 
  schd-prev-taps-new-param 
this instruction is followed by the new scheduling trade-off directives only. 
the parameters which the planner may specify include: 
  if-time-server 
this parameter allows the planner to specify whether insertion of an if-time server into the schedule to be built is required  desired but not imperative  or not useful. this gives the planner the capability of trading off the need for an if-time server if resources and/or deliberation time are constrained. the planner will usually require its insertion  unless  quick  replanning is required to respond to some emergency  atkins  1 . 
  trade-off-server-exec-time 
this boolean indicates whether scheduler trading-off of the server worst case execution time is permitted. 
  levels-of-priority-scheduling 
this parameter specifies how many different priority levels the scheduler may analyze before aborting. 
   the planner also sends the scheduler three probabilities: the maximum and minimum probabilities of the set of expanded states and the current threshold probability. note that the current threshold probability is always less than or equal to the minimum expanded state probability. these probabilities are used during the manager's binary search  as discussed in section 1. 
   the scheduler will return either a new suggested probability threshold or a successful schedule. a new threshold message can occur either when the scheduler is over or under constrained: the new value being either greater than or less than the previous threshold  respectively. 
1 	testing scheduler feedback 
extensions were introduced into the previous simulated flight domain knowledge base  atkins et a/.  1  to model more potential dangers  forcing the planning and scheduling of more preemptive taps. the addition to the knowledge base consisted of modeling the possibility of colliding with other air traffic at any point in the flight. traffic was modeled in the system through the use of three actions  ac : a void-traffic  course-correct  and resume-heading. these actions are designed to preempt temporal transitions to failure  ttf  and rely on temporal transitions  tt  to function correctly together  figure 1 . 

figure 1. 	circa traffic avoidance world model. 
   this complex chain of events requires the planner to request scheduling of three additional taps. one of the planner-scheduler iteration cycles generated during the operation of circa is presented for analysis. the original scheduling request sent from the planner to scheduler is shown below. 

	mcvey  et al; 	1 

if-time server separation constraint bound to 1 after the binary search. a rule within the manager specifies that if a partial schedule is successfully made  the manager should calculate a new threshold probability suggestion for the planner and return it as feedback. in this case  the algorithms for calculating the new threshold generated the value of 1  which was returned to the planner. 
   the planner  using the new threshold  replanned and submitted a new request to the scheduler which was similar to the original request but with slight timing relaxations and without the previously troublesome tap 1. this request was satisfied by the scheduler  and the successful schedule was returned. 
   by comparison  before the feedback mechanism was added  a scheduling failure caused the planner to blindly increment its probability threshold by 1 and replan. this resulted in a successful but under-utilized schedule. there was no method for detecting under-utilization and subsequently decreasing the threshold  thus this non-optimal schedule was accepted and the system performed below its capabilities  potentially failing to react in time to a fatal situation which had been needlessly pruned during planning. 
1 future research 
an open question which needs to be addressed is the handling of under-utilized schedules. tests of the current implementation have shown that in some cases the suggested probability threshold is too high. when this occurs  too many taps may be excluded from subsequent requests. to prevent this  the scheduler  or planner  must be able to ascertain when a valid schedule is under-utilized. 
   in the future  the planner should be provided with the capability to reason about what it should do given scheduler feedback. this reasoning will likely be domain dependent  and could be specified in the form of production rules which indicate user or designer preferences. alternatively  the reasoning may borrow from decision theory  computing the expected utility for different courses of action and choosing the strategy which yields the most benefit. currently the planner blindly adopts whatever probability threshold suggestion or schedule the scheduler sends back  which is not an ideal policy given the scheduler's roughs indirect knowledge of states and their probabilities. 
1 	conclusions 
we have addressed the difficult problem of interfacing an ai planning system to a real-time scheduler by proposing  developing  and implementing an iterative feedback mechanism. this mechanism allows a large degree of decoupling between the scheduler and planner  enabling the two modules to each perform within its realm of expertise  communicating with mutually meaningful information in a controlled protocol to solve a global problem. 
1 	planning and scheduling 
   further refinement of the circa-specific methods for calculating probability threshold feedback and detecting under-utilized schedules is needed. however  our scheduler feedback method gives the system an increased chance of efficiently meeting goals under resource constraints by providing quantitative knowledge to the planner  eliminating the need for blind search. this represents a crucial step towards the realization of a fully self-reliant real-time ai architecture capable of solving difficult real world control problems such as completely automated flight. 
