 
1 
　we propose a model of problem solving that provides both structure and focus to search. the model achieves this by combining constraint satisfaction with heuristic search. we introduce the concepts of topology and texture to characterize problem structure and areas to focus attention respectively. the resulting model reduces search complexity and provides a more principled explanation of the nature and power of heuristics in problem solving. we demonstrate the model of constrained heuristic search in two domains: spatial planning and factory scheduling. in the former we demonstrate significant reductions in search. 
1. introduction 
　we propose a model of problem solving that provides both structure and focus to search in the problem space. the model achieves this by combining the process of constraint satisfaction  csp  with heuristic search  hs . the resulting model both reduces search complexity and provides a explanation of the nature and power of heuristics in problem solving. our model focuses on reasoning within a problem space  and can be viewed as being complementary to the soar architecture  laird  newell & rosenbloom 1 . 
our problem solving model  called constrained 
heuristic search  chs   retains heuristic search's synthetic capabilities and extends it by adding the structural characteristics of constraint satisfaction techniques. in particular  our model adds to the definition of a problem space  composed of states  operators and an evaluation function  by refining a state to include: l this research hag been supported  in part  by the defense advance projects agency under contract #f1-c-1  and in part  by grants from mcdonnell aircraft company  boeing computer services  and schlumberger corp. 
1. problem topology: provides a structural characterization of a problem. 
1. problem textures: provide measures of a 
problem topology that allows search to be focused in a way that reduces backtracking. 
1. problem objective: defines an objective function for rating alternative solutions that satisfy a goal description. 
this model allows us to  1  view problem solving as constraint satisfaction  thus taking advantage of these techniques   1   incorporate the synthetic capabilities of heuristic search  thus allowing the dynamic modification of the constraint model  and  1  extend constraint satisafaction to the larger class of optimization problems. in the following  problem topology and textures are defined  followed by examples of their use in the domains of spatial planning and factory scheduling. 
1. problem topology 
　our intent is to define a problem's topology so that search can be performed more efficiently; this is related to the notion of a problem being  well structured   simon 1 . 
　within the heuristic search model  a variety of techniques for structuring problems have been investigated. abstrips  sacerdoti 1  demonstrated how hierarchical reformulation of the problem via omission of variables reduces search complexity  hearsay-ii  erman et al 1   molgen  stefik 1   and opis  smith  fox & ow 1  demonstrated how hierarchical reformulation via aggregation and abstraction reduces search complexity. isis  fox 1  demonstrated how hierarchical reformulation via omission of constraints reduces search complexity. these structuring techniques are more engineering guidelines than formal characterizations. 
　on the other hand  constraint satisfaction research has begun to formalize the concept of well structured constraint graphs  but their techniques can be applied only to a narrow set of problems. constraint satisfaction techniques  as described in 
 mackworth 1  haralick & elliott 1  freuder 
1  dechter & pearl 1   approach problem solving 
	fox  sadeh and baykan 	1 
　
by constructing a constraint graph where nodes are variables with discrete domains and arcs are n-ary constraints among the values the variables may be assigned. problem solving is performed by sequentially choosing a variable and a value to assign to it that satisfies all constraints incident upon it. backtracking occurs when an assignment cannot be found. research has gone into methods for structuring the network so that the amount of backtracking can be reduced. arc-consistency is one such technique that achieves local consistency between groups of variables via the elimination of incompatible values  montanari 1  mackworth 1  davis 1 . width 1 networks that are arc consistent are backtrack free  freuder 1 . 
　solving a csp involves finding an assignment of values to the variables that satisfy a set of constraints. from a heuristic search perspective  the initial state contains all the variables and their domains and constraints  the operators select a variable and a value to assign it  and the evaluation function is composed of constraints  some distance metric and an objective function. the sequence of states generated in the problem space represent alternative orderings of variables and values to assign to them. backtracking results in new braches in the search tree. the important insight that we wish to draw from csp research is that by manipulating the constraint graph  the ordering of variables and values can be optimized. that is  the constraint graph can be viewed as providing a structure for the problem. 
　we define problem topology as a graph g  composed of vertices v and edges e: 

each variable in n may be a vector of variables whose domains may be finite/infinite and continuous/discrete. constraints are n-ary predicates over variables vertices. a satisfiability specification vertex groups constraints into sets of type and  or  or xor. an xor satisfaction set denotes that only one constraint in the set must be satisified. edges link constraint vertices to variable vertices  and satisfiability specifications to constraints. 
　we distinguish between two types of problem topologies: 
　definition 1: a completely structured problem is one in which all non-redundant vertices and edges are known a priori. 
this is true of all csp formulations. 
	definition 	1: 	a 	partially 	structured 
1 	search 
problem is one in which not all nonredundant vertices and edges are known prior to problem solving. 
this definition tends to be true of problems in which synthesis is performed resulting in new variables and constraints  e.g. the generation of new subgoals during the planning process . 
　operators in chs have many roles: refining the problem by adding new variable and constraint vertices  reducing the number of solutions by reducing the domains of variables  e.g.  assigning a value to a variable vertex   or reformulating the problem by relaxing constraints or omitting constraints and/or variables. 
　features of the problem topology are the types of variables and constraints  and their associated propagation algorithms . davis  davis 1  mentions two classes of what we view as topological features  namely the types of values the domain of a variable may contain  such as variables whose domains are discrete and finite  label and value inference   are intervals  have belief for each member  relaxation labelling   and are expressions  expression inference . the second classs of features focus on the types of constraints  such as constraints that are unary predicates  order relations  bounded differences  e.g. x-y c   linear equations with unit  i.e. - 1   1  1  coefficients  linear equalities and inequalities with arbitrary coefficients  boolean combinations of constraints  algebraic equations  and transcendental equations. additionally  domains may or may not have preferences for values  e.g. preferences for due dates of a job . 
　what value do we derive from viewing a problem space state as a constraint graph  first  we have provided a more refined definition of a problem space state thereby reducing the looseness of its definition and allowing the definition of general measures of problem structure  i.e.  textures. second  properties can be proved about the nature of the problem  e.g.  width-1 constraint networks that are arc consistent are backtrack free  freuder 1 . third  the process of problem reformulation can be viewed as transformations of problem topological primitives. a possible negative  is that the number of problem types that can be represented in the form of a constraint graph is limited. but this set is growing larger; in the factory scheduling example  we show how the representation can be extended to handle optimization. by adding the power of heuristic search  we believe that we can apply the model to a broader class of problems. 
1. problem textures and objective 
　focus of attention in search is concerned with the ability of the search algorithm to opportunistically decide where the next decision is to be made  erman et al 1 . in chs  for search to be 
　
well focused  that is to decide where in the problem topology an operator is to be applied  there must be features of the topology that differentiate one subgraph from another  and these features must be related to the goals of the problem. we have identified and are experimenting with seven such features that we call problem textures  sadeh & fox 1 . below we define these textures for chss where all solutions are equally preferred  i.e.  the problem objective rates all solutions to the constraints equally acceptable. 
　 variable  value goodness: the probability that the assignment of that value to the variable leads to an overall solution to the chs  i.e. to a fully consistent set of assignments . this texture is related to the value ordering heuristics  haralick & elliott 1  which look for the least constraining values. value ordering heuristics are meant to reduce the chance of backtracking. in the case of discrete variables  the goodness of a value is the ratio of complete assignments that are solutions to the chs and have that value for the variable over the total number of possible assignments. 
　constraint tightness: constraint tightness refers to the contention between one constraint or a subset of constraints with all the other problem constraints. consider a chs a and a subset c of constraints in a. let b be the chs obtained by omitting c's constraints in a. the constraint tightness induced by c on a is defined as the probability that a solution to b is not a solution to a. in the case of discrete variables  this is the ratio of solutions to b that are not solutions to a over the total number of solutions to b. 
　variable tightness with respect to a set of constraints: again consider a chs a  a subset c 
　of constraints  and the chs b obtained by omitting c in a. a variable vs tightness with respect to the set of constraints c is defined as the probability that the value of v in a solution to b does not violate c  in the case of discrete variables  this is simply the ratio of solutions to b in which vs value violates c  i.e. at least one of the constraints in c  over the total number of solutions to b. 
　constraint reliance: this measures the the importance of satisfying a particular constraint. consider a constraint ci. we defined chs b as being chs a -  ci . given that constraints can be disjunctively defined  the reliance of chs a on a constraint ci is the probability that a solution to chs b is not a solution to a. in the case of discrete variables  constraint reliance is defined as the ratio of the number of solutions to chs b that are not a solution to chs a to the number of solutions to chs b. the larger the value  the greater the reliance the problem has on satisfying the particular constraint. 
　variable tightness: consider a variable v in a chs a. let c be the set of constraints involving v 
　and b be the chs obtained by omitting c in a. vs tightness with respect to c is simply called v's tightness. hence the tightness of a variable is the probability that an assignment consistent with all the problem constraints that do not involve that variable does not result in a solution. alternatively one can define variable looseness as the probability that an assignment that has been checked for consistency with all the problem constraints  except those involving that variable  results in a fully consistent assignment. notice that if one uses a variable instantiation order where v is the last variable  v's tightness is the backtracking probability. variable looseness/tightness can be identified with variable ordering heuristics  haralick & elliott 1  freuder 1  which instantiate variables in order of decreasing tightness. 
　variable contention: it estimates the degree of contention that exists among a set of constraints in assigning a value to a variable. given a chs a  a set c of constraints incident at variable v  and chs b = chs a - c  one measure of contention is to take the ratio of the number of elements c' of the powerset of c' that do not have a solution to chs b + c'  to the total number of elements in the powerset of c' in essence  the more combinations of constraints in c' for which there is not a solution  the greater the contention. 
　constraint arity: the number of variables involved in a constraint or more generally in a group of constraints. 
　these textures generalize the notion of constraint satisfiability or looseness defined by  nadel 1  and apply to both chss  and csps  with discrete and continuous variables. notice that  unless one knows all the chs's solutions  the textures that we have just defined have to be approximated. textures may sometime be evaluated analytically  sadeh & fox 1 . a brute force method to evaluate any texture measure consists in the use of monte carlo techniques. such techniques may however be very costly. in general  for a given chs  some textures are easier to approximate than others  and some are also more useful than others. usually the texture measures that contain the most information are also the ones that are the most difficult to evaluate. hence there is a tradeoff. each domain may have its own approximation for a texture measure. 
　we have extended these textures to take into account the problem objective where the objective is expressed as a sum of functions of one variable  using bayesian probabilities to approximate the likelihood that a variable results in an optimal value  sadeh & fox 1 . 
　textures provide a more principled view of attention focusing. as such  they can explain the power of heuristic knowledge used in search. we have already mentioned variable and value ordering heuristics respectively based on variable looseness and value goodness. another example is in factory 
	fox  sadeh and baykan 	1 
scheduling  where a useful heuristic is to schedule the bottleneck resource first. in our factory scheduling example we show that the concept of resource bottleneck analysis is motivated by constraint arity considerations and illustrates the concept of constraint tightness. 
1. chs problem solving process 
　the chs model of problem solving is a combination of constraint satisfaction and heuristic search. search is performed in the problem space where each state contains a problem topology. the problem solving model we propose contains the following elements: 
  an initial state is defined composed of a problem topology  
  constraint propagation is performed within the state  
  texture measures and the problem objective are evaluated for the state's topology  
  operators are matched against the state's topology  and 
  a variable node/operator pair is selected and the operator is applied. 
the application of an operator results in either adding structure to the topology  further restricting the domain of a variable  or reformulating the problem  e.g.  relaxation . 
　the next two sections demonstrate the application of the chs model to the problems of spatial planning and factory scheduling. 
1. spatial planning 
　wright  baykan & fox 1  is a spatial planning system that generates two-dimensional layouts consisting of configurations of rectangles. it is currently being applied to the design of kitchens. wright formulates space planning as a hierarchical chs. each level of the hierarchy consists of a set of variables and constraints. knowledge of the design domain is represented by a class hierarchy of prototype design units and constraints on them expressing desired spatial relations and limits on dimensions  areas and distances. inputs for generating a layout are an existing configuration which may be an empty space with dimensions specified as a range of values  and a set of design unit instances to be located and/or dimensioned. at the second level  the variables are the design unit instances. at the third level  variables are the locations of horizontal and vertical lines  dimensions  areas and orientations of the rectangular design unit instances. constraints are unary  binary or ternary algebraic relations. the constraint graph uses satisfiability specifications to denote conjuncts and disjuncts of constraints. spatial relations between design units are mapped onto algebraic relations between their component variables. prototype 
1 	search 
design units that have more than one instance may cause disjuncts in the constraint graph between levels 1 and 1  and spatial constraints that can be satisfied in different ways introduce disjuncts to the constraint graph between levels 1 and 1. the top level of the graph is in conjoint normal form. a new state is generated for satisfying each disjunct of the selected constraint. wright finds all significantly different solutions that are pareto optimal. 
　the spatial planning problem demonstrates the following characteristics of the chs problem solving model: 
  the problem topology is hierarchical  nodes  
i.e.  design units are composed of multiple variables whose domains are continuous intervals or discrete numbers  
  constraints define spatial limitations using size bounds and relative positioning  
  texture measures are used to identify the con-straint to satisfy  
  the problem objective is used to rate alteran-tive states  and 
  operators generate new states by either as-singing values to variables or further constraining or relaxing the problem. 
　wright uses three texture measures for selecting constraints. the first measure is from a variable perspective  and the last two are from a constraint perspective. the texture measures are: 
  variable tightness: is approximated by the number of remaining conjunctive constraints on each design unit instance. 
  constraint reliance: is approximated by 1/number of disjuncts. constraints with fewer disjunctive cases remaining are selected. if the number of disjuncts is 1  the constraint is satisfied without needing to generate a new state for each disjunct. 
  constraint tightness: is approximated by the reduction in the domains of continuous variables involved  as a result of satisfying the constraint. constraints that result in large reductions are favored. types of algebraic relations that will be added to the csp due to each of the competing constraints are also taken into account. 
texture measures are applied lexicographically. active constraints are assigned ratings with respect to a metric  and constraints with lower values are eliminated from contention. if there is a single constraint with the best measure  it is used. if more than one constraint remains  the next texture measure is applied  or a constraint is selected randomly. 
　figure 1 shows the number of search states required for finding all solutions to five kitchen layout problems  under different combinations of texture measures. the combinations tested are: method 1: selects a constraint at random  method 1: uses variable tightness  method 1: uses constraint reliance  method 1: combines variable tightness and constraint reliance  and method 1: uses all texture measures defined above. when a combination of more than one measure is used  they are applied in the order they are defined above. each measure eliminates some constraints from consideration. if more than one constraint remains after applying the texture measure s   specified by the method  a constraint is selected at random. the number of states given for each problem-method combination is the average of three runs. in the second problem  method 1 reduces search by more than 1% compared to method 1  and in the third problem by 1%. 

　in order to compare our approach to spatial planning with generate and test  wright is compared with two space planning programs  dps 
  pfeffercorn 1  and loos  flemming 1. their performances are compared in terms of the number of states generated when finding the first solution and when finding all 1 solutions. the problem used in the comparison is arranging six fixed size blocks  dps can only deal with polygons of fixed size  in a rectangular envelope  such that no blocks overlap. exactly the same objects and constraints can be used by all three programs due to the simplicity of the problem. wright finds the first solution using 1% fewer states compared to both dps and loos  and finds all solutions using 1% fewer states compared to loos  no data available for dps . 
1. factory scheduling 
　factory scheduling involves the assignment of start times and resources to a set of activities. each activity belongs to an order  i.e. job . activities within the same order are subject to precedence constraints as specified by a process plan. additionally no two activities are allowed to use the same resource at the same time  we assume resources of unary capacity . each order has a release date and a latest acceptable completion date  which may be later than the due date   that can be used to determine an earliest start time and a latest start time for each activity in the order. additionally each activity may require one or several resources  for each of which there may be several alternatives. for each activity  utility functions map each possible start time and each possible resource alternative onto a utility value  preference . the sum of these utilities over all the activities to be scheduled defines an objective function to be maximized. th ese utilities  fox 1  sadeh & fox 1 arise from organizational goals such as reducing order tardiness  reducing order flowtime  using accurate machines  performing some activities during a specific shift  etc. 
　we view the scheduling problem as an optimization version of the chs model  where each activity is an aggregate variable whose values are reservations. a reservation consists of a start time and a set of resources to be allocated to the activity. each activity constitutes a variable vertex in the problem topology. activity precedence constraints are binary constraints represented by constraint vertices connected to two activity variable vertices. a capacity constraint vertex is associated to each physical resource of the domain and connected to all the variablevertices representing activities that can possibly use the resource. each capacity constraint ensures that the corresponding resource will not be allocated to more than one activity at any given time. accordingly we distinguish between two types of constraint interactions: 
  the intra-order interactions defined by the precedence constraint vertices between activities belonging to a same order  and 
  the inter-order interactions induced by the capacity constraint vertices between activities contending for a same resource. 
both types of interactions contribute to the tightness of each activity. 
　search in our chs model begins with a single state where all activities still have to be scheduled and all resources are available scheduling an activity in a state with a reservation results in the creation of a new search state where new constraints resulting from the assignment of the reservation to to the activity are propagated. the propagation consists in udpating the domain of start times and resources that remain possible for each unscheduled activity  sadeh & fox 1 . if an inconsistency is detected the system backtracks. next the scheduler computes a tightness measure for each unscheduled activity. the activity with the highest tightness measure is selected to be scheduled next. a value goodness measure is computed to select the first reservation to be tried for that activity  among the reservations that are still possible . in this paper we assume that the goodness of a reservation is simply given by its combined utility  i.e. the sum of its start time utility and the 
fox  sadeh and baykan 1 
utilities of each of the resources selected for the activity in that reservation  more sophisticated measures of value goodness are discussed in  sadeh & fox 1  along with experimental results . the process goes on until all activities have been scheduled or until all search states have been visited. 
　in order to evaluate the performance of our measure of activity tightness  we designed a set of 1 scheduling problems. the problems contained between 1 and 1 orders  for a total number of activities ranging between 1 and 1. each activity required only one resource  for which there could be alternatives. in some examples the resource alternatives all had equal preferences  while in others they had different preferences. the scheduling problems were built to reflect a variety of demand profiles: localized bottlenecks at the beginning  middle  and end of the problem span  global bottlenecks spanning the whole duration of the scheduling problems  and auxiliary bottlenecks were all considered. three different types of start time utility functions were allowed: all start times  between the earliest and latest start times  are equally preferred   late start times are preferred  and triangular start utility functions with a peak corresponding to the due date  minus the duration of the activity . triangular utility functions were only assigned to the last activities of some orders. time was discretized and a granularity equal to the third of the smallest activity duration was used. 
　the experiments involved two variants of the same scheduler. in one variant the scheduler picked the next activity to be scheduled according to the tightness measure described in the previous subsection  while in the other variant the next activity to be scheduled was picked randomly among the remaining activities to schedule. 
　the performances of the two variants of the scheduler were measured along two dimensions: search efficiency  i.e. number of activities to schedule over number of search states generated  and global utility of the solution as defined by a normalized objective function. the normalized objective functions were built so that the best possible schedules that could be built without checking for constraint violation would have a global value of 1. in general the best feasible schedule had a global utility that was smaller than 1  hence the measures of global utility should only be used to compare the relative performance of the two variants  rather than assess their absolute performance. in the best case search was performed without backtracking  thereby resulting in an efficiency of 1. 
　the table in figure 1 reports the average search efficiencies and schedule values obtained for the two variants of the scheduler. standard deviations are provided between parentheses. rand denotes the random variable ordering variant  and 
1 	search 
tight the variant using our measure of variable criticality. the search was stopped when it required more than 1 search states. for rand  this cutoff rule had to be used in 1 of the 1 experiments. it did not have to be used for tight. the average search efficiency of rand is therefore even worse than 1. the average schedule values listed in the table correspond to the 1 experiments for which the rand variant found a schedule in less than 1 search states. 
　the results clearly indicate the increase in search efficiency obtained by using our measure of variable tightness. the micro behavior induced by this texture measure resulted in a macro behavior that focused search attention on bottleneck resources  when appropriate. additionally they show that the schedules obtained when using the tightness measure are also slightly better than the ones obtained with the rand variant. 

1. conclusion 
　the creation of general models for problem solving has been of continuing interest to artificial intelligence researchers. the process is evolutionary  elaborating and/or creating new search methods and richer representations of knowledge. the soar architecture  for example  combines both the problem space and production system models and extends them with universal subgoaling and chunking  thus achieving a model with powerful learning capabilities. but within this model  there are two aspects of the problem space that remain ill-defined: the notion of structure and means of focusing attention within a structure. our model  constrained heuristic search  extends the problem space model in these directions. problem topology provides a definition of structure in the form of a constraint graph. problem textures provide a probablistic  graph theoretic definition of the complexity and importance of decisions within a topology. problem ob-
jective defines an objective function that rates states that satisfy their constraints. together they enable the problem solver to direct search more economically towards a higher quality solution. 
　we demonstrated the model in two domains: spatial planning and factory scheduling. in spatial planning  we demonstrated that hcs is more efficient in finding solutions than other comparable systems. in factory scheduling  we generalized constraint graphs to account for preferential temporal constraints  making it possible to represent the general job shop scheduling problem for the first time. texture measures  based upon these preferences  enabled the scheduler to opportunistically select the next best decision to make. they also provided an explanation of the power of domain heuristics like bottleneck analysis. 
　currently  we are exploring additional constraint representations and propagation techniques in order to represent a broader set of problems. we also hope to explore the creation of methods for automatically reformulating problem space topology. 
