 
we take temporal reasoning to be the problem of maintaining a set of constraints between time points and/or intervals  and responding to queries about the temporal separation between those individuals. formal investigations of this constraint-satisfaction problem have demonstrated tradeoffs between the expressive power of the constraint language and the time required to answer queries. a simple constraint language admits an algorithm cubic in the number of individuals; allowing unrestricted disjunctive constraints makes the algorithm exponential. the problem is that applications of temporal reasoning  e.g. plan pro-
jection  need both disjunctive constraints and an algorithm much faster than 1   n 1   . it is significant  however  that the nature of the constraints added by and the queries posed by an application tend to be structured and predictable. our solution to the problem is to exploit the structure of the application domain to provide fast responses to typical queries. we consider the problem of plan projection under uncertainty and build a temporal representation-hierarchical interval constraints  hic -that allows appropriate dis-
junctive constraints. we then implement the hic representation in a temporal-reasoning module  and test it using a plan-projection application. applying the hic module to a simple temporal projection problem shows orders-of-magnitude improvement over running the same projector using current implementations of domain-independent temporal constraint propagators. 
1 	introduction 
temporal reasoning  tr  has become identified in the literature  e.g.  kautz and ladkin  1    dechter et 
   *this work was supported in part by nsf grants iri1 and iri-1 and by an nsf graduate research fellowship. thanks to dan weld for commenting on an earlier draft 
1 	automated reasoning 
a/.  1    meiri  1   as a domain-independent prob-
lem of constraint satisfaction: given  1  a set of temporal individuals  time points and/or intervals    1  explicit constraints on their temporal separation  and  1  implicit constraints like the interval transitivity relations of 
 allen  1  or the transitivity properties of euclidean metric distance  compute the tightest bounds on the separation of any two individuals.  dean and mcdermott 1    koomen  1   and  kautz and ladkin  1  report on implementations of these domain-independent algorithms. 
   there have been two predominant approaches to temporal reasoning. interval-based systems   allen  1  take intervals to be the fundamental temporal entities  and allow the specification of qualitative constraints that hold between intervals. systems based on time points  dean and mcdermott  1; dechter et a/.  1   on the other hand  take instants in time  points  to be the fundamental temporal entities  and allow both qualitative and metric constraints among those individuals  constraints specify that the temporal distance between two time points falls within some particular interval.  there has been a significant amount of work comparing these two approaches  and also some recent work showing how the two frameworks can be unified  vilain et a/.  1; kautz and ladkin  1; meiri  1 . 
   analysis of these systems reveals a clear tradeoff between the expressive power of the constraint language and the worst-case running time of the constraint propagation algorithm  tradeoffs that hold regardless of the underlying representation. detailed analysis of these results is beyond the scope of this paper  but shows that  simple  constraints1 over either a time-point or time-interval-based system admit an 1   n 1   solution algorithm  where n is the number of temporal individuals  points or intervals . simple constraints cannot represent certain disjunctive information  however  and algorithms for processing sets of unrestricted disjunctive constraints require time exponential in n in the worst case. 
 
　　see  dechter et a/.  1l  and  vilain et al.  1  for a precise definition of simple constraints.  davis  1  analyzes this tradeoff as well. we defer a detailed comparison of these systems to  williamson and hanks  1 . 
　many application areas in ai do some sort of temporal causal reasoning: reasoning about changes in propositions  the occurrence of events  and so on. planning  temporal projection  motivation analysis  and qualitative simulation are prominent examples. causal reasoning in turn requires temporal reasoning  to keep track of the durations of events  the time at which propositions change state  and so on. 
　these formal results about temporal-reasoning algorithms are troublesome to programs that do causal reasoning. causal reasoning almost always involves some sort of disjunction  as discussions in  hanks  1a   
 dechter et al.  1   and  weld and de kleer  1  chapter 1  demonstrate  so simple temporal constraints will not generally suffice. 
　moreover  the application program may generate great numbers of temporal individuals  and will call the tr module many times in the course of doing higher-level causal reasoning. experiments in  hanks  1b  show that projecting a plan of roughly 1 steps generates about 1 time points  and that about 1% of the projector's time is spent performing temporal-reasoning tasks. even the cubic tr algorithm will be unacceptable for most applications. 
we must conclude  then  that domain-independent or 
 uninformed  temporal reasoning is too slow to support reasonable application-program performance. in this paper we advance the idea that the application domain can provide the  information  that allows temporal reasoning to be efficient the temporal constraints imposed by an application  and the queries it typically poses to the tr module  are structured and regular. a tr module can exploit this structure and these regularities and by doing so can provide appropriate functionality while delivering acceptable performance. 
　we demonstrate our approach by considering a particular causal reasoning problem  a simplified version of plan projection under uncertainty  hanks  1a  and  hanks  1b . we define formally the plan language used by the projector and a corresponding structured representation for the temporal information it generates the representation  called hierarchical interval constraints  hic   combines time point and in-
terval information in a nested format that  mirrors the structure of the projector's plans. we implement a temporal-constraint propagator using the hic representation  then run experiments by instantiating a simple projection algorithm using our hic' propagator  dean's  time-map manager  and kautz and ladkin's  l1l  mats system as subroutines. the hic system runs faster by orders of magnitude; furthermore  its performance degrades more slowly as problem size increases. 
1 	the plan projection problem 
 hanks  1a  discusses the problem of projecting totally ordered sequences of actions under uncertainty. uncertainty about the state of the world or the effects of an action means that an action sequence  plan  may have many possible outcomes. the projector builds a scenario tree1  which is a temporal trace of the plan's execution. each path through the tree  a chronicle  is one possible  internally coherent course of execution. the projection problem is to control branching in the scenario tree while still being able extract useful information about the plan's effects. 
we will simplify the projection problem somewhat: 
  instead of the probabilistic representation in  hanks  1a  we will use a three-valued truth assignment true  false  unknown for each proposition. a world state then consists of propositions along with their truth assignments. any proposition not true or false is assumed to be unknown. 
  a simple action consists of a name and a set of outcomes. each outcome is a pair   condition  effect . the condition describes the world states in which the corresponding effect will be realized-a condition is a set of propositions. the corresponding effect consists of a duration  a time interval  and a set of proposition/truth-value pairs. 
the idea is that if  at execution time  all of a condition's propositions are true  then all of the effect's propositions will take on the corresponding truth value we require that an action's conditions be mutually exclusive and exhaustive  so at execution time exactly one outcome will be realized. the projector may not know which one  however  since one or more of the action's conditions may have truth value unknown. projecting a simple action will cause a branch in the scenario tree each time more than one of an action's outcomes has a condition that evaluates to true or unknown. 
  from the simple actions we define complex actions representing sequential  parallel  conditional  and it-
erated execution of simple actions1. 
if a1  a1  an are actions and p is a proposition  then the following are actions too: 
-  seq a1  a1  . . .   an  
-  par a1  a1  	    an  
-   i f p a1 a1  
-  while p a1  
　the projection algorithm is presented with an initial world state and an action. it projects the action fully  branching every time a subaction has multiple possible 
outcomes. 
　consider  for example  projecting a plan such as  seq a b c d . suppose that the projector can identify a single outcome for each action except c 1 which has two possible outcomes. figure 1 a  shows what the scenario tree would look like. the nodes in the tree represent the outcomes of the primitive actions in the plan. there are two chronicles  representing the two possible courses of execution. 
1
   this structure is similar to an environment graph   davis  1  chapter 1 . 
1  shaw  1   uses similar program-description operators. 
1 that is  exactly one condition for a  1  and d evaluates to true. 
	williamson and hanks 	1 


 b  hic representation 
figure 1: projection example 
　the projector may then have to answer questions both about the states of propositions at various points of time- is p true when action a is executed    is g true when the plan finishes executing  -and also temporal queries like  how long will the plan take to execute   and  will this segment of the plan take more than 1 minutes   we address queries only of the latter type  and furthermore  will concentrate mainly on temporal queries involving the distance separating time points within the same chronicle 
　we will next describe the hierarchical interval constraint structure  which is an attempt to mimic the sorts of temporal structures generated by the projector 
1 	hierarchical interval constraints 
a hierarchical interval constraint  hic  represents an interval of time  and may comprise one or more suhiutervals. subintervals  if any  are also represented by hics. the interval's duration-its minimum and maximum temporal length-depends on the two sorts of information: the durations of its subintervals  and the interval's type. hic types represent common temporal reasoning structures  some of which cannot be represented as simple temporal constraint graphs 

table 1: how  is calculated for complex hics 
of  for each hic type. a hics duration  is computed increment ally by the system when it is defined  a process requiring time linear in the number of its children. 
　for example  imagine that we wish to reason about an action go-to-work  which will be carried out by performing one of two possible subactions: either by walk-to-work  taking from 1 to 1 minutes  or bike-to-work  taking from 1 to 1 minutes. we create simple hics w and b to represent the last two actions  and specify =  1  and =  1 . we then create a selection hic  g  to represent the go-to-work action and specify that =  b  w . the system will calculate that =  1 . 
　the descendants of a hic are its children  all their children  etc.  the terms parent and ancestor also have the obvious definition.  a hic must have at most one parent  and no hic may be a descendant of itself; i.e. hics must be properly nested. a top-level hic is one that has no parent a leaf hic has no children. leaves must be type simple. 
　our temporal reasoning module reasons about isolated time points in addition to these hic structures. time points may be useful to represent the occurrence of exogenous events  or to synchronize the plan's execution with known clock times time points are integrated with hic' structures to form an arbitrary temporal constraint graph  tcg   with time points as the vertices and toplevel hics as the edges if all of the hics were of type simple and sequence  the expressive power of the system would be equivalent to a network consisting of simple temporal constraints as described in  dechter et al.  1 . this is also equivalent to the constraints allowed by the tmm system  dean and mcdermott  1 . 
　the additional hic types  selection and parallel  significantly increase the expressive power of the system. they allow an application to represent and reason effi-

1 	automated reasoning 

ciently about commonly occurring temporal situations which previously existing formalisms could only accommodate by resorting to more general  exponential-time algorithms an example of this is the go-to-work situation described above. simple temporal constraint networks  in the technical sense of  dechter et al.  1   cannot represent this situation at all. general temporal constraint networks can find the more precise solution but are np-hard to solve. 
　temporal queries request the distance between two time points  which may be the beginning or end of any hierarchical interval  known as virtual time points   or one of the isolated time points in the tcg. 
　we compute the temporal distance between two time points as follows: 

  if the two time points are both endpoints of hics that share some common ancestor we compute the distance from each time point to each end point of that common ancestor. although this requires time exponential  1d   in the depth of nesting of the hics  this is still at most linear in the number of descendants of the intervals' common ancestor1. 
  if the two time points are not end points of hics that share a common ancestor  or if either of them is an isolated time point in the t c g   we have no choice but to propagate bounds through the entire graph. we use the floyd-warshall transitive closure algorithm  which is 1 n1  in the number of explicit time points  but independent of the number of hics.  the algorithm requires only the lengths of the toplevel hics  which have been pre-computed.  
 williamson and hanks  1  provides a complete discussion of the query algorithm and its computational complexity. 
   our algorithm's computational advantage derives from the fact that it allows the application to represent a temporal reasoning situation using the hic framework almost exclusively-only a small number of explicit time points are typically required. in fact most queries do not require solution of the solution the t c g at all  and even when the entire graph must be considered it is much smaller than it would be if the same situation had been represented using existing  uninformed tr systems. 
   by letting the application provide information about the structure of the tr task  hics effectively allow the query algorithm to ignore constraints irrelevant to the particular query. as a striking example  we shall consider our plan projection application  which does not require the construction of a t c g at all  but represents the projection scenario in a single nested hic structure 
1 	h i c s i n p l a n p r o j e c t i o n 
hic types simple  sequence  selection  and parallel directly support the plan projection task. a simple hic represents a single  atomic action. it has no subintervals  and its temporal length  minimum and maximum  is supplied by the application. a sequence hic represents two situations: a compound action composed of a number of sub-actions executed sequentially  as well as a series of adjacent actions each with a single outcome. in other words  a scenario tree with a single branch appears as a sequence interval constraint. 
   selection hics represent actions that have more than one possible outcome due to uncertainty: a sub-hic is created for each possible outcome. 
   as an example  consider projection of the plan mentioned above  which gave rise to the chronicle tree in figure 1 a . figure 1 b  shows the corresponding hic structure. the smallest boxes are simple intervals representing the outcomes of each primitive action. e1 is a selection hic representing the fork in the scenario tree. the fact that it is a selection hic codes the information that exactly one of the branches will actually be realized 
1
　　assuming that each non-leaf hic has two or more children. 
at execution time. s1  s1 and s1 are sequence hics  si representing the temporal interval over which the entire plan is executed. 
　queries to the temporal-reasoning module might ask about the amount of time separating any two time points: the beginning or end of any pair of the structure's intervals. note again that neither the initial pro-
jection task nor queries involving the plans steps require construction of a temporal constraint graph. we represent the entire scenario tree in a single  nested hic structure  meaning that temporal queries will require at worst time linear in the number of time points. in many cases the time required will be significantly less. 
   an example of the increased expressiveness of our system is that the duration of the entire plan can be obtained with a single temporal query. existing implementations based on simple temporal constraint networks would require the application to minimize and maximize over the durations of each individual chronicle to obtain the same information. 
1 	empirical results 
we implemented our projector on top of three different tr modules: our own hic system  the metric/allen 
time system  mats  of kautz and ladkin   and the temporal reasoning component of dean's  t m m all systems were implemented in common lisp  and tests were run on the same machine under similar loading we will first describe how we implemented the projector using the other two temporal-reasoning modules  then report the comparative results. 
   t m m ' s temporal reasoning facility essentially builds a graph of time points constrained by simple interval metric constraints. t m m allows no disjunctive constraints. we represented the projected plan's scenario tree by creating a pair of time points to represent the beginning and ending of each plan outcome  which were then constrained by the associated action's duration. the end point of each outcome and the begin point s  of the following outcome s  were constrained to be consecutive by adding the constraint  1  between them. 
   the mats system integrates metric information into allen's framework of qualitative interval relationships. it allows the creation of temporal intervals  specification of their qualitative relationships  and specification of interval-valued metric constraints between the end points of intervals. we represented the scenario tree by creating an interval for each action outcome. the duration of such outcome's interval once again has the application-supplied duration. intervals for successive outcomes are constrained to meet each other. 
   for each implementation we projected plans that generated scenario trees of various sizes. we then performed 1 random temporal queries on the resulting temporal structures the plans were all less than ten steps long. we changed the number of possible outcomes in the scenario tree by varying the number of possible outcomes for the first action. in effect this introduced uncertainty early in the projection. the number of initial branches varied between one and eight; doubling the number of 
	williamson and hanks 	1 
initial branches essentially doubles the size of the resulting scenario tree. 
   we formed a temporal query by randomly choosing a chronicle from the tree  choosing two outcomes from that chronicle  and then choosing one of the end points of each of those outcomes. table 1 shows the cpu time  in milliseconds on a decstation 1  required for projection and query processing. 
   note that the query time required by the mats system is cubic in the size of the scenario tree  making it completely impractical for larger problems.  mats also requires space quadratic in the size of the tree   mats spends almost all of its query-processing time in computing the solution for the entire tcg  which is then cached. mats would therefore take essentially the same amount of time to process one query as it did to process all 1 queries. tmm and hic  on the other hand  compute query answers incrementally  and would therefore process a single query roughly 1 times faster 
　tmm's temporal reasoning mechanism required only linear time to answer queries  but seemed to require quadratic time to construct the constraint graph initially  we discuss tmm's propagation mechanism below 
　our hic system required only linear time for projection  and performed queries in sub-linear time this is possible because the constraint network's structure allows the query algorithm to isolate a particular chronicle and ignore the  irrelevant  constraints in the others. 
　these results suggest that our system is capable of handling projection problems several orders of magnitude larger than either of the alternative implementations. 
1 	related work 
 kautz and ladkin  1l  and  dechter et al.  1  both present metric tr algorithms that are completely domain independent. we noted above our opinion that these algorithms are mainly useful for pointing out explicitly the tradeoffs between expressive power and speed. we doubt that either algorithm  implemented without problem-dependent optimizations  will prove useful for applications of a reasonable size.1 
    allen  1  introduces the notion of a reference interval1 as a means of controlling temporal inference each interval added to the database is assigned to one or more reference intervals  and the system caches the full interval transitivity table for all the intervals contained within a given reference interval. to infer the relationships between two intervals that do not share a reference interval the system searches for a path between the two intervals  restricting its search to reference intervals alone. allen discusses the possibility of applying this idea to the problem of reasoning about events and processes  though he does not implement such a system. we provide an implementation  and furthermore extend the temporal rep-
   1on the other hand  the mats implementation available through  kautz and ladkin  1l  is extremely elegant and easy to use  and so provides a nice vehicle for exploring small problems. 
1allen in turn acknowledges  kahn and gorry  1 . 
1 	automated reasoning 
resentation to include quantitative as well as qualitative constraints. 
　the t i m e l o system of  koomen  1  implements a temporal reasoning algorithm based on allen's qualitative interval framework. it provides an algorithm for building reference-interval structures automatically. in some sense koomen' approach is diametrically opposed to our own. both approaches recognize that an application's constraints and queries exhibit regularities  and furthermore that exploiting these regularities is crucial to achieving good performance. in koomen's system the application adds constraints without communicating that structure to the temporal database module; timelogic rediscovers that structure by constructing an appropriate hierarchy of reference intervals. our approach allows the application to communicate its temporal structure directly  which is then incorporated into the structure of the temporal database itself. 
   dean's  time-map manager  tmm  implements both causal and temporal reasoning patterns. its temporal-reasoning mechanism constructs graphs whose nodes are time points connected by simple metric constraints it implements a heuristic  limited-depth search to infer the mst restrictive constraints binding any two points in the graph. underlying this scheme is the assumption that paths through the constraint graph will be short the search can be quite efficient if the assumption holds  but if it is violated-if the graph contains long paths or is highly connected--its performance can degrade to worse than the standard on1  algorithms. and since the algorithm abandons paths that exceed a constant bound  it can potentially report incorrect results. 
　a second notable feature of tmm is its temporal indexing scheme. this technique  which is also similar to reference intervals  allows the application to provide information about the granularity of the temporal reasoning problem so that time points can be indexed for more efficient retrieval this functionality is an important step toward the kind of informed temporal reasoning necessary for realistic applications. 
　our work also builds on the work in  hanks  1   which was an early attempt to optimize a temporal database manager to perform tasks like temporal inferencing  temporally scoped database fetches  and hypothetical recisoning about the future  under conditions of uncertainty and ignorance. 
1 	conclusion 
formal explorations of temporal-reasoning algorithms have made the tradeoffs between expressive power and computational efficiency extremely clear. the results point out that an application cannot use a domainindependent temporal constraint propagator and expect reasonable performance: reasonable functionality comes at the price of an exponential algorithm  and the algorithms are too slow in the worst case even under the most restrictive limitations. 
　our paper has shown how to build an efficient temporal reasoning module by exploiting regularities both in the constraints typically added by the application and 


table 1: cpu time  in msec  for projection and 1 temporal queries 

in the queries typically posed. we considered the problem of plan projection  and advanced a formal model of the problem's constraint structure. a temporal projector using an implementation of our model dramatically outperformed current domain-independent implementations in absolute terms  and furthermore showed better performance degradation as problem size grew. 
　it remains to be seen the extent to which our h1c model for temporal reasoning can be applied to other application domains  or whether a class of similar models can be developed for other applications. it is clear  however  that if a temporal-reasoning system is to be of practical value to a realistic implementation  it will have to have some model of its applications1 behavior identifying a set of hic-like structures offers a promising means of providing functionality midway between truly domain-independent temporal reasoning and problemspecific programs. 
