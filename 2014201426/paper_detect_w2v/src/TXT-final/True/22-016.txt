 
over the last few years  object-oriented techniques have gained an increasing recognition both in software engineering and in ai. object-oriented systems present undisputable advantages and 
provide features that make them really suitable to represent knowledge. however  our practical experience in using these techniques for knowledge representation led us to discover that objectoriented systems also present serious drawbacks  essentially due to their lack of expressive power. these drawbacks can really be felt when modelling domains characterized by a wide variety of knowledge. this paper introduces the notion of representation cluster  which allows to provide any object-oriented system with customizable knowledge representation formalisms. these formalisms enable to express and handle diverse kinds of knowledge using only their natural highlevel properties. such an approach speeds up knowledge bases development  makes them clearer  natural  and avoids a great deal of code writing. its advantages are illustrated on two realistic examples extracted from the knowledge representation system of an expert system shell dedicated to realtime network troubleshooting. 
1 introduction 
as a tool for representing knowledge  object-oriented techniques present a well known interest. they are particularly suited to express knowledge in systems that are inherently model-based. 
　that is why we intensively used object-oriented techniques to model the knowledge in our dantes network troubleshooting expert system.  for a description of dantes  see  mathonet et al..   1  . we learnt  the  hard way   that a growing knowledge base can become very difficult to understand and to maintain. this led us to identify some drawbacks in the use of object-oriented techniques for representing knowledge; they are explained in section 1  after a brief overview of the principles of object-oriented techniques in the contexts of programming languages and knowledge representation. 
* this research was supported by irsia/iwonl. 
to overcome the lack of expressive power of the initial 
dantes object-oriented system  we enhanced it with the notion of representation cluster. this concept is perfectly general and can be applied to any object-oriented system. its definition can be found in section 1  together with the description of an enhanced object-oriented system  called doos . 
　for illustration purposes  section 1 is devoted to two realistic uses of the representation cluster concept in the domain of computer network troubleshooting. finally  section 1 stresses the gain of expressive power brought by representation clusters to object-oriented systems. 
1 object-oriented systems 
this section discusses the advantages and disadvantages of object-oriented systems. as the term object-oriented system can have slightly different meanings depending on the context where it is used  we first specify the object-oriented systems considered in this paper. for a complete discussion  see  stefik and bobrow  1 . 
1 object-oriented programming languages 
object-oriented programming is based on the concepts of object  class  inheritance and message passing. an object is  an entity that combines the properties of data and procedure   stefik and bobrow  1 : an object has a local memory  variables  and procedures  called methods  attached to it. the interaction between objects is done via message passing. an object responds to a message by executing one of its methods. objects are organized into classes  i.e. in sets of objects sharing the same properties and the same behaviour. the objects belonging to a class are called the class instances. classes can be organized in an inheritance lattice. some object-oriented programming languages also provide metaclasses. a metaclass is a class of classes. as stressed in  danforth and tomlinson  1   the primary justification to introduce such a feature is the desire to treat everything as an object. 
　compared with more traditional approaches  objectoriented programming languages have several advantages  mainly due to a clean data and procedure organization  stefik and bobrow  1 . they support data abstraction  increase the modularity of programs  and  due to property inheritance  avoid redundant declarations or specifications. therefore  object-oriented programming languages encourage the development of better organized  more easily modifiable  and thus more robust software. 
1 object-oriented 	concepts 	and 	knowledge representation 
1.1 object-oriented 	systems 	for 	knowledge representation 
　in ai  object-oriented concepts have been used for knowledge representation purposes. object-oriented representation systems can be related to knowledge representation systems based on the frame idea  minsky  
1   such as krl  bobrow and winograd  1  or kee  fikes and kehler  1 . the term frame-based systems designates a large family of systems which are all based on the same fundamental principle: they organize knowledge into structures that group both data and procedures; these structures are related by some inheritance mechanism. the similarity with the object-oriented concepts in programming is obvious. 
　in the rest of this paper  object-oriented system refers to a system relying on the basic principles of object-oriented programming and possibly providing specific features for knowledge representation  such as viewpoints  bobrow and winograd  1  or variable annotations. object-oriented systems enable the treatment of some common sense reasoning aspects and especially of exceptions and defaults. they provide general and flexible techniques that are ideally suited to express knowledge in model-based systems. 
1.1 limitations 
　object-oriented systems offer a relatively low level of abstraction and represent knowledge in a uniform way. 
　low level of abstraction means that there is an important semantic gap between knowledge as perceived in the real world and its representation. knowledge is complex in essence: it generally involves subtle and rich concepts mixed together or interlinked by a large amount of various relationships. this contrasts with the simplicity of the features provided by object-oriented systems: object  class lattice  inheritance... as a consequence  the representation of any knowledge requires the decomposition of this knowledge into primitive and simplified elements which fit into the framework imposed by the object-oriented system. as knowledge does not directly match the features provided by the object-oriented system  the knowledge base  kb  developer must force the matching  often by adding procedural code to the knowledge representation. for example  suppose that some device d is represented by an object o. expressing that an instance variable of o represents a relationship between d and other devices must be done by providing the object o with procedures which handle the constraints and treatments required by the inteipretation of the variable as a relationship. in real-life situations  the resulting knowledge bases often consist of a few class definitions and a large amount of procedural code where recognizing the represented knowledge is very difficult. representing knowledge becomes a very difficult programming task that requires a lot of time and effort and a very sound methodology. 
　uniformity of representation means that every concept in any knowledge is directly represented using the same basic techniques. still  knowledge is not uniform but is by nature very different from one domain to another: just consider medicine  oil drilling or plant control. futhermore  within a given domain  knowledge can also present broad differences. except for very simple domains  it clearly and naturally divides into various kinds of knowledge. each of these kinds of knowledge is characterized by intrinsic properties of its own. these intrinsic properties depend of course on the knowledge itself but also on the treatments to be performed by the knowledge-based system. however  within an objectoriented system  all the different kinds of knowledge must be expressed by means of class lattice  variables  methods...  whatever the differences between them. 
　these drawbacks can make an object-oriented knowledge base unnatural and very difficult both to understand and to maintain. moreover  these problems do not facilitate the concurrent development of a knowledge base by several persons. as each developer can have his own ideas about the best representation strategy  the kb risks to be totally unreadable. 
1.1 example 
　to illustrate the notions of kind of knowledge and of intrinsic property  let us consider the dantes application domain: network troubleshooting. network troubleshooting involves  at least  two kinds of knowledge: knowledge about the components constituting the network  e.g. nodes  lines  peripheral processors  and knowledge about the events  the alarm notifications  issued by the network. each of these kinds of knowledge has its own characteristics. 
　all network components have individual properties such as an identifier  a location  a current status. network components are interlinked by various relationships  for example   processor pi1 is connected to node boston by line 1  . the intrinsic properties of network components include thus their individual properties and their relationships. 
　events emitted by the network are also characterized by some individual properties: the identifier of the issuing component  a specific code  the time at which they have been issued  ... moreover  they have a format. events are issued by the network as byte strings; the format of an event is the description of the corresponding string. note that events are not linked by any relationship. the intrinsic properties of the event kind of knowledge include the individual properties and the format information. 
1 an enhanced object-oriented system: 
doos 
1 the concept of representation cluster 
the limitations discussed in section 1.1 should not lead designers to forget the advantages of object-oriented systems  which make them a very sound basis for knowledge representation. however  we believe that these systems should be enriched with mechanisms allowing to customize them to the representation requirements of each particular kind of knowledge. these requirements include an expressiveness tailored to the intrinsic properties and the automatic generation of general treatment procedures associated with these kinds of knowledge. such customization mechanisms lead to two object-oriented levels: the knowledge representation level and the underlying object-oriented system level; the former constitutes an abstraction layer on top of the latter. 
tools 　to represent and handle knowledge using directly its intrinsic properties  a representation cluster  rc  is associated with each kind of knowledge. a rc groups all the knowledge representation level classes modelling the corresponding kind of knowledge and is characterized by two properties: a class definition mechanism and a class instantiation mechanism. these mechanisms specify the syntax and the semantics of the formalisms that must be used to respectively define and instantiate the classes belonging to the rc. 
　this approach is still object-oriented and satisfies the basic principles exposed in section 1; domain entities are represented by classes and instances. however class definition and instantiation formalisms are no longer fixed as in classical object-oriented systems but can be adapted to the natural high-level properties of the represented knowledge. therefore  a rc constitutes a knowledge representation environment specifically suited for a given kind of knowledge. 
1 doos an object-oriented system embedding the rc concept 
the rc concept has been implemented in doos  the 
dantes object-oriented system. doos provides an underlying object-oriented system with the representation cluster concept. the underlying system is based on flavors  weinreb and moon  1  and provides the features described in section 1: classes  multiple inheritance  class and instance variables  class and instance methods  variable annotations and viewpoints. in doos  a rc is defined by its name  its possible super rc  representation clusters can be organized in a tree allowing inheritance between them  and the declaration of its class definition and instantiation mechanisms. the following subsections present these mechanisms in doos. 
1.1 rc class definition mechanism 
　in doos  a class definition is always handled using a define lisp form. which arguments must be given to this define form is specified by the class definition mechanism of the rc to which the class belongs. these arguments are thus entirely adaptable to the kind of knowledge related to the rc  and are chosen to allow the explicit expression of all its intrinsic properties. 
　most generally  the first three arguments will be the rc name  the class name and the possible superclass name s   used to establish the class lattice within the rc . other arguments can  for example  specify the class and/or instance variable names and annotations  class properties like its relationships with other classes  class behaviours like the way a network component propagates its status changes to other components. 
　the rc class definition mechanism also specifies the function that will interpret the definition of the classes belonging to the representation cluster. this function will generate code to implement any action implied by the class definition. these actions can include a class definition in the underlying object-oriented system  the introduction of mixins for this class  the management of the class name property-list ... the interpretation function can also induce the automatic generation of functions or methods which will be used to manipulate the represented knowledge. 
1.1 rc class instantiation mechanism 
a class instantiation is handled by a create lisp form. 
the class instantiation mechanism specifies the arguments of the create form and the function that interprets this form. the arguments of the class instantiation form can explicitly refer to the intrinsic properties of the considered kind of knowledge. the interpretation function will take any action necessary when a class will be instantiated. these actions will most generally involve the effective creation of an instance but also any treatment related to the  birth  of a new instance  for example  the modification of other instances linked to the new one by some relationship or the automatic creation of other instances related to the new one . 
1.1 defining class definition and instantiation mechanisms 
　in doos  the classes belonging to a rc and the rc intrinsic properties are mapped into features directly provided by the underlying object-oriented system. 
　for example  one can interpret the definition of a class c belonging to a particular representation cluster by defining a class c in the underlying object-oriented system. each intrinsic property specified in the class c definition can be implemented using a large variety of techniques  including the following: 
- as a class of the underlying object-oriented system  related in some way with c; 
- as a mixin mixed to c; 
- as a  set of  class variables of c; - as a  set of  instance variables of c; - as a method defined on c. 
　this mapping is specified in the class definition mechanism. at the present time  the language used to define the class definition mechanism associated with a rc is the language provided by the underlying object-oriented system  and lisp . in the future  doos should be provided with a higher level formalism for defining that mechanism. this formalism would allow to declaratively express the mapping from classes belonging to a rc and the rc intrinsic properties to the features provided by the underlying objectoriented system. 
　as an example  suppose that a rc  named r  has three intrinsic properties: p1  p1  p1. the definition of the class definition mechanism of this rc could be: 
 defmeca for r 
:define-form-args 
 rc-name c p1 p1 p1  
:define-form-interpretation-function :c  class :name c  
:p1  mixin :name pv :mixed-in c inheritance superclasses-first  
:p1  class-variable :name p1' :of c :init-value nil  
:p1  method :name p1' :of pv :parameters    
:body  ...     
the :define-form-args declaration indicates that the 
define forms used to define classes belonging to r should have five arguments: the rc name  the class name  c   and the values ot the intrinsic properties p1  p1  p1. 
　the :define-form-interprctation-function declaration specifies how a class c belonging to r  and its intrinsic properties  should be mapped into features of the underlying object-oriented system: 
- a class  named c  would be defined in the underlying object-oriented system  
- a mixin  named p1'  would be defined and introduced as a superclass of c  the inheritance priority could be specified   
- a class variable  named p1  would be introduced in the class c; its initial value would be nil  
- a method  named p1  with no arguments and the specified body  would be defined on the mixin p1'. 
　the interpretation of such a declarative definition would automatically generate the effective class definition mechanism associated with the rc named r. 
　the class instantiation mechanism associated with r could be defined in a similar declarative way. 
1 using representation clusters to customize knowledge representation 
to illustrate how representation clusters can be used for developing dedicated knowledge representation systems  let us consider examples drawn from the dantes knowledge representation system  developed using doos. dantes is a tool to build expert systems for real-time network problem management. such expert systems receive events issued by the network components or reported by the persons who operate on the network. they interpret and correlate these events to detect and diagnose problems in the network with the aim to identify faulty components. as mentioned in section 1  two kinds of structural knowledge are of particular interest in this domain: the network components and the network events. both have quite different properties. the subsections below are devoted to these kinds of knowledge and to their representation. 
1 network components 
1.1 background 
　computer networks are composed of various interconnected components  e.g. nodes  trunks  lines  processors . a network component is characterized by some specific individual properties  name  location  identifier ...  and by some behaviours such as the way its status variations are propagated to its related components. network components are interlinked by various relationships. for example  if the hardware constituents of a node are a memory  a bus  a control processor  and some line processors  there exists a relationship constituents linking the node and its hardware constituents. the intrinsic properties related to network components include thus their individual properties  their behaviours and their relationships. 
　the structural knowledge about a network can then be divided into the following: 
- the network model. this includes the description of the various network component types  their individual properties  their behaviours  and the relationships that exist between them. 
considering our preceding example  if the network has nodes with four types of hardware constituents  memory  bus  control processor  and line processors   the network model will include the definition of the following specifies the nodes present in the network  e.g. three nodes: new-york  boston  and washington   together with their related hardware constituents. 
　the network configuration generally includes thousands of components. during their activities  the reasoning process and the network operators need to access specific components according to various and complex criteria. therefore  an efficient retrieval mechanism must be provided. this mechanism makes an intensive use of the relationships between network components. for example  if one has to access all the components constituting the hardware of a switching node  what is needed is all components linked to the switching node by the constituents relationship. 
1.1 before doos 
　in the initial version of dantes  knowledge was directly represented with flavors. each component type was represented by a flavor. its properties were expressed by instance variables. its behaviours were explicitly attached as mixins to the flavor. the large variety of behaviours often led to a flavor and mixins  soup   hardly maintainable  and with a functionality very difficult to predict. the flavors representation of relationships was really low-level. a relationship was represented  in the network component flavor  by an instance variable containing the list of the related components. in this approach  relationship management had to be explicitly expressed with procedural code attached to each network component flavor having instance variables representing relationships. this code and the resulting retrieval mechanism depended on the network representation and had to be adapted each time a relationship type was modified or added or when a new type of component was defined. 
　the creation of the network configuration consisted in making instances of the network component flavors with correct initial values for their instance variables including those representing relationships. the configuration creation also depended strongly on the network representation and any modification to the relationships induced modifications to the configuration creation mechanism. 
　a great deal of the problems above came from the inadequate level of the relationships representation. this resulted in a knowledge representation that contained too much sensitive code which had to be adapted or revised whenever the network model was modified. 
1.1 what doos provides 
　the following rcs are defined using doos: networkcomponent and network-relation. 
network-relation 
component types: node  memory  bus  control-processor  network components. a relationship existing between 　we will only describe the features of the network-relation formalism which are necessary to understand the use of relationships in the definition  creation and treatments of 
　
line-processor. the network model will also include the definition of the relationship constituents linking the node component type and the memory  bus  control-
processor and line-processor component types. 
tools - the network configuration. it describes all the components physically present in the network and their relationships. for example  the network configuration network components is represented by two dantes relations. these relations must be understood in the common mathematical sense. they are binary and inverse of each other. for example  the constituents relationship existing between the nodes and their hardware constituents is represented by a relation from the node class to the node constituent classes  this relation is called has-constituents  and by the inverse relation from the node constituent classes to the node class  it is called is-constituent-of .  as explained below  in dantes  network component types are represented by classes.  
　both relations modelling a relationship are defined together by a single class belonging to the network-relation representation cluster. a network-relation class definition involves the specification of the network component classes linked by the two defined relations. for example  to represent the constituents relationship  a class constituents will be defined. it describes both has-constituents and isconstituent-ofrelations and specifies the network component classes  nodes ...  linked by these relations. 
network-component 
　each network component type is represented by a class belonging to the network-component rc. 
　the name of a component type and the possible superclasses specification constitute the first two arguments of a network-component class definition. afterwards  class and instance variables  with their possible annotations  can be declared. finally  the relations linking the defined component class to other ones must be expressed and some behaviours can be specified. 
　let us consider nodes as an example. each node has an identifier  which is represented by an instance variable like all network component individual properties. a node is interlinked to its hardware constituents by the constituents relationship  represented by the has-constituents relation . moreover  it is linked to some peripheral processors by a relationship represented by the linked-to relation. the specific behaviours associated to a node are the following: a status variation of a node influences the status of the peripheral processors connected to it and the node can record deductions about itself and its hardware constituents. 
the dantes definition of the node class is as follows: 
 define 	network-component 
	node 	; component name 
  identifier type symbol   
;; instance variables  identifier has the symbol type 
 backbone-object  
;; superclass from which node inherits relations 
;; node relationships with other component types 
  has-constituents type  or memory bus control-processor line-processor   
;; node has a has-constituents relation with 
;; these network component types 
 linked-to type peripheral-processors   
;; node has a linked-to relation with its 
;; connected peripheral processors 
	:behaviours 	; node specific behavburs 
  update-peripheral-processors-status  
 record-deduction     
　note that the behaviours attached to a network-component class  such as update-peripheral-processors-status and recorddeduction  must have been predefined. they belong to the behaviour rc also defined in dantes  but not detailled in this paper. 
　the class definition mechanism associated with the network-component rc handles a series of actions including the definition of a class in the underlying object-oriented system  the attachment of the declared behaviours to this class and the implementation of the specified relations. moreover  it automatically builds the retrieval mechanism that will be used to access specific components in the network configuration. indeed  the relations specified in each component class definition are used by the class definition mechanism to generate all the possible paths existing between components classes.  a path links two component classes; it is a sequence of relations that must be applied to an object of the first class to access an object of the second class.  by interpreting each network component class definition  the network-component class definition mechanism progressively builds a precompiled access graph  linking all the component classes by all possible paths existing between them. this access graph allows a very fast retrieval  in the network configuration  of any component object accessible from a given one and satisfying some given conditions. 
　the class instantiation mechanism provided by the network-component rc specifies the arguments of the network component creation form: 
- the network-component class that must be instantiated; 
- the values of the component individual properties; 
- the specification of the network component objects that are linked by some relation with the network component object being created. if some specified component does not exist  it is automatically created. 
　the following form creates a node with a line-processor as constituent: 
 create 	'network-component 'node .'identifier 'detroit 
:has-constituents ' line-processor :id 1   
　note that the inverse relations linking existing component objects to the new one are automatically updated. the network configuration is generated from a series of such create forms.  in practice  these create forms are automatically generated from the codified network description available in each network environment.  
1 network events 
network events are byte strings  called event strings  issued by some network components and received by dantes. such events trigger dantes' reasoning process. event strings have various formats depending on the kind of event they represent. for each format of event string  there is a well known splitting of the string into various fields. the value of some of these fields determines the specific event type to which the event suing corresponds. 
　as for network component types  network events types are represented by classes. these classes are naturally organized into a tree. they belong to the network-event rc. 
the main problem with network events is their creation. 
dantes indeed receives a byte string from the controlled network and must transform this string into an event object that the reasoning process will be able to treat. as a consequence  the transformation process must determine the network event type  more precisely the network event class  corresponding to the incoming event. 
　in the previous version of dantes  the transformation process was implemented explicitly for a specific set of received event strings and a specific tree of event types. its code explicitly involved conditions on the received strings and referred to the event types. it was thus totally dependent on the particular controlled network. the code had to be rewritten for each network. moreover  it had to be updated whenever the event siring formats were changed or a new event type was considered. 
　to solve these problems  the present network-event class definition formalism allows to declaratively express the information needed to generate automatically the transformation process. this information consists of a named-fields property and a discrimination-condition property. 
　the named-fields property allows to associate symbolic names to some fields of the event string  i.e. to some substrings of the event string. 
　the discrimination-condition associated with an event type et is a condition defined on the event string. if a received event string does not verify this condition  it certainly does not correspond to an event of type et. otherwise the subtypes of et are recursively checked. the process ends when a leaf of the event type tree is reached and all encountered discrimination-conditions are satisfied: the event type corresponding to the received event string has been found.  note that backtracking takes place when the process reaches an event type with unsatisfiable 
discrimination-condition.  
　for example  consider that network events belong to two large categories  each having its own format: the backboneevents and the peripheral-events  which respectively begin with the character n or p. the definition of the corresponding classes can be: 
 define network-event 
	backbone-event 	; event name 
	1 	; no instance variable 
	1 	; no superclass 
:named-fields 
  event-category  first-character *event-string*    
;; the symbol event-category is bound with the 
;; first character of the event string  stored in 
;; global variable *event-string*  
:discrimination-condition 
 equal event-category  n   
;; to correspond to a backbone-event  the event 
;; string must begin with n 
:behaviours   frequency-analysis     
;; frequency analysis can be made on backbone 
;; events 
 define network-event peripheral-event ; event name 1 ; no instance variable 1 ; no superclass :named-fields 
  event-category  first-character *event-string*    
;; to correspond to a peripheral-event  the event 
;; string must begin with p 
.'discrimination-condition 
 equal event-category  p     
　from the definition of all event classes and especially from the named-fields and discrimination-condition declarations  the class definition mechanism associated with the network-event rc automatically builds a very efficient transformation process. this process is specifically suited to the various formats of the received event strings and to the defined event classes. therefore  adding or removing event classes or changing the format of event strings only requires to change the declarative representation of events  changing named-fields and/or discrimination-condition properties  defining new event classes or removing obsolete ones . the automatic generation of the transformation process relieves the knowledge engineer from any further programming and removes the need to write any code specifically bound to the event formats of the specific network. furthermore  it is worth noticing that both properties used for this automatic generation are natural and intrinsic properties of events. 
1 discussion 
1 advantages of the representation cluster approach 
the examples of section 1 show very clearly the advantages of an object-oriented system involving the representation cluster concept 
　first of all  such a system preserves the well-known qualities of an object-oriented approach for model-based applications. 
　furthermore  it suppresses the major drawbacks of objectoriented systems concerning their lack of high expressive power. representation clusters indeed allow to dedicate a high-level specific formalism to each kind of knowledge. these dedicated formalisms allow to express knowledge in a natural way  providing adequate levels of abstraction for modelling  sub-  domains. the intrinsic properties that characterize the represented knowledge are direcdy expressed in the formalism and no longer dispersed in object-oriented features like variables  methods  mixins and so on. this drastically increases the knowledge base readability. moreover  such dedicated formalisms enable to privilege the important concepts of a kind of knowledge. 
　the interpretation function of these formalisms can avoid a lot of programming effort by automatically generating functions and methods to be used for the treatment of the represented knowledge. this considerably clarifies the knowledge representation system. indeed  as soon as the relevant information about the domain has been expressed  all that can be derived from this information is automatically generated. this makes knowledge bases much easier to maintain. 
　another point to stress is that all the formalisms of the representation system can provide the same class definition or creation framework and therefore can present a clean uniformity of style. for example  in doos  it is very easy to adopt a sound convention for the order of the define and create arguments. if such conventions are established  the various kinds of knowledge of a domain will be expressed in a uniform style but with their specific characteristics. 
　finally  the representation system resulting from the various formalisms is very adaptative. if a formalism does 
　
tools 
　
not fit exactly the requirements of the knowledge to which it is dedicated  one simply needs to modify the class definition 
　
or creation mechanism of the corresponding representation cluster. 
1 relationships with other concepts 
it is worth noticing that metaclasses and rcs are quite different. they lie in two different conceptual levels  respectively the object-oriented system  oos  level and the knowledge representation  kr  level. metaclasses are oos classes whose instances are oos classes  introducing an additional repetitive layer of classes and objects. they allow to treat everything  at the object-oriented system level  as an object. now  rcs are introduced to provide an abstraction layer on top of the object-oriented system. futhermore rcs allow to customize object-oriented knowledge representation formalisms to various kinds of knowledge. they group knowledge representation classes and not classes of the underlying object-oriented system. a kr class does not exist by itself in the underlying object-oriented system but corresponds to several features of this object-oriented system  classes  methods ...  and  why not  metaclasses . 
　it is also interesting to position our approach with respect to clos  common lisp object system   bobrow et al  1   clos does not yet provide a standard for metaclasses and metaobjects. however the trends have been described in 
 bobrow and kiczales  1 . according to these trends  the clos interpreter is metacircular  i.e. the clos 
implementation can be viewed as an object-oriented program which is itself written in clos. this lets users extent or modify the standard interpreter behaviour by redefining some protocols  i.e.  some sets of generic functions . typically what can be customized is the inheritance mechanism  the allocation and slots access of instances  the updating of subclasses when a class has been modified  and the method combination mechanism. all these features concern internal properties of objects and classes; they stand in the object and class world. they do not concern the formalisms used to define or instantiate classes. in clos  these formalisms seem to have been predefined once and for all. therefore the purposes of representation cluster and clos metaobject concepts are fundamentally different 
1 conclusion 
this paper presented the representation cluster concept. 
each rc is composed of a class definition and a class instantiation mechanism that can be customized to the different kinds of knowledge a knowledge-based system has to deal with. these mechanisms allow to define and instantiate classes using formalisms that are exactly adapted to the particularities and intrinsic properties of the represented knowledge. this approach helps solving the major problems of the object-oriented systems coming from their low level of abstraction and uniformity of expression. its advantages are: 
- it preserves the well-known advantages of the objectoriented systems; 
- it allows to express knowledge in a high-level natural way  which facilitates the development and maintenance of knowledge-based systems; 
- it relieves knowledge base developers from a tangible amount of programming. 
　doos implements the rc concept upon an underlying object-oriented system based on flavors. it has been used to develop the dantes knowledge representation system tailored to the network troubleshooting domain. however  the rc feature could be added to most object-oriented systems: to implement it  the user simply needs to rely on the features provided by his object-oriented system. 
acknowledgements 
we are very grateful to suzanne galand and pierre-joseph gailly for their helpful comments on drafts of this paper. we also thank the anonymous referees for their remarks. 
