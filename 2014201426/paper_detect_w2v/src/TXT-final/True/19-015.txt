: an augmented and/or tree representation of logic programs is presented as the basis for an advanced graphical tracing and debugging facility for prolog. tpm can be run in slow-motion/close-up mode for novices or high-speed/longdistance mode for experts with no attendant conceptual change. moreover  it deals correctly both with clause head matching and with the cut. the current implementation runs on apollo workstations  and is written in prolog. 
1 	introduction 
in  eisenstadt  1  we developed a model of prolog execution which gave detailed symptomatic information so that either the programmer could home in directly on trouble spots or else a supervisory program could detect characteristic 'symptom clusters' in order to spot bugs. the current effort is an attempt to provide a significant boost to the practical debugging of very large programs by highly experienced prolog programmers  while maintaining conceptual clarity for novices. the underlying philosophy of 'retrospective zooming' still applies  but now we include the modern graphical techniques which the earlier work only hinted at. 
section 1 describes the underlying principles involved in the design and development of our view of prolog execution  which we dub the transparent prolog machine'  tpm . details of the running user environment are presented in section 1  followed by a worked example in section 1. the account which follows assumes that the reader is an experienced prolog user. augmentation  here dubbed the 'aorta'  'and/or tree  augmented'  diagram  is the focal point of our graphical debugger. tpm allows both a long-distance view of execution  displaying several thousand nodes and highlighting 'points of interest' at the user's request  and a close-up view  using all of the detailed notation of aorta diagrams. 
to illustrate the close up view  the program below is contrived to use a large number of aorta diagram features in a small space. 
party x :- happy x   birthday x . %party if happy & birthday party x :- friends x y   sad y . % or to cheer up sad friend 
happy x :- hot  humid  !  swimming x . happy x :- cloudy  watchingtv x . happy x :- cloudy  having fun x . 
cloudy  humid  hot. having fun tom . having fun sam . swimming john . swimming sam . watching tv john . sad bill . sad sam . birthday tom . birthday sam . 
friends  torn john . friends  torn sum . 
if 1 pose the query  - party name   the above program succeeds with the instantiation name = sam. figure 1 shows the aorta diagram corresponding to the final snapshot of execution. 
circular nodes are used to depict system primitives  there is one  the cut  in figure 1 . the large rectangular boxes in figure 1 are called procedure status boxes. the top half of such boxes shows the status of the goal at the time of viewing. a question mark indicates a pending goal; a tick  'check'  indicates a successful goal; a cross indicates a failed goal; a tick/cross combination indicates an initial success followed by subsequent failure on backtracking. the lower half of the procedure status box indicates the number of the latest matching clause head. thus  in the case of the goal party the tick in the top half of the box indicates that the goal was successful  and the number 1 below it tells us that was the second clause which succeeded. the small vertical lines dangling beneath each procedure status box are known as 'clause branches'  and the square boxes at the end of such lines are 'clause status boxes'. such boxes use the same question-mark  tick  cross  and tick/cross combination to depict the status of individual clauses. if a given clause head does not unify  then a short horizontal 'dead-end' bar is added instead of a clause status box  examples may be seen under the procedure status boxes for sad and birthday in figure 1 . clause branches correspond to 'or' choices  but are drawn differently from their traditional counterparts in order to make the processing of individual clauses obvious at a glance. we use a family metaphor to describe the lineage of goals. in figure 1  happy and birthday are sisters  and their mother is party. subgoals friends and sad are sisters of one another  but they have a different lineage from that of happy and birthday. we can model this relationship by attributing different paternity to each different clause. in other words  clause heads ci and c1  labelled purely for the reader's convenience in figure 1  represent different fathers for the different groups of children. thus  c1 is a step-fat her of birthday  and birthday and friends are step-sisters. to reflect the chronology of execution  we also note that happy is an older sister of birthday  and c1 is & future stepfather of birthday. the family metaphor enables us to provide a concise definition of the behaviour of the cut: it freezes older sister goals and their descendants  eliminates future step-fathers  and then succeeds. 
returning to our party example  we can see that happy succeeded initially on clause 1  but unification with either clause of birthday was not possible. this failure caused the backtracking into swim  which itself failed upon backtracking  no further clauses to attempt   as indicated by the tick/cross combination appearing in the top of its status box. this is also the case with the ! goal. notice the frozen cloud around the cut's older sisters hot and humid and the hashing showing the elimination of the cut's future step-fathers under the procedure status box of the parent goal happy. the parent's failure is further indicated by the tick/cross in the top part of its status box. the failure of clause one of party leads to clause two being attempted. the friends goal succeeds on clause one  i.e. friends tom  john   but sad john  fails. this time friends succeeds on the second clause  namely friends  torn  sam   and a brand new invocation of the sad goal occurs. to indicate that there are one or more previous invocations of a goal at the same point in the search space  a dark-shaded ghost status box is drawn. this ghost status box is selectable by the user as a way to observe the state of execution at a particular moment. 
to illustrate unification  the relations and arguments next to the top half of each procedure status box depict the state of play when the goal was invoked  whereas the relations and arguments next to the bottom half of each procedure status box depict the matching clause head found in the data base. userchosen variable names are subscripted automatically to indicate renamed variables. the diagrams use a sideways '=' with arrowheads to show unification. up arrows indicate output 
1 	architectures and languages 
variables; down arrows indicate input variables. right-angled arrows indicate a variable 'passed across' or shared with a sister goal. headless arrows indicate directly-matching terms. often there is a direct visual correspondence between a variable and the arrow showing its instantiation in the diagram  e.g. sam is directly beneath y1 in its first occurrence next to the status box for friends . whenever the correspondence is 'indirect'  i.e. the instantiation has come 'from elsewhere'  we place a small lozenge beneath the variable to show its instantiation at the moment of the aorta 'snapshot'  e.g. sam is in the lozenge underneath y1 in its second occurrence next to the status box for 
sad . notice in figure 1 that x1 is instantiated to torn  y1 is instantiated to sam and that this instantiation is passed to the goal sad. the goal sad y1   with y1 instantiated to sam  matches directly against the fact sad sam  in the database. 
1 ldv: the long distance view 
the long distance view  ldv  is designed to allow the user to retrospectively analyse the global behaviour of very large programs. it shows the execution space of the program  as opposed to the full search space  and the final outcome of attempted goals. this is done by means of a schematized and/or tree in which individual nodes summarize the outcome of a call to a particular procedure. each node is actually a collapsed 'procedure status box'  showing just the top half of the procedure status box as introduced above. powerful gestalt effects are possible even in very long-distance views of large trees  because familiar 'clusters' of nodes are easy to spot  particularly for someone who has been developing the associated code over a period of days  and has become accustomed to the repetition of certain familiar shapes. potential items of interest can  of course  be inspected more closely  even while preserving a considerable degree of surrounding context. in section 1 we describe our 'selective highlighting' facility which enables the programmer to 'light up'  by blinking or changing the colour of  nodes in the tree which satisfy some particular constraint or behavioural description. 
the ldv automatically incorporates certain convenient abstractions for simplifying the display. these abstractions are based upon the concept of a shallow cliche  which is a segment of code that can be statically analysed to reveal a characteristic shape or characteristic behaviour. the most prominent shallow cliche  and the only one we deal with at the moment  is tail recursion. the ldv depicts tail recursion by showing only the first two and last two calls  using the equivalent of 'ellipsis dots' in the diagram for all the intervening calls. the intervening call details may be 'opened up' for inspection by the user on request. 
1 a working environment 
1 the basic environment 
the user environment provides the user with access to the normal prolog interpreter/compiler via command line input as usual  but extends this by providing menu options to invoke the tpm trace package on a new query or trace a previously executed query. menu options are also present to support the highlighting and replay options outlined later in this section  as well as to alter the viewport onto  or scale of  the graphics trace in the graphics areas. the area displaying the graphics is mouse sensitive  and clicking on a ldv node produces a 1-ply aorta diagram with that node at the centre. ghost status boxes or clause status boxes can also be interrogated via the mouse. the interface provides help documentation for each option associated with a particular mouse button. 

1 selective highlighting 
frequently a user will wish to ask queries of the form 'where did x get instantiated to  a  b ' or 'where in the program does foo get invoked by bar'. to address this problem we provide a selective highlighting option in the ldv display. this option allows the user to specify a search 'form' corresponding to the following template: 
goal: functor arguments parent: functor arguments 
constraint: term 
	1 before 	1 first 	1 success 
	1 after 	1 latest 	1 failure 
for example  we can request the highlighting of all occurrences of the principal functor foo with a second argument instantiated to the list  bar  called by the mother goal gawp. the arguments of gawp need not be specified  even the functor foo need not be specified . the constraint pan of the search form allows us for example to highlight all occurrences of the principal functor foo with a second argument instantiated to some list  indicated by a meta-variable such as l  with the added constraint that the length of l be less man 1. the result of such requests will be for tntspecified items to be highlighted wherever this combination occurs in the ldv. this facility allows for rapid location and tracing of given functors or variables. it also allows the user to effectively spy a variable or a particular variable instantiation and observe its behaviour retrospectively in the trace. 
1 replay 
one of the major problems in telling the story of a program's execution is explaining re-instantiation of variables  multiple successes or failures  and other facets of backtracking. we deal with this problem by providing a replay facility whereby the usei can see the dynamic execution of the program through the ldv execution space or aorta diagrams  clearly indicating failure and subsequent backtracking  re-attempting of goals  subsequent failure  resatisfaction or retries. the replay facility thus allows the user to view the execution space at any given time  or at any particular goal invocation. the user can control the speed of the replay with slow motion and single step options being available. 
our replay capability is possible only because we store an exhaustive history of the program's execution. it is our belief that the rewards offered in terms of rapid debugging easily outweigh the overheads of history preservation  particularly in modern  cheap-memory  computing environments. nontermination however must clearly be avoided e.g. by interpreter stack monitoring a la shapiro  1 . 
just before replay begins  i.e. following a selective highlighting choice or a request to replay from the beginninc   the ldv is 'wound back' to the user-selected point. the interesting thing about the ldv at this point is that it shows a 'pre-ordained' search space  i.e. the ldv shows nodes in the tree which tpm guarantees will eventually form part of the execution space  but which at the moment of replay have yet to be traversed. 
1 zooming 
zooming allows the user to see a close up aorta view of any node chosen from the ldv. since zooming and highlighting requests always begin with the ldv  all the perspective information associated with the ldv is available at the point of choice  allowing the user clearly to understand the context of the code which is being observed 'close up'. this approach removes the 'forest-vs.-trees' problem associated with conventional 'spy' packages. in such packages  once a spied' goal is reached it may no longer be clear how you arrived there  how the instantiations of the variables have been derived  what state the program is in  what side-effects have taken place  whether the program has only reached this point on backtracking  and  if a 'redo' is involved  the nature  cause  and scope of the backtracking involved. 
1 a worked example 
consider the following scenario: a pre-stored database describes the contents of a warehouse  giving the reference number  order number  item  price  and quantity  all referenced in terms of the supplier. the database looks like the following: jones 1 llla tyres 1 1 . 
jacks  1 pumps 1 1 . jacks 1a wheels 1 1 . 
smiths  1 hubcaps 1 1 . 
now suppose that since the original was drawn up  things like the old reference number  price  and quantity in stock have changed. what we wish now to do is to take items which are currently in stock and check them with the old database  compiling a new database of items and suppliers. if an item is new  i.e. not in the old database  then the program will warn us that a new item is encountered and return the list of known items so far processed. items that are included in the new database already are ignored. here is the relevant  buggy  program: 
search jjb  x|t   x|tsl :jones     x        store jones x   search db t ts . 
search db  x|tl  x|ts  :jacks     x       store jacks x   search db t ts . 
search db  x|t   x|ts  :smiths     xs        store smiths xs   search db t ts . 
search db u u : 
     nl write 'ah items are known'  nl. search db lx|j n :write 'list contains unknown item: '   write x  ni. 
store manu item :manufacturer manu item . 
store manujtem :assert manufacturer manu item  . 
given the query 
 - search db ltyres wheels hubcaps  p . 
the program appears to be working correctly  and the following new facts are asserted: 
manufacturer jones tyres . manufacturer jacks wheels . 
manufacturer smiths hubcaps . 
now  if we present it with the query 
        - search db  tyres wheels hubcap  p . we expect the program to print out 'list contains unknown item: hubcap'  and return with the truncated list p= tyres wheels . unexpectedly  however  the query succeeds with p= tyres wheels hubcap . that is  the program claims to know all the items  instead of reporting that it contained an unknown item  namely hubcap. if we ask for an 
	eisenatadt and brayahaw 	1 

figure 1 ldv of  - search db ityres wheels hubcap   p   which unexpectedly succeeded. the goal searchdb with first argument  hubcapl 1 is highlighted. 
ldv of the execution space we will get the diagram depicted in figure 1  but without the highlighting . since we are interested in what happened when search db came to deal with hubcap we can use the selective highlighting facility to show us where in the tree searchjib gets called with first argument instantiated to  hubcapl  . figure 1 shows the result of our highlighting request. 
having located this node we can ask tpm to zoom in on the goal. as figure 1 shows  this gives us a three ply 'aorta' view of the goal  with the chosen goal in the middle. 
from the aorta diagram we can see that its behaviour prior to reaching the chosen goal was entirely as predicted. once entered it tries to attempt jones     hubcapv  j via clause one and fails. it then attempts to do the same thing  via clause two  for jacks     hubcap      with similar results. this is what is expected however we can see at a glance that smiths     xs      succeeds with xs=hubcaps  the first item in the  database. this is clearly not what was meant to happen! the program should have tried to prove smiths     hubcap      but was accidentally called with the uninstantiated variable xs as its third argument. this argument subsequently got instantiated by unification with the first fact found for smiths  namely smiths     hubcaps       . note the arrows and lozenges indicating dataflow and variable instantiation in the three selected clauses. this selection was done by the user clicking on a status box leading to the status box 'opening up' to reveal the extra unification information. the correct code for clause 1 of searchdb is shown below: 
search db  x|tl fx|tsj :smiths     x       store verb x   search db t ts . 
given the changed code  the call to smiths will now be smiths       hubcap       which will  correctly  fail. tpm was in error here contained all the variables twice. indeed the pattern of their occurrence was entirely plausible  since smiths may have used an output variable which was to be dealt with by store if the program semantics were different. either way the aorta will show clearly the behaviour of the program. more detailed worked examples  including the replay facility run on a simple compiler  and a discussion of the relationship between tpm and declarative debugging  are presented in  eisenstadt and brayshaw  1 . 
1 conclusions 
our aim has been to reconcile a global view of prolog program execution with the 'truth' about unification and clause selection. the key ingredients of our approach have been  i  appreciation of the power of gestalt patterns   ii  recognition of the need  and the ability  to display thousands of nodes at a time   iii  enhancement of traditional and/or tree branches with individual clause details   iv  enhancement of and/or tree nodes with goal 'status boxes' and  v  ability to vary the type of detail being investigated with the particular grain size  rather than using a physical 'zoom'. these ingredients combine to yield an environment which is suitable both for teaching introductory prolog programming and for assisting the day-to-day efforts of highly experienced prolog programmers. 
1 