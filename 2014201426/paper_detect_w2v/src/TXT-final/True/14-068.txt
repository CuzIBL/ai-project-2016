 
     brand x is a simple representation language implemented as a pure extension of lisp. brand x provides the following additional facilities over lisp: unique and canonical structures  property lists for all objects  labels for all objects  and a syntax to express each of these  supported by a reader and printer. brand x is intended as an  assembly language  for representation languages  attempting to provide facilities generally found useful in the simplest manner  without any strong commitment to specific representational conventions. the fundamental ideas of the language are described  an overview of its features and notation is given  and some inherent problems of implementation and semantics are presented. 
introduction 
     the past decade has seen the introduction of numerous programming languages and representational languages specifically intended for use by the ai community. the early seventies saw the introduction of languages  e.g.  
planner. conniver. q 1  which incorporated higher level data structures  novel invocation and control structures  context mechanisms  and rule-like representations of knowledge  1. 1. 1 . later research  focusing on problems of the meaning of representations  has led to a new group of languages  e.g.  rri . fri . ri /one   emphasizing the structure of representations  multiple descriptions and viewpoints   frame-like  systems  and procedural attachment 
|1  1. 1  despite the promise and even popularity of these languages  most ai programs continue to be written in that robust standby which precedes the above by at least a decade  lisp. 
     the attraction of lisp continues to be its great simplicity and mutability  allowing any user to build features of more power and incorporate them within the language the contrasting weakness of each of the above-mentioned languages is that they make representational and control commitments which  although appropriate to some applications which guided the development of the language  later appear arbitrary or wrong for other potential uses. to successive generations of ai researchers  it continues to seem more attractive to implement their own language extensions on top of lisp than to accept a complete package of conventions provided  or imposed  by the more recent language designers however  some generality docs exist among the facilities that have been repeatedly invented-roughly corresponding to the notion of semantic networks  if only as a medium of implementing frame systems or indexing structures for logic or production-rule based inference programs. it is obviously desirable to provide as powerful a set of support facilities as possible  without overstepping the bounds of commitment which may make the resulting language unacceptable. 
     our interest in extending lisp arises from our recent experience in building large ai programs which represent knowledge in the form of semantic networks in addition to straightforward implementations of such data structures in terms of lisp symbols and property lists  we have also explored implementations built on discrimination networks of expressions . a uniform indexable data type similar to leaptriples  and several generations of representation languages embedded within lisp  1. 1 . 
     a useful base language for implementing semantic networks must have facilities for creating  retrieving and manipulating nodes and links among them. we have found that a consistent set of extensions to lisp which support unique expressions and the ability to attach properties to any object serves us well without overcommitment to representational conventions which arc still  the proper subject of various research efforts. 
     brand x has been designed and implemented with the above observations as its guiding principle: it attempts to provide a commonly useful set of facilities but to avoid decisions about how any specific features of semantic networks should be represented. thus  it is meant to be an  assembly language  of representation languages  providing a bottom layer above lisp in terms of which other conventions will be defined and implemented 
     the recent lack of success of a second thread of development has also contributed to our desire to make brand x a simple extension to lisp rather than a self-contained programming language although many proposed ai languages suggest that procedures as well as data should be encoded within the language itself  often that course has not been adequately supported either the issues of how to represent procedures  and how to interpret them  have been put off  leaving the language dependent on its implementation environment  lisp  for procedural support  or a very complex interpreter has been created which has limited  if any  appeal to users other than the ones who developed the language as in the case of data structures mentioned above  the simplicity and power of lisp seem elusive to language builders. 
brand x's immediate predecessor is the xi ms language of hawkinson 
. which ha.s been used by the authors and their colleagues both as a data base and as the implementation medium of owi  1. 1  brand   was inspired by the observation that many of the facilities provided by xims appeared merely to duplicate features already adequately provided by msp. suggesting that its function could be gteatly simplified by implementing instead a limited  general set of extensions to usp. 
     in summary  then  we lake the following position: because lisp is so successful as a base language for ai research  try to build directly on it when creating higher-level representation languages in creating brand x. wc have chosen to add new data types and to extend the standard msp interpreter to exhibit some reasonable behavior for these types in all this  however  wc have tried to assure that all of lisp remains intact therefore. with virtually no exception  any valid lisp expression is a valid brand x expression  and its interpretation remains unchanged. 
     brand x is implemented as an extension of lisp  maclisp    and supports the following additional features: 
a. unique and canonical list structures- providing a data base facility in which expressions may be identical when composed of the same subexpressions  b universal property list.t-permitting the attachment of property/value pairs to any object in the language  
c 	labels-providing 	an abbreviation for convenient reference to complex expressions  
d. an extended lisp notation-allowing a convenient mechanism for reading and printing any lisp and brand x structures  
e 	triples-a special  compact data type having three components  especially 
for the support of owi . which is optionally present in the language. 
implementing semantic networks 
1      the authors are sometimes asked if they can explain in a simple way the advantage of implementing a semantic network in brand x over implementing it directly in lisp 'typically  a semantic network is a difficult data structure to read and print in lisp. it has backpointers which create circular structures. 
and it is so strongly interconnected that given any piece of it to print lisp punt functions often punt the whole network  in lisp the traditional way to meet these difficulties in lo make every node of the network an atomic symbol  with the network links on its property list. given an atom  lisp will print just us name  not tracing down the properly list  and thus not imping through the whole network. there are at least four difficulties with this solution. 
　　　first  the names of the network nodes are often not meaningful. especially if user programs create new network nodes  the nodes are typically given names such as g1. g1. etc these names do nothing to improve the intelligibility ol the semantic network nodes created by the user can of course be given readable  if long  hyphenated names such as lefttusk of-elephant-clyde-1. if such names are. however  uninterpreted by the system  as g1 must be   then the user has no assurance that the given node name actually represents what its name implies such assurance can be gained by explicitly checking that the relationships the node enters into are consistent with its name  but in that case the common information is redundantly stored in the network-once in the names and once in the links one possible solution occasionally proposed is to permit the system to extract that information from the node name when needed. because names encoded as lisp atomic symlx ls have no innate structute. this requires settling on a grammar of names and a parser for them- not an appealing strategy for the fundamental building blocks of a system in our view  the cncoding of some attributes ol a node in its name is quite appropriate; we depart from the solution criticized here chiefly in using innately structured objects for names. 
　　　second  because the standard lisp printer will print only the name of a node  the programmer must generally write a set of special purpose print lunctions lo print just those links which are desired such code must be carefully written to avoid printing semantic network loops. although special primers for displaying interesting portions of any large collection of interconnected objects will often prove necessary  we have found that the standard printing action for brand is often adequate and is certainly useful for browsing. 
　　　third  there is no declarative notation which the programmer can use to make the task of inputting a semantic network easy the programmer may again write special functions lot this purpose typically. the input notation as defined by these functions will differ from what is generated by the specialpurpose print functions thus  the application may lack lisp's useful ability to read back whatever can be printed finally  the atoms which represent nodes lake up quite a bit of memory space this space can be reduced somewhat if the atoms are not made unique in memory  but then one cannot refer lo a node by typing in its atom name. 
　　　in brand x. we provide the user with an alternative to using atoms for nodes and we deal with the above difficulties in a general manner the essence of the solution is to make it possible for data structures other than atoms to be unique and to have properties these then become an alternative to atomic symbols for representing nodes. a systematic approach to reading and printing all data structures is then provided. other features and conventions for building semantic networks may also be useful  but the authors do not want to be committed to them at the implementation language  brand x  level  1j. 
equality  identity  uniqueness  composed objects 
　　　if semantic network nodes are to be named by decomposable objects  we must have the ability to write the same name more than once-thus  the ability to compose objccls in unique ways. this desire leads to an analysis of the meaning of  same  and points lo a reasonable solution and some troubling puzzles. 
　　　the traditional definition of equality holds that two objects arc equal if they are indistinguishable by any known test in that case  of course  one may as well speak of just one object  although various paradoxes based on that interpretation have been suggested ' in compulation  however  the above definition of equality is not the one usually favored this is because computer models of the real would often permit tests of distinguishabilily which are artifacts of the implementation  typically  computer implementations can distinguish objccls based on then address in the memory of the computer; thus  two otherwise-equal objects may be distinguishable by being at different addresses for example  although we would like lo think of the two numbers 1 and 1 as equal  some lisp's implementations lind them distinguishable under the eq predicate  which tests equably of address. 
　　　one standard solution lo the undesirable nature of strict equality is to distinguish between identity-true indistinguishabilily-and equality-now taken to mean indistinguishable in the real world  even though distinguishable in the implementation  list's eq and equal predicates capture these notions of identity and equality  respectively.1 the distinction between identity and equality is important not only for very significant efficiency considerations. but also because the ability of programs to cause side-elfects permits them to distinguish among equal but non-identical  non-eq  objects. 
　　　a second standard solution is to adopt a convention and mechanism for uniqueness  in which objects intended to be equal are indeed made fq-i.e.. objects are made unique according to the equality criteria  so the system permits the existence of only the single unique representative of an  equivalence  class of equal objects. lisp's interning mechanism performs essentially this function for alomic symbols. this solution is motivated by the desire lo use eq as the standard equality test  for the reasons cited in the last paragraph the additional effort needed on input to create or find the unique object implied by the one actually input is more than rewarded by the possibility of efficient algorithms based on the assumption that some class of equal objects is indeed unique  eq   
　　　the case of lisp's handling of atomic symbols deserves investigation in its own right  as a guide to how interning is to be viewed in general. suppose we intend lisp's alomic symbols lo be the same whenever they are spelled the same then the desired equality test on lisp atomic symbols is samepnamep  which is true just if its two arguments arc atomic symbols which arc spelled identically. the lisp's reader  using the system-provided intern function  chooses a unique instance of all symbols with the same spelling and assures that that same instance is read each time a symbol of the same spelling is input.1 this assures that  ordinarily  all instances read of the same-spelled 
symbol are eq-thus  alomic symbols are unique. 
　　　lo understand how we might define uniqueness for composite objects  consider in detail the ideal nature of the ini e rn function  formally. intern ts a function which maps atomic symbols to atomic symbols such that its result is the representative of the equivalence class into which its argument falls when the set of alomic symbols is petitioned by the function samepnamep. if lisp's interned all atomic symbols  we would say that 
  atomic symbols are unique  with respect lo eq  under the predicate samepnamep. 
we lake all objects to have certain characteristics known as criterial. 
 these are the characteristics used by the partitioning predicate of an interning scheme for example  the spelling of an atomic symbol  the sequence of characters in its written form  is criteria!  but other characteristics such as its value  properties  and address are not. in the above interning scheme. 
　　　brand x introduces two new list data types with different criteria for uniqueness: ulists  unique lists  and clists  canonical lists . the fundamental interesting characteristics of these types are that: 
  ulists arc unique  with respect to eq  under the condition that their criteria! components  car and cdr  are identical  eq . and 
  clist's are unique  with respect to eq  under the condition that their criterial components  car and cdr  are equal  equal . of these types. clists are the easier to comprehend because they have the properly that  equal imp 1 i es eq.  any canonical combination of canonical objects yields another canonical object and eq tests are sufficient to determine equality. the other type. ulist. is one of a possibly large number of other useful types which partition the universe of expressions by a predicate stronger than eq bul weaker than equal. ulists are particularly useful for enabling the user to re-create the same  fq  structure on a second unique construction of the same pair of non-canonical objects. such an ability may not be very important  though it has been proposed for example as a way of associating values with previously evaluated expressions  global . brandx automatically 
creates canonical rather than unique structures when all components of the structure are canonical  and under the control of a flag may always construct canonical structures. 
　　　brand   also provides a new data type triple  and notions of uniqueness and canonicity for it a triple is a compound object with three 
1 

which could he created by evaluating the lisp's expression 
  lambda  x   rplacd  cdr x  x    list 'puzzle 'puzzle  . 
brand x provides the function canonical which  given any object as argument  returns its canonical representative.  it is the canonical version of iniern  what are we to expect if we hand p to canonical1 the result 
 let us call it pp  should clearly be a canonical list structure whose car and cadr arc both puzzle. whose cddr is eq to itself  and whose cdr is not. 
however.  cdr pp  should obviously be equal to pp itself  yet the two structures cannot be identical without doing violence to our intuition that the canonical form of a two-cycle should not be a one-cycle.1 
　　　the simplest solution to this puzzle is to claim that equal cannoi be applied to structures such as p or pp because lqual is defined as a recursive tree-comparison algorithm and is therefore inapplicable to circular structures. although this is- certainly true in use  e.g..  equal p  cdr p   will lead to looping . we feel that this begs the question-it reflects equals failure to capture our motion of equality rather than a true solution. 
a more attractive solution would be to follow the definition of 
canonical as the parallel of intern lisp's intern does not guarantee that only a single atom with the same name is ever created; it merely chooses one as the representative of the equivalence class and maps all others onto that we could act similarly in this case and sav that pp and  cdr pp  both fall into the same equivalence class and canonical chooses  say. pp as the representative then 
 canonical  cdr pp   -  pp 
this proposal has a grave problem  though the point of having canonical structures is to enable us to make use of the  equal implies eq  rule. yet now pp and  cdr pp  cannoi be eq. and mapping the latter onto the former by 
canonical is little or no help in the case of intern  the mapping onto the representative was useful because it was done consistently on input  by read  and because lisp does not ordinarily create non-interned atomic symbols. by contrast  simply taking the cdr of pp retrieves the non-canonical instance of pp the canonicalization could be performed at  run time  by requiring car and cdr to yield the canonical versions of components of canonical structures  but at a very high cost. 
     currently brand x   therefore adopts no solution-such circular structures cannot in general be made canonical1 the puzzle presented here  however  is interesting not only for its difficulties for brand x. we observe that no formal scheme can permit the specification of cyclic structures and also enforce * equal implies eq.  . 
brand x language overview 
     for a complete description of brand x. we refer the reader to the brand x manual . in this section we merely summarize the facilities provided for support of unique and canonical objects  for generalized properly lists  and 
for reading and printing. 
structure building  decomposition and testing 
     the fundamental construction operators of brand x are unique and canonical versions of lisp's cons utons and ccons for support of triples  the functions triple. utriple and ctriple serve the analogous purpose. car and cdr decompose lists. ultsts and clists. and ilk. tie and cue decompose all kinds of inples higher level constructor functions such as lisp's list and list* are also provided in unique and canonical versions. 
predicates to test an object for being of a particular type are also given; the general predicate brand-x-objectp yields the type  ulist. clist. triple. utriple. or ctriple  of any of the hkand x lypcs and nil for anything else. 
     an existing unique or canonical object may of course be found by simply re-creating it: ils uniqueness assures that no second copy is made. this technique cannot be used merely to discover if the object already exists  because it has the effect of creating it if it does not exist1 hkand x therefore provides a syntactic form. known  which causes its argument to be retrieved if already present but nil to be returned if the argument is not present. lisp's buckquote syntax 1 is especially useful in this application  allowing us to write  known   .a . b   to find out whether any unique list structure whose car is the value of a and whose cdr is b has been constructed. 
properties 
     brand x extends the lisp notion of properties to all objects of the language  including all maci isi* data types and other hkand x objects. thus. any object may ha e a property list  1  the functions git p. getpl. putp. remp. proplist. and setproplist arc extensions of and subsume the corresponding maclisp's functions get. getl. putprop. remprop. plist. and set plist'1 
     in addition to the above  we have also found it useful to support explicitly the manipulation of pmpcnics which have lists as their values. the functions addp and delp add and remove one value to or from a list of values on a ptoperty of any object new values arc added at the front of the list  and duplicates are deleted equality checking for duplicates and for deletion is bv lq. the motivation lot these functions is that we wanted to provide a syntax 
 see below  which allowed the expression of multiple values for properties such as daughters or characterization. 
     each call to ucok's. ccons. utriplf and ctriple causes the created cell to be added under the car-1  inverse car  property of its car  ilk. in the case of triples  this structure is necessary to maintain uniqueness and canomcity. and is also often useful for other indexing and searching applications. the function car-1 retrieves the list of objects so indexed under its argumenl 
l abels 
     any r r w d x object may be labeled. in a system in which names are typically constructcd by composition of other names  a facility for abbreviating names is essential to avoid printing an expression of size at least 1n for objects built by n compositions. by convention  labels are most often atomic symbols  although any object may label any other the assignment of labels is intended to be permanent  and numerous implementation problems result if labels are reassigned the relationship between a label and the object it labels is not to be viewed as the relationship between vanables and values. both the label and the object are read as the identical entity. 
     a label may be used in hkand x before the expression it labels has been defined  and an expression may also be used and later have a label assigned to it however  problems again arise if both the label and the expression are used before they are associated. 
unique and canonical 
     the functions unique and canonical arc provided to return the unique and canonical versions of their inputs. listed here are 
1. the brand x types to which each function applies. 
1 	the components of those types considered criteria! by the function. 
1. the equality predicate used on objects of that type  and 
1. a description of the resulting value returned by the function. 
unique 
atomic symbol 	print name 	same p name p 
1 atomic symbols are made unique by the list' primitive intern. the representative element of the equivalence class under same p name p is the first symbol seen with that name. 
number 	type and value 	equal 
numbers are interned by nintern  which uses a hashing scheme defined by brand x and also used by the property list mechanism. the representative is the first number of that type and value which is ninter ned. 
	list or ulist 	car and cor 	eq-parts 
yields the unique ulist  or clist if the components are canonical or the flag ccons is non-nil  formed of the car and cdr of the inpul if the input is a ulist  it is unchanged. if a list  its car and cdr are uconsed. the representative element cannot be eq the first list made unique because brandx implements lists and ulists as different lisp data types. 
	triple or utriple 	ilk  tie and cue eq-parts 
yields the unique utriple  or ctriple if the components are canonical or if the  lag ccons is non-nil  formed of the ilk  tie and cue of the input. if the input is a utriple  it is itself returned if it is a triple  its components are combined by utriple. 
clist or ctriple 	self 	eq 
clists and ctriples are innately unique because there is no mechanism for forming other copies of them -equal implies eq. 
other 	self 	eq 
hunks  arrays  and other usp data types are considered to be unique  forming singleton classes under the chosen equivalence relation. a relatively straightforward extension of the ideas used for the creation of unique list structure could also be applied to hunks and arrays  but this has not been done in nrand x. 
canonical 
atomic symbol 	print name 	samepnamep 
atomic symbols are made canonical by the usp primitive intern. the representative element of the equivalence class under samepnamep is the first symbol seen with that name. this is the same as under unique. 
	number 	type and value 	equal 
numbers are interned by nintern. which uses a hashing scheme defined by brand x and also used by the property list mechanism. the repre-
sentative is the first number of that type and value which is ninterned. 
this is the same as under unique. 
	list. ulist  or clist 	car and cdr 	tqual 
the canonical representative of any form of list is a ci. 1st. the canonical form of a clist is itself. that of a list or ulist is the ccons of the canonical versions of its car and cdr. note that this may require the complete copying of list or ulist structure into clist structure. clists are easily recognized in the implementation  so that equal tests can be performed by eq and canonicalization is trivial. 
triple  utriple or ctriple 	ilk. tie and cue equal 
the canonical representative of any form of triple is a ctriple. the canonical form of a ctriple is itself. that of a triple or utriple is the ctriple of the canonical versions of its ilk. tie and cue. 
note that  as for list structure  this may require the extensive copying of 
triple and utriple structures. equal tests on clists may also be performed by eq. 
other 	self 	eq 
hunks  arrays  and other lisp data types are considered to be canonical as well as unique  forming singleton classes under the chosen equivalence relations. a relatively straightforward extension of the ideas used for the creation of canonical list structure could also be applied to hunks and arrays  but this has not been done in rrand x. 
     the predicates uniquep and canonicalp test whether their arguments are unique and canonical respectively. the meaning of these predicates is that any object which passes one would itself be returned by the functions unique and canonical. internp and ninternp are special cases of these for atomic symbols and numbers. 
notation 
     one of the powerful simplicities of usp is that  on the whole  any object may be printed out in such a way that it can later be reconstituted by reading in that printed representation.1 this notion is preserved and extended to brand x objects. 
lists  ulists  and clists 
     our goal has been to preserve usp syntax as much as possible. therefore  lists and conses may be formed as in lisp: 
 reading  a . b  is equivalent to evaluating  cons 'a 'b  and reading  a b c  is equivalent to evaluating  list 'a 'b 'c . ulists and clists are written in a manner similar to lists  but with square brackets instead of parentheses. thus  reading  a . b  is equivalent to evaluating  ucons 'a 'b   and reading  a b c  is equivalent to evaluating  ulist  a 'b 'c . ulists. when they are composed of non-unique components  are shown in the appropriate mixture of parentheses and square brackets. thus  for example  reading  a   b     is equivalent to evaluating  ucons 'a '   b     . 
canonical structures must always be composed only of canonical substructures; thus  their printed representation is free of parentheses. in contrast with the above example  
	 ccons *a 	'   b     yields  a b . 
triples  utriples  and ctriples 
     in a manner analogous to lists  a notation is defined for triples. the fundamental triple notation looks like a list of three elements  the ilk  tie and cue. but with an asterisk between the ilk and tie. thus  
reading  a*b c  is equivalent to evaluating  triple *a 'b 'c . 
similarly  reading  a*b c  is equivalent to evaluating  utriple 'a 'b 'c   and ctriples are formed when each component of a utriple is canonical.1 
labels 
     labels are assigned by preceding the criteria! part of the expression by the label and the symbol ''= .  note that this is within the brackets delimiting the expression.  for example  
 an-example = this is an example  
assigns to the canonical four-list  this is an example  the label anexample. 
a label is used by prefixing it with an exclamation point in the syntax. 
thus  after the last example  
	 now . 	ian-example  
is entirely equivalent to 
 now this is an example   
and will be printed in the shorter form. 
properties 
     lisp does not provide any explicit syntax for the assignment or display of properties. in brand x. within the square brackets or parentheses used in writing an expression  the criteria  expression may be followed by any number of property assignment clauses. each is of the form: 
an ampersand  &   followed by the property indicator  followed by any number of values. 
the values are added  via addp  so that they appear in the order given in the syntax thus  if  ball 1  has no color property to begin with  then after 
　 ball 1 &.c1r reo green blue   we have 
 getp ' ball 1  'color  ＊   reo green blue . 
     to support effective optional cross-indexing in the data base  brand x permits the specification of both forward and reverse properties at the same time. to specify a reverse property link  follow the initial ampersand and property by a second ampersand and property  before the values. for example  after 
　 ball 1 &c1r &having-this-color red white   we have 
1 
	 getp 	' ball 1  	'color  -   red white   and 
	 getp 	'red 'having-this-color  =    ball 1     . 
     in lisp  an expression such as   . x  is syntactically invalid  as it appears to cons nothing onto x. in bkand x. however  we interpret that form as equivalent to just x.  this provides a syntactic means of attaching ptopertics  and labels as well  to any brand x object. for example  we use the following notation to attach possible-values lo color: 
	 . 	color &possible-values 
red orange yellow green blue indigo violet  
anaphora 
     we often find it convenient to refer to parts of an expression as that expression is being written. in specifying the representation of a frame in a semantic network  for example  wc may need to refer to the subject role of the frame in close proximity lo our specification of the expression representing the frame itself. for example  
 run into trouble &r1les 
 subject  run into trouble  
&c person   
lo indicate that run into trouble has a subject role and that whatever satisfies that role must also satisfy the characterization person. note that  after the above  
 getp ' run into trouble  'roles  yields 
  subject  run into trouble   . 
it is undesirable lo have to repeat the expression  run into trouble  each time a role of that frame is to be specified or referred to. instead  brand x allows us to write 
 run into trouble &r1les 
 subject : &c person    
which is read identically with the expanded form above. here  the colon  :  acts us an anaphor. referring to the criierial expression which is one level of parentheses or brackets out from the appearance of the colon. 
     brand x supports a general facility for anaphora  expressed via successive colons not separated by space. the number of colons specifies the number of levels of parentheses and brackets to move out to find the anaphor being referred to. for example  the  person : :  in 
 run into trouble &r1les 
 subject : &c  person : :       . 
stands for  person  run into trouble  . 
     spaces are normally insignificant in brand x except lo delimit atomic symbols. in the case of colon anaphora  however  spaces may not be placed between the colons. thus  in the above  if we had written 
 person : :  instead  it would have been read as 
 person  subject  run into trouble    subject  run into trouble   . 
     when writing non-unique list structure  the colon anaphor is not only a convenience but more essential  because rewriting an expression cannot create uniquely the same one as a previous instance. thus  if we wished to form a 
     structure like that of the simpler example above  but from non-unique lists  wc could write 
 run into trouble &r1les 
 subject : &c person    
which is not equivalent lo the fully written-out version 
 run into trouble &r1les 
 subject  run into trouble  &c person    
because the two expressions  run into trouble  are not eq in the second case. 
     anaphora provide a form of local labeling. they also permit the printing of circular structures  and are capable of extension to permit reading of all such structures as well.1 
syntax 
     to recapitulate the syntax of brand x formally  we present an extended bni description: 
 x-expr  ::＊  lisp-atom  |   x-expr-body   | 
  x-expr-body   |  1abel-spec  | 
 colon-anaphor  |  quoted-form  | 
 backquoted-form  |  comma-form  
 x-expr-body  : = { label.x-expr *}  criterial-expr  
{ prop-specs }* 
 criterial-expr  	::= 	{ x-expr }* {. x-expr } | 
 ilk :x-expr * tie: x-expr   cue:x-expr  
 nrop-spec  	: : * & prop:x-expr  	{&prop.x-expr } 
{ va/:x-expr }+ 
 label-spec  :: = ! x-expr  
 colon-anaphor  	::＊ 	{ : } + 
 quoted-form  	::  	' x-expr  
 backquoted-form  	::＊ * x-axpr  
 comma-form  	:* 	  x-expr  
in the above  we have used braces  { ... }  lo indicate optional phrases  and + as superscripts on optional phrases to indicate zero or more and one or more permitted repetitions  respectively. melasyniaclic variables are in angle brackets    ...   ; such a variable of the form  name:type  is an expressive variant of just  typc -thus.  prop:x-expr  is merely  x-expr  with a suggestion of its meaning as a properly descriptor. spaces arc not significant  except as separators and as noted above between successive colons in colon anaphors. note that although any x-cxpr is acceptable as a label  by convention we will use only atomic symbols. quotation is as in lisp  so that ' x is a convenient abbreviation of  quote x . 
     backquoted forms and comma forms require a little explanation because  although they arc commonly used in maclisp  they are not innately part of lisp. they provide a facility for abbreviating programs which are to construct structures of a particular form. for example  the form 
 a b  c  d   e  f g   is read as 
 list 	'a 'b  list 'c d  e 	' f g  . 
variable parts of such a structure are preceded by a comma. other parts are quoted if they are constants or formed up by the appropriate brand x operation. 
implementation 
     brand x is implemented in maclisp as a number of functions  hooks into the reader  printer and evaluator which are provided by the base language  and objects implemented as maclisp hunk structures. 
representation of objects and properties 
     unique and canonical lists and all triples are represented by maclisp object of type hunk 1. for list types  the car and cdr of the hunk are the car and cdr of the object  and a third component identifies the object as a 
brand x entity and holds its property list. for triples  the hunk contains the 
ilk  tie and cue of the triple as well as the component which identifies its type and holds its properly list. the ilk of a triple is the car of its hunk. this is the only storage structure decision allowed to be visible at the language level  because it allows efficient algorithms which use the car-1 function to retrieve unique or canonical objects whose car or ilk is the given object 
     ali unique and canonical objects are indexed under the car-1 property of their car or ilk; this is needed to enable brand x lo find such an object given its components. this indexing is not symmetrical between the car and cor; therefore  finding such an object among many with the same car is potentially costly. at the cost of additional overhead in storage  a cdr-1 property could also be maintained and the search could be optimized. there is also other independent motivation for that property  to permit a user-level cdr-1 function  but we have so far not been persuaded to pay the storage cost for its possible benefits label attachments arc recorded under the label and label-1 properties of the object and label  respectively. 
     unfortunately maclisp does not provide any way lo prevent the components of user-defined types from being examined and altered by the system's primitive functions. the integrity of a brand x data base can be seriously dis-

1 

rupted by indiscriminately applying operations such as rplaca and rplacd to unique or canonical structures. similarly  careless changing of the properties used by brand x can lead to trouble. were hrand x implemented in a strongly-typed language with good modularity and information-hiding practices  e.g.  clu  . these problems could be avoided. our planned implementation on the lisp machine will also be able to avoid them by similar means. 
     numbers arc made unique by a hashing scheme which uses maclisp's sxhash function. the hash table is also used to store the numbers' property lists. this method assures that equal numbers  which are not generally eq in maclisp  can share properties. the primitive type of the numbers matters  and the fixed number 1 is different from the floating number 1. 
     other non-atomic-symbol maclisp objects  including normal list structures  are associated with properties by another hashing scheme based on the object's address. only those objects arc in the table which have properties  and the storage cost here is minor. 
interactions with the lisp system 
     maclisp gives primitive support for user-defined extended data types built as hunks the lisp primitive functions eval  print. equal  subst and sxhash  when applied to a hunk which is identifiable as an instance of a user-defined extended data type  call a handler function instead of performing their normal action. this mechanism is used in brand x to permit a completely integrated use of brand x objects in lisp code and data. 
     the lisp printer has been augmented and put under the control of several flags. printing in lisp's read-eval-print loop uses a pretty-printer which displays not only a formatted version of the expression to be printed but also its label  if present  and its properties anaphora are also used to abbreviate printout and to print circular structures. 
     the lisp reader has been augmented by the definition of reader-macro functions for characters such as       and       which direct the parsing of input expressions as specified in the description of the notation  above. the primitive lisp reader continues to be used for reading symbols and numbers. implementation of the reader  especially because of difficult interactions between the use of anaphora and backquote. was especially difficult. indeed  although we have been able to identity algorithms lor reading at least noncanonical innately circular structures  we have not yet implemented them because of their difficulty. 
     in the course of developing brand x syntax  we have also designed a reader extension for maclisp to allow the mapping of different actual characters onto the virtual character set of the language. in these terms  hrand 
x expressions are read in terms of virtual characters such as beg in-unique list and property-indicator  which are mapped in the standard reader environment onto the characters       and '& . such a mechanism  called an ear afler a suggestion of gerald j. sussman. permits various lisp extension packages to be used together without causing syntactic conflicts; all that is required is to map the total set of logical characters needed in an application onto the available physical character set. this facility is being implemented by glenn burke both for maclisp and the lisp machine. 
evaluation 
what should it mean to evaluate  in the sense of lisp's eval  various 
brand x objects  by default  we treat evaluation of unique and canonical list structure just as if the lists were normal lisp lists. thus  evaluating the expression 
　 car  quote  a . b       is no different from evaluating 
 car  quote  a . b       
again by default  we say that eval cannot be applied to a triple; it yields an error. 
     our intent is that this hook into the action of lisp's evaluation mechanism should serve as the basis for a more sophisticated evaluator to work on declarative structures of greater complexity than lisp s-expressions. an experimental version of such an interpreter has been programmed by glenn burke.1 providing pattern-directed invocation of procedures by examining the database of methods. triples are used to express a hierarchic a-k-o structure in which methods for evaluation are inherited. more specific ideas on how such interpretation ought to be organized will be given elsewhere  1   and other interpreter implementations are planned. one important criterion of these is that they arc to interface consistently with lisp's normal action of evaluation-evaluating a simple lisp expression should be the same in hrand x as in lisp. 
another puzzle-with labels 
     included here is a short discussion of a number of problems which can arise in the use of labels. these problems arc not easily solved  and arc solved not at all or only badly by the current implementation of brand x. 
     the intent of a label is to be simply an abbreviation for the object it labels. if labels were used only afler the object they labeled was created  and if labels were never reassigned  then these problems would not arise. however  because of the possible need for mutual recursive reference in data structures  and because of the more frequent need lo refer to something in an interactive environment before having completely defined it. labels do get used before they arc assigned. the implemcntor of a system must choose some representation for an unassigned label and must decide how such an object can be used. one possible choice is lo ban all use of such objects  but this fails the criteria outlined above and is also difficult lo implement in a language like lisp  in which information hiding is impossible. another choice allows reference to these objects but not an examination of their components. this would permit the use of unassigned labels in constructing other objects  but would prohibit asking for. say  the car of such an object this is also impossible to implement in lisp  and any attempt to enforce such conventions systematically would be very expensive; many algorithms can be significantly speeded up if they need not handle a special case of unassigned labels because the implementor knows that the test already in use in  he algorithm will al..o succeed or fail appropriately for these. therefore  brand x permits the examination of the representation of unassigned labels  which have a standard internal structure. 
     however  the use of labels before they are assigned creates very serious problems: 
     if an object and an unassigned label are both used to construct other objects  and then if that label is assigned to that object  then there is in general no good way lo assure that all previous uses of the two will indeed refer lo the identical object. thus  formerly-made references lo the label will not be eq to formerly-made references to the object this could be fixed only by an elaborate indexing mechanism which keeps track of the use of all unassigned labels  or by an alternative mechanism which scans the entire data base for uses of the label  references lo its dummy object  and replaces them with the actual object. an alternative  possibly available on different computer architectures  would be to define eq to follow data indirections   hidden pointers   before making address comparison tests  but this is not generally feasible. this problem is easily avoided  as it is in the current hrand x implementation  if the label is unused before its assignment; then  the dummy object is never crealed. if the label has been used  but the object to which it is assigned has not yet been created  the problem is also avoidable if the object can be created  on top of the dummy object representing the label. this is done in the current brand x whenever it can be; it fails if the underlying lisp data types of the intended object and the dummy object are distinct-e.g.. if a formerly used dummy label  whose default is created as a ucons or utriple. with underlying lisp data type hunk1   is then assigned to a list. 
     canonicalizaiion of data structure can fail because some identity that depends on label assignment may not be known when it is computed. for example.  a b c  and  ccons 'a ' ifoo  may appear to have little in common; yet. if  b c  appears and  f1 = b c  is later done  the two expressions are seen lo be identical however  the second canonical structure was created before this was known  and cannot be simply made lo be eq lo the first the same problem also appeal's when labels are used as a mechanism for creating circular structures for instance  afler  f1 = bar .  foo   we have a new structure whose car is bar and whose cdr is itself. repealing this operation with different labels will create distinct such structures  although of course there should be only one because it is canonical. this is again the problem we have described in our earlier discussion of the puzzle of the canonicity of circular structures. 
1 

conclusion 
     we have described a limited set of extensions to lisp to support its use for implementing semantic networks. the principal features given in brand x are the ability to create unique and canonical list and triple structures  the availability of property lists on all objects  labeling of any object  reading and printing of objects and their properties  and the integration of brand x objects into the standard lisp environment so that they appear as first-class data types to the brand x user. 
     this package is available in the maclisp environment and will shortly be made available on the lisp machine. it is currently being used as the representation medium for an english query system eqs and several smaller projects of the authors and our colleagues. so far  it has satisfied its design mandate  to provide us a useful set of extensions to our favorite implementation language  lisp  without overcommitting us to decisions best left to a higher level of language design. 
acknowledgments 
     the authors would like to thank mr. glenn s. burke for his invaluable advice and programming help in the construction of brand x. especially in integrating it into the maclisp system. this research was supported  in part  by the national institutes of health grant no. 1 p1 lm 1 from the national library of medicine  and by the defense advanced research projects agency  dod  monitored by the office of naval research under 
contract no. n1-c-1l 
notes 
1 for example. black suggests  1  that we consider a universe consisting only of two indistinguishable balls in orbit about each other we have absolutely no features to tell  which ball is which.  yet wc would hesitate to claim that the two balls are the same 
1 roth are defined more technically  of course e1 is defined as identity of address  and equal is defined as a recursive test which checks for the identity of primitive 
onjects and me equality ot constituents of compound objects equal is further modified so that equality of numbers is tested by idenuty of type and numerical equality {x - y = 1  of the values. 
1 even this has exceptions  as usp's intern actually stores its representative instances in an oblist or obarray  of which multiple versions may be maintained in addition  some lisp functions can create atomic symbols without interning them to add to the possible confusion. usp's definition of equal unfortunately yields false when two symbols arc same pname p but not eq. 
1 b r a n d x exists in versions which either include or do not include support for triples such support may be omitted simply to save a small amount of the  virtual  memory space used by the system for large applications which do not require the type although this was initially an important design consideration for us. experience indicates that all significant applications use triples the remainder of this discussion will assume that they are present 
1 there is no reason why notions of uniqueness and canonicity could not be extended to these other structured objects as well  but this was deemed unnecessary and is not currently done the extension would be done in analogy with the definitions for list structure and triples  two- and three-element structures   although more efficient indexing schemes may be needed for larger structures. 
1 this issue is equivalent to the previously-cited question of whether two identical objects can even be spoken of as two objects there is almost a formal equivalence between this puzzle and the problem of the universe of two balls 
1 note that this applies only to structures which are circular in that they contain themselves as their own critenal parts circularity in the more conventional form of self or mutual reference by links is fully supported. 
1. this problem is familiar to all lisp users who have tried to tell whether an atomic symbol has already been interned; merely typing the symbol interns it 
1. see the later discussion of brand x syntax. a formal definition may be found in the lisp machine manual  1 . 
1 it might perhaps have been better to redefine the original functions and thus to avoid having both get and getp we decided  however  to leave the original functions unchanged so that users depending on their error detection capabilities would not be misled 
1 this is not completely true  as some data types  e.g. arrays in maclisp  have no printed representation  and furthermore  circular structures  those which include themselves as a part  cannot normally be printed 
1 note that in a brand x without triples  the asterisk has no special significance and. for example.  a*b c  would be read as a list of two atoms. a*b and c. 
1 the rationale for this is that maclisp's l i s t * function  which forms successive conscs of its arguments  eg..   l i s t * 'a b ' c  is equivalent to  cons 'a  cons 
1 
'b ' c   . which is of course  a b . c    yields just its single argument if given only one argument 
1 technically  the formation of truly circular expressions presents some difficulties more severe than those encountered in forming structures that arc circular through property attachments l o r example  in forming the structure  a  b :      whose cadadr is cq to itself   we appeal to need the whole structure before wc can form its substructure because of the difficulties noted earlier. brand x docs not now support an input syntax for circular structures of the kind in which an expression is its own subexpression if such an expression is formed  e.g. by rplaca   however  the printer will punt it with anaphora 
1 private communication 
