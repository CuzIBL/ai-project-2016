. r1 is a rule based program used by digital 
equipment corporation's manufacturing organization fc configuring vax 1 systems. since its inception. r1 has had the capability of producing a functional system by fleshing out an order consisting only of a cpu. some primary memory  and some devices; until recently  however  it was not capable of accepting as part of its input a set of ad hoc  customer specific  constraints left to itself  r1 was capable of producing reasonable configurations. but it was incapable of modifying its decisions on the basis of information that others could provide this paper describes how rules were added to r1 to take advantage of such information r1 can now accept as input commands that specify how particular components are to be configured whenever one of the commands becomes relevant  these rules take control  extend the configuration in the direction indicated by the command  and then step aside  allowing rt's ordinary-case configuration rules to regain control.1 
1. background 
　in december   1. we began v/ork on r1  a rule based program that configures vax 1 computer systems  mcdermott 1a  mcdermott 1bl. given a set of components  a customer's order . r1 produces diagrams specifying the spatial relationships among those components. if. while organizing the components  it finds that additional components are needed to construct a functional system  it adds those components. since january  1  r1 has been used by digital equipment corporation's manufacturing organization to configure almost all vax 1 systems shipped digital currently has a group of 1 people responsible for maintaining r1 and extending its capabilities. 
   the development of. r1 and xsel is being supported by digital equipment corporation the research that led to the development of ops1. the language in which rl and xsel are written  was sponsored by the defense advanced research projects agency  dod . arpa order no 1  and monitored by the 
air force avionics laboratory under contract f1 c 1 the views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies  either expressed or implied  of digital equipment corporation  the defense advanced research protects 
agency  or the us government vax 1 and unibus are trademarks of digital 
equipment corporation 
   r1 is implemented in ops1  a general purpose  rule-based language  forgy 1  forgy 1 . ops1 provides a rule memory  a global working memory  and an interpreter that tests the rules to determine which ones are satisfied by a set of the descriptions in working memory. a rule.is an if then statement consisting of a set of conditions  patterns that can be matched by the descriptions in working memory  and a set of actions that modify working memory on each cycle  the interpreter selects one of the satisfied rules and applies it. since applying a rule results in changes to working memory  different subsets of rules are satisfied on successive cycles. r1s knowledge of how to configure vax 1 systems consists of about 1 rules; each of these rules encapsulates one set of constraints on the way in which components can be associated. initially working memory contains just a list of the names of the components ordered. after a description of each of these components is retrieved from a data base. rl constructs a configuration by associating components in ways that satisfy the constraints held in the rules. r1 is recognition driven; that is  each of its rules recognizes a 
   different situation in which the creation or extension of a partial configuration is called for r1 does almost no backtracking because its knowledge is sufficient to lead it unerringly from the set of components ordered to an acceptable configuration. 
　xsel  a system that will complement r1  is currently under development at cmu  mcdermott 1 . xsel is a computer salespersons assistant; its function is to interact with a salesperson  or customer  to obtain the information required in order to tailor a system to fit the customer's needs. after obtaining this information from the customer  it selects a cpu  some amount of primary memory  some software  and whatever devices  eg   disk drives  tape drives  terminals  printers  the customer needs; this skeletal order is then passed to r1 to be fleshed out  with cabinets  boxes  backplanes  controllers  cables  etc   and configured. during the interaction with the customer  it may become evident that the particular needs of that customer imply special configuration constraints; in these cases xsel informs r1 of those constraints. 
　r1 was not designed*to take customer-specific constraints into account in configuring systems. therefore  for r1 to use the 
1 
information passed to it by xsel  a major modification to its approach to the configuration task was required the extended task imposes significant new demands: 
  customer-specific constraints must be viewed as refinements of rvs ordinary-case configuration constraints. 
  systems must sometimes be configured in the absence of customer-specific constraints. 
  customer specific constraints can affect most aspects of a system's configuration. 
in the absence of information about how a customer intends to use his system  the configuration task may be under-constrained; there may be a number of apparently equally acceptable ways in which the system can be configured. given some information about how the customer intends to use his system  some configurations become more acceptable than others  and occasionally configurations that appeared unacceptable become acceptable. thus customer-specific constraints must take precedence over the ordinary-case constraints. the uses a customer intends to make of his system sometimes imply no special constraints thus customer-specific constraints cannot be presupposed. finally  the needs of a customer may have implications for almost any aspect of the system configuration. thus no ordinary-case constraint knowledge is unaffected by customer specific constraints. 
　because the task of extending r1 to handle customer-specific constraints has implications for all of rvs knowledge  we considered redesigning r1. but that turned out not to be necessary. instead  we were able to develop a general ad hoc constraint-handling capability by augmenting r1 with a relatively small number of rules. the general problem we faced is that of transforming rule-based programs that are unable to take advice into programs that can use advice or do without it. the problem divided into two parts. most of rvs configuration capabilities have gone through a lengthy period of test and refinement; the knowledge it needs for these capabilities is now relatively complete. recently  however  r1 was augmented with a set of rules that enable it to do the floor layout task; this capability is just beginning to be tested and refined. in the next section of the paper  the ad hoc constraint-handling capability used by r1 for tasks in which it already has expertise will be described. section 1 will address the issues that arose in providing such a capability for the floor layout task. 
1. a superimposed ad hoc constrainthandling capability 
　rvs expertise in the configuration task has evolved gradually over a period of two years. its knowledge is now sufficient to enable it to produce an acceptable configuration in the absence of information about the intended uses of a system. thus our task was to preserve this expertise while at the same time modifying r1 so that it could benefit from the advice of experts who understand the special configuration constraints implied by particular applications. 
1. design considerations 
   in order to understand the problem of oroviding r1 with the capability of assimilating constraints on the fly  it is necessary to know something about the basic problem-solving method that r1 uses. the method used is a particularly powerful variety of heuristic search called match  newell 1 . when match can be used to solve a problem  a path from the initial state to a solution state ran be found without any backtracking. it follows that for match to be applicable  it must be possible to order the set of relevant decisions in such a way that no decision has to be made until the information sufficient for making it is available. it should be clear that for complex problems  in which much of the information required at any decision point will be available only after other decisions are made  the applicability of match rests entirely on whether it is possible to specify at each step what information is sufficient for that step. for most of the vax-1 configuration task  it is possible to provide such a specification. 
　r1 implements match by requiring that the conditions of each of its rules specify the conditions under which that rule can be safely applied; that is  no rule can be applied in a particular situation  or at a particular state  unless all the information needed to insure that it will extend the configuration in an acceptable way is present. a typical rule is satisfied if  1  an unconfigured component with a particular set of characteristics is in working memory  and  1  descriptions of partial configurations and/or other unconfigured components with particular characteristics are in working memory. when the rule is applied  it specifies how that unconfigured component is to be associated with one or more of the other components. 
   since each of rvs rules implicitly defines exactly the set of situations in which it can be applied  there are no necessary interdependencies among rvs rules. a rule that recognizes a situation as one it can deal with does not care how that situation came to be; it cares only that it has come to be. this suggests that all that is needed to implement an ad hoc constraint handling capability is a set of rules that  1  recognize when various types of customer-specific constraints have become relevant to the current state of the configuration and  1  step in to effect whatever extension or modification is called for. rvs other rules  since they are indifferent to the genealogy of a configuration  will simply treat these externally imposed changes as if they had been initiated by r1. the new rules are  of course  subject to the same requirement as rvs other rules: they have to define the conditions under which they can be safely applied. but this poses no serious problem since the new rules propagate constraints that tailor the configuration to the customer's needs  and thus the only issue is when they should be applied  not 
1 

whether they should be applied. 
　more specifically  the strategy we adopted was to leave untouched  for the most part  the rules comprising r1's basic configuration capability. this left r1 performing the configuration task  in the absence of customer specific constraints  in the same way it always hag  we simply added a set of rules tnat recognize situations in which some type of customer-specific constraint is present together with descriptions of components or partial configurations which indicate that it is time to attend to that customer-specific constraint. each of these rules modifies working memory elements in a way that insures the satisfaction of the customer-specific constraint. in a sense  these new rules are disassociated from the mainstream configuration task; they stand outside and allow customer-specific demands to step in  change the world to be the way the customer wants it  and then step back out and let r1 continue about its business. 
1. a language for communicating constraints 
　to understand the nature of the constraints that xsel might pass to r1  it is necessary to have a rough idea of the dimensions along which acceptable configurations can vary. there are four dimensions of primary interest. 
  the positions of controllers on buses. 
  the positions of backplanes in boxes or cabinets and the positions of boxes and panels in cabinets. 
  the distribution of devices among controllers 
  the types and lengths of cables used to connect pairs of devices 
along any of these dimensions  customer specific needs may dictate specific partial configurations or may simply indicate that the general configuration constraints should be made more or less restrictive. thus xsel must be able to tell r1  1  to configure a set of components in a particular way  and  1  to strengthen or relax particular constraints. 
　the language xsel uses to communicate with r1 consists of a small set of commands that give xsel control over the various aspects of the four dimensions listed above. r1 understands 1 commands. most of these commands enable xsel to specify how a particular component is to be associated with other components; the rest enable it to modify various restrictions that r1 ordinarily assumes. when xsel discovers a customerspecific constraint  it generates a command that tells r1 how to satisfy the constraint. when r1 is given a set of components to configure  any commands generated by xsel are passed to it as well. each command becomes a working memory element containing information that identifies the command as relevant to a particular set of components or to a particular restriction. 
　each of the commands that specifies how a component is to be associated with other components contains a descriptor that indicates the purpose of the command  and identities by name or by type the component it is concerned with. a variety of other information is contained in a command  all of which has the function of specifying the nature of the relationship between the component and other components. sometimes this information identifies a second component and describes precisely how the two components are to be associated  e.g.  the position of a backplane in a box  the location of a controller on a bus . in other cases  no other components are explicitly identified; the relationship of the component to other components is specified indirectly  e.g.  the position of a module relative to otner modules . each command that describes how r1 is to modify a restriction identifies the restriction to be changed and provides a redefinition of that restriction. 
the command that enables xsel to specify precisely where a 
unibus module is to be placed can be used to illustrate how customer-specific constraints and ordinary case constraints interact xsel generates this command when it knows either that the expected usage of some unibus device that a customer needs will vary from the normally expected usage  or when the customer will be adding modules to the system and wants to leave space for those modules on the unibus. the command identifies the module to be positioned by name; it specifies a slot number  a backplane position  a box. and a cabinet; it also indicates the amount of space that the module occupies to deal with this command. r1 has a number of rules that step in and nut of the regular configuration process at various points. ordinarily when configuring unibus modules  r1 first determines the optimal  normal usage  sequence for those modules and then attempts to place the modules in that sequence. the placement task involves selecting a module  a box  if there is more than one unibus   a backplane  on the basis of the backplane requirements of the module selected   and additional modules until the backplane is filled. there are rules at each of these points that take control away from the normal configuration process if working memory contains a command to position a unibus module in the box or backplane being filled before the modules are placed in an optimal sequence  r1 marks as not to be included in the optimal sequence each module wnose position has been specified by xsel. when selecting the box and module to configure next  a module specified to be placed in the next backplane position in a box will be selected in preference to the next module in the optimal sequence. when selecting a backplane for a module  r1 makes sure that the backplane selected is of the appropriate type and size. finally  in filling up a backplane  r1 places any other modules that it has been told to put in that backplane before placing the remaining modules. 
　the number of rules that had to be added to realize the ad hoc constraint-handling capability was quite small relative to the total number of rules. r1 has 1 rules that enable it to do all but the 
1 
floor layout task; of these  1 are rules which recognize commands generated by xsel. these rules essentially overlay rvs general configuration rules; they know how to modify partial configurations  or other data structures  in a way that changes the state out from under r1 without affecting rvs ability to recognize what action is appropriate next. this extension of r1 is perhaps as interesting in what it shows about the inherent robustness of the match method as it is as a capability in itself. a few  about 1  of rvs rules were changed in adding the new capability  but the changes were all in the direction of further specifying the conditions under which the old rules were applicable; that is  in a few cases  it was necessary to add a condition element to the old rules to give the new rules an opportunity to step in and take control  but essentially the old rules remained unchanged. 
　it should be noted that in the course of adding the capability  it became obvious that the idea of communicating by command could be exploited by r1 itself. in some cases  rvs processing provides it with information that constrains the configuration in some way before it is quite ready to use that information. the commands provide a convenient way of storing the information for subsequent use. for example  early in its processing r1 checks the baud rate of certain unibus modules to insure that total baud rate does not exceed the maximum permitted. if the maximum is exceeded *r1 marks the extra modules as not to be configured. however  if there is more than one unibus on the system  more modules can be configured provided that they are distributed among the unibuses. r1 discovers the excessive baud rate well belore it begins to configure unibus modules; it can now at this point generate a command specifying on which unibus each of the modules is to be placed  thereby simplifying considerably the subsequent box and module selection task. 
1. a foundational ad hoc constrainthandling capability 
　the floor layout task differs from the other tasks involved in configuration in that it is impossible to do an acceptable job of floor layout without some customer specific information. since r1 has had no access to such information  a floor layout capability was not included initially. during the fall of 1  the version of r1 that will be used in conjunction with xsel was provided with a floor layout capability.1 r1 is now capable of producing diagrams for multiple rooms showing the position and orientation of each component. because the floor layout task presupposes some customer-specific information  our approach to developing an ad hoc constraint-handling capability for the floor layout task differed significantly from our approach to handling other sorts of ad hoc constraints. after describing rvs current knowledge of how to do floor layout  these differences 
   much of the design and implementation of the new floor layout capability was done by brigham bell. 
will be discussed. 
1. rvs floor layout capability 
   though r1 assumes that xsel will provide it with room dimensions and with the locations of doorways and obstructions  it does not rely on xsel for any other information. to perform the floor layout task  r1 first groups components on the basis of cabling considerations and then places these groups on the floor in ways that satisfy the ordinary-case configuration constraints it knows about before trying to place a group of components  r1 creates a working memory element to represent each obstruction-free rectangular space in the room. of the spaces that are large enough to contain the group  r1 selects that space which is furthest from the busiest door in the room. if none of the spaces are large enough  it backtracks. for example  suppose a set of rectangular spaces tor some group  a  is generated  and group a is placed in one of them. next  a set of spaces is generated for group b  but none are large enough to contain it. then group a  the last group of successfully placed components  would be removed from the room  and the working memory element which represented the rectangular space group a occupied would be deleted. of the remaining spaces originally generated for group a  the next best space  i.e.  the space furthest from the busiest door  would be selected  and group a placed in that space. a new set of spaces would then be generated for group b in the hope that one of these spaces will be large enough to contain it. larger groups  those with more components  are positioned before smaller groups  and groups with many constraints on where they can be placed are positioned before less constrained groups. 
   the fact that r1 is generating a floor layout for a computer system rather than for some other set of objects does not yet affect its configuration strategy to a significant extent. r1 does assume that terminals and line-printers should be placed near the busy door  that all other components should be placed as far from busy doors as possible  that components should be placed in rows with certain aisle and service space restrictions  that all of the components in the same row should face in the same direction  and that rows of components should face each other. when there is unused space in a room  rows facing each other are pushed apart. these are all of the domain-specific knowledge that rl currently has for performing the floor layout task. 
1. customer p