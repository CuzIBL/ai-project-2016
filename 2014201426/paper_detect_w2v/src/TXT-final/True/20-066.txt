 
by integrating a dominance prover into the plan search process  the traditional constraint-posting planning paradigm can be generalised to permit partially satisfiable goals. in this approach  the view of planning as theorem proving is retained  although the emphasis is on proving theorems about dominance relations on classes of candidate plans. plan classes are generated by posting constraints at various levels of abstraction  then classified within a plan lattice that manages inheritance of properties and dominance characteristics. an analysis of tweak demonstrates how to recast existing planning ideas in this framework  providing insight into the planner's capabilities with a dominance-proving interpretation. the plan lattice representation highlights the role of plan subsumption in optimizing search. 
	i. 	introduction 
one glaring limitation of the traditional ai robot planning paradigm is its view of goals as logical predicates on world states. such a view precludes the consideration of uncertainty except in rare cases where either uncertainty is adequately captured in tolerances or execution monitoring with replanning is viable. even in the absence of uncertainty  planning to satisfy goal predicates provides no mechanism to choose among the plans that achieve the goal nor any guidance about what to do when no such plan exists. the literature has offered ad hoc solutions to overcome some of these limitations in specific cases  for example  simple resource allocation mechanisms or domainspecific meta-planning rules. 
     alternate views  such as bayesian decision theory  offer more comprehensive choice criteria but do not address the planning task of constructing strategies from more primitive actions. 
     in this paper i describe a formal framework for planning that permits the broader range of choice criteria necessary in an environment of partially satisfiable goals with multiple objectives. at the same time it can incorporate many of the principles  representations  and techniques of existing research on planning. central to the framework is 
1
 supported by national institutes of health grant no. 
r1 lm1 from the national library of medicine. 
1 	reasoning 
the notion of planning as the derivation and propagation of dominance relations among classes of candidate plans. 
     definitions and explanations of the structures constituting the planning framework are provided in the sections below. the theoretical apparatus is illustrated with an investigation of tweak  a nonlinear constraint-posting planner  chapman  1a . although tweak is defined in terms of logical goal predicates  an interpretation in terms of the dominance relation provides insight into its capabilities and efficiency. an analysis of tweak's search procedure highlights the role of plan subsumption computations in this approach to planning. 
	ii. 	the plan lattice 
let c be the planning language  or equivalently  the set of all syntactically valid plans. for example  if a {ai ... a n } is an alphabet of primitive actions  then l = a* is the language of linear plans. the language of nonlinear plans is similar  extended by an encoding for partial orders. a plan class is any set of plans  p c l. p is also called a partial plan when it represents a set of constraints that incompletely specifies the plan we are concerned about. 
     we can view the planning process as one of incrementally adding constraints to candidate plan classes until some problem is solved regarding the plan to be executed. in traditional planning the problem is to identify a plan that satisfies the given goal. with a more versatile evaluation criterion  the problem is to find the best plan. except for some special cases where convenient optimization techniques are applicable  it is not possible to determine whether a given plan is optimal by examining it in isolation. it may be more reasonable to answer questions about the optimal plan without necessarily constructing a complete description. 
     the partial plans generated during the planning process can be organized in a specialization lattice according to the subset relation. an example of a plan specialization lattice appears in figure 1. the node in the graph marked 
u
 a*a1a*  denotes the set of all plans with at least one instance of action a t . the set of plans beginning with a1 forms a subclass  as does the set of plans where a1 is followed by a1. 
denotes the initial situation. two plans that both achieve or do not achieve the goal are equally preferred  or indifferent  denoted 1  the expression means that is preferred or indifferent to 
　the preference relation characterises the choice criterion employed by the planner. a planner based on expected utility takes 
		 1  
the discussion of dominance that follows does not depend the plan lattice representation of a search space supports a constraint-posting approach to planning. a constraint-potting planner  illustrated best by molgen  stefik  1   can be more efficient than a planner that evaluates only complete plans. flexibility is gained by allowing many forms of constraints rather than  for instance  just adding actions to a sequence or specifying exact bindings for variables. however  these advantages depend on having some justification for the constraints based on properties of the partial plan. for example  molgen knows that for a screen operation to be useful  it must select the appropriate bacteria. thus  when adding a screen step to a plan  molgen is justified in posting a constraint of the form  resists antibiotic-1 bacterium-1 ; constraining the antibiotic to a particular chemical agent would be unjustifiably specific at this stage. 
     by adding only the constraints that have the best justifications  a planner implements a least commitment strategy. an extreme form of least commitment propagates only provable properties of admissible plans. in practice  however  real planners  like molgen  have to make guesses when no provable constraints are available. the least commitment heuristic tends to minimize both the likelihood of wrong guesses and the extent of backtracking required to recover from such mistakes. a policy of working on plan classes at high levels of abstraction is simply a particular form of least commitment strategy. because it avoids backtracking  a search procedure that preserves the entire lattice of partial plans corresponds to  no commitment  planning. 
iii. 	dominance in the plan lattice 
to speak meaningfully of dominance among plan classes  we need to introduce a preference relation  over plans. in categorical planning  for example  one plan is preferred to another if it achieves the goal and the other does not. to state this in terms of the situation calculus  mccarthy and hayes  1   we write: 
		 1  
g is the goal predicate  defined on situations resulting from the robot performing a plan in a given situation. here a  on any particular criterion for plan choice. although we assume that  is a total order on plans  we do not insist that the planner be given a complete or even an explicit description of the preference relation. 
     we say that a class of plans dominates another if  for any plan in the second class  some plan in the first class is preferred or indifferent. it should be emphasised that it is possible to prove dominance without identifying the superior plan-otherwise this approach provides no advantage over branch-and-bound search. the dominance relation  d  is defined as follows: 
		 1  
the strict version of dominance  d' is defined similarly  except that here a particular plan in the first class is preferred to any in the second.1 
		 1  
clearly  strict dominance implies dominance. in addition  the properties below follow easily from the definitions: 
	d is reflexive  transitive  and complete. 	 1  
	d' is anti-reflexive  transitive  and asymmetric. 	 1  
 1  
 1  
  1   1  
    
　　these properties serve as dominance propagation rules within the plan lattice. by  1  and the transitivity of dy dominance by a particular class is inherited in the plan lattice. strict dominance is also inherited  by  1  and weak dominance inheritance. thus  markers or links indicating dominance relations need be stored only at the upper envelope of classes to which they apply. dominance 
sthis difference is required because of the possibility of infinite 
plan classes with no maximal elements. if  1  were exactly a strict version of  1   then such a class would strictly dominate itself. for the same reason  a definition of weak dominance that merely substituted  in  1  would not entail the reflexive property. assuming every plan class has a maximal plan is unreasonable  even if it is appropriate to require that t does. 
	wellman 	1 

is propagated upwards in the lattice by application of the union properties  1 and 1   which also hold for d'. 
   a plan class is restricted by asserting that it is weakly dominated by one of its subsets. in the molgen example given above  if is the class of plans that include the screen operation  and is the subclass that includes the resists relation as well  then asserts that  resists antibiotic-1 bacterium-1  is a valid constraint. the new dominance assertion represents progress because it lets us focus our attention on a smaller set of plans. thus  deriving these restrictions is an important task of the dominance prover. 
　　　constraints might be posted to explore the search space even though the dominance relation does not provably hold. often  such constraints are justified by identifiable assumptions that imply dominance. we can express this case by asserting the conditional dominance relation  for s an assumption proposition 
		 1  
     normal dominance is just dtrue. as an example of conditional dominance  suppose that we are uncertain about the identity of the organism of interest; it could be either bacterium-♀ or bacterium-s. for i = 1 and 1 let s be the proposition  bacterium-i is the organism of interest  and  the plan class that restricts p1 to those plans in which the resists relation holds between antibiotic-1 and bactcrium-i. then we have   and 
       by the definition of conditional dominance  1   we g e t a p p l i c a t i o n of  1  yields the result 
     of particular value are conditional dominance relations where s itself contains dominance assertions. for example  if  asserts that 
given the optimal plan is in    we can further confine attention to  this is one way to derive the restrictions mentioned above. in fact  this is precisely the strategy employed by both pednault  pednault  1  and chapman  chapman  1b  to limit the search space of their planners. we will see how this works for the latter example in section v below. 
     reasoning about conditional dominance can be implemented straightforwardly via any mechanism for reason maintenance  de kleer  1a  mcallester  1 . the interesting task for the dominance prover is to come up with meaningful conditions that imply useful dominance relations. 
	iv. 	planning 
a program manipulates the plan lattice by repeatedly performing the following steps  not in any particular order : 

  generate new plan classes by adding constraints to undominated classes. 
  construct and refine the prediction/evaluation part of the world model. 
  derive and propagate dominance relations among plan classes. strengthen conditional dominance relations. 
     we will say that a program performing these tasks is planning. note that in this view planning is not a search for a single plan to execute  but an exploration of properties of admissible plans. a planner performs useful work by refining the plan lattice  even if the lowest-level classes are never reduced to singleton sets. if  after much computation  the planner has narrowed the admissible plans to a set that contains 1 or possibly an uncountable infinity of plans  this may seem like little progress. but if we can determine that all plans contain  for example  an appendectomy  we solve a significant problem.1 
     the prevailing view of planning as construction of a completely specified course of action is never totally accurate. planners devote their resources to isolated decisions  as in whether or not to perform an appendectomy  without specifying all other features of the plan. a plan to obtain some bananas is complete only with respect to a have-bananas goal; in the larger context of satisfying all physical and emotional needs forever  the agent never stops planning. figuring out how to get the bananas is a small act of refinement on the big plan. 
     the framework presented so far should be regarded as an abstract model of planning with partially satisfiable objectives. it generalizes the case of goal predicates and applies to uncertain situations. rather than prove that a plan necessarily achieves a goal  as in traditional ai planning  the planner tries to prove properties of the optimal plan. these properties define the class of admissible plans. 
     to instantiate the abstract model to a particular planning mechanism  one needs to specify: 
  the plan language  
  a constraint language  representation for partial plans . 
  a domain modeling language  including a way to de-scribe the effects of actions and a representation for the preference relation  
  a dominance prover. 
the structures described earlier-the plan lattice and dominance relations-serve mainly as theoretical machinery for analysis of this class of planners. specifying the languages and the dominance prover is the real work in designing a planner. 


1 	reasoning 

1
　　plan classet with fuch huge cardinalities should be the norm  not exceptions. if the plan language includes real-valued parameters  then all but the tightest constraints still leave an uncountable set of candidate plans. the plan class  administer a dose of drug x within the next minute* includes individual plans where the drug is given at any point in the 1-second interval. 

     as a simple illustration  consider mathematical optimization techniques as planners. optimization is a special case of dominance proving where the program tries to find a singleton dominator  often in one step. for example  if our plan language is 1 and the domain model consists of a linear objective function and a set of linear constraints among the elements of the vector  then our dominance prover should be a linear programming algorithm. in this case there are no partial plans. branch-and-bound integer programming is an example of an optimization procedure that does make use of partial plans and explicit dominance proving. 
     in the development of the planning model up to now  we have paid little attention to efficiency. the computational value of planners in this framework depends on a 
judicious choice of the languages and algorithms that define it. although it is difficult to characterize efficiency at the present level of generality  there are a few high-level issues that can be identified at this point. first  the addition of constraints during lattice refinement cannot be arbitrary. the planner must generate constraints that relate to the problem at hand and are meaningful to the dominance prover. unless the prover can establish dominance relations on the lattice  refinement is irrelevant. second  it is important to consolidate the plan lattice to avoid redundancy and further the propagation of dominance relations. we will examine this topic further in sections vi and vii below. 
v. 	an extended illustration: tweak 
in the introduction i suggested that existing planning work can be recast in this framework. in this section i examine tweak  chapman  1a  chapman  1b   a nonlinear planner that captures much of the state-of-the-art in a neat algorithm. though tweak belongs to the mainstream planning tradition in considering only goal predicates  its main ideas can be expressed clearly in terms of the plan lattice and dominance relation. 
     as described in the previous section  the way to instantiate this planning framework is to define the various representations appearing in and operations performed on the plan lattice. the plan language for tweak is particularly simple. a plan is a sequence of steps  each specifying an action applied to some objects. the term  nonlinear  refers not to plans  but to the representation for incomplete plans  or plan classes.1 a plan class is nonlinear if it specifies only a partial order on its steps. there are two other sources of incompleteness in tweak: steps may be missing  and steps may refer to variables rather than constant objects. thus any partial plan in tweak may be specified by the steps it includes  the ordering constraints 

　　1  a planner with a parallel execution capability  for example  a multi-agent planner  could actually have a nonlinear plan language. the constraint language for such a planner would be more complex. on the steps  and the constraints on the designations of variables in the steps. 
the domain modeling language is also quite simple. 
the effects of actions are completely described by finite sets of pre- and post-conditions on each step. a world model corresponding to each plan class records the status of goal and condition propositions in a propositional database. finally  is defined by the categorical planning preference relation  l . in tweak  g is simply a conjunction of propositions. 
     the interesting part of tweak is not these representation languages  but the dominance properties that are applied. the power of the planning algorithm derives from the fact that  given a partial plan  we need to consider only a few types of constraints to guarantee that if a satisfactory completion of the partial plan exists  one also exists among its constrained subclasses. constraints are posted via plan modification operators. for our purposes it helps to regard these operators as functions that return constrained plan classes given a starting plan class and possibly some other arguments. we need five plan modification operators: 

     each returns the set of elements of p that satisfy the indicated constraint. addstep constrains the partial plan to include an instance of step t. order confines p to those plans in which step s is applied before step t. note that if this  or the result of any modification operation  is a contradiction  then the function returns the empty plan class. analogously  if the constraint is already implied  the operator is the identity function on p. the code si gnat e  abbreviated cod  and noncodesignate  ncod  functions add the appropriate constraints to the elements indicated. in general  there may be several ways to implement a codesignation among complex elements  such as predicate instances  in terms of their primitive constituents. finally  the ifcodesignate  ifcod  function constrains z and w to codesignate if x and y do. 
     tweak is defined by a nondeterministic procedure that achieves a goal by applying combinations of these operators to a partial plan. chapman presents the procedure as a simple graph   chapman  1a  page 1    chapman  1b  page 1   where the paths from start to end exhaust the possible sequences of plan modifications that can restrict a partial plan p to achieve a goal proposition p at step s. a completely analogous description in our functional notation is the expression appearing in figure 1. this complicated expression  consisting of a combination of plan classes formed by various modifications on represents the set of plans nondeterministically explored by chapman's algorithm. 
	wellman 	1 
     let p' denote this plan class. in the figure  e is the set of establishers; that is  actions that possibly assert the goal proposition. c and w are the potential clobbercrs  actions that negate the goal  and white knights  actions that re-establish the goal   respectively. the function conseq on steps returns the consequent propositions  or postconditions  of the action. that there is a plan in p' that achieves the goal if there is one in p can be captured by asserting  this is a restriction  because each of the components of the p' expression is itself a subset of p. 
     the main theoretical contribution of tweak boils down to this dominance condition. tweak refines p by adding constraints until it finds a partial plan that necessarily achieves the goal  that is  a class provably containing only goal-achieving plans. the theoretical apparatus we have developed can help us understand this process. 
     each term in the expression of figure 1 corresponds to a plan class which is a subset of  these distinguished plan classes serve as intermediate structure in the plan lattice depicted in figure 1. this lattice reflects a decomposition of the search space based on the tweak algorithm. the plan classes with subscripts denote parameterised classes; a complete diagram of this lattice would include  for instance  an at for every t  for the directed links  the plan class pointed to is defined by the boxed set operation applied to the others. thus  and 
 all connections indicate specialization of plan classes from higher to lower levels. 
     because it would be difficult for the planner to generate a description of p.1 directly from the definition of figure 1  in practice it is necessary to manipulate representations of these intermediate classes. the tweak search procedure nondeterministically chooses intermediate plan classes to instantiate and combine until it finds a subset of p1 that necessarily achieves p at s. in the process  the algorithm recursively invokes itself  taking one of the intermediate classes as p and forming the structure of figure 1 
1 	reasoning 
beneath it. 
v i . classification and dependency-directed search 
it is possible that a recursive invocation of the tweak dominance relation would reveal that some intermediate plan classes at one level are dominated by more restricted classes at lower levels. more generally  propagation via  1  through  1  may uncover dominance conditions within or between levels which can be exploited to reduce the search space. 
     these possibilities suggest an addition to the planning steps listed at the beginning of section iv. when partial plans are generated  they are classified by finding their greatest lower and least upper bounds in the plan lattice.1 classification serves to consolidate the lattice  resulting in a maximal propagation of the known dominance conditions. 
     the dominance relation provides us with a class of nogood sets to be used in pruning the search space. planners without a notion of dominance can consider only contradictory plans  that is  empty plan classes  to be nogood; other pruning criteria must be built into the control mechanism. the discussion above illustrates that although tweak's search procedure implicitly takes advantage of the fact  cannot exploit the dominance consequences 
for intermediate plan classes. 
     consolidating the plan lattice through classification prevents redundancy in plan space search. notice  for example  that the plan class dq depends only on q  even 

　　　1the term classified is used here in tht same sense that concepts are clarified in kl-one  schmolse and lipkis  1 . swartout and neches  swartout and neches  1  represent plans by the goals they are intended to achieve and employ a classifier to construct a taxonomy of intents. their decision-making program selects from the taxonomy the most specific plan for the purpose at hand. because this taxonomy comprises compiste plans  their use of classification falls outside of the planning framework developed here. 
though its position in the expression for p' is within the scope of c. a chronologically backtracking search would generate this class for every  c q  pair encountered during the iteration  resulting in a duplication of effort if clobberers share consequents. 
     a simple dependency-recording mechanism would most likely avoid this and similar redundancies. a clever enough scheme might even recognize that  are the same when  however  it is doubtful that any of the standard dependency maintenance mechanisms would catch the more subtle relationships that hold between classes created on successive recursive invocations of the planning algorithm. a precise characterization of avoidable redundancies is rarely offered in descriptions of planners. 
     following the terminology used by de kleer in describing his assumption-based truth maintenance system  atms   de kleer  1a   each plan class is an assumption context represented by the plan modification operators defining it. the plan specialization lattice corresponds to the context lattice of the atms with context subset replaced by plan subsumption. indeed  an implementation using an atms would be just as powerful as the classification scheme presented here  provided that we could construct a propositional interface  de kleer  1b  capable of communicating the relevant implications of partial plans. in our case  though  this does not appear feasible. a mapping of partial plans to sets of propositions would force us to create distinctions  for instance  in unique identifiers for steps  that would fail to preserve isomorphism characteristics. 
     like the assumption-based approach  the plan lattice structure facilitates the exploration of multiple consistent contexts simultaneously.1 but contrary to the atms view  we are not interested in finding all solutions  the class of all plans that achieve the goal . therefore  we can restrict the domain of assumption sets that need to be considered to those explicitly created as plan classes by the planning algorithm. 
　　to recap  the scheme presented here offers two sources of benefits with respect to plan search efficiency. first  the dominance relation provides a major new class of nogoods which may potentially shrink the search space. second  consolidation of the lattice through classification of partial plans takes advantage of dependencies that might be obscured by an interface with a propositional tms. 
vii. 	the complexity of subsumption 
as for knowledge representation mechanisms  the key operation in plan classification is the computation of subsump-
　　　tthis contrasts with the dependency-directed backtracking employed by tweak. the design of schemer  zabih  1  zabih tt of.  1 -a dependency-directed interpreter for a non-deterministic lisp-illustrates this difference and highlights the issues in constructing a propositional interface for arbitrary dependencies. 
tion relations  brachman and levesque  1 . we saw above that classifying plans as they are generated minimizes the search space.1 conversely  a perfect dependency mechanism is in effect computing these subsumptions. 
     unfortunately  nonlinear plan subsumption is npcomplete.1 this is true even for plan classes derived exclusively from addsttp and order operators  that is  partial orders on steps. the exponential potential of subsumption lies in the combinatorial number of possible mappings between the steps of the two plan classes. if  however  we can specify the correspondences between steps  for example  which put-on in  corresponds to which in  then subsumption is at worst quadratic. in practice we will generally not have complete correspondences  but typically the possible mappings between steps will be highly constrained. actions may map only to others of the same type  therefore the computation will not be prohibitive as long as plan classes do not contain many steps of a single type. codesignation constraints also help to restrict the possible mappings  as do explicit identifications among steps which may be provided by the planner when introducing steps in several partial plans at once. finally  we might consider restricting the constraint language so that subsumption is tractable  perhaps to tree-shaped partial orders. 
     the effect on subsumption complexity of proposed extensions to the constraint language should also be considered. for example  we could allow actions themselves to be expressed at multiple levels of abstraction  as in the sequence low-dose steroid therapy is-a steroid therapy isa drug therapy  without significant cost in complexity  as long as action subsumption itself is not expensive.1 extending the plan modification operators to include union and intersection  as suggested by figure 1  is not as benign. intersection  conjunction  presents no problem because the plan modification operators associate and commute  but computing subsumption among classes that are unions  disjunctions  of other classes appears substantially more difficult. 
	viii. 	summary 
in this paper i have introduced and applied some analytical tools for studying and designing constraint-posting planners. the main components of this framework are 


a specialisation lattice and a dominance relation defined over plan classes. these concepts were motivated with simple examples from molgen and a more detailed account of tweak. the power of the tweak algorithm resides in a central dominance result which allows the planner to restrict attention to a small subset of the possible completions of a partial plan. explicit characterisation of the dominance relation allows the planner to recognise that certain plan classes need not be explored  even though they might contain a valid plan. although standard dependency-directed backtracking methods improve search efficiency  the only way to ensure complete lack of redundancy is to classify the partial plans in the lattice by computing subsumption among plan classes. this problem is np-complete for nonlinear planning  but constraints commonly arising in practice may render the computation tractable. recognising the centrality of subsumption suggests a novel approach to analysing the complexity implications of plan constraint languages. 
     the true test of the scheme presented here will be how well it supports tasks that require planning in the presence of uncertainty and partially satisfiable objectives. i am currently applying this framework to the design of a planner for the task of formulating decision models from a large medical knowledge base. the domain modeling language and dominance prover proposed for this task are based on ongoing work on qualitative influence networks  weiiman  1a  wellman  1b . 
acknowledgments 
discussions with zak kohane  ramesh patil  ron rivest  
elisha sacks  peter szolovits  kate unrath  tom wu  and 
ramin zabih contributed to the style and content of this paper. 
