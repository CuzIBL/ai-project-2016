 
this paper describes a program  called new-
ton  that finds approximate symbolic solutions to parameterized equations in one variable. n e w t o n derives an initial approximation by solving for the dominant term in the equation  or if this fails  by bisection. it refines this approximation by a symbolic version of newton's method. it tests whether the first newton iterate lies closer to the solution than does the initial solution. if so  it returns this iterate; otherwise  it chooses a new initial solution and tries again. 
1 	introduction 
research in symbolic equation solving has focused on exact solution methods. the resulting programs  such as macsyma  mathlab group  1  and press  bundy and welham  1l   either return an exact solution or fail. yet  scientists and engineers routinely must solve problems that have no exact closed-form solution. they need an equation solver that finds adequate approximate solutions to such problems  rather than failing. in fact  they often prefer a simple approximate solution even when a complicated exact solution is available. for example  the equation x1 + x - k cannot be solved for x in closed form  but x = k is an accurate approximation to the solution for k near 1. one might well prefer this approximation to the full solution of x1 + x = k  which is very long and complicated. this paper describes an equation solver  called newton  that finds approximate solutions to parameterized equations in one unknown. 
　numeric analysis provides many algorithms for solving individual equations approximately  but says little about parameterized equations. one could solve numerically for specific parameter values and interpolate the results. this would provide little general understanding and require prohibitive amounts of computation  especially for equations containing multiple parameters. instead  newton constructs a single parameterized solution  such as x = k above  for all legal parameter values. users can instantiate a solution with multiple parameter values  rather than rederiving it numerically for each value. they can examine the influence of parameters on a solution analytically instead of by experimentation. 
for example  the approximate solution x - k increases linearly in k. 
1 	the algorithm 
n e w t o n takes as input a parameterized function / x   an interval domain for x  and a set of constraints. each constraint is a strict or nonstrict inequality between realvalued functions of the parameters  for example k   1 and k1   1 m . the constraints and f x  must be extended elementary functions: polynomials and compositions of exponentials  logarithms  trigonometric functions  inverse trigonometric functions  and absolute values. newton assumes that f x  is differentiate and has a single  simple root1 in the domain of x. i discuss multiple and nonsimple roots in the concluding section. 
　n e w t o n narrows in on the root in stages. first  it brackets the root within an interval on which f x  is monotonic by the following algorithm: 
1. let  a  1  be the domain of x 
1. if f' x  has a fixed sign on  a  1  then return  a  1  
1. let m= a + b /1; if f a f m    1 then 1  - m else a  - m 
1. go to step 1. 
if a = -oo or b = oo  it chooses a very small or very large finite number instead. it uses the bounder inequality prover  sacks  1a  sacks  1b  to test whether the inequalities in steps 1 and 1 hold for all parameter values that satisfy the input constraints. the simple root assumption ensures that the algorithm terminates. for example  the function f x  = x1+kx-l1 with parameter k and constraints - 1   k   1 is monotone on the domain x e  1  because /' x  = 1 + k   1 - 1 = 1   1. 
　next  newton calculates an initial approximate root  x1 for f x . if f x  is a sum  it finds the addend of maximal absolute value among those containing x  deletes the remaining addends that contain x  and solves the resulting equation.1 in our example  the addends x1 and xk contain x with |x1|    kxi so newton solves x1 - 1 = 1 to obtain x1 = 1. it rejects x1 = -1 because that root lies outside the domain. newton tries to calculate x1 for general equations by reducing them 

these reductions suf-
1 	automated deduction 

for x in  1 . the cases of x1   r and of / x  monotone decreasing are analogous. the complete test for equation  1  appears in figure 1. n e w t o n resolves the inequalities with bounder as before. 
   n e w t o n tests progressively narrower intervals until it succeeds or the interval shrinks beneath a prespecified width. it starts with the monotone interval  a  1  and repeatedly bisects the distance from x1 to each current boundary. if the initial guess really is a good candidate for iteration  the shrinking should eventually make the test work  at which point newton returns the first iterate. if not  newton must choose a different value for x1 by bisection and start over. if the test had failed in the example  the next test interval would have been  1 1   splitting the distance from the ends of  1  to x1 = 1. 

　the previous examples are all separable  that is expressible in the form / x ik  = g x  + h k . the final example  

with 	demonstrates that new-
ton handles nonseparable functions as well. the function increases monotonically and has a unique root. the convergence condition holds for all k. given the modest constraint  newton can calculate x1 = k 
and 	
the relative error of x1 is 1 for k = 1  1 for k - 1  and less than 1 for k   1. one can obtain even better results with a more sophisticated choice of xo  setting x = 1 in log x+ar   the dominated term of f  x   and solving the resulting equation to obtain 
n e w t o n does not implement this strategy. newton's method appears to work for 1   k   1  even though the convergence condition fails. a more experimental implementation could validate x1 empirically on a large number of sample parameter values  rather than give up. 
table 1 summarizes the examples in this paper. 
1 	conclusions 
this paper describes newton  an equation-solver that finds approximate roots to parameterized functions by a symbolic version of newton's method. if this fails  it turns to a symbolic bisection algorithm. n e w t o n requires that the function have a single  simple root in its domain. one can handle a nonsimple root  r  of / x  by applying newton to /i x  = /   x   / / '   x     which has a simple root at r. one can find multiple roots by partitioning the domain into intervals on which / x  is monotone  hence has at most one root  and applying newton to each subinterval  a  1  for which f a f b    1. i describe a program that calculates the monotone intervals elsewhere  sacks  1 . 
   n e w t o n can only find a root r of / x  for which the sign of /' r  is fixed for all legal parameter values. otherwise  it can neither bracket the root within a monotone domain nor prove that newton's method converges. for example  the function / x  =  ax -   ex has a unique root of l/a for a not= 1  but /' 1/a  = aella can be positive or negative. a possible solution is to partition the space of legal parameter values into regions on which f' x  has a fixed sign and solve for each subset separately. in our example  one can solve for a   1 and for a   1. partition algorithms exist for polynomials  arnon et a/.  
1 ; partitioning other functions is a topic for future research. 
　the strategy of applying numeric techniques symbolically to parameterized problems has many other applications. newton's method generalizes to vector equations. additional numeric techniques  such as the secant method and fixed-point iteration  press et a/.  1   also extend directly to parameterized equations. other domains for symbolic application of numeric algorithms include markov theory  which i have worked on with 
	sacks 	1 
j. doyle  doyle and sacks  1    integration  and dynamic systems theory. 
acknowledgements 
harry mynick of the princeton plasma physics laboratory motivated me to develop newton. forman acton  woody bledsoe  joel friedman  dick lipton  harry mynick  and especially mike wellman provided valuable comments on this paper. 
