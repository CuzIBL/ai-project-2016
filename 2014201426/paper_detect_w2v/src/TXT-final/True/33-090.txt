 	tion  d-ladder must have some description of the information 
this paper1 presents a method of formally representing the 	present in the database  and must be able to decide whether or not there is a database query that will answer the original ques-
information that exists in a relational database. the primary 	1 tion. other researchers  including rciter  1  and chang   
utility of such a representation is for deductive questionhave advanced solutions to the problem posed above; but their 
answering systems that must access an existing relational solutions are inadequate for a number of reasons. a common 
database. to respond intelligently to user inquiries  such sysfault is that they compromise the expressive power with which 
tems must have a more complete representation of the domain they represent the domain of discourse in order to arrive at a 
of discourse than is generally available in the database. the satisfactory algorithm for deriving database queries. we will 
problem that then arises is how to reconcile the information critique these systems more fully at the end of this paper. present in the database with the domain representation  so that 
database queries can be derived to answer the user's inquiries. the key task we accomplish in this paper is the formulahere we take the formal approach of describing a relational tion of a representation rich enough to describe the domain of database as the model of a first-order language. another first- discourse  along with information that the associated database order language  the metalanguage  is used both to represent contains about that domain. furthermore  we present an algothe domain of discourse  and to describe the relationship of the rithm that will determine when sufficient information exists in database to the domain. this view proves particularly useful in the database to decide the truth of some statement about the two respects. first  by axiomatiiing the database language and domain  and generate the appropriate database language query. its associated model in a metatheory  we are able to describe in to formalise the information content of a relational a powerful and flexible manner how the database corresponds database  we take the view that the database is a finite model of to the domain of discourse. secondly  viewing the database as a a particular first-order language  called the database language  or mechanizable model of the database language enables us to take ddl. the operations of the relational calculus can then be used advantage of the computational properties of database query in a decision procedure for sentences in the language. when this language processors. once a database query that is equivalent occurs  the database language is said to be interpretable  with to an original query is derived  it can be evaluated against the the database as its intended model. queries to the database are database to determine the truth of the original query. thus expressed as sentences in the dhl; operations on the relations the algebraic operations of the database processor can be incor- of the database can be used to find the truth-value of any forporated in an elegant way into the deductive process of question- mula of the ddl. a model with this property is said to be a answering. 	computable model. 
when viewed as an interpreted language  the ddl lacks 
	1. introduction and overview 	the descriptive power necessary for most ai applications  e.g.  
     this paper presents a method of formally representing the it is impossible to express disjunctive facts   cither it is raining information that exists in a relational database. database rep- or the sun is out  . thus we will axiomalizc the domain of disresentation technology has progressed independently of ai  but course separately as a theory in a first-order predicate calculus there is a need to reconcile it with ai representations. many ai with equality  which is a powerful descriptive formalism. this systems that address real-world domains must access existing language is called the metalanguage  or ml. in addition to endatabases; typicallly these have been natural-language question- coding the domain of discourse  the ml theory will contain a 
     answering systems  e.g.  lunar  1  and d-laddeii  1 . the description of the ddl. that is  the ml theory will have terms d-ladder database  for example  is a pre-existing relational that denote ddl expressions  and predicates that assert the database that is distributed across several sites of the arpanet; truth of ddl expressions in their intended model  the database. access to the information is through a pre-defined database finally  the ml theory will contain axioms that relate the truth query language. d-ladder can parse and  understand  of sentences in the ddl to predicates in the ml that describe english-language questions for which no information is available the domain of discourse. these axioms characterize the connecfrom the database because it maintains a representation of the 1note that we are not making a judgement here about the utility of domain of discourse that subsumes the information present in database representation technology. il may be the case that all the in-
formation that is present in the database under consideration could be 
the database. however  to respond reasonably to a user's ques-	more easily and conveniently represented using standard ai techniques  
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　e.g.  semantic nets or morn clauses. the situations we are interested to l the work reported here was supported by the defense advanced research are those where the database is a pre-defined part of the domain  and wt project* agency und r contract n1 r 1. the views and con- must build some representation for the information that it contains. given clusions contained in this document arc thoso of the authors and should the prevalence of databases as an in formation-storage technology  it seems not be interpreted as representative of th  official policies of the defense reasonable to expect that some applied ai systems will have to interact advanced research projects agency of the u.s. government. with them. 
1 

tion between the database and the domain of discourse. 
　　queries about the domain are originally expressed as formulas in the ml. by attempting a constructive proof of a certain ml expression involving that formula  it is possible to either answer the query by a proof in the ml theory  or find a dhl expression that is equivalent to the original ml query. in the latter case  because the ddl is fully interpreted by the database  the answer to the query can be found by evaluating the dbl expression with a suitable database query processor. this whole process is reminiscent of the answer extraction technique of green . 
　　the metalanguage/database language dichotomy is useful in making a theoretically satisfying distinction between the description of the discourse domain required by an aj system  and the information that may be present in an associated database. as a result  it will be possible for a question-answering system that uses this representation to respond in a more sophisticated way to user inquiries to a database. for example  it is possible to correctly represent the distinction between questions such as  is p always true   versus  is p currently true in the database   
1. the relational database as a model 
　　we seek a method of describing the information that a database contains  that is  a way of formally characterizing the way in which data in the database relates to the domain under consideration. for the purposes of this paper  we will restrict our attention to a particular type of database  the relational database  because it is more readily amenable to formal analysis than are other database formulations.1 a relational database is a set of relations {/  } over a set of domains {dj}. each relation ft consists of a set of tuples of some fixed length n  the arity of the relation; we will indicate a relation's arity with a superscript  rn. the elements of the tuples are drawn from the domains of the database.1 in a relational database  the relations arc finite  but the domains may be infinite  e.g.  the domain lengths in the sample database below is the set of positive real numbers over some interval. 
　　as an example relational database  consider the following relations about the ships world: 
shipr : ships x snames x lengths x medic co mm an dr : officers x ships 
the domains are ships  s names  ship names   lengths  officers  and medic. medic is the bi-
nary domain {t f}  and its use will be explained below. this sample database is derived from the blue file database accessed by the ladder project  1 . a typical tuple of the shipr relation might be {u s n m l af ay ette 1.& t}. 
　　a relational database is used to model the world in the following way. if a tuple {u x  y z} is present in a relation r1  then the objects u  x  y  and z are assumed to participate in the corresponding real-world relation. thus the presence of the 
*thc approach deicribed here will actually work with any databaie representation technology that is powerful enough to be a mechanizable model for tome first-order language. 
tuple {usnl1ztlafayettem** t  means that the ship usn1 has the name lafayette and the length 1. the interpretation of the medic value is that the ship has a doctor on board if the value is t  and does not if the value is f. 
　　what happens if a tuple is not present in a relation depends on the interpretation one chooses for the database. the strongest assumption that can be made is that if a tuple is absent  the relation does not hold for the elements of that tuple. whether this assumption is appropriate or not depends on the domain of discourse that is being modeled. it assumes that the database has complete information about the part of the world that corresponds to the relations it contains. in many applications  the database has only partial information about the domain of discourse. a formalization of the information that the database contains must be rich enough to represent a partial correspondence between the database and the domain. 
　　the relations in a relational database can be considered to form an algebraic structure under the operations join  restriction  projection  and set union and difference . these operations can be used to extract information from the database in a convenient manner. for example  suppose we wished to find the officers of all ships over a length l. one way to do this would be to join tuples from the commandr and shipr relations with the same ships element 1 restrict the resulting relation so that only tuples with a length element greater than l remain  and then project the officer elements to yield a 
　　set of one-element tuples containing the answer. 
　　formally  the results of algebraic manipulations on a relational database can be described by designing an appropriate first-order language for the database. the basic idea is that expressions in the language  which we will call the database language  or dbl  are either true or false with respect to the database; further  because wc actually have the database in hand  it is possible to determine the .truth value for any expression of the dbl by performing algebraic operations on the database. thus the dbl functions as a query language for the database  because it describes properties of the database. a query is phrased as an expression in the dbl  and then algebraic manipulations can be performed on the database to determine the truth of the expression  and hence answer the query. codd  1| has shown that the five given operations are sufficient to decide the truth-value of any expression in an appropriately defined dbl; hence the database and its associated algebra forms a computable or mechanizable model for the dbl. 
　　at this point  it is helpful to look at the dbl for a particular database  the sample database given above. we will use a manysorted first-order language with equality. there is one sort for each relation in the database; a sort consists of all tuples that are in its corresponding relation. variables are restricted to range over a given sort. in quantified expressions  the sort that a variable is restricted to will always be indicated by giving the name of the relation for the sort. for example  in 
vtishipr       
the variable t is restricted to tuples in the relation shipr. because variables only refer to tuples in a relation  this type of language has been called a tuple relational calculus  1 . 
　　besides variables over tuple sets  we allow function terms that refer to elements in the domain. among these terms will be unary functions that pick out elements of a tuple. generally  
*this operation if called an equijoint and is the composition of a join with an equality restriction. 
1 

we will use function names that are similar to the domain of the element that they select from the tuple. as an example  consider: 

　　the language also contains the boolean operators  the equality predicate  and some arithmetic predicates such as greater than and lest than. as defined  the dbl has the important property that every expression that can be written in the language is decidable with respect to the sample database  using the relational algebraic operations. such a language is called safe in the database literature ; a safe language is one whose expressions can all be interpreted by examining just the instances of relations present in the database. the practical import of this is that safe languages are mechanisable  in the sense that the truth value of every expression in the language can be determined by a finite number of algebraic manipulations on its intended model. 
1. the metalanguage 
　　a language like the ddl for which the intended model is available is called an interpreted language. if the database correctly reflects the structure of the domain of discourse  then we need no additional representational apparatus to describe the domain. however  it is more often the case that we have incomplete information about the domain of discourse: for example  we may know that the lafayette is commanded either by smith or jones  without knowing which one of the two is the actual commander. such partial information about the domain cannot be expressed within the database model. 
　　another way to view this situation is to say that the database and the domain of discourse are both models of the dbl  but they are not coextensive. that is  in the real world it may be the case that either smith or jones is the captain of the lafayette; because we do not know which is the case  there will be no tuple in the com manor relation of the form {nnn ♀/1jv1}  where 1jv1 is the identifier of the lafayette. so if the query   does jones command the lafayette  is posed in the dbl  the answer with respect to the database will be  no   which may not be the case in the actual world.1 
　　if a question-answering system is to return correct responses to user's queries when only partial information about the domain is available  then a more powerful representation than the dbl and its associated database is required. on the other hand  we wish to make use of the information that is contained in the database in those cases where it is sufficient for responding to a query. so the representation we seek must not only characterise the domain of discourse  it must also encode the way in which 
 we are going to uiume in this paper that what information the database does contain about the domain of ditcottrac is correct. in principle  the formalisation presented in this taction could readily handle case* where the database was not in conformity with the domain  e.g.  the tuple jones  usn1 is present in the com manor relation even when jones is not actually the commander of the lafayette. it may be useful in practice to have this ability  especially when dealing with a changing domain where updates to the database may not be timely. 
the database as a model corresponds to the actual world. 
　　to represent the domain of discourse  we will use another many-sorted first-order language with equality  called the metalanguage  or ml. the ml will have non-logical axioms that state properties about the domain. for example  for the ships world we might define the following predicates: 

a typical assertion about the domain might be: 

which says that every ship has a length. it is not critical that we have chosen this particular form of the first-order predicate calculus; any of the non-sorted variants would do just as well. note that the ml need not be a tuple calculus; in this example  variables range over individual ships  officers  lengths  etc.  rather than tuples. 
in addition to representing the domain of discourse  the 
ml is also used to characterize the database as a model of the 
dbl; this is what makes it a metalanguage. in the ml  we will use the predicate db of one argument  a dbl formula  to mean that that formula holds in the database. assume  for example  that the ml term / denotes the dbl formula vt/shtpr | name *  = lafayette  v  length t    1 . 
then the ml expression db j  asserts that the dbl formula denoted by / is actually true of the database; that is  all tuples in the shi pr relation either have their sname element equal to lafayette  or their length element greater than 1. 
　　in the metalanguage  we require a number of constructors for dbl formulas. for boolean connectives of the dbl  the constructors and  or  imp  and not take ddl formulas as arguments and return the obvious dbl compound boolean formula. for example  the ml term and f  g  denotes the dbl formula fag  where f and g are the dbl formulas denoted by / and g. this abstract syntax for object-language formulas was introduced by mccarthy  1 . 
　　because the db predicate represents truth in the database model  the normal truth-recursion axioms are valid for it. we introduce the ml sort dbfs  which is the set of all dbl formulas  and write the truth-recursion axioms as: 

　　additionally  to construct an arbitrary dbl formula we will need ml terms that denote dbl predicates  terms  and quantifiers. at this point it is convenient to develop the theory for the propositional case; later it will be extended to predicates over individuals. for each dbl propositional constant there is a ml constant term that denotes it. the convention will be to use primed terms in the ml to denote the corresponding unprimed propositional constants in the dbl. thus the ml term p' will have the dbl proposition p as its denotation. given this and the ml boolean constructors  it is possible to write a ml term for any sentential expression of the dbl  e.g.  and p  not q'   denotes the dbl formula pa q. the two ml terms true' and false' are specially defined to refer to the dbl propositions true and false  whose truth values in 
1 
the database arc always taken to be true and false  respectively: 
db true' =pv~p 	t p   db false'  s pa~p 	j 	h1' 
1. database query derivation 
　　having described the dbl and its associated database within the ml  we are in a position to formulate the derivation of database queries in the ddl from an original ml query. at this point we will restrict our attention to closed queries  that is  those whose answer is either yes or no. closed queries can be represented by closed ml expressions. 
　　suppose that qwff is a ml expression whose truth value is to be determined. consider the ml schema: 
		t . 
if a constructive proof of t  can be found for a given instance of qwff  the binding for / will be a dbl formula that is equivalent to the original query qwff. by evaluating the dbl query with respect to the database  the truth of qwff can be determined. note the use of the equivalence connective in tv  if the answer to the dbl language query turns out to be  false   then the negation of qw/f will have been established. 
　　a special case of t  occurs if the binding for / is true or false. when this happens  the truth or falsity of qwff will have been established entirely within the metalanguage  without the necessity of evaluating a dhl query. 
example. let p and q be two dbl propositions which we intend to have the same meaning as the ml predicates p and q  respectively  wc can use the same names because we will always know which language a formula is in . the ml also contains the constructors p' and q' of no arguments  whose denotations are the dbl language formulas p and q. we can state that the dbl and ml predicates have the same meaning by axioms of the following sort: 
db f ~p 
db q  =q 
p1 states that p  or q  holds just in case the dbl formula represented by p'  or q'  holds in the database. the axioms p1 can be used to derive dbl queries equivalent to any ml query that is a sentential expression over p and q. suppose the original ml query is p /q. then it is easy to show that  by tr1 and p1  
	pvq 	ql. 
　　the process of database query derivation is similar to that of answer extraction in formal question-answering systems  1|. the problem of finding a database query is reduced to that of finding a proof of the first-order ml formula that is an instance oftl. 
1. predications on individuals 
　　in section 1 an abstract syntax was developed for dbl constant predicates. but since an important part of the dbl are terms referring to individuals  the abstract syntax must be extended to include constructors for these dbl terms. in this section we introduce the needed technical machinery for this into the ml. although the machinery itself may appear cumbersome  the idea behind it is fairly simple: to state the correspondence between terms in the dbl and the individuals they name. the complications arise in keeping track of the distinction between terms in the ml  terms in the ol  and the individuals they denote. 
1 the denotation function 
　　we begin by defining a new sort  dbts  that is the set of dbl terms. ml terms or this sort will denote dbl terms. again  a primed convention will be used; e.g.  the ml constant term a' will denote the dbl constant term a. we can diagram this relationship as follows: 

the arrows in the diagram represent the denotations of the terms. a and b as terms in the ml refer to the individuals a and b in the domain of discourse; they are of the sort inds. similarly  the terms a and b of the dbl also denote individuals in the domain. the ml constants a' and b'  of sort dbts  refer to the dbl terms a and b  rather than individuals. there is nothing special about using the same symbols in both languages to denote these individuals; it is done here simply for consistency of naming. 
　　to construct dbl expression that involve predications over arguments  the ml contains a primed constructor symbol p' for each predicate symbol p of the dbl. the arguments of the ml constructor p' are dbl terms  one for each of p's arguments. thus the denotation of the constructor p' is a dbl predicate over dbl terms; p' a' b'  denotes the dbl predicate p atb . 
　　although it is possible for the dbl and the ml to have different domains of individuals  it is technically convenient to 
make them identical. this will make the correspondence between quantified expressions in the two languages easier to state. to assert that the dbl's model actually has enough individuals  the denotation and naming functions must be introduced into the metalanguage. 
　　it is often useful to know  in the ml  what individual a dbl term refers to. the denotation function a is used for this purpose;1 it takes a dbl term as its argument  and returns the individual denoted by that term. in the ml  the sorts of the argument and result of the denotation function are given by: 
vn/dbts 1 j / / n d s a n  * *  
the a function can be understood more easily by examining the denotation map for individuals in the ml and the dbl; it maps between a dbl term and its referrent. because  in the ml  a' refers to the dbl term whose denotation is the same as the ml term a  we write: 

1 standard names 
　　in any language  there may be many different names for the same individual; e.g.  we could speak of the lafayette as  the ship commanded ' v jones.  such names might change their denotations in different circumstances  however. it is handy to have a name for each individual that is always guaranteed to refer to that individual; these are called standard names. all of the constant terms that we will introduce into the dbl will be such standard names  e.g.  i*afayette from section 1   


1 

by using pa above  either of the following two dbl expression can be proven to satisfy q1: 

given just pa  it is not possible to find a dbl expression corresponding to the query   is jones the doctor on board usn1   the domain of discourse represented by the doc predicate properly subsumes the database's information on the subject. thus it is possible to represent this query in the ml  but not in the dbl. 
1. incomplete information 
　　in the previous section  we encountered an example of a database which had incomplete information about the domain of discourse: there was no representation for which doctor was on board a ship  just an indication that some doctor was present. in this section  we will examine a few of the more common ways in which a database may have incomplete information about the domain. this catalog does not exhaust the possiblities available for characterizing the relationship of a database to its domain within the mi.; but it does show how to deal with a few of the more common situations that arise in practice. 
1 no attachment for a predicate 
　　it often occurs that some part of the domain of discourse is just not referred to at all by the database. for the sake of conceptual completeness  for example  we may allow the user to ask about properties of ships that are not included in the database under consideration. in this case  there will be a predicate in the ml that refers to the property  but no corresponding dbl tuple set. the ability to deal with this type of incompleteness is particularly important in building systems that must interact with users who are unfamiliar with the contents of a database. 
　　a special case of this type of incompleteness occurs when a ml predicate has only a partial correspondence in some database relation. an example of this is the doc predicate in the previous section  axiom pa ; only ml queries involving existential quantification over the doctor argument could be answered. partial correspondence of a ml predicate is characterized by the ability to find dbl expressions for some  but not all of the ml queries containing the predicate. 
1 only-if incompleteness 
　　the correspondence previously stated between the com predicate and the commandr relation  expressed in p1  used an equivalence connective. the only-if half of this connective is important for the derivation of dbl expressions equivalent to ml formulas involving com. this is because the onlyif half of f1 states that if the tuple {a b} is not present in the commandr relation  then a does not command b. 
　　in many cases  however  the interpretation of a database relation is that if a tuple is present  then the relationship holds between those; individuals; but if it is not present  it cannot be inferred that the relationship does not hold. all of the positive instances of the relation correspond with the domain of discourse  but not the negative instances. for example  it may be the case that all of the commanders of u.s. naval ships are known  but not those of foreign naval ships. then the axiom p1 is too strong  and must be weakened to an implication: 

this axiom it not strong enough to allow the derivation of equivalent dbl expressions for the com predicate  but may still be useful in an intelligent question-answering system. failing to find a proof of an instance of t  for a ml query  such a system might weaken t1 to find a dbl formula that implies  but is not implied by  the original query. if a positive answer is returned from the database  then the original query is true; if not  no conclusion can be drawn. 
1 domain incompleteness 
　　since the dbl is a tuple calculus  there is no explicit quantification over subdomains of inds  e.g.  ships  officers  etc. how then can dbl queries be formed that ask whether a property holds for all the members of one of these sets  for example  consider the ml query: 

this asks whether all ships have a length greater than 1 meters. suppose we assume that every ship length is represented in the shipr relation: 

ps is not sufficient to answer qs; the reason is that we have not stated anything about whether all ships are included in the shipr relation or not. a counterexample to the truth of qs would be a domain where there were some ships that did not have lengths. the best we can do with ps is to derive the equivalent ml formula: 

where there is still a ml quantifier over all ships. 
　　domain incompleteness is thus automatically assumed unless explicit non-logical axioms are included to counteract it. for the ships world we are using as an example  we want to say that all ships in the domain are to be found in the shipr relation; on the other hand  not all lengths or names need be present. that is  the domain lengths is assumed to be the rational numbers in the interval  say   1 ; at any given moment  only a finite subset of these will be present in the shipr relation. similarly  more names are available than are in use. 
　　to state the completeness of the shipr relation with respect to ships  we assert: 

that is  a universal quantifier over ships can be moved inside the dd predicate to the shipr relation. the use of p1 enables us to prove that the following dbl expression satisfies qs: 

on the other hand  because there is no explicit domain completeness axiom like ps for lengths  the question  is there some ship of every length   cannot be answered by a dbl query. 
1 

　　the ability to correctly represent that the database has if this ml formula could be proven  then any query about only partial information about a domain of individuals enables individual doctors and ships could be answered. note that us to allow infinite domains in the database  without deriving we are not interested in evaluating the dbl formula that is ddl expressions that yield counterintuitive truth values for ml a binding for / in this case; rather  we wish to establish the queries. if answering a ml query involves quantifying over an existence of a class of dbl formulas. 
infinite domain  then no equivalent dbl expression will ever be in a more speculative vein  we might consider integrating generated for it. the ml/ddl framework with current aj formalisms for the representation of changing states of the world  most notably 
1. other issues 	the situation calculus  1 . suppose each ml predicate were 
extended to take an additional argument  a situation in which 
　　in this section we will briefly describe how open queries the predicate was to hold. thus doc x y s  would mean that can be accomodated in the metalanguage approach. we will z was the doctor on board y in situation a. there would be also examine some of the ways in which a question-answering some distinguished situation 1  the current state of the world  system might use the representation to respond intelligently to about which the database would have information. it would user queries. 
then be possible to correctly represent and answer user queries 
1 open queries 	that made the distinction between a proposition always being 
	open queries are queries whose answer is a set of in-	true of the domain  as opposed to true in the current situation. 
dividuals  rather than a truth value. in the metalanguage  open for example  consider the two queries: queries can be represented by a formula that has one or more is there always a doctor on every ship  free variables in it. the answer to the query is the set of those is there a doctor on every ship now  
individuals that  when substituted for the free variables  make the first of these can only be answered by proving a ml formula the query true.1 for simplicity  we will consider open formulas over all situations; the second can be answered by consulting the with only one free variable. the free variable will be indicated current state of the database. 
by enclosing it in square brackets next to the ml formula: m x  if several previous copies of the database are kept around  is a ml formula with free variable z. free variables in the ml then it is also possible to answer queries about past situa-
will always be of the sort inds. 	tions. suppose  for example  that the day associated with each 
	in the dbl  we will allow free variables over the simple 	situation is kept in the mi   and a separate copy of the daily 
 non-tuple  domains. because of the finitencss of the dbl tuple database is available for querying. then queries such as  do domains  dbl expressions involving free variables have the im- more ships have doctors on board today than yesterday   could portant property that only a finite set of individuals will satisfy be answered by evaluating two database queries and computing the expression when substituted for the free variable.1 a dbl the answer from the values they returned. 
query with a free variable is thus guaranteed to return a finite set 
of individuals; further  because of the computational properties 	1. relation to other work 
of the dbl discussed in the second section  there exists an al-	some recent work in formalisms for database representation gorithm for determining this set. 	has been collected in |1j. this work differs broadly from the ap-
     the problem of finding a dbl open formula that cor- proach presented here in that the dabatase is viewed as a set of responds to a ml open formula can be stated in terms similar ground atomic sentences in a first-order theory of the domain to t l   the schema for closed queries: of discourse  rather than as a model. there arc several disad-
           vantages to interpreting the database as part of the syntactic t1. description of the domain  which the approach described here does not suffer from: 
here is the dbl expression constructed by substitute because the database tuples are taken to be part of the laning the term tj z  for the free dbl variable or in /. if a conguage that describes the domain  special algorithms must structive proof of t1 can be found  then it will yield an open 
dbl formula whose truth value is the same as that of m z  for 	be formulated to translate from a formula containing non-
every individual z. database predicates to an equivalent one containing just database predicates  
1 types of questions and answers 	t 	special assumptions about incomplete information must 
　　the ability to formalise the relationship of the database to be made  because it cannot be assumed that the negation the domain opens up new possibilities for intelligent response to of a tuple not present in a relation holds. these special a user's queries. one type of query that can be readily handled assumptions  which have been called the closed world asin this framework is a request concerning what information sumption and domain closure  do not always correspond the database has about the domain. for example  suppose a with our intuitive notions about incomplete information naive user wants to know if the database has information about in the database  and do not give the required flexibility 
what doctors are on board which ships. this question could be in axiomatizing the relationship of the database to the phrased in the ml as: 	domain. 
  the representational power of the first-order language used to describe the domain is severely restricted in order to carry out database query derivation in the presence of the 
'reiter  1  extends the notion of the answer to an open query to disjunctive 
combinations of individuals  e.g.   either smith or jones commands the incompleteness assumptions. in particular  these systems lafayette.  we do not consider this complication here. forgo the use of existential quantification and function symbols in axioms that connect the database and non-database 
 to show this  it is necessary to exclude from the dbl expressions of the 
form a = q  where 	a 	free variable. 	predicates. this means  for example  that a relationship 
1 

such as pi could not be encoded. 
　　the systems described in   l  suffer from these limitations to a greater or lesser extent  depending on which trade-off they choose to make. for example  chang  l  chooses a very restrictive form for his axioms  but has a simple algorithm for deriving equivalent formulas that involve only database relations. reiter  relaxes these restrictions somewhat  and also gives an exact account of the assumptions being made about incomplete information; but his derivational algorithm is more complicated. 
　　it should be mentioned that the criticisms leveled above apply to the so-called evaluational approach to database query derivation  which is assumed in this paper. that is  the database is presented a priori  and must be addressed by a separate query processor whose communication overhead is high relative to deduction outside the database. with this assumption  it is reasonable to try to transform the full query to one that can be evaluated all at once against the database. other systems  such as   assume a much tighter coupling between the database and the non-database parts of the first-order theory. the database is assumed to be simply a repository for atomic ground formulas that can be accessed during the course of a proof  although some attempt is made to minimize the total number of accesses. 
1. conclusion 
　　we have taken the view that the information content of a relational database can best be represented as a model of a particular type of first-order language  a tuple relational calculus. this view has proved particularly useful in two respects. first  by axiomatiding the database language and its associated model in a metathcory  we have been able to describe in a powerful and flexible manner how the database corresponds to the 
domain of discourse. this is a representational advance  because ai systems that must address databases need just this facility. secondly  viewing the database as a mechanizable model of the dbl enables us to take advantage of the computational properties of database query language processors. once a 
database query that is equivalent to an original query is derived  it can be evaluated against the database to determine the truth of the original query. thus the algebraic operations of the database processor can be incorporated in an elegant way into the deductive process of question-answering. 
　　a final word about implementation. an initial algorithm that incorporated some of the ideas about incomplete information in the database was implemented for the d-ladder project  1|. a restricted first-order language  the conceptual schema  was used to represent the domain of discourse  and a query expressed in this language was transformed by the algorithm into the database language soda |1|. however  this algorithm did not take advantage of the power of the metalanguage encoding. in klaus  an intelligent knowledgeacquisition and question-answering system  we intend to implement the ml/dbl structure as described in this paper  and explore the complicated issues of deduction that will arise. 
