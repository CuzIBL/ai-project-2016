 
ross |1  is an object-oriented language developed for building knowledge-based simulations  1l. swirl |1  1  is a program written in ross that embeds knowledge about defensive and offensive air battle strategies. given an initial configuration of military forces  swirl simulates the resulting air battle. we have implemented 
ross and swirl in several different lisp environments. we report upon this experience by comparing the various environments in terms of cpu usage  real-time usage  and various user aids. 
1. introduction 
over the past six months we have been engaged in implementing 
ross  an object-oriented  know ledge-based simulation language  1jj and swirl  an air battle simulation  1  1   in five different lisp environments we discovered that the environments varied considerably in how well they supported system development. we report upon our experience by comparing the various environments in terms of cpu usage  real-time usage  and user aids  e.g.  editors and file packages . our aim is to critically examine several lisps available today  in order to help those who are building large systems to make an informed choice about which dialect may be most appropriate for their application. 
1. five implementations of ross and swirl 
1. maclisp on a dec-1 
maclisp  running under tops-1  was the original language in which ross was implemented. approximately one man-year was required to make ross a reasonably mature object-oriented programming environment. two factors greatly contributed to the speed of ross development. first  maclisp has a very efficient implementation on the dec-1 that made it possible to quickly experiment with additions and changes to the ross design.  of course  the speed of maclisp also contributed to the efficiency of the swirl simulation written in ross. as may be seen in table 1  the implementation in the maclisp-ross version is  overall  the fastest of all implementations of swirl.  second  within maclisp  we could make use of emacs  a powerful screen-oriented editor  that runs locally within maclisp through the use of the ledit package. emacs had two features that were crucial to efficient program development. first  emacs understands lisp structures  e.g.  it does automatic s-expression indentation  pretty-printing and parentheses balancing . second  when using emacs to edit a function definition  one directly edits the file containing the function. the user is in full control over not only the format of function definitions  but also exactly how the functions are arranged in files  and therefore in hardcopy when printed. 
what hindered the development of ross in maclisp was the poor documentation of many essential language features. often novice maclisp users regard maclisp as primitive  especially compared to 
interlisp  which advertises such user packages as the clisp iterative facility  the record package  the filepackage  and the printout printing facility in fact all these features exist in maclisp  but until recently  unless you had a maclisp wizard around  the only way to find out about them was by browsing through the files your machine's maclisp directory. this kind of search cost us at least a month in development time. 
t the views expressed in this paper are the authors' own and do not represent thope of rand or any of its research sponsors. 
the other main problem with the maclisp implementation was that it resided on a dec-1. this machine is proving increasingly inadequate for large ai programs  because of its small 1-bit address space. 
1. franrllsp on a vax-1  
because of franzlisp's advertised compatibility with maclisp  we thought it would be straightforward to convert our maclisp versions of ross and swirl to work within the franzlisp environment. this was almost the case. about two man-weeks of effort over a one month period was required for the conversion process. we did notice certain inconsistencies between franzlisp and maclisp but they were fairly easy to fix. although ross and swirl are large systems even when compiled  see table 1   they ran acceptably fast within franzlisp  even when running large simulations. 
our franzlisp runs under the unix operating system and provides us with a very useful link to our c-based graphics programs. compiled versions of these programs can be directly loaded into franzlisp. this feature allows us to dynamically view a swirl simulation as it is running. 
franzlisp also scores high marks for some user development tools. like maclisp  one can use emacs as a screen-oriented local editor. here the interaction is a little different. the user is actually in 
emacs and sends forms to lisp for evaluation. the advantage of this is that within emacs  the user can move backwards and forwards across forms  modifying them and resubmitting them to lisp as he chooses. we find this to be a powerful environment for rapid code modification. 
1. interllsp-d on a dolphin  
our first interlisp version of ross was developed on the xerox 
1  dolphin  processor. this version underwent substantial redesign not only because of the difference between maclisp and interlisp but also because we wanted to improve upon the maclisp version. it took us about four man-months for the new implementation  which was more time than expected. the major problem was speed. as the statistics in table 1 indicate  the dolphin was over an order of magnitude slower than the maclisp-1 version for running a standard simulation. but the dolphin fared worse in speed of software development than speed of performance of a developed system. file operations  e.g.  loading files or editing a function then saving it on file  see table 1  were the major bottlenecks. further  since interpreted code on the dolphin usually executes too slowly to be tolerable  all code had to be compiled before being tested. this substantially increased the time between identifying a bug  fixing it  and testing out the fix. 
perhaps the most outstanding feature of the dolphin is its graphics capability. we found it to be very powerful for quickly implementing a wide range of graphics tasks. also several user aids like the trace and break packages have been augmented graphically and enable one to display and hold far greater information on the screen than with conventional terminals. the dolphin's graphics capabilities  bitmap display  mouse and windowing are well exploited by dedit  the principle function editor. it is especially powerful when used with the ttyin facility which  like emacs  has some very useful features such as parenthesis matching  and moving forwards and backwards over s-expressions. we have one maior caveat: dedit is a function editor  not a file editor. with dedit one changes the definition of a function  but makefile  the interlisp function for writing out a symbolic file  determines the appearance and location of function definitions within files. in contrast  when editing func1 s. narain et al. 
tions with emacs in maclisp  one changes both the definition and appearance  since one is editing a file and a function simultaneously. 
the dolphin operating system does not provide a tree structured directory system  so that files cannot be stored as logically as one would like them to be. the high bandwidth  1 mbits/sec  ethernet communication network connecting the dolphins and the vax1 allows one to quickly transfer large files between different stations. 
1. interlisp on a vax-1  
bringing the ross/swirl system up in vax-interlisp did not turn out to be as straightforward as we had expected even though we had already developed ross/swirl in interlisp-d. though interlisp-d source code was almost completely transportable  certain subtle incompatibilities were fairly time consuming to discover. it took about one and a half man-months to bring the ross/swirl system up. 
as with interlisp-d  speed was the main factor slowing both program development and hindering subsequent effective use of the swirl simulation. this slowness is partly due to working in a time-sharing environment and partly due to the sheer size of interlisp and the overhead involved in evaluating an expression  e.g.  dwim  clisp . we regard the interlisp-vax version of ross as marginal for serious simulation applications. 
one inconvenience of interlisp-vax  not shared by the other interlisp implementations  is that unix file names are restricted to at most 1 characters and do not have version numbers. although interlisp does attempt to simulate version numbers  it does so at the unix level. these files all look alike and what results can be seriously confusing at times. also  considerable caution must be exercised while manipulating files in unix since it is very easy to delete or overwrite them. 
since the conversion task involved a non-trivial amount of file manipulations  editing  copying  deleting  the process was helped immensely by the availability excellent file editors  emacs and the local rand editor e   ani by the unix software support. we rarely had occasion to use the interlisp structure editor. 
1. interllsp on a dec-1  1  
ross/swirl has been most recently developed for interlisp on the 
dfx-1. it took about one man-week to bring up this version. yet  several factors made this a surprisingly painful process. among other things  the backquote facility  for defining macros  had to be redefined. we also found that files bad to be massaged in format considerably so that interlisp-1 would accept them. however  because of the extremely efficient disk operations on the dec-1  the powerful emacs editor  the friendly tops-1 operating system  which has among other features  excellent backup support  tree structured file directories  altmode completion   and useful tops-1 resident software  it was possible to go through several iterations of the system fairly rapidly. even so  swirl ran substantially slower than the corresponding implementation in maclisp on a dec-1. 
1. discussion 
through several years of experience in developing large lisp-based systems we have formed certain opinions about features in various lisp environments  and their effect upon programmer productivity. we summarize these below. 
first  as perhaps with any software development effort  the total turnaround time between writing a piece of code and testing it out should be minimal. this implies that the cycle of obtaining fresh lisp sessions  loading files  executing code  modifying code  and storing changes should be as rapid as possible. we found that maclisp  franzlisp and interlisp-1 satisfied this requirement  but interlisp-d and interlisp-vax did not. a major bottleneck in interlisp-d program development concerned file operations. not only did they take a long time to complete  but there was also a lack of a good file editor. we had to use the file editors on the vax  particularly when converting some of swirl files from maclisp into interlisp  and suffered a substantial increase in the number of time-consuming steps needed to make a change on disk. also  interlisp is much bigger than maclisp or franzlisp  and its large size causes frequent swapping at run time leading to considerable deterioration in execution speed. the presence of user aids  e.g. dwim  mas terse ope  
programmers assistant  if not deactivated  further adds to the time needed to produce a response. even while programming in int lisp  we found we had rare occasion to use many of these featur in the rase of interlisp-d  for example  dwim operated so slow that it was quicker for the user to detect and correct his own sp ling errors. 
secondly  we found it more desirable to create our code by direc writing into files  instead of defining functions within lisp  and usi makefile to write them out to disk  as is done in interlisp. our opinion  good programming style refers not only to the str ture of functions  but also to the organization of functions in larger  logically connected units of code. if it is difficult for the p grammer to maintain full control over the appearance of lar hunks of code or files  it eventually becomes very hard for him keep a good cognitive map of his programs. without such a m the programmer's understanding of his program  and the rate which he can modify it  diminishes as the system grows larg maclisp and franzlisp give the programmer complete control ov the organization of code. obtaining such control in interlisp is pc sible  but indirect  awkward  and time consuming. 
finally  we have come to increasingly believe that speed is as impo tant a tool for software development as any sophisticated user int face. al has been notorious for ignoring efficiency issues. ma research applications run in interpreted lisp. often there is decent lisp compiler  and where there is  even good lisp hackers not know the special compiler declarations needed to make good of compilation. as ai moves from developing theoretically intere; ing but computationally light systems into a market place th demands computationally-intensive  scaled-up systems that m run in real time  there will be an increasing need for  industri; strength lisps . these would include  for example  compilers th are well documented  heavily optimized  that run in the san environment as the interpreter  and that are guaranteed to. produ code that runs the same as interpreted code. presently no compi meets all these requirements  although common lisp  hopes meet these goals. 
1. 