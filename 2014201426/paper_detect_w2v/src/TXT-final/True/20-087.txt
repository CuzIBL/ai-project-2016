: the constructive second-order proofs that we study are associated with inductive definitions on classes of finite structures  where each structure represents a database state. to an inductive definition of a predicate p on a class k corresponds a uniform proof of p i.e a function which for each structure u defines a proof of p in u in the second section  we review the definition of an inductive query  and the differences between logic programming and 
inductive definability. we give some examples and then describe compilation techniques. in the third section we introduce the notion of a uniform proof  and in the fourth section we study properties of uniform proofs  namely non-monotonicity and                                                                        intensionality. these proofs use computations on sets and the finiteness of the 

	de rougemont 	1 

definition-  is inductive on a clan k if 
there exists a system with parameters such that for all u: 

1. inductive definability and logic programming. in classical logic programming data and logical definitions are treated as first-order axioms and a query is solved by attempting to find some first-order proof of q in the theory defined by the axioms if the data changes  the theory changes and so will the proof of q 
in the inductive definability framework  we set a fundamentally different formalism as we distinguish between data and logical definitions the data determines the finite relational structure u of a class k. and the logical definitions are taken as inductive definitions relative to k to a class k we associate a c/ass of theory  namely the set of true first-order formulas of u  th u    for each u if the data changes  the structure changes within the same class k  but the the class of theory does not change. 
we only solve inductive queries on the class k given an inductive query q and a structure u  we solve the query q and produce a proof of q or -q in u to the query q corresponds a uniform proof i.e a function which for each structure u associates a proof of q or -q in u. although we will obtain different proofs for each structure u  database state   they will all correspond to the same uniform proof. 
let us illustrate this fundamental difference with a simple classical example a more detailed analysis is made in |1 . we adopt the prolog notations: in the inductive framework      replaces the symbol  뫴- . 
exampie:consider two classes of acyclic directed graphs 


the inductive definition defines tc x y  on the class of finite graphs  in particular on the classes g }  n  and g1 n    where y is a parameter. in the logic program  tc is defined by 1 rules  and the inductive definition of tc has 뫩 component*. let us analyse the q u e r y i n both formalisms. 
 the inductive definition of tc will be compiled into code independent of the data  c-code  then machine code   using call-by-value for the parameter variables  and a call-by-sets for the recursion variables  see next section . in the case of tc 1 l   
the query 	evaluates to false 	o n a n d to true 
on g1 n  let us compare the proofs generated by these two approaches 
logic programs:  evaluates to no  using 
negation by failure |1|  in time 1 n    as all the paths from 
1 are considered 	 evaluates to 	yet  but 
the complexity analysis depends on the position of the new atomic clause  if this new clause is inserted before the clause  e 1     the complexity is constant  one step . if it is inserted after the clause  e 1  n   the complexity will be 1 n   the worst-case analysis is therefore 1 n   if we add data  for example n e 1 l     the theory changes  and the proofs change each proof of tc 1 l  is specific to a given finite graph 
 inductive definability: for all constants o and  the uniform proof of  is a constructive second-order proof that paraphrases the compilation of the inductive definition it could be represented as the inductive set  hat been computed. if  then yes  otherwise no. we obtain the same uniform proof independently of the graphs as we compute a unary set  the relativized complexity is o n  it can be pre-computed at compile-time  and is the basis of the intensional analysis. 
on the graphs  evaluates to 	no  using the 

1 	reasoning implicit negation by inductive cloture1. we use the symbol o to represent this negation on the graphs evaluates to yet the following labeled trees represent these 
1.s. the compilation of inductive queries. 
let k be a class of logical databases. each explicit relation r is compiled into two c-functions. for simplicity  let us suppose r binary  and assume that a type-definition set has been defined that includes the data-structures for base relations  grids . 

the c-function rb assumes that x and y are known strings a and b representing elements of the domain  and returns 1 if  and 1 if  whereas the function rf assumes 
that at least one of the variables is unknown or free  value nil   and returns a pointer to a set. 
1.1. compilation rule: 
be a system defining r 

  for inductions of positive dimension d  compile s.  and s f as before pass the parameter by value  and compute the inductive sets  until the closure ordinal is reached project on the recursive variables if known. 
this 	computation 	rule defines 	rb 	and 	rf  	and 	works 	for 
existential induction  horn-clauses   and universal inductions. in this last case  we compute a set and check that its cardinality is equal to the cardinality of the finite domain we also compile - r 
by generating 	 and act 	*-  using the complement 
operator on the finite domain d1. 
1.1. witnewet. 
explicit by the component variable i is quantified existentially. in order to prove we have to exhibit an element c in d such that 
 the computation of rb will call for a selection and then a join-operation. we will compute |s a s |   and check for each element d of that set if the first d that we find 
with this property is the witness of | 
in an induction of positive dimension  a new element in the inductive set s at stage i  uses a witness at stage i-1. these witnesses can be stored together with the inductive sets  at no extra cost. 



component of the inductive definition of r is of the form 

  i f a node is labeled with  r b1  .. b/   i  and its child with 
then the i-th component of the inductive 
definition: an effective proof of in u is a labeled tree in u whose root is labeled with and an effective proof of in v is a labeled tree in u whose root is 
labeled with 
 to denote effective proofs of q and 
definition: a uniform proof of a query q on a class k is a function  computable in polynomial time  that associates an 
theorem 1: a query q is computable in polynomial time iff there is a uniform proof of q. 
theorem 1: if a class k1 is an inductive expansion of a class 
k  and if there is a uniform proof of q on k.  then there is a 
uniform proof of q on k. 
theorem 1 is implicit with our definition of |- . theorem 1 comes from the equivalence between inductiveness and being uniformly provable. theorem 1 is the recursion theorem rephrased in this 

context. 

1 	reasoning 
모모1 this coastruction is inefficient at soon as the arity of r is 1  but the intentional analysis will allows us to know in advance that it it inefficient 
	de rougemont 	1 
모---------------

모------------------------------------------------------------

---------------

------------------------------------------------------------

