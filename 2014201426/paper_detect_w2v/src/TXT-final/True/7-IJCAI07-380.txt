
local search procedures for solving satisfiability problems have attracted considerable attention since the development of gsat in 1. however  recent work indicates that for many real-world problems  complete search methods have the advantage  because modern heuristics are able to effectively exploit problem structure. indeed  to develop a local search technique that can effectively deal with variable dependencies has been an open challenge since 1.
in this paper we show that local search techniques can effectively exploit information about problem structure producing significant improvements in performance on structured problem instances. building on the earlier work of ostrowski et al. we describe how information about variable dependencies can be built into a local search  so that only independent variables are considered for flipping. the cost effect of a flip is then dynamically calculated using a dependency lattice that models dependent variables using gates  specifically and  or and equivalence gates . the experimental study on hard structured benchmark problems demonstrates that our new approach significantly outperformsthe previously reported best local search techniques.
1 introduction
a fundamental challenge facing local search researchers in the satisfiability  sat  domain is the increasing scope and performance of complete search methods. while for most of the 1s it was taken for granted that local search was the most practical method for solving large and complex real world satisfiability problems  selman et al.  1; kautz and selman  1; be¡äjar and many`a  1   the latest generation of complete sat solvers have turned the tables  solving many structured problems that are beyond the reach of local search  e.g.  zhang et al.  1; ee¡än and biere  1  .1 so it is of basic importance to the area that local search techniques learn from the success of the newer complete methods.
¡¡the current research goes to the core of this problem by modelling problem structure within a local search procedure. this involves a two-part process: firstly problem structure must be recognized within the original problem representation  here we are considering satisfiability problems expressed in conjunctive normal form  cnf  . and secondly this structure must be represented within a local search procedure in such a way that the local neighbourhoodof possible moves will only contain structure respecting flips.
¡¡the ideas behind this approach come from two sources. firstly  there is the recent work on modelling constraint satisfaction problems  csps  as sat problems  pham et al.  1 . here the presence of csp multivalued variables is automatically detected in the clausal structure of a cnf problem. this information is then embedded within a local search in such a way that for each group of binary valued sat variables corresponding to a single multivalued csp variable  only one sat variable will be true at any one time. this enforces that the underlying csp variable is always instantiated with a single domain value. the sat-based local search achieves this by doing a two-flip look-ahead whenever it encounters a literal associated with a csp domain value. in effect this look-ahead turns off the current csp domain value with one flip and turns on a new value with a second flip. a significant advantage of this approach  when encoding binary csps  is that the cost of such a double-flip equals the sum of the costs of the individual flips  because these flip pairs will never appear in the same conflict clause. for this reason  csp structure exploiting algorithms can be easily embedded within an existing sat local search architecture and add negligible processing overhead to an individual flip. as we shall see  more general structure exploiting approaches do cause interactions between literals within the same clauses  and so require more sophisticated flip cost calculation procedures.
¡¡the second source for the current research comes from ostrowski et al.'s  work on the extraction of gates from cnf encoded sat problems. these gates represent relationships between sat variables of the form y = f x1 ... xn  where f ¡Ê {  ¡Ä ¡Å} and y and xi are boolean variables from the original problem. if such a gate is recognized  the value of y is determined by x1 ... xn  and can be removed. ostrowski et al. used this method to simplify a range of structured sat benchmark problems  producing significant performance gains for their systematic dpll solver. however  to the best of our knowledge  such structure exploiting approaches have not been applied in the local search domain.
¡¡the problem facing a local search approach to implementing gates is one of efficiency. ostrowski et al.'s approach can detect independent variables whose values determine a set of dependent variables via clausal gate connections. using this information  we can implement a local search that only flips the values of independent variables and then dynamically calculates the effects of these flips on the overall solution cost. however  a local search needs to know the flip cost of all candidate flips in advance of making a move. generally this is achieved by maintaining a make cost and a break cost for each literal in the problem i.e. the numberof clauses that will become true if a literal is flipped and the number of clauses that will become false . these costs are then updated after each flip. a major advantage of a sat local search is the speed with which these cost effects can be calculated  this is achieved using clever data structures that exploit the sat cnf problem structure   tompkins and hoos  1 . however  taking an approach that only flips independent variables renders the standard sat local search architecture redundant. in this case  finding the potential cost of an independent variable flip requiresus to solve a mini-satprobleminvolvingall the affected dependent variables and their associated clauses.
¡¡the rest of the paper is organized as follows: we first explain how the cost of flipping an independent variable in a local search can be efficiently calculated using a dependency lattice data structure. this structure models the various dependencies in the original problem and dynamically calculates which independent variables  when flipped  will cause a clause to change its truth value. details of the construction and operation of this lattice are given in the next two sections. to evaluate the usefulness of this new approach  we conduct an empirical study that examines several of the structured sat benchmarks that have proved to be the most difficult for local search in the past. finally  we discuss the significance of our results and indicate some future directions of research.
1 gates and dependencies
in the following discussion we shall broadly follow the terminology used in  ostrowski et al.  1 . firstly  consider the following cnf formula:
  a ¡Å b ¡Å c ¡Å d ¡Ä a ¡Å b ¡Ä a ¡Å c ¡Ä a ¡Å d 
¡¡here  for the clauses to be satisfied  if b and c and d are all false then a must necessarily be false  otherwise a must necessarily be true. this is an example of an  or  gate  because the value of a is determined by truth value of  b ¡Å c ¡Å d  and can be represented as
a = ¡Å b c d 
similarly  if we reverse the signs of the literals we get:
 a ¡Å b ¡Å c ¡Å d ¡Ä  a ¡Å b ¡Ä  a ¡Å c ¡Ä  a ¡Å d 
¡¡now for the formula to be satisfied  if b and c and d are all true then a must necessarily be true  otherwise a must necessarily be false. this example of an  and  gate can be represented as
a = ¡Ä b c d 
¡¡a third commonlyoccurringclausal structureis the  equivalence  gate  or  xnor  gate   illustrated as follows:
 a ¡Å b ¡Å c ¡Ä  a ¡Å b ¡Å c ¡Ä  a ¡Å b ¡Å c ¡Ä a ¡Å b ¡Å c 
¡¡here  in order to satisfy the formula  a will be true iff b and c are both true or both false  i.e. if they are equivalent  otherwise if b and c differ then a will be false. this can be represented as
a =   b c 
¡¡finally  an  xor  gate is the negation of an  equivalence  gate  illustrated as follows:
  a ¡Å b ¡Å c ¡Ä a ¡Å b ¡Å c ¡Ä a ¡Å b ¡Å c ¡Ä  a ¡Å b ¡Å c 
where a will only be false if b and c are equivalent. this can be represented as
a = ¨’ b c 
¡¡if an  equivalence  or an  xor  gate depends on more than two variables  then equivalence or difference is calculated in a pairwise fashion  i.e. if a =   b c d  and b and c are false  then b   c is true  and if d is true  then d    b   c  is true and therefore the gate is true. in general  we represent an  xor  gate as y = ¨’ x1 ... xn   an  equivalence  gate as y =   x1 ... xn   an  or  gate as y = ¡Å x1 ... xn  and an  and  gate as y = ¡Ä x1 ... xn . here y is the dependent variable because its value is determined by the independent variables x1 ... xn. for the sake of simplicity  we treat an  xor  gate  e.g. a = ¨’ b c   as a special case of an  equivalence  gate  e.g.  a =   b c   in the rest of the paper.
1 the dependency lattice
as ostrowski et al.  have already described  the process of recognizing gates in a cnf problem can be reduced to searching for the appropriate clausal structures during a preprocessing phase. this information can then be used to classify the dependent and independent variables. for a complete search method  this means the search space can immediately be reduced to only consider independent variable instantiations  as all dependent variable values can be automatically fixed by propagation.
¡¡however  for a local search  there is no built-in propagation mechanism. in fact  a local search strategy precludes propagation because it deliberately allows inconsistent assignments to persist. to exploit the information inherent in dependent variable relationships requires us to remove them from the domain of  free  variables while still including their effect in the overall cost of a particular flip. to achieve this we have developed a dependency lattice data structure. this lattice is formed as a result of analyzing the original cnf problem into independent variables  and relationships between internal and external gates. firstly  an independent variable is not simply a variable that determines the value of a dependent variable in a gate relationship  because such determining variables can in turn be determined in another gate. an independent variable is a variable that is never determined in any gate relationship. secondly  an internal gate is any gate that can be recognized within the structure of the original cnf formula  and thirdly  an external gate is a gate where the dependent variable represents a clause from the original cnf formula that is not part of any internal gate. to clarify these concepts  consider the following cnf formula example:
  g1¡Å v1¡Å v1 ¡Ä g1¡Å v1 ¡Ä g1¡Å v1 ¡Ä
 g1¡Å v1¡Å v1 ¡Ä  g1¡Å v1 ¡Ä  g1¡Å v1 ¡Ä
 g1¡Å g1¡Å g1 ¡Ä  g1¡Å g1¡Å g1 ¡Ä
  g1¡Å g1¡Å g1 ¡Ä g1¡Å g1¡Å g1 ¡Ä
 v1¡Å g1 
which is equivalent to:
 g1 = ¡Ä v1 v1  ¡Ä g1 = ¡Å v1 v1  ¡Ä
          g1 =   v1 v1  ¡Ä c1 = ¡Å v1 g1   where c1 is an additional variable that depends on the clause  v1 ¡Å g1   i.e. if  v1 ¡Å g1  is true  c1 is true  otherwise c1 is false . in general  each original cnf clause that is not subsumed within a gate dependency is represented by an additional variable  that then subsumes the clause in an external  or  gate dependency.
¡¡having translated our original problem into a set of gates  we can now represent it as the dependency lattice in figure 1:

figure 1: an example dependency lattice.
¡¡here the original variables have become nodes in the lattice  such that nodes v1 ...v1 correspond to the independent variables  nodes g1 ...g1 to the internal gates and node c1 to an external gate. in this form  a satisfying assignment to the original cnf formula is equivalent to an assignment of the independent variables such that all the ci external nodes evaluate to true. this result follows trivially from the structure of the lattice  which implements the structure of the internal gates and therefore ensures that all internal gate relationships are necessarily satisfied. when all the external nodes evaluate to true  this means all the remaining cnf clauses that were not subsumed as internal gates are true  and hence that a satisfying assignment has been found.
¡¡the purpose of the lattice is to embody the structure of gate dependencies in such a way that the cost of flipping an independent variable can be efficiently calculated. this is analogous to existing local search sat solvers  except that existing solvers are only equipped to handle  or  gate dependencies.
1 calculating flip costs
to illustrate the process of cost calculation  we have instantiated the independent variables in figure 1 as follows: v1 ¡û false  v1 ¡û false  v1 ¡û true and v1 ¡û false. moving down the lattice from v1 and v1 to the  and  gate at node g1 it follows that the values of v1 and v1 make this gate variable false. similarly  moving down from v1 and v1 to g1 we can see that the corresponding  or  gate variable is true. then following down from the gates at g1 and g1 to the  equivalence  gate at g1 we can see that this gate variable is false  and so on. in this way  the lattice reflects the necessary consequences of the independentvariable instantiations on the rest of the problem.
¡¡to calculate the cost of flipping a particular independent variable vi we need to know how many external gate variables will become false and how many will become true as a result of the flip. this is achieved by storing at each gate node the set of independent variables that  if flipped  would cause the gate variable to change its truth value. for example  node g1 stores the independent variable v1  signifying that if v1 was flipped then g1 would change from false to true. similarly  g1 can only become false if v1 is flipped. moving down the lattice  we can see that g1 would become true if either g1 or g1 were to change values. as flipping v1 will change the truth value of g1 and flipping v1 will change the truth value of g1  either of these flips will also change the truth value of g1  so g1 inherits v1 and v1 into its variable set. node c1 similarly inherits v1 and v1  as a change in either variable will make c1 true.
¡¡once we have the correct variable sets for each of the external gates we can read off the make cost and break cost for each independent variable simply by counting the number of times a variable appears in a false external gate  = make cost  and the number of times it appears in a true external gate  = break cost . so  in our example  both v1 and v1 have a make cost of one  with all other make and break costs equal to zero.
1 the general case
in realistic problems it can easily happen that the same independent variable appears in multiple branches leading to the same gate. to handle such cases we require more general definitions of how the variable sets for each gate type are composed.
¡¡firstly  if an  and  gate is true then all its parent nodes must be true  therefore any change in a parent node's truth value will also change the truth value of the gate. this means the gate's variable set  v   should inherit the union of all the parent variable sets  psets   as follows:
if true and  then v ¡û¡È true psets  
¡¡alternatively  if an  and  gate is false then only if all its parent nodes become true will the gate become true. this requires that all false parent nodes become true and no true parent node becomes false  as follows:
if false and  then v ¡û¡É false psets   ¡È true psets  
¡¡the rules for an  or  gate can be similarly defined in reverse:
if false or  then v ¡û¡È false psets  
if true or  then v ¡û¡É true psets   ¡È false psets  
¡¡for all  equivalence  gates with no more than two parents  only if the truth value of a single parent changes will the value of the gate change  as follows:
v ¡û¡È psets  ¡É psets 
¡¡in general  an  equivalence  gate is true iff the count of its true parents has the same parity as the count of all its parents. as we did not discover any  equivalence  gates with more than two parents in our problem set  we did not implement the more-than-two-parent case.
¡¡in addition  we did find rare problem instances where a single variable was dependent on more than one gate. in these circumstances  we added an additional dependent variable for each extra gate and connected these variables to the first variable via additional  equivalence  gates.
1 implementation
the motivation behind the dependency lattice is to develop an efficient method to update the make and break costs for the independent variables. clearly there is a potential for the additional work of calculating flip costs using the lattice to outweigh the benefits of reducingthe size of the search space  i.e. by eliminating dependent variables and internal gate clauses from the problem . therefore it is of significance exactly how the lattice is updated. in our current implementation we do this by representing the total set of independent variables at each node using an nind bit pattern  such that if the ith independent variable is in the variable set of a particular node  then the ith position of the bit pattern for that node will be set. using this representation we can efficiently implement the set operations necessary to propagate the effects of flipping an independent variable through the lattice. this propagation starts when an independent variable has been selected for flipping. beginning at the lattice node corresponding to this variable  the update works down the lattice to all the connected internal nodes. for example  if v1 is flipped in figure 1  then nodes g1 and g1 will be selected for update. the update process then performs the appropriate set operations on the parent variable sets to produce an updated variable set and truth value for the selected gate. if the truth value of a node and the contents of its variable set remain unchanged after an update then no further propagation is required from that node. otherwise the process continues until it reaches the external nodes. then  if an external node's variable set is changed  this updates the make and break costs of any affected independent variables and the process terminated.
¡¡if we follow the process of flipping v1 in figure 1  this will alter the variable set at g1 from {v1} to {v1 v1} and change g1 to true. as the variable set at g1 has changed these effects are now propagated to the internal node g1 which becomes true. now we have a situation where both parents of g1 share the same variable  i.e. g1 now has {v1 v1} and g1 has {v1}. in this case if v1 were flipped then both parents of g1 would change their truth value and still remain equivalent  leaving g1 unchanged. hence g1 only inherits v1 into its variable set. finally  the external node c1 changes its truth value to true and changes its variable set from {v1 v1} to {v1 v1}. this change then causes the make costs of v1 and v1 to be reduced by one and the break costs of v1 and v1 to be increased by one. the process terminates with all external nodes set to true  meaning that a satisfying solution has been found. this situation is illustrated in figure 1:

figure 1: a dependency lattice solution.
1 experimental validation
in order to validate our approach to handling gate dependencies  we implemented a non-cnf version of adaptnovelty+  hoos  1  that operates on the new dependency lattice platform. we then evaluated the performance of this algorithm on a selection of satlib ssa1  parity 1- and 1-bit problems.1 table 1 firstly shows the effect of gate detection on the number of variables and clauses in the problem set  detailing the number of independent and dependent gates in the corresponding non-cnf dependency lattices and the total time taken for each conversion.
¡¡we then compared the performance of our new non-cnf adaptnovelty+ algorithm against the original cnf based variant by running the two algorithms 1 times each on the ssa1 and par1 instances and 1 times each on the par1 instances. table 1 shows the success rate  the average number of flips and time in seconds taken to solve these instances. each run was timed out after 1 hour for the ssa1 and par1 instances and after 1 hours for the par1 instances.
	as	shown	in	table	1 	the	non-cnf	version	of
adaptnovelty+ significantly outperforms its original cnf counterpart both in terms of flips and time. indeed  the new non-cnf approach is at least 1 times better than the original cnf approach on these instances. in addition  this is the first time that a local search solver has managed to find solutions for all the parity 1-bit problems within 1 hours. the only other sls method that can solve these problems is dlm1  wah and wu  1 . however  dlm could only solve the compacted par1-*-c instances  producing only 1 successful run out of 1 attempts and taking nearly 1 hours to find a solution.
¡¡as all else has been left unchanged between the two versions of adaptnovelty+  we must conclude that the extraordinary performance gains are due to the successful recognition and exploitation of variabledependenciesin the new noncnf approach. as shown in figure 1  the dependency lattice
problemcnfextractednon-cnf#seconds#vars#clauses#fixed#eq#and/or#input#outputssa-1 1 11111ssa-1 1 1111ssa-1 1 1111ssa-1 1 1111.1par111111.1par111111.1par111111.1par111111.1par111111.1par1111 111par1111 111par1111 111par1111 111par1111 111table 1: the effects of the gate extracting algorithm on the ssa1-  and parity problems. this table shows the number of  fixed    equivalence   #eq  and  and/or  gates extracted from each instance. the numberof  independent and  external dependent gates of each processed non-cnf instance are described in the table as #input and #output  respectively.
problemcnf basednon-cnf based% solved#flips#seconds% solved#flips#secondsssa-1%1 1.1%11ssa-1%1 1.1%1.1ssa-1%1 1.1%1.1ssa-1%1 1.1%11par11%1 1.1%11par11%1 1.1%11par11%1 1.1%11par11%1 1.1%11par11%1 1.1%11par11%n/a  1h1%n/a1.1par11%n/a  1h1%n/a1.1par11%n/a  1h1%n/a1.1par11%n/a  1h1%n/a1.1par11%n/a  1h1%n/a1.1table 1: the results of solving the ssa1-* and parity problems using the cnf and non-cnf based versions of adaptnovelty+. the #flips and #seconds are the average number of flips and seconds taken to solve each instance. for the original adaptnovelty+ the #flips values have been approximated as the flip counter maximum was exceeded.
of the par1 instance is highly connected. access to this extra knowledge enables the new solver to maintain the consistency of the dependent variables and hence to efficiently navigate the search space and find a solution. the structure of the variable dependencies is otherwise flattened out and hidden in the original cnf representation. this means that cnf based sls solvers must expend considerable extra ef-

figure 1: the dependency lattice of the par1 instance. in this graph  the independent gates are depicted as shaded rectangular boxes and the dependent  equivalence    and  and  or  gates are represented as hexagon  house and inverse house shaped boxes  respectively. external dependent gates are also lightly shaded. a solid arrow outputs the gate value  while a dashed arrow outputs the negation of the gate value.
problemcnf basednon-cnf based% solved#flips#seconds% solved#flips#secondsbart1%1.1%1.1bart1%1.1%1.1bart1%1.1%1.1bart1%1.1%1.1bart1%1.1%1.1table 1: the results of solving the aloul's bart fpga problems using the cnf and non-cnf based versions of adaptnovelty+. the #flips and #seconds are the average number of flips and seconds taken to solve each instance.
fort to discover solutions that respect these dependencies.
¡¡however  the cost of maintaining consistency between the newly discovered gates in our non-cnf approach is also significant. to measure this  we conducted an additional experiment using a set of bart fpga problems that exhibit no dependency structure  aloul et al.  1 . table 1 shows our non-cnf adaptnovelty+ solver to be more than 1 times slower on these problems. however  this performance deficit can be partly explained by the initial cost of searching for gate dependencies in the original cnf representation  and hence will become less significant for problems where the solution time significantly exceeds the preprocessing time. we also used the built-in c++ set class to update the lattice which could be replaced by more efficient  special purpose data structures and operators. finally  it would be trivial to implement a switch that automatically reverts to using a cnf based solver when the proportion of gate dependencies falls below a given threshold.
1 conclusion
in conclusion  we have introduced a new dependency lattice platform that effectively maintains the consistency between independent and dependent variables  or gates  during the execution of a local search. based on this platform  our new non-cnf version of adaptnovelty+ can solve many hard structured benchmark problems significantly faster than its original cnf based counterpart. in addition  this non-cnf adaptnovelty+ variant is the first local search solver able to reliably solve all five par1 instances within 1 hours. by exploiting variable dependencies within a local search and by solving the par1 problems we have also successfully addressed two of the  ten challenges in propositional reasoning and search   #1 and #1  presented in  selman et al.  1 .
¡¡in future work  we expect that non-cnf implementations of the latest clause weighting local search solvers  such as paws  thorntonet al.  1  and saps  hutter et al.  1   will further extend the state-of-the-art in local search techniques. in fact  the extension of these solvers using our dependency lattice is very straightforward. instead of counting the number of external dependent gates that will be made or broken if an independent gate is flipped  we simply sum the corresponding weights of the dependent gates.
¡¡another future research direction is to develop new heuristics that further exploit the gate dependencies when selecting the next variable to flip. with these improvements  we expect that local search techniques will be able to match the performance of the state-of-the-art dpll solvers on the more structured industrial benchmark problems.
acknowledgments the authors would like to acknowledge the financial support of national ict australia  nicta  and the queensland government. nicta is funded through the australian government's backing australia's ability initiative and also through the australian research council.
