 
stratified case-based reasoning is a technique in which abstract solutions produced during hierarchical problem solving are used to assist casebased retrieval  matching  and adaptation. we describe the motivation for the integration of case-based reasoning with hierarchical problem solving  exemplify its benefits  detail a set of algorithms that implement our approach  and present their comparative empirical evaluation on a path planning task. our results show that stratified case-based reasoning significantly decreases the computational expense required to retrieve  match  and adapt cases  leading to performance superior both to simple case-based reasoning and to hierarchical problem solving ab initio. 
1 	problem and proposed solution 
case-based reasoning  cbr  is a problem-solving paradigm that focuses on the retrieval  revision  and reuse of stored solutions to solve newly presented problems  kolodner  1; aamodt & plaza  1 . the representation of cases can be simple  e.g.  feature vectors  or complex  e.g.  semantic networks . an advantage of simple representations is that retrieval and revision algorithms for such representations have comparatively low computational cost. however  this low computational cost comes at the expense of limited representational power. for example  the relational knowledge required for such tasks as planning  design  and analogical reasoning is difficult to express in a feature-vector case representation. however  more expressive case representations require more expensive retrieval and revision functions. for example  when cases are represented as semantic networks  case matching requires subgraph isomorphism determination  an np-complete task  garey k johnson  1 . 
　in this paper  we propose using abstraction to combat the complexity associated with expressive case representations. we explain how abstraction can be used to reduce this complexity in section 1 and describe an example task in section 1. section 1 then introduces a set of algorithms that implement our approach. we 
1 	case based reasoning 
david w. aha 
navy center for applied research in ai 
code 1 
naval research laboratory 
washington  dc 1 aha aic.nrl.navy.mil 
      1  1 / fax: -1 evaluate their capabilities in comparison with simpler case-based and abstraction approaches in section 1 and discuss related work in section 1. 
1 	abstraction: reducing cbr complexity 
two principal approaches exist for reducing the complexity of indexing and matching complex cases on sequential machines.1 one approach is to precompute some portion of the match between cases  e.g.  by organizing cases into a hierarchy partially ordered by subgraph relations  levinson  1  . an alternative approach involves using case abstractions for indexing and matching. previous use of abstraction in indexing has generally focused on thematic abstractions  such as goals  hammond  1  or expectation failures  schank & leake  1 . use of abstraction in case matching has generally been limited to feature generalization  e.g.  finding common ancestors of new-case and old-case features in a hierarchy that encodes subsumption relations on features values  porter et al.  1  . 
　this paper advocates a new approach for using abstraction in cbr. underlying this approach is the observation that hierarchical problem solving1 gives rise to solutions at multiple levels of abstraction. if the solutions produced by hierarchical problem solving at every level of abstraction are retained  then the more abstract solutions can assist in indexing  matching  and adapting less abstract solutions. we refer to a case whose representation has multiple abstractions as a stratified case  and we define stratified cbr as the use of stratified cases in case-based problem solving. the potential benefits of this approach are: 
  indexing and retrieval. a more abstract solution to a problem can provide an accurate index to less abstract solutions to the problem because it consists 
lsee  kolodner  1  and  kettler k hendler  1  for 
related work on machines with parallel architectures. 
　1 in hierarchical problem solving  search is performed in an abstraction of the original search space. the solution in the abstract space is then used to guide problem solving in the original space. where applicable  this technique can lead to significant reductions in search time  sacerdoti  1; holte et al.  1; knoblock  1; bacchus k yang  1 . 
　the goal of this task is to locate a route connecting the start and goal positions. we modeled this as the task of constructing a sequence of straight and curved track segments  or traversal operators  such that the start and goal positions lie at the ends of the connected track. we of the most important aspects of the less abstract solutions. 
  matching. retaining case abstractions permits cases to be compared in an abstract space in which matching may be much less expensive than at the ground level of abstraction. 
  adaptation. an abstraction of a stored case may be much easier to reuse than the ground-level case itself. stratified cases can be reused at the most specific level of abstraction at which they can be applied to the given problem without requiring adaptation of less abstract  non-matching facts. 
　since stratified cbr involves reusing hierarchical problem solving episodes  its applicability is limited to domains in which there is an abstraction hierarchy suitable for hierarchical problem solving. however  several techniques that automatically derive abstraction hierarchies have recently been developed  and the development of new techniques is the focus of an active research community  knoblock  1; christensen  1; bacchus & yang  1 . 
1 	the route-finding task 
we chose a route-finding task to demonstrate the utility of stratified case-based reasoning because this task is an important area of activity in robotics and is amenable to hierarchical problem solving. our taskinvolves finding an optimal or near-optimal path between a given pair of start and goal positions through a field containing obstacles. we chose to work with fields described by n x n arrays of positions  where n is a power of 1. this allowed us to define a simple abstraction hierarchy in which an abstract position at level 1 position  r  c   zero indexing  abstracts over the following four ground-level positions: 

　figure 1 shows a situation in which s and g denote the start and goal positions. the figure on the left is a ground level field containing 1 positions  where the grey associate with each position the set of operators that can be used to traverse it. thus  each unblocked position at the ground level is associated with all possible operators  which are shown in figure 1. each blocked position is associated with the empty set of traversal operators since traversal through them is impossible. 
　determining the available operator set for each abstract position involves determining  1  what operators are available for each of the four positions it abstracts and  1  which of the six operators  if any  are still possible after joining these four lower-level positions. for example  while all six traversal operators are available for the top-left abstract position  the only operators available for the position to its right are {a c  f}  i.e.  the others are unavailable because no traversal through this abstract position can reach the position below it . 
　we restricted our consideration to fields whose obstacle configurations guarantee that hierarchies created using our abstraction operators satisfy the downward refinement property  bacchus & yang  1   i.e.  every abstract solution can be refined to a concrete solution  if a concrete solution exists .1 thus  we considered only fields for which hierarchical problem solving reduces search. 
　the stratified cbr approach to this problem is to retain and reuse the solution paths found at every level of abstraction in hierarchical search. retaining abstract 
solutions decreases the cost of finding the most similar stored solution path because the distance from the new start and goal to these paths can be accurately measured at the highest levels of abstraction  where search is much less expensive  i.e.  since the fields are smaller in size . 
1 	algorithms 
this section introduces two non-cbr algorithms and five cbr algorithms  table 1  that can be applied to the route-finding task. each of the cbr algorithms re-
　　1  the downward refinement property is satisfied for our abstraction operators if  1  all adjacent obstacles are arranged in rectilinear regions and  1  whenever the length of a sequence of adjacent obstacles is at least the size of an abstract region at some level of abstraction  then its width is at least the region size minus 1. 
	branting and aha 	1 
non-cbr algorithms 
we considered two non-cbr algorithms for the routefinding task. the first is best-first search  a*  using manhattan distance as the heuristic estimation of distance from the current position to the goal position. the second is hierarchical a*  which uses a* to find a path from the start position to the goal position in the highest level abstraction of the given field. at each lower level of abstraction  search by a* is restricted to positions falling within the solution path at the next higher level of abstraction. 
　the cases used by the cbr algorithms described below are generated by hierarchical a*. given an abstraction hierarchy for a particular field and start and goal positions  hierarchical a* generates a path connecting the start and goal positions at every level of abstraction. each solution at a given level of abstraction is treated as a separate case. a refinement of a case  i.e.  a solution at the next lower level of abstraction  is termed a child of the case  and a case is termed the parent of its refinements. since distinct positions at the ground level may be identical at more abstract levels  distinct cases at a lower level may have identical parents. cases can therefore be organized into a forest of taxonomic trees. a case library consists of a taxonomic forest of cases sharing a common abstraction hierarchy but distinct pairs of start and goal positions. 
1 	ground level cbr algorithms 
the simplest of the cbr algorithms is ground cover  table 1   which searches the case library for ground solution paths that include the new start and goal positions. if any are found  then it returns a randomlyselected shortest solution path. otherwise  it invokes a* to find a solution. 
the second ground level cbr algorithm is ground 
closest  table 1   which also searches the case library for ground solution paths that include the new start and 
1 	case based reasoning 
goal positions. if none are found  then ground closest adapts each ground case  i.e.  uses a* to locate the shortest paths joining the new start and goal positions with the stored case's solution  and returns the shortest adapted solution. thus  this algorithm supports partial matching. to prevent retrieval from increasing in proportion to the size of the case library  ground closest uses a modification of a* that prunes each node n for which f n  is greater than the cheapest adaptation found so far. thus  ground closest performs bestfirst search for the shortest adaptation paths within each case  but branch-and-bound search through the case library for the case with the shortest adaptation paths. 
1 	stratified cbr algorithms 
the three stratified cbr algorithms can reuse case solutions stored at any abstraction level. each of these algorithms starts by retrieving from the case library the set of most specific matching cases  i.e.  lowest-level cases whose solutions include abstract positions that abstract the given start and goal positions . this search begins at the root of the case library  recurses with its children  i.e.  top-level abstractions of solved cases   and continues recursing until it reaches the ground level  in which case the segment of a solution connecting the new start and goal positions is returned  or cases that no longer cover both the start and goal positions. 
　in the latter case  the first algorithm  cover  table 1   randomly selects one of the most specific matching cases and performs hierarchical a* starting at the next lower level of abstraction  restricting search to positions falling within the solution path in the most specific matching case. 
　in contrast  the second algorithm  closest  table 1   supports partial matching between new problems and previous solutions. starting with the most specific 


matching cases  or the most abstract cases  if no cases match  closest finds the refinements of each case  i.e.  the case's children   adapts each refinement  i.e.  uses a* to find the shortest adaptation paths from the start and goal positions to the solution path at that level of abstraction  restricting search to positions in the parent case's adaptation paths   and selects the refinements having the shortest adapted solution paths.1 closest recursively calls these three steps until the ground level is reached  at which time it randomly selects and returns an adapted case. 
　the final algorithm  closest threshold  table 1  attempts to recognize situations in which adapting an existing case will be more expensive than problem solving ab initio. closest threshold behaves identically to closest if there are matching cases. however  if there are no matching cases  then closest threshold uses a* to find the shortest path from the start to the goal position at the highest level of abstraction. if there are top-level cases whose adapted solution paths are no longer than the path length found by a*  then closest threshold treats these cases in the same manner as closest. if there are no such cases  then closest threshold uses hierarchical a* rather than cbr. 
　1 to prevent the performance of closest from degrading when there are large numbers of redundant cases  i.e.  cases with equally short adapted solutions   closest performs two additional types of pruning. first  among cases with the shortest adapted solution paths  closest retains only those for which the sum of the lengths of the paths from the start and goal positions to the previous solution path are least. second  below the highest level of abstraction  if there are multiple cases for which the paths from the start and goal positions to the previous solution path intersect the previous solution path at identical positions  i.e.  multiple cases for which the reusable segments of the old solution paths are indistinguishable   then only one such case is retained. 

　1 empirical evaluation 
previous work has demonstrated the advantages of hierarchical problem solving over non-hierarchical methods e.g.  holte et al.  1; knoblock  1; bacchus & yang  1 . we focus here on demonstrating the utility of reusing the abstract solutions generated by a hierarchical problem solver. therefore  this section describes empirical comparisons of case-based vs. non-casebased approaches for hierarchical problem solving. we also include comparisons with non-hierarchical methods  both case-based and otherwise  to verify that the more storage-intensive hierarchical approaches deliver better performance. 
1 	hypotheses and experimental variables 
the empirical hypotheses explored in this section are: 
1. reusing stored case solutions decreases search costs. 
1. reusing abstract case solutions decreases costs more than reusing only ground-level solutions. 
1. partial matching yields lower search costs than perfect matching. 
1. preventing expensive partial matching  via thresholding  yields the best performance on this task. 
we will compare the five algorithms described in section 1 against a* and hierarchical a*. the primary dependent variable of interest is work effort as measured by the number of nodes expanded by a* in the course of executing each algorithm.1 we will also not discuss the lengths of the algorithms' solutions since they were all very similar.1 the independent variables are 
1. the size of the case base  
1. the number of abstraction levels  and 
1. the distribution of selected problems  i.e.  start and goal positions . 
　1  we ignore the additional computational costs incurred by the hierarchical and case-based algorithms. the one-time cost of building a hierarchy is 1 n x o   where n is the number of ground level positions and o is the number of traversal operators. this cost is amortized over each set of training and testing problems drawn from a single ground level field and obstacle configuration. the cost of case retrieval is reduced to a constant by hashing cases on their abstraction level  start position  and goal position. 
　1 in experiment 1  their averages varied from 1  a*  to 1  ground closest . 
branting and aha 1 

we varied one of the independent variables listed above in each of three experiments. the settings for the other two variables were held constant at default values  see table 1 . all the reported results refer to averages over sets of 1 testing problems. each set is decomposed into ten subsets often problems. each subset refers to a different layout of obstacles  where the layouts are constrained as described in section 1. each algorithm was applied to the same set of training and test sets. 
varying the number of cases 
we varied the number of stored cases while fixing the field size to be 1 x 1 and the number of abstraction levels to three. the problems were selected so that the start and goal positions were on  opposite ends  of the field  meaning that the value of one randomly selected dimension  e.g.  row  was chosen randomly and the other  e.g.  column  was fixed to maximally distance the two positions. 
　figure 1 summarizes the results. since a* and hierarchical a* do not use stored cases  their results remain constant. the five cbr algorithms all outperformed a*. ground cover's work effort decreased linearly with library size  indicating that it found almost no stored matching problems for small-sized case bases but occasionally found such matches for larger case bases. 
ground closest outperformed ground cover for 
larger case bases  which indicates the benefits of adapting stored solutions when they are sufficient in number and similarity to new problems. 
　the performance improvement delivered by the three stratified cbr algorithms was dramatic. cover's average work effort decreased linearly with library size  in-
   past cases with short solution paths at the ground level are less likely to contain segments useful for subsequent problems. similarly  the benefit of case reuse is less likely to outweigh the overhead of retrieval and adaptation in new problems involving start and goal positions that are near to each other  since such problems can be inexpensively solved ab initio. 
1 	case based reasoning 
dicating the utility of reusing stored solutions at different abstraction levels. this approach significantly outperformed ground cover  p   1 for 1 training cases   indicating that the stratified approach is better than the non-stratified cbr approach for this task. similarly  closest significantly outperformed ground closest  p   1 . finally  closest significantly outperformed cover  p   1   indicating that partial matching is preferable to perfect matching on this task. however  no significant difference was found  i.e.  for 1 training cases  suggesting that the thresholding algorithm outperforms closest. thus  these results support our first three hypotheses  but not. our fourth. 
varying the number of abstraction levels 
in this experiment  we fixed the size of the ground level field to be 1 x 1 and varied the number of abstraction levels. the results for a* and the non-stratified cbr algorithms remain constant since they are not effected by stored cases at varying abstraction levels. 
　in contrast  figure 1 shows that the search costs of the hierarchical problem solver and the stratified cbr algorithms decrease with the number of abstraction levels. cover  as expected  performs slightly better than hierarchical a* because it reduces search whenever it finds a perfect  abstract  match and otherwise does not incur additional search costs. the partial matching stratified cbr algorithms perform poorly when only a few abstraction levels are used because adaptation is costly when the positions along a solution path lie far from the start and goal positions. however  they perform significantly better than the other algorithms  i.e.  at least at the p   1 level  when four abstraction levels are used since adaptation is much less costly in the higher abstraction levels. although closest outperformed closest threshold  their differences were not significant. these results again support the first three hypotheses described in section 1 and contradict the fourth. 

varying the problem distribution 
in experiment 1  we varied only the way in which problems  i.e.  pairs of start and goals positions  were selected. we used the opposite ends strategy in the other experiments  which chooses positions that are maximally distant in the space along one axis and randomly selected on the other axis. this is a favorable bias for stratified cbr since it guarantees long solution paths  which increases the probability of reuse. we add two strategies here that decrease this probability: random.  which selects positions randomly  and opposite sides  which selects positions randomly but guarantees them to be on opposite sides of one of the two dimensions. these three strategies differ in the degree to which they prevent the selection of nearby start and goal positions. random allows selection of such pairs. opposite sides prevents this to some degree  and opposite ends prevents this entirely. 
figure 1 summarizes the results for this experiment. 
as expected  search costs rise for a* and hierarchical 
a* as the average minimum solution length increases  i.e.  it was 1  1  and 1 for random  opposite sides  and opposite ends respectively . this increase also yields abstract solutions that require less search to adapt  i.e.  since they cover more of the space   which explains why cbr performance improves as solution length increases. the stratified cbr algorithms again outperformed the ground cbr algorithms  and the stratified partial matching algorithms outperform cover. 
1 	summary 
the results of our experiments provide initial support for the first three hypotheses stated in section 1. the cbr algorithms outperform the non-cbr algorithms on which they are based  i.e.  especially for the opposite ends problem distribution   which supports the claim that solution reuse can decrease search costs. the stratified cbr algorithms outperform the ground level cbr algorithms  which supports the claim that the reuse of abstract case solutions further improves performance. the partial matching algorithms  i.e.  closest and ground closest   outperform the perfectmatching cbr algorithms  i.e.  cover and ground 
cover . finally  the results of closest threshold reflects how it mediates between these two extremes  but it does not outperform closest  contradicting our fourth hypothesis  i.e.  that thresholding yields the best results . however  we conjecture that  for case libraries for which the adaptation cost of the best case is sufficiently high  thresholding will be beneficial. 
1 	discussion and related work 
the distinguishing characteristic of stratified case-based reasoning is its reuse of stored solutions at all abstraction levels. holte et al.'s  1  alternating opportunism algorithm similarly uses hierarchical refinement to reduce search costs. it caches  in each state in the search space  information that simplifies a* search  i.e.  g n  and h n  values . their approach is complementary to ours in that it reduces search effort from a state-oriented rather than a solution-path perspective. 
　cbr adaptation methods are typically either transformational  which retrieve solutions and apply adaptation operators to revise them to solve a new problem  or derivational  which replay the derivations of problemsolving episodes  carbonell  1 . stratified cbr employs a transformation approach that uses more abstract solutions to index and guide the adaptation of less abstract solutions. since stratified cbr partitions cases by level of abstraction rather than by stages of goal reduction  it is applicable to tasks that use problem-solving methods other than goal reduction. moreover  we hypothesize that in tasks that use goal reduction stratified cbr will often order goals by degree of constraint more effectively than derivational analogy  because abstraction is often more indicative of degree of constraint than order of appearance in a goal-reduction graph. 
　the priar  kambhampati  1  framework for plan modification embodies many stratified cbr characteristics. priar retrieves solutions with minimum 
	branting and aha 	1 
predicted adaptation costs and uses causal dependency structures to guide adaptation via a minimum-conflict search strategy. these structures function as partiallyordered abstraction hierarchies for decomposing actions. retrieved abstract solutions are not guaranteed to be refinable and can be extended during adaptation  i.e.  with additional planning . previous work on priar has focused on its semantics and its applicability rather than on isolating the contribution of resuing abstract solutions. haigh et al.  1  integrate derivational analogy with a limited  i.e.  two abstraction levels  stratified cbr approach. their work focused on a route planning task rather than on isolating the contributions of stratified cbr. hanks and weld  1  describe a similar general framework that permits adaptation of abstract plans. however  unlike stratified cbr  this approach does not use more abstract solutions to index less abstract solutions. 
　explanation-based learning  ebl   mitchell et al.  1  resembles stratified cbr in that a macro derived by ebl algorithms from a proof of concept membership constitutes an abstraction of the proof  i.e.  a generalized example . however  ebl systems typically allow 
reuse at only a single level of abstraction for each generalized example  whereas stratified cbr allows reuse at any level of abstraction. 
　we believe that the stratified cbr approach could be beneficially incorporated into ebl algorithms  into hierarchical reinforcement learning approaches  kaelbling  1   and into other al approaches involving hierarchical problem solving. we view it as a general contribution to al research on abstraction and envision its incorporation into many multi-strategy systems. 
1 	conclusion 
this paper has described stratified case-based reasoning  an application of case-based reasoning to hierarchical problem solving. an empirical evaluation in a routefinding task demonstrated that this approach can lead to significantly lower computational costs than either hierarchical problem solving ab initio or ground-level cbr. moreover  the evaluation showed that reusing abstract solutions yields better performance than reusing only ground level solutions  that the performance benefit of stratified cbr increases with the size of the case base and with the number of abstraction levels  and that partial matching outperforms perfect matching. 
acknowledgement s 
many thanks to patrick harrison for supporting this research and for discussions leading to this paper. rob holte's input and feedback were also valuable. this research was supported in part by a visiting summer faculty research grant from the naval research laboratory. 
