 
　　　the design and prototype implementation of a deductive processor for efficient extraction of implicit information from explicit data stored 
within a relational data-base system is described. general statements  premises or inference rules  as well as queries are expressed in a canonical form as implications. from user queries  the system constructs skeletal derivations  proof plans  through the use of a predicate connection graph  a pre-computed net structure representing possible deductive interactions among the general statements. the system incorporates techniques for rapid selection of small sets of relevant premises  by proof planning ; development and elaboration of proof plans; proof plan verification; use of proof plans as a basis for determining data-base access strategies; and instantiation of plans   i . e .   turning proof plans into proofs  with retrieved data-base values. examples of the current capability of the system are 
illustrated. 
introduction 
　　　the deductive processor  dp  described in this paper has been designed to interface with existing and emerging relational data management systems  rdmss . given this orientation  we have 
made a sharp distinction between specific facts  n-tuples  which reside in an roms data base and general statements  rule-based knowledge or premises  that are directly accessible to the dp. since the number of general statements that may be required for a practical application is likely to be large  perhaps hundreds to thousands of premises   particular attention has been paid to the development of techniques for the rapid selection of relatively small sets of premises relevant to answering a user's specific request. premise-selection techniques are automatically invoked when deductive support is necessary to respond to a user's request; otherwise  queries  fall through  the dp and directly drive the rdms. 
　　　this  deductive inference by exception  principle suggests that the dp be viewed as an addon or enhancement to existing data-base searching capabilities1 such an enhancement can result in a major increase in the power of a data manage-
ment system by providing a means for extracting and deriving implicit information from data bases of explicit facts. further  as we shall see  the dp can aid a user in evaluating the u t i l i t y and/or plausibility of an inferentially obtained answer by displaying the evidence on which the answer is based. 
we briefly review some of the relevant work in 
the field of deductive question answering  outline our approach  describe the several components of our prototype dp  and illustrate by means of two examples the current operation of the system. 
approach 
　　　previous approaches to adding deductive capab i l i t i e s to data management have occurred primarily in the development of question-answering systems  simmons1*'1 reviews many of these . the primary aeductive methods that have been used are setinclusion logic  e.g.  converse1 and synthex1: techniques based on the  resolution  principle'1  e.g.  qa1 and mrpfj ; procedural-oriented deduction  e.g.  shrdlu1; and goal-oriented backward chaining  e.g.  mycin 
　　　the primary difference between these systems and our dp is in our use of planning. our system creates deduction plans to guide the generation of f u l l deductions. we believe such planning to be essential for cutting through the massive number of dead ends and irrelevant inferences which have impaired the performance of earlier systems. planning becomes even more important for systems involving large numbers of premises. selection of a manageably small set of possibly relevant premises can be based on such planning. 
　　　to this end we have designed and implemented a deductive processor that f i r s t builds derivation skeletons which represent possible deduction plans. once such plans are generated  the system will attempt to instantiate and verify the plans 
 examine substitutions for variables in premises . we have thus separated the premise-selection process from the process of verifying the consistency of variable substitutions. 
　　　the generation of derivation  proof  plans is centered around middle-term chaining . this process finds implication chains from assumptions to goals through the premises. middle-term chaining combines the processes of forward chaining from the assumptions in a query and backward chaining from the goals in a query.  in the case of no query assumptions  middle-term chaining defaults to backward chaining.  as chaining proceeds in the two directions  intersections are performed on the derived sets. when a non-empty intersection occurs  the system has found an implication chain from an assumption to a goal. the resulting chain is passed on to the proof plan generator  which extracts the premises whose occurrences are involved in the chain. subproblems may result  requiring further deduction or data-base search. the examples presented below will illustrate these processes. 

knowledge 	r e p r . - l : 	kellopp 

　　　the chaining process does not operate on the premises themselves but on a net structure called 
t n e
	 predicate connection graph  pcg . 	this graph 
is abstracted from the premises. when a premise is introduced into the system  the implication connections existing among the predicate occurrences in the premise are encoded into the pcg. further  the deductive interactions   i . e .   unifications1  between predicate occurrences in the new premise and predicate occurrences in existing premises are pre-computed and encoded into the pcg. the variable substitutions required to effect the unifications are stored elsewhere  for latter use by the proof plan verifier. thus  the pcg contains information on the implications within premises and the deductive interactions among the premises. during the generation of middle-term chains and proof plans  the system is aware of the existence of unifications among the premises  but it does not need to generate the unifications nor does it need to examine and combine the variable substitutions associated with the interacting unifications. the former is done by a pre-processor  while the latter is done by the verifier after proof planning. 
　　　although some connection graphs used in theorem-proving systems also contain information on the unifications among general assertions  resolution clauses in these systems   they are not used as a planning tool as is the pcg. the pcg most resembles sickel's clause interconnect i v i t y graph !1 in that both graphs represent the i n i t i a l deductive search space and are not changed in the course of constructing deductions. other graph procedures''' involve adding nodes to graphs as deductions are formed. more detail on the pcg is given in klahr . 
representation of information 
　　　the basic representation for general assertions  premises  is the primitive conditional' . this form is a normalized first-order predicatecalculus implication statement. the antecedent of the implication contains the assumptions  conditions  of the assertion; the consequent contains the goals of the assertion. conjunctions  disjunctions  and negations can occur on either side of the implication. each assumption and goal is a predicate occurrence consisting of a predicate  relation  and its argument terms   i . e .   variables  constants  or functions . 
　　　the primitive conditional was chosen because general assertions are usually formulated in the form of   i f . . . . t h e n . . .   implications. users can easily express and understand general assertions 
in this form and can easily control and understand proofs involving them. further  this form facilitates system discovery of deductive implication chains. 
　　　variables and constants occurring in premises and queries may be categorized into specific domain classes. 	for example  a variable  x  might be specified as being a laboratory and the constant 
 joe  as being a scientist. 	in attempting to 
knowlehff 
match argument strings involving these terms  the system will not allow the substitution of joe for x because they belong to different domains. the use of such semantic information eliminates certain deductive interactions among the premises and thus reduces the search space of possible deductions 1   1 . 
　　　semantic information in the form of usersupplied advice can also be given to the system. advice most typically involves recommendations on the use of particular premises or predicates in finding deductions. 	for advised premises  the system will try using them whenever possible in the course of constructing a proof. 	for advised predicates  the system will try chaining through occurrences of them  in premises . 	in the case of negative advice  specified premises and predicates are avoided in proofs. 
　　　advice may be given for a particular input query or stored in a permanent advice f i l e which the system accesses for each query. advice statements are in the form of condition-recommendation rules similar to the meta-rules used in mycin'. the conditions contain information about predicates  constants  and domain classes that may occur in query assumptions and goals. the conditions are matched against the input query and  if they are satisfied  the associated recommendations about the use of certain premises and predicates are activated. internally  advice is transformed into premise and predicate alert l i s t s  as well as negative alert l i s t s for negative advice   which are accessed in the chaining and proof-planning processes. 
　　　in addition to the information used by the deductive processor  there is also a f i l e of specific facts used by a data management system. this latter system searches for and retrieves specific facts needed to resolve subproblems resulting from premises. for our experiments with the prototype deductive processor  we have written a small lisp relational data-base management system. facts are stored relationally as n-tuples associated with a predicate  relation  name. when a particular predicate occurrence becomes a subproblem  the system has three alternative methods for resolving i t ; the decision is based on how the user defined the various predicates known to the system. if a predicate is defined computationally by a procedure  the procedure is executed to determine the predicate's truth value. if a predicate is specified by the user as defined primarily by its data-base values  the unresolved predicate is l e f t for data-base search. otherwise  an unresolved predicate occurrence is given further deductive support through the premises.  such predicate classification is currently mutually exclusive but need not be. an alternative control structure could try several methods for resolving each subgoal.  the examples below will show the interface between the deductive processor and the data management system  as well as examples of procedurally defined predicates. 
	- 1 : 	k 1 o g g 

	figure 1. 	deductive processor components system components 
     figure 1 displays the various components of the deductive processor as well as its position in a deductive data management system. 	the language processor is currently not a part of our initial prototype environment but will be incorporated at a later date. 	the control processor shown in figure 1 currently accepts premises and queries in primitive conditional form as well as user advice and commands. 	it accesses and coordinates the several system components described below. 
array initialization and maintenance 
     information abstracted from the premises is segmented into seven internal arrays. 	this segmentation contributes to good system structuring and increases processing efficiency. 	each predicate 
occurrence is assigned a unique integer index. 	information about a particular predicate occurrence is obtained from the array containing the kind of information needed by indexing into the array with the integer associated with the occurrence. 	the seven arrays are: 
     premise array: each entry represents a premise and contains a list of the occurrences  i.e.  occurrence indices  in the premise  the plausibility of the premise  and the premise itself  both symbolic  primitive conditional form  and english  for purposes of display. 
     predicate array: this array contains the relations known to the system. associated with each relation is its support indicator  i.e.  the method used to resolve the relation when it occurs as a subgoal  deduce  search data base  compute . 
　　predicate occurrence array: each entry represents a predicate occurrence and contains the following information about the occurrence: its predicate name  index into predicate array   the premise in which it occurs  index into premise array   the sign of the occurrence  positive or negative   whether the occurrence is in an antecedent or consequent of a primitive conditional  the main connective governing the occurrence  i.e.  conjunction or disjunction   and the numerical position of the occurrence within the premise. the information is compactly stored in a single one-word bit vector. 
　　arguments array: the argument strings of the predicate occurrences are stored in this array in a one-to-one correspondence to the positions 
of the occurrences in the predicate occurrence array. 
　　links array: deductive dependencies within premises are stored in this array. basically  these dependencies derive from implication connections among predicate occurrences within premises  klahr1 . this array is also indexed by occurrence integers. for each occurrence  a list of the occurrences it implies is stored in the entry corresponding to the occurrence's index. 
　　unifications array: each entry contains a list of the unifications  deductive interactions  associated with the given occurrence. the unifications array and the links array comprise the predicate connection graph. 
　　variable-substitutions array: the substitution lists association with unifications are stored in 

knowledge r e p r . - l : kellogge 

a one-to-one correspondence to the position of the unifications in the unifications array. 
middle-term chain generator 
     each input query is broken down  based on the logical connectives in the query  into sets of assumptions  from query antecedents  and goals  from query consequents . the predicate connection graph is used to find deductive implication chains between assumptions and goals.  wave fronts  are expanded out of assumptions and out of goals until an intersection is found  at which point the middle-term chain is identified and extracted. 
proof plan generator 
     for each middle-term chain generated  the system extracts the premises whose occurrences are part of the chain. any subgoals resulting from the premises are set up as requiring deductive support through the premises  data-base search  or procedural computation. subgoals are added to a proof proposal tree  which contains proof plans as they are being formed and developed. proof plans having no remaining deduce subgoals are then passed on to the verifier. 
proof plan verifier 
     the variable substitutions required by the unifications in a proof plan are examined for consistency. if there are no clashes  i.e.  no variable taking on more than one distinct constant value  then verification is successful. if there are any remaining subgoals requiring data-base support  the data management system is called to search the file of specific facts. 
display processor 
     the user has a wide variety of display options available to monitor the operation of the deductive system. 	in particular  he can examine middleterm chains generated  proof plans formed  subgoals  proof plan verification  data-base search requests  data-base values returned  answers  completed proofs  and premises used in proofs. 
computer examples 
     in figures 1 and 1 we illustrate examples of the current operation of our initial dp prototype interfaced to a small rdms.  both dp and rdms are 
written in lisp 1 and operate on an ibm 1 
computer.  
     in the first example  we illustrate the generation of short inference and search/compute plans for the question   what ships are closer to the kittyhawk's home port than the kittyhawk is   the query is first shown in english and then in the primitive conditional symbolic form that our prototype currently recognizes. 	the query is expressed in terms of a conjunctive goal composed of the predicates closer-than and home-port. constants  e.g.  kittyhawk  are specified by being 
knowledge repr 
enclosed in parentheses  while variables  e.g.  x and y  are not. one of the query goals  home-port  is to be given data-base support  i.e.  it has been characterized as defined by data-base values  while the other goal  closer-than  is to be deduced. since the antecedent in the query is empty  middle-term chaining defaults to backward chaining. the system back-chains from closer-than through premise 1. the plausibility  similar to certainty factors in mycin1  of the plan in this case is simply the plausibility of the single premise used. premise plausibilities range from 1 to 1 and are set by the user. 
     two new search requests  in addition to homeport  result from premise 1  as well as a compute relation containing functional arguments. computations for the functions and the relation are delayed until values for the variables x and y have been found in the data base  i.e.  values which satisfy the search requests . 
     the system sends the three search requests to the rdms  which finds two ships  the forrestal and the gridley  that are closer to the kittyhawk's home port  san diego  than the kittyhawk is. the system then displays the proof that led to the first answer  the forrestal . a proof using the other answer would be identical to this one except that gridley would replace forrestal in the proof  and the distance between the gridley and san diego would replace 1  the distance between the forrestal and san diego . the symbols g1  g1  etc.  represent nodes in the proof proposal tree and are used here for reference. g1 and g1 represent the original goals as also shown in the inference plan. g1  g1  and g1 are subgoals that resulted from premise 1  which was used to deduce g1. thus  these three subgoals are indented below g1. 
     the middle-term-chaining and proof-planning processes are more evident in the example in figure 1. the input query contains two assumptions  damaged and destination  and one goal  transport . taurus and ny are constants; cargo and x are variables. the query asks the system to find values for x that satisfy the query. the variable x is restricted to range over ships.  this is an example of a domain class specification for a variable. such domain specifications could also have been used in the previous example.  in the course of developing deductions  the system will not allow values to be substituted for x that belong to domain classes other than ships. 
     the inference plan shown in figure 1 has already been verified. to see the planning mechanism more clearly  we will refer to figure 1. the first middle-term chain generated connects the destination assumption to the transport goal via premise 1. this is shown by the unifications u and u1 in figure 1. the predicate occurrences involving the relations available and offload become subproblems. the former is to be given data-base support; the latter is deduced by a middle-term chain from the damaged assumption through premises 1 and 1. the chain is shown in 
figure 1 by the unifications u1 u1  and u1-. the 
	1 : 	kellogg 

 what ships are closer to the kittvhawk's home port 
 than the kittyhawk 	is  
query   oimp and closer-than x 	 kittyhawk  y  
　　　　　　　　　　　 home-port  kittyhawk  y         inference plan: 
	deduce 	g1 *closer-than x kittyhawk y 
　　search g1  home-port kittyhawk y premises used:  1  plan plausibility: 1 search/compute plan: 
search  ships kittyhawk search  ships x search  home-port kittyhawk y compute *greater-than  distance-between kittyhawk y    distance-between x y  
entering data base 
data-base search successful 
answer summary - variables: 
 x y  answers: 
 forrestal san-diego  
 gridley 	san-diego  
proof display: 
	deduced 	g1 *closer-than forrestal kittyhawk san-diego 
fact g1   ships kittyhawk fact g1   ships forrestal 
computed g1   greater-than 1 fact g1  home-port kittyhawk san-diego 
premises used:  1  proof plausibility: 1 type premise number to display  or 'eno': 
1 
  all 	x1  	 all x1  	 all 	x1  
 and  ships x1  	 ships x1   
 greater-than  distance-between x1 x1  
    distance-between x1 x1    imp  closer-than x1 x1 x1   
plausibility: 	1 
type premise number to display  or 'end': 
eno 
end display 
  i f the taurus were damaged while destined for new  york with a cargo  what ships could transport the 
 cargo to new york  
query   what  ship . 	x   
 and  damaged  taurus   
                  destination  taurus   ny  cargo   imp  transport x cargo   n y         inference plan: deduce gl *transport ship#x x1 ny 
	assume 	 destination taurus ny x1 
	deduce 	g1   offload taurus x1 x1 
	assume 	**damaged taurus 
	mid-term 	  returns taurus x1 
premises used: 	 1 1  	plan plausibility: 	1 search/compute plan: search 	-home-port taurus x1 search 	*carry taurus x1 
	search 	-available 	ship#x x1 
entering data base 
data-base search successful 
answer summary - variables: 
 x  
answers: 
 pisces  
 gemini  
proof display: 
	deduced 	gl 	*transport 	pisces 1l ny 
	assume 	*destination taurus ny oil 
deduced 	g1   offload taurus oil freeport assume 	  damaged taurus 
	mid-term 	**returns taurus freeport 
　　fact gll***home-port taurus freeport fact g1** carry taurus oil fact g1   available pisces freeport premises used:  1 1  proof plausibility: 

figure 1. deduction involving deduce  data-base search  and compute predicates 

end display 
figure 1. 	deduction using middle-term chaining 


knowledge reper.-l: kelloggdge 

two new subproblems are to be given data-base support. 	thus the plan generated uses three premises and contains three subproblems requiring data-base search. 	the plausibility of the plan is currently calculated by a fuzzy intersection  the minimum of the plausibilities of the premises involved1 . 
     the plan is then verified with variable substitutions inserted in the plan and in the search deductive processes is being supplemented by additional investigations into the encoding and 
integration of incomplete and plausible knowledge. 
acknowledgements 
     the research reported here has been supported by the advanced research projects agency of the department of defense and is monitored by the office of naval research under contract n1-c-1. 

requests  figure 1 . note the variable constraints in the search requests. the variable x1 represents the home port of taurus; values found for this variable must be the same as those found for x 1 in the available search request. the proof aisplay is given for the first answer found  the pisces . 
     in figure 1 we note that the unifications u  and u1 were computed when these premises were first entered into the system and stored in the pcg. also stored in the pcg were the implication connections within the premises  e.g.  between damaged and returns  between returns and offload  and between destination and transport. the unifications u-   u-  and u1 were computed after query input  because they involve predicate occurrences in the query  and serve to locate possible middle-term-chain end points. once these end points were identified  only the pcg was used for middle-term chaining. 
summary and future plans 
     we have described a deductive system specifically designed to provide inferential capability for a data management system. from a set of general assertions  the system generates skeletal derivations or proof plans in response to given input queries. these plans are then used to trigger data-base search requests for the specific facts needed to instantiate and thus complete proof plans  turning them into proofs and answers. general information is thus used to guide and direct the proof-planning process and to identify subproblems that may be resolved by data-base search or by computation.  or subproblems may be left open in the display of incomplete proof plans to the user  thus identifying information which cannot be found within the system but which the user may be able to supply from without.  
     we are currently expanding the prototype along several different dimensions in line with our goal of eventually incorporating the deductive processor into an operational data management system and language processor environment. a number of improvements in man-machine interaction and user displays are being made in order to allow users to have more direct and flexible control of the proof-plan-generation and data-base-search processes. additional semantic constraints oh the generation of plans will be introduced through the 
1. 1. 1. 
1. 1. 1. 
1. 1. 1. 
references 
davis  r.  buchanan  b.  and shortliffe  e. production rules as a representation for a knowledge-based consultation program. 
artificial intelligence  1  1  1. 
green  c. c. theorem proving by resolution as a basis for question-answering systems. in machine intelligence 1  meltzer  b. and michie  d.  eds.   edinburgh university press  edinburgh  1  1. 
kellogg  c. h.  burger  j.  diller  t.  and fogt  k. the converse natural language data management system: current status and plans. proceedings of the symposium on information storage and retrieval. acm. new york. 1. 1. 
kellogg  c  klahr  p.  and travis  l. a deductive capability for data management. in systems for large data bases  lockemann  p. c. and neuhold  e. j.  eds.   north holland  amsterdam  1  1. 
klahr  p. the deductive pathfinder: creating derivation plans for inferential questionanswering. ph.d. dissertation  computer science department  university of wisconsin  madison  december 1. 
klahr  p. planning techniques for rule selection in deductive question-answering. in pattern-directed inference systems  waterman  
d. and hayes-roth  f.  eds.   academic press  new york  1. 
kowalski  r. a proof procedure using connection graphs. journal of the acm  1  1  1. 
mcskimin  j. r. the use of semantic information in deductive question-answering systems. tr-1  university of maryland  colleqe park  1. 
minker  j.  fishman  d. h.  and mcskimin  j. r. the q* algorithm-a search strategy for a deductive question-answering system. artificial intelligence  1  1  1. 

use of a semantic net to further restrict the range of variables  as well as through extensions to the existing semantic-advice condition-recommendation formalism. work in these two critical areas of improved user and semantic control of 
knowledge 
1. robinson  j. a. a machine-oriented logic based on the resolution principle. journal of the acm  1  1  1. 
p r . - l : kellogg 1 1 

1. schwarcz  r. m.  burger  j. f.  and simmons  r. f. a deductive question-answerer for natural language inference  communications of the acm  1  1  1. 
1. shostak  r. f. refutation graphs. artificial intelligence. 1. 1  1. 
1. sickel  s. 	a search technique for clause interconnectivity graphs. 	ieee transaction 
on computers  c-1  1  1. 
1. simmons  r. f. answering english questions by computer: a survey. communications of the acm  1  1  1. 
1. simmons  r. f. natural language questionanswering systems: 1. communications of the acm  1   1  1. 
1. shortliffe  e. h. computer-based medical consultations: mycin. american elsevier  new york  1 
1. travis  l.  kellogg  c  and klahr  p.  
inferential question-answering: extending converse. sp-1  system development corporation  santa monica  calif.  1. 
1. winograd  t. understanding natural language. academic press  new york  1. 
1. zadeh  l. a. fuzzy sets. information and control  1  1  1. 
k n o w l e d g e r e p r . - l : k e l l o 
1 

spark: a system for 
parallel representation of knowledge 
gerald a. wilson 
	computer 	science laboratory 
naval research laboratory washington  d.c. 1 
in 	the 	system 	for 	p a r a l l e l 	representation 	of 
knowledge  spark  the ingredient of concern is not the h i g h - l e v e l   human-like  modeling of knowledge  but the compact  e f f i c i e n t   and e f f e c t i v e i n t e r n a l representation and use of the knowledge. spark employs a knowledge base representation technique which has been shown to be as much as seven times more e f f i c i e n t for information r e t r i e v a l than some other r e l a t i o n a l r e p r e s e n t a t i o n s . at the same time  t h i s technique  c a l l e d the p a r a l l e l representation  par  technique  can also compact the knowledge base by a f a c t o r of two or more. what d i s t i n g u i s h e s spark from data management systems is that t h i s e f f i c i e n t and e f f e c t i v e r e t r i e v a l mechanism also provides a powerful deductive inference c a p a b i l i t y . 
	two types 	of 	p a r a l l e l i s m 	are 	employed 	in 
spark  one achelved by data s t r u c t u r e s anc the other by p a r a l l e l processing. both are made possible by the d i s t i n c t i o n made between the   s t r u c t u r e   and the   c o n t e n t   of d a t a . in human problem solving the s t r u c t u r e is the general concept while the content is the sets of items which  when combined with the s t r u c t u r e   make one or more instances of that concept. thus   t r a n s p o r t i n g a from x to y  is a concept while 
  c a r r y i n g the block from the f l o o r to the t a b l e   is an instance of that concept with the content: c a r r y i n g ; b l o c k ; f l o o r ; and t a b l e . for the basic constructs  the i n d i v i d u a l f a c t s and inference r u l e s of the knowledge base  par employs templates to represent the s t r u c t u r e and sets to specify the content. for example  the c o l l e c t i o n of f a c t s about objects supported by the t a b l e would be given by: 
    r   x   y   {   s u p p o r t s   / r     t a b l e   / x   
 block cone lump hammer  / y   
where  r x y  is the template s p e c i f y i n g the concept of a binary r e l a t i o n w i t h two independent arguments. the sets associated w i t h r  x  and y can be used to form s p e c i f i c instances by appropriate s u b s t i t u t i o n s   in t h i s case simply ordered cross products of the s e t s . to index the knowledge base par employs meta-templates and super-sets in a corresponding manner. the indexing s t r u c t u r e proovides a compact form which f a c i l i t a t e s e f f i c i e n t search and r e t r i e v a l . thus the representation is p a r a l l e l because any s i n g l e symbol appearing in a par s t r u c t u r e can represent an unbounded number of instances of that symbol in the knowledge base. 
       the second type of p a r a l l e l i s m is m u l t i processing made possible by the meta-templates and super-sets of the index s t r u c t u r e . the meta-templates are cannonlcal b-trees which p a r t i t i o n the knowledge base i n t o d i s j o i n t c o l l e c t i o n s of d a t a . when a query p a t t e r n matches n meta-tempates  n independent processes may be created to complete the r e t r i e v a l match  thus performing many r e t r i e v a l s in p a r a l l e l . 
       spark  w i t h the par technique  is not posed as a panacea for a l l knowledge base management problems. several c o n s t r a i n t s were assumed in the development: 
 1  very large knowledge bases  more than 1**1 b i t s   are to be commonly employed. 
 1  there is a s i g n i f i c a n t degree of i n t e r r e l a t i o n s h i p among the elements of the knowledge base. if the knowledge base is viewed as a c o l l e c t i o n of n - t u p l e s   then any d i s t i n c t argument of a tuple has a high p r o b a b i l i t y of appearing in m u l t i p l e t u p l e s . 
 1  search and r e t r i e v a l are the preponderance of knowledge base o p e r a t i o n s . 
 a  search and r e t r i e v a l may be e q u a l l y l i k e l y f o r any combination of arguments  i . e . a query n - t u p l e may have i n s t a n t i a t e d any combination of argument p o s i t i o n s   the remaining p o s i t i o n s being l e f t f r e e . 
 1  the representation must a l l o w semantic  domain s p e c i f i c   c o n s t r a i n t s to be used in the search and r e t r i e v a l process. 
 1  sets should be treated as s e t s . 
 1  the representation should f a c i l i t a t e the use of i n f e r e n c e . 
these c o n s t r a i n t s appear to be q u i t e general and r e p r e s e n t a t i v e of a large v a r i e t y of r e a l i s t i c knowledge bases. 
       the p a r a l l e l representation technique employed in the spark system is posed as an approach to i n t e l l i g e n t knowledge base management   i . e . management employing inference  for very l a r g e knowledge bases. p r e l i m i n a r y r e s u l t s from a s i m p l i f i e d model and analysis of the technique i n d i c a t e the p o t e n t i a l for s i g n i f i c a n t storage and search processing savings over some other r e l a t i o n a l r e p r e s e n t a t i o n s . i t i s s i g n i f i c a n t t o note that the space savings due to the knowledge base compression a b i l i t y of par do not cause an increase in the e f f o r t required to search the knowledge base on the average. the search mechanism can accomplish i t s task more e f f i c i e n t l y in f a c t . this is due p r i m a r i l y to the e l i m i n a t i o n of any c o n f l i c t between the manner in which the i n f o r m a t i o n is stored and the manner in which it is u t i l i z e d by the search mechanism. because the par technique is intended as an i n t e r n a l repres e n t a t i o n of i n f o r m a t i o n it can be adapted to many 
d i f f e r e n t high l e v e l e x t e r n a l 	r e p r e s e n t a t i o n s . 
       the implementation and t e s t i n g of spark is c o n t i n u i n g at the naval research laboratory. once the system is f u l l y o p e r a t i o n a l experimentation w i l l be made w i t h large p r a c t i c a l knowledge bases to f u r t h e r determine the strenghts and weaknesses of spark and the par technique. 

knowledge repr.-l: wilson 1 

approximate responses from a data base 
query system: an application of inferencing 
in natural  language 
aravind k. joshi and s. jerrold kaplan 
university of pennsylvania 
department of computer and information science 
the moore school of electrical engineering philadelphia  pennsylvania 1 
ronald m. lee 
department of decision sciences 
the wharton school 
university of pennsylvania 
	philadelphia  pennsylvania 	1 
　　　our' goal is the development and application of various techniques for generating approximate responses to data base queries. an  approximate response  is a response other than a direct answer to the question. approximate responses are frequently referred to by linguists as  indirect answers  or  replies   e.g. in bs1 . what is approximate is not so much the response as the relationship between the response and the i n i t i a l query. our approach is to regard an interaction between a user and a data base as a discourse  having the properties and constraints normally associated with human dialog.  conversational postulates of grice  g1  are examples of such constraints.  many of the conventions of human dialog can be implemented through approximate responses which  for instance  1  aid a user in formulating a suitable alternative query when the precise response to the i n i t i a l query would be uninteresting or useless; 1  inform a user about the structure or content of the data base when the user is unfamiliar with i t s complexities; and 1  summarize at an appropriate level  eliminating unnecessary detail. 
　　　natural language  nl  query systems are of benefit to users who are only partially familiar with the structure and/or content of the underlying data base. such  naive  users are typically hampered by their lack of knowledge in formulating a query which w i l l retrieve the. desired information. we believe that nl can do more than simply provide the user with a convenient  higher-level replacement for a formalized query syntax. nl questions frequently embed information about the user's understanding of the structure of the data. this information can be exploited to inform and guide the user in the use of the data base. 
　　　of particular interest to us is the key role that shared knowledge between conversants plays in the effectiveness of human dialog. 	as observed in  ch1   dialog tends to proceed with statements which offer a specific piece of 'new' information to the conversation which is differentiated from information considered as 'given' or already known 
* this work is partially supported by nsr grant mcs 1. 
we wish to thank peter buneman  rob gerritsen  and ivan sag for many f r u i t f u l discussions. 
to the other party. breaches of this 'given-new contract' can point to the need for additional background information to be supplied in order for communication to be effective. we believe that this observation can be effectively utilized within the context of queries to a data base system. our approach here is to pay special attention to the 'given' information contained in the user's questions in the form of presuppositions. if these turn out to be false  we interpret this as a signal that the user misunderstands some aspect of the data base's structure or content and is in need of additional c l a r i f i c a t i o n . an approximate response e x p l i c i t l y contradicting the failed presupposition and perhaps suggesting an alternative is appropriate  as it is in human dialog. such a response serves to correct the users mis impressions and provide suggestions for alternatives  hopefully relevant and useful ones. 
　　　a presupposition of a sentence s can be broadly defined as any assertion that must be true in order for s to be meaningful. 	in the case of questions  the presupposition must be true for a direct answer to be meaningful. 
　　　presuppositions come in many forms. there are presuppositions which are primarily syntactic  jw1 . others deal with implied restrictions on the size  or a claim about the completeness of the answer set  bs1 . of particular interest in a data base context are those presuppositions of an nl question which are implied by a corresponding formal query to a given data-base structure. we have observed that each stage in the execution of a formal query  except for the final one  has an interpretation as a presupposition of the nl question. if a particular stage of execution returns a null set  the corresponding presupposition has failed and can be explicitly contradicted  rather than returning an obviously uninformative or misleading null response. 
consider the query 
 which linguistics majors got a grade of b or 
better in cs1   
assuming a suitable structure for the data 
　 see figure one   a corresponding formal query might perform the following operations: 1  find the set of students and restrict it to linguistics majors; 1  find the set of courses and restrict it to cs1; 1  find the class l i s t  set of students  associated with the result of 1; m  restrict the class l i s t of 1 to those with grades   b; and 1  intersect 1 with 1 to produce the response. an empty set at each stage could be used to produce the following approximate responses contradicting the failed presuppositions: 1  there are no linguistics majors; 1  there is no course  cs1 ; 1  no students were enrolled in cs1; and 1  no students received a grade of b or better in cs1. a failure in the final stage leads to the direct answer none. it is worth noting that different data structures w i l l reveal different presuppositions. for instance  a different data base might produce the response  no linguistics majors took cs1.  

knowledge 	r e p r . - l : 	joshi 
1 

     another type of approximate response deals w i t h the generation of a response to a s u b s t i t u t e query. for i n s t a n c e     i s venus the f o u r t h p l a n e t     may be responded to by   n o   it is the second 
p l a n e t .     s e e  l1  f o r s i m i l a r examples . 	a de-
t e r m i n a t i o n of t h e focus and t o p i c of the question can be used to generate an appropriate a l t e r n a t i v e   as opposed to  say    n o   mars is the f o u r t h p l a n e t .   s y n t a c t i c and c o n t e x t u a l cues are 
under i n v e s t i g a t i o n to determine the t o p i c and focus i n t h e face o f p a r t i a l i n f o r m a t i o n . 	careful c o n s t r u c t i o n of the formal query can provide a r e l e v a n t piece o f a l t e r n a t i v e i n f o r m a t i o n f o r f r e e by s e l e c t i n g the most appropriate access path to the d e s i r e d i n f o r m a t i o n . 
     an important convention of human conversation is t h a t no p a r t i c i p a n t monopolize the d i s c o u r s e   so t h a t c o n t r o l can be shared. one i m p l i c a t i o n of t h i s i s t h a t a l l responses given i n a convers a t i o n a l mode must be s h o r t . thus where the system 
would otherwise respond w i t h a lengthy l i s t   we would p r e f e r to be able to r e t u r n a non-enumerat i v e   or   i n t e n s i o n a l   response . lengthy response sets could be summarized  or defined by a charact e r i s t i c o r a t t r i b u t e . for i n s t a n c e   the question  which employees engage in p r o f i t sharing   may be answered by l i s t i n g the extension of a set c o n t a i n i n g  perhaps  1 names  or by the i n t e n s i o n a l response   a l l v i c e - p r e s i d e n t s .   the summary might be computed from the data or i n f e r e d from the data base schema  and can be used to avoid unnecessary and d i s t r a c t i n g d e t a i l . i n these cases  the response may i m p l i c i t l y i n c o r p o r a t e the r e s t r i c t i o n s of the q u e s t i o n . for i n s t a n c e   a response to  which students were i n v i t e d t o the p a r t y     o f  the g i r l s l i v i n g i n west p h i l a d e l p h i a .   c l e a r l y i m p l i e s t h a t o n l y those g i r l s who are students were i n v i t e d  kh 1 . answers  which i n h i b i t e d browsing and query f o r m u l a t i o n   approximate responses  as they are used in human d i a l o g   can s i g n i f i c a n t l y increase the usefulness and convenience of data base query systems. 
