: this paper describes the development of an architecture and implementation of a graphical tracing system for the parallel logic programming language parlog. novel features of the architecture include a graphical execution model of parlog; a range of representational techniques that allow the user a choice of perspective and granularity of analysis; and ongoing work on graphical tools that provide user-defined visualisations of their programs  either before the program is run  or afterwards by demonstration from a textual trace. the aims of the architecture are threefold:  1  to aid program construction and debugging by providing an informative graphical trace of the program's execution;  1  to provide the user with a choice of representational techniques  at a preferred level of granularity; and  1  to allow users to define their own visualisations  that more truly map onto their conception of the problem  and which support the way they wish to view the execution information. 
1. 	introduction 
one of the central tenets of our current research on visualisation is that different visualisation techniques are optimal for different tasks and purposes. any representation necessarily makes some things explicit at the expense of others. in this work i aim to show how using different presentation styles  which show different aspects of the execution process  can produce a practical visual model of a parlog virtual machine  and one that can benefit teaching  tracing  and also debugging. 
　in this current work on parlog i am interested in letting users get their own perspective on the program  and one that suites their needs best. this has resulted in the development of a repertoire of representation techniques that give the user complimentary perspectives  using different levels of detail and abstraction. in addition users are able to come up with their own perspectives using special visualisation defining tools. 
　background material to the current discussion can be found in the following. parlog is described in gregory  1  and conlon  1 . a good review of program visualisation techniques can be found in myers  1  and utter and pancake  1 . a visual programming style front-end for 
parlog has been proposed by ringwood  1 . conlon and gregory  1  present an impressive system for the textual tracing of parlog  including the ability to closely monitor  incremental  i/o  processes  and communication channels. 
　this paper will first briefly introduce a basic model of the visual execution of parlog  see brayshaw  1a for a fuller treatment . this model will then be generalised to show how we can embed it within a series of visual stories of a program's execution. there is an inherent problem in many representation systems that in defining a representation some things are made explicit  others implicit  some things highlighted  some hidden. by providing different prespectives on the execution behaviour of the program we will attempt to demonstrate how a fuller and more informed view of the program can be gained from looking at the program as its different faces are revealed in the series of visualisations. then i shall discuss how we can further utilise these representational techniques so that users can modify them and produce their own visualisations  before finally adding some conclusions. all the representations use the same execution model  however the information is presented from different perspectives  emphasising different aspects of execution. 
1. 	a visual execution model of parlog 
parlog provides an interesting test case for the use of program visualisation  not only to try and generalise our own earlier work on visualisating prolog  eisenstadt and 
brayshaw  1; brayshaw and eisenstadt  1  1   but also to deal with the special dynamics of parallelism and associated problems like starvation and deadlock  e.g. see ringwood  1 . the basic model is built around the concept of the node representing a process  and the shading of the nodes indicating the process state  as in fig. 1 below . 
　
this then is the core. to it we now must add a more detailed execution model. the one i use is adopted from conlon  1   because it provides a good conceptual model for novices and experts alike of the workings of parlog. it considers process evaluation to proceed in four stages  namely testlcommitloutput/spawn  which are discussed in detail below. 
　test the clauses of the goal are tested to see if they are candidates. clauses are tested via or-parallel search. for each clause  two tests  of head and guard  are carried out by and-parallel search. clauses can be thought of as racing to be the first clause to satisfy both head and guard tests. 
　c o m m i t the process commits to the first clause to pass the test stage. all other input matching or guard evaluation  associated with other possible candidate clauses  ceases. the commit stage marks the end of the race between the guards. 
　output once a clause has been committed to  any output arguments can then be bound. 
　spawn the process then reduces to the sub-goals in the chosen clause body. as a result  concurrent subprocesses are spawned  one for each of the subgoals. the process succeeds if all the sub-processes succeed. if however one of the conjunctive sub-processes fails  then the overall process goal fails. if the spawned  reduced to  goal is a leaf node in the execution space  then the call succeeds immediately and the goal succeeds. 

figure 1. an example of the basic execution model adopted from  conlon  j 1 . 　figure 1 considers how this maps onto a simple database query. 
　
let us now consider the actions of parlog when doing this simple query. on attempting a goal  the process tests in parallel the head and the guard of all the clauses of the goal. in figure 1  we see that we are attempting to prove that drinks john what  is true against the database drinks mike  whisky   drinks john  beer   and drinks helen  wine . at the top of the figuure we see the test phase of a goal evaluation  a . the icon on the left shows we are currently evaluating a goal. the goal itself is drawn to the right of it. the mode declarations  whether an argument is input or output  arc shown by the shaded arrows above the goal. these correspond to the modes of the respective arguments.  indicates input  and  output. thus we can see that drinks's first argument must be input  and its second output. when we match the heads in parallel we produce a local evaluation space for each clause  as shown in the three boxes below the main process state icon. we can thus see at a glance what the different possible binding enviroments are. the goal is shown at the top of the box  the attempted head match below. database clauses are indexed by number on the left. variables are shown renumbered by subscripts  to avoid name clashes. in the main body of the clause the renaming is by number  however in the transient parallel evaluation spaces of the evaluation lest phase  we show the temporary variable bindings subscripted by letter. finally  arrows are used to show data-flow and pattern matching  in the same manner as eisenstadt and brayshaw  1 . thus we can see that of the three possible clauses  only the second clause drinks john beer  matches the goal d r i n k s   j o h n   what1 . 
　in the top part of figure 1  we can see that only clause two of drinks matches the database. as a result  clause two wins the test phase and is committed to. we write the name of the clause next to the node indicating the state of the process  and commit at that choice point. any output variables can now be unified  as we see figure 1 c . finally we spawn any new sub-processes in the body of the clause. as drinks is defined as a simple fact  the evaluation now succeeds as we see in the final snapshot  and hence we can see that the overall evaluation has succeeded with the result drinks john  beer . 
　the view we have just given is a very fine-grained account of the executon process. we can however develop a much coarser grained model  suitable for monitoring much larger programs. we do this simply by omitting details of the 
1 
unification of the program and considering instead just the name of the process and its state  indicated by the icon on the left-hand-side. if i want to see more information about the unification  the different possible binding environments in the test phase  or the data-flow arrow  i can use the same technique of zooming we introduced in  eisenstadt and brayshaw  1   to reveal more fine-grained information. 
also notice that because the coarse grained representation is only a superset of the fine-grained view  i can arbitrarily interleave coarse and fine traces. i will demonstrate this notation further when we incorporate this account in different representational models. 
1. integrated multiple representations of p a r l o g programs 
so far we have only introduced a model of individual processes. we now need to say how these individual views can be related together to give a model of execution that considers a program made up of many of these nodes. all the views that are discussed are tightly integrated. the user can readily swap from one to the other. coarse grained views can be opened out into fine-grained ones  and vice verca  by mouse-clicking on the nodes. ail the views of the program also have a replay panel  so the trace history can be wound back to the beginning and browsed through  running it forward and back as the user sees fit. the basic modus operandi of the current system is that the user runs the program and then gets a visualisation of it after the run  the user being able to choose different representation style as appropriate. other representations can be called up from a menu or the user can choose to build new representations  or use an existing user-defined visualisation . 
　an and/or tree gives us our kernel prepresentation style. amongst its strengths are its good mapping to the source code and compactness. our basic representation is introduced below. 
　
figure 1. the basic and/or 
　on the left we see the basic notation we use; ands are distinguished from ors by the conjunction bar linking arcs in the tree. alternative clauses can be viewed via ors and conjoined sub-processes in a clause body as ands. guards are distinguished by characteristic line stippling. once the processes commits to one particular choice  the successful guards change to a broader hashed line style to disunguish them from the surrounding unsuccessful ones. these unsuccessful nodes are left in whatever state they were in when the commitment took place. the fact that one of the clause guards is shown as being successful necessarily tree representations employed. 
implies that these others have not been. program dynamics can be revealed by using the replay panel which can show what happens and when. when a clause commits processes are shown in whatever state they were in when they were terminated  as this can be informative about how and why a particular process failed/successfully committed at a particular point. using dynamics  suspended goals can be see as evaluating root nodes  their lack of activity showing dynamically the suspension  and graphically we reinforce this model by showing a line underneath to distinguish them f r o m n o n - s u s p e n d e d n o d e s . 
　

figure 1. mixing coarse and fine-grained views. 
　
　in figure 1 all the nodes that we dealt with were coarsegrained descriptions. as we noted earlier we can however introduce fine grained information as well. to do this we can zoom in on selected nodes. in figure 1 above  we can see the effect of doing this for the nodes a and test1. in both cases we now have our fine-grained view of execution again. notice also  that at the moment that we have taken the snapshot in figure 1  tests is in the process of its test phase. we can see the individual clause evaluation environments below the bottom of the process node. the environments for a are not shown by default  other than when the process was in its test phase  but can be brought up again and displayed as at the point of commitment  by mouse-clicking on the node. 

figure 1. a process communication model. we can see what data is being communicated and between whom  by looking at what information is on which channel. notice  the re-occurring shapes caused by recursive filter and sift processes 　another description of parlog can be in terms of many intercommunicating processes. according to such a model  parlog can be thought of as a kind of object-oriented language. to support this view we have developed a process communication model  illustrated in figure 1. 
　
　in this model we view each process as a node  and link the processes together according to the data-flow between them. on these links we show either the data-flow that has occurred in an incremental fashion  or just the new elements  depending upon the user's preference. the nodes in the diagram are actually the same as tliose in the tree based views that we have been looking at previously. in the trees  each process was depicted by a node whose visual state descriptor mapped onto that of the process. we can use the same notation in the data-flow diagrams. we can view these data-flow diagrams as horizontal cross sections of the trees. however  the logical control shown in the trees is removed. 
the data-flow diagram need not be made up of simple crosssections; the slices can come from arbitrary parts of the program  hence arbitrary process communication can be seen. it is important to remember  however  that the relation between the two representations is essentially one of perspective; one representation emphasises control  making data-flow implicit  the other pulls data-flow between processes out front  but hides the overall control relations between the processes. 
　a final representation style we employ is based on the metaphor introduced in  domingue and eisenstadt  1 . this metaphor aims to make repetetive or cycle-based behaviour explicit. in parlog  constructs like recursion allow us to conceptualise a program carrying out some form 
1 
　

figure 1. a schematic view of the cycle based representation  call the cycle table. of repetetive process. although we could detect this type of behaviour in the other traces it would be implicit within the trace representation we are employing. the cycle table aims to make this explicit. the basic form is to consider a list of items to viewed on a per-cycle basis and place these items down one axis of the table. down the other we consider the individual cycles. the cross section of these two axis then tells us what event happenned on what cycle to what item. in parlog we have defined a default mapping between recursive processes and the cycle table. likewise we can also look at guards on each invocation of a processes  so that each new guard becomes a new conceptual  cycle . doing this allows us to compare the behaviour of the guard on each sucessive invocation. 
　
these representation styles form the basis of our library. 
thus currently we can distinguish between three different execution metaphors and two types of granularity. in the next section we will discuss how to use these execution metaphors with new canonical units defined by the user. moreover  the architecture is open to the extent that we can expand the system by embracing other metaphors of execution  whilst still maintaining our execution model and levels of granularity. the important notion has been the ability to see execution from different perspectives: goal reduction  process communication  and iteration. 
1. 	user defined visualisations 
one of the important proposed features of this system is the provision for users to be able to define their own visualisations. this section will describe possible ways we are exploring to go about doing this. taking any one of the representations as a template  users should be able to program a new mapping between their program and the trace they have generated  thereby producing a new visualisation  of their own design. we have here tried to design additional tools that let the user write this mapping more easily  without getting involved in heavy code production to program the debugger. to this end we will discuss two tools. the first lets the user define visualisation by selecting nodes from the call graph of the program before it is run. thus the programmer can  a priori  decide what trace to see of his/her program  design the trace  and then run the program. the second method works post execution. it allows the user to take a textual trace of the program and describe the mapping between representation template and textual trace in terms of it instances  as shown in the trace. thus the user can define his/her own visualisation based on a posthumous analysis of the trace. in addition however  the most crucial concept that distinguishes these user defined mappings is that they need not be in terms of individual nodes in the underlying trace. instead  groups of nodes can be considered as an individual clich1  and mapped as one into the representation template. thus higher level descriptions of the program can be rendered in the visualisation by showing the mapping these higher level events have to the underlying symptomatic footprint they leave in the program trace. by thus analysing the program trace and detecting the user defined footprints  these events can then be mapped into the representation template chosen  and a user defined visualisation produced. this is implemented as a sequential search of the trace history. however  as relative temporal information is also preserved  simulated concurrency is therefore possible. how this proceeds depends on the representation chosen  as we will discuss below. 
　in trees and process communication views arbitary mappings may be produced by describing the footprints of individual nodes. thus nodes in the tree need not be individual processes  but instead represent much larger cliches about the program. the way we propose to go about doing this is as follows. the template consists of an abstract model of the representation with a series of roles  c.g.nodcs  links etc.  which the user has to instantiate with a series of generators. these are defined as clich1 patterns to look for in the trace history  each such cliche is said to be defined by the characteristic footprint it leaves behind in the trace when it occurs. each trace footprint has a script associated with it  that is defined using one of the two techniques we will discuss below. for each process  the tracer searches the trace history of the process and its spawned subprocesses. at specific points in the script  the script can allow for nested clichd patterns. thus a script could say that between the call and exit of a particular process  go and look for cliches that occurred within this particular subtree. in this manner hierarchical abstractions can be produced. 
　for cycle tables the process is slightly different. here  there are three critical things to define. the first is what event marks the beginning of a new conceptual cycle. then what are the items  termed agents  that we wish to consider on these cycles. finally we have to define what are the events we wish to sec. the algorithm then computes the following. it first looks for cycle events  starting from a particular root process  and searching downwards. once it has found the intervals that make up the cycle  it then looks for each agent  to see which events clichds happenned to it in that particular cycle. if more than one event occurred the default is to show the last. earlier ones can be picked up using the replay notion introduced earlier. note that the dynamics of this display can be  though by no means need to be  very different from the parallel dynamics of the parlog code underneath. in other words  this model can be used to map a different conceptual model of the machine  and indeed might be used to serialise out a particular piece of 
　
code  if that helped the user's conceptualisation of the problem. 
　in order to make the definitional process of these mappings more easy  we arc constructing the following two tools. 
1 graphical techiniques for preexecution trace construction 
this is a generalisation of a technique developed for 
prolog in  brayshaw  1b . the user is first asked to choose a representational style. for whatever style they choose  they have to fill in the role fillers in the template they wish to use. they can do this by identifying the footprint in terms of the program's call graph. the call graph plots out the potential execution space of a program. from it the user can then specify which nodes in the execution space they wish to group together  and in what calling structure  in order to specify the footprint of the cliche they are interested in. the footprint is produced by specifying a pattern of nodes from the call tree. the footprint they are defining is that pattern in the final execution trace that constitutes an instance of the concept they are defining. each time they choose a node they are prompted to further conditionalise their choice by adding a script to that node. the final script for the footprint is the conjunction of the scripts for the individual nodes. variable naming is unique to the entire script and not just local to an individual node script  so constraints between local nodes can be so recongnised. the language for the scripts is prolog  since this is the language in which the tracer is embedded. in order to write the script the user is given a menu based authoring tool. 
　the tool allows the user to say what the patterns in the trace for this footprint arc. legal patterns are derived from the execution descriptors originally designed to describe prolog execution  eisenstadt  1   but here generalised to parlog. they include a call  with optional reference to a particular clause   call success or failure  and the options to be specific about the type of failure. to the left of this menu is the general script editing area. users can type into this if they so wish  or edit what is there. additional prolog goals can further constrain the script. additionally however the user can edit the script by means of a menu. suppose we selected an example node called a in the call graph. the default script is that for this pattern to hold  a is simply called  and we can express this by the line call a        . however  we can make this pattern much more specific. we can sec any calls to specific clauses of a  namely clauses 1  and 1   which resulted in failure due to sub-process failure. to do this and create the script  we have to choose the appropriate options from the menu  and then specify to a separate dialog what are the numbers of the clauses we wish to consider. nodes can be added to a footprint by repeatedly selecting them from the call graph and defining scripts in this way. the calling structure specified from the call graph between the individual nodes is also made a precondition of the script. once a clichd definition is complete a double click ends the definition process. where appropriate the user can call upon an icon editor to define a special symbol for that cliche or choose to use the built in representational styles. this definitional processes can be repeated to define any number of clich1s. 
1 defining visualisations from the textual trace of a progam 
　this second technique attempts to allow the user to work from a textual trace of the program. the textual trace has the same symptom descriptors as we saw in the previous section  again adopted from eisenstadt 1 . users can define a clich1  and associate it with the role filler of a template  by first choosing a representation style and a particular role. they can then define the clich1 footprints by selecting instances of these footprints as they have manifested themselves in the runtime trace of the program. several instances can be presented as examples of the footprint. where the new is information is more specific  this is then added to the definition of the script defining the footprint. when generalisations are involved the tracer has a series of syntactic rules it follows  true automated generalisations not being possible without a model of the language semantics . so for example when two examples differ by an argument containing different literals  it is assume that the value doesn't matter and the values are replaced by a variable. likewise the user can choose to automatically hollow out a term as short hand for making the example more generic. during the whole operation  the script that is being developed can be seen and edited  and augmented by additional constraints in prolog. once the scripts are defined  and depending upon the representation chosen  the new definitions are used to try and produce a new visualisation of the program. we see this process of visualisation production as potentially being an iterative one so that if the resulting views are not to the programmers' liking they can go back and edit the scripts to produce new ones. scripts developed from the call graph descriptions can also be re-edited in this fashion  and in light of the actual program execution as seen in either the textually based traces  or the four graphical based views. 
1. 	scaling issues and other approaches 
text tracing systems can be thought of as a type of program visualisation system. to convice yourself of this just consider the amount of layout  structuring and indenting that makes them readable. like their graphical conterparts  to be successful they really have to present the required information in an acceptable manner. thus any visualisation system  be it textual or graphical  has to think about scaleability  and when you consider scalcability  you have to consider the types of representations used. we have discussed ways of tackling the scaling issue for graphics elsewhere  brayshaw and eisenstadt  1 . the point 1 want to make here is that there isn't some special dichotomy which destinguishes textual visualisations from graphical visualisations. both are required to provide sufficient information  and selective information. exhaustive program traces  in either mode  can be too unwieldy to use  if not useless  and take too long. for either system  what is required is an informative trace of a limited part of the 
1 
program. i therefore believe that it is misleading to think that somehow text traces are  practical  while graphics ones not. they are different ways of exploring the information space  and what makes program visualisation exciting is finding what possibilities graphics affords for openning up new routes. 
1. 	conclusions. 
in this paper i have argued for the use of different perspective techniques to visualise parlog. these have focused on an execution model  embedded within three metaphoric description of the system  goal reduction  process communication  and iteration   and portrayed either at fine  coarse  or user defined levels of detail. these techniques are currently being realised in an implementation that has been described in this paper. the system is written in prolog using an extended and modified version of the parlog meta-interpreter for a subset of the language developed in pinto  1 . 
　the current development is particularly focussing on realising the type of flexibility of representation style discussed in section 1. in particular  one desirable future development would be to make the whole of the definitional process of these new footprints graphical  and minimise the amount of  programming  envolved. 
1* 	acknowledgement 
this work is currently supported by mrc/serc/esrc 
uk joint research council grant #1/cs1  the support of which is gratefully acknowledged. the author would also like to thank marc eisenstadt for many discussions about visualisation and program debugging  and for detailed comments on an earlier draft of this paper. 
1. 	