 
we investigate the ability of two central encoding methods to propagate reachability and relevance information using resolution steps. more specifically  we compare the ability of unit-propagation and higher-order resolution steps to propagate reachability and relevance information in the context of the linear and graphplan encoding schemes to the ability of a natural class of reachability and relevance algorithms that operate at the plan level. as a result of our observations and additional considerations  we experiment with a preprocessing step based on limited binary resolution that shows nice results. 
1 introduction 
the success of the planning as satisfiability  pas  approach 
 kautz and selman  1; 1  has led to various attempts to refine the initial methods used and to improve our understanding of its performance. in particular  various methods for generating formulas from planning instances have been compared  ernst et al  1   and various systematic alternatives to the original stochastic method have been examined  e.g.   li and anbulagan  1; bayardo and schrag  1  . still  many issues surrounding this approach are poorly understood. in particular  little is known about the influence of the encoding method on performance. 
concentrating on the two encoding methods proposed by 
 kautz and selman  1   the linear and the graphplanbased encodings  we examine their influence on the ability to propagate reachability and relevance information via unit propagation and  more generally  k-clause resolution. we do so by comparing the pruning ability of these techniques to that of variants of existing algorithms that operate on the original problem formulation  boutilieret al.  1 . 
　our work is motivated by unit resolution's central role in the davis-putnam algorithm  davis et a/.  1  and many of its offsprings  e.g.   freeman  1; crawford and auton  1; li and anbulagan  1; gomes et ai  1    and its use as a preprocessing step when stochastic methods are applied. moreover  a limited form of binary propagation is used in crawford's compact program for simplifying cnf formulas and is utilized in the blackbox planner  kautz and 
1 	planning and scheduling 
selman  1 . reachability and relevance analysis play a major role in recent planning algorithms  most notably in the graphplan planner  blum and furst  1 . 
　finally  motivated by some of our observations and by the fact that binary clauses form a significant fraction of the clauses within sat-encoded planning problems  we show that a simple and cheap preprocessing step based on limited binary resolution can yield nice savings in running time. 
　the paper is organized as follows: in section 1  we discuss the reachable-k algorithm and its counterpart  relevant-k. we compare each algorithm's ability to prune possible actions to that of k-clause resolution. a number of theoretical results are presented as well as an empirical comparison of the various methods for k = 1. in section 1  we motivate and explain the use of binary-binary resolution as a preprocessing step and show its effect on two recent efficient systematic algorithms. the overhead of this preprocessing step is relatively small  and in some cases it yields nice savings. we conclude with a discussion of future and related work in section 1. throughout the paper we assume basic familiarity with the essential ideas behind the pas framework and the graphplan algorithm. proofs appear in a longer version of this paper  although their central points are discussed here. 
1 reachability  relevance  resolution 
reachability and relevance analysis form an essential part of successful modern planning algorithms. the most notable example of reachability analysis is graphplan's planning graph  blum and furst  1   and many recent planners employ either reachability analysis  e.g.   bonet et ai  1    relevance analysis  e.g.   mcdermoot  1; nebel et al.  1    or both  kambhampati et al.  1 . the importance of reachability and relevance analysis has been noted in the context of decision-theoretic planning as well. for example   boutilier and dearden  1  employ relevance analysis to reduce the state-space  and  boutilier et al  1  describe a general method for reachability analysis for mdps. below  we discuss this method in a simplified form suitable for classical planning problems described using the strips representation language  fikes and nilsson  1 . we shall also present a counterpart of this method for performing relevance analysis and relate these algorithms to k-clause resolution in the context of sat-encoded planning problems. 

  = propositions that are true initially. 
  ' 
  = actions all of whose preconditions are in 
  neither nor are noops or a  is a noop whose effect is destroyed by 
  and deletes a precondition or an effect of 
we 	define 	inductively as follows: 
  = literals that appear in the effects of. 
  = actions whose preconditions appear in st and no subset of them appears in 
  = k-tuples of literal appearing in such that some subset of any set of actions from. mat has these literals as their effects appears in  where {l  p} as appropriate . 
  neither nor are noops  or aj is a noop whose effect is destroyed by aj}. 

figure 1: reachable-k 
1 	propagating reachability information 
reachable-k  boutilier et al  1  is an algorithm for estimating the states reachable from a given initial state. as formulated  it is quite general and applies to domains with nondeterministic actions and conditional effects. in figure 1  we present a simplified version of reachable-k that deals with deterministic  unconditional actions represented in the strips representation language. an important reason for our interest in it is its similarity to the influential planning graph construction of the graphplan planner  blum and furst  1 . in fact  it generalizes the ideas behind graphplan's planning graph  which is equivalent to reachable-1. we use ai to denote the set of actions feasible i steps from the initial state  si  to denote the corresponding set of propositions  and to denote constraints on these propositions  such that 
if then these propositions cannot cooccur after i steps. ca* denotes similar constraints on actions. here  *  {l  p}  where l is used when we restrict our attention to linear action sequences  and p is used when we allow concurrent non-conflicting actions  i.e.  actions that do not destroy each others' effects or preconditions and whose preconditions are not constrained not to co-occur . of course  for k = 1 the sets and are empty for all  1. fi-
nally  note that in this description  the set of possible actions contains all actions of the form noop{/   where / is a literal. 
　when k = 1  si and ai  represent the propositional and action levels of graphplan's planning graph  and csi and  hold their respective mutual exclusion constraints. we 
have not stated a termination condition for this algorithm  but one can be formulated based on the content of  or the index % itself. in the pas framework  where the number of time-steps is fixed  one would opt for the second alternative. reachable-k gives us sets of actions and propositions  that can occur after the performance of j actions  or j sets of concurrently non-conflicting actions  from the initial state. it is sound in the following sense: if a set of propositions or a set of actions is excluded by it at time j  we know that these cannot occur  resp. be executed  after j steps. 
　sometimes  all actions that can be executed at a particular time point in which p holds have -p as an effect. in that case  we can ignore the noop p  action  as it will not be part of any useful plan. however  as formulated  p will appear in reachable-k's next level. we denote by reachable* -k a variant in which noop p  does not appear in such a case. 
1 k-clause resolution and reachability 
k-clause resolution  or propagation  refers to the resolution of pairs of clauses one of whose length is k at most. the k = 1 variant  i.e.  unit propagation  is an integral part of all major algorithms for generating satisfying assignments. 
　we wish to compare the type of reachability information derived by performing k-clause resolution on sat-encoded planning problems  with the information obtained by running the reachable-k algorithm. by reachability information we mean constraints on the set of actions possible at a time point or constraints on world states  in the form of  e.g.  sets of unreachable propositions or k-tuples of propositions . our focus will be on the first type of constraints. we say that one algorithm generates more reachability information than another if it always generates a superset of the constraints on actions generated by the other algorithm  and there are instances in which this is a strict superset. we compare the two reachable variants with two encoding methods discussed in  kautz and selman  1 :1 the linear encoding and the more interesting graphplan encoding. 
linear plan encoding 
the linear plan encoding  kautz and selman  1  is a simple and natural method for translating a planning problem into a formula that is satisfiable iff there is a valid plan of length n  for some given n . the clauses in the linear plan encoding fall into the following classes: 
1. an action implies its preconditions prior to its execution; 
1. an action implies its effects following its execution; 
1. an action does not affect any other proposition  frame ax-ioms ; 
1. there is at least one action at each time point; 
1. there is at most one action at each time point. 
here  noop actions are not considered. in addition  the formula contains unary clauses describing the initial and goal states. in analyzing reachability effects  we ignore information about the goal state  discussed later in the section on relevance . 
　consider the mechanism by which resolution can yield reachability information: given the propositions that hold at the initial state  we can derive the negation of actions whose preconditions do not hold using unit propagation on axioms of class 1. propagating these unit clauses with the appropriate 
　　1 the third  state-based  encoding method cannot be generated automatically. 
	brafman 	1 

table 1: pruning effects of unary methods. is the number of possible actions. following entries hold number of actions pruned using: reachable-1  relevant-1  both combined  unit propagation on linear encoding using initial state  and using the final state. unit propagation in the graphplan encoding using the final state yielded no pruning. execution times for the reach/relevant algorithms are   1 seconds except for bw.c  1 sec.   and bw.d  1 sec. . 
instance of axiom class 1  we will obtain a disjunction of all actions that can be executed at the first time point. so far  this is identical to what reachable* -k provides. to propagate this information forward  we can resolve these action disjunctions with axioms of class 1 and 1. this  however  requires binary resolution. hence  except for the unlikely case in which a single action is possible  there is no more that we can derive using unit propagation alone. reachable* -1  on the other hand  can provide us with a list of all possible effects of these actions and possibly prune out future actions whose preconditions do not appear in this list. we conclude: 
lemma 1 in the context of the linear encoding  reachable* 1 yields more reachability information than unit propagation. 
example: consider a blocks' world domain with a single action schema move object source destination . its preconditions 	are: 	on object source   	clear object   clear destination  and its effects are: on objeet destination   clear source   -on object source   -clear destination   except when the destination is the table which is always clear . if we have k stacks of blocks initially   actions can be performed at the initial state  i.e.  moving a block from the top of a stack to the top of another stack or the table . this will be discovered by both algorithms. in particular  unit propagation will yield a disjunction of all these actions. we know that all blocks that are 1 or more blocks below the top cannot participate in the second move action. reachable-1 will find this out due to the fact that they are not clear. suppose that a is one such block. all initially feasible actions participate in a frame axiom of the form movewhich  in clausal form is resolving against 
 a  1 . if we could 
deduce -'clear a  1   we could rule out all actions that have it as a precondition. but if we are restricted to unit propagation  this requires deducing move-x for some initially feasible action  and we cannot make such a deduction. precise numbers for a number of instances appear in table 1. 
　if we propagated information forward using axioms of class 1 and 1 and binary resolution  i.e.  as discussed before lemma 1   we now have a set of disjunctions of the possible 
s1 	planning and scheduling 
effects  including frame effects  of the initially allowable actions. the number of such disjuncts is   where e is the maximal number of effects of an action and m is the number of actions that can be executed initially. in some cases  these dis-
junctions could contain a single literal  e.g.  when all initially allowable actions leave some proposition unchanged. when one of these disjunctions contains only literals that are negations of some action's precondition  we can deduce the negation of this action by resolving with axioms of class 1. 
　in the example considered above we would generate a disjunction of the form 
containing all time 1 actions whose negations have not been 
deduced. as discussed above  for all such actions  we can ob-
tain a clause of the form . resolv-
ing these binary clauses against the clause above  we obtain a unary clause   that can be used in conjunction with class 1 axioms to deduce the negations of actions whose preconditions include clear {a   1 . 
　using the effect disjunctions we deduce mutual exclusion constraints on actions  but these are already built into the encoding. in principle  one can resolve these effect disjunctions with each other  but any useful new resolvants already appear among them  simply based on the fact that an action cannot have a proposition and its negation as effects . consequently  we have: 
lemma 1 in the linear encoding  binary resolution is sufficient to conclude all possible reachability constraints. 
　reachable* -k propagates information forward in a similar manner but does not consider interactions between more than k actions or propositions. since such interactions can occur  we have: 
consequence 1 reachable* -k yields less information than binary resolution. 
the graphplan encoding 
the graphplan encoding differs from the linear encoding by its ability to consider multiple concurrent  non-interfering  actions  allowing one to obtain shorter plans which  in turn  can reduce the search space size. it constructs the following sets of clauses: 
1. an action implies its preconditions; 
1. an effect implies one of the actions that has this effect; 
1. there is at least one action at each time-point; 1. two conflicting actions cannot occur together. 
besides the obvious ability to consider multiple parallel  noninterfering  actions  the important difference between the graphplan and linear encoding is in axiom class 1  referred to in  ernst et al.  1  as explanatory frame axioms.  clauses in this class will contain positive occurrences of action literals and negative occurrences of state literals. 
　as in the linear case  using unit propagation we can infer which actions cannot be applied at the initial state. using axioms of class 1  we can propagate this information forward  deducing the negation of all effects that cannot be producal by the initially allowable actions. this information enables us to exclude actions whose preconditions cannot be produced. this forward propagation is essentially identical to 

reachable-1. if we ignore the explicit constraints appearing in axiom class 1  we can conclude: 
lemma 1 in the context of the graphplan encoding  unit propagation and reachable-1 yield the same reachability in-
formation. 
notice that axioms from class 1 do not participate in unit propagation because they contain pairs of negated actions. resolving against them requires a positive action literal which cannot be deduced using the given axioms  except for the unlikely case in which a single action is possible initially . in general  we can deduce only negated action literals  which can be resolved against axioms of class 1 to yield  at best  deduced effects  or against axioms of class 1 to yield a disjunction of possible actions. this is precisely what reachable-1 yields. 
　when k   1  the mechanism remains the same  but now axioms of class 1 can play a part if we apply binary propagation. first  we will have binary constraints on co-occurring actions. these will propagate forward  possibly resulting in constraints on state propositions. these constraints need not necessarily be binary. their propagation will require  in the general case  more than binary resolution. more generally  we observe that: 
lemma 1 in the context of the graphplan encoding  for k   1  k-clause resolution yields more information than reachable-k. 
as a special case  when k = 1 it has been observed  kautz and selman  1  that graphplan's propagation of mutexes  which is equivalent to reachable-1  is equivalent to a restricted form of binary resolution. 
　in general  one difference between these methods lies in the ability of k-clause resolution to yield disjunctions of more than k state propositions or actions  although these constraints cannot be propagated forward unless k is larger than the maximal size of clauses of class 1. as an example of how binary resolution can yield more reachability information than graphplan's planning graph consider a situation where p can be produced only by actions q can be produced only by and r can be produced only by but each pair of is mutually exclusive. if are the only possible actions  then we can derive the ternary constraint 
1 k.-clause resolution and relevance 
we formulate an algorithm similar to reachable-k  which we 
call 	relevant-k  	with 	a 	sim-
ilar soundness property. relevant-k prunes the search space by generating a set of propositions that could appear in states that precede the goal state by k steps in any execution of a valid plan. actions whose preconditions are not among these propositions can be ruled out. this leads to a reduced search space. relevant-k is described in figure  for k = 1 we ignore the sets  various existing algorithms use ideas similar to relevant-1  e.g.   mcdermoot  1; nebel et al 1  . 
　for relevant-k: to work in practice we must make the following closure assumption: if a proposition appears in the effect of an action  possibly negated   it must also appear in its 
1  we consider the parallel execution case only. 

precondition  possibly negated . when propositions stand for path properties  e.g.  see the tsp domain in the graphplan distribution   one cannot enforce this condition.1 
　we now compare the amount of relevance information that can be propagated backwards using k-clause resolution and the goal literals as opposed to relevant-k. consider unit propagation first. in the context of the linear encoding  we see that all actions that destroy some goal condition will be ruled out. however  actions that are irrelevant because they produce irrelevant effects will not be pruned. this is incomparable to relevant-1. there  irrelevant actions will be pruned out  but a relevant action that destroys some goal proposition will not be ruled out without modification to the algorithm. 
　in the context of the graphplan encoding the relationship is clearer. from the goal propositions and axioms of class 1 we can deduce disjunctions of actions that must have produced these effects. typically  these disjunctions will not contain unit clauses  and unit propagation cannot proceed farther. notice that we cannot deduce the kind of information obtained via the linear encoding. that is  if an action destroys some goal proposition  we cannot conclude its negation using unit propagation. for example  if a has -p as an effect and p is part of the goal  we have      as an instance of axiom class 1. since a appears positive in this axiom  we cannot deduce its negation by resolving against it. rather  deducing negated actions requires explicit effect axioms of the form 
 finally  while such information is not deduced necessarily by relevant-1  the simple relevance information deduced by relevant-1 cannot be deduced here either. that is  we have no way of deducing -a if all of a's effects are irrelevant to the goal. we conclude  again  ignoring the explicit mutual exclusion information contained in axiom class 1 : 
lemma 1 in the context of the graphplan encoding  unit propagation yields less relevance information than 
* relevant-1 
1  with small modification  this assumption can be removed. 
	brafman 	1 

some actual values appears in table 1. in particular  in the examples we looked at  the graphplan encoding could not {mine any action. this follows from the  quite typical  fact that in these domains  each of the facts that hold at the final state can be achieved by a number of actions  hence  unit propagation can deduce only disjunctions of possible actions  none of which are a unit clause. since we have no way of deducing negated actions  propagation stops at this point. 
　the general case is similar. in the linear encoding  having obtained a disjunction of allowable actions  we can generate a disjunction of allowable preconditions. this information is propagated backwards much like the forward case. yet  as in the k = 1 case  all we can expect is a form of backwards reachability analysis from the goal state  rather than true relevance analysis. in the context of the graphplan encoding  we will generate disjunctions of relevant actions  from which disjunctions of relevant preconditions can be deduced  etc. however  irrelevant actions will not be excluded explicitly  since more than one action is allowed at each step  and we will only conclude that some relevant action must appear. nor can we exclude actions that destroy a goal proposition. on the other hand  using k-clause resolution we can deduce constraints of order greater than k  unlike relevant-k. therefore  no clear winner emerges. we hypothesize that relevant-k: would perform better  but this remains to be tested. 
　finally  we note that  1  the graphplan planner does not incorporate relevance analysis  but mea-graphplan  a more recent variant  does  kambhampati et al.  1 . 
 1   ernst et ai  1  discuss an enhanced version of the graphplan encoding which contains effects axioms as well 
 i.e.  axioms of the form action -  effect . in terms of the ability to propagate reachability and relevance analysis we see here only an added ability to rule out actions that destroy needed propositions  as in the linear encoding.  
1 binary resolution preprocessing 
specialized subroutines that exploit binary clauses in sat problems have been considered in the past  larrabee  1 . we believe that judicious use of binary resolution is a promising direction in the context of the pas framework for a number of reasons:  1  graphplan's mutexes are equivalent to binary clauses  and their propagation is equivalent to a limited form of binary resolution  kautz and selman  1 .  1  binary resolution yields all the reachability information in the linear encoding  lemma 1 .  1  binary clauses form a large fraction of the clauses within encoded formulas: in the linear encoding  all axioms of class 1 1 yield binary clauses  and in the graphplan encoding  this is true of axioms of class 1.  1  1-sat problems can be solved in polynomial time. 
　unlike unit propagation  binary propagation increases the size of the formula  although it yields clauses that are no larger than the clauses resolved . this increase can slow down the solution process considerably and the increased memory consumption can lead to thrashing. consequently  one must either restrict the extent of binary propagation or devise fast  efficient methods for performing them. 
　we experimented with a simple preprocessing step which resolves pairs of binary clauses until no new clauses are derived. this method can be used by systematic and stochastic 
1 	planning and scheduling 

table 1: effect of binary clause preprocessing on rel-
sat  avg. over 1 runs on an amd-k1mhz processor running linux. running times for bin/bin include bin/bin resolution times  see res. column . for the number of unit clauses generated see unit column. results for bw-dir.d are on a sun ultraenterprise 1 running solaris 1.1. 
methods as a simplification step  and it can be implemented efficiently. it is not always useful  as sometimes no or few unit clauses are deduced. yet  the overhead it incurs is relatively low  especially when we consider the more complex examples  and it seems to be a useful enhancement. in table 1  we see a comparison of the running time of bayardo and schrag's rel-s at algorithm with and without the preprocessing step. 
we also show the time required for binary-binary resolution and the number of unit clauses derived.1 
　we also experimented with the performance of the satz algorithm  li and anbulagan  1  on the above instances with and without bin/bin resolution. in table 1 we give the running times for satz as applied to the original and the simplified formula for those instances in which they differ. in addition  we conducted a number of experiments in which we attempted to resolve binary clauses with clauses of arbitrary size. we found the overhead of this method too large. 
1 conclusion 
we have shown a connection between the scheme used to encode planning instances and the ability to propagate reachability and relevance information from the initial and final steps to other time points. we compared this ability to that of the reachable-k and relevant-k algorithms  the first being a generalization of graphplan's planning graph  and the second being a natural extension into relevance analysis. we also pointed out the fact that binary clauses form a major part among all clauses in sat-encoded planning problems  and we attempted to exploit this phenomena. our initial experiments show nice improvements in instances where unit clauses can be derived from binary resolution  and a small overhead otherwise. we are currently experimenting with various extensions 
　　1  see ftp://ftp.research.att.eom/dist/ai/logistics.tar.z and satplan.data.tar.z for the instances used. 


table 1: effect of binary clause preprocessing on the 
satz algorithm. experiments conducted on an amd-k1mhz processor running linux. times for satz with bbr do not include binary resolution preprocessing step. only instances in which binary resolution yielded some unit clauses were examined. 
of the davis-putnam procedure that perform limited amounts of binary resolution during the search process. 
　this work is among the first attempts to theoretically analyze different encoding schemes. we have concentrated on one particular aspect of such encodings  i.e.  their ability to propagate concrete state information backwards and forwards. naturally  this attempt is a-priori limited in its scope  as this ability is only one factor influencing the performance of various algorithms  and its influence is probably more significant in systematic methods based on the david-putnam procedure than in methods based on stochastic local search. 
　other authors have considered some of the ideas presented here  too. kautz and selman  1  point to the ability to backward propagate information thanks to the encoding of effects in the graphplan encoding. kautz and selman  1  mention a relation between graphplan's mutex constraints and binary propagation. recent work on this planner employs crawfords's compact algorithm which uses a restricted form of binary propagation to reduce the size of the formula. finally   ernst et al.  1  discuss optimizations performed on sat-encoded planning problems  among them the use of type inference and a form of dataflow analysis that seems related to reachable-1. 
acknowledgments 
i wish to thank craig boutilier and chris geib for valuable discussions on reachability analysis and the anonymous reviewers for their useful comments. this work was partially funded by the paul ivanier center for robotics research and production management. 
