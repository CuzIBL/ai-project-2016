 
this paper will present a generalisation of chart parsing able to cope with the case where the object being parsed is a particular kind of diagram  a flowgraph  and the grammar is an appropriate type of graph grammar  a flowgraph grammar . a 
feature that often occurs in such diagrams is structure sharing. this paper also discusses the problem of diagram recognition in the case where structure sharing is allowed  noting that we want to permit structure sharing  but not enforce it. 
1 introduction and motivation. 
many applications make use of diagrams to represent complex objects. examples are electrical circuit diagrams and programmer's apprentice  rich  1  style plan diagrams. in such applications it is often necessary to systematically recognise how some diagram has been pieced together from other diagrams. this is analogous to the parsing problem for strings  and this paper will present a generalisation of chart parsing  thompson and ritchie  1  able to cope with the case where the object being parsed is some kind of diagram  a flowgraph  and the grammar is an appropriate type of graph grammar  a flowgraph grammar . often the various components of the diagrams can be regarded as producers of values which are fed as inputs to other components which in turn produce values to be passed on elsewhere. a feature that often occurs is structure sharing  when one component feeds one or more of its results to more than one other component  fan-out . in this situation the source component can be viewed as playing more than one role in the whole structure  and could have been duplicated so that separate copies of the component were responsible for each of these roles. this leads to no change in functionality  although there may be a loss in efficiency as measured by the number of components  electrical circuit case   or computational effort and code size  plan diagram case . this paper also discusses the problem of diagram recognition in the case where structure sharing is allowed  noting that we want to permit structure sharing  but not enforce it. 
1 	tools    the symmetric case of structure-sharing arising through fan-in  rather than fan-out is not dealt with explicitly in this paper. however  the parsing algorithm is easily modified to cope with it  the neccessary modifications to the algorithm being similar to those needed for fan-out. tha algorithm described in this paper has been implemented in pop-1. 
1 notation and definitions. 
flowgraphs and flow grammars will be defined as special cases of plex languages and plex grammars first studied by feder . a plex is a structure consisting of labelled nodes having an arbitrary number  n  of distinct attaching points  used to join nodes together. a node of this kind is called an nattaching point entity  nape . attaching points of napes are not connected directly together  but are connected via intermediate points known as tie-points. a single tie-point may be responsible for connecting together two or more attaching points. if the direction of the connections is important then the plex is known as a directed plex. many types of graph structure  e.g. webs  pfaltz and rosenfeld  1  rosenfeld and milgram  1   directed graphs  and indeed  strings  can be regarded as special cases of directed plexes. we will only consider the special case of directed plexes in which each nape's attaching points  from now on called ports  arc subdivided into two mutually exclusive groups  known as input ports  restricted to only have incoming connections  and output ports  restricted to only have outgoing connections . we will further restrict ourselves to the special case in which each port of a nape is only connected to a single tie-point. this type of plex will be called a flowgraph and is a generalisation of brotsky's  use of the term. sec figure 1  top  for an example of a simple flowgraph. 
　　just as a set of strings constitutes a language  so a set of plexes constitutes a plex language  and it is possible to define a plex grammar and the plex language generated by a plex grammar. similar remarks apply to flowgraphs  webs  and graphs etc. 
　　a production in a string grammar specifies how one string may be replaced by another  either in producing strings or in recognising them. in plex grammars the same is true but we encounter a difficulty  due to the 1-dimensional nature of plexes  not apparent in the string case. in the string case a 
production like 
a ==  axyb 
applied to a string 
....dae.-  say  
results in the string 
....daxybe 
and the question of how the replacement string is to be embedded in the host string in place of a never arises because there is a single obvious choice i.e. whatever is to the left of a 

in the original string is to the left of the replacing string  and similarly on the right. in the graph case we no longer have this simple left-right ordering on the napes and this question of embedding becomes much more complicated. most of the discussion of this topic is in the web and graph grammar literature  e.g.  pfaltz and rosenfeld  1  rosenfeld and milgram  1    but most of it applies  with some slight modifications  to the flowgraph case as well. the approach taken here is to specify with each production which tie-points on the left hand side correspond to which tie-points on the right and then connect everything connecting to one of these left hand tie-points  from the surrounding subgraph  to its corresponding right-hand tie-point. 
　　we define a flowgraph grammar g to be a 1-tuple  n t p s  where: 
n is a finite non-empty set of napes known as nonterminals. 
t is a finite non-empty set of napes known as terminals. p is a finite set of productions. 
s is a special member of n known as the initial  or start  
nape 
and the intersection of n and t must be empty. 
　　if we arbitrarily order the input and output ports of a nape then each nape in a flowgraph can be represented in the form of a triple 
 nape-label  input list  output list  
where nape-label is the label on the nape  and input list is a list in which the ith entry is the tie-point to which the ith input port is connected. similarly the output list specifies to which tie-point each of the output ports is connected. using this convention a complete flowgraph g can be represented as a set gc  known as the component set  of such triples. 
　　with the above conventions the productions in a flowgraph grammar have the general form 

where 
a is known as the left-side structure  represented as a component set 
c is known as the right-side structure  represented as a 
component set 
l  is the left-side input tie-point list 
r  is the right-side input tie-point list 
　　lo is the left-side output tie-point list  and ro is the right-side output tie-point list. l1  and rj must be of the same length  as must l and r   and specify how an instance of the right-side structure is to be embedded into a structure w containing an instance of the leftside structure which is being rewritten according to the production. the rewriting and embedding is done as follows: 
　　the instance of the left-side structure is removed from w and replaced by an instance of the right-side structure. now  for each tie-point x in l  any previous connections from napes 
	lutz 	1 

in w to x are replaced by connections from the same attaching attach to these tie-points  and the set of inactive tie-points 
points of the same napes to the corresponding tie-point in rr 	which are those which would be inputs or outputs of the patch the same is done for tie-points in lo and ro. note that one can 	were it complete. a nape needed by a partial patch will be eliminate the need for explicit storing of r1 and ro by simply 	called immediately needed if any of its tie-points are active. using the same variable names on the left and right hand sides 	the components entry of a patch lists  instantiated versions of  
of the production to denote corresponding tie-points. 	those n apes in the right hand side of the rule which have been 
just as in the string case  by considering various restrictions completely instantiated  and the needed entry lists uninstantiated 

on the form of x and y in a production of the form: 
x== y 
one can arrive at the notions of context-sensitive  context-free  and regular flowgraph languages  ehrig  1 . in particular  restricting the productions to have a single nape in their leftside structure gives us the flowgraph equivalent of context-free string languages  and we will only concern ourselves with these from now on. in this case we no longer need to store l1 and lo since the input and output lists of the single triple on the left of the production already specify this information. see figure 1 for an example of the notation and of the rewriting process. 
1 	chart parsing of context-free flowgraphs. 
in a chart parser  assertions about what has been found by the parsing algorithm are kept in a  database  known as the chart. such assertions will be called covering patches  or simply patches   and are of two kinds - complete patches and partial patches. a complete patch is a statement that a complete grammatical entity  corresponding to some terminal or nonterminal symbol of the grammar  has been found. partial patches are assertions that part of some grammatical entity has been found  and about what would need to be found in order to complete the grammatical entity concerned. one can think of a patch as being a closed loop drawn round some subgraph of the flowgraph  indicating that this subgraph corresponds to all or part of some grammatical entity as defined by the grammar. if we regard the right-side structures of rules as uninstantiated templates  then complete patches with non-terminal labels correspond to the occurrence of an instantiation of the rightside structure of some rule  thus forming an occurrence of the left-side structure of the rule. partial patches correspond to partially instantiated instances of the right-side structure of some rule  and thus to partially recognised instances of the leftsidestructure of the rule. each patch a contains the following information: 
1  label a  - the name of the grammatical entity corresponding to the patch  and is always one of the terminal .or non-terminal symbols of the grammar. 
1  inputs a  - a set of input tie-points for the patch. 
1  outputs a  - set of output tie-points for the patch. 
1  components  - a list of the other patches involved in making up this patch i.e. what other patches have been used to recognise this patch. 
1  needed a  - a description of what else needs to be found to complete the patch. in the case of a complete patch this will be empty  and for partial patches will 
 as yet  parts of the rule. note that some of the tie-points in the needed entry may be instantiated. these are where the needed napes connect to the ones already found. we will say that a partial patch a is extendable by a complete patch b  or that b can extend a  in the case where a immediately needs a patch of the same type as b and the instantiated tie-points in this needed patch do not conflict with any instantiations actually occurring in b. 
　　the essence of the chart parsing strategy can then be stated as follows: 
　　every time a complete patch is added to the chart a search is made for any partial patches immediately needing a patch of the sort just added at the appropriate place. for each of these partial patches a new patch is made extending it by the complete one  and this new patch is then added to an agenda of 
patches to be processed at some appropriate time. similarly  every time a partial patch is added to the chart a search is made for any complete patches which could be used to extend the partial patch just added  and any are found new patches are made which extend the partial one  and these are added to the agenda to be processed when appropriate. note that patches are only ever added to the chart. they are never removed  thus avoiding the need to redo work that has been done before. 

figure 1 
　　it should be clear from this that the basic operation of the algorithm is that of joining a complete patch to a partial patch to make a new enlarged patch. fig. 1 shows a partial patch being joined to a complete patch to make a new patch  the enclosing box . the resulting patch has the same items in its 

be a flowgraph structure  represented as a list of components entry as the original partial patch plus the complete triples. patch. its needed entry is equal to that of the original partial 
for a partial patch  the input and output tie-points  i.e. those by patch minus the needed patch corresponding to the complete which the patch connects to the surrounding flowgraph  are patch. note that the matching of a needed patch to an actual 
each subdivided into two categories - the set of active tie-points complete patch may introduce further instantiations of tiewhere the patch itself is still seeking other components to 	points in the needed entry of the new patch. on connecting the 
1 	tools 

two patches all the inactive tie-points of the partial patch 	an additional step is needed in which partial patches with 
remain inactive. some of its active tie-points will correspond empty components entries are made for every rule in the to tie-points of the complete patch  this is where the two grammar whose left-side structure is labelled by the start patches actually join . other active tie-points remain active in symbol of the grammar. each such rule leads to several such the new patch since it is still looking for other patches to attach empty patches  one for each permutation of the input tie-points to them. of the complete patch's  input and output  tie-points of the original graph. the inactive-inputs and active-outputs some have already been mentioned i .e. those connecting directly entries for each of these patches are the permuted inputs. the 
to the partial patch. others will become new inactive tie-points 
of the resulting patch since it will not be looking for anything to attach to them. however other  input and output  tie-points of the complete patch may now become active  viewed as belonging to the new patch  since it may now expect other patches to attach to them in order to complete itself. provided all these distinctions are kept clear there is no great difficulty in implementing the joining operation. 
   the initialisation of the chart and the agenda now needs to be described. to begin with a complete patch is made for each of the terminal napes in the original graph  and these are needed entry is just the right-side structure of the rule with any 
appropriate instantiations of the tie points occurring in it. 
　　the complete algorithm is shown as algorithm 1 below. when it terminates the parse is regarded as successful if the chart contains a complete patch for s  and the inputs and outputs entries are the same as the input and output tie-points of the graph being parsed. 
   the only remaining issue is how to organise the chart so that it can be searched efficiently. the chart is first of all 
divided into two parts  one for complete patches  and one for partial. the part for complete patches is organised as two added to the agenda. if the algorithm is to be run top-down then arrays  one for indexing each patch by its inputs  and one for initialise chart and agenda; until the agenda is empty do pick a patch a from the agenda; unless a is already in the chart then add a to the chart; if a is complete then for each partial patch b in chart extendable by a do make a new patch extending b with a and put on agenda; 
endfor; if bottom-up then for each rule r in p such that rhs r  has an input nape labelled by label a  do for each such nape x in r do make new empty patch b with label b  lhs r  and needed b =rhs r  with instantiations dependent on match between x and a and 
inputs b =inputs a  and active-outputs b =inputs a ; 
add b to agenda; 
endfor; 
endfor; 
endif; 
else for each complete patch b in chart which can extend a do make a new patch extending a with b and put on agenda; 
endfor; if top-down then for each object c immediately needed by a do for each rule r in p with lhs r =label c  do make new empty patch b with labcl b =label c  and needed b =rhs r  with instantiations dependent on match between c and lhs r  and inputs b =inputs c  and active-outputs b  =inputs c ; 
add b to agenda; 
endfor 
endfor 
endif 
endif 
   endunless enduntil; 
algorithm 1 
	lutz 	1 

indexing by its outputs. so each complete patch is entered several times into the chart  once for each of its inputs and outputs. for further efficiency each of the elements in these arrays is a hash table and the patches are actually entered into these hashed by their label. this enables efficient retrieval of all patches with a particular label at a particular place in the graph. in a similar fashion partial patches are entered into their part of the chart indexed by their input and output tie-points  and hashed by the labels of each of the patches they immediately need. note that there may be several of these. 
　　finally  note that a similar trick can be used to store the grammar rules themselves in order to enable efficient retrieval of appropriate rules. 
1 	structure-sharing flowgraphs. 
as stated in the introduction we are also interested in the case 
where structure sharing is allowed. to make this more precise the reflexive  transitive  symmetric closure of collapses is then an equivalence relation  share-equivalence  on the set of flowgraphs  and we then want any parsing algorithm which can recognise some graph g to also be able to recognise any flowgraphs share-equivalent to g. we also want thegrammatical formalism used to be able to generate not only the flowgraphs derivable directly from the grammar  but also all shareequivalent flowgraphs. this can be done if we allow at any point in the generation of a flowgraph the replacement of the graph so far generated  g1  by any graph g1 for which either gl collapses g1 or g1 collapses gl. a flowgraph grammar with the addition of this rewriting rule will be referred to as a structure sharing flowgraph grammar  a ssfg . figure 1 
illustrates several phenomena that can occur with ssfgs  and which motivated the above definition. 
　　to see how the chart parsing algorithm can be modified to cope with ssfgs it should first be noted that for any flowgraph g there is a smallest flowgraph gmin which is share-equivalent to g. secondly it should be noted that the right-side structure 
of any rule in a ssfg can be replaced by any flowgraph shareequivalent to it without altering the generative capacity of the grammar. wecan therefore define a canonical form fora ssfg in which each rule of the form: 
a== b 
has been replaced by the rule: a ==  b . 
mm 
so the first change to the algorithm is actually to change the grammar to its canonical form  and to use this new form of the grammar for parsing. the second change is to the action of adding a complete patch to the chart. previously the only check that was done was to see if the patch was already in the chart. now the algorithm must additionally check that there is no other patch with the same label and the same inputs in the chart. if there is then the algorithm must collapse the new patch and the one that was there already into a single patch with a new set 
of output tie-points and identify the original outputs of the two patches with these new tie-points. provided tie-points in the various triples making up the patches are represented as pointers to pointers to tie-points  rather than storing the tiepoints directly in the triples  then simply changing the values of the second set of pointers will implement the identification universally throughout all patches in the chart. if the information that this has been done is needed by an application the algorithm can make a note of this fact either by annotating the tie-points 
1 	tools 

involved or by an assertion held separately. 
1 	discussion 
although there is quite a lot of literature on the generative abilities of various types of graph grammar formalisms  see e.g.  ehrig  1  feder  1  fu  1  gonzalez and thomason  1  pfaltz and rosenfeld  1  rosenfeld and milgram  1    there is relatively little on parsing strategies  except for rather restricted classes of graph and web grammars  e.g.della vigna and ghezzi  1 . in its top-down strictly left-to-right form chart parsing of context-free suing languages corresponds to earley's algorithm  earley  1   which was generalised by brotsky  to parsing flowgraphs of the kind described here  except that his algorithm could not cope with fan-out at tie-points. however the approach laken here can also run bottom-up  and can cope with the case in which there is fan-out. running bottom-up is particularly useful in applications in which we want to recognise as much as possible even though full recognition may be impossible  because of errors in the graph  or because the grammar is neccessarily incomplete . zelinka   1  has modified brotsky's algorithm to cope with fan-out  but her algorithm only runs in a psuudobottom-up fashion by starting it running top-down looking for every possible non-terminal at every possible place in the graph. as discussed earlier the algorithm presented here is also easily modified to cope with structure sharing in a natural way  and indeed can also be easily generalised to run right-to-left as well as left-to-right. it can also be easily modified to cope with fan-in at tie-points. 
　　a particular advantage of a chart parser is that it quite explicitly keeps a record of all partial patches it finds. this is useful in applications for which we may not just wish to verify that some graph can be generated from some grammar  but also to enable the system to make suggestions based on  near-miss  information about how to correct the graph. it is in such applications that it may be useful to modify the algorithm to run right-to-left as well  since this may enable one to find more  near-misses   i.e. those missing their start napes  than one would find if the parser only ran left-to-right. 
　　the algorithm presented here runs in time polynomial in the size  measured by the number of tie-points t  of the graph being parsed provided that we do not allow the right-hand sides of rules to have  dangling  points  i.e. tie-points which are neither input or output tie-points of the rule  but which do not have both incoming and outgoing connections . if we allow these then there are graphs for which the algorithm will take time exponential in the size of the graph. some intuition into why the algorithm runs in polynomial time can be gained if one considers the maximum number of possible patches that can be built the algorithm only distinguishes patches which differ in at least one of their input tie-points  their output tie-points  or their label. th e maximum number  k  of inputs andmaximum number  m  of outputs in a patch is determined by the grammar  as is the number of possible labels  l . so the number of possible patches is bounded above by the product of l and the number of possible ways of selecting at most k out of t tie-points  and the number of ways of choosing at most m out of t tie-points. this gives us 1 l.tk+m  patches altogether. stemming from this fact a careful analysis then shows that the whole algorithm only takes timepolynomial in t. full details will appear in a future paper. in this connection it should be noted that although the algorithm performs flowgraph recognition in polynomial time  it does not find all parses in polynomial time. this is because for some flowgraphs and some grammars there may well be an exponential number of parses  this is also true of earley's algorithm operating on strings! . the algorithm will however find a parse if one exists. if an application requires all possible parses  then the algorithm can be modified to store any patch which is equal to one already in the chart in terms of its inputs  outputs  and label  but not equal in terms of its components  in an auxiliary data structure. at the end of the parsing there will then be enough information around in the chart to enable subsequent calculation of all the possible parses. 
