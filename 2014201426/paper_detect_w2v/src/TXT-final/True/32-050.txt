 
in this paper we consider the problem of cyclic schedules such as arise in manufacturing. we introduce a new formulation of this problem that is a very simple modification of a standard 
job shop scheduling formulation  and which enables us to use existing constraint reasoning techniques to generate cyclic schedules. we present evidence for the effectiveness of this formulation  and describe extensions for handling multiple-capacity resources and for recovering from breaks in cyclic schedules. 
1 	introduction 
a cyclic scheduling problem is a scheduling problem in which some set of activities is to be repeated an indefinite number of times  and it is desired that the sequence be repeating. cyclic scheduling problems arise in domains such as manufacturing  time-sharing of processors in embedded systems  and in compilers for scheduling loop operations for parallel or pipelined architectures. in this paper  we will take the manufacturing domain as our motivation and address the cyclic version of the job shop problem  in which a set of tasks  which describe the building of a single widget  are to be scheduled into a cyclic schedule for a widget factory. 
　cyclic scheduling has not received much attention in the ai community  but there is a considerable body of 
　*this work was done while this author was at rockwell palo alto lab. t some of this author's contributions to this work were 
made while at rockwell and with support through cirl. 
1 	planning and scheduling work available in the or literature;  hanen and munier  1  gives an excellent overview. many heuristic approaches have been suggested for particular problems such as hoist scheduling  but there is also work on representations for general job shop problems  such as  hanen  1  and  roundy  1 . we do not have the space in this paper to fully describe their approaches  but the common element involves building a special-purpose data structure which represents the problem  and solving it using techniques such as branch-and-bound search or mixed integer programming. 
　in this paper  we will describe a different approach to the cyclic scheduling problem  one which is a conceptually simple extension of the constraint-based formulation of scheduling problems that has enjoyed much recent success. the main advantages to using such a constraint-based framework are the availability of existing techniques and the extendability of constraint-based representations. this allows us to transparently exploit the power available in any of the modern constraint satisfaction search engines  utilize other constraint reasoning techniques such as constraint propagation and consistency checks  and use the problem formulation within larger constraint decision problems. we also find that the formulation lends itself to the use of methods for recovering schedules after a failure  and that it can be extended to handle more complex problems such as resource constrained project scheduling. 
　we will start with a brief description of the nowstandard constraint formulation of job shop scheduling  and then go on to present our extension to handle cyclic scheduling problems. we then present experimental results on solving such cyclic scheduling problems  and briefly discuss two extensions to our approach. 

1 job shop scheduling 
the job shop scheduling problem can be found in many standard texts  e.g.  baker  1  ; the problem is specified by a set of tasks  t  and a set of resources  r. there is a function on tasks  dur t   specifying a non-zero duration for each task  and a predicate u t r  specifying whether task t uses resource  finally  there is a set of precedence constraints  where each constraint specifies that the task  must be completed before the task  can begin. a valid schedule is an assignment of start times to each task such that the precedence constraints are obeyed and no two tasks require the same resource at the same time. the completion time of the final task in the schedule is called the makespan of the schedule. the goal of scheduling can either be satisfying  find a schedule whose makespan is at most d   or optimizing  find a schedule with minimal makespan . 
　the satisficing scheduling problem can be encoded as a constraint satisfaction problem  and solved using search or a combination of constraint propagation and search  and the optimizing scheduling problem can be solved with additional search or branch-and-bound over possible makespans. early approaches focused on searching over the space of start times for tasks. more recent approaches have found it more efficient to search over ordering decisions between tasks-once sufficient orderings have been added to guarantee that the resource constraints have been satisfied  it is simple to determine a minimal start time for each task consistent with those orderings. 
1 	cyclic job shop scheduling 
in the job shop scheduling problem  the set of tasks is fixed as given. for the cyclic job shop problem  we assume that the set of tasks is a template which we wish to repeat indefinitely-for example  the tasks represent the steps to build a single widget  and we wish to construct a schedule for a widget factory. in order to make efficient use of our resources  we will want to overlap the manufacture of multiple widgets. a cyclic schedule for building widgets is one in which a new widget is begun every k time units  the cycle time   and the same schedule of tasks is completed for each widget. assuming the time to complete each individual widget is greater than k  the result is a pipeline in which multiple widgets are under construction at any one time. 
　it is not the case that a cyclic schedule is necessarily the most efficient schedule; for any fixed number of widgets  tv  a non-cyclic schedule for building n widgets might very well exist that is more efficient than any cyclic schedule  hanen  1 . even if we do not know n in advance  we could still use an 1v-widget schedule as an approximation  repeating it as necessary. there are two significant advantages to using cyclic schedules  however. 
　*note that this approach to representing resource usage allows for tasks requiring more than one resource  which is a commonly used extension to the standard job shop problem. 
figure 1: a scheduling problem and a cyclic solution. 
 a  shows a cyclic problem: each box is a task with a 
name and resource required  the size of the box indicates task duration and the arcs indicate required precedence.  b  shows an arbitrary assignment of starting times to tasks that respects resource constraints   c  shows this assignment interpreted as a cyclic schedule; the boxes in bold are the instances of each task used to build a single widget. 
the first is that cyclic schedules are much easier to implement: it is easier to communicate a short  repeatable sequence of actions to the agents which must carry them out  than to specify a much longer  non-repeating sequence. secondly  the cost of computing optimal schedules for n widgets grows exponentially with at  while the cost of finding a single widget cyclic schedule to make tv widgets is independent of n. furthermore  as we shall see  the complexity of our cyclic algorithm has in the worst case only an extra logarithmic factor over the basic job shop algorithm.1 
　in order to explain our cyclic scheduling formulation  we will start at the end  with some observations on cyclic schedules. the main observation is that any assignment of start times to tasks that satisfies the resource constraints can be converted into a cyclic schedule. for 
example  consider the scheduling problem specified in figure 1 a . figure 1 b  shows an assignment of these tasks to resources. to convert this assignment into a 
　　1 an interesting compromise between computation cost and optimality is to build cyclic schedules for building two or more widgets at a time. 
draper  jonsson  clements  and joslin 	1 

cyclic schedule  paste copies of the basic cycle together into a strip in such a way that they do not overlap- this induces a cyclic schedule with some particular cycle time  as shown in figure 1 c . then  no matter what task ordering was chosen  or what cycle time is induced  it is possible to overlay a complete schedule for one single widget such that the precedence constraints are satisfied; this is done in bold in figure 1 c . a simple counting argument shows that this is a proper cyclic schedule for this set of tasks: every task is fulfilled  and there are no tasks left over. 
　this exercise demonstrates several things. first  whereas the makespan is the only measurement of interest in the traditional job shop schedule  in the cyclic case we have two: the cycle time k  and the latency  l  which is the number of cycles required to complete a single widget  which is also equal to the number of widgets in production simultaneously . 
　　secondly  notice how the precedence constraints were satisfied. for any precedence constraint     it is either the case that  and  occur within the same cycle  in which case the 'normal' precedence holds between them  or it is the case that  is in one cycle  and  is in a subsequent cycle.  in figure 1  the precedence constraints a   b  a   d  c   e  and d   e are satisfied 'normally/ while constraints b   c and e   f cross cycle boundaries. 1 the point is: in order to satisfy a constraint   we can either order before  within a cycle  or defer the execution of  to the subsequent cycle. this observation is the basis of our cyclic scheduling formulation: we will restrict our attention to scheduling of tasks within a single cycle  modifying the definition of the precedence constraint to allow for the two different ways in which it can be satisfied. 
　with this formulation  we can employ any standard search procedure. there are no new decision variables: we search only over orderings of steps within a cycle. we can do satisficing search for both a given cycle time k and latency l  or we can optimize cycle time for fixed latency or vice versa  or we can search for a set of dominating solutions in both k and l. 
　we will now lay out our constraint encoding formally  and introduce some additional variables and consistency checks to avoid redundant or useless search. the inputs axe: 
  the set of tasks  
  : the set of resources  
  dur t : the duration of each task  
  u t r : usage predicate for each task/resource pair  
  : a set of precedence constraints on task pairs  
  k: the cycle time  
  : maximum allowable latency  optional . 
the decision variables we search over are: 
have to be careful about tasks which overlap cycle 
boundaries  such as task d; we will address this below. 
1 	planning and scheduling 
  : ordering predicate on pairs of tasks within a single cycle. 
　we use the following non-decision variables for consistency checking: 
  1t t : start time of t wrt the beginning of a cycle  
  cs t : cycle in which the first instance of t starts  
  cf t : cycle in which the first instance of t finishes. 
cycles are numbered from one at the beginning of the schedule; cs and cf measure the positions of the begin and end of each task for the first widget  e.g. in figure 1 we have: cs{d  = 1  cf{d  = 1  and cs{f  = 1 . note that cs and cf are only required if there actually is a desired limit on latency  which we will assume to be the case. 
　for conciseness  we will add notation to represent the condition that a task crosses the cycle boundary: 

the constraints we must satisfy are as follows: 
1. the start time of each task is within the cycle: 

1. if task  is ordered before task   then the termination of ti in the cycle occurs before the start of in the cycle. 

it is possible for both a n d t o hold  if either task crosses the cycle boundary. 
1. if two tasks use the same resource  one must be ordered before the other; if either task crosses the cycle boundary  they must be ordered in both directions  and both tasks cannot cross the cycle boundary. 
finishes. 

1. if a task crosses a cycle boundary  its finish cycle number is one greater than its start cycle number; otherwise they are the same. 

1. the cycle numbers must be between one and lmax' 


　when solving this problem  we initially assign possible ranges to the variables: 
. then we 
search over assignments to   using consistency propagation techniques to prune the possible values of all the variables. when enough ordering variables have been set such that all the required constraints are guaranteed to hold  we take start times and cycle numbers to be the minimal of their remaining possible values. 
　this description is complete  but misses some important details concerning the efficient pruning of the supporting variables. 
　in the standard job shop constraint formulation it is customary to keep  in place of a set-valued st t   two variables-earliest possible start time  est t  and latest possible start time lst t -which represent the end points of st t . the value of  can be efficiently updated by using the rule 

 and a symmetric rule for lst t  . the advantage of this representation is that the updated values for est t  and lst{t  can be computed quadratically in the number of tasks by traversing them in topological order  for est t   and reverse topological order  for lst t  . 
　in our formulation of the cyclic scheduling problem  we also use est t  and lst t  to represent the end points of 1t t   and we use essentially the same rules for updating these variables  except that we now must account for the cycle boundary by introducing a mod k. but  since the ordering decisions o ti tj  may have a cycle  the propagation may not terminate at the end of the schedule  as it does for standard job shop problems. for an example  consider a task a that crosses the cycle boundary and as a result forces an increase in the earliest start time for another task b. if moving b then ultimately results in changing est a   the standard propagation will continue propagating this cycle  until est a  reaches k. however  we note that when the task sequence for a resource is moved more than once  the current schedule is proven to be infeasable and the propagation can therefore be halted immediately. 
　our treatment of the cs t  and cf t  follows a similar pattern: we keep two variables to implement the lower and upper bounds on each quantity. to update the values for ecs t  and ecf t   we initially assign each variable to zero  then do two passes. in the first pass  ecf t  is updated using constraint 1 above-that is  

in the second pass  we consider the precedence constraints in topological order. for each precedence constraint  we enforce the following constraints: 

each time one of these constraints increments ecs t   we reinforce constraint 1 by incrementing ecf t  by the same amount. 
　the computation of lcs t  and lcf{t  follow a symmetric pattern  initializing from constraint 1 and lst t   and updating by considering the precedence relations in reverse topological order. 
　the algorithm described above produces a schedule for a fixed cycle length k. in order to optimize over k  we must iterate the scheduling process over possible values of k. an upper bound on k is given by the makespan of the problem  treated as an ordinary job shop scheduling problem  which could be bounded or approximated by any number of means . a lower bound for k is given by the largest total time requirement for any one resource  at which point that resource is 1% utilized . 
　the worst-case complexity of this algorithm  for a single value of k  clearly differs from the complexity of the ordinary job shop scheduler by only a small constant factor  required to process the additional constraints for computing cycle numbers . if we assume that the cycle time and the task durations are all integers  we can bound the worst case time required to search over multiple values of k by   where t is the time to invoke the scheduler for a single instance of k. 
1 	experimental results 
it is clear that cyclic schedules have a number of advantages over non-cyclic schedules in applications where schedules are repeated. the question is whether the cost of generating cyclic schedules is reasonable enough that these advantages can be realized. to verify that this is indeed the case for our cyclic scheduling formulation  we compare the cost of solving problems using our formulation to the cost of solving the same problems using the smaller classical formulation  with the goal of minimizing the cycle length. the comparison is done by applying an optimization search method  branch-and-bound with a time cutoff  to each formulation of a given problem and comparing the resulting cycle length. for the standard formulation  we calculate the cycle length as the longest distance between first and last use of a resource  since a new widget can be started at those intervals.1 
　the scheduling problems used in this comparison are from norman sadeh's scheduling test suite  sadeh  1 . disregarding the makespan limits  which are irrelevant when minimizing cycle time  the suite gives us 1 different problem instances. each problem has 1 tasks  each task uses exactly one resource and there are 1 resources in all. it should be noted that these particular problems are not all that hard for modern search techniques and well-honed heuristics  crawford and baker  1 . but  the question here is not whether our formulation outperforms existing engines or heuristics for job shop scheduling; the question is whether this larger cyclic constraint formulation can be solved efficiently enough 
　　1 note that for the standard formulation  the cycle length also replaces makespan in all pruning and heuristic calculations. in all other aspects  the search proceeds as usual; ordering decisions are made such that resource and precedence constraints are satisfied. 
draper  jonss1n  clements  and j1slin 	1 

that the benefits still outweigh the possible increase in solving time. for answering that question  these scheduling problems are a perfectly suitable testbed. 
　to solve the two different formulations of the scheduling problems in the same manner  we use the gensolve system  j1nsson  1   which is currently a prototype of a general constraint satisfaction system that can use arbitrary combinations of procedural propagation methods to speed up the search effort. in this system  problems are represented by providing the decision variables  the constraints on value assignments  and procedures that perform propagation. for both scheduling formulations we use procedures to determine the possible start times for tasks; in the regular formulation we use the standard propagation of earliest and latest start times  while in the cyclic formulation we use the propagation algorithm described above  with a latency limit of lmax = 1 . in both formulations we use the standard slack-based heuristic described in  smith and cheng  1 . 
the key results of this comparison are tabulated in 
table 1. the results clearly demonstrate that the cyclic scheduling formulation of these problems can be solved quite effectively by standard constraint solvers. furthermore  the results show that when it comes to scheduling for cyclic applications  using this new formulation provides significantly better results than using the standard 
job shop formulation. 

table 1: a comparison of the effectiveness of minimizing the cycle time using the new cyclic scheduling formulation and doing the same using the standard scheduling formulation. each problem instance was solved using a simple version of branch-and-bound search  on an ultrasparc-ii  with a time limit of thirty minutes. 
1 	extensions 
one of the advantages that our approach to cyclic scheduling has over existing special-purpose algorithms is that a general constraint satisfaction formulation can be extended and adapted much more easily. as examples of this  we will briefly describe how our approach can be extended to the more general class of cyclic resourceconstrained project scheduling problems  and how it can be adapted to provide an approach to recover from failures in the exectuion of cyclic schedules. 
　in real-world manufacturing scheduling there are typically resources that have capacity greater than one  e.g. a pool of skilled labor   tasks may require multiple instances of each resource type and each task may use multiple resource types. these characteristics have been 
1 	planning and scheduling 
formalized as the resource constrained project scheduling  rcps  problem  blazewicz et al  1   which is considered significantly more difficult than the job shop problem. 
　we would like to extend our cyclic formulation to create a solution for the cyclic rcps problem. we will do this by adapting an existing approach to solving such problems. this approach is based on initially scheduling the tasks without any regard to the resource constraints  but respecting the precedence constraints  and then eliminating resource constraint violations by assigning values to corresponding ordering decision liabks  crawford  1 . first  let us point out conditions that have changed from the job shop problem: 
  tasks that use the same resource r do not necessar-ily need to be ordered with respect to each other  if the sum of their usage of r is less than the total availability of r. 
  tasks can have a duration that exceeds the cycle length k  provided that for each task t that uses some resource r with capacity c  we have and 

as a result  a task's cycle finish number can be more than one greater that its cycle start number. 
  the lower bound for k is given by the largest total time requirement for any resource divided by its capacity. 
　in the cyclic formulation of the above-mentioned approach  all the tasks are initially scheduled at the beginning of the cycle  without any regard to either resource constraints or precedence constraints. the resource constraint violations are then eliminated as before  while precedence constraint violations are resolved by either making the appropriate ordering decision within the cycle or by defering the second task to a later cycle. the impact of each ordering decision is then propagated to restrict the bounds on start times and cycle numbers for later tasks  in a similar fashion as for the cyclic job shop scheduling formulation. just as for the standard rcps problems  systematic backtracking methods such as limited discrepancy search  harvey and ginsberg  1   or nonsystematic repair methods like doubleback optimization  crawford  1   can then be used to explore the 
space of decisions. 
　turning our attention to schedule recovery  it is well known that optimal or near optimal schedules lack tolerance for delays  and thus are easily broken when delays do occur. in the non-cyclic case  we can generate a new schedule from the point of disruption  either from scratch or by modifying the old schedule. however  since one of the goals of cyclic scheduling is regularity  generating an entirely new schedule is not a desirable option. in the cyclic case  we want to focus on returning as quickly as possible to the already-established schedule. 
　to do this  we consider a rescheduling window  which covers from when the disruption occurs to when the 

cyclic schedule will be restored. within it tasks will not follow the repeating pattern used elsewhere in the schedule. the rescheduling window may have jagged left and right edges; any tasks running at the time of the disruption  but not affected by it  jut into the window from the left side  and any tasks in progress when the cyclic schedule is restored jut into the window from the right side. 
　the right edge of the window can be determined by incrementing over possible times until a window that is big enough to accommodate the rescheduling is found. in some cases this may be achieved without pushing back the entire schedule. however  if the disruption is big enough  it may not be possible to recover unless the entire schedule is pushed back  thus allowing the recovery more time in which to place the schedule. once a window has been established  any search technique can be used to schedule the tasks within it. 
1 	conclusion and related work 
in this paper we have developed a formulation for solving cyclic job shop scheduling problems as constraint satisfaction problems. we have implemented this formulation and shown that it can be used to generate good cyclic schedules  using standard constraint satisfaction methods. we have also demonstrated that for the purpose of finding cyclic schedules  the use of our formulation outperforms the use of standard job shop formulations  when the same search technique and shceduling heuristic are applied to both. in addition to this  we have described how our formulation can be generalized to cyclic resource constrained project schedules and how the formulation allows us to develop methods for recovering from failures in the execution of cyclic schedules. 
　as mentioned in the introduction  there are several formulations for cyclic job shop scheduling in the or community. furthermore  there exist specific cyclic scheduling techniques in industry  e.g  those used to schedule update cycles on recent honeywell avionics  boddy and goldman  1 . we have not been able to do performance comparisons between our approach and other techniques  but the formulation presented here has other clear advantages in terms of understandability  and in terms of being able to exploit existing constraint reasoning techniques and heuristics. perhaps most importantly  based on this simple constraint representation  further research can build on this formulation. for example  by adapting it to more complex scheduling problems -as we have started doing with the cyclic rcps problem. 
　on the other hand  the or techniques typically handle more complex types of precedence constraints than we do: it is allowed for a task  to depend on the completion of a task  from a different iteration-this is needed for the compiler problem where a loop may contain a statement of the form . this kind of precedence does not seem to occur in manufacturing problems  our primary interest  but it would nonetheless be interesting to see if this representation can be extended to handle such more general forms of precedence. 
