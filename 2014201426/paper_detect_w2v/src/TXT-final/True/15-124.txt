 	ii 	a generalized loop construct 

　　　in practical prolog applications  difficult and opaque uses of control primitives are often 
unavoidable. to relieve these d i f f i c u l t i e s   a preliminary set of high-level control predicates has 
been developed. two technical goals were achieved. the f i r s t was to cast control f a c i l i t i e s found desirable in conventional languages into a logicprogramming form. the second was to provide con-
venient high-level structures for all the sorts of 
algorithmic routines a prolog clause might sensibly perform. the availability of such structures should make deliberately algorithmic use of prolog respectable and may help win prolog wider use. 
	i 	introduction 
     many prolog users accept that prolog programs tend towards one of two extremes in a way that 
corresponds to two different sorts of problem. on the one hand  for many problems there are logically 
elegant solutions in prolog. these require l i t t l e 
resort to  cut     f a i l   and  repeat  beyond some 
well structured use of  cut  in binding and finalizing clauses. practical applications  
however  often involve many predicates which 
display an algorithmic flavour  with opaque and difficult uses of  cut     f a l l   and  repeat . these difficult uses of the control primitives severely 
disrupt the otherwise lucid self-documentation of sensibly written prolog. this is costly  both in 
comprehension time and induced errors. regarding control f a c i l i t i e s   then  we would concur with the contention of  hardy 1  that prolog offers only low level primitives comparable to the assembler level of conventional programming. 
　　　we assume that a much higher level of logic programming remains a relatively distant goal. meanwhile  algorithmic programming structures are desirable both in principle and in practice. in principle  even at the program specification level  algorithmic content is often important. this can arise  for example  due to the relation of algorithms to time complexity. well-structured algorithmic programming can thus have intrinsic 
self-documentary virtue. with regard to practice  programmers rarely have the opportunity to rewrite  in logic programming style  routines already well understood in algorithmic terms  and frequently there are no elegant prolog formulations available. 
　　　there is thus a need to add to prolog the means of well-structured algorithmic expression. we have been pleased to find how extensively the desirable f a c i l i t i e s from conventional languages coutd be incorporated without damaging prolog. this report presents our first implementation of the  logal  control structures  which run on the 
pdp-1 unix prolog system  version nu1  as sketched in appendix f of  clocksln and mellish 1 . 
　　　our offering comprises two programming constructs  a conditional and a generalized loop. the loop is the more innovative and important of these. it follows the practice of languages such as alg1 in having a  building block  syntax for loops. the following fixed-order sequence of four optional  building blocks  or  phrases  is used. 

each of these phrases consists of an appropriate keyword followed by a predicate to be called  for 
example  while read line l '' or  until x=y . we have allowed ourselves two arbitrary restrictions 
on the selection of phrases. first  a loop cannot consist of a while-phrase or until-phrase alone. second  no loop can include both a while-phrase and an until-phrase. whatever selection of phrases is made for a given loop  the phrases are executed in the order in which they appear  repetitively  
until a termination condition arises. adaptations of the conventional loop necessary to suit the prolog environment are detailed below. distinctive keywords are used to signal modified semantics. 
our keywords are declared as operators so that the phrases can be concatenated with a minimum 
of parentheses. this technique makes an additional mandatory closing keyword useful to avoid ambiguity and help catch syntax errors. we use  od  in this role for loops. relying on available syntactic 
f a c i l i t i e s has meant that parentheses are s t i l l required around arguments whose top level operator 
has a priority equal or greater than that of the keywords  as in the following. 

　　　we have not initially provided for-phrases generating number series. rather  after the style of  every  in icon  griswold et. al. 1  a series of outcomes is generated by calling a predicate and then repeatedly backtracking and resatisfying it until it f a i l s . to signal this we write the forphrase in the form  for each  term  .  for each  conveys the notion  for-each instantlatlon~of  concisely and naturally. generating arithmetic series is reasonably easy with this arrangement. 
　　　the next adaptation is fundamental to the semantics of loops in the prolog environment. it concerns the action to be taken if  on any cycle of iteration  the main body of the loop  i.e. the do-phrase  should f a l l . two alternatives have been provided. loops with do-phrases introduced by the keyword  do any  succeed regardless of any cycles of iteration in which their body f a l l s . loops with do-phrases introduced by the keyword  do one   however  fail immediately should their body once f a l l . for example  if the predicate: 
for each ru!e r  
do one   translate r rt   store rt    od 
succeeds  then for each rule a translation has been found and stored.  for each g do one p od  in fact equivalent to the well known construct  not   g  not p   . the  do one  form is in fact the general case  as  do any x  is equivalent to  do one   x ; true   . the  do any  option is provided for convenience and efficiency. loops 
which include a  do one  phrase and a  while  or  until  phrase incur overheads in distinguishing between two modes of termination  whereas the corresponding  do any  loops do not. 
　　　the syntactic limitations of the prolog interpreters we use require a final adaptation. special treatment is required for phrases which are sometimes but not always the first phrase of a loop. for instance  when a for-phrase precedes a 
　　　do-phrase  the do-phrase is not the first phrase in a loop  thus its first keyword has to be a dyadic infix operator. when a do-phrase is the f i r s t 
phrase in a loop  however  its first keyword must be a monadic prefix operator. this in turn requires the use of distinct keywords. fortunately  when a loop begins with a do phrase  it is natural to say  repeat  instead of  do   as in pascal. likewise  we use  repeat one  instead of  do one  and 
 repeat any  instead of  do any  in this context. this produces structures such as the following. 
repeat one p until u od repeat any p od 
neither for-phrases nor until-phrases can appear in both monadic and dyadic contexts  leaving the 
case of the while-phrase. at the start of a loop  we introduce a while-phrase with plain  while   but use  whlle still  otherwise  as shown below. 
while w do any p od for each g~whlle still w do one p od 
　　　the complete implementation of the generalized loop is given in appendix i. this includes a clause for each format of loop that can be constructed 
using the above rules. although there are 1 such clauses at the top level  this does not amount to a 
great deal of code. however  much of this code is excruciatingly difficult to write and read  
underlining the ergonomic difficulties presented by the control primitives. the following relatively simple case illustrates something of this. 
repeat one p until u od :- i  repeat  
detval p v   /i set v to success of p 1   not v ; determine u     
         i  v  i. 	/i whether the loop succeeds 1 where 
	determlne x  :- callto x   i. 	/! a call that 
/i can't be backtracked into from outside 1 
detval x true  :- callto x  ; i. /i call x *1 detval x fali  :- !. /i  determinate*  and /i advise whether it succeeded 1 
	callto x  :- x. 	/i unlike the system  call  
/i predicate  a real call to fall back 
/i to in case x executes   i   f a l l   . */ 
this works as follows   repeat  always succeeds  so 
	d. dodson and a. rector 	1 
every time the loop is to be repeated  control will 
backtrack to this point and work forwards again   detval  is then used to call p and according to whether or not p succeeds  set v to true or f a l l . now  provided v=true  a call will be made to u. if either v=fail  or v=true and the call to u suc-
ceeds  the loop must terminate. all this is handled by   not v ; determined!   . if this f a l l s   control backtracks to the repeat for the next iteration. if it succeeds  a cut is then passed which throws away the backtrack history of the call to the loop. the final call to v fails the loop if the body of the loop  p  failed. 
　　　in general  variable bindings made in a phrase which succeeds remain in scope for all subsequent phrases within a cycle. in the clause above  for instance   detval p v     not v ; determlne u     ensures that variable bindings from successfully calling p remain in scope when calling u. writing    not p ; determlne u     would not achieve this. at the end of each cycle  all variable bindings are undone ready for a further cycle  unless iteration is terminated by a while-phrase or until-phrase. after termination by a while-phrase or until-phrase  all bindings made in the last iteration remain in force. these rules are quite 
natural; they were formulated only after we had exploited them for some time. when not required  variable bindings introduced by a call are easily discarded by surrounding the call with a double  not .  variable bindings  or instantiations  represent existence. for any set of variables  their concurrent instantiations  those currently in scope  are things of which the successfully 
called predicates mentioning them are true.  
	i l l 	the conditional construct 
　　　apart from loops  two other high-level intramodular control structures are conventionally recognised  the conditional and the case structure. a case structure suggests a direct access control step. such a step cannot be programmed within a 
prolog clause  though some interpreters provide it in the form of indexed clause selection. we use the 
following predicate for conditionals. it is an extension of a  cond  predicate described in  bundy and we i ham 1 . the operator declarations 
illustrate the technique used in both constructs. 

recursive application of the else if any option allows case-like structures. note~that backtracking through antecedents is prevented whilst backtrack-
ing through selected consequents is unhindered. 
iv example of usage 
　　　this example is chosen to illustrate recursive application of the loop format discussed in detail above  rather than for elegance or even realism. it repeatedly performs a  consultation . after each consultation it repeatedly asks the user whether 

1 d. dodson and a. rector 

