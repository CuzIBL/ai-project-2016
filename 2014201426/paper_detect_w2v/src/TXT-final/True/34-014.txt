deductive retrieval mechanisms for state description models 
r i c h a r d e. 	f l k e s 
s t a n f o r d 	research 	i n s t i t u t e 
	menlo park  	c a l i f o r n i a 	1 

a b s t r a c t 
       this paper p r e s e n t s some programming f a c i l i t i e s f o r modeling the semantics of a task domain and f o r d e s c r i b i n g the s i t u a t i o n s t h a t occur in t h a t domain as a task is being c a r r i e d o u t . each such d e s c r i p t i o n models a   s t a t e   of the task e n v i ronment  and any g i v e n s t a t e can be transformed i n t o a new s t a t e by the occurrence of an event t h a t 
a i t e r s the environment. such modeling systems are v i t a l in many al systems  p a r t i c u l a r l y those t h a t do q u e s t i o n answering and those t h a t do automatic g e n e r a t i o n and e x e c u t i o n m o n i t o r i n g of p l a n s . the modeling mechanisms d e s c r i b e d are b a s i c a l l y e x t e n sions and m o d i f i c a t i o n s o f f a c i l i t i e s t y p i c a l l y found in al programming languages such as planner  conn1ver  and qa1. in p a r t i c u l a r   we discuss our use of a 1 valued l o g i c   g e n e r a t o r f u n c t i o n s to deduce answers to model q u e r i e s   the saving and maint a i n i n g of d e r i ved r e s u l t s   and new f a c i l i t i e s f o r modeling stntc changes produced by the occurrence of events. 
i n t r o d u c t i o n 
       this paper d e s c r i b e s some model ing f a c i l i t i e s that have been developed as p a r t of a l a r g e comp u t e r based consultant system  cbc  being designed and implemented at the sri a r t i f i c i a l i n t e l l i g e n c e center. the cbc is intended to serve the r o l e of an expert c o n s u l t a n t to a human a p p r e n t i c e doing maintenance and r e p a i r o p e r a t i o n s on e l e c t r o m e c h a n i c a l devices. the a i r compressor shown in f i g u r e 1 is an example of such a device that has been used d u r i n g the ear ly stages of the p r o j e c t   a complete overview of the p r o j e c t is g i v e n elsewhere in t h i s volume in reference 1. 
       the models t h a t we are concerned about in t h i s paper could be d e s c r i p t i o n s of any environment of i n t e r e s t at s p e c i f i c instances in t i m e . each such d e s c r i p t i o n is s a i d to model a   s t a t e   of the e n v i ronment  and a s t a t e can be transformed i n t o a new s t a t e by the occurrence of an event t h a t a l t e r s the environment. for the cbc  these models d e s c r i b e the s t a t e o f the w o r k s t a t i o n i n c l u d i n g the d e v i c e   t o o l s   t e s t equipment  e t c .   and the events are p r i m a r i l y maintenance and r e p a i r o p e r a t i o n s p e r formed by the a p p r e n t i c e . 
       programming f a c i l i t i e s for q u e r y i n g s t a t e des c r i p t i o n models and f o r u p d a t i n g them to r e f l e c t the occurrence of an event are v i t a l in many al systems  p a r t i c u l a r l y those t h a t do q u e s t i o n answering and those t h a t do automatic g e n e r a t i o n and e x e c u t i o n m o n i t o r i n g of p l a n s . planners  for examp l e   use these models to s i m u l a t e p o t e n t i a l 
operator  event  sequences and investigate their consequences. 
       one of the goals for the cbc project is to have the system synthesize plans for transforming a device from any a r b i t r a r y state of assembly or disassembly into any other such state. this planning c a p a b i l i t y is required for component r e mo va 1 or replacement operations and  in general  whenever a c o l l e c t i o n of assembly and disassembly operations are needed to help accomplish a task. we w i l l refer to this planning domain for examples throughout this paper. 
　　　the modeling mechanisms to be described here are basically extensions and modifications of f a c i l i t i e s t y p i c a l l y found in recent planning programs implemented in languages such as conniveh  ref. 1   planner  ref. 1   and qa1  ref. 1 . the need for such additional knowledge representation mechanisms is evident as ai projects cont inue to move in the d i r e c t i o n of considering more complex task domains. the presentations here are meant to add an increment to our a b i l i t y to design and b u i l d such large systems. 
expressions and states 
　　　our modeling system is implemented as an extension of the qlisp programming language  ref. 1 .  note: qlisp is a direct descendant of the qa1 language and was designed to maintain qa1 language features while eliminating the i n e f f i c i e n c i e s i n troduced by the qa1 i n t e r p r e t e r . it is a set of functions loadable into the interl1sp  ref. 1  system  and qlisp  statements  are b a s i c a l l y c a l l s on these lisp functions. hence  the user can 
freely intermix qlisp and lisp code. the control features that were lost by eliminating the qa1 i n terpreter are currently being restored by making 
use of new control f a c i l i t i e s provided by the 1nterlisp system  ref. 1   . l each state description model can be thought of as a set of qlisp expressions  with each expression having a t r u t h value associated with i t . an expression t y p i c a l l y is a statement of a relationship among e n t i t i e s in the task domain such as objects  concepts  or other relationships. for example  the expression  connected pump platform  is a statement that the pump is connected to the platform  and the expression  fastener  connection pump platform  b1lt:1  is a statement that boltrl is a fastener of the pumpplatform connection. 
　　　although each qlisp expression has a l1spstyle property l i s t associated with i t   we use 
1 
these p r o p e r t y l i s t s i n our models o n l y f o r t r u t h values and bookkeeping i n f o r m a t i o n . t h e r e f o r e   i n s t e a d of p u t t i n g green as the v a l u e of the p r o p e r t y color on the p r o p e r t y l i s t of pump  we would c r e a t e the e x p r e s s i o n  color pump green  and put true as the v a l u e of the p r o p e r t y truthvalue on i t s p r o p e r t y l i s t . this convention c r e a t e s homogenous models and a l l o w s a p a t t e r n matching program to a s s o c i a t i v e l y r e t r i eve any r e l a t i o n s h i p in a 
model. 
     the qlisp c o n t e x t mechanism a l l o w s the system to b u i i d and m a n i p u l a t e a c o l l e c t i o n of s t a t e des c r i p t i o n s w i t h o u t having to c r e a t e and m a i n t a i n a complete copy of each s t a t e . a   c o n t e x t t r e e   is m a i n t a i n e d in which each node denotes a s t a t e . to represent the new s t a t e t h a t is produced by the occurrence of an event in some s t a t e s i   the system c r e a t e s a new node in the context t r e e as a d i r e c t descendent of the si node. a l l i n f o r m a t i o n i n s t a t e s i t h a t i s not e x p l i c i t l y changed i n the new s t a t e is assumed to also hold in the new s t a t e . that i s   each s t a t e i n h e r i t s model i n f o r mation from the s t a t e that is i t s parent in the context t r e e . 
	querying 	s t a t e 	descr i p t ion 	models 
t r u t h 	values 
     a s t a t e d e s c r i p t i o n model is a source of i n f o r m a t i o n ahout a p a r t i c u l a r s i t u a t i o n   and i t s primary use is as a data base for answering quer i e s about the s i t u a t i o n . our modeling system i n t e r a c t s w i t h i t s users   b o t h people and programs  as if qlisp expressions w i t h t r u t h values a t t a c h e d were the o n l y r e p r e s e n t a t i o n s being used  even though the opt ion e x i s t s for s t o r i n g i n f o r m a t i o n in o t h e r forms. hence  a l l queries from o u t s i d e the modeling system concern the t r u t h value of expressions in some given s t a t e . 
     when answering a query about a p a r t i c u l a r exp r e s s i o n in some g i v e n s t a t e   the system searches f o r a t r u t h v a l u e . the search begins w i t h the exp r e s s i o n ' s p r o p e r t y l i s t for the given s t a t e . i f 
     the p r o p e r t y truthvalue has no value on that p r o p e r t y l i s t   the p r o p e r t y l i s t f o r the given s t a t e ' s parent   i n the c o n t e x t t r e e   is checked. the search c o n t i n u e s in t h i s manner u n t i l a value is found o r u n t i l a l l the s t a t e s i n the context are c o n s i d e r e d . if no value is found  the search r e turns unknown as i t s r e s u l t . 
need since s t a t e d e s c r i p t ion mode is arc i n h e r c n t l y incomplete  and it is important for the s y s tem to be aware of what it doesn' t know as we 1 as 
what 	it 	does 	know. 
generators 	instead 	of 	b a c k t r a c k i n g 
       qlisp provides f a c i l i t i e s for a s s o c i a t i v e l y r e t r i e v i n g expressions from the data base that match any g i v e n p a t t e r n   where a p a t t e r n is def i n e d to be an e x p r e s s i o n t h a t may c o n t a i n unbound 
v a r i a b l e s . the qlisp statements f o r q u e r y i n g the data base use t h i s p a t t e r n matching f a c i l i t y and are s i m i l a r to the query statements found in planner and qaa. they are designed to f i n d a s i n g l e instance of a given p a t t e r n . to cause the p a t t e r n matcher to continue i t s search and o b t a i n another such i n s t a n c e   the u s e r ' s program must r e t u r n to the query statement v i a the language's b a c k t r a c k i n g mechanism   i . e .   b y   f a i l i n g     . 
       using b a c k t r a c k i n g in t h i s way to sequence through a class of expressions t h a t a l l match a g i v e n p a t t e r n has severe l i m i t a t i o n s i n that i t t i e s the s e q u e n t i a l p r o d u c t i o n of each e x p r e s s i o n to the c o n t r o l s t r u c t u r e of the u s e r ' s program. in p a r t i c u l a r   it r e q u i r e s t h a t the same p o r t i o n of the u s e r ' s program be executed f o r each e x p r e s s i o n  namely  the statements immediately f o l l o w i n g 
       the query s t a t e m e n t   . a l s o   since a l l the backt r a c k a b l e e f f e c t s o f t h a t port ion are being   u n done  a f t e r each f a i l u r e   it makes cumbersome the saving of r e s u l t s f o r each expression g e n e r a t e d . such a b a c k t r a c k i n g mechanism is best s u i t e d to a   g e n e r a t e - a n d - t e s t   s i t u a t i o n where the user des i r e s a s i n g l e e x p r e s s i o n that not o n l y passes the query s t a t e m e n t ' s t e s t s   but a l s o passes a d d i t i o n a l t e s t s i n c l u d e d i n the u s e r ' s program. 
       we have adopted the c1nn1ver s o l u t i o n to these l i m i t a t i o n s in our modeling system by p r o v i d i n g f u n c t i o n s that are g e n e r a t o r s o f e x p r e s sions from the data base. for example  t h e r e is a g e n e r a t o r v e r s i o n of the qlisp is statement c a l l e d 
       gen:is that f i n d s instances of a given p a t t e r n having t r u t h value true in a given s t a t e . each time a g e n e r a t o r f u n c t i o n such as gen:is is c a l l e d   it produces as many expressions as is c o n v e n i e n t f o r i t . these expressions are put on a   p o s s i b i l i t i e s l i s t   along w i t h a   t a g   t h a t i n d i cates how the g e n e r a t o r can be r e s t a r t e d when more expressions are requested  and t h i s p o s s i b i l i t i e s l i s t is r e t u r n e d by the g e n e r a t o r as i t s v a l u e . 

　　　since any e x p r e s s i o n can be s t o r e d as the value of p r o p e r t y truthvalue  t h i s r e t r i e v a l mechanism a l l o w s use of an n-valucd l o g i c . for examp l e   one could have   f u z z y   t r u t h values r e p r e sented as i n t e g e r s from -1 to +1. for our models  we c u r r e n t l y are using a 1-valued l o g i c 
　　　that a llows the system to d i s t inguish expressions that are  known t r u e      known f a l s e     or  have unknown t r u t h v a l u e   in any given s t a t e . this is the s i m p l i s t l o g i c thai meets a modeling systems 
       if the f u n c t i o n try:next is c a l l e d w i t h a p o s s i b i l i t i e s l i s t as an argument  it w i l l remove the f i r s t expression from the l i s t and r e t u r n i t as a v a l u e . if the p o s s i b i l i t i e s l i s t c o n t a i n s no e x p r e s s i o n s   then try:next attempts to produce new ones by u s i n g the tag to r e s t a r t the g e n e r a t o r . since each c a l l to try:next can be made from anywhere in the u s e r ' s program  g e n e r a t o r s of t h i s form s u c c e s s f u l l y separate the product ion of a 

1 

next data 	element 	from the process ing 	that 	is done on each element. 
       cons i d e r   	for example  	a set of q u e r i e s conc e r n i n g which 	components are 	connected 	to the pump in s t a t e s i . 	they can be 	i n i t i a l i z e d as 	f o l l o w s :  setq pl  gen:is  connected pump -c  s i     . 
then whenever one of these components is needed  e v a l u a t i o n of  try:.nf.xt pl  w i l l r e t u r n a t r u e i n stance of the p a t t e r n  connected pump-c  and w i l l set the value of the qlisp v a r i a b l e c to be the   f o u n d   component. 
       we have implemented programming f a c i l i t i e s to support the w r i t i n g atu! use of g e n e r a t o r f u n c t i o n s u s i n g 1ntkrl1sp funarc's. a funarc is a data object t h a t conceptua1ly r e p r e s e n t s a copy of a 
f u n c t i o n and a pr i v a t e data envi ronment 	for 	t h a t 
copy. this funakg imp omentation a 1 lows the def i n i t i o n of a generator f u n c t i o n to include a set of v a r i a b l e s   i . e .   a data environment  whose values w i l l be saved and r e s t o r e d each time the g e n e r a t o r is r e s t a r t e d . these  own v a r i a b l e s   a l l o w the g e n e r a t o r f u n d ion t o save p o i n t e r s i n d i e a t i n g 
where it is in its search f o r gene r a t a b l e iterns. the funarg j s added to the p o s s i b i l i t i e s l i s t as the   t a g   t h a t try:next uses to r e s t a r t the gene r a t o r . included in the implementation are connlver-style f u n c t i o n s such as note  au-revotr  adieu  and try:next  which make the d e f i n i t i o n and use of g e n e r a t o r s convenient and p r a c t i c a l . 
funarg's do not p r o v i d e a complete c o - r o u t i n e 
  p r o c e s s   f a c i l i t y because the c o n t r o l envi ronment is not saved between c a l i s   and t h e r e f o r e each r e s t a r t n e c e s s a r i l y r e t u r n s c o n t r o l t o the beginning of the f u n c t i o n . our experience w i t h g e n e r a t o r s   however  has i n d i c a t e d t h a t making a v a i l a b l e a first:call  p r e d i c a t e f u n c t i o n t h a t can be c a l l e d from i n s i d e a generator to d i s t i n g u i s h i n i t i a l c a l l s from r e s t a r t s removes e s s e n t i a l l y a l l o f the hindrance caused by not having a saved c o n t r o l environment . hence  t h i s implementat ion of generat o r s is simple and e f f e c t i v e and can be made 
a v a i l a b l e 	in most 	lisp systems. 
the query f u n c t i o n s 
       we can now d e s c r i b e our model q u e r y i n g mechanism. query f u n c t i o n s are a v a i l a b l e c a l l e d 
       deduce:one  deduce:each  deduce:all  refute:one  refute:each  and refute:all. each of these funct i o n s takes a p a t t e r n and a s t a t e as arguments. the deduce f u n c t i o n s f i n d instances of the p a t t e r n t h a t are t r u e in the g i v e n s t a t e   and the refute f u n c t i o n s f i n d i n s t a n c e s o f the p a t t e r n t h a t are f a l s e in the g i v e n s t a t e . the :one f u n c t i o n s f i n d o n l y a s i n g l e i n s t a n c e and are not r e s t a r t a b l e ; the :each f u n c t i o n s are generators and r e t u r n p o s s i b i l i t i e s l i s t s ; and the :all f u n c t i o n s r e t u r n a l i s t o f a l l the f i n d a b l e i n s t a n c e s . 
       known t r u t h values are u s u a l l y not a l l e x p l i c i t l y s t o r e d in a model. i n s t e a d   the user t y p i c a l l y provides d e r i v a t i o n f u n c t i o n s t h a t compute them when they are needed. these f u n c t i o n s may embody formal theorem p r o v i n g s t r a t e g i e s or s imply be statements of i m p i i c a t i o n a 1 r u l e s d e r i v e d from the semantics of the task domain. they serve to extend each model in the sense t h a t   from the c a l l i n g program's p o i n t o f view  the d e r i v e d i n stances of a p a t t e r n are i n d i s t i n g u i s h a b l e front i n stances a c t u a l l y found in the model. 
       our query f u n c t i o n s are s i m i l a r to a planner or qa1 goal statement in t h a t they f i r s t use the p a t t e r n matcher t o f i n d s u i t a b l e instances o f the p a t t e r n in the data base and then  if more i n stances are needed  they c a l l user s u p p l i e d f u n c t i o n s to attempt d e r i v a t i o n s of the desired i n s t a n c e s . these f u n c t i o n s are assumed to be g e n e r a t o r s t h a t produce d e r i v e d instances of the p a t t e r n . 
       for example  a d e d u c t i o n f u n c t i o n in the cbc system f i n d s and generates t r u e instances of p a t t e r n s of the form  positioned 'x -y  by u s i n g 
deduce:each 	to 	f i n d 	t r u e 	instances of 	the p a t t e r n 
 attached $x $y   s i n c e components t h a t are attached are assumed to be positioned. a l s o   a r e f u t a t i o n f u n c t i o n f i n d s and generates f a l s e i n stances of p a t t e r n s of the form  positioned -x -y  by u s i n g deduce:each to f i n d t r u e instances of the p a t t e r n  removed $x $y   since components t h a t are removed are assumed to be not positioned. 
       such d e r i v a t i o n f u n c t i o n s are the u s e r ' s p r i mary means of e x p r e s s i n g the semantic l i n k s among the r e l a t i o n s o c c u r r i n g i n the s t a t e d e s c r i p t i o n 
models. a l s o   they can p r o v i d e an i n t e r f a c e to i n f o r m a t i o n t h a t i s s t o r e d i n r e p r e s e n t a t i o n s o t h e r than qlisp e x p r e s s i o n s . that i s   it may be much 
more convenient and e f f i c i e n t to s t o r e some i n f o r mation i n a r r a y s   t r e e s   o r o n d i s k f i l e s ; deduce and r e f u t e a c t i o n s serve as the access f u n c t i o n s 
to 	these a l t e r n a t e data bases. 
storage and r e t r i e v a l . o f a c t i o n functions 
       the f i r s t element of each nonatomic e x p r e s s i o n in the model is assumed to be the name of a r e l a t i o n  or a qlisp v a r i a b l e t h a t is to be bound to a r e l a t i o n   . t h e r e f o r e   the deduce and refute f u n c t i o n s can use r e l a t i o n names as an index to d e termine which d e r i v a t i o n f u n c t i o n s should be c a l l e d . a c c o r d i n g l y   we a s s o c i a t e w i t h each r e l a t i o n two l i s t s o f d e r i v a t i o n f u n c t i o n s t h a t can d e r i v e instances o f p a t t e r n s t h a t begin w i t h the r e l a t i o n . one l i s t c o n t a i n s the  deduce a c t i o n s   used by the t h r e e forms of deduce and the o t h e r c o n t a i n s the   r e f u t e act i o n s   used by the t h r e e forms of refute. 
       this simple i n d e x i n g technique is used as an a l t e r n a t i v e t o   p a t t e r n d i r e c t e d i n v o c a t i o n   o f 
       the a c t i o n s  which is a v a i l a b l e in qlisp . 

1  

p a t t e r n d i r e c t e d i n v o c a t i o n   where a p a t t e r n is ass o c i a t e d w i t h each a c t i o n f u n c t ion and a p a t t e r n matcher determines which a c t i o n s are a p p l i c a b l e whenever a query is made  is a u s e f u l technique in many s i t u a t i o n s   but i t s power and importance should b e looked a t r e a l i s t i c a l l y . i n t h i s s i t u a t i o n the i n d e x i n g scheme seems p r e f e r a b l e even though it has the disadvantages t h a t an a c t i o n ' s l o c a l v a r i a b l e s do not a u t o m a t i c a l l y get bound to elements of the p a t t e r n and a d d i t i o n a l t e s t s may be needed in an a c t i o n to determine if it is a p p l i cable t o the p a t t e r n . 
       however  the i n d e x i n g scheme has the f o l l o w i n g advantages:  1  the use of the a c t i o n s is made more e f f i c i e n t by s i g n i f i c a n t l y r e d u c i n g the need f o r p a t t e r n m a t c h i n g ;   1   each l i s t o f deduce and r e f u t e a c t i o n s i s t y p i c a l l y q u i t e s h o r t s o t h a t the user can e a s i l y determine an a p p r o p r i a t e o r d e r i n g 
       of each l i s t and s i m i l a r l y can determine where on the l i s t a new a c t i o n should be i n s e r t e d ;  1  and  f i n a l l y   we have found t h a t a s s o c i a t i n g semantic i n f o r m a t i o n d i r e c t l y w i t h each r e l a t i o n is a conv e n i e n t way to c o n c e p t u a l i z e and l o c a l i z e the semantic i n f o r m a t i o n i n the system. with t h i s o r g a n i z a t i o n   the set o f a c t i o n f u n c t i o n s a s s o c i a t e d w i t h a r e l a t i o n s p e c i f y e s s e n t i a l l y a l l the semant i c i n f o r m a t i o n t h a t the system knows about t h a t r e l a t i o n . 
	saving 	derived results 
overview 
       when a model query causes d e r i v a t i o n s to be a t t e m p t e d   we want the r e s u l t s of those d e r i v a t i o n s to be s t o r e d and r e t a i n e d in succeeding s t a t e s as long as they remain v a l i d . in t h i s way the system achieves the maximum b e n e f i t from d e r i v a t i o n s and minimizes unnecessary r e d e r i v a t i o n s . it is a simple matter to s t o r e a r e s u l t in the s t a t e where a d e r i v a t i o n is done  but more care must be taken if the r e s u l t is to be made a v a i l a b l e i n o t h e r s t a t e s . i n t h i s s e c t i o n w e w i l l des c r i b e a set of mechanisms designed to p r o v i d e maximum r e t e n t i o n of d e r i v e d i n f o r m a t i o n w i t h a m i n i -
mum of bookkeeping overhead. 
       a model query is an a t t e m p t to f i n d t r u e  or f a l s e   instances of a g i v e n p a t t e r n . each time such an i n s t a n c e is d e t e r m i n e d   our deduce and refute query f u n c t i o n s save the d e r i v e d r e s u l t by a s s i g n i n g a t r u t h v a l u e to the i n s t a n c e   i . e .   put it as the value of truthvalue on the e x p r e s s i o n ' s p r o p e r t y l i s t   s o t h a t the v a l u e w i l l not have t o be r e d e r i v e d if it is needed a g a i n . for example  if a deduce a c t i o n f o r assembled determines t h a t the pump is assembled by q u e r y i n g the model about each of the pump's components  then the e x p r e s s i o n 
 assembled pump  w i l l be assigned a t r u t h v a l u e of true. 
       if a query 	is one of 	the 	:all forms  	or 	if 	it is an 	:each 	form and 	the g e n e r a t i o n continues u n t i l a l l d e r i v a b l e i n s t a n c e s o f the p a t t e r n are p r o duced  or if the query p a t t e r n c o n t a i n s no unbound v a r i a b l e s  and t h e r e f o r e has o n l y one p o s s i b l e i n s t a n c e     then the system a l s o records the f a c t t h a t a l l instances of the p a t t e r n have been d e r i v e d . then  if the same query is repeated  the system w i l l know t h a t the a c t i o n f u n c t i o n s cannot f i n d any new instances and can t h e r e f o r e prevent i l l - f a t e d a t t e m p t s at r e d e r i v a t i o n . for example  if d u r i n g a query a l l the components t h a t are p o s i t i o n e d w i t h 
       respect to the pump have been found as i n s t a n c e s of the p a t t e r n  positioned pump - c     then when t h a t i n f o r m a t i o n is requested in a l a t e r query  d e r i v a t i o n f u n c t i o n s such as the one t h a t looks f o r components a t t a c h e d to the pump w i l l not be r e c a l l e d . 
       these   s e t completeness i n d i c a t o r s   are a l s o f r e q u e n t l y u s e f u l to i n d i c a t e the case where t h e r e 
are no d e r i v a b l e instances of a p a t t e r n . for examp l e   i f a l l d e r i v a t i o n a t t e m p t s a r e u n s u c c e s s f u l a t d e t e r m i n i n g whether the pump is assembled  then the set of d e r i v e d instances is empty and marked as comp l e t e . 
	saving and m a i n t a i n i n g derived 	instances 
       our a l g o r i t h m s f o r m a i n t a i n i n g these saved d e r i v e d r e s u l t s i n succeeding s t a t e s depend o n a v a i l a b i l i t y o f the   s u p p o r t   f o r each d e r i v a t i o n . the   s u p p o r t   f o r a d e r i v e d i n s t a n c e is d e f i n e d to be those expressions from the model t h a t are used as 
axioms in c o n s t r u c t i n g the d e r i v a t i o n . for examp l e   i f a n a c t i o n f u n c t i o n q u e r i e s the model f o r the l o c a t i o n s of two o b j e c t s and concludes t h a t one 
of the o b j e c t s 	is above 	the o t h e r   	then 	the 	l o c a t i o n s of 	the 	two o b j e c t s 	form the support set 	f o r the r e s u l t . 	a c t u a l l y   	s i n c e any model 	query may r e t u r n a d e r i v e d r e s u l t   	the support set 	f o r 	the   a b o v e   	r e s u l t would be 	the union of 	the s u p p o r t sets 	f o r 	the 	two 	l o c a t i o n e x p r e s s i o n s . 
       the user s u p p l i e d deduce and 	r e f u t e a c t i o n s are r e s p o n s i b l e 	f o r computing and s t o r i n g s u p p o r t f o r each d e r i v e d 	i n s t a n c e t h a t 	they 	f i n d . 	i n a l -
most a l l cases t h i s is an easy task. for example  i f a n a c t i o n embodies the i m p l i c a t i o n   x i m p l i e s y     then the a c t i o n can s i m p l y f e t c h the support f o r x and a t t a c h it to y. get:support and put:support f u n c t i o n s are p r o v i d e d f o r p e r f o r m i n g these support set m a n i p u l a t i o n s . 
       functions are a l s o p r o v i d e d f o r deduce and r e f u t e a c t i o n s to c a l l when they have d e r i v e d a t r u t h 
       v a l u e f o r an i n s t a n c e of the query p a t t e r n and have determined the support f o r t h a t d e r i v a t i o n . these f u n c t i o n s add the e x p r e s s i o n to the c u r r e n t p o s s i -
b i l i t i e s l i s t  remember t h a t a c t i o n f u n c t i o n s are g e n e r a t o r s     set the t r u t h v a l u e   i . e .   truthvalue  of the i n s t a n c e   put the support set on the i n s t a n c e ' s p r o p e r t y l i s t   and put a p o i n t e r to the i n stance on the p r o p e r t y l i s t of each member of the support s e t . use of these f u n c t i o n s to   n o t e   der i v e d r e s u l t s i m p l i e s t h a t d e r i v e d t r u t h v a l u e s can be found by the p a t t e r n m a t c h e r ' s search through 
1 

the data base at the b e g i n n i n g of a model query  and each e x p r e s s i o n t h a t supports a d e r t v a t ion will have on i t s p r o p e r t y l i s t a p o i n t e r to the e x p r e s s i o n s t h a t i t s u p p o r t s . 
       a d e r i v e d r e s u l t remains v a l i d in succeeding s t a t e s as long as i t s support remains v a l i d . we t h e r e f o r e have the system do the r e q u i r e d m a i n t e nance on d e r i v e d i n s t a n c e s in new s t a t e s by i n c l u d i n g w i t h the s t a n d a r d model u p d a t i n g f u n c t i o n s   d e s c r i b e d below  the f o l l o w i n g f a c i l i t y . whenever an e x p r e s s i o n w i t h a known t r u t h value has i t s t r u t h v a l u e changed d u r i n g a model update  the t r u t h value o f each o f the expressions that i t sup-
p o r t s is set to unknown in the new s t a t e . the t r u t h values of these   s u p p o r t e e s   may not in f a c t have changed in the new s t a t e   but the d e r i v a t i o n s that made the t r u t h values known are no longer 
v a l i d . hence  if a model query in the new s t a t e needs to know one of the d e l e t e d t r u t h v a l u e s   a new d e r i v a t ion must be a t t e m p t e d . for example  if  attached pump platform  is the support f o r  positioned pump platform  and a detach pump from p l a t f o r m a c t i o n causes a new s t a t e to be c r e a t e d   then the t r u t h value of  positioned pump platform  w i l l be set to  unknown   the pump may s t i l l be in p o s i t i o n o n the p l a t f o r m   but the j u s t i f i c a t i o n f o r the e a r l i e r c o n c l u s i o n about the pump's p o s i t i o n i s n o longer v a l i d . 
       the mechanism we have d e s c r i b e d thus f a r is e f f e c t i v e   easy to use  and e f f i c i e n t for saving and m a i n t a i n i n g d e r i v e d t r u t h values o f e x p r e s sions t h a t are instances of a query p a t t e r n . each d e r i v e d i n s t a n c e is assigned a t r u t h v a l u e   the support p o i n t e r s are e s t a b l i s h e d   and when a s t a t e t r a n s i t i o n i n v a l i d a t e s the d e r i v a t i o n the d e r i v e d t r u t h v a l u e i s d e l e t e d . 
saving and m a i n t a i n i n g complete sets 
       consider now the maintenance of the   c o m p l e t e ness  i n d i c a t o r s t h a t are a t t a c h e d t o p a t t e r n s when a l l d e r i v a b l e i n s t a n c e s have been found. s p e c i f y i n g the support f o r such i n d i c a t o r s poses some s u b t l e problems  because the completeness d e pends not o n l y on the v a l i d i t y of the d e r i v e d i n stances but a l s o on whether any o t h e r instances are d e r i v a b l e . t h i s l a t t e r c o n s i d e r a t i o n i m p l i e s t h a t if any change should occur in a succeeding s t a t e t h a t c o u l d p o s s i b l y a l l o w some a c t i o n f u n c t i o n to d e r i v e a new i n s t a n c e   then the completeness i n d i c a t o r should be removed from the p a t t e r n in the new s t a t e * for example  d u r i n g the d e t e r -
m i n a t i o n o f a l l the components t h a t are p o s i t i o n e d w i t h r e s p e c t to the pump  some deduce a c t i o n may have looked f o r components t h a t are a t t a c h e d to the pump. t h e r e f o r e   any succeeding s t a t e p r o duced by an a c t i o n t h a t a t t a c h e s a component to the pump w i l l cause the removal of the complete-
ness i n d i c a t o r from the d e r i v e d p o s i t i o n i n g s . each d e r i v e d i n s t a n c e w i l l s t i l l b e v a l i d i n the new s t a t e ; o n l y the completeness of the set is in doubt. 
we have approached t h i s problem of the v a l i d i t y of completeness 	i n d i c a t o r s 	by keeping a 	record 
of a l l the model q u e r i e s made d u r i n g a d e r i v a t i o n . i f any o f these q u e r i e s w i l l produce d i f f e r e n t r e s u l t s in a new s t a t e   i . e .   a d i f f e r e n t set of der i v e d i n s t a n c e s     then the a c t i o n f u n c t i o n s t h a t made the o r i g i n a l d e r i v a t i o n may behave d i f f e r e n t l y in the new s t a t e and in p a r t i c u l a r may der i v e a d i f f e r e n t set of i n s t a n c e s . t h e r e f o r e   to m a i n t a i n the completeness i n d i c a t o r s we record d u r i n g a model query   i . e .   a c a l l on one of the deduce or refute f u n c t i o n s   a l l the o t h e r model q u e r i e s t h a t occur. 
       consider a query 	to 	f i n d 	instances of a p a t t e r n po d u r i n g which are executed q u e r i e s q1  
q1  . . .   qn to f i n d i n s t a n c e s of p a t t e r n s p1  p1  . . .   pn. the system records f o r each query ql whether it is a d e d u c t i o n or a r e f u t a t i o n and t h e p a t t e r n p i a s s o c i a t e d w i t h i t . i f a l l d e r i v a b l e 
i n s t a n c e s of po are found  then po is g i v e n a com-
p l e t e n e s s i n d i c a t o r   the set o f d e r i v e d i n s t a n c e s i s put o n i t s p r o p e r t y l i s t   the q u e r i e s q l   . . .   qn are put on   s t a t e t r a n s i t i o n t e s t l i s t s     and a p o i n t e r to p a t t e r n po is put on the p r o p e r t y l i s t of each of the p a t t e r n s p1  ....  pn. 
       whenever an e x p r e s s i o n w i t h a known t r u t h 
       v a l u e is h a v i n g i t s t r u t h v a l u e changed d u r i n g a s t a t e t r a n s i t i o n   a t e s t is made to determine if it matches the p a t t e r n of any query on the a p p r o p r i a t e s t a t e t r a n s i t i o n t e s t l i s t . i f a match o c c u r s   the completeness i n d i c a t o r s of the p a t t e r n s p o i n t e d to by the matching p a t t e r n are removed s i n c e t h i s s t a t e t r a n s i t i o n may a f f e c t the comp l e t e n e s s o f those d e r i v a t i o n s . this e n t i r e mechanism is b u i l t i n t o the deduce  refute  and model u p d a t i n g f u n c t i o n s   so that the user who w r i t e s a c -
t i o n f u n c t i o n s need not 	be aware of i t . 
in 	summary 
       to summarize  our model q u e r y i n g mechanisms p r o v i d e f o r the a u t o m a t i c d e r i v a t i o n o f t r u t h values f o r p a t t e r n i n s t a n c e s when they are not e x p l i c i t l y s t o r e d in the model  f o r the saving of a l l such d e r i v e d r e s u l t s s o t h a t s i m i l a r l a t e r quer i e s w i l l not r e i n i t i a t e the d e r i v a t i o n f u n c t i o n s   and f o r the maintenance of such saved r e s u l t s . a l s o   an important side e f f e c t of these mechanisms is t h a t each d e r i v e d i n s t a n c e has the support f o r i t s d e r i v a t i o n s computed and s t o r e d w i t h i t . such support i n f o r m a t i o n has many uses because it i n d i cates p r e c i s e l y which statements in the s t a t e model a p a r t i c u l a r p r e c o n d i t i o n   subgoal  or ac-
t i o n depends on  ref. 	1   . 
	s t a t e 	t r a n s i t i o n s 
updating 	functions 
       the models of s t a t e changing o p e r a t o r s that a system works w i t h must c o n t a i n s u f f i c i e n t i n f o r m a t i o n about the e f f e c t s of each o p e r a t o r so t h a t 

1 

they can be s i m u l a t e d and a d e s c r i p t i o n produced of the expected r e s u l t i n g s t a t e . as in most p l a n n i n g systems  we are assuming t h a t the a p p l i c a t i o n of an o p e r a t o r in some s t a t e so is modeled by p r o d u c i n g a new s t a t e s1 t h a t is c o n c e p t u a l l y an updated copy of so   i . e .   s1 is a d i r e c t descendent of so in the qlisp c o n t e x t t r e e   . the e f f e c t s of the o p e r a t o r arc i n d i c a t e d by a s s e r t i n g   d e n y i n g   and d e l e t i n g expressions in the new s t a t e 
s1. 
       in our modeling system we p r o v i d e the f o l l o w i n g set of model updat ing s t a t e m e n t s : 
	 s1m:assert 	  e x p r e s s i o n 	  s t a t e       
 s1m:deny  -expression .   s t a t e       and  sim: delete   - p a t t e r n s   s t a t e  . 
sim:assert  sim:deny  changes the t r u t h v a l u e of the g i v e n e x p r e s s i o n to true  false  in the g i v e n s t a t e . sim:delete changes the t r u t h v a l u e o f a l l express ions t h a t match the g i v e n p a t t e r n to unknown in the g i v e n s t a t e . these statements a l s o c a l l a sot of user s u p p l i e d f u n c t i o n s   l i k e planner antecedent theorems  t h a t t y p i c a l l y make a d d i t i o n a l changes in the new model t h a t are d i r e c t r e s u l t s o f the a s s e r t i o n   d e n i a l   o r d e l e t i o n being done. these user s u p p l i e d f u n c t i o n s p l a y an i m p o r t a n t r o l e i n s i m p l i f y i n g o p e r a t o r models i n t h a t they a l l o w the user to express in one p l a c e 
s i d e e f f e c t s o f p a r t i c u l a r a s s e r t i o n s   d e n i a l s   o r d e l e t i o n s t h a t always occur no m a t t e r what o p e r a t o r does them. in t h i s way  these s i d e e f f e c t s do not have to be repeated in each o p e r a t o r t h a t causes them to occur. 
       as in the case of the deduce and refute f u n c t i o n s  and f o r s i m i l a r r e a s o n s     we have e l e c t e d t o s t o r e the user s u p p l i e d u p d a t i n g f u n c t i o n s o n each r e l a t i o n ' s p r o p e r t y l i s t . hence  a r e l a t i o n can have a l i s t of assert:actions  deny:actions  and delete:actions. these l i s t s i n d i c a t e how a model u p d a t i n g o p e r a t i o n should proceed f o r an exp r e s s i o n h a v i n g the g i v e n r e l a t i o n a s i t s f i r s t element. 
       the s t a n d a r d model u p d a t i n g f u n c t i o n s  as found in qa1  planner  qlisp  conniver  e t c .   app l y user s u p p l i e d f u n c t i o n s o n l y a f t e r the e x p r e s s i o n ' s t r u t h v a l u e has been changed. o f t e n i t would be convenient to have user s u p p l i e d f u n c t i o n s a p p l i e d b e f o r e the e x p r e s s i o n ' s t r u t h value is changed as w e l l as a f t e r . for example  if a r e l a t i o n l i k e location has c e r t a i n uniqueness p r o p e r t i e s   then any a s s e r t i o n of an e x p r e s s i o n cont a i n i n g t h a t r e l a t i o n  such as  location b1lt:1 1     can a u t o m a t i c a l l y be preceeded by a d e n i a l  such as  sim:deny  location b1lt:1  -loc   . by a l l o w i n g the programmer to s p e c i f y such an a u t o matic d e n i a l in an a s s e r t   p r e - a c t i o n     we remove the n e c e s s i t y for s p e c i f y i n g the d e n i a l each time such an a s s e r t i o n is done. 
       we p r o v i d e f o r both   p r e - a c t i o n s   and   p o s t a c t i o n s   d u r i n g model u p d a t i n g by g i v i n g the p r o grammer the opt ion of s p e c i f y i n g when the t r u t h v a l u e of the expression will be changed. this is done by i n c l u d i n g an a s t e r i s k  *  in the act ion l i s t . the a s t e r i s k i n d i c a t e s when in the course 
of a p p l y i n g the a c t i o n s t h a t the e x p r e s s i o n ' s t r u t h value is to be changed. hence  a l l a c t i o n s preceeding the a s t e r i s k are   p r e - a c t i o n s   and all a c t i o n s f o l l o w i n g the a s t e r i s k are   p o s t - a c t i o n s .   
       when the u p d a t i n g f u n c t i o n s encounter the a s t e r i s k i n the a c t i o n l i s t   they a l s o p e r f o r m the maintenance o p e r a t i o n s on d e r i v e d r e s u l t s . this means t h a t if the e x p r e s s i o n had a known t r u t h 
       v a l u e and t h a t value is being changed  then a l l the e x p r e s s i o n ' s supportees must be d e l e t e d . a l s o   the s t a t e t r a n s i t i o n t e s t l i s t s are checked t o determine if any set completeness i n d i c a t o r s should 
be removed. 
model updating using. deduce and refute a c t i o n s 
       the i n f o r m a t ion in many deduce and r e f u t e act i o n s can a l s o be used to determine the secondary e f f e c t s of a s s e r t i o n s and d e n i a l s . we would l i k e f o r the system to make use of t h i s in format ion 
d u r i n g model u p d a t i n g so t h a t the user does not have to d u p l i c a t e it in updat ing f u n c t i o n s . for example  if the user has w r i t t e n a deduce act ion t h a t embodies the r u l e  x i m p l i e s y     then we do not want him to also have to w r i t e a deny a c t i o n f o r y t h a t removes from the model any t r u t h v a l u e s t h a t could be used to d e r i v e x. the in format ion necessary to do these changes at the a p p r o p r i a t e 
time i s i n c l u d e d i n the o r i g i n a l deduce a c t i o n . 
       consider a c o n s i s t e n c y checking procedure t h a t would make use of deduce and r e f u t e a c t i o n s 
and t h a t could be a p p l i e d as a s t a n d a r d p a r t of model u p d a t i n g . we can d e s c r i b e t h i s procedure by i n d i c a t i n g how it would work f o r d e n i a l s . the t r u t h v a l u e of the e x p r e s s i o n being denied would be set to unknown and an attempt would be made to deduce the e x p r e s s i o n . if t h i s attempt produces a s u c c e s s f u l d e r i v a t i o n   then the new s t a t e c o n t a i n s support f o r the t r u t h of the e x p r e s s i o n even though it is being d e n i e d . the i n c o n s i s t e n c y can be e l i m i n a t e d by removing the support f o r the d e r i v a t i o n . if the support set has e x a c t l y one e x p r e s s i o n i n i t   then t h a t e x p r e s s i o n can have i t s t r u t h v a l u e r e v e r s e d .   t h i s is the  x i m p l i e s y  case where denying y is i m p l y i n g t h a t x should a l s o be d e n i e d .   the reversed t r u t h value would be s t o r e d as a d e r i v e d r e s u l t w i t h the o r i g i n a l e x p r e s s i o n t h a t is being denied  y  as i t s s u p p o r t . when the support set c o n t a i n s more than one e x p r e s s i o n   we know t h a t at l e a s t one of the e x p r e s s i o n s 
must have i t s t r u t h v a l u e r e v e r s e d   but we do not know which o n c   s   . t h e r e f o r e   the best we can do is set to unknown the t r u t h values of a l l the sup-
	p o r t 	e x p r e s s i o n s . 
1 

         if the system knows which r e l a t i o n s are changeabie by events and winch ones are t r u e in a l l s t a t e s   then it can decrease unnecessary d e l e t ions by removing the unehangcable expressions from the support set before cons i d e r i n g d e l e t i o n s or a t r u t h v a l u e r e v e r s a l - a f t e r the support f o r the d e r i v a t i o n has been removed  a new d e r i v a t i o n is a t tempted and the process is repeated u n t i l no new 
d e r i v a t i o n can be 	tound. 
　　　　this u p d a t i n g procedure does not guarantee c o n s i s t e n c y in the new stalc nor does i t prevent l a t e r chanpes to the s t a t e from i n t r o d u c i n g new i n -
consis t e n d os. however  it does a u t o m a t i c a l l y take care of many model u p d a t i n g d e t a i l s and it removes a l l e x i s t ing incons i s t o n e i o s i n the s t a t e t h a t arc d i s c o v e r a b l c by the system's d e d u c t i v e machinery. if the system cannot d e r i v e the f a c t s from which an i n c o n s i s t e n c y f o l l o w s   then the i n c o n s i s t e n c y i s i r r e l e v a n t and can s a f e l y be i g n o r e d . 
　　　　o b v i o u s l y   there are s i t u a t i o n s in wbich t h i s procedure i n i t i a t e s computat i o n a l l y expensive der i vat ions and causes many unnecessary d e l e t i o n s . hence  i t must be s e l e c t i v c l y a p p l i e d . we have put the e n t i r e process under user c o n t r o l by a l l o w i n g i n d i v i d u a l s p e c i f i c a t i o n of which deduce and r e f u t e 
a c t i o n s are employed 	to determine 	t r u t h value d e l e t i o n s and r e v e r s a l s d u r i n g model 	u p d a t i n g . 	this 	is done by p r o v i d i n g a 	f u n c t i o n update:w1th t h a t 	takes a deduce or r e f u t e a c t i o n and an e x p r e s s i o n as a r guments  	and 	is used 	to s p e c i f y an a s s e r t or deny a c t i o n . 
　　　　note that using an  x i m p l i e s y  deduce act i o n as a deny a c t i o n for y is not the same as wr i t ing a deny act ion f o r y t h a t s i m p l y denies x. the d i f f e r e n c e is that in the l a t t e r case x would be denied each time y is d e n i e d   and the deny act i o n s a s s o c i a t e d w i t h x would then t r i g g e r o f f 
o t h e r a s s e r t i o n s   d e n i a i s   and d e l e t i o n s . such a process cou id c l u t t e r up the model w i t h many i r r e l evant i m p l i c a t ions of the d e n i a l of y. however  in the former case where the deduce act ion is used as the deny a c t i o n for y  no changes are made in the 
model if x cannot be d e r i v e d ; and if x can be der i v e d   o n l y the supporters of the d e r i v a t i o n are changed. thi s means t h a t o n l y those t r u t h values t h a t are a c t u a l l y i n c o n s i s t e n t w i t h the d e n i a l of y 
are changed; 	no 	i r r e l e v a n t 	i m p l i c a t i o n s are s t o r e d . 
the r e l a t i o n s and   ok. 	and not 
　　　　and  ok  and not arc   b u i l t i n t o   our modeling system in the sense t h a t deduce  r e f u t e   a s s e r t   deny  and d e l e t e a c t i o n s have been w r i t t e n for each of them. whenever p o s s i b l e   c o n j u n c t i o n s   d i s j u n c t i o n s   and negations are decomposed i n t o more p r i m i t i v e forms by the a c t i o n f u n c t i o n s . for example  the a s s e r t a c t i o n f o r and a l s o a s s e r t s each of the c o n j u n c t s   and the deduce a c t i o n f o r not s t r i p s o f f the not from the query p a t t e r n and attempts to r e f u t e the remaining p a t t e r n . 
       the r e f u t e a c t i o n s f o r and and or t r a n s l a t e the query i n t o a c a l l on deduc♀:each by u s i n g the r u l e s : 
	  not x i   and . . . 	and  not xn   	i m p l i e s 
	 not   x i or . . . or xn   	and 
  not x i   or . . . or  not xn   i m p l i e s  not  xi and . . . and xn  . 
the deduce a c t i o n s f o r and and or have an import a n t r o l e to p l a y in t h a t they are the o v e r l o r d s 
o f the d e r i v a t i o n s o f each c o n j u n c t o r d i s j u n c t . they could each be expanded i n t o f u l l problem s o l v i n g e x e c u t i v e s t h a t would make use of cor o u t i n e f a c i l i t i e s t o e x p l o r e a l t e r n a t i v e d e r i v a t i o n s i n p a r a l l e l and semantic i n f o r m a t i o n t o determine the o r d e r i n which c o n j u n c t s o r d i s j u n c t s 
are c o n s i d e r e d . we have experimented w i t h o n l y u n s o p h i s t i c a t e d v e r s i o n s o f these a c t i o n s   but the i m p o r t a n t p o i n t to note is t h a t the query mecha-
ni sm g i v e s 	those act ions 	c o n t r o l over 	the d e r i v a t i o n so 	t h a t 	the o p t i o n 	is 	t h e r e to expand 	them 
when needed. 
summary 
       we have d e s c r i b e d a set of programming f a c t 1 i t i e s f o r b u i l d i n g   m a i n t a i n i n g   and q u e r y i n g s t a t e d e s c r i p t i o n models. these f a c i l i t i e s are u s e f u l in systems such as p l a n n e r s   q u e s t i o n a n swerers  and s i m u l a t o r s . they a l l o w the s t o r a g e and r e t r i e v a l o f statements w i t h t r u e   f a l s e   and unknown t r u t h v a l u e s   and p r o v i d e a programming e n vironment t h a t a l l o w s d e r i v a t i o n r u l e s embodying the semantics of a task domain to be e a s i l y added as f u n c t i o n s to the system. these r u l e s can a l s o be used to a s s i s t in modeling the e f f e c t s of an o p e r a t o r t h a t c r e a t e s a new s t a t e . f a c i l i t i e s arc p r o v i d e d t o save the r e s u l t s o f these d e r i v a t i o n f u n c t i o n s   and to d e l e t e the r e s u l t s in new s t a t e s 
whore the d e r i v a t i o n s are n o longer v a l i d . f i n a l l y   the semantics of c o n j u n c t i o n s   d i s j u n c t i o n s   and 
negations are p r o v i d e d as a p a r t of the system. 
acknowledgments 
       many people at the sri al center have c o n t r i b uted to the development of t h i s system. 1 wish to e s p e c i a l l y thank marty r a t t n e r   e a r l s a c e r d o t i   and georgia s u t h e r l a n d f o r t h e i r i m p o r t a n t h e l p . the work r e p o r t e d h e r e i n was sponsored by the advanced research p r o j e c t s agency of the department of defense under c o n t r a c t dahc1-c-1 w i t h the u.s. 
army research o f f i c e . 
