 
traditional methods for explaining programs provide explanations by converting to english the code of the program or traces of the execution of that code while such methods can provide adequate explanations of what the program does or did  they typically cannot provide justifications of the code without resorting to canned-text explanations. that is  such systems cannot tell why what the system is doing is a reasonable thing to be doing. the problem is that the knowledge required to provide these justifications is needed only when the program is being written and does not appear in the code itself. 
　　　　the xplain system uses an automatic programmer to generate the consulting program by refinement from abstract goals. the automatic programmer uses a domain model  consisting of facts about the application domain  and a set of domain principles which drive the refinement process forward. by examining the refinement structure created by the automatic programmer it is possible to provide justifications of the code. this paper discusses the system described above and outlines additional advantages this approach has for explanation. 
1 . i n t r o d u c t i o n 
　　　　to be acceptable  expert programs must be able to explain what they do and justify their actions in terms understandable to the user. expert programs usually have some heuristic basis while these heuristics may provide good performance for most cases  there may be unusual cases where they produce erroneous results  or where the rationale for using them is faulty. if a user is suspicious of the advice he receives  he should be able to ask-for a description of the methods employed and the reasons for employing them. in addition  the scope of expert systems  like that of human experts  is often quite narrow. an explanation facility can help a user discover when a system is being pushed beyond the bounds of its expertise. 
　　　　in the area of medical consultant programs1 the need for explanation is particularly acute. in designing a consultant program  we must consider what sorts of capabilities we are trying to provide tor the physician user. if we consider the interaction between a physician and a human consultant  we realize that it is not just a simple oneway exchange where the physician provides data and the consultant provides an answer in the form of a prescription or diagnosis. rather  there is typically a lively dialog between the two. the physician may question whether some factor was considered or what effect a particular finding had on the final outcome. viewed in this light  we realize that a computer program which only collects data and provides a final answer will not be found acceptable by most physicians. in addition to providing diagnoses or prescriptions  a consultant program must be able to explain what it's doing and justify why it's doing it. 
　　　　researchers have recognized this  and many proposals for new expert systems have at least mentioned the need for explanation. some systems have actually provided an explanatory facility. yet existing approaches to explanation fail in some important ways. this paper will document these failings and describe an approach toward their solution. 
　　　　while we have concentrated on the problem of providing explanations to medical personnel  we do not feel that the need for explanation is limited to medicine nor that the techniques we have developed for explanation and justification are limited to medical applications. medical programs provide a good testbed for the general problem of explaining a consulting program to the audience it is intended to serve. 
the next section will describe the digitalis therapy 
advisor  the program we have chosen as a testbed for our ideas about explanation  and some of the medical aspects of digitalis therapy. after that  we will describe some of the problems with previous explanation systems and the approach we have taken to overcome those problems. 
1. digitalis therapy and the digitalis advisor 
　　　　the digitalis glycosides are a group of drugs that were originally derived from the foxglove  a common flowering plant. their principal effect is to strengthen and stabilize the heartbeat. 
inability of the heart to provide the body with an adequate blood 
1 author's current address usc/lnformation sciences institute. 	this research in current practice  digitalis is prescribed chiefly to patients who show signs of congestive heart failure  chf  and/or conduction disturbances of the heart. congestive heart failure refers to the 

was supported  in part  by the national institutes of health grant no 1 p1 lm 1 from the national library of medicine the author wishes to express his thanks to peter szolovits for his insightful comments and suggestions during the course of this research 
1 some medical consultant programs include mycin-a program that aids physicians with antimicrobial therapy  shortliffe1   internist-a program that makes diagnoses in internal medicine  pople1  and pip-a program that makes diagnoses primarily in the area of renal disease  pauker1  

flow this condition causes fluid to accumulate in the lungs and outer extremities and it is this aspect that gives rise to the term  congestive . digitalis is useful in treating this condition  because it increases the contractility of the heart  making it a more effective pump a conduction disturbance appears as an arrhythmia  which is an unsteady or abnormally paced heartbeat. digitalis tends to slow the conduction of electrical impulses through the conduction system of the heart  and thus steady certain types of arrhythmias. due to the positive effect that digitalis has on the heart  it is one of the most commonly used drugs in the united states. 
　　　　like many other drugs  digitalis can also be a poison if too much is administered for a variety of reasons  including a small therapeutic window  subtle signs of toxicity  and high interpatient variability  digitalis is difficult to administer one complication the physician must deal with is the possibility that his patient may be more sensitive to the drug  for whatever reason  than the average patient if a physician knows those factors that make a patient more sensitive he can reduce the likelihood of overdosing  or underdosing  the patient by adjusting the dose depending on whether he observes the sensitizing factors or not. 
　　　　over the years  a number of factors have been identified that increase the automaticity of the heart.1 these include  a low level of serum potassium  hypokalemia   a high level of serum calcium  hypercalcemia   damage to the heart muscle  cardiomyopathy   and a recent myocardial infarction  among others . when these exist in conjunction with digitalis 
administration  the automaticity can be increased substantially. 
we will concentrate on just the first three in this paper.1 
1 the digitalis therapy advisor testbed 
　　　　a few years ago  a digitalis therapy advisor was developed at mit by pauker  silverman  and gorry  silverman1  gorry1 . this program was later revised and given a preliminary explanatory capability  swartout1 . the limitations of these explanations  and of those produced by similar techniques  will be discussed below. this program differed from earlier digitalis advisors  peck1. jelliffe1  jelliffe1  sheiner1  in two important respects. first  when formulating dosage schedules  it anticipated possible toxicity by taking into account the factors that increased digitalis sensitivity and reduced the dose when those factors were present. second  the program made assessments of the toxic and therapeutic effects which actually occurred in the patient after receiving digitalis to formulate subsequent dosage recommendations. this program worked in an interactive fashion the program would ask the physician for data about the patient and produce recommendations after that data was entered. when 
1 in the normal heart  there is a place in the left atrium called the sinoatrial  sa  node  which sets the pace for the heart under the right circumstances  other pans of the heart can take over the pace setting function sometimes this can be life-saving if. tor example  the sa node is damaged but at other times it can be life-threatening  since several pace-makers operating simultaneously tend to increase the likelihood of setting up s dangerous arrhythmia when we say that digitalis increases the automaticity of the heart  we mean that digitalis increases the tendency of other parts of the heart to take over the pace-setting function from the sa node 
1 the xplain system currently only knows about the first three factors  although it would not be particularly difficult to expand it to cover the others 
the dose of digitalis was being adjusted  the physician was asked to consult with the program again to assess the patients response this is the program we used as a testbed for our work in explanation and justification in the remainder of the paper  we will refer to this program as the  old digitalis advisor  
1. kinds of questions 
         in the spring of 1  we conducted a series of informal trials in an attempt to discover what kinds of questions occurred to medical personnel as they ran the digitalis advisor in this trial  medical students and fellows were asked to run the program and ask questions  verbally  as they occurred to them. the author attempted to answer these questions. the interactions were tape recorded and later transcribed. 
         no formal analysis of the data was attempted  but examination of the transcripts did provide an indication of types of questions that might arise while running a consulting program these included: 
1 questions about the methods the program employed: 
user:  how do you calculate your body store goap 
that's a little lower than i anticipated.  
this sort of question could be answered by the explanation routines of the old digitalis advisor. it can also be answered by the system presented in this paper. 
1. justifications of the program's actions: 
user:  peruses recommendations   why do we want to make a temporary reduction  
author:  we're anticipating surgery coming up and surgery  even non-cardiac surgery  can cause increased sensitivity to digitalis  so it wants to temporarily reduce the level of digitalis   
this is exactly the sort of question we are concentrating on in this paper 
1. questions involving confusion about the meaning of terms: 
is the renal function stable'' the possibilities are: 
1. stable 
1. unstable 
enter single value = = = =  
user:  now this question...i'm not really sure...'renal function stable' does it mean stable abnormally or...because i mean  the patient's renal function is not normal but it's stable at the present time.   
	author 	 that's what it means  
this paper will not address this last type of question. 
1 

1. previous approaches to explanation 
　　　　a number of different approaches have been taken to attempt to provide programs with an explanatory capability. the major approaches include using 1  previously prepared text to provide explanations and 1  producing explanations directly from the computer code and traces of its execution 
         the simplest way to get a computer to answer questions about what it is doing is to anticipate the questions and store the answers as english text. only the text that has been stored can be displayed. this is called canned text  and explanations produced by displaying canned text are called canned explanations. the simplest sorts of canned explanations are error messages. for example  a medical program designed to treat adults might print the following message if someone tried to use it to treat an infant: 
the patient is too young to be treated by this program. 
it is relatively easy to get a small program to provide english explanations of its activity using this canned text approach. after the program is written  canned text is associated with each part of the program explaining what that part of the program is doing. when the user wants to know what's going on  the computer merely displays the text associated with what it's doing at the moment. 
　　　　there are several problems with the canned text approach to explanation the fact that the program code and the text strings that explain that code can be changed independently makes it difficult to guarantee consistency between what the program does and what it claims to do. another problem with the canned text approach is that all questions and answers must be anticipated in advance and the programmer must provide answers for all the questions that the user might ask. for large systems  that is a nearly impossible task finally  the system has no conceptual model of what it is saying that is  to the computer  one text string looks much like any other  regardless of the content of that string. thus  it is difficult to use this approach if we want our system to provide more advanced sorts of explanations such as suggesting analogies or giving explanations at different levels of abstraction. 
to check sensitivity due to calcium i do the following steps: 
1. i do one of the following: 
1 if either the level of serum calcium is greater than 1 or intravenous calcium is given then i do the following substeps. 
1.1 i set the factor of reduction due to hypercalcemia to 1. 
1.1 add hypercalcemia to the reasons of reduction. 
1 otherwise  i remove hypercalcemia from the reasons of reduction and set the factor of reduction due to hypercalcemia to 1. 
fig. 1. explanation of how the system checks hypercalcemia 
　　　　another approach to explanation is to produce explanations directly from the program  davis1  shortliffe1  swartout1  wmograd1 . that is  the explanation routines examine the program that is executed. then by performing relatively simple transformations on the code these explanation routines can produce explanations of how the system does things. for example  the old digitalis advisor could examine the code it used to check for increased digitalis sensitivity caused by increased serum calcium and produce an explanation of what that code did  as shown in figure 1 . 
　　　　the digitalis advisor  like most similar systems  also maintains an execution trace the trace can be examined by the explanation routines to tell what the system did for a particular patient figure 1 describes how the system checked for myxedema. the system also has a limited ability to explain why it is asking the user a question figure 1 shows the system's response when the user wants to know why he is being asked about serum calcium. 
　　　　since the explanation routines only perform simple transformations on the program code  the quality of the explanations produced in this manner depends to a great degree on how the system code is written. in particular  the basic structure of the program is not altered significantly  and the names of variables in the explanation are basically the same as those in the program. if the explanations are to be understandable  the expert system must be written so that its structure is easily understood by anyone familiar with its domain of expertise  and the variable and procedure names used in the program must represent concepts which are meaningful to the user. 
i checked sensitivity due to thyroid function by executing the following steps: 
1. i asked the user the status of myxedema. the user 
responded that the status of myxedema was present. 
1. since the status of myxedema was present i did the following: 
1 i added myxedema to the present and correctable conditions. the present and 
correctable conditions then became myxedema. 
1 i removed myxedema from the degradable conditions the degradable conditions then became hypokalemia  hypoxemia  
cardiomyopathies-mi  and potential potassium 
loss due to diuretics 
1 i set the factor of reduction due to myxedema to 1. the factor of reduction due to myxedema was previously undetermined. 
1 i added myxedema to the reasons of 
reduction. the reasons of reduction then became myxedema 
fig. 1. explaining how thyroid function was checked 


　　　　this method of producing explanations has some advantages it is relatively simple. if the right way of structuring the problem can be found  it does not impose too great a burden on the programmer; since the explanations reflect the code directly  consistency between explanation and code is assured. 
         despite these advantages  there are some serious problems with this technique it may be difficult or impossible to structure the program so that the user can easily understand it. the fact that every operation performed by the computer must be explicitly spelled out sometimes forces the programmer to program operations which a physician would perform without thinking about them. that problem is illustrated in figure 1. steps 1  1  and 1 are somewhat mystifying. in fact  these steps are needed by the system so that it can record what sensitivities the patient had that made him more likely to develop digitalis toxicity. these steps are involved more with record keeping than with medical reasoning  but they must appear in the code so that the computer will remember why it made a reduction. since they appear in the code  they are described by the explanation routines  although they are more likely to confuse a physician user than enlighten him. an additional problem is that it is difficult to get an overview of what is really going on here. while the system is explicit about record keeping  it is not very explicit about the fact that it is going to reduce the dose  though it hints at a 
1. providing justifications 
　　　　we need a way of capturing the knowledge and decisions that went into writing the program. one way to do this is to give the computer enough knowledge so that it can write the program itself and remember what it did. this notion of automatic programming has been researched considerably  balzer1  barstow1  green1  long1  manna1  and is not a new idea. using an automatic programmer to help in producing explanations is a new idea. since we are primarily interested in explanation  we have chosen not to deal with a number of problems that arise in automatic programming  including: choosing between different implementations  backup and recovery from dead end refinements  and optimization. 1 system overview 
　　　　an overview of the xplain system is given in figure 1. the system has five parts a writer  a domain model  a set of 
domain principles  an english generator  and a refinement structure. the writer is an automatic programmer it wrote new code which captured the functionality of major portions of the old digitalis advisor1 the domain model and the domain principles contain knowledge about the domain of expertise. thus  in this case  they contain information about digitalis and digitalis therapy they provide the writer with the knowledge it needs to write the code for the digitalis advisor the refinement structure can be thought of as a trace left behind by the writer. it shows how the writer develops the digitalis advisor when a physician user runs the digitalis advisor  he can ask the system to justify why the program is doing what it is doing. the generator gives him an answer by examining the refinement structure and the step of the advisor currently being executed. if we wanted to write a new program covering a new medical domain  we would have to change the domain model and the domain principles  but we should not have to change the writer or the english generator.1 

reduction by saying that the  factor of reduction  is being set to 1. 
1 

　　　　the refinement structure is created by the writer from the top level goal  in this case administer digitalis  as it writes the digitalis advisor. the refinement structure is a tree of goals  each being a refinement of the one above it in the tree  see figure 1 . by  refining a goal  we mean taking a goal and turning it into more specific subgoals looking at figure 1  we see that the top of the tree is a very abstract goal  in this case  administer digitalis. this goal is refined into less abstract steps by the writer. these more specific steps are steps the system executes to administer digitalis. for example  one such step is to anticipate toxicity  that is  to anticipate whether the patient may become toxic due to increased digitalis sensitivity. the writer then refines this more specific goal to a still more specific goal. eventually  the level of system primitives is reached. system primitives are operations which are built-in. normally they are very basic  simple operations  so the fact that they cannot be explained is usually not a problem. typical primitives include those that perform arithmetic operations like plus and times and those that set variables to a particular value. the leaves of the refinement structure constitute the basic operations performed by the digitalis advisor  the program that we wanted the automatic programmer to produce 
　　　　domain principles tell the writer how something  such as prescribing a drug or analyzing symptoms  should be done. they guide it as it refines abstract goals to more specific ones a  somewhat simplified  domain principle appears in figure 1.b this particular principle helps the writer in anticipating digitalis toxicity. it represents the common sense notion that if one is considering administering a drug  and there is some factor that enhances the deleterious effects of that drug  then if that factor is present in the patient  less drug should be given. this principle has three parts: a goal  a domain rationale  and a prototype method. 
　　　　the goal tells the writer what it is that the principle can help it do. in this case  the principle can help the writer in anticipating toxicity. the domain rationale is a pattern which is matched against the domain model to see where it is appropriate to achieve the goal. in the example  the system will look in the domain model to match a finding  e.g. increased ca  which causes some sort of a dangerous deviation  e.g. change to ventricular fibrillation  which is also caused by an increased level of the drug. by looking at the domain model  we can see both increased ca and decreased k will match as findings  since both can cause a change to ventricular fibrillation. 

the domain model is a model of the facts of the domain. 
in this case  it is a model of the causal relationships in digitalis therapy. a simplified portion of the model is shown in figure 1 in this model  the boxes are states  and the arrows represent causality. this model shows some of the effects of increased digitalis. it also shows that increased serum ca and decreased serum k can each cause increased automaticity these facts correspond to the sorts of facts that a medical student learns in class during the first two years of medical school. these facts are static. that is  they have no notion of process. the model says that increased digitalis can cause a change to ventricular fibrillation but it doesn't say what to do about it. medical students go to medical school for an additional two years and acquire these procedures by observing more experienced personnel as they practice medicine on the wards. the set of domain principles provides the writer with this sort of procedural knowledge. 
         the prototype method is an abstract method which tells the system how to accomplish the goal. once the domain rationale has been matched  the prototype method is instantiated for each match of the domain rationale. when we say that we instantiate the prototype method  that means that we create a new structure where the variables in the prototype method have been replaced by the things they matched. in this case  two structures would be created. in the first  finding would be replaced by increased serum ca and drug would be replaced by digitalis. in the second  finding would be replaced by decreased serum k and drug would again be replaced by digitalis. note that now  with these new structures  we have changed the single abstract problem of how to anticipate toxicity into several more specific ones  such as how to determine whether increased serum k exists  how to reduce the dose  and how to maintain it. 

after instantiation  the more specific goals of the 
prototype method are placed in the refinement structure as sons of the goal being resolved. if we look at figure 1  we can see that the instantiated prototype method that checks for decreased serum k has been placed below the anticipate toxicity goal once they have been placed in the refinement structure  the newly instantiated goals become goals for the writer to resolve for example  after the writer applied this domain principle  it would have to find ways of determining whether increased calcium existed in the patient  whether decreased potassium existed  and ways of reducing and maintaining the dose. the system continues in this fashion  refining goals at the bottom of the structure and growing the tree down and down until eventually the level of system primitives is reached. 
         the system must also take into account interactions between the actions it takes. for example  while the individual instantiations above say that if increased serum calcium exists the dose should be reduced  and if decreased serum potassium exists the dose should be reduced  but they don't give any indication ot what should happen if both increased calcium and decreased serum potassium co-occur. exactly what should happen depends on the characteristics of the domain. it could be that the occurance of either sensitivity  covers  for the other  so that only one reduction should be made and the predicate of the if should be made into a disjunction. or   as is actually the case   it could be that when multiple sensitivities appear  multiple reductions should be made. the way to resolve that is to serialize these two program fragments  connecting the outputs of the first to the inputs of the second. the automatic programmer handles this situation by setting it up as something to be refined. the domain principle used in the refinement of this problem may further constrain the way in which other goals may be refined. the details of this operation will not be presented here. the interested reader should see  swartout1i . 
　　　　once the refinement process is complete  we have a working expert system. a sample interaction with the system is given in figure 1. the first sentence of the explanation was produced by stating the higher goal  that is  anticipate toxicity  next  the explanation routines located the domain principle which caused the step in question to appear in the program. the domain rationale associated with that principle was then converted to english  with pattern variables replaced by the facts in the domain 
model they matched . that step produced the next two sentences of the explanation the last sentence is just the instantiated version of the prototype method of the domain principle these explanations should be compared with those presented in figure 1 to appreciate the improvement that is possible with this approach  the generation routines are described in detail in  swartout1l  . 
1 explanations of domain principles 
　　　　in the original version of the digitalis advisor  when we wanted to give a more abstract view of what was going on. we just described a higher level procedure  swartout1  in this regard we were following the principles of structured programming while this approach often gave reasonable explanations  there were times when it was considerably less than illuminating the general method for anticipating digitalis toxicity was called  check sensitivities  in the old version of the digitalis advisor. an explanation of it appears in figure 1. while this explanation does tell the user what sensitivities are being checked 1 it does not say what will be done if sensitivities are discovered nor does it say why the system considers these particular factors to be sensitivities finally  it is much too redundant and verbose the first objection can be dealt with by removing the calls to lower procedures and substituting the code of those procedures inline this results in the somewhat improved explanation produced by xplain when it 
please enter the value of serum-k: why  
the system is anticipating digitalis toxicity. decreased serum-k causes increased automaticity. which may cause a change to ventricular fibrillation. increased digitalis also causes increased automating. thus  if the system observes decreased serum-k. it reduces the dose of digitalis due to decreased serum-k. 
please enter the value of serum-k: 1 
please enter the value of serum-ca: why  
 the system produces a shortened explanation  reflecting the fact that it has already explained several ot the causal relationships in the previous explanation also  since the system remembers that it has already told the user about serum k  it suggests the analogy 
1 

is asked to describe the method for anticipating digitalis toxicity  see figure 1  however  while this explanation shows what the system does  it doesn't say why things like increased calcium  cardiomyopathy and decreased potassium are sensitivities  and if anything  it is even more verbose than the original explanation 
         the reason we can't get the sorts of explanations we want by producing explanations directly form the code is that much of the sort of reasoning we want to explain has been  compiled out.  thus  we are forced into explaining at a level that is either too abstract or too specific the intermediate reasoning which we would like to explain was done by a human programmer in the case of the old digitalis advisor however  because this performance program was produced by an automatic programmer  that reasoning is available in the domain principle. for example  if we were to use the english generator to explain the domain principle that produced the code for anticipating digitalis toxicity rather than the code itself we would get the explanation that appears in figure 1. thus  the use of an automatic programmer not only allows us to justify the performance program  but it also allows us to give better descriptions of methods by making available intermediate levels of abstraction which were not previously available. 

1. is automatic programming too hard  
　　　　one possible objection to the whole approach to explanation advocated in this paper is that it is just too hard to get an automatic programmer to write the performance program. when i first began this research  i thought that was the case. the original plan for producing better explanations was to create structures detailing the development of the performance program  but these structures would be created by hand rather than automatically it was feared that automatic programming was just too hard however  as the research progressed  it became clear that if we had sufficiently powerful representations available so that it could be said that explanations were being produced from an understanding of the program  then actually writing the program automatically wouldn't be all that much more difficult. i suspect this is true in general it seems that the primary difficulty in both explanation and automatic programming is a knowledge representation problem  and that the kinds of knowledge to be represented in both cases are similar so that a solution to one case makes the other much easier however  it must be pointed out that the field of automatic programming is still an active research area and a number of difficult problems remain to be solved in addition to the knowledge representation problem so this 

1 

conjecture still awaits a final resolution. 
1. a summary of major points 
　　　　first  we have argued that to be acceptable  consultant programs must be able to explain what they do and why. second  we have described the various ways that traditional approaches fail to provide adequate explanations and justifications major failings include: 1  the inability of such approaches to justify what the system is doing because the knowledge required to produce justifications is not represented within the system  and 1  a lack of distinction between steps required just to get the computer-based implementation to work  and those that are motivated by the application domain. third  we have outlined an approach which captures the knowledge necessary to improve explanations this involves using an automatic programmer to generate the performance program as the program is generated  a refinement structure is created which gives the explanation routines access to decisions made during the creation of the program. the improvement in explanatory capabilities that is achieved is due more to the availability of this refinement structure than to the use of more sophisticated english generation functions  since the explanation routines used in this paper do not differ greatly from those used in the old digitalis advisor. 

1. references 
 barstow1  barstow  d.   a knowledge-based system for automatic program construction   proceedings of the fifth international conference on artificial intelligence  1 
 ba!zer1  balzer  r.  goldman  n.  wile  d.   informality in program specificatioos   proceedings of the fifth international conference on artificial intelligence  1 
 clancey1  clancey  w.j.   transfer of rule-based expertise through a tutorial dialogue   stanford university  department of computer science  stan-cs-1.1 
 davis1  davis  r.   applications of meta level knowledge to the construction  maintenance and use of large knowledge bases   phd thesis  stanford artificial intelligence laboratory memo 1 . 
 gorry1  gorry  g. a.  silverman  h.. and pauker  s. g.  capturing clinical expertise: a computer program that considers clinical responses to digitalis  american journal of medicine 1-1.  march 1 . 
 green1  green  c.c.  gabriel  r.p.  kant  e   kedzierski  b.i.. mccune  b.p.  phillips  j.v.  tappel  st.  westfold  s.j.   results 
in knowledge based program synthesis   proceedings of the 
sixth international joint conference on artificial intelligence  1  jelliffe1  jelliffe r.w.  buell j.  kaiaba r. et al   a computer 
program for digitalis dosage regimens   math. biosci. 1-1  1 
 je!liffe1  jelliffe r.w.  buell j  kaiaba r   reduction of digitalis toxicity by computer-assisted glycoside dosage regimens   ann intern. med. 1-1 
 long1  long  w.j.   a program writer   mit laboratory for computer science  tr-1 
 manna1  manna  1.  waldinger  r.   the automatic synthesis of systems of recursive programs   proceedings of the fifth international conference on artificial intelligence  1 
 peck1  peck c.c.  shemer l.b. et al:  computer-assisted digoxin therapy   new england journal of medicine 1-1. 
1. 
 pauker1  pauker  s g . gorry  g.a.. kassirer  j p.  and schwartz. w.b.   toward the simulation of clinical cognition: taking a 
present illness by computer   the american journal of medicine 1 1  june 1  
 pople1  pople  he jr.   the formation of composite hypotheses in diagnostic problem solving  an exercise in synthetic reasoning   proceedings of the fifth international joint conference on artificial intelligence  1 . 
 sheiner1  sheiner lb.  rosenberg b.. melmon k.   modelling of individual pharmacokinetics for computer-aided drug dosage   
compufers and biomedical research 1 -1 
 shortliffe1  shortliffe  e.h.  computer based medical consultations: mycin  elsevier north holland inc.  1  
 silverman1  silverman  h    a digitalis therapy advisor   mit 
project mac tr 1  1 
 swartout1  swartout  w.r.   a digitalis therapy advisor with explanations   proceedings of the fifth international joint conference on artificial intelligence  august 1 
 swartout1l  swartout  w.r.   producing explanations and justifications of expert consulting systems   mit laboratory for computer science technical report  in press  
	 winograd1  	winograd  	t.  	 a 	computer 	program 	for 
understanding natural language   mit artificial intelligence laboratory tr 1  1 
1 

