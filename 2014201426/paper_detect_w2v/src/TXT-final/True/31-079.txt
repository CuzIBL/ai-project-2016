1 	constraint satisfaction 

ble constraint propagation systems show that the amount of constraint propagation that enables a problem-solver to be the most efficient varies with the problem-solver  with the application  and with the problem-solving context  van hentenryck  1; collinot and le pape  1 . the following sections present the results of an investigation of the techniques that can be used to extend the propagation of disjunctive constraints. 
1 bibliographical study 
in the literature  there are roughly two types of methods that provide more precise time-bounds. the first type of method  described in section 1  consists in determining whether an activity a must  can  or cannot be the first or the last to execute among a set of activities s that require the same resource  carlier and pinson  1; nuijten et a/.  1b; caseau and laburthe  1 . the second type of method consists in comparing the amount of resource energy required over a time interval  t1 t1  to the amount of energy that is available over the same interval  erschler et a/.  1; beck  1; le pape  1 . this form of propagation is discussed in section 1. 
1 	automatic sequencing of activities 
rather than just looking at pairs of activities {a b}  the first type of method compares the temporal characteristics of a to those of a set of activities 
　let est a denote the earliest possible start time of a  let a denote the latest possible end time of a  and pa denote the processing time of a  the smallest possible processing time of a if the processing time of a is not fixed . let est n denote the smallest of the earliest start times of the activities in denote the greatest of the latest end times of the activities in   and denote the sum of the processing times of the activities in 
let 	mean that a is before  after  b and 
mean that a is before  after  all the 
activities in n. the following rules apply: 

new time-bounds can consequently be deduced. when a is before all activities in the end time of a is necessarily smaller than  or equal to  . when a is after all activities in the start time of a is necessarily greater than  or equal to  
　the technique which consists in applying these rules is known as edge-finding  applegate and cook  1l .  actually  applegate and cook use the term  edgefinding  to denote both the above type of deduction  i.e.  a  bounding  technique  and the non-deterministic choice between the possible orderings of activities  i.e.  a  branching  technique. in the following  edge-finding is considered only as a deterministic deductive  bounding  technique.  
　notice that if n activities require the resource  there are potentially 1 n * 1n  pairs  to consider. an algorithm that performs all time-bound adjustments in 1{n1  is presented in  carlier and pinson  1 : 
  compute  jackson's preemptive schedule  for the resource under consideration.  preemptive  means that an activity a can be interrupted to process another activity b. jackson's preemptive schedule  jps  is obtained by applying a very simple priority rule: whenever the resource is free and one activity is available  schedule the activity a for which leta is the smallest. if an activity b becomes available while a is in process  stop a and start b if lets is strictly smaller than leta; otherwise continue a. 
  for each activity ai  compute the set of the activities which are not finished at t on j ps. let p*k be the residual duration on the preemptive schedule of the activity ak at time . take the activities of in decreasing order of due dates and select the first activity aj such that: 

if such an aj exists  then post the new temporal constraints: 

where ca s is the completion time of the activity ak in jps. 
　 nuijten et a/.  1b  presents a variant of this algorithm  which also runs in 1 n1   but is simpler in the sense that it does not require the computation of jackson's preemptive schedule. 
　 caseau and laburthe  1  presents a constraintbased technique based on the same principles. two sets of rules based on the concept of  task intervals  are developed: 
  edge-finding within a task interval: the edge-finding technique is very powerful but  as we have said  it cannot be naively applied to all the subsets q of activities requiring the same resource  since for n activities  this would lead to 1n sets . to avoid this  caseau and laburthe associate to all couples of activities  a b  scheduled on the same machine the set of activities k a b  which will surely be scheduled between the earliest start time of a and the latest end time of b: 

k a b  is called a task interval and is considered of interest only when a and b belong to ka b  deductive edge-finding propositions are applied to task intervals: for each activity c in k a b  rules determine whether c necessarily executes before  or after  all the other activities in k a b . 
  edge-finding between a task interval and an-other task: this second set of rules is used to deduce that a task c cannot be performed before  or 

　the counterexample shows that the second set of rules  breaks  unique fixpoint semantics  when applied only to task intervals. having different possible fixpoints is not a real problem when developing a specific algorithm  but may be annoying in the context of a generic constraint programming tool. indeed  it means that a user of the tool can face different execution behaviors depending on the order in which constraints are posted. such variability makes it less easy to use the tool for the development 
of complex scheduling applications. 
	1 	energy-based reasoning 
the second type of method consists in comparing the amount of resource energy required over a time interval  t1 t1  to the amount of energy that is available over the same interval. 
　in  erschler et a/.  1   the authors analyze the effect of time and resource constraints on the admissibility of schedules. they study how activity characteristics and resource constraints can induce new constraints which allow to restart the propagation. although erschler  lopez and thuriot have worked on discrete resources  i.e.  resources the capacity of which can be greater than one   from now on  we focus on the case of unary resources  i.e.  resources of capacity 1 . 
constraint satisfaction 
yet the result struck us given that our algorithm was extremely simple. 
　while using this algorithm  we noticed that the number of backtracks required to prove the optimality of the solution varied with the order in which constraints were posted. this observation suggested that our implementation did not have a unique fixpoint. yet we have been unable to put together a simple example with two different fixpoints. 
　energetic reasoning is also used in the tosca system of beck  beck  1  and in the energetic resources of ilog schedule  le pape  1 . beck uses a data structure called  habograph  to compute the required energy consumption and the maximal energy available over each time interval  t1 t1  up to a given discretization of time. when the required energy consumption exceeds the maximal energy available  a failure occurs. when the required energy consumption is close to the maximal energy available  a constraint threat is indicated. the habograph can also be used to determine that an activity cannot fully execute during a given time interval  t1 t1   in a way similar to applying the rules above  but with predetermined time intervals rather than intervals depending on the time-bounds of activities. 
　in ilog schedule  an energetic resource represents the fact that the amount of energy that can be used over given intervals of time is limited. roughly  an energetic resource does not represent a resource per se  but the amount of work performed by the resource over regular intervals of time. the capacity of an energetic resource is consequently not measured as a number of machines or as a number of men and women  but as a number of machining hours  or as a number of human-days  humanweeks or numan-months  spent for the performance of the activities. the following code  for example  creates an energetic resource to represent the fact that at most 1 human-days of work can be spent each week. the time unit is supposed to be the day and date 1 corresponds to the beginning of the first week. ctdiscreteenergy* w ＊ new ctdiscreteenergy ... ; v- maketimetable 1  1 * number of weeks  1  1 ; 
energetic reasoning is thus performed for each time interval  t1 t1  of the form  1n l n + 1  . in fact  an energetic resource of ilog schedule corresponds to a  piece of habograph  used to update the time-bounds of activities. energetic resources are occasionally used in ilog schedule applications to implement redundant constraints  that result in more constraint propagation being performed . 
	1 	theoretical comparison 
the previously described mechanisms have been implemented in several systems and shown to give interesting results as far as computational time is concerned. one issue however to be dealt with is the management of the additional data structures used to implement these techniques. indeed  these data structures may be more or less costly to maintain both in terms of cpu time and in terms of memory consumption. 
　the task intervals of  caseau and laburthe  1  require the maintenance of a data structure in 1 n1  where n is the number of activities requiring a given resource. 

note that  in principle  this memory space consumption could be avoided  but at some expense in terms of cpu time. similarly  the habograph of  beck  1  uses a memory space in 1  h/g 1  where h is the scheduling horizon and g the grain of the habograph. an energetic resource in ilog schedule uses a memory space in 1{h/g  only since the energetic analysis is restricted to time intervals of size g. using implementation cues similar to those used in the sequential time-tables of ilog schedule  le pape  1   the habograph could be reduced to time intervals  est a let b  such that est a is the earliest start time of an activity a and lets the latest end time of another  or the same  activity b. the space complexity would then be 1 n1 . 
　erschler  lopez and thuriot do not say much about their implementation choices in this respect. however  the use of the energetic rules for all pairs  esta let b  obviously requires either 1 n1  in space  or 1 n1  in cpu time. the less consuming techniques are those of  carlier and pinson  1  and  nuijten et a/.  1b . 
　the following table summarizes the complexity analysis of the various propagation techniques we have discussed. the time complexity that is given corresponds to one iteration  over the n activities of the same resource  of the constraint propagation process. a question mark is used when we are not sure about the actual complexity of the technique. two things that are difficult to measure a priori do not appear in the table:  1  the typical number of iterations necessary to reach the fixpoint;  1  the  pruning power  of the propagation that is being performed. in the next section  we present experiments performed to assess the effectiveness of some of these propagation techniques: arc-b-consistency  edge-finding  and energetic reasoning. 
the table also includes a new algorithm developed by 
carlier and pinson  which runs in 1 n * log n   time  carlier and pinson  1 . we have not yet found the time to study this algorithm in detail. the results of the next section are based on the 1 n1  algorithms of  carlier and pinson  1  and  nuijten et a/.  1b . 
technique time space arc-b-consistency 1 n1  o n  edge-finding 1 n1  
1 n * log n   o n  1 n  task intervals 1 n1  1 n1  energetic reasoning 1 n*  o n  habograph     1  h/g 1  energetic resources 1 n* h/g  1 h/g  1 experimental study 
1 	implemented algorithms 
in addition to arc-b-consistency  three  extended  constraint propagation algorithms have been implemented on top of version 1 of ilog schedule. 
  the era algorithm is based on energetic reasoning. 
  the efj algorithm performs edge-finding based on jackson's preemptive schedule. 
  the efn algorithm performs edge-finding based on the method described in  nuijten et a/.  1b . 
constraint satisfaction 
era 
in a preliminary experiment  we combined the first rule of erschler  lopez and thuriot  cf. section 1  with the edge-finding technique of carlier and pinson restricted to the overall set of yet unordered operations. using the resulting algorithm  we noticed that the number of backtracks required to prove the optimality of the solution varied with the order in which constraints were posted. we consequently changed the rule as follows: rather than computing the energy required over the time interval  esta lets   we compute the energy w that would be required by other activities between the latest start time of a and the earliest end time of b if a were scheduled before b. we deduce that if a is before b  then at least w units of time must elapse between the end of a and the beginning of b. we can then use w to update  still under the hypothesis that a is before b  the latest start time of a and the earliest end time of b. as long as w increases and is not large enough to prove that a cannot be before b  we iterate. 
　our implementation of energetic reasoning uses data structures in o n   rather than 1 n1  . consequently  the energetic reasoning algorithm runs in 1 n1   even without iterating the energy calculation. within the same 1 n1  loop  the algorithm directly applies the edgefinding technique of carlier and pinson to all the 1-tuples and  n-l -tuples of activities  where n denotes the number of unscheduled activities requiring a given resource   without computing jackson's preemptive schedule. 
efj 
the second constraint propagation algorithm is a direct implementation in ilog schedule of the technique described in  carlier and pinson  1 . however  our implementation computes jackson's preemptive schedule in 1 n1  rather than 1 n * log n  . this allows us to reuse data structures predefined in ilog schedule rather than implementing new ones: it would be interesting to determine the number of activities n at which the price of additional data structures would be balanced by the resulting cpu time savings. 
the algorithm also applies the rules of caseau and 
laburthe to a unique task interval for each resource  i.e.  the task interval consisting of all unscheduled activities. it runs in 1 n1  and uses data structures in 1 n . it is applied iteratively as long as it results in updates of earliest and latest start and end times. 
efn 
the third constraint propagation algorithm is similar but uses the algorithm of  nuijten et a/.  1b  rather than computing jackson's preemptive schedule. it runs in 1 n1  and uses data structures in o n . 
　normally  the two edge-finding algorithms result in the same deductions. however  in the case of the algorithm of  nuijten et a/.  1b   we were incidentally able to deduce a bit more than the pure edge-finding technique. indeed  each time the earliest start time of an activity is updated  we can note that the activity cannot be the first to execute among the yet unscheduled activities of the considered resource. this information can then be used to prune the search tree. 

　such deductions are also possible in the case of the algorithm of carlier and pinson  but they are less numerous. as we shall see in the next section  the two algorithms provide slightly different results in terms of cpu time and number of backtracks. 
1 	results 
the following table compares the three constraint propagation methods on four problems taken from the constraint programming and operations research literature. results on more than eighty problems are available in 
 baptiste  1 .  the first problem is a bridge construction scheduling problem that is often used as a benchmark problem within the constraint programming community  van hentenryck  1 . the other problems are 
job-shop scheduling problems with 1 jobs and 1 machines  hence with 1 activities  considered to be particularly hard to solve to optimality. the optimization algorithm consists of a branch-and-bound backtracking search  with constraint propagation being performed at each node of the search tree. details about the problems and the optimization algorithms are available in  baptiste  1 . 
　in the table  prob denotes the problem instance and algo the constraint propagation algorithm used to solve it. bt and cpu denote the total number of backtracks and cpu time needed to find an optimal solution and prove its optimality. bt-pr and cpu-pr denote the number of backtracks and cpu time needed for the proof of optimality. cpu times are expressed in seconds on a hp1 workstation  rounded either to the closest second or to the closest tenth of a second. 
　for the bridge construction  bdg   the table also provides results obtained using arc-b-consistency  arc  as a constraint propagation procedure. such results are not provided for the job-shop problems because 1 job-shop problems were generally not solved with arc after three hours of computational time. era results for abz1 are not available for the same reason. the table shows that the number of backtracks significantly decreases when more propagation is being performed. on the simple bridge problem  the algorithm based on arcb-consistency performs better than the others in terms of cpu time: the cost of additional constraint propagation is not balanced by the reduction of the search effort. on the more complex job-shop scheduling problems  the cost of additional constraint propagation is more than balanced by the reduction of the search effort. 

　the three algorithms were also tested on an industrial project scheduling problem submitted by a customer of ilog  and found to be extremely difficult to solve. the problem consists of scheduling two projects that require common resources. there are forty-five activities and five resources to consider. each activity requires up to four resources. within each project  activities are subjected to precedence constraints. three of the resources are unary resources. the number of activities that require each unary resource is close to thirty. the two other resources are discrete resources with capacity greater than one. 
　there are two optimization criteria: the goal is to minimize the end times of two activities  one for each project. as the projects rely on common resources  these two optimization criteria are conflicting. as a result  the final user wants to impose upper bounds on the two criteria  and wants the system to tell whether there exists a solution satisfying these upper bounds. the following table provides the cpu times obtained for different values of the upper bounds of the two criteria. if an algorithm is incapable of solving an instance within one hour of cpu time  that is reported by  - . the results show that the algorithms which use edge-finding strongly outperform the other algorithms. 

1 	conclusion 
following these experiments  an industrial version of the edge-finding algorithm of  nuijten et a/.  1b  was implemented in a new version  1  of ilog schedule. we also improved our search strategy for solving jobshop scheduling problems. the new strategy consists of: 
1. generating a first solution  very quickly   
1. iteratively improving the solution by keeping part of the best solution  i.e.  keeping some ordering decisions  selected randomly with a probability p that decreases over time  and searching with a limit on the number of backtracks per iteration  
1. systematically exploring the search space when p falls below a given threshold. 

the following table provides the average results obtained over three runs  on the ten 1 job-shop scheduling problem instances used by applegate and cook in their computational study of the job-shop scheduling problem  applegate and cook  1 . cpu times are expressed in seconds on an ibm rs1 workstation. over the ten instances  the total number of backtracks for ilog schedule is 1  while the total number of nodes explored by applegate and cook's algorithm is 1. the use of edge-finding techniques allows the user of ilog schedule to enjoy the flexibility inherent to constraint programming  with performance in the same range of efficiency as specific operations research algorithms  such as the one reported in  applegate and cook  1 . 

acknowledgments 
the authors would like to thank jean-francois puget  
younes alaoui  michel leconte  wim nuijten  and all the members of the ilog solver development and consulting team for their contributions to the design and continual improvement of ilog schedule. thanks also to the referees for their helpful comments. 
