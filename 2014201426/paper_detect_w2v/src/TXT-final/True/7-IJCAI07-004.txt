
the qcsp+ language we introduce extends the framework of quantified constraint satisfaction problems  qcsps  by enabling us to neatly express restricted quantifications via a chain of nested csps to be interpreted as alternately conjuncted and disjuncted. restricted quantifiers turn out to be a convenient solution to the crippling modeling issues we encounter in qcsp and-surprisingly- they help to reuse propagation technology and to prune the search space. our qcsp+ solver-which also handles arithmetic and global constraints- exhibits state-of-the-art performances.
1 introduction
we extend the qcsp  quantified constraint satisfaction problem  framework by introducing a new language  called qcsp+. such extension is motivated by the difficulties we experienced in modelling and solving most non-trivial problems as plain qcsps. so  let us start by describing  q csp  in order to point out some of its modeling weaknesses.
　a csp is a search problem established by giving a set of variables ranging over finite domains  and a conjunction of constraints mentioning such variables. for example  given x （ {1 1}  y （ {1}  and z （ {1 1}  the csp

is solved by selecting  if possible  one value for each variable in so as to satisfy the three constraints at once. for example  x = 1  y = 1  z = 1 is a valid solution  while x = 1  y = 1  z =1 is not. csp formulations are naturally suited to model real-world problems  and countless applications exist indeed. for the sake of this paper  a csp problem is best viewed as a decision problem in which all the variables are quantified existentially  i.e. the existence of one single consistent assignment suffices to answer the problem positively :

the seemengly inconsequential amendment of making quantifiers explicit leads us to play in an entirely new field  bordeaux and monfroy  1 : what if  some of  the variables are quantified universally  for example  what means for

 to be true  the most intuitive way of entering the new scenario is by thinking of it as a game between two players. one player is associated to the existential quantifier-we call him
thestraint  hence to satisfy the whole csp. the goal of the --player. the goal of theplayer-the other is related to the universal quantifier -player is to satisfy each con --: the  
player is to violate at least one constraint  thus overcoming the opponent's effort. the two players play against each other in turn  for a finite and fixed number of rounds. the moves they do consist in assigning values to variables. which variables get assigned at each step is statically decided by the left-to-right order in the prefix of the problem  in our example  the prefix is   x （ {1 1} y （ {1} z （ {1 1}  .
　in  1   the  -player plays first  and he is given the chance to choose a value for x. then  it is time for the  -player to assign a value to the variable y. finally  the  -player assigns z and the game terminates: the satisfaction of the set of constraints is evaluated. we say that such quantified csp  qcsp  is true if the  -player has a winning strategy-i.e. if he can manage to satisfy every constraint whatever the universal opponent does-and is false otherwise. for example   1  is true  while it becomes false if we change the prefix to  x y z. as opposed to the purely existential csp case  the order of quantifiers is important: by flipping y and z in  1  we play under the prefixqcsp is widely believed to be strictly more  powerful  x z y  and the existential player looses the game. than csp: an entire hierarchy of qcsp problems exists for which no equivalent csp formulation can be written  compactly   qcsp is pspace-complete  csp is np-complete . some of these problems are openly perceived as games by humans  i.e. board games   while in others the underlying game structure is camouflaged  see section 1 .
　despite the expectation engendered by the strength of the language  we find in the literature no single account of a realworld model1 actually solved by a qcsp solver. why 
　a partial explanation is that qcsp solvers are in their infancy and miss most  quantified  constraint propagators  i.e. forward inference rules that are vital to cut the search space.
this limitation discourages or prevents people from investing in the production of realistic models. however  we have recently built a full-fledged qcsp solver  benedetti et al.  1b   which manages several constraints. even so  models of many  natural  cases stay surprisingly difficult to devise.
　to pinpoint the problem  let us take a step back to qcsp as a game between   and    and let us observe that with games almost invariably come rules: some choices could be precluded as a function of previous choices by the same player or by the opponent. an elementary example is the prohibition in most board games to play in a cell already occupied by someone. in the qcsp game  this means that players cannot in general assign variables in arbitrary ways. the set of legal choices is dynamically restricted over a game life-span in relation to the moves already occurred  so to comply with an underlying game discipline. the observance of such discipline is precisely what plain qcsps find difficult to enforce.
　no support for dynamic ranges of variables is provided by the prefix: in  1  z ranges over {1 1} whichever the values chosen for x and y. so  we have to embed the game discipline in the constraints. it is a matter of stating that if a player chooses a forbidden value  or combination of values  he looses immediately. such threat is promptly posed to the  -player: we consider the membership of the move to the set of legal moves as just an additional constraint. if the  -player cheats  he makes such constraint false  he looses the game.
　no similar expedient can be used against the  -player: the game is a loss for him when all the constraints are satisfied  a thing which simply cannot be imposed by just conjuncting whatever additional constraint. rather  to solve such  discipline problem we should slightly modify the whole formalization. this reformulation-based approach has been presented in  ansotegui＞ et al.  1  for the case of two-players qbf games but  for the reasons discussed in section 1  it comes out to be an unsatisfactory remedy to our problem. so  let us introduce a different solution  based on handling the game rules explicitly. as we shall see shortly  qcsp is not enough to plainly state the new formalization as it lacks support for disjunctions between constraint sets. consider the following problem  in which rules are provisionally absent 
	 x1 y1 x1 y1.c x1 x1 y1 y1 	 1 
 let uppercase letters denote sets of variables rather than a single variable  domains are not shown . suppose the legal opening moves for  -player are characterized by a set of constraints  a csp   i.e. an assignment to the variables in x1 is a legal opening move iff it is a solution to in the classical csp sense. next   -player's reply at second step is constrained by some csp: once the choices over x1 from  -player's side are known  an assigment over
y1 is to be considered only if it solves. likewise  rules  and are provided. to capture this scenario  we introduce restricted quantifiers qx l   with q （ {   }: they quantify over x yet only span over those assignments to x which comply with the csp-based rule l. with this compact notation  our example is written:
 x1 l 1 x1  .  y1 l 1 x1 y1  .  x1 l 1 x1 y1 x1  .
            y1 l 1 x1 y1 x1 y1  . c x1 x1 y1 y1  which reads  for all the assignments to x1 such that l 1 holds  exists an assignment to y1 such that holds and for all... . we can reshape the above formula as a prenex qcsp as we realize that the  such that  connective stays for a conjunction when  -player is involved  and for an implication when  -player is concerned. so  we actually ask whether

or  in an equivalent prenex form with explicit disjunction  if
		 1 
 statement  1  shows that the most natural way to express restricted quantifiers would be to extend the language to handle disjunctions. but  a shift to general non-conjunctive csps would hamper the critical opportunity to inherit the huge amount of propagators already implemented for the purely conjunctive case. we would fall back into the inability to exercise csp tools on real problems  by having a nice formalism with just a proof-of-concept or no implementation at all.
　our solution is to design a limited disjunctive extension of the qcsp formalism  which is  i  enough to express all the disjunctions originating from the use of restricted  universal  quantifications  but is  ii  still capable of inheriting and exercising the reasoning core of standard  q csp solvers.
      x1 from a fol perspective  the syntactic shape ofthe problems we introduce-the qcsp+ problems  generalizing example  1 -is a chain of nested alternated quantifications with restrictions  depicted aside . this language is cognitively adequate to represent game-withrules scenarios  modeler's viewpoint  section 1   and at the same time is amenable to be decided by reusing existing technology  solver's viewpoint  section 1 . indeed  each restriction rule is a standard csp  inside which the usual propagation procedures can be capitalized. what is to be designed is  i  an external search-guiding mechanism that evaluates the truth value of the alternated chain of csps as a function of the truth value of the leaves  and  ii  an inter-leaf propagation scheme that reconciles the separate csps and makes them share information in a sound way. as a final note  let us observe that the  game-with-rules  scenario we target is definitely not a marginal modeling case. on the contrary  the usage of restricted quantifiers is so natural  see section 1  that one ends up wondering which non-trivial problems can be modeled as plain qcsps! the relation between our approach and recent contributions in the close field of qbf decision procedures is discussed in section 1. the implementation of a full-fledged solver and experiments on quantified models are presented in section 1. in section 1 we summarize our contributions and present directions for future work.
1 motivating examples
the concepts involved in the modeling of the following common problems are naturally captured as a conjunction of constraints. however  the questions we ask require universal quantifiers and disjunctions in exactly the qcsp+ style.
problem 1 suppose some  partial  ordering  is established to rank the solutions of a given csp p. while a csp is not enough to compactly characterize the best solutions of p w.r.t.   qcsp+ gives to the problem an elegant one-move game formulation:.
in the following example  cadoli et al.  1   solutions to the csp represent sets  and the   relation creates preferences. example 1  strategic companies  we are given a collec-
panies have reciprocal financial participations  and a subsettionc〜gcto specify which goods each company produces. com-of companies  a set g of goods  and a relation prod 
 that owns more than 1% of some c（c is said to be a controlling set for c. a company may have many controlling sets. they all are represented by a relation contr  -written1c〜c. a set of companies s  c is  production-preserving pp s -if it  i  covers all the goods in g  i.e. by cumulating the goods g such that  we obtain
g; and  ii  is closed under the controlling relation  i.e.  for each then c （ s. a strategic set is any subset-minimal production-preserving set  i.e. the pp property is lost in each proper subset of a strategic set . a company x（c is not strategic  intuition: it can be sold with no impact on either the overall portfolio of goods or the controlled companies  if it belongs to no strategic set  i.e. if

the prod and contr relations as defined above can be easily expressed in propositional logic. we adopted such restricted version to enable a direct comparison with boolean reasoners  section 1 . more realistic models-mentioning explicit amounts of goods  capacity of production and percentage of participations-still fit nicely in the csp vocabulary  but they lay outside the natural reach of propositional logic.
problem 1  game strategy  let a set of variables xi describe the state at step i of a system evolving after the alternate moves of two opponents p and p   selected out of
	 	 
a finite set of possibilities. a game is defined by a 1-tuple  of csps: a move m in a state x is only possible when the precondition axiom pa x m  is satisfied and leads to a new state x defined by the successor state axiom ssa. initial and winning conditions are recog and g p x  respectively  with p （ {p  p } . let   denote   and vice-versa. the first player p game in at most k rounds if  x1 i x1  .ws   1   where  wins the
ws
for i   1k  and ws q i  := g pq xi 1  for i = 1k.
the next example shows qcsp+ escaping the intricacies of game formalization we find in e.g.  gent and rowley  1 .
example 1  connect n〜m k  let b= bij （{1 p  p }n〜m be a matrix of variables representing the board state in a gentempt to aligneralized connect-1 game  played on ak signs . the existence of a winning strategyn〜m board in the atfor the first player is modeled by posing pa  where x（ 1..m  is the column of the current move  and using

as ssa  where p （ {p
the initial condition i b  is …ijbij  p=1 }. theis the current player.g csp is a conjunction of alldifferent constraints excluding each alignment.
problem 1  conformant scheduling  consider n tasks of duration δ1 ...δn requiring an amount of resource r1 ...rn  and subject to the ordering constraints o  1..n 〜 1..n   where means that task i must end before task j starts. we want to schedule the tasks so that  i  we finish by time t   ii  we comply with o  and  iii  the instantaneous resource consumption never exceeds a fixed capacity r. a global constraint cumulative r t1 δ1 r1 ... tn δn rn  is provided by most csp solvers to check the latter condition. we have a degree of uncertainty about the actual resources required by each task. an hostile environment can impact on them  subject to certain constraints em r1 ... rn . is it possible to devise an adversary-safe schedule 
.
cumulative r t1 δ1 r1 ... tn δn rn  … max ti+δi  ＋ t
example 1 consider three tasks to be completed within time t = 1 and without surpassing a capacity r = 1  with δ1 = 1  δ1 = 1  δ1 = 1  r1 = 1  r1 = 1  and r1 = 1. task 1 has to finish before task 1 starts. we seek an attack-safe schedule  under the assumption that the environment can add one unit of cost to up to two tasks. the picture aside shows that the optimal schedule  a  is subject to critical
attacks  the linear schedule  b  exceeds t  while the solution  c  to the our qcsp+ instance meets all the requirements.
1 formalizing and deciding qcsp+
let v be a set of variables and d =  dv v（v the family of their domains  hereafter we tacitly assume an underlying global version of v and d . for w   v   we denote by dw the set Πv（wdv of tuples on w. the projection of a tuple t  or a set of tuples t  on a variable v  or a set of variables w  is denoted by t|v  or t|w . a constraint is a couple c= w t  with w   v and t   dw  w and t are noted var c  and sol c  . a csp is a set of constraints. for a csp c  we note

solby varc  its solutions  where-for any c =sc（c var c  its variables and byw u   v   a   dw  and
b   du-it is. we name range over w   v any function r with domain w that associates to each v （ w a subset r v    dv.
definition 1  restricted quantifier  a restricted quantifier is a 1-tuple q =  q w r c  where q （ {   }  w is a set of variables  r is a range over w  and c is a csp.
definition 1  qcsp+  a qcsp+ with free variables f is a couple  qs g   where the quantification structure qs is a finite  possibly empty  sequence  q1 ... qn  of restricted quantifiers qi =  qi vi ri ci  for which it holds that
　   i j （  1..n  vi ” f =   and 
　  var ci    wi “ f with wi = sj＋i vj and g is a csp  called goal  with var g    wn “f. if f =   the qcsp+ problem is said to be closed.
consistently with the examples already presented  we compactly denote such qcsp+ by writing:
q1 （ r1  c1 . ... . qnvn （ rn  cn .g
　only two closed qcsp+ with an empty quantification structure exists:  and   〕   where  denotes the empty csp  and 〕 stands for any csp which contains an empty constraint. given a qcsp+ problem p =
   q1 v1 r1 c1  ...   qn vn rn cn   g  with free variables f  the result of assigning the value a（dv to a variable v（f  written p v=a   is defined as p =   q1 v1 r1 c1 v= a   ...  qn vn rn cn v = a    g v = a    where the assignment to a csp is in turn obtained by collecting the result of the assignments to each constraint: given a constraint c =  w t   it is c v = a  = c if v /（ w. otherwise  it is  where
. this notion extends natu-
rally to tuple-assignments  w = t   with w   v   t（dw. for any w   v   t （ dw  and any range r over w  let us write t（wr to mean  v （ w t|v （ r v .
definition 1  evaluation of a qcsp+  any closed qcsp+  qs g  evaluates to a value in {true false} as follows. base case. evaltrue and eval   〕  =false.
inductive case. let it be . it is eval  qs g   = true iff:  i  q =   and for all t （ wr such that t（sol c   it is eval true  or
 ii  q=  and there exists t（wr such that t（sol c  and eval.
the decision procedure we implement closely mimics the definition of eval  and is based on a classical depth-first recursive search of the and/or tree associated to a quantification structure. as in csp solvers  a form of forward-inference  called propagation  is of key importance to prune the search space  and is exercised in each search node. what is peculiar to qcsp+ is exactly the way this propagation operates  and the way it builds on top of standard csp propagation.
　we model a csp propagation scheme as parametric function propp ， -where the parameter p is a csp-whose domain and co-domain are the families of ranges over var p . the result propp r  of a propagation over r is meant to contract the range of each variable  hence to reduce the branching factor of the search  while preserving the solutions of p. this means that for any variable v （ var p  it is   but at the same time for each solution t （ sol p   if t|v （ r v  then. propagation is computed by a chaotic iteration as the greatest common fixpoint of the domain-reduction operators associated to each constraint c （ p  where the operator for c prunes values that fail a local consistency check against c  apt  1 .
if r1 is a range over w1 and r1 is a range over w1  w1 ”
w1 =     we define  v = 1 v  if v （ w1 and r v =r1 v  if v （ w1. we note projections of ranges onto sub-domains by |  so e.g. r|w1 = r1 and r|w1 = r1. the analogous of propagation in qcsp+ is as follows.
definition 1  cascade propagation  given a propagation scheme prop  a qcsp+ problem p  and a range rf for the free variables f of p  the qcsp+ problem cascade p  obtained by cascade propagation from p is defined as follows. base case. it is cascade   g   =   〕  if  for any. otherwise v （ f  we have  where cascade   g   =   g . inductive case. let it be p. if for any=    q w r cv  |qs“  gw  it isand
cascade p  then =  〕cascade  if q= . otherwise  no empty range（if fq =    and in  cascade

wherethe new range r for the free variablescascade  qs g   is computed usingf“w of  qs g .
the intuition is that propagation at the level of each restricted quantifier  q w r c  is the  authoritative  source of information about the new ranges of w. conversely  for variables inployed where all the prunings realized by dominating scopesvar c  w a private temporary version of the ranges is emare cumulated. such collective result flows through the chain of authoritative propagations to boost them  then vanishes.
　the alternated structure of qcsp+ endows cascade propagation with an intrinsic advantage over the usual quantified arc-consistency of qcsp: it turns the global consistency check for values in universal domains into a local property  decidable at the level of single constraints in the csp rule of restricted quantifiers. this way  we expunge values from both universal and existential domains  symmetrically  by just  re using quantification-unaware csp propagators.
 qcspwe call+ such thatvalidity preservingp qcspany mapping+  eval p  =op :evalqcsp op +p  ★  and we say that op  is a（ contractor if  p =  qs g   ii   （  it is  i 
  and  iii  for every  q w r c  （ qs 
 q then.
theorem 1 cascade propagation is a validity-preserving contractor for qcsp+ problems.
the above property guarantees soundness and termination of the decision procedure  which performs cascade propagation at each search node. for details see  benedetti et al.  1a .
1 discussion and related works
concerns about the unsuitability of qcsp to model real cases have not been raised so far1: current random models do not clash with the issues addressed in this paper. qcsp+ has been designed in fact to provide crucial benefits in the upcoming development of more realistic models.
　the existence of a   -discipline  issue in quantified conjunctive languages has been recently identified by the qbf community  ansotegui＞ et al.  1 . a static version of the same question has been discussed for the case of qbf encodings of multi-valued qcsp variables whose boolean mapping needs to avoid  illegal  combinations  gent et al.  1 .
　this problem impacts on qcsp remarkably more than on qbf: the latter does not bother at all with the modeler's viewpoint  as it is not required for a human to write or understand a qbf specification. such qbf is obtained through a computer-assisted compilation which starts from some higher-level language and terminates in a process called cnf-ization. this consists in casting the meaning of any structured formula into a cnf by conjuncting the clausebased local meaning of each sub-formula through the help of auxiliary variables  plaisted and greenbaum  1 . a natural workaround to the discipline problem comes out of this mechanism: we reduce to a conjunctive matrix the entire meaning of e.g.   1 . this trick has since ever been adopted- often tacitly-in qbf models  and is the reason why a library of real-world instances exists  giunchiglia et al.  1 .
　a more structured qbf encoding technique-applied to two-player games-has been proposed in  ansotegui＞ et al.  1   where indicator variables are introduced to connect in a suited qbf the sat-plan propositional encoding of preconditions  effects  etc  kautz and selman  1 . however  this approach is shown to lead search-based solvers to explore artificially enlarged search spaces  an effect which can be mitigated either by employing encodings tuned to trigger a synergy between top-down search and boolean inference mechanisms  or by feeding the solver with information on the special role of indicator variables. more recently  dnf representations for boolean constraints have been adopted to reduce the search space  sabharwal et al.  1; zhang  1 .
　these approaches involve intricate details  or do not introduce explicitly a language/semantics. they demand searchbased solvers  or exploit boolean-only concepts  e.g. dnf   or focus on  human-level  games rather than on the general issue of modeling concepts through quantified constraints.
　conversely  restricted quantification is a fairly general and neat solution  inspired by analogous forms of quantification found in other modeling languages under the name of qualified  description logic   or bounded  logic programming   or restricted quantification  logic and semantics theory .
　restricted quantifiers-which allow us to reuse propagation technology and are not exclusively designed for searchbased reasoners-can be fully  back ported  to the realm of qbf  where they yield the qbf+ language  defined as the restriction of qcsp+ to boolean variables and clausal constraints. qbf+ will be studied in a forthcoming paper  but a first application is presented in the next section.
　the qbf-inspired techniques mentioned above can be interpreted as workarounds to bypass restricted quantifiers in qbf. while first evidences suggest  cfr. next section  that restricted quantifiers may be equally rewarding in qbf  their introduction in qcsp is supported by compelling arguments  as major obstacles prevent us from adapting other solutions: first  the modeler should be made responsible for capturing the semantics of the alternating structure in  1 . this threatens one of the fundamental assumptions of  q csp: models have to be human-writable and readable. second  qcsp constraints cannot undergo arbitrary syntactic manipulations as clauses do. to illustrate the problem  let us consider the qcsp+ formula  x c1 x   y  c1 x y   .c1 x y  . one way to attain a qcsp version of this formula would be to define a  single  constraint over x “ y whose meaning

is c1 x  …  c1 x y   ‥ c1 x y     to be processed by a quantified extension of the gac-scheme  nightingale  1 . though heavily demanding  in space or time  depending on the technique employed   this is still feasible for small  ex-

figure 1: running time comparison over the  strategic company  family  example 1  section 1 . the x axis gives the number of companies in the set. we compare qecode with state-of-the-art qbf solvers  and the qbf formulation with the qbf+ one.
plicitly defined table constraints. yet no viable solution exists if the c1 are  as they usually happen to be  sets of possibly arithmetic/global constraints. another option is to use the reified version of each constraint  bordeaux  1 .
the reified version of c x  is an always consistent constraint
  where y （ {1}  which is satisfied as if c x  is consistent  and as  otherwise. so  we can
write
 a generalized version of such rewrite shows that qcsp+ is still in pspace . inescapable complications arise in practice  as  i  no reified version is provided by the csp environment for many constraints  and  ii  the shift to the reified version may be considerably detrimental from the solver's viewpoint  since reified constraints cannot prune values from domains so long as they don't know the value of their last parameter.
1 implementation  models  and experiments
we implemented our decision procedure for qcsp+ in a system built around the csp solver gecode  schulte and tack  1 . our solver-called qecode-accepts a wide set of constraints in the input language1  and is publically available from  benedetti et al.  1c . at present  no other system accepts a constraint language as expressive as qecode does1  and no suited public domain model exists yet.
　we contribute an initial test suite by devising qcsp+ generators for the examples in section 1. example 1 and 1 do not rely on non-boolean variables/constraints and have a straight translation into qbf or qbf+. our generators also produce such equivalent propositional formulations. this enables us to exercise our system against qbf solvers. it is to be noticed that such comparison is of relative significance and biased in favor of qbf solvers  as it does not leverage the strengths of qecode  e.g. non-boolean variables  propagators with a complex semantics   while an important weakness is exposed  i.e. data structures are not tailored to boolean reasoning .

figure 1: comparison over some  connect  games  section 1  example 1 . the x axis gives the depth of analysis  number of moves .　results are shown in figure 1 and 1. for the  strategic companies  case  it comes out that only one qbf solver  out of the six state-of-the-art ones we have tested1  can compete with qecode. this result is impressive in the light of a recent work  gent et al.  1  estimating in two to three orders of magnitude the gain  q csp solvers can achieve by using the light data structures of sat/qbf solvers  which gecode  hence qecode  are not using . to cross-check this hypothesis of gain we modified the qbf decision procedure described in  benedetti  1  to parse and solve qbf+ specifications1: the results-labeled  a.b. on qbf+  in figure 1-confirm an improvement of one/two orders of magnitude over the best qbf solver and the base solver respectively.
　the existence of strategies in board games is a combinatorial problem with a large number of quantifier alternations known to be hard for general purpose reasoners. for connect n〜m-k results are quite favorable to qecode  figure 1  only the two best performing qbf solvers are shown . our models do not include symmetry breaking or auxiliary predicates.
1 conclusions and future work
major obstacles complicate the modeling of real-world problems in purely-conjunctive quantified constraint languages  like qcsp or qbf. the   -discipline  issue has been identified as the main culprit. we radically overcome such difficulty by introducing the qcsp+ language  where restricted quantifiers are allowed. this language enrichment is obtained through a controlled integration of disjunctive operators  and is purposely designed to facilitate the inheritance of existing solving and propagation technology: we implement the full-fledged qcsp+ solver qecode on top of gecode. incidentally  qecode  which can decide plain qcsps as special cases  happens to be the first qcsp solver to accept a wide set of constraints in the input language  including global constraints  and one of the first to be available publically.
　we devise multi-language generators to establish an initial suite of instances with restricted quantification. experimental comparisons against qbf solvers on some boolean models are quite favorable. however  our main contribution lays elsewhere: qcsp+ offers the formerly absent possibility to write and solve real-world models based on quantified constraints.
　we are currently working on the modeling of applicative problems in qcsp+  and in designing decision procedures for qcsp+ and qbf+ that are not based on search. 