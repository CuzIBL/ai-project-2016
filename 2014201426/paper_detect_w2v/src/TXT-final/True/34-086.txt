 

　　this paper describee some new methods used in planner-besm-1 system for the implementation of planner. backtracking is implemented with a single stack and no copying of activation frames is needed. lists are represented as arrays of pointers; the garbage collector for this representation requires no additional memory. restrictions on variable values are accomplished by using 'semi-definedf structures. these methods have enabled to achieve the high efficiency of the system work. 
　　together with the well-known techniques  coordinates in data base organization  1    context number for failpoints  and so on  planner-besm-1 system uses some new methods. this paper briefly describes three of such methods. backtracking is implemented with a single stack and without copying information in the stack. lists are represented as arrays of pointers which contain the length of lists; the garbage collection used for this representation requires no additional space. restrictions on variable values are accomplished with structures that are not fully defined. 

1  introduction 

　　newer programming languages  1  intended for use in artificial intelligence research have introduced many new facilities that make much more easy the construction of sophisticated ai systems. therefore practical implementation of these languages and creating efficient methods for this are the necessary and important tasks for ai progress. 
　　among the new languages planner   1  has gained the widest popularity. planner was the firbt language introducing a majority of the new concepts and methods. now planner attracts much attention: many papers propose methods of its translation  there are some practical implementations of it and others are being created. 
　　planner-besm-1 system is an interpreter. in some important aspects this system differs from other planner systems. the system has been designed to be an efficient practical tool  so the efficiency of the language implementation  which is the heel of achilles for planner  has been given more attention rather than aiming to implement all without exception features of planner. some features which are not the main within the language but require the superfluous memory and time for their implementation have not been introduced into the input language of this system. for example the input language uses only recursive and backtrack regimes and prohibits actors' utilization in matching patterns. this has enabled to use methods that increase the efficiency of the system work. 
1. implementation of backtracking 

　　there are some schemes for implementing backtrack control. for example the paper  proposes a scheme with two stacks. but this scheme requires multiple transfers of information from one stack to another. the scheme of  1} uses one stack and is intended for implementation of various control regimes. this general scheme has been used to implement language popler 1  which has sophisticated control structure. however  being adapted only to backtracking  this scheme spends the superfluous space and time because it requires multiple copies of activation frames. 
　　planner-besm-1 system uses also one stack for keeping frames of activations but no copying is needed  so this scheme requires less memory and time than the above schemes. the scheme is as followes  1 . 
　　there is a list called 'archive' that roughly corresponds to 'failist' of scheme  . archive saves information on changes of variable binding  data base and so on  made by the program. for each changed object archive keeps its location in memory and its previous state. using this the system will restore the previous states of the objects when a failure occurs within the program. 
　　stack contains information needed for functions' elaboration. upon entry to a function certain storage  called a frame of the function activation  is allocated in the end of stack. any frame occupies 

1 

always one continuous piece of stack space. the head of a frame contains activation name  a pointer ar to archive and links of this frame: a pointer i  see be-
low   a pointer al which specifies the 
variable bindings accessible within this frame  a pointer cl to the calling frame  and return address rt to the caller  thus moments of the elaboration of a function p which calls functions g  h and i in turn  the function g setting a failpoint and i calling a function j which generates a failure: a  g exits; b  h exits; c  j generates a failure; d  control is returned to g. a continuation point is saved in the called frame . a frame may also contain information on exit actions of the activation. another space of a frame holds temporary intermediate results and local variables' bindings  if any  of the function. during the whole activation the size of its frame is constant  while the contents of frame may vary   so the size is fixed on activation entry and then does 
not vary. 
　　if a function hasn't set any failpoint during its elaboration and if the function exits  then the frame of this function is removed out of stack  i.e. a pointer s to the end of stack will again point to a cell upper this frame. if during an activation a failpoint has been set  then the activation frame is retained in stack. in this case the pointer s is not changed. a consequence of 
this is that the frame of active function is not always located in the end of stack. for this reason there is another pointer r which always points to the frame of function that is active now. the active function uses this pointer in order to 
access its own frame. when & new frame is created  the value of r becomes a link cl  and then r begins to point to the head of the new frame; later  when the function exits  cl will be transfered to 
r. therefore without failpoints the pointers s and r are changed synchronous-
ly  which corresponds to normal recursive regime. 
　　when a function has to set a failpoint  it allocated information on this failpoint in the last cell of its frame 

and then fixes a pointer f to this cell  the third stack pointer - f - always points to a cell of the last existing failpoint . this information consists of address pp of the previous failpoint cell and 'reaction address' ra that is an address of the interpreter instractions which will perform certain actions when a failure returns control to this failpoint. pig. 1 shows the contents of the frame for  among  1 ijcai  ussr tbilisi  1   in the moment when this function has set a failpoint before returning the first selected value - 1. 
　　　it is possible by comparing the pointers r and f to determine whether or not a function has set a failpoint and hence to determine whether or not a frame of the function should be retained in 
stack. if on a function exit then the function has a failpoint so the pointer s is not changed  otherwise s varies. pig. 1 shows the states of stack and pointers e  r and f at different 
   when a failure occurs  the interpreter cleans stack up to the frame which keeps the last faildoint  the value of f is transfered to s  and then returns control to the reaction on failure within this failpoint. since information on the failpoint is located in a frame of acti-
vation that has set the failpoint  the reaction gets an access to all information of this frame  in particular to information needed for redoing the elaboration of the function. using this information the reaction restores the pointer rt restores access environment with link cl  and then with scanning archive it restores previous values of variables  previous state of data base and so on. due to these actions the state of execution is restored. the further actions of reaction are different for different functions. for example  function among will chop the next element off the list stored in its frame and then will return this 

1 

element as new result. but i f the list is empty then the function will destroy its failpoint  address pf will be tranefered to pointer f  and failure will propagate upper. 
　　an addition is necessary to the described scheme. let us consider the elaboration of  and e1 e1 e1 e1   . this function calls its arguments in turn until false occurs- ahd sets no failpoint so it cannot catch a failure on its own. however its arguments may set failpoints and generate a failure. hence and cannot manage transfers of control among its arguments. for example  let e1 sets a failpoint and e1 generates a failure that returns control to e1. if the repeated computation of e1 succeeds then control is returned to and again  but this function will not know that it should call e1 and not e1. 
　　this mistake is easily rectified. when a function calls another function  the calling one gives some information  a pointer i  to the called one to keep it. when the lower function finishes i t returns this pointer together with its result. as a rule  i is a pointer to the list of arguments followed the argument evaluated now. the returned pointer informs the calling function which argument should be evaluated at the next step. hence the correct work of the calling function is not broken by transfering control from one argument to another. 
　　all functions of planner for backtrack regime  in particular non-local goto and failures directed to a point  were implemented within the bounds of the described scheme. 
1- list representation 

　　in planner the main operations on lists are more complex than  for example  those in lisp  there are scanning lists from both the ends  selecting any element or sequent from list  matching list-patterns. the usual list representation  as in lisp systems  is not effective for elaborating these operations. for example a match of lists requires easy determining the list lengths but i t is impossible with this representation. on the other hand  the operation cons  efficiently implemented with this representation  is not typical for planner. moreover the usual list representation leads to scattering list cells all over the me-
mory  which is inconvinient for the paging of virtual memory used in plannerbesm-1 system. 
　　in view of this  planner-besm-1 system uses a different list representation  namely  a list is represented as an array of pointers  see fig. 1 . a pointer to a list consists of three parte: the initial address of array  the length of array and a type indicator  each data type has its own indicator . a list length used tn a pointer makes easy to match patterns and to scan lists from the end. successive location of list elements makes easy to select any element or sefment. due to such representation lists and tuples are not distinguished. in addition  this representation partially  on the highest level  localizes list cells in memory. 
　　a pointer to integer is the same integer with fixed exponent which is also an indicator of type 'integer'. pointers to other data types consist of two parts  viz.  type indicators and references to property cells of data. free space of these pointers is used for various aims  for example to list all labels of function prog. 
　　the list representation described requires the free space of list memory to be one continuous sequent. the interpreter fills this space from bottom to top  hence the garbage collector must pack relevant pointers and move them down  modifying references of these pointers. multiple references to inside of lists make difficulties for this moving and for reference changing  so the garbage collection used in flanner-besm-1 system takes three stages. but this garbage collection is simple and doesn't require additional space  and this differs it from other methods of garbage collection with packing. 
　　the first stage is to mark cells of lists needed for the further runnig of program. this is performed as in iasp systems  besides the total amount of 
marked cells is counted. 
　　the second stage is linear scanning list space from top to bottom and changing all references down  i.e. references to cells with larger addresses . this changing is performed as follows. 
　　let a current examined cell a is marked and also contains a reference to cell b   b a ; in this stage all references up are ignored . then the garbage collector interchanges both the references of cell a and b  and if this reference to cell b is the first one from top then both the cells a and b is marked by '+'  this marker is distinct from the marker used in the first stage . then cell a+1 will be examined. 
　　if a current examined cell b contains the marker '+' then at this moment the cell b contains also the initial address of list of cells a1 a   ...   an   ai a.+1  a   b   which have had the references to cell b before. at this 
moment address b' which should be assigned to pointer of cell b is known: b' is defined by the total amount and the amount of already examained marked cells. so the garbage collector in scanning the chain of cells a   ...   a   a- puts the address b1 into them. the last cell &1 of this chain is marked and contains the re-

1 

ference that has before been placed in cell bt so this reference ie transfered to cell b  marker   +   is removed out of cells a1 and b  and then the contents of cell b is treated on common base. 
　　in planner-besm-1 system the list space is placed in the bottom of memory  hence all references from other spaces to this space are references down. in order to avoid scanning other spaces in the second stage  all references of those spaces to the list space are treated in the first stage as described above. 
　　the third stage of the garbage collection is linear scanning the list space from bottom to top  moving all marked pointers  to the space bottom  and changing all references up. this stage is similar to the previous stage but each reference up is moved to new location first and then its new address is used. 
1. restrictions on variables 

　　matching two patterns is used in function match or during theorems' invocation. one of problems here is the implementation of restrictions on variable values. when a pattern matches another pattern some variables get no values but their future values are constrained. for example on elaboration of  match *x *y   prefix '*' means 'to assign value to variable'  no variable gets a value but their future values will be equal. another type of restrictions appears in matching a variable with a list which contains variables. for example on elaboration of  match * i  *y a .y   the future value of x will be a list with three elements  the second of which is atom a  two others are equal and are the future value of y  prefix '.' means 'to get value of variable' . 
　　since the input language of plannerbesm-1 eystem prohibits actors' utilization in matching two patterns  restrictions on variable values may be of the above types only. this restrictions are implemented in such manner. 
　　new data type 'semi-defined structure' is introduced. this is a structure a part of which is not defined  namely  a 
　　inner  not accessible to users  variable without a value or a list some elements of which are semi-defined structures. if a variable gets no a fully defined  'real '  value in matching then ite value  sd-value  will be a semi-defined structure. this sd- value is constructed with the pattern which has been confronted to the variable: all variables of the pattern are substituted by their values  in particular by sd-values  wherever possible; the rest of variables get references to some inner unassigned variables as values  and then these references are inserted into the pattern. thus any variable has a value always but sd-value is not accessible to users. 
　　in matching sd-value behaves as well as 'real' value: object confronted to a variable with sd-value must match sd-value. a consequence of this is that a variable may get only the 'real' value that matches the existing sd-value. in general case  any new restriction on variable value is immediately checked on compatibility with the existing sd-value  and if they do not conflict then their 'intersection' will be the new sd-value of the variable. this check often allows to define the full value of variable in proper time* for example this takes place for  match  *x .x    *ya   b *z  } . 
　　cross-references among 'real1 variables are accomplished by sd-values since in general case each inner variable is referenced by some semi-defined structures. if a semi-defined structure is filled in fully or partially then all or so-
me inner variables referenced by this structure get values  and hence some other semi-defined structures are also filled in fully or partially. since cross-references among 'real' variables are accomplished indirectly  through inner variables the existence of which doesn't depend on the existence of 'real' variables  but depends on amount of references to them   so it is not necessary to retain 'real' variables in memory only because of the program has defined links among other 'real' variable by those. so when a theorem has set no failpoints then its frame ie removed out of stack even if there are cross-references among global 
variables through its local variables  because the existing inner variables are holding this links. 
