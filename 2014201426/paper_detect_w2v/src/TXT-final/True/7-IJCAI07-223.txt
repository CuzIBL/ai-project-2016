
we show that the problemof model checking multidimensional modal logics can be reduced to the problem of model checking arctl  an extension of the temporal logic ctl with action labels and operators to reason about actions. in particular  we introduce a methodology for model checking a temporal-epistemic logic by building upon an extension of the model checker nusmv that enables the verification of arctl. we briefly present the implementation and report experimental results for the verification of a typical security protocol involving temporal-epistemic properties: the protocol of the dining cryptographers.
1 introduction
epistemic logic  fagin et al.  1; meyer and hoek  1  has traditionally played an important role in artificial intelligence  ai . not only does epistemic logic provide a formal basis for reasoning about states of knowledge in automatic reasoners but it can also be seen as a formal specification language to reason about artificial agents. indeed  epistemic concepts are particularly appropriate in multi-agent systems  mas  as knowledge constitutes the basis for rational action. in this line of work typically one considers the epistemic modal logic s1n combined with a temporal logic for branching time or linear time interpreted on computationally groundedsemantics  wooldridge  1 such as the one of interpreted systems  fagin et al.  1   or a suitable variation of it  wooldridge and lomuscio  1 .
¡¡while much attention in the 1s and 1s focused on proving meta-logical results  notably completeness and computational complexity  for various temporal and epistemic combinations  halpern and moses  1; meyden  1; meyden and wong  1   considerable attention has been given in the past few years to the problem of devising model checking techniques for these formalisms  hoek and wooldridge 

 
¡¡¡¡the author acknowledges support from epsrc grant gr/s1.  
 with riacs at nasa ames while performing this work.  
¡¡¡¡with mct at nasa ames while performing this work. the author acknowledges support from epsrc grant cna/1.1; gammie and van der meyden  1; raimondi and lomuscio  1; penczek and lomuscio  1 . these efforts are strictly related to the recent shift of attention from theorem proving to model checking as suggested  among others  in  halpern and vardi  1 .
¡¡this article intends to make a contribution in this line by proposingan efficient modelchecking techniquefor verifying ctlk  an epistemic logic on branching time  penczek and lomuscio  1   based on nusmv  cimatti et al.  1   a mainstream model checker for temporal logic. specifically the present article makes the following points. first  it is shown that the model checking of ctlk can be  automatically  rephrased as the one of model checking the actionbased temporal logic arctl  pecheur and raimondi  1 . second  we present an automatic translator from an smv-like language for a semantics of mas for the extension above. the main benefits of this proposal against the current stateof-the-art lies in the efficiency of the approach which we try to demonstrate by discussing experimental results.
1 preliminaries
we summarise the formalism of interpreted systems in section 1  a formalism to reason about time and knowledge in a system of agents. in section 1 we discuss the problem of model checking using nusmv.
1 interpreted systems and ctlk
the formalism of interpreted systems  introduced in  fagin et al.  1   provides a formal framework to reason about time and knowledge in a system of agents. let ¦² be a set of n agents: ¦² = {1 ... n}. a set of local states li and a set of actions acti is associated to each agent i  together with a protocolpi : li ¡ú 1acti assigning a list of enabled actions to each local state. the local states of an agent change according to a local evolution function ti : li ¡Á le ¡Á act ¡ú li  where le is the set of local states of a special agent in ¦²  the environment   and act = act1 ¡Á ... ¡Á actn. the set s = l1 ¡Á ... ¡Á ln is called the set of global states. given a set of initial global states i   s  the set g   s representing the set of reachable states is generated by the evolution of i and in accordance with the protocol and the agents' local evolution functions1. given a set of atomic propositions ap and an interpretation v   s ¡Á ap  an interpreted system is a tuple

¡¡the logic ctlk combines the traditional ai epistemic logic s1n with the temporal logic ctl. specifically  the syntax of ctlk is defined as follows:
  ::= p |    |   ¡Å   | ex  | eg  | e  u   | ki   1 
where ki  is read as  agent i knows    and the ctl operators have the standard meaning - for example  eg  is read as  there exists a path where   holds forever . other derived operators are defined in a standard way  see e.g.  clarke et al.  1; fagin et al.  1  . to evaluate ctlk formulae  a kripke model mis =  w i rt ¡«1 ... ¡«n v   is associated to a given interpreted system is  as follows: w is the set g of reachable states  i   w is the set of initial states  the temporal relation rt   w ¡Á w is obtained using the protocols pi and the evolutions functions ti  the epistemic relations ¡«i   w ¡Á w  for i ¡Ê ¦²  are defined by checking the equality of the i-th local component of two global states  i.e.     and v is the evaluation relation appearing in is1.
¡¡the formulae defined by  1  are interpreted in mis in a standard way: we refer to  clarke et al.  1; fagin et al.  1; penczek and lomuscio  1  for the formal definition of m |=    where |= is the standard satisfaction relation.
1 model checking using nusmv
given a kripke model m and a formula    model checking is defined as the problem of establishing whether or not m |=  . in this approach m represents the system to be checked and   the specification of the system. in the last fifteen years techniques and tools have been developed to performthe verification task in an automatic way  mainly for temporal models and temporal specifications. nusmv  cimatti et al.  1  is a mature model checker for temporal logics and it has been employed in the verification of a number of examples. other very successful model checkers exist  notably spin  holzmann  1   verics  nabialek et al.  1   etc.
¡¡nusmv has a dedicated modelling language  the smv language  which permits the definition of the temporalmodel in an expressive  compact and modular way. nusmv avoids building or exploring the state space corresponding to its models explicitly; instead  nusmv applies symbolic techniques based on ordered binary decision diagrams  obdds  or propositional satisfiability  sat  solvers to efficiently perform verification over large state spaces.
¡¡nusmv is a command line tool available for most operating systems  and its source code is available under the terms of the gnu general public license  gpl .
1 model checking mas: state of the art
recently  different approaches have been proposed to extend model checking techniques from temporal logics to richer logics  with the aim of verifying knowledge-based and agentbased systems. two main streams can be identified in the recent literature:
1. dedicated tools. works along this line include the model checker mck  model checking knowledge   gammie and van der meyden  1    implementing the verification of certain classes of interpreted systems. verics  nabialek et al.  1  is a model checker for mas described using networks of timed automata. mcmas  raimondi and lomuscio  1  is an obdd-based model checker for mas described in interpreted systems.
1. extensions  and translations  to existing tools.  hoek and wooldridge  1  propose the use of local propositions to reduce the problem of model checking knowledge and time to the verification of a temporalonly model.  wooldridge et al.  1  define the mable language  and they show how the verification of this language can be reduced to the verification of promela code  the input language of the model checker spin  holzmann  1  . similarly   bordini et al.  1  introduce the language agentspeak f   and they present a translation into promela code.
¡¡experimental results from the papers cited above show that  on average  purpose-built tools can handle larger examples  and that trying to use existing tools often requires manual intervention. we show below this is not necessarily the case. in the remainder of this paper our aim is to introduce a fully automated methodology that builds upon an existing tool  nusmv  and show that it performs comparably or better than similar approaches.
1 model checking ctlk in nusmv
this section introduces the logic arctl  action-restricted ctl  and a proposed extension to nusmv thereby enabling the verification of arctl operators. in section 1 we show how the problem of model checking for ctlk can be reduced to the problem of model checking for arctl  thereby permitting the verification of ctlk by using nusmv. in addition  in section 1 we present an smv-like language for interpreted systems and its translation into smv code.
1 the logic arctl
the logic arctl  pecheur and raimondi  1  extends the logic ctl by allowing quantification over action labelled paths. more in detail  given a set of atomic propositions ap and a set of atomic actions aa  the syntax of arctl is defined as:
 ::=p |    |   ¡Å   | e¦Áx  | a¦Áx  |e¦Á  u   | a¦Á  u   1 ¦Á::=b |  ¦Á | ¦Á ¡Å ¦Á 1 where   and ¦Á are state and action formulae and p ¡Ê ap b ¡Ê aa are atomic propositions over states and actions  respectively. similarly to ctl  other temporal operators can be derived in a standard way.
	a model for arctl is a tuple of the form m	=
 s s1 a t vp va   where s is a set of states  s1   s is a set of initial states  a is a set of actions  t   s ¡Á a ¡Á s is a transition relation  notice the dependence on actions   vp : s ¡ú 1ap is an interpretation for atomic propositions  and va : a ¡ú 1aa is an interpretation for atomic actions. given a model m =  s s1 t vp va   the ¦Á-restriction of m  denoted by m¦Á  is a model m¦Á =  s s1 t¦Á vp va   where t¦Á is a transition relation such that  iff  and a |= ¦Á  where |= is the natural extension of va to propositional formulae ¦Á . we refer to  pecheur and raimondi  1  for further details.
¡¡for model checking purposes  we have extended nusmv to support the verification of arctl formulae. we used nusmv existing  input  variables to model arctl actions. in particular  we have modified the syntax of the formulae accepted by nusmv as follows:
ctlexpr	::=	...	 existing ctl forms 
eax simpleexpr ctlexpr
eag simpleexpr ctlexpr
ea simpleexpr  ctlexpr u ctlexpr 
where simpleexpr is a conditional expression  further restricted to contain only input variables. for example  ea a  p u q  is the concrete syntax for ea puq . additionally  we have implemented extensions to the nusmv code base to enable the verification of these operators  the details of these modifications are beyond the scope of this paper  we refer to  pecheur and raimondi  1  for further details .
1 reducing ctlk to arctl
the problem of model checking ctlk  see section 1  can be reduced to the problem of model checking arctl. specifically  given a ctlk model mk and a ctlk formula  k  we can define an arctl model m = f mk  and an arctl formula f  k  such that mk |=  k iff f mk  |= f  k . let ¦² = {1 ... n} be a set of agents  and let mk =  w i rt {¡«i}i¡Ê¦² v   be a model associated to some interpreted system is =
.	the model f mk  is an
arctl model m =  s s1 a t vp va  such that
  s = w and s1 = i;
  the set aa = {run agt1 ... agtn} contains a proposition run to label temporal transitions  defined by rt  and n propositions agti  one for each agent  to label epistemic equivalence steps  defined by ¡«i   and the action set a is 1aa;
  the transition relation t combines the temporal transition rt and the epistemic relations {¡«i}i¡Ê¦² in the following way: for states
;  ii  ;  iii   for all 1 ¡Ü i ¡Ü

1
¡¡¡¡case  iii  is necessary for interpreting distributed knowledge operators  but this discussion is beyond the scope of this paper.

figure 1: verification work flow for interpreted systems
¡¡the translation of a temporal-epistemic formula into an arctl formula is inductively defined as follows:
  f p  = p  if p is a propositional formula.
  f ex   = erunx ; f e  u¦×   = erun  u¦× ; f eg   = erung ; f ki   = aagtix .
in other words we use the labels run  agti  respectively  to denote a temporal relation  the epistemic relation for agent i  respectively . this translation allows us to model check ctlk formulas by model checking their translations in arctl. clearly a similar approach can be used for more complex modal logics.
¡¡the translation from an interpreted system is to the arctl model f mis  is performed automatically by a translator we have implemented  see next section .
1 an smv-like language for interpreted systems
we have designed extensionsof the smv languagefor the description of interpreted systems and ctlk formulae. these extensions can be translated to into a standard smv model and arctl formulae. concretely  the extensions are defined as a library of m1 macros1. the work flow needed to perform verification of an interpreted system is summarised in figure 1. notice that the only manual intervention is the provision of the input file describing the problem to be verified.
¡¡in this language  an agent  name  is associated with the smv variables  v1  ..  vn  that define its local state  through a declaration agent  name   v1  ..  vn  . the actions of each agent are represented as input variables  ivar . the protocol of each agent is described as a relation between its local state and action variables  within an smv trans statement . the transition function is encoded using a new ttrans statement  and initial conditions using a new tinit statement. figure 1 shows the structure of a typical definition of a class of agents as an smv module  note that  --  starts comments in smv  see  cimatti et al.  1  for details .

     1  kernighan and ritchie  1  is a general-purpose macro processor available on most unix platforms.
module anagent args env  -- an agent module var local : {...};	-- the local state
agent me local 	-- declare the local state
ivar action : {...}; -- actions of the agent
tinit  ...  ; trans  action =-- initial conditionscase ...  
ttrans  next local  =-- the agent's protocolcase ...  -- the agent's evolution functionmodule main-- main modulevar env-- declare env variablesvar alice : anagent args1 env  ; -- an agent bob	: anagent args1 env  ; -- another agent
figure 1: example of agent definition in extended smv
¡¡internally  the translation generates additional boolean variables ivars corresponding to the run and agti propositions of the arctl model  e.g. run  bob.me and alice.me in the model of fig. 1   and ttrans statements expand to standard trans statements conditioned on run.
¡¡note that the state space of the nusmv model is not a priori restricted to the  temporally  reachable states; this has to be imposed by the translation scheme. a state is reachable iff it can be reached from the initial states through a series of temporal steps  or  equivalently  iff there exists a reverse path from that state back to the initial set . assuming we have access to reverse temporal transitions through some action condition back in our arctl model  and a state condition init for initial states  the set of the  temporally  reachable states is captured by the following arctl formula:
reachable ¡Ô ebackf init
since this is a temporal formula  it has to be folded into nusmv properties; it cannot be used in the nusmv model itself. for example  the ctlk formula ki  expands to the
arctl formula aagtix reachable ¡ú   .
¡¡our library implements this scheme. in particular  the ttrans construct implements an encoding scheme allowing temporal transitions to be traversed both forwards and backwards. on the specification side  new operators tax  tag  etc. provide the equivalent of smv's built-in ax  ag  etc.  restricted to temporal transitions  and a new operator kk implements ki . for instance  the ctlk formula ag ka p¡Åq   expressing that agent a always knows either p or q  is written as tag kk a p|q  .
1 example application
in this section we model the protocol of the dining cryptographers using the formalism presented in section 1  in order to enable its verification using the methodology presented in section 1. the protocol was introducedby chaum in  chaum  1   and was modelled using agents by various authors  van der meyden and su  1; raimondi and lomuscio  1; kacprzak et al.  1 . the aim of this protocol is to allow the anonymous broadcasting of messages  and it is usually introduced using the following scenario  wording
from  chaum  1  :
¡¡ three cryptographers are sitting down to dinner at their favorite three-star restaurant. their waiter informs them that arrangements have been made with the maitre d'hotel for the bill to be paid anonymously. one of the cryptographers might be paying for dinner  or it might have been nsa  u.s. national security agency . the three cryptographers respect each other's right to make an anonymous payment  but they wonder if nsa is paying. they resolve their uncertainty fairly by carrying out the following protocol:
¡¡each cryptographer flips an unbiased coin behind his menu  between him and the cryptographer on his right  so that only the two of them can see the outcome. each cryptographer then states aloud whether the two coins he can see-the one he flippedand the one his left-hand neighbourflipped-fell on the same side or on different sides. if one of the cryptographers is the payer  he states the opposite of what he sees. an odd number of differences uttered at the table indicates that a cryptographer is paying; an even number indicates that nsa is paying  assuming that dinner was paid for only once . yet if a cryptographer is paying  neither of the other two learns anything from the utterances about which cryptographer it is 
¡¡this protocol can be extended to any number n of cryptographers greater than three. we encode the scenario by using an interpreted system by introducing n agents c1 ... cn  and one agent e to represent the environment  which selects the payer and the result of coin tosses at the beginning of each run  non-deterministically   raimondi and lomuscio  1 .
¡¡the local state of cryptographer ci is modelled using three variables equali paidi eveni  representing respectively whether the coins that ci can see are equal or different  whether ci is the payer  and whether the number of different utterances reported is even.1 the list of actions for each cryptographer includes the actions do nothing  say equal  and say different  performed in compliance with the description provided above. in the initial state the variables for each cryptographer are initialised to a null value  and they are updated in the first time step  to reflect the environment's configuration. at this point  each cryptographer utters the appropriate phrase  represented by say equal or say different  and the variable storing the value of  different  utterances  either even or odd  is appropriately updated. the key properties of this scenario  van der meyden and su  1  are easy to express using ctlk. for instance:
 odd ¡Ä  paid1  ¡ú ax kc1 paid1 ¡Å paid1 
 1 
¡Ä kc1 paid1  ¡Ä  kc1 paid1  
	even ¡ú ax kc1  paid1 ¡Ä  paid1  	 1 
¡¡formula  1  expresses the property that  if the first cryptographer did not pay for the dinner and there is an odd number of utterances  then  upon update of his local state  the first cryptographer knows that someone of the remaining cryptographers paid for the dinner  but the first cryptographer does not know who the payer is. formula  1  expresses the property that if the number of utterances is even  the first cryptographers knows that nobody paid for the dinner.
n. cryptbool varsnusmvmcmasverics11s1s1s11s1s1s11s1s1m11s1s1m11s1sn/a11s1mn/a11sn/an/atable 1: average experimental results.
¡¡we have encoded this scenario using the language presented in section 1 and we have been able to verify the example for up to nine cryptographers1. experimental results are reported in the next section.
1 experimental results
table 1 reports the time results obtained in the verification of the example presented in the previous section  as a function of the number of cryptographers  first column . the third column reports the time required for the verification of the formulae 1 and 1  appropriately translated into arctl formulae . the second column reports the number of boolean variables required to encode the example  see  clarke et al.  1  for more details on this technique   and provides an estimate for the size of the model; for instance  1 boolean variables are required to encode an example with 1 cryptographers  corresponding to a maximal state space of size 1 ¡Ö 1.
¡¡the fourth and fifth columns report the time results obtained in the verification of the protocol of the dining cryptographers using the model checkers mcmas and verics  as reported in  raimondi and lomuscio  1; kacprzak et al.  1   for the verification of the same formulae mentioned above  as a function of the number of cryptographers. notice that  in the case of mcmas  the verification time does not depend on the formula being verified and it is usually a fraction of the time spent in reading and parsing the model  the opposite is true for nusmv  because of different implementation choices . the last column reports the time results for verics. differently from the previous two cases  verics's results are based on an implementation of bounded model checking for ctlk.  penczek and lomuscio  1 . due to this  verics's performance for this two formulae is worse than the other two model checkers  but verics is normally capable of finding counterexamples for false formulae effectively: in  kacprzak et al.  1  it is shown that certain false formulae can be verified in scenarios with up to 1 cryptographers. neither mcmas nor the technique of this article can handle this magnitude of state spaces.
1 discussion
a comparison of the results obtained with the three model checkers is reported in figure 1. clearly for the formulae considered here the approach presented here performs moderately better than mcmas and verics. the better performance is due to the optimisation techniques implemented in nusmv  such as on-the-fly model checking and caching . obviously  experimental results depend on the examples tested and it is not appropriate to draw final conclusions on one example only. additionally  we would expect verics to outperform the approach presented here when trying to falsify formulas on very large state spaces. nevertheless  we think the discussion above shows that the technique presented here can significantly complement the other model checkers in many instances.

figure 1: comparison of the experimental results.
¡¡we could not compare our methodology to other existing approaches based on existing model checkers  see section 1 . indeed  such approaches often require a manual intervention in the translation from their specific programming language into the programminglanguage of the temporal model checkers  and this is not feasible for large examples such as the one considered here.
1 conclusion
in this paper we have presented a novel technique for model checking ctlk that relies on the translation of this logic into action-based temporal logic and model checking of this logic with nusmv. the approach is sound and complete and our implementation shows experimental results that are in line with or better than existing specialised tools.
¡¡the use of macros for extending the nusmv language has allowed for easy prototyping but limits the syntactic flexibility. a more natural syntax could be supported with more involved translation facilities. further planned work includes investigating optimisation of the verification scheme  both at the level of the translation from ctlk to arctl and through additional extensions or optimizations of nusmv itself. moreover  we limited our analysis to dining cryptographers because this is the only scenario for which experimental results are available in the literature. in future work we certainly plan to use the technique and tool presented here to investigate more realistic scenarios.
¡¡another important issue to be addressed is the handling of witness traces generated by nusmv  which need to be formulated back in terms of the original ctlk model. we would also like to investigate using nusmv's sat-based bounded
model checking capabilities rather than the current obddbased approach. given the limitation of nusmv  this requires shifting from branching to linear temporal logic  requiring a new and more restrictive encoding scheme for ctlk properties. the feasibility and applicability of such a scheme remains to be explored.
