
in peer-to-peer inference systems  each peer can reason locally but also solicit some of its acquaintances  sharing part of its vocabulary. this paper studies both theoretically and experimentally the problem of computing proper prime implicates for propositional peer-to-peer systems  the global theory  union of all peer theories  of which is not known  as opposed to partition-based reasoning .
1 introduction
recently peer-to-peer  p1p  systems have received considerable attention because their underlying infrastructure is appropriate to scalable and flexible distributed applications over internet. in a full p1p system  there is no centralized control or hierarchical organization: each peer is equivalent in functionality and cooperates with other peers in order to solve a collective task. first p1p systems were simple keyword-based file sharing systems like napster  http://www.napster.com  and gnutella  http://gnutella.wego.com   for which efficient lookup services  e.g.  chord  stoica et al.  1   have been invented. recently  schema-based peer data management systems like edutella  nedjl et al.  1  or piazza  halevy et al.  1b  have been proposed. in those systems  query answering complexity is directly related to the expressivity of the formalism used to state the semantic mappings between peers schemas  halevy et al.  1a . the scalability of piazza so far goes up to about 1 peers and relies on a wide range of optimizations  mappings composition  paths pruning  tatarinov and halevy  1    made possible by the centralized storage of all the schemas and mappings in a global server.
¡¡in this paper  we make the choice of being fully distributed: there are neither super-peers  as in edutella  nor a central server  as in piazza . in addition  we aim at scaling up to thousands of peers. we consider p1p inference systems in which the local theory of each peer is a set of clauses defined upon a set of propositional variables. each peer may share part of its vocabulary with some other peers. we investigate the reasoning task of finding consequences of a certain form for a given input formula expressed using the local vocabulary of a peer. this reasoning task is important in many applications  diagnosis  information integration   in which output must be computed from input that is provided at query time  and cannot be reduced to satisfiability checking.
¡¡the problem of distributed reasoning considered in this paper is quite different from the problem of reasoning over partitions obtained by decomposition of a theory   dechter and rish  1; amir and mcilraith  1  . in that problem  a centralized large theory is given and its structure is exploited to compute its best partitioning  in order to optimize the use of a partition-based reasoning algorithm. in our problem  the whole theory  i.e.  the union of all the local theories  is not known and the partition is imposed by the p1p architecture. therefore  existing algorithms   amir and mcilraith  1; dechter and rish  1; del val  1   are not appropriate for our consequence finding problem.
¡¡section 1 defines formally the p1p inference problem addressed in this paper. section 1 describes the distributed consequence finding algorithm that we propose and states its properties. section 1 accounts for a significant experimental study of the scalability of this approach. section 1 describes related work and we conclude in section 1.
1 peer-to-peer inference: problem definition
a peer-to-peer inference system  p1pis  is a network of peer theories. each peer p is a finite set of formulas of a language lp. we consider the case where lp is the language of clauses that can be built from a finite set of propositionalvariables vp  called the vocabulary of p. peers can be semantically related by having common shared variables in their respective vocabularies. each peer only knows its own local theory and that it shares some variables with some other peers of the p1pis  its acquaintances . it does not necessarily know all the peers with which it shares variables. when a new peer joins a p1pis it simply declares its acquaintances in the network  i.e.  the peers it knows to be sharing variables with. a p1pis can be formalized as an acquaintance graph.
definition 1 let p = {pi}i=1..n be a collection of clausal theories on their respective vocabularies vpi  let v = ¡Èi=1..nvpi. an acquaintance graph over v is a graph ¦£ =  p  acq  where p is the set of vertices and acq   v ¡Á p ¡Á p is a set of labelled edges such that for every  v pi pj  ¡Ê acq  i 1= j and v ¡Ê vpi ¡É vpj.
¡¡a labelled edge  v pi pj  expresses that peers pi and pj know each otherto be sharing the variable v. for a peer p and a literal l  acq l p  denotes the set of peers sharing with p

figure 1: acquaintance graph for the tour operator example
the variable of l. for each theory p  we consider a subset of target variables t vp   vp  supposed to represent the variables of interest for the application. the goal is  given a clause provided as an input to a given peer  to find all the possible consequences of the input clause and the union of the peer theories  that belong to some target language. given a set sp of peers  the target language t arget sp  is the language of clauses  including the empty clause  involving only target variables of peers of sp. a shared variable must have the same target status in all the peers sharing it.
definition 1 let p be a clausal theory and q be a clause. a clause m is called a prime implicate of q w.r.t. p iff p ¡È {q} |= m and for any other clause m¡ä  if p ¡È {q} |= m¡ä and m¡ä |= m then m¡ä ¡Ô m. m is called a proper prime implicate of q w.r.t. p iff it is a prime implicate of q w.r.t. p but p |1= m.
definition 1 let ¦£ =  p  acq  be an acquaintance graph modeling a p1pis  where p = {pi}i=1..n is a collection of clausal theories with respective target variables. the consequence finding problem is  given a peer p and a clause q ¡Ê lp to find the set of proper prime implicates of q w.r.t. si=1..n pi which belong to t arget p .
¡¡since none of the peers of a p1pis knows the union of the theories of the system  the consequence finding problem in a p1pis is new and significantly different from the consequence finding problem in a single global theory  even partitioned . in a full p1p setting  each peer must run the same reasoning algorithm locally and independently  while being able to distribute part of the reasoning task that it controls to some of its acquaintances.
example : let us consider 1 peers  figure 1 . p1  describing a tour operator  expresses that its current far destinations  f  are either kenya  k  or chile  c . these far destinations are international destinations  i  and expensive  e . p1  only concerned with police regulations  expresses that a passport is required  p  for international destinations. p1 focuses on sanitary conditions for travelers. it expresses that  in kenya  yellow fever vaccination  y   is strongly recommended and that a strong protection against paludism should be taken  pl  when accomodationoccurs in lodges  l . p1 describes accommodation conditions : lodges for kenya and hotels  h  for chile. it also expresses that when anti-paludism protection is required accommodationsare equippedwith appropriate anti-mosquito protections  am . shared variables are indicated on the edges of the acquaintance graph  figure 1 
 	p1 =	and	p1 =	.
¡¡we now illustrate the behavior of the distributed consequence finding algorithm detailed in section 1. when a peer receives a query  it first computes all local consequents of the query. those in t arget p  are immediately returned. then  those made of shared literals are splitted. for each shared literal  a subquery is propagated to the neighbor peers sharing the corresponding variable. when returned  consequents of the subqueries are respectively queued for future recombination. as soon as one answer has been returned for each subquery  they are recombined and transmitted back as new consequents to the querying peer. this process continues incrementally  as further consequents for the subqueries are returned.
¡¡forinstance  supposethat f is transmitted to peerp1 by the user. the consequents that are locally computed are e  i and c¡Åk. since e¡Êt arget p1   it is immediately returned as a local consequent. since i is shared with p1  it is transmitted to p1  which produces the clause p. since p¡Êt arget p1   it is transmitted back to p1 and returned as a remote consequent of the initial query. the clause c ¡Å k  being made of shared variables  is splitted and c and k are transmitted separately to the concerned neighbors. c is transmitted to p1  which returns  only  h to p1  where it is queued for combination. similarly  k is transmitted  independently  to p1 and p1  both share k with p1 . on p1  l is produced locally. since l¡Êt arget p1  it is returned as a first consequent of k to p1  where it is queued. on p1  after recombination  h ¡Å l is then returned as a first combined consequents of the initial query. since l is also shared between p1 and p1  it is propagated on p1  where the clause  k ¡Å pl is produced and  in turn  splitted. p1 is then asked for pl and returns am as its only consequent. p1 is asked for  k. this happens while the complementary query k is still under process. we will see in section 1 that when a same reasoning branch contains two complementary literals  which is detected using a history mechanism   it is closed and 1 is returned as a consequent. p1 now combines am  returned by p1 for pl   and 1  returned by p1 for  k  as a new consequent of  k ¡Å pl  and thus  transmits am back to p1 as a new consequent of l. for lack of space  we do not detail all reasoning branches. the set of consequents of the initial query eventually produced is: {e i h ¡Å l h ¡Å am h ¡Å y h ¡Å pl}. among those answers  let us note that some of them  e.g.  h ¡Å y  involve target variables from different peers. such implicates cannot be obtained by partition-based algorithms like in  amir and mcilraith  1  which only compute consequents that belong to the target language of a single peer.
1 distributed consequence finding algorithm
our distributed and anytime consequence finding algorithm is has been presented in  adjiman et al.  1b . for this paper to be self-contained  we describe the three main message passing procedures  which are implemented locally at each peer. they are triggered by the reception of a query  resp. answer  final  message  sent by a sender peer to a receiver peer  denoted by self  which executes the procedure.
¡¡those procedures handle an history which is initialized to the empty sequence. an history hist is a sequence of triples  l p c   where l is a literal  p a peer  and c a clause . an history   ln pn cn  ...   l1 p1 c1   l1 p1 c1   represents a branch of reasoning initiated by the propagation of the literal l1 within the peer p1  and the splitting of the clause c1: for every i ¡Ê  1..n   1   ci is a consequence of li and pi  and li+1 is a literal of ci  which is propagated in pi+1.
¡¡the reasoning is initiated by the user  denoted by a particular peer user  sending to a given peer p a message m user p  query   q   which triggers the procedure receivequerymessage m user p query   q   that is locally executed by p. in the description of the procedures  we will use the notations:
¡¡  for a literal q  q¡¥ denotes its complementary literal and resolvent q p  denotes the set of clauses obtained by resolution between q and a clause of p 
¡¡  for a clause c of a peer p  s c   resp. l c   denotes the disjonction of literals of c whose variables are shared  resp. not shared  with any acquaintance of p. s c  = 1 thus expresses that c does not contain any shared variable 
¡¡    is the distribution operator on sets of clauses: s1   ¡¤¡¤¡¤   sn = {c1 ¡Å ¡¤¡¤¡¤ ¡Å cn |c1 ¡Ê s1 ... cn ¡Ê sn}. if l =
{l1 ... lp}  we use  l¡Êlsl to denote sl1   ¡¤¡¤¡¤   slp.
¡¡the main properties of the resulting distributed message passing algorithm  stated in  adjiman et al.  1a   can be summarized as follows:
¡¡1  the algorithm is sound: the answers that are returned are all implicates of the literal having triggered the reasoning.
¡¡1  the algorithm terminates and the user is notified of the termination  which is crucial for an anytime algorithm.
¡¡1  the completeness of the algorithm is guaranteed if each local theory is saturated by resolution and if the acquaintance graph is such that if two local theories have a common variable  there exists in the acquaintance graph a path between those two theories  all the edges of which are labeled with that variable. if that property is not satisfied  the algorithm still applies but does not guarantee to return all the proper prime implicates when it terminates.
¡¡note that 1 can be returned by our algorithm  lines 1 to 1 and 1 to 1 in receivequerymessage . therefore  our algorithm can be exploited for checking the satisfiability of the global theory at each join of a new peer. for the sake of simplicity  our algorithm is presented as applying to literals. however any clause can be handled by splitting it into literals and recombining the results obtained for each literal using the   operator.
1 experimental analysis
in order to study scalability issues of our p1p algorithm we have conducted a significant experimentation on networks composed of 1 peers. to the best of our knowledge  this is the first experimental study on such large p1pis. our motivation was twofold. first  to study how deep and how wide reasoning spreads on the network. second  to evaluate the time needed to obtain answers and to check to what extent the p1pis is able to support the traffic load.
¡¡since we want to use our infrastructure in real web applications  we have chosen to generate acquaintance graphs having the so-called small world property  which is admitted  newman  1  as being a general property of social networks  including the web . following  watts and strogatz  1   we start from a regular ring of 1 nodes  1 edges algorithm1: procedure handling queries. it takes care of the propagation of the literal q by self.
receivequerymessage m sender self query hist q  
 1  if  ¡¥q      ¡Ê hist
 1  send m self sender answer   q self 1 |hist  1 
 1  send m self sender final   q self true |hist  true 
 1 else if q ¡Ê self or  q self    ¡Ê hist
 1 	send m self sender final   q self true |hist  true 
 1 else
 1  local self  ¡û {q} ¡È resolvent q self 
 1  if 1 ¡Ê local self 
 1  send m self sender answer   q self 1 |hist  1 
 1  sendm self sender final   q self true |hist  true 
 1  else
 1  local self 	¡û	{c	¡Ê	local self | l c  ¡Ê
t arget self }
 1  if for every c ¡Ê local self  s c  = 1
 1  foreach c ¡Ê local self 
 1  sendm self sender answer   q self c |hist  c 
 1  sendm self sender final   q self true |hist  true 
 1  else
 1  foreach c ¡Ê local self 
 1  if s c  = 1
 1  sendm self sender answer   q self c |hist  c 
 1  else
 1  foreach literal l ¡Ê s c 
 1  if l ¡Ê t arget self 
 1  answer l   q self c |hist   ¡û {l}
 1  else
 1  answer l   q self c |hist   ¡û  
 1  final l   q self c |hist   ¡û false
 1  foreach rp ¡Ê acq l self 
 1  sendm self rp query   q self c |hist  l 
algorithm 1: procedure handling answers. r is returned as a consequent of the last literal added to the history hist.
receiveanswermessage m sender self answer hist r  
 1 hist is of the form	 
 1 answer l  hist  ¡û answer  l  hist  ¡È {r}
 1 result¡û  l¡Ês c  {l¡ä}answer l hist    {l c  ¡Å r}
 1 if hist¡ä =    u¡ûuser else u¡û the first peer p¡ä of hist¡ä
 1 foreach cs ¡Ê result
 1 	send m self u answer   q self c |hist¡ä  cs 
algorithm 1: procedure handling notifications: answer computation for the last literal added to hist is completed.
receivefinalmessage m sender self final hist true  
 1 hist is of the form   l¡ä sender true   q self c |hist¡ä 
 1 final l¡ä hist  ¡û true
 1 if for every l ¡Ê s c   final l hist  = true
 1  if hist¡ä =   u¡ûuser else u¡û the first peer p¡ä of hist¡ä
 1  send m self u final   q self true |hist¡ä  true   1  foreach l ¡Ê s c 
 1 	answer l   l sender     q self c |hist¡ä   ¡û  
per node  and rewire each node with a given probability pr. it has been shown that between regular graphs  pr = 1  and uniform random graphs  pr = 1   the graphs generated with pr = 1 have  small world  properties.
¡¡in the following experiments  the number q of shared variables labelling each edge varies  and each of the 1 local theories is a 1+p clausal theory composed of clauses of length 1 and a varying ratio p of clauses of length 1. each local theory is generated in two steps. first  1 clauses of length 1 are uniformly generated over 1 variables that are proper to the local theory  among which 1 are chosen as target variables. then  we add clauses  involving shared variables  of length 1 or 1. we denote %1cnf the percentage of clauses of length 1 to generate in the whole set of mapping clauses. each mapping clause is randomly generated by picking a variable in each of the two peers and by negating it with probabilty 1
¡¡ if the clause is of length 1  the third variable is chosen at random between the variables of the two peers .
¡¡the experiments have been conducted on two different platforms. for the measurements concerning the behavior of query processing  number of messages  depth and width of each query processing  we have used a single computer running 1 peers. such measurements  consisting in building reports on all peer traces are easier to perform when all data are available on a single computer. in contrast  when time was part of the measurement  we deployed our algorithm on a cluster of 1 heterogenous computers  athlons with 1gb of ram: 1 at 1ghz  1 at 1ghz and 1 at 1 ghz . in these last experiments  each computer was running around 1 peers  randomly selected.
¡¡as we will see  results often exhibit an exponential distribution: some queries may need a very long time to complete. it was thus not always possible to perform our experimental analysis without introducing a timeout parameter. each query is labeled with its remaining time to live  which is decreased each time a query needs to traverse a peer to be processed. when necessary  the timeout has been set to 1 seconds.
¡¡we first report on the distributed behavior of query processing by measuring the number of peers that are involved in query processing. then  we report on the time of query processing and on the number of answers.
1 distributed behavior of query processing
we have measured the distribution of the depth of query processing as well as the potential width of a query. the depth of a query is the maximum length of the reasoning branches developed by the distributed algorithm for returning an answer. the width of the query estimates the number of neighbors that are solicited  on average  for processing a query.
¡¡figure 1 shows the cumulative distribution function of the depth of 1 queries  when we make vary the number q of shared variables per edge and the ratio %1cnf of mapping clauses of length 1. each point on the figure reports a run  for a distinct query.
¡¡the four top curves show a relatively small query depth. for instance  with q = 1 and %1cnf = 1 no query depth is greater than 1  and none of those four curves have a query depth greater than 1  which suggests that our algorithm behaves well on such networks.
¡¡as soon as the value of %1cnf increases queries have longer depths: with q = 1 and %1cnf = 1  1% of the queries have a depth greater than 1  the maximum being 1 . if we focus on the last three curves on the right  a sharp threshold clearly appears  showing three phases: a sharp growth  representing query processing with small depth  followed by a plateau  and then a slower growth. the small depth query processing and the 'plateau' are characteristics of an exponential distribution of values: most of the process-
cdf of queries's depth

figure 1: cumulative distribution function of queries depth. the y scale is re-centered on  1   1 .
ing is easy  but the little remaining is very hard. the slow growth observed is due to the timeout  a side-effect of which is to bound the query depth. without such a timeout  previous experiments suggest that there would exist some queries requiring very long reasoning branches. this point is outlined on the curve corresponding to the hardest cases  q = 1 and %1cnf = 1  where there is no query of depth between 1 and 1. this suggests that when hard processing appears  it is very hard. in experiments that are not reported here  we have seen that such an exponential distribution of values was not observed when the acquaintance graphs have a regular ring structure  but was observed on random graphs. we have also measured the integration degree of queries  which is the number of distinct peers involved in the query processing. we have observed the same kind of exponential distribution of values than for the depth  but with 1% smaller values: 1 of the peers are repeated in the histories. that phenomenon was not observed on random acquaintance graphs and seems closely related to the small-world topology.
¡¡figure 1 shows the cumulative distribution function for the width of the queries. each curve summarizes 1 runs. with q = 1 and %1cnf = 1  more than 1% of the queries are solved locally and 1% otherare solved by asking just one neighbor. with q = 1 and %1cnf = 1  1% of the queries solicit 1 neighbors on average  each of them soliciting 1 peers  with 1% chance and so on. such result explains the combinatorial explosion observed on hard instances.
¡¡our experiments have pointed out a direct impact of the %1cnf value on query processing  which is not surprising considering the hardness of clauses of length 1 for prime implicate computation. those experiments also suggest an exponential distribution of query depths  due to the short path length between two peers in the acquaintance graphs  and with an importantrepetitionof solicited peers  dueto the large clustering coefficient of small world acquaintance graphs.
1 time and number of answers
we now report a time performance study of our algorithm when it is deployed on a real cluster of 1 heterogeneous
cdf of queries's width

figure 1: cumulative distribution function of queries width the y scale is re-centered on  1 1   the x axis on  1 .
computers. based on the previous observations  we have chosen to focus on 1 differents kinds of acquaintance graphs  denoted easy  medium  hard and very hard  see table 1 .
network
mediumvery hardq =1q =1%1cnf =1%1cnf =1%1cnf =1stans.1s  1% 1s  1% 1s  1% 1s  1% 1thans.1s  1% 1s  1% 1s  1% 1s  1% 1thans.-1s  1% 1s  1% 1s  1% 1thans.-1s  1% 1s  1% 1s  1% all1s1s1s1s% timeout1.1.1.1#answers 1 1 1 %unsat 1 1 1 1
table 1: characteristics of the query processing on easy to very hard networks.
¡¡the values reported in the table 1 are mean values over more than 1 different queries. for each column  we show the time needed to produce the 1st  1th  1th and 1th answers of a query. each mean time is followed by the percentage of initial queries that are taken into account in the averaging. for instance  for the medium case  1% of the queries have produced more than 1 answers  and the 1th answer was given on average after 1 seconds  the average does not take into account queries that did not produce at least 1 answers . the all row is the mean time needed to produce all answers  including queries that lead to timeout  the percentage of which is reported in the %timeout row. the last two rows report the mean numberof answers and the ratio of proven unsatisfiable queries w.r.t. the network.
¡¡it is not surprising to find that there is no timeout for the easy case. it is known  marquis  1  that satisfiability checking and prime implicates computation are tractable for sets of clauses of length 1. moreover  the high partitioning of the global theory induced by the low value of q  number of shared variables  is often a witness of  easy  cases for reasoning for centralized theories. the point to outline for this case is that there are on average 1 answers  and they are produced very quickly.
¡¡even on hard and very hard instances  our algorithm produces a lot of answers coming from a number of different peers. for instance  we measured on average 1 answers for hard  and 1 answers for very hard problems  which already represents a large amount of data. in addition  on those very hard instances  1% of runs produced at least one answer. it is noticeable that such hard instance may also be hard for checking the satisfiability of an equivalent  centralized  theory. the formula corresponding to the centralized version of all the distributed theories has n=1 variables and m=1 clauses 1 of which are of length 1. it has been shown in  monasson et al.  1  that  for such 1+p formulas  if one does not restrict the locality of variables  the sat/unsat transition is continuous for p   p1  where p1 = 1  and discontinuous for p   p1  like in 1-sat instances. intuitively  for p   p1  the random 1+p-sat problem shares the characteristics of the random 1-sat problems. let us emphasize here that  with the characteristics of our very hard network  we have p = 1 for which the transition phase between sat and unsat instance  monasson et al.  1  occurs at m/n=1. here  we have m/n=1  which is near the transition phase to confirm that this is where the hard instances would be in practice. of course  such a comparison is only indicative  because there is no variable locality restriction in the standard 1+p model.
¡¡to summarize  when deployed on a real cluster of heterogeneous computers  our algorithm scales very well. even on very hard instances that shares characteristics of a very large 1+p formula at the crossover between the 1-sat/1-sat and the sat/unsat transitions  our algorithm was able to generate a large number of answers in a reasonable time  for a majority of runs.
1 related work
the distributed message passing algorithm that we have described in section 1 can be viewed as a distributed version of an ordered linear deduction  chang and lee  1  to produce new target clauses  which was extended by  siegel  1  in order to produce all implicates of a given clause belonging to some target language  and further extended to the first order case in  inoue  1 . the problem of computing new derived clauses  a.k.a. hl ¦µi-prime implicates  corresponds exactly to the problem of computing proper prime implicates w.r.t. a theory. it has been extensively studied in the centralized case  see  marquis  1  for a survey .
¡¡we have already pointed out the differences between our work and  amir and mcilraith  1 . first  in a full peerto-peer setting  tree decomposition of the acquaintance graph is not possible. second  in contrast with partition-based algorithms as in  amir and mcilraith  1   our algorithm is able to combine answers from different peers in order to compute implicates involving target variables of different peers.
¡¡the model-based diagnosis algorithm for distributed embedded systems  provan  1  exploits the knowledge on the distribution of the system to diagnose for optimization purpose. in distributed atms  mason and johnson  1   agents exchange nogood sets in order to converge to a globally consistent set of justifications. such a distributed vision of atms relies on a global knowledge shared by all the agents and aims at getting a unique global solution. we think that our peer-to-peerinference system can be applied for handling fully distributed model-based diagnosis and fully distributed atms  in which no global knowledge is required.
¡¡some recent work deals with distributed first order logic. a model-based and a proof-theoretic semantics has been defined in  ghidini and serafini  1  for a collection of first ordertheories communicatingthroughbridgerules that define semantic mappingsbetween their respective domains of interpretation. based on that work  distributed description logics has been introduced in  borgida and serafini  1  and a distributed tableau method has been proposed for satisfiability checking.
1 conclusion
we have presented a peer-to-peer inference system based on propositional logic and we have shown that it scales up to a thousand of peers. the peer-to-peer infrastructure that we have developed is used in a joint project with france te¡äle¡äcom  aiming at enriching web applications with semantics and reasoning services.
¡¡so far  we have restricted our algorithm to deal with a vocabulary-basedtarget language. however it can be adapted to more sophisticated target languages  implicates of a given language  e.g.  based on literals and not only variables  of bounded size ... . this can be done by adding a simple tag over all messages to encode the desired target language.
¡¡we plan to extend our current work in two main directions. first  we want to tackle semantic web applications  in which the bottleneck is to deal with distributed resources shared at large scale. rdf s   see  antoniou and van harmelen  1   is a standard for annotating web resources  which we think can be encoded in our propositonal setting. second  we want to handle more sophisticated reasoning in order to deal with a real multi-agent setting  in which possible inconsistencies between agents must be handled.
