 
this paper describes a technique for executing logic programming languages such as prolog for the cray-type vector processors. this technique  which we call the parallel backtracking technique  enables a kind of or-parallel execution without process explosion. the compiled intermediate language code for the parallel backtracking execution is the same as the code presented in our previous paper. the compilation is based on a kind of program transformation called or-vectorization. however  the interpretation of the intermediate code is changed to enable the parallel backtracking execution. an execution simulator and a compiler prototype were developed. we have not yet implemented this technique to our native code execution system  but we expect a performance of eight times or more higher than scalar processing upon implementation. 
1 	introduction 
we  kan 1a  developed vectorization techniques which enables execution of logic programming languages such as prolog on pipelined vector processors such as the hitachi s-1  nag 1  or the cray-1. using these techniques  a prolog program is transformed into vectorized program in an intermediate logic programming language; then this program is compiled into procedural programs. the former is called the vectorization phase  and the latter the code generation phase. a type of orparallelization  which is done in the vectorization phase  enables prolog programmers to use operation pipelines and storage-access pipelines of vector processors  which leads to the expectation of high performance. we compiled a program of the eight-queens problem by hand using these techniques  and achived a high performance of 1 mlips on the s-1. 
　the major drawback of the method described above is that it does not avoid process explosion. in a parallel processing of highly or-parallel program by a naive 
   *the author's current address is center for machine translation  carnegie-mellon university  1 forbes avenue  pittsburgh  pa 1  usa. the e-mail address is yk a. nl.cs.cmu.edu. 
method  the number of processes may be increased explosively and the computation may become unable to continue due to resource exhaustion. this situation is called process explosion. though the eight -queens problem can be solved using the above method because the number of processes remains within range of computational powers  the twelve-queens problem might fail to solve. 
　this paper describes an execution technique for the vectorized program without explosion. section 1 overviews the compilation and execution method for vector processors. section 1 overviews the parallel backtracking technique  kan 1b   which is a technique for avoiding explosion of vector length in combinatorial search. section 1 describes the technique for avoiding process explosion in vector processing of prolog. this technique is an extension of the parallel backtracking technique. section 1 draws conclusions about out methods. 
　other works on vectorizing logic programming languages  nil 1   nil 1   tat 1  are in the works. there are two major differences between their approaches and ours. one is the difference of the source languages. we use prolog  in a wide sense   which has and-parallelism and global or-parallelism. they use ghc  ued 1   which has and-parallelism and only local or-parallelism. the other is the difference in processing structure. our method is based on compile-time program transformation. their method is based mainly on interpreters. 
1 	an overview of prolog vectorization 
there are two kind of concurrent processings. one is vector or pipelined processing and the other is parallel processing. if a computation is fitted well in vector processing  the hardware is very efficiently used. however  vector processing  which is a kind of simd-type parallel processing  is more inflexible than mimd-type parallel processing. only the same kind of operations can be performed by an instruction. so  not all the programs can be fitted well in vector processing  and a compiletime program transformation is necessary to do so. this transformation is called vectorization. 
　to execute a prolog program on vector processors  a method of program transformation to fit it in vector processors must be used. or-vectorization  kan 1a   a type of program transformation  enables a type of or-parallel 
	kanada and sugaya 	1 


1 	parallel and distributed processing 

　the details of the transformation techniques and examples are described in the previous paper  kan 1a . 
　during execution of deterministic procedures  procedures which have one or no solution  the vector length  or the number of elements in each vector  is constant. some goals may fail  and the number of the valid elements decreases. however  vectors with dead elements can be processed with masked operation facility or list vector facility of vector processors  kan 1a . so the number of the elements can be constant in the or-vectorized program. 
　on the contrary  the vector length varies during the execution of nondeterministic procedures. more than one solutions are generated from each vector element  and the solutions  the values of each variable  should be accumulated into a vector to lengthen the vector length. the reason why they should be done so is as follows. 
vector processors are slower than scalar processors when they are used with single-element vectors only. high performance is achieved when using them with vectors of sufficient length  namely one hundred or more elements. in most programs with or-parallelism  there is only one process initially. so  if the solutions are not the intermediate code of select is very similar to that of nondeterministic procedure append  which is described in the previous paper  kan 1a . so only a brief explanation about the vectorized code of select is presented here. figure 1 shows the intermediate code of vjselect  and figure 1 outlines the execution of the following vectorized goal: 

　in the source program  select inputs a list and selects one of the elements and returns it and the list of the rest elements. so  question  - select   a b   x1  r1  returns the following two solutions: 

question  - select    x1 r1  returns the following one solution: 

　procedure v.select is the vectorized counterpart of procedure select. the first argument of vjselect is the input. in the above vectorized goal  the first argument 
	kanada and sugaya 	1 

is a vector of two elements   a b  and . so this goal is the vectorized counterpart of the above two questions. 
　the body of procedure v select consists of three parts. the first part corresponds to the first clause of procedure select  and the second part corresponds to the second clause. the third part has no counterpart in the source program. 
　the first part computes the two solutions  and returns the vectors with these solutions. the second part computes the rest solution  calling v .select recursively  and returns the vectors of the solutions. the live-ness of the vectors is displayed by a mask vector  kan 1a   ml. both elements of ml are true  that means all the elements of the vectors are live  solutions. the second part returns vectors of two elements  but the second elements are killed or invalidated. the live-ness of the vectors is displayed by mask vector m1. 
　the third part  procedure vjnerge  inputs the outputs of the previous parts  merges them  and outputs two vectors which contain all of the solutions. the result of the whole computation is as follows: 

the length of all the vectors before vjnerge are the same  two. the vector length is changed only by vjnerge and the lengths of all the vectors outputted by v merge are the same  three. 

figure 1: vector length explosion in a combinatorial search by vector processors 

1 	the parallel backtracking technique 
the parallel backtracking technique avoids explosion of vector length in parallel processing of combinatorial search programs  kan 1b . it was a technique for vectorizing procedural backtracking programs  though it was expected to be applied for vectorizing prolog programs  kan 1 . 
　figure 1 explains a problem of simple vector processing of search problems. in a vector processing of search problems such as the eight-queens by vector processors  the vector length increases because the number of possible solutions  each of which is an element of the vector  explosively increases during processing. the vector elements may overflow from the main storage or the disks  then the computation fails to continue. 
　figure 1 explains the solution for the problem given in kanada  kan 1b . the vector is split into two or more small vectors when the vector length becomes too large  step 1 and 1' . then the computation is continued only for one of the vectors  v1  and the others are saved as choice points. when the computation for the first vector finishes  step k   the control returns to one of the choice points and the same computation as for the first vector  v1  is performed for the second vector  v1 . all the split vectors are processed in the same way. in the case of figure 1  v1 is the final vector. the vector splitting may be done more than once  as shown in figure 1  step k+1 and k+1' . 
　whole computation is done in or-parallel in the process shown in figure 1. on the other hand  some  backtrackings  occur in the process shown in figure 1  which 
1 	parallel and distributed processing 
figure 1: a combinatorial search using parallel backtracking technique 
is the reason why this technique is called the  parallel backtracking technique.  
1 	explosion-free execution of prolog 
the explosive increase of vector elements is very close to the process explosion in or-parallel processing of prolog. if the parallel backtracking technique described in the last section is slightly modified  it is applicable to the vectorized execution of prolog  thereby avoiding a process explosion without the expense of efficiency. this section explains the method of applying the parallel backtracking technique to prolog. 
　first  the program points  where the vectors should be split and choice points are made  must be decided to apply this technique. vectors are split only in vjnerge  and choice points are made only in vjnerge in our parallel backtracking execution. because the vector length is increased in the execution of procedure vjnerge of the intermediate language  and it is kept constant in other execution steps in the execution method shown in our previous paper  kan 1a . procedure v merge outputs the input vectors as they stand if the vector lengths are sufficient  or merges them if not sufficient. this merge may be a partial merge  i.e. merging some of the vectors but not all. 
   figure 1 shows an execution example of vjnerge under its parallel backtracking interpretation. procedure vjnerge inputs three vectors to merge  a1 a1 and a  outputs two vectors  a1 and a'1  and an input mask vector which is not shown in figure 1. the input vectors of vjnerge are formed into list of vectors  so vjnerge actually inputs one list of vectors and outputs one vector. the first and the second input vectors are merged and the resulting vector is outputted  and the third one is outputted as it stands. this means vjnerge does a partial merge here. a dead element in a1  which is displayed by the input vector  is not included in a1. 
when vjnerge is called  it succeeds and outputs the first result  a1  and it makes a choice point for a'1. when a backtracking to the choice point in vjnerge occurs  vjnerge outputs the second result  af1. since the intermediate language is prolog-like  backtrackings are handled appropreately. a more backtracking to v merge just causes a failure because there is no more choice point  and it causes a further backtracking. 
　this functional change of v merge can be done without syntactic changes of the intermediate code. only the interpretation of the intermediate code is changed. no global choice points are created in the interpretation given in our previous paper  but choice points are created and global backtrackings to them are occurred in the new interpretation. so the intermediate language may have been a procedural one in the previous paper  but it must be a prolog-like language with automatic backtracking for applying the parallel backtracking technique. 
　there are two methods for merging and splitting vectors. one is to merge first then to split  and the other is to merge only when vector length is short. the former method merges all the input vectors first and then splits them appropriately. the good point of this method is that vector length can be chosen arbitrary. however  this method is inefficient because both merging and splitting require the copying of vectors. the latter method merges vectors only when they are too short and it does not actually split vectors. the latter method is probably better because it require less copying of vectors. in the latter method  it is probably good to merge the input vectors one by one until the vector length becomes sufficient for achieving high performance by vector processors. 
　we have developed a simulator for vectorized execution  and a compiler which inputs a prolog program with mode declarations and generates vectorized intermediate language program. both programs are written in prolog. the structure of this system is outlined in figure 1. this intermediate language  il  is a prolog-like language with vectors. its syntax is the same as the il in our previous paper. the simulator inputs the il  and computes the solutions using vectors  which are simu-
	kanada and sugaya 	1 
lated by functor #       a functor whose name is  #   in prolog. a functor is good for simulating vectors because elements of a functor can be accessed by indices using built-in predicate arg in prolog  and vector elements are immutable  unassignable  in our model. each build-in procedure in the intemediate language  such as v merge  is simulated by a prolog procedure. so the intermediate code is executed directly by the simulator. 
　though the computation is performed in pseudoparallel  the simulator decomposes resulting vectors and returns the solutions one by one to the user. so  the user interface is very similar to prolog's  though the order of solutions may be different from sequential prolog's. for example  we assume that the user types a question and the first vector of solusions of the program  s1  contains two solutions  s1 and s1. it will take a little time until s1 is printed  because it requires to compute the value of s1 and to extract s1 from s1. however  if the user types   '' or requires a backtracking  s1 will be printed immediately because it only requires to extract it from s1. if the user requires a more solution  the user may have to wait a little because it requires to compute the second vector of solutions  s1. 
　though prolog is used  most part of the simulator program is deterministic; no choice points are made in most part. however  there are two procedures where global backtracking is used. one is procedure v merge  and the other is the procedure which decomposes vectors for the user. 
1 	conclusion 
this paper has shown a technique for executing prolog programs on vector processors without process explosion. this technique is called the parallel backtracking technique. we developed a execution simulator using this technique  which inputs intermediate code generated by a vectorizing compiler described in our previous paper  kan 1a . 
   we have not yet developed a real execution system. however  using this technique  we can certainly make a prolog system whose performance ranks more than eight times higher than the mainframe machine in solving the eight-queens program. because the non-backtracking execution of this program achieves a high performance of nine times higher than scalar processing  and backtrackings does not take much time in the parallel backtracking execution. 
acknowledgement 
the authors wish to thank dr. sakae takahashi and seiichi yoshizumi of hitachi ltd. for their continuing support of our research. 
