 
       we present a model for processing english requests for i n f o r m a t i o n from a r e l a t i o n a l data base. the model has as i t s main steps  a  l o c a t i n g semantie c o n s t i t u e n t s of a request;  b  matching these c o n s t i t u e n t s against larger templates c a l l e d concept case frames;  c  f i l l i n g in the concept case frame using information from the user's request  from the dialogue context and from the u s e r ' s responses to questions posed by the system; and  d  generating a formal data base query using the c o l l e c t e d i n f o r m a t i o n . methods are suggested for c o n s t r u c t i n g the components of such a n a t u r a l language processing system for an a r b i t r a r y r e l a t i o n a l data base. the model has been applied to a large data base of a i r c r a f t f l i g h t and maintenance data to generate a system c a l l e d planes; examples are drawn from t h i s system. 
	1. 	introduct ion 
       the language processing model for the planes system for n a t u r a l language access to a large data base  1-1  has evolved over the past two years to a point where we f e e l that it is now p r a c t i c a l to begin c o n s t r u c t i n g such systems for other data bases. key ideas and assumptions in the model are described below. 
       the model is designed to handle requests by r e a l   casual users  whose only programming l a n guage is e n g l i s h   but who have some knowledge of the m a t e r i a l in the data base.t we have assumed that users w i l l ask questions which are often ungrammatical  which include many a b b r e v i a t i o n s   both standard and non-standard  and which use e l l i p s i s  omission of information to be understood in context  and pronouns e x t e n s i v e l y .  see malhotra  for ideas about the types of things users are l i k e l y to type i n .   
       the model is designed to work w i t h a r e l a t i o n a l model | 1   1     data is viewed as being divided i n t o r e l a t i o n s which correspond t o f i l e s or sets of f i l e s in conventional data base t e r minology. each r e l a t i o n contains a c o l l e c t i o n of tuples which correspond to records; each tuple contains one or more domains or f i e l d s . a r e l a t i o n can conveniently be thought of as a t a b l e   
*thc research described in t h i s paper was supported by the office of naval research under contract number n1-c-1. 
t i n the planes systems  we have provided e a s i l y accessible help f i l e s to b r i n g a user without data base knowledge to a point where he can use the r e s t of the system. 
w i t h each row being a tuple and each column a domain. there are two important reasons for using the r e l a t i o n a l approach: 
 1  the r e l a t i o n a l approach stresses data independence. this means that the user and f r o n t end programs are e f f e c t i v e l y i s o l a t e d from the a c t u a l data base o r g a n i z a t i o n . we are now working w i t h only a small subset  approximately 1  b i t s   of a much larger database  approximately 1 b i t s   ; if we were to use our f r o n t end w i t h the entire-
data base  the data accessing programs would have to be m o d i f i e d   h u t   using the r e l a t i o n a l model  changes need not a f f e c t the  data model  seen by users and the n a t u r a l language f r o n t end. 
 1  many data bases arc already i n t e r n a l l y organized in a tabular form  and are thus n a t u r a l l y suited to a r e l a t i o n a l data model. we are not in t h i s paper concerned w i t h updating and normalizat i o n aspects of the r e l a t i o n a l data bases. 
       most of the examples given in t h i s paper are drawn from the world of the planes system  1 1 j . planes is a working system which operates on a data base supplied by 1-m  maintenance and m a t e r i a l management   mechanicsburg  pa. the data base is comprised of d e t a i l e d f l i g h t and maintenance data  plus data summaries  and is organized by month  a i r c r a f t   and type of data  scheduled maintenance  unscheduled maintenance  f l i g h t s   e t c .   . 
	1. 	key ideas 
       probably the most important c o n t r i b u t i o n s of our work are the o v e r a l l o r g a n i z a t i o n of the model  and ideas on how to generate each component of the model for a novel data base. we have attempted in our work to a t t a c k on a broad f r o n t and i n t e g r a t e s o l u t i o n s to many p r a c t i c a l problems i n c l u d i n g 
       operating speed  dialogue and paraphrase generat i o n   s p e l l i n g c o r r e c t i o n and e r r o r recovery  browsing and answering of vague questions  answer g e n e r a t i o n   automatic help f i l e s   e t c . 
1 	central assumption 
       the c e n t r a l novel assumption underlying the model is that a data base request is uniquely determined by the set of semantic c o n s t i t u e n t s in a clause  independent of the order of the cons t i t u e n t s . # we need only s u f f i c i e n t grammatical correctness to recognize the phrase boundaries of semantic c o n s t i t u e n t s and clause boundaries 
  i f any . 	thus the modei handles grammatical 
e n g l i s h   	  p i d g i n e n g l i s h     o r ungrammatical 	l i s t s 
# there are important exceptions  for example comp a r a t i v e constructions such as   . . . d i d plane 1 have more f l i g h t s than plane 1... where the order of  plane 1  and  plane 1  in the sentence is important. 

natural 	language-1; waltz 

of semantic c o n s t i t u e n t s w i t h equal ease. to our knowledge the use of a method such as t h i s for data queries i s o r i g i n a l w i t h t h i s p r o j e c t . 
       given our c e n t r a l assumption  the processing of a u s e r ' s query involves p r i m a r i l y i d e n t i f y i n g a l l the semantic c o n s t i t u e n t s   e . g .  for our data base  time p e r i o d   plane type  s e r i a l numbers  maintenance types  e t c . each of these semantic c o n s t i t u e n t s can be a variable;   i . e . the name of a f i e l d for which the system is to f i n d values   or a constant   i . e . a value for a p a r t i c u l a r f i e l d which a data item must s a t i s f y     or a set of constants   i . e . a set of values or range of v a l u e s   . thus  in  which planes had engine maintenance in may 1   planes is a v a r i a b l e and eng ine ma i n t enanc e and may 1 are constants. an operation on a 
       v a r i a b l e   e . g .  sum of f l i g h t hours   functions as a constant. the i d e n t i f i c a t i o n of semantic cons t i t u e n t s is handled by a group of atn subnets  each of which is an   e x p e r t   on recognizing dif-ferent ways of expressing one type of semanticc o n s t i t u e n t ; thus  there are subnet experts for time p e r i o d   planetype  e t c . 
1 	concept case frames and context regi sters 
       a second major set of ideas is necessary to handle the f o l l o w i n g problem: o f t e n a u s e r ' s r e quest w i l l omit information necessary to form an adequate query. this can happen because!  a  a user leaves out information meant to be understood in context   t h i s is c a l l e d e l l i p s i s      b  a user uses a pronoun in place of a named c o n s t i t u e n t   or  c  a user simply neglects to include a l l the' necessary i n f o r m a t i o n . to handle these s i t u a t i o n s 
we- use context r e g i s t e r s together w i t h concept case frames. context r e g i s t e r s are h i s t o r y keepers; they store a l l semantic c o n s t i t u e n t s of requests along with answers to e a r l i e r questions and other informat i on. 
¡¡¡¡¡¡each concept case frame is a template r e p r e senting a whole series of questions about the data 
base. the templates are used as t o o l s to   b u i l d   a legal query by f i l l i n g in the mandatory   s l o t s   of the template w i t h i n f o r m a t i o n extracted from the current request  e a r l i e r requests  world knowledge or d e f a u l t values. if the set eif semantic 
c o n s t i t u e n t s found in a user's request does not match a concept case frame e x a c t l y   we can look back through past context r e g i s t e r values to f i l l in missing elements  as w i t h e l l i p s i s and pronoun r e f e r e n c e     ask the user to pick the appropriate meaning if there is more than one possible way of f i l l i n g in the concept case frame  or note that a j o i n  combining of more than one r e l a t i o n   is necessary if there are. elements l e f t over a f t e r matching any single concept case frame. certain concept case frames also correspond to requests for help f i l e s   or note that d e c l a r a t i v e i n f o r -
mation is being input   e . g .  from now on consider only plane 1 .       or note that the request requires special processing  as in the case of a vague question or one r e q u i r i n g a l e r t i n g f u n c t i o n s . a good way to begin enumerating concept case frames is to look at the domains   f i e l d names  for each r e l a t i o n . 
1 . 1 query ge ne r a t or 
       the t h i r d important set of ideas is concerned with query generation. the system can generate a formal data base query from the set of semantic c on s t i t ue n t s whether or not a concept case frame was matched. 
       the f i r s t step is to decide what to r e t u r n as an answer  	and to specify what patterns   h i t s   must s a t i s f y . 	to do t h i s   the query generator f i r s t notes which c o n s t i t u e n t s are constants or sets of constants and which are v a r i a b l e s 	 see above . 	often there w i l l be only one v a r i a b l e   denoted by a question word 	  e . g . which  when  where  	e t c .   ; a l l v a r i a b l e s and sets of const ants must be part of the answer r e t u r n e d . 	the constants and sets of constants are treated as p r e d i c a t e s   
i . e . as f i e l d values against which i n d i v i d u a l data items or   t u p l e s   must be cemipared to f i n d which are   h i t s   . 
       the second step is to decide which r e l a t i o n s to search. there are about 1 r e l a t i o n s in our data base  each corresponding to one month's det a i l e d data of a p a r t i c u l a r type   e . g . f l i g h t -
hours  for one p a r t i c u l a r plane  or to summary data for planes of one class for various p e r i o d s   and so on. there are also temporary re1ations 
which are created as a dialogue progresses  and the system must be able to determine when these are being r e f e r r e d to 	 as in  of these  	. . .   and other folleow up q u e s t i o n s   . 	because there is both summary and d e t a i l e d d a t a   and several types of data for each plane  	the  decision of the query generator requires some processing. 	the1 query generator i n t e r s e c t s the 	sets of r e l a t i o n s r e ferred to by each semantic c o n s t i t u e n t   	in the 
hope that only a single r e l a t i o n w i l l remain. if no r e l a t i o n s remain  then a j o i n  or j o i n s   is required and a d d i t i o n a l processing is necessary; if more than one r e l a t i o n remains  then h e u r i s t i c s can often help select one   e . g . use summary data rather than d e t a i l e d data i f e i t h e r i s possible  or the user can be offered a choice among the a l t e r n a t i v e s . 
       as i t s t h i r d s t e p   the query generator must decide on how to sort the h i t s when r e t r i e v e d . sometimes s o r t i n g is s p e c i f i e d in queries   e . g .  give me' t o t a l maintenance hours for plane 1 by month   ; otherwise it is determined by a h e u r i s t i c 
p r i o r i t y 	scheme. 
	1 . 	model operation 
       the processing of a user's request is divided i n t o four main phases: p a r s i n g   i n t e r p r e t a t i o n   e v a l u a t i o n   and response. 
        1  in the parsing phase  a set of semantic features w i t h values is formed from the u s e r ' s request. as part of t h i s phase pronoun reference and e l l i p s i s are resolved  and complex questions are broken up i n t o a sequence of simple queries. 
        1  in the i n t e r p r e t a t i o n phase  the feature and value representation of the user's request is t r a n s l a t e d i n t o a 'program ' c a l l e d a  data base query   to generate the data to answer the r e quest. 

natural 	lanr;uaf:e-1: 	waltz 1 

¡¡¡¡¡¡the bulk of t h i s paper is devoted to e x p l a i n ing these f i r s t two phases of the model's operat i o n . 
        1  the e v a l u a t i o n phase uses the query generated in the previous stage to search the data base and r e t u r n the needed data. 
        1  the evaluation p o r t i o n passes the. r e s u l t i n g data to the response generator. 
       at each stage of the process  the r e s u l t s are sent to context r e g i s t e r s   which consist of a set of stacks of relevant i n f o r m a t i o n . these stacks contain the r e s u l t s of each stage   e . g . u s e r ' s request  paraphrase  e t c .     s y n t a c t i c components   e . g . subject  o b j e c t   e t c .     and semantic/cont e x t u a l information   e . g . time s p e c i f i c a t i o n   
e t c .   . this i n f o r m a t i o n is made a v a i l a b l e for l a t e r r e s o l v i n g of anaphoric reference  supplying 
phrases deleted through el l i p s it;  	and generating responses. 
1 	parsing 
¡¡¡¡¡¡the f i r s t phase    p a r s i n g     a c t u a l l y covers several operations. these include 
 a  cleaning up the input   c o r r e c t i n g s p e l l i n g   s u b s t i t u t i n g canonical words and synonyms  e t c .   ; 
 b  applying the semantic atns to the input request and f i l l i n g in context registervalues ; 
 c   b re a k in g up questions w i t h e nib e d d e d 
clauses i n t o two or more  simple q u e r i e s   ;  d  applying concept case frames to  simple q u e r i e s     r e s o l v i n g e l l i p s i s   pronoun r e f e r ence and questions i n v o l v i n g m u l t i p l e r e l a t i o n searches. 
       these operations are explained in more det a i l i n the f o l l o w i n g s e c t i o n s . 
1 	cleaning up the input 
       the parser f i r s t checks to make sure that each word of the input is known by the system. roots and i n f l e c t i o n markers are s u b s t i t u t e d 	for i n f l e c t e d words  	canonical 	words are s u b s t i t u t e d for synonyms  	and single words are s u b s t i t u t e d for c e r t a i n phrases 	  e . g . 	 usa  for united states of america  . 	if a given input word cannot be found in the d i c t i o n a r y   	then the s p e l l i n g c o r r e c t i o n module is c a l l e d . 	this module attempts to f i n d d i c t i o n a r y e n t r i e s 	  c l o s e   to the input word using methods described in 	| 1   ; 	if one of these c a n d i dates 	is c o r r e c t   	it 	is 	inserted 	in place of the misspelled word. 	if no candidates are found  or if 	the user r e j e c t s a l l 	the 	suggested candidates  a word adding module can be c a l l e d to t r y to add the u s e r ' s word to the d i c t i o n a r y by f i n d i n g a synonymous word or phrase already known to the system. 	the user can also t e l l the system to ignore the word and continue. 
1 	applying semantic atns 
       this section together w i t h the next two desc r i b e the heart of the language understanding process. it is here that pronoun reference and e l l i p s i s are r e s o l v e d   and here too t h a t much of the o v e r a l l programming e f f o r t for the system has been expended. the processing in t h i s p o r t i o n 
is handled by subnets. 
       each subnet is an atn  phrase parser which matches only phrases w i t h s p e c i f i c meaning. for example  in the planes world there are subnets for each d i f f e r e n t semantic o b j e c t : plane type  date  time p e r i o d   m a l f u n c t i o n   maintenance type  a i r c r a f t component  e t c . some examples of phrases w i t h the subnet for  time p e r i o d   would match are: 
 between jan 1 and feb 1    1     d u r i n g february and march     t h e n     and   i n the f i r s t s i x months of 1.  most subnets match noun phrases or p r e p o s i t i o n a l phrases. the construct i o n of subnets is based on winograd's analysis of noun phrase q u a n t i f i e r s   e . g .   f i r s t       r e s t      more t h a n       l a r g e s t     e t c .   are handled by a special subnet as are q u a l i f i e r s   e . g . the i t a l i c i z e d words in the phrase  a1s which crashed in may  . subnets also check f o r compounds   e . g .  planes 1 and b    plane 1 or plane 1     e t c .     and recognize verb phrases. 
       subnets are applied to the input request one a f t e r another. when a subnet matches a phrase  that phrase is saved along with information on 
which subnet matched i t   and a t t e n t i o n is s h i f t e d to the next p o r t i o n of the request. also as part of t h i s phase   noise words  are matched by a subnet and e s s e n t i a l l y discarded.  noise words  r e f e r to phrases l i k e  please t e l l me    can you t e l l me    would you let me know    could you f i n d     e t c . 
       whenever subnets match a phrase  they set the value of a corresponding context r e g i s t e r   which acts as a h i s t o r y keeper. context r e g i s t e r s are; used for pronoun reference and e l l i p s i s ; if some item s  in a request have been l e f t unspecified or replaced by pronouns  context r e g i s t e r values from previous request are used to supply the 
missing information or the referent of a pronoun. there are also context r e g i s t e r s for the l a s t request  l a s t paraphrase  last query language form  and last answer. context r e g i s t e r s are implemented as stacks; which are pushed down w i t h 
each new request. thus an e a r l i e r context could be r e t r i e v e d from a user statement l i k e  a while ago we were t a l k i n g about skyhawks   by looking back through context r e g i s t e r s u n t i l a planetype context r e g i s t e r value equal to  skyhawk  was found  and then r e s t o r i n g a l l the other context r e g i s t e r values current at that time. 
       at the end of t h i s phase we arc l e f t w i t h a set of representations of the semantic contents of the phrases in the sentence and a l i s t of the order of the c o n s t i t u e n t s . unless c e r t a i n cons t r u c t s  such as comparatives  e . g .   . . . g r e a t e r t h a n . . .     or embedded q u a n t i f i e d clauses  are present  the order of the phrases is ignored. this means that passive  active and   p i d g i n e n g l i s h   requests are a l l represented i d e n t i c a l l y from t h i s p o i n t of processing onward. given t h i s sort of processing  pronoun reference and e l l i p s i s become a r e l a t i v e l y d i f f i c u l t task. the parsing of a pronoun does not r e s u l t in i t s attachment to a p a r t i c u l a r semantic category. e l l i p s i s may be 

natural 	lang uage -1: 	waltz 
1 

t a k i n g place but it is hard to be s u r e .   our handling of these issues is described in the next s e c t i o n . 
       specific subnets recognize requests for help i n f o r m a t i o n   and draw help f i l e s in d i r e c t l y . 
       embedded clauses are handled by subnets; t h i s process is described in section 1 below. 
1 	concept case frames 
       concept case frames enumerate the patterns of questions understood by the system  and can also associate data base query skeletons w i t h question types which cannot be properly handled by the query g e n e r a t o r   . our concept case frames are somewhat d i f f e r e n t than ordinary case frames | 1   ; each concept case frame consists of the act   t y p i c a l l y r e l a t e d to the verb  and a l i s t of noun phrases  referred to by subnet/context r e g i s t e r name  which can occur meaningfully with the a c t . unlike ordinary case frames  we do not store i n f o r m a t i o n about the r o l e   e . g . agent  p a t i e n t   instrument  played by the various phrases  and each act covers a number of r e l a t e d verbs   e . g .   f l y       l o g   and   r e c o r d   map i n t o the same a c t   . phrases which would have to occur in every concept case frame  such as  time p e r i o d     are omitted from the i n t e r n a l r e p r e s e n t a t i o n of concept case frames. together  the subnets and concept case frames form a  semantic grammar  very s i m i l a r to that used in sophie  'l . 
       whenever c o n s t i t u e n t s of a sentence are missing  as in e l l i p s i s   or replaced by pronouns or r e f e r e n t i a l phrases  the model is able to suggest what type of phra.se is necessary to comp l e t e the concept by f i n d i n g a l l the concept case frames which match the rest of the sentence. if only one concept case frame matches  we are done; if more than one matches  then reference to which c o n s t i t u e n t s were present in the previous sentence is usually adequate to decide among c a n d i dates; otherwise  the user can be given the set of p o s s i b i l i t i e s from which to choose the appropriate r e f e r e n t s for each phrase. furthermore  the system can guess that sentences l i k e  how many 
malfunctions logged more than 1 f l i g h t hours  are meaningless because a l l phrases are recognized but no matching concept case frame e x i s t s . 
       more s p e c i f i c a l l y   the matching is done as f o l l o w s . a f t e r the best concept case frame   i . e . the longest one that matches the most semanticcategories of the phrases  has been chosen and as many s l o t s in the template as possible f i l l e d i n   pronoun reference and e l l i p s i s must be r e solved. if a l l mandatory s l o t s are f i l l e d and no pronouns occur  everything is already resolved. 
*1ne clue for e l l i p s i s is f i n d i n g a question word followed by an a c t i o n . this sometimes indicates that it is occurring--namely the noun phrase normally expected in that p o s i t i o n is missing. the probable e l l i p s i s can be tagged so that f u r ther i n v e s t i g a t i o n can be taken on l a t e r . 
pronouns are resolved by noting which semantic category s l o t s are l e f t over for them. pronouns can be replaced w i t h items that f i t that same semantic category by scanning backwards through the context r e g i s t e r values for e a r l i e r sentences. when e l l i p s i s and pronouns occur at the same t i m e   it may be impossible to decide which of two or 
more s l o t s to put a pronoun i n t o . if the frame contains no o p t i o n a l s l o t s   it makes no d i f f e r ence where the pronoun is put because the system w i l l have to f i l l in any other empty s l o t s before proceeding. should optional s l o t s be included  the task becomes more d i f f i c u l t because the pronoun may go in a required s l o t or an optional s l o t . if it should go in an o p t i o n a l s l o t   thee l l i p s i s must be occurring for the required s l o t . i f i t f i l l s the required s l o t   then e l l i p s i s may or may not be occurring for the optional s l o t . the second case is the one that causes a problemwe must know if e l l i p s i s is occurring to be able 
to e x t r a c t the f u l l meaning of the query. we resolve t h i s problem by assuming that e l l i p s i s is occurring  and scanning the very recent set of past queries  say the last one or two sentences  to see if the context b u i l t up confirms our hypothesis   i . e . see if can f i n d anything to f i l l the o p t i o n a l s l o t   . if nothing f i t s the semantic category of the s l o t   the e l l i p s i s is overruled and the hypothesis dropped. otherwise we f i l l in the s l o t w i t h the i n f o r m a t i o n found. if a l l else f a i l s   we can ask the user to select the approp r i a t e i n t e r p r e t a t i o n from among a set of hypotheses.  being able to choose from among a small set of p o s s i b i l i t i e s is s t i l l much simpler for the user than rephrasing!  
       e l l i p s i s alone is a l i t t l e easier to handle. any time i n f o r m a t i o n is missing from required s l o t s we know that e l l i p s i s is o c c u r r i n g . the past queries can be scanned backwards for i n f o r mation to f i l l the s l o t s . if we do not find enough information to f i l l a l l the s l o t s we can ask the user for the required i n f o r m a t i o n . when e 1ipsis of opti ona1 s l o t s is o c c u r r i n g   we must use a set of h e u r i s t i c s to give us a clue that the omission of a phrase has occurred. e a r l i e r we 
mentioned an example of such a heuristic-namely f i n d i n g a question word followed by a verb other than the verb to be without any i n t e r v e n i n g noun phrase-. 
1 	construction of a query 
¡¡¡¡¡¡the f i l l e d - i n concept case frame is next translated i n t o a formal query expression for use 
with a r e l a t i o n a l data base system.t the t r a n s l a t i o n i n v o l v e s : 
 1  s e l e c t i n g the r e l a t i o n s   f i l e s and card types  to look at in order to r e t r i e v e the information necessary for answering the user's request;  1  deciding what domains  data f i e l d s   to r e t u r n from the r e l a t i o n s which are searched.  in general  more f i e l d s are returned than are a c t u a l l y 
+ while we have not done so  it should be possible to w r i t e s i m i l a r query generators for other data models. 

natural 	language-1: 	waltz u 1 

asked for. for example  if asked about which planes had engine maintenance during some time period  planes returns not only the plane identification numbers  but also the dates of maintenance and codes for the exact type of maintenance. ; 
 1  deciding how to arrange the output data. typical orderings are by increasing or decreasing size of some field value  like  number of hours 
down time   or sequentially by date. other more complex orderings may be specified by the user 
 e.g.  list maintenances for plane 1 by month. ;  1  deciding which operations should be performed on the fields returned. examples of operations include l i s t   count  average  sum  and find largest; 
 1  translating field values  e.g. for dates  plane types  or actions  into internal data base codes. 
 1  most important  organizing a l l this material into an expression in the relational calculus  1  1  which can be used to implement the actual data base search. 
¡¡¡¡¡¡the general process was described briefly in section 1. for a simple query  one involving no joins  comparatives  listing by special grouping  e.g. by month  plane serial number  repair location  etc.   and no special quantification.  this process involves  a  finding the question phrase  s   e.g. which planes in  which planes flew more than 1 times      b  inserting it in the answer slot of the general query skeleton '  c  interpreting other semantic phrases and values  constants and sets of constants  as predicates   d  inserting these in the general skeleton  e.g. adding  gt flights 1.  to the l i s t of predicates  given the question above    e  completing the answer-description portion of the skeleton with other field values  using both heuristic knowledge about meaningful answer forms and any special user instructions  e.g.   p l o t . . .       l i s t . . .     etc.   and  f  deciding upon and f i l l i n g in a answer sort specification  e.g. by increasing serial number  in time sequence  by groups according to portion of the plane repaired  etc. . 
¡¡¡¡¡¡the query construction is more complex for quantified expressions  e.g.  find a l l repairs for the 1 planes with the most flight hours   comparatives  e.g.  did plane 1 log more flight hours than plane 1     questions with embedded clauses  e.g.  which planes that crashed in may had engine maintenance in april     and requests involving special operations  e.g. 'vhich plane flew the 
most hours in may   . 
¡¡¡¡¡¡of particular interest is the method by which relations to be searched are selected. 	the system looks at each phrase separately  and notes which 
relations the phrase could possibly belong to. some phrases  like plane type and date  are not 
*the general query skeleton consists of an ordered set of slots for quantification  locally bound variables  answer format  predicates to be satisfied by   h i t s     and an answer sort specification. very useful for this process  since they appear in most relations  but others  like flighthours  appear in only one or two relations. all the relations possible for a clause are then intersected  and if a single relation is selected  the process of selecting a relation is complete for the phrase. clauses are then considered in pairs  and so on. if more than one relation or a set of relations remains  then the request is ambiguous  and priority scheme or a dialogue is necessary to select the appropriate relation. if no relations remain at any intersection step  then more than one relation must be searched to answer the request  and the results of these searches must then be combined via the relational operation called joining  constructing a single relation from two different relations . as an example  the request:  find a l l planes which had engine maintenances on the same day as a f l i g h t   would require searching the maintenance and flight relations  and then joining these relations via the date and plane domains by intersecting the sets of tuples for maintenance and flight and retaining tuples with identical planes and dates. 
1 	constructing a paraphrase 
¡¡¡¡¡¡an important part of any query system's operation is allowing a user to verify whether or not the system has correctly understood his request. to this end  the. system feeds back its understanding of the request  with pronoun reference and ellipsis resolved  for the user's approval. the paraphrase is straight forwardly constructed from the formal query  and any special information associated with the matched concept case frame.  special information  includes query language skeletons  calls to help f i l e s   and special functions  such as statistical comparison functions  needed to answer complex questions. 
¡¡¡¡¡¡if the user does not approve of the interpretation of his request  he can enter into a clarifying dialogue with the system   	the system asks whether the user wants this query 
executed on the data base  if he wishes to continue with the current sentence as context  this is useful for correcting minor errors  e.g. typing the wrong year   or with the previous sentence as context. as a simple example  suppose a user wanted data  for a previously specified question  for january 1  but  using ellipsis  typed  january 1  instead. it is simple to correct this by typing  n  when asked by the system  shall i execute this query on the data base...y or n    and then simply typing  1 . the system w i l l recognize this as a year  substitute it for 1  and the user can then have the corrected query executed. clearly  minimum typing and no remembering of special commands is required for this sort of error correction. 
1 	retrieving the data 
¡¡¡¡¡¡the query expression generated is expressed in the data sublanguage alpha   as implemented in lisp by green . this expression is used 
by the relational data base system to construct the actual program which retrieves the data. in order to construct the search program  the system 

natural lan&uake-1: waltz 1 

must : 
 1  select the files to be searched; 
 1  select an order for searching these f i l e s ;  1  generate an expression for testing and selecting tuples values to return while searching;  1  generate a program to combine data  possibly from a number of different relations  so that the proper answer w i l l be returned. 
 1  decide when to save the results of a search for future use. this is important in interactive querying  since interesting results can be expected to evoke follow-up queries from a user  and such queries are likely to reference tuples just retrieved. 
1 	generating an answer 
¡¡¡¡¡¡once the data has been retrieved  the results are passed to the output module  which decides on an appropriate  display format for the data. if possible it attempts to produce a graph. this can only be done if  1  pairs of items are returned   1  one item is numerical   1  the number of items returned is small enough  but not too small  to produce a reasonable graph which w i l l f i t on a crt screen. if a graph is not possible  the system w i l l produce a l i s t or table; if there is too much data to f i t on the screen  the results 
w i l l be automatically output to the line printer. 
1 	embedded clauses 
¡¡¡¡¡¡qualifying phrases or qualifiers  see winograd    constitute the most common type of dependent clause. examples of qualifiers are the underlined parts of  planes which crashed in may    maintenance performed on a1s   and  planes with poor maintenance records.  qualifiers appear after the main noun in a noun phrase  and are often introduced by relative pronouns such as  which  or  that   or by verb forms ending in -ed or -ing. prepositional phrases can also serve as qualifiers. 
¡¡¡¡¡¡qualifiers can be found by applying a qualifier subnet to the portion of a request following the main noun of a noun phrase. because qualifier syntax is f a i r l y restrictive  in many cases merely examining the single word after the main noun may suffice to preclude the presence of a qualifier. if a qualifying phrase or clause may be present  the following actions are taken: 
 1  a syntactic parser  based on woods' lsnl1s parser   is invoked to find if a qualifier is present  and if so what its boundaries are.  1  if the embedded clause is not grammatical  heuristics are invoked to attempt to bracket the clause. 
 1  once a qualifier is found to be present  processing is suspended on the current clause  and the current context register values are pushed down. 
 1  the main noun from outside the qualifying phrase is substituted for the relative pronoun  if any  or is inserted as a phrase element in the qualifier. 
 1  the qualifying phrase or clause is processed like a normal request  with the main noun from the 
clause above serving the role of the requested item. note that verb forms get changed to a root plus an inflection  so that the exact verb form does not affect this processing. prepositions as well as verbs can refer to certain case frames  so 
that  for example   planes with poor maintenance records  has the same meaning to the system as 
 planes having poor maintenance records.   1  the query corresponding to the. qualifier must be integrated with the query corresponding to its surrounding clause to form the overall query. the ordinary meaning of qualifiers seems to suggest that the qualifier query be evaluated on the data base f i r s t   and its result should then be used as the scope of search for the other clauses  
in fact  either search can in general be performed f i r s t . * 
     notice that request can involve searching more than one relation  even if there are no 
qualifiers or dependent clauses  as in the sentence:  did any planes have a flight on the same day as an engine maintenance   in this case the relation for flights and the relation for maintenances must both be searched  and the results joined with respect to plane and date values. 
1 adding new questions 
¡¡¡¡¡¡extending system competence within the model is particularly easy although for the most part it 
must be done by a programmer. to add the a b i l i t y to handle a new type of sentence  one must only add a concept case frame which expresses that sentence. variations on this sentence  including active and passive forms  e l l i p s i s   different phrase orderings and the addition of noise words can a l l be handled with no additional machinery  provided that the proper relation  or relations  is automatically selected by the translation 
mechanisms discussed above. the addition can be handled in ordinary user mode. if a novel request is encountered   i . e . one which does not match any concept case frame   the query generator can s t i l l attempt to handle the request  and feed back a paraphrase to the user. if the user approves of the paraphrase  the request can be added to the concept case frame l i s t . the request can be added in a general way only if there were no pronoun 
reference and no ellipsis in the request--if there were  the concept case frame generated would be incomplete. if special instructions are necessary  these are attached to the concept case frame but this process probably w i l l involve a programmer for the foreseeable future. 
     extending the subnets is also fairly easy; we have written a net editor  described in   which takes a phrase and adds the states and arcs to match this phrase  to a specified subnet  using a minimum number of new arcs and states. once a 
 planes estimates temporary storage required for each query  and selects the query with minimum requirements to search f i r s t . the storage e s t i mates are made on the basis of statistical information stored for each f i l e . query construction is discussed in more detail in  and . 

natural 	lankuap:e-1: 	waltz 1 

new phrasing has been added to a subnet's repertoire  the phrase can of course be matched in any sentence context. 	to add a new phrase in user mode  the new phrase must be synonymous with some phrase already known by the system. 
	1. 	evaluation of the model 
¡¡¡¡¡¡to our knowledge  no other model proposed or implemented attempts to deal with ungrammatical input; any scheme based on sentence parsing  e.g. woods et a l .   must be restrictive  even if certain ungrammatical constructs are allowed  woods  for example allowed single noun phrases as requests  interpreting them and  find  noun phrase .  . the sophie system  uses a semantic grammer similar to that in planes  and is thus at least conceivably able to deal with nongrammatical input. 
¡¡¡¡¡¡a number of other systems have dealt with pronoun reference and e l l i p s i s   including  at least  lunar   sophie   shrdlu   rendezvous   nlpq 1 l     and lifer . 
¡¡¡¡¡¡much of the stimulation for generating our model came from reading codd   and some of the. query generator ideas are similar to those expressed in sowa . some language processing ideas were inspired by parry   
¡¡¡¡¡¡the amount of computation required by the model is relatively modest. planes typically requires 1 seconds to parse a sentence and generate a formal relational query. total processing time depends c r i t i c a l l y on the amount of data to be searched. 
¡¡¡¡¡¡plans for the near future include extensive testing on real potential users. 
