 
pro-active agents typically have multiple simultaneous goals. these may interact with each other both positively and negatively. in this paper we provide a mechanism allowing agents to detect and avoid a particular kind of negative interaction where the effects of one goal undo conditions that must be protected for successful pursuit of another goal. in order to detect such interactions we maintain summary information about the definite and potential conditional requirements and resulting effects of goals and their associated plans. we use these summaries to guard protected conditions by scheduling the execution of goals and plan steps. the algorithms and data structures developed allow agents to act rationally instead of blindly pursuing goals that will conflict. 
1 introduction 
pro-active intelligent agents are those agents that pursue goals  thangarajah et al  1a . these agents typically have multiple goals that are active simultaneously. these goals can interact with each other both positively and negatively. for example consider a mars rover agent that has a goal to perform soil analysis at location a and another goal to perform rock analysis at location d. clearly the agent cannot pursue these goals in parallel since they require the agent to be at different locations. this is an example of negative interaction. 
　an intelligent agent should not blindly pursue conflicting goals or unintentionally make its own goals unattainable if such is easily avoidable. in earlier work  thangarajah et al  1  we provided mechanisms for identifying and facilitating positive interactions with respect to the effects of goals. horty and pollack's work on evaluating an agent's options in the context of its existing plans  horty and pollack  1  and pollack's work on overloading intentions  pollack  1  also contribute to managing positive interactions. 
　in pursuing their goals intelligent agents often use intermediate steps which enable later steps to achieve the goal. this is often managed using a series of plan steps where the effect of an earlier step achieves the pre-condition for a later step. a rational agent engaged in this kind of pro-active behaviour should not allow the pre-conditions that have been achieved by an earlier step to be interfered with before the later step that relies on the pre-condition is done. for example suppose an agent is using a plan to cook dinner  involving going to the store  buying some items  coming home and preparing the meal. having arrived at the location of the store  a rational agent would not allow a plan which took the agent elsewhere to intervene  prior to actually purchasing the items at the store. 
　this paper focuses on recognising situations where these linkages exist in a plan and controlling plan interleaving to ensure that an agent does not allow negative interference in the pursuit of separate parallel goals. we provide detailed mechanisms that can be easily implemented in agent platforms such as prs  ingrand et al.  1  j a m  huber  1   dmars  dtnverno et al  1   and jack  busetta et al.  1 . 
　there has been significant work in the area of conflicts in agent systems  tessier et al  1 . however  the focus has been on multi-agents and identifying various types of conflicts. our work focuses rather on providing algorithms and representations that allow detection and resolution of conflicts due to multiple parallel goals in a single agent. 
　there is also work in plan scheduling to avoid conflicts such as the work of  boutilier and brafman  1  and  clement and durfee  1b; 1a . boutilier and brafman provide a representation of concurrent interacting actions by extending the strips action representation language  and provide an algorithm for planning with concurrent plans. however this work  like traditional planning approaches  requires the agent to have a completed plan  and perform the scheduling prior to execution  i.e. off-line . this is not useful for the type of agents that we deal with which are situated in highly dynamic environments where it is generally not possible to determine which plans to use in advance. 
　clement et al. use the notion of summary information to co-ordinate plans at abstract levels. they have provided a formalism which defines correct interleaved plan execution  clement and durfee  1b  and a scheduling algorithm which uses this information to appropriately interleave plans to avoid resource conflicts  clement et al  1 . the work presented here focusses on recognising the way in which early steps in a plan typically pave the way for later steps  setting up  dependency links  and provides mechanisms to ensure that an agent recognizes these in managing its execution of parallel goals. we also provide mechanisms for continually updating summary information so that agents are also able to reason about partially completed goals. 
　in  thangarajah et al  1b  we provided means for an agent to detect and avoid resource conflicts by using summary information about resources.1 in the current paper we use a notion of interaction summaries  based on the effect summaries developed by clement and durfee  clement and durfee  1b   containing information about effects  pre-conditions and in-conditions of goals and plans. effects are the conditions that a goal or plan aims to achieve  preconditions are conditions that must be true for a plan to begin execution  and in-conditions are conditions that must remain true while the relevant goal or plan is active. 
　specifically  we protect in-conditions and pre-conditions that have been achieved by earlier steps in a plan. we do not protect all pre-conditions: if the pre-condition has not been achieved by a previous step then there is no clear justification for protecting it. in particular  when defining the notion of 
preparatory effects in section 1  we only consider dependencies between nodes that are part of the same top-level goal. 
　in this work we consider only  achievement goals 1  that is goals where the agent attempts to achieve some condition  and when this condition is achieved the goal is removed from the agent's mental state. 
1 plan and goal representation 
this work builds on our previous work presented in  1a; 1b; 1 . the representation of goals and plans arc therefore similar to what we presented in  thangarajah et al  1 . to summarise these agents have a pre-defined set of plans which are used to satisfy goals at run-time. a goal-type is a template for a goal which consists of  i  a label that indicates the type of the goal  e.g. transmitresultsgoal  ii  inconditions of the goal1  iii  the effects of the goal1 and  iv  the possible set of plan-types that can satisfy the goal  winikoff e/a/.  1 . 
　similarly a plan-type is a template for a plan and consists of  i  a label for the type of plan  ii  pre-conditions for the plan to begin  iii  in-conditions that must be maintained during plan execution  iv  the direct effects of the plan and  v  a plan body which specifies what the plan does. plan bodies can contain subgoals and actions. these are combined by either sequencing them  e.g.  achieve goal g1 and then perform action a  written as  g1; -a   or by performing them in parallel  e.g.  achieve goals g  and g1  written as  
　the pre-conditions include in-conditions1. the reason for this is that in-conditions are stronger than pre-conditions: if 
   'this work was done independently from  but is quite similar to that of  clement and durfee  1b . 
   1  another type of goal is a maintenance goal  where the agent ensures that a particular condition is never violated. 
   1 pre-conditions  in-conditions and effects are all represented as logical conditions. 1 these effects are the direct  desired effects of the goal  similar to the notion of primary expectations of  pollack  1 . 
     1 formally  if i is the in-conditions then we consider the preconditions to be t  p. 
1 
an in-condition fails to hold when a plan begins executing then the plan fails immediately. 
　each goal-type g also has a goal-plan tree template where a goal-plan tree is a tree structure of goals whose children are the plans that achieve it and the children of a plan are the subgoals of the plan  with g as the root. all of the subgoals of a plan must be executed in order for the plan to succeed   and  . however  it is not necessary that all plans of a goal be executed   or  . 
　when the agent decides to pursue a goal  a goal-plan tree instance is created and updated at run-time to contain goal and plan instances. in addition to the above properties  goal and plan instances will also have a label  instance-name  that gives a unique handle to it at run-time. this is basically a path expression in a goal-plan tree instance  e.g. in figure 1 g p sgz pa is the instance-name for plan pa . 
　the execution cycle of the agent is similar to the wellknown and developed bd1  belief desire intention   rao and georgeff  1  style of agents that map to agent implementation systems such as prs  jam  dmars  and jack  where a plan is selected from an applicable plan set and if it fails an alternative applicable plan is tried if available. we extend this model by requiring that a goal with an in-condition that is false is delayed until the in-condition becomes true1. 
1 	preparatory effects and dependency links 
typically  when developing a set of plans to achieve a goal  a developer is not able to consider all the ways in which the pursuit of other goals may interfere with this goal. there are two important ways in which parallel goals can interfere  which we try to capture and reason about in this work. considering the logical outcomes of goals and plans  interference can occur: 
1. when an in-condition is made false while a plan or goal is executing  causing the plan or goal to fail. 
1. when a previously achieved effect is made false before a plan or goal that relies on it begins executing  preventing the goal or plan from being able to execute. 
　we thus define a preparatory-effect  p-effect  of a goal g as follows. consider two plans p1 and p1 which are utilised to satisfy g and p1 is executed before p1 as shown in figure 
1. if p1 brings about an effect e which is a pre-condition of p1  then there is a dependency-linkbetween the preparatoryeffect e and the dependent-plan p1  e  {p 1 } . we shall term this a dependency-planlink. in the event that an effect of a plan serves as a pre-condition to all the plans that satisfy a sub-goal  as is the case with effect e and sub-goal  then there is a dependency-link between the p-effect and the dependent-subgoal  e {sg1 } . we shall term this a dependency-subgoallink. 
　a dependency-planlink is complete when the dependent plan begins execution. a dependency-subgoallink is complete when either  a  the dependent-subgoal is complete or  b  the last possible plan to satisfy the sub-goal begins execution  all other plans have been tried but failed . 
     1 some of the systems will begin executing the goal and have it immediately fail. 
multiagent systems 

figure 1: dependency-links example 
　when a p-effect is achieved the agent should protect the effect from being undone until all the dependency-links associated with the effect are complete. 
　all dependency-planlinks are potential by definition because the agent has other means of achieving the dependentplan's parent sub-goal. 
a dependency-subgoallink is either 
  definite if the dependent-subgoal will definitely be pursued as is the case with .sg1  figure 1 ; or 
  potential if the dependent-subgoal is not definite. sg1 is an example of such a sub-goal as it depends on the path chosen for sg1. 
　the above categorisations leads to a ranking of importance with respect to guarding a p-effect. a definite dependencysubgoallink is strongest because the dependent-subgoal will definitely be pursued and all ways of achieving it require the p-effect as a pre-condition. a potential dependencysubgoallink is stronger than a dependency-planlink because although they are both potential the dependent-subgoal of the dependency-subgoallink will definitely fail if the p-effect is not true. in contrast the parent sub-goal of the dependent-plan of a dependency-planlink has other means of being achieved. this ranking is useful for defining agents that are more or less careful with respect to protecting preparatory effects from interference. 
dependency-entry: 
in order to reason about and protect p-effects we attach dependency information at each plan-node of a goal-plan tree. this is done at compile time1 and each entry which we shall term a dependency-entry consists of a set of dependencylinks   p-effect  dependent-plan/subgoal   where the p-effect is an effect of the plan. we attach dependency-entries only to plans because p-effects are achieved by plans  goals only declare what the plans will achieve. 
1 	interaction tree 
in order to detect if goals can be executed in parallel without any interference from each other we define the notion of inter-
     1 wc do not describe the computation method in detail - the definitions above form a specifi cation that can be easily realised. action summaries. when there is potential interference these interaction-summaries help us to schedule appropriately. 
　interaction-summaries are similar to effect-summaries developed in  thangarajah et al  1  and based on the work of clement and durfee  clement and durfee  1b  on condition summaries. the effect-summaries of a goal summarise the effects that will definitely be achieved irrespective of the path chosen to satisfy the goal and those that may be achieved depending on the path chosen. these were used in  thangara-
jah et ai  1  to detect situations where the plans of two goals that bring about the same effect could be merged and to facilitate this merging. 
　we use interaction summaries to ensure that the effects of one goal do not interfere with active in-conditions and dependency-links of other goals. therefore we need to maintain summary information of  a  effects as they could cause the interference  and  b  in-conditions and preparatory-effects as these are what need to be protected when active. only those pre-conditions that are set-up by p-effects are protected so we do not need to maintain pre-condition summaries separate from the information in the dependency-entries. 
　for the discussion ahead the general term condition refers to either in-conditions or effects  including p-effects . similarly to  thangarajah et al  1   conditions can be either definite or potential. a definite condition will definitely be achieved/required  achieved for effects and required for inconditions  at some point along every possible path of achieving the goal  i.e. this condition need not be required by all plans  but is required by at least one plan in every possible way of achieving the goal . a potential condition will possibly be achieved/required at some point in the pursuit of the goal  i.e. this condition is part of at least one plan in at least one path of achieving the goal but not achieved/required in all possible paths of achieving the goal . the set of potential conditions and definite conditions are exclusive of each other. 
interaction summary: 
an interaction-summary of a goal/plan contains the definite and potential in-conditions  effects and p-effects. formally the interaction-summary of a goal/plan n is a 1 tuple. 

where si  se and spc are the summaries of in-conditions  effects and preparatory-effects respectively. the in-conditions summary contains the definite and potential in-conditions of the node. and each of and are simply sets of conditions  . similarly for the effects and p-effects summaries. we shall see how we can derive interaction-summaries of a goal/plan in section 1. 
interaction-tree: 
the interaction-tree structure is a goal-plan tree where attached at each node is the interaction-summary and in addition for plan-nodes the dependency-entry1 of the plan. this tree is built at compile time for each goal-type and instantiated at run-time for each goal-instance. figure 1 shows the interaction tree of a simple goal of a mars rover agent to perform soil experiments at location a. 
　the interaction-tree for any active goal is updated dynamically as the goal is pursued. when a plan/sub-subgoal com-

figure 1: interaction tree example 1  as described at the end of section 1. pletes the corresponding node is removed and the interaction summary of the parent-node is re-computed. any changes to the parent node are propagated up the tree. dependencyentries are updated when plans  dependent-plans  begin execution. 
1 	deriving interaction summaries 
interaction summaries are derived at compile time and updated at runtime  similarly to the mechanism used in  thangarajah et al  1b . in this section we use the following notation: g p  is the set of subgoals of the plan p  and in-cond n  is the in-conditions of n  with n being either a goal or a plan . 
　the interaction-summary of a node of a goal-plan tree is derived by combining the local conditions of that node with the interaction-summaries of all its child nodes. each piece of the summary  the in-condition summary  the effect summary and the p-effect summary  is calculated by combining the relevant pieces of the local and children nodes. the interaction summaries of goal nodes and plan nodes are calculated slightly differently and the details are as follows. 
　the effects summary of a plan is computed by taking the union of the local effects of the plan with the effects of each of the goals within the plan  using the addition operator defined as follows: 

where d and p are respectively sets of definite and potential conditions  either effects or in-conditions . the effects summary of a plan is then: 

the p-effect summaries are analogous to effect summaries. 
　the in-condition summary of a plan is similar to the above and is defined as: 

　the summaries of goals however need to take into account that the plans whose conditions are being combined  are alternative ways to achieve a goal. the agent will typically1 only 
1  more than one plan may be executed in the case of plan failure. 
this does not change the rationale for the combination operators. 
1 
execute one of these alternative plans and thus the combined definite conditions are those that are definite for all plans  while the combined potential conditions are those potential for some plan plus those that are definite for some plan  but not for all. the conditions of plans are combined using a merge operator defined as follows: 
　goals do not have effects other than the effects of their plans  so the effect summary1 of a goal is: 

　the in-condition summary of a goal is then defined as the merged in-conditions of its plan nodes  combined with the local in-conditions of the goal as follows: 

　in order to determine the interaction-summary  is  of a set of goals  the operator is applied to all of the goals in the set as follows  

1 executing goals simultaneously 
having calculated interaction summaries  we then use these to detect and avoid potential interference. we will first look at ways of determining whether two goals will definitely not interfere with each other  in which case they can be pursued in parallel without any monitoring or scheduling of plans. then we will discuss how goals that may have potential interference can be scheduled to avoid such conflicts whilst being pursued simultaneously. 
　as we have discussed in section 1  when two goals are executed in parallel  we track and protect the following two constraints:  a  the in-conditions of each goal and its active plan instances must not be violated and  b  the preparatory-effects  p-effects  that have been achieved must not be undone until the dependency-links are complete. 
the p-effect summary is similar 
multiagent systems 
　
　we can determine that a new goal gnew will not interfere with an existing set of goals gset if all  i.e. both definite and potential  the effects of gnew are compatible with all the derived in-conditions and p-effects of gset. two conditions1 are compatible if it is possible for them to be simultaneously true. the details depend on the specific representation of conditions. 
1 	scheduling 
if there is interference between two goals this can be avoided by pursuing the goals in sequence. however  this restriction is too strong since it requires that the agent never have more than one goal that is being pursued. a more reasonable restriction is to pursue the goals in parallel  but monitor these goals for the steps which cause conflict and schedule them such that they do not interfere with each other. we do this by guarding the in-conditions and dependency-links that are active when adopting new goals and executing new plans. 
　in order to do this we use the interaction-trees and we further require a data structure that we shall call the guardedset1  gs  which includes in-conditions and dependencylinks that are currently active and need to be guarded by the agent. dependency-links are obtained from the dependencyentry of the associated plan-node from the interaction-tree. in-conditions are placed together with the name of the associated goal or plan instance the guardedset can be defined by the following simple grammar: 
guardedset  dependency-entry incondentry dependency-entry p-effect pgname incondentry  in-condition pgname 
pgname  planlnstancename goallnstancename 
　we avoid interference between goals by  i  protecting the in-conditions while a plan or goal is executing  and  ii  protecting the p-effects that are achieved by a plan from the effects of new plans until the relevant dependency-links complete. however  in doing this  we must be careful to avoid deadlocks. for example  imagine we have the following two goals: 
g1 .incondition x   g1 .. subgoal 1 .effect not y   g1-incondition y   g1 .. subgoal1.effect notx . 
assume that the agent is pursuing g1  but has not yet reached subgoall. the gs contains x  as it is an in-condition of g1. in considering g1  if the agent checks only the conditions in the gs there appears to be no problem and g1 could be pursued  placing y also in the gs. however when subgoal i and subgoal1 are respectively reached  they would be suspended as they affect y and x respectively  both of which are in the gs  thus creating a deadlock. consequently  before adopting a goal/plan  we look ahead at effects that can be achieved by existing goals  using their interaction summaries  and ensure they don't interfere with the in-conditions of the new goal/plan to be executed. 
　interference can then be avoided between goals by incorporating the following steps into the agent execution cycle. 
1. when the agent begins the pursuit of a goal the inconditions of the goal  i.e. the direct in-conditions  not 
''more generally  sets of conditions 
1  actually  this is a pair of multisets. the derived in-conditions  are added to the gs. 
1. when the agent satisfies a goal or the goal fails any inconditions of the goal in the gs are removed. if the goal is part of a dependency-subgoallink in the gs this entry is also removed. 
1. when a plan begins execution 
 a  in addition to placing the in-conditions into the gs  if the plan has any p-effects then the relevant dependency-entry of the p-effects are placed in the guardedset. the reason we do this at the start of the plan  instead of the end  when the p-effect is achieved  is because the plan step that achieves the effect is not known in advance; and the agent should not begin another plan that could possibly undo the p-effect while the plan is executing. 
 b  if the plan either completes a dependency-planlink or a dependency-subgoallink1 that is protected in the gs  then delete that dependency entry. 
1. when a plan completes or fails execution  the inconditions of the plan that are in the gs are removed. further  in the event of plan failure any dependencyentries associated with p-effects of the plan are removed from the gs. 
1. before the agent adopts a goal gnew  it should perform the following to avoid deadlocks. check for each goal g that has an associated condition in the gs  whether the in-conditions of gnew are compatible with the combined definite and potential effects of g. 
if they are compatible then gnew can be pursued in parallel with g. else check for compatibility with the definite effects of g. 
if they are not compatible then unless gnew completes before g they will conflict. since we have no notion of time gnew should not be pursued in parallel with g  but should be re-considered when the incompatible effects of g have been achieved. 
else the agent can either  a  choose to be cautious and not allow gnew to execute until the incompatible effects in g are achieved  or  b  since potential conditions depend on the path chosen  be optimistic and allow gnew  to execute hoping that the incompatible effects  and resulting goal/plan failure  will be avoided. 
1. before the agent executes a plan pnew  it should check whether the effects of pnew are compatible with the conditions protected in the gs. if they are not compatible then the plan must wait until they are compatible. also in order to prevent deadlocks the in-conditions and peffects of the plan must be checked against the derived effects of existing goals that have a guarded condition as done before adopting a new goal. 
　above we have given priority to the goal that is already being pursued as opposed to the new goal. this however is totally dependent on the priority mechanism of the application. if the new goal is more important then existing goals 
1 by being the last plan to be attempted. 
　
can be preempted. however goal priorities and mechanisms for goal preemption are beyond the scope of this paper. 
1 conclusion 
in this paper we argued that intelligent agents often have plans involving several steps  where the results of one step set up conditions for a later step to be successful. intelligent agents typically pursue multiple goals in parallel  but if intelligent or rational  they should manage this parallelism in a way which avoids undoing of preparatory effects too early. they should also not do something intentionally which causes immediate failure of another currently executing plan/goal. 
　we defined a notion of preparatory effects and dependency links and described how summary information could be computed and then used to protect both preparatory effects  before a plan/goal executes  and in-conditions  while a plan/goal executes . these mechanisms allow an intelligent agent to pursue multiple goals in parallel without stupidly and unnecessarily acting in a way that causes failure of some goal or plan. these mechanisms capture the kind of reasoning that is done effortlessly by humans  but which is not yet evident in intelligent computer agents. 
　our analysis and experimentation indicates that this additional reasoning is not computationally expensive. however we plan to also test the costs and benefits empirically in further work. we also plan to do work to clarify the relationship between this work and earlier work by clement and durfee et al. 
