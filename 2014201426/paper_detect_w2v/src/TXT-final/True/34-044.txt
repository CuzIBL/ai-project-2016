 and keywords 
a modification of pohl's b i - d i r e c t i o n a l h e u r i s t i c search algorithm is desribed together with a s i m p l i f i e d implementation. theorems are proved about conditions y i e l d i n g shortest paths. the results are given of a worst case analysis of d i f f e r e n t algorithms suggesting a rankorder of t h e i r q u a l i t y . 	results that pohl had obtained with a u n i - d i r e c t i o n a l h e u r i s t i c search algorithm on the 1-puzzle are compared with the results obtained by the new - s i m p l i f i e d - algorithm. 
keywords: a r t i f i c i a l i n t e l l i g e n c e   b i - d i r e c t i o n a l n e u r i s t i c search  front to front guiding  path f i n d i n g . 
1. introduction 
i n t h i s paper we l i m i t ourselves to those problems a  which are representable in the state.-operatorstate -  paradigm; 
b  where the goal can be e x p l i c i t l y represented as a state in a set of s t a t e s ; 
c  whose problem space can be described as a l a b e l l e d graph; 
d  where it is equally possible to work from the 
s t a r t state to the goal state as the other way round; 
e  where there is a h e u r i s t i c function available which can be used to guide the search process. 
as is w e l l known  see e.g. / 1 /   a h e u r i s t i c funct i o n can be used to guide u n i - d i r e c t i o n a l search. the property of ending with a shortest path between s t a r t state and goal s t a t e   as can be found with breadth f i r s t search without h e u r i s t i c funct i o n   can even be preserved if the h e u r i s t i c function is a lower bound on the real minimum eff o r t to be made. in /1/ and / 1 / an algorithm is described which generalizes to the b i - d i r e c t i o n a l case. this algorithm in fact performs two independent u n i - d i r e c t i o n a l searches  a forward search guided to the goal node  and a backward search guided to the s t a r t node. the disadvantage of t h i s i s   that in a search space where more than one path exists from the s t a r t node to the goal node  the two searches often proceed along two d i f f e r e n t paths  so that the two sets of closed nodes   f o r the terminology of ' c l o s e d '   'nodes' and other technical jargon see / 1 /   grow i n t o nearly complete u n i - d i r e c t i o n a l trees before i n t e r s e c t i n g each other  instead of meeting in the 'middle' of the space. 
in the next section we discuss another algorithm that remedies t h i s deficiency and we give a simp l i f i c a t i o n of that algorithm which has been implemented in a fortran program. in section 1 we compare our r e s u l t s with the results of pohl's u n i - d i r e c t i o n a l h e u r i s t i c search on the 1-puzzle. in section 1 we mention some possible improvements of the implemented algorithm. 
1 

before going i n t o a precise description of the 
bhffa  we give an i n t u i t i v e sketch. suppose we have the s i t u a t i o n as in f i g . l   where s and t are the sets of closed nodes and 1 and t are the two fronts of open nodes  and we decide to expand a node from s. in pohl's bhpa algorithm a node was chosen in s which had a minimum value 
of the function g +h 	s where g 	was the current s 	s 	s 
mimimum to the s t a r t node & and h was an e s t i mator of the distance from the node to the goal 
node t. the h 	we use is d i f f e r e n t   h 	is a m i -
	- 	s 	s 
nimum of h+g over every node in the opposite front t  where g is l i k e g but with respect to the goal node t and h is an estimator of the shortest distance between a r b i t r a r y pairs of nodes. immediately the disadvantage of t h i s a l gorithm with respect to bhpa must be c l e a r   s i n ce the calculation of the function h in our a l gorithm is much more complicated than the c a l culation of the distance to t in bhpa. on the other hand there are gains  but we defer d i s cussing them to the next section. 


in step 1 nothing is said about the decision to go forward or backward  as investigated by pohl  the most promising procedure is to count the number of nodes in s and t and to select the front which has the fewest  but at least one . benidea the f-valuo the g-value needs to be stored at each node  as the g-value might be updated in step 1 and 1 of bhffa. 
1 some theorems about bhffa 
we give some theorems and proofs about bhffa which p a r a l l e l the theorems and proofs about the u n i d i r e c t i o n a l a * algorithms o f / 1 / . in t h i s section we also formulate another b i d i r e c t i o n a l algorithm bhffa1 which is i n t e r e s t i n g from a t h e o r e t i c a l viewpoint and which we compare with bhffa in section 1. 
1 

according to lemma 1 there exists always an open node n in sut on p with f  n  or f   n     h   s   t   . therefore the nodes expanded must nave an f-value less or equal to h   s   t   . consequently t h e i r gvalues are less or equal to h   s   t   . thus bhffa only expands nodes at most h   s   t   / 1 steps away from s or t  and t h i s is a f i n i t e number. let 
m 	and mt be the sets of a l l nodes which are s 
ever generated from s and t respectively. as every node has only a f i n i t e number of successors and as the maximum number of steps any node is away from s or t is f i n i t e   both ms and mt can only contain a f i n i t e nuaber of nodes  ana so m=m s um t is of f i n i t e s i z e . let the number of s 	t 
nodes in m be v. let p be the  necessarily f i n i t e   number of d i f f e r e n t paths from s to m if mcms   and from t to m if mcmt   and l e t p be the maximum over a l l p . then p is the maximum number of d i f f e r e n t times a node can be reopened. after p.v i t e r a t i o n s of bhffa a l l nodes of m are permanently closed. so sut=# and bhffa h a l t s   which produces a c o n t r a d i c t i o n . case 1: we have j u s t proved that bhffa e v e n t u a l ly h a l t s   and it can only do so for two reasons: 
it has found a s o l u t i o n p a t h   or sut is empty. if the l a t t e r is the case  then the last node expanded had no successors at a l l    otherwise they would have been placed in 1 or t . but t h i s means that there is no path from s to t  c o n t r a d i c t o r y to assumption. so bhffa halts because it has found a solution path. case 1: just before ending with a node m  there would  by lemma 1  be a node n inswith f {n   h   s   t     f  m =gs  mj+g-dn  and thus n woull be chosen for expansion instead of m. . 
q.e.d.l 

the next theorem proved in /1/ is the optiraality theorem  which states that if two h e u r i s t i c s   h and h*  are r e l a t e d by h *   n   t     h   n   t   * h   n   t   f o r a l l n  and if for both h e u r i s t i c s the consistency property holds   meaning that h n t +h{n x   h   x   t     then every node expanded by h w i l l also be expanded by ii . this theorem doesn't hold for bhffa. the reason for that i s   t h a t   unlike in the u n i - d i r e c t i o n a l and in pohl's b i - d i r e c t i o n a l algorithm  the f-value of an open node is not s t a t i c in bhffa  and the way in which it changes depends on both the exact form of the h e u r i s t i c and the real distances between the nodes in the opposite f r o n t ; and without assuming some det a i l e d information about those  the exact behaviour of any h e u r i s t i c with bhffa is hard to p r e d i c t . we haven't succeeded in f i n d i n g a general proof t h a t   if one h e u r i s t i c is better   i n the above sense  than an other  it w i l l a l ways f i n i s h in less i t e r a t i o n s . we don't consider t h i s a great l o s s   because in most cases it w i l l nevertheless be t r u e . {something  for example  which can be proved i s   that if there 

theorem 1 
the lemmas and theorems proved in / 1 / for the u n i - d i r e c t i o n a l a* algorithm  including the opt i m a l i t y theorem  also hold f o r bhffa1. proof 1: bhffa1 is in fact the u n i - d i r e c t i o n a l 
a algorithm in the product space of the nodes with i t s e l f . q.e.d.1. 
1 worst case analysis 

are two h e u r i s t i c s   	and then h w i l l f i n i s h in less i t e r a t i o n s   . 
now we describe another b i - d i r e c t i o n a l algorithm  bhffa1  because it can be easily implemented and seems to be elegant. the worst case error anal y s i s   the results of which are described in the 
next s e c t i o n   however  suggests that the number of nodes expanded explodes f a s t e r . the notation of bhffa1 follows more closely the terminology of / 1 / . 
1 

j is a monotonically decreasing function of r  then  no matter what the h e u r i s t i c exactly looks l i k e   
ional pohl; 
ed by algorithm a. 
that t h i s indeed must be the case can be understood i n t u i t i v e l y by looking at the figures 1  1 and 1  where the length of a bar represents the depth to which nodes o f f the solution path are expanded. the t o t a l length of a l l the bars i n creases from figure 1 to figure 1. 
 . suppose that for two nodes both l y i n g on the solution path holds that 
forsome and else  at least one of the two l y i n g o f f the path   then  is a r e l a t i v e e r r o r bound and t h i s is the worst possible case. now for the bhffa  the u n i - d i r e c t i o n a l algorithm and pohl's b i - d i rec tional algorithm nodes o f f the solution path w i l l be expanded u n t i l a depth j=1.r + 

so here the monotone condition holds with the result stated above. furthermore we give exact formulas for the number of nodes expanded by the d i f f e r e n t algorithms in t h i s worst case: 

1 the program 
a modified bhffa algorithm is implemented as a fortran program  geared toward solving the 1puzzle. in t h i s search-space a l l edgelengths are taken as unity. the most important r e s t r i c t i o n made is t h a t i f   a f t e r having expanded 1 nodes  the program s t i l l has not found a solution path  it gives up. another important modification is that the number of open nodes in a front can-
not exceed some maximum m  which is given to the program as an input parameter but must be less 1. whenever an  m+1 -th node should be added to a f r o n t   f i r s t the open node with the current worst f-value is deleted from it -unless the node 
 i t s e l f has an f-value even worse  in which case it won't be inserted. we c a l l thin operation  pruning   a term also used in / 1 / . thin step is mainly necessary to save time  as the number of comparisons needed to calculate h  x  f o r a node x in s  is equal to the number of nodes in t and vice versa. but t h i s also means that the algorithm is not admissable anymore   an algorithm s a t i s f y i n g theorem 1 is called admissible   because it is possible that some node on the optimal path w i l l be thrown away because it looked very bad at some i t e r a t i o n . in a search space where only one path exists from start  to goal node  some backtracking mechanism would be r e quired to ascertain that t h i s path is found. in the case of the 1-puzzle  the actual i n f l u e n ce d i d n ' t appear to be very large if m was set at 1  or l a r g e r     as w i l l be seen in sect i on 1step 1 of bhff'a  where occurrence of a new node in the col l e c t i o n of closed nodes of i t ' s own front is checked was eliminated. we did t h i s because we thought the time gained in possibly expandi ng a few nodes less would not balance the loss caused by searching through the set of closed nodes f o r every new open node  whereas the solution path found w i l l most l i k e l y not be i n fluenced. step 1 was done by estimating a l l distances to the opposite f r o n t   and i n s e r t i n g node x in one of the ordered fronts of open nodes  where the ordering is gi ven by the f-values of the open nodes. a nasty s i d e - e f f e c t was that the i n s e r t i o n of a new node in s could imply a r e ordering of t and vice versa. the ordering was done using a square matrix in which a l l combinations of the h x y -values of the fronts were stored. step 1 {the terminating condition  was eliminated and replaced by a test in step 1: ' i f x't'ut then halt with a solution p a t h ' . the t e s t i n g of x being in  instead of just being in t is a necessary consequence of the pruning  as it is possible that a descendant of a closed node is deleted from the open front. three h e u r i s t i c functions were implemented in the 


1 

counted shorter than no path at a l l   ; if the same pathlength was found by both programs they both scored 1; if a problem was not solved by e i t h e r of the programs they both scored 1. the score for the number of nodes expanded was obtained in a similar way. in so far the solution q u a l i t y is 

as there were ten di f re rent 1-puzzles  t h i s amounts to a t o t a l of 1 problems  of which our program solved 1  whereas the u n i - d i r e c t i o n a l program of pohl solved 1 of them  it can be seen that in nearly a l l these cases the h e u r i s t i c is not a lower bound on the real e f f o r t to be made. this is the main reason why many of the solutions found are not optimal  both for pohl's program and ours. 
tables 1 and 1 summarize the r e s u l t s   the f u l l results on a l l ten problems may be found in the expanded version of t h i s paper already mentioned in section p.p. in table    where the performance 
of the d i f f e r e n t functions is compared  the score f o r pathlength was obtained as follows: the program with the shortest path for some problem scored 1 and the other 1   and any path is concerned  bhffa is an improvement over the u n i d i r e c t i o n a l algorithm: it solves more problems  finds in general shorter paths  and expands less 
nodes on the average  although the last effect is less prominent than we expected. bhffa performs p a r t i c u l a r l y well with a strong h e u r i s t i c f u n c t i o n ; with f1 the t o t a l number of nodes expanded by our program was 1% less than that by pohl' s program. the front length adequate for the problems was found e m p i r i c a l l y . experimental runs were made 
with frontlengths 1  1 and 1. an increasing number of problems was solved and a higher s t a b i l i t y was reached.  by s t a b i l i t y we mean the chance that a longer frontlength preserves a sol u t i o n obtained with a shorter f r o n t l e n g t h ; 
pruning t r i c k s are the obstructing force here . 
1 

as could be expected  the performance with respect to the f r o n t l e n g t h depends on both the sol u t i o n path length and the h e u r i s t i c used: the better the estimator  the smaller the f r o n t l e n g t h required  a length of 1 would suffice for a perfect h e u r i s t i c   . a l l problems were run with a frontlength of 1  and the least s a t i s f a c t o r y solved were run again with a frontlength of 1  in order to see whether the maximum number of 1 expanded nodes or the pruning in the fronts was the bottleneck. in general the f i r s t seems to bo the case  since no s i g n i f i c a n t improvement was made  with the exception of f1 on a1 where six instead of one out of 1even problems was solved. the main disadvantage of pohl's b i - d i r e c t i o n a l a l g o r i t h m   as mentioned in section 1  appeared to be remedied. the fronts now did meet near the middle of the search-space  which we could see by comparing g and gt of the i n t e r section nodes. 
the large disadvantage of our algorithm is the very time-consuming c a l c u l a t i o n of the distance estimator. with a frontlength of 1  i would expect the bhffa-program to take in the average about 1 times longer to obtain a solution   f o r the same problem with the same h e u r i s t i c   than a u n i - d i r e c t i o n a l program  run on the same machine. in general  the loss of e f f i c i e n c y w i l l not be s u f f i c i e n t l y s e t - o f f by the shorter paths found. nevertheless  it may pay o f f i n   for example  an abstrips-like environment  see / 1 /     where it is c r u c i a l to f i n d an optimal path from among many d i f f e r e n t e x i s t i n g paths  as the number of sub-problem searches depends on the pathlength found in the dominating problem-space. there are bhffa or a s i m i l a r algorithm   i n the next section we w i l l suggest ways to make it cheaper   with a strong h e u r i s t i c f u n c t i o n   may f i n d an optimal path more e f f i c i e n t l y than a u n i - d i r e c t i o n a l program with a h e u r i s t i c s a t i s fying the lower bound c o n d i t i o n   because t h i s kind of h e u r i s t i c tends to be rather weak and results in a fast explosion of the number of nodes expanded. 
1. open problems and loose ends. 
bhffa can be s i m p l i f i e d by not c a l c u l a t i n g the h e u r i s t i c distance to every node in the opposite front but only to the best h a l f or even leas of them. this idea is inspired by the fact t h a t   in the l i m i t e d number of cases where we checked i t   a node realised i t s minimum nearly always to a node which belonged to the best ten of i t s own f r o n t . a further s i m p l i f i c a t i o n would be to delete the resequencing of the opposite f r o n t as 
the consequence of adding a node to a f r o n t . the s e n s i t i v i t y of the solution q u a l i t y to these computation time and memory savings should be tested. 
bhffa  needs implementation to be able to compare i t s performance with that of bhffa. looping as a consequence of the pruning can be recognized but which rescue program should be started then is unclear. 
the p a r t l y expanded node technique  as suggested in / 1 /   needs i n v e s t i g a t i n g . a loss technical question however concerns the selection of the most i n t e r e s t i n g ones among the vast amount of pot.cutinl macro-operator sequences that appear in a solution.path. 
but the real a.i.-question is s t i l l : how can the program improve i t s heuristic function beyond simply optimizing some coefficients. heavily related to this is the question: how to find automatically the best representation for a problem to be treated by heuristic algorithms. 
acknowledgements 
this research originated from a grant of the 
netherlands organization for the advancement of pure research  z.w.o.   which enabled the f i r s t author to v i s i t u.t. in austin  texas  where l. siklosky introduced him to this f i e l d . discussions with t. pohl on e a r l i e r drafts were highly appreciated. 
