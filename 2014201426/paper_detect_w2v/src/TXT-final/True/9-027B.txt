 
　　　　this paper proposes a modular actor architecture and definitional method for artificial intelligence that is conceptually based on a single kind of object: actors  or  if you will  
virtual processors  activation frames  or streams . 	the formalism makes no presuppositions about the representation of primitive data structures and control structures. 	such structures 
can be programmed  micro-coded  or hard wired 1n a uniform modular fashion. 	in fact it is 
impossible to determine whether a given object is  really  represented as a list  a vector  a hash table  a function  or a process. the architecture will efficiently run the coming 
generation of planner-like artificial intelligence languages including those requiring a high 
degree of parallelism. 	the efficiency is gained without loss of programming generality because 
it only makes certain actors more efficient; it does not change their behavioral 
characteristics. the architecture is general with respect to control structure and does not have or need goto  interrupt  or semaphore primitives. the formalism achieves the goals that 
the disallowed constructs are intended to achieve by other more structured methods. planner progress 
 programs should not only work  but they should appear to work as well.  
pdp-1x dogma 
　　　　the planner project is continuing research in natural and effective means for embedding knowledge in procedures. in the course of this work we have succeeded in unifying the 
formalism around one fundamental concept: the actor. 	intuitively  an actor is an active agent 
which plays a role on cue according to a script  we  use the actor metaphor to emphasize the inseparability of control and data flow in our model. data structures  functions  semaphores  
monitors  ports  descriptions  quillian nets  logical formulae  numbers  identifiers  demons  processes  contexts  and data bases can all be shown to be special cases of actors. all of the 
above are objects with certain useful modes of behavior. 	our formalism shows how all of the 
modes of behavior can be defined in terms of one kind of behavior: sending messages to actors. an actor is always invoked uniformly in exactly the same way regardless of whether 1t behaves as a recursive function  data structure  or process. 
 it is vain to multiply entities beyond need.  
william of occam 
 monotheism is the answer.  
　　　　the unification and simplification of the formalisms for the procedural embedding of knowledge has a great many benefits for us: 
　　　　foundations: the concept puts procedural semantics  the theory of how things operate  on a firmer basis. it will now be possible to do cleaner theoretical studies of the relation between procedural semantics and set-theoretic semantics such as model theories of the quantificational calculus and the lambda calculus. 
　　　　logical calculae: a procedural semantics is developed for the quantificational calculus. the logical constants for-all  there-exists  and  or  not  and implies 
are defined as actors. 
　　　　knowledge based programming is programming in an environment which has a substantial knowledge base in the application area for which the programs are intended. 
the actor formalism aids knowledge based programming in the following ways-. procedural embedding of knowledge  tracing behavioral dependencies  and substantiating that actors satisfy their intentions. 
　　　　intentions: 	furthermore the confirmation of properties of procedures is made easier and more uniform. 	every actor has an intention which checks that the prerequisites 
and the context of the actor being sent the message are satisfied. the intention is the contract that the actor has with the outside world. how an actor fullfllls its contract is its own business. by a simple bug we mean an actor which does not satisfy its intention. 
we would like to eliminate simptedebugging of actors by the meta-evaluation of actors to show that they satisfy their intentions. suppose that there is an external audience of actors e 
which satisfy the intentions of the actors to which they send messages. intuitively  the principle of actor induction states that the intentions of all actions caused by e are 
in turn satisfied provided that the following condition holds: if for each actor a the intention of a is satisfied =  that the intentions of all actors sent messages by a are satisfied. computational induction  manna   structural induction  burstall   and peano induction are all special cases of actor induction. 	actor based intentions have the following 
advantages: 	the intention is decoupled from the actors it describes. 	intentions of 
concurrent actions are more easily disentangled. we can more elegantly write intentions 
for dialogues between actors. 	the intentions are written 1n the same formalism as the 
procedures they describe. thus for example intentions can have intentions. because protection is an intrinsic property of actors  we hope to be able to deal with protection issues in the same straight forward manner as more conventional intentions. intentions 
of data structures are handled by the same machinery as for all other actors. 
	comparative schehatology: 	the theory of comparative power of control structures is 
1 
extended and unified. the following hierarchy of control structures can be explicated by 
incrementally increasing the power of the message sending primitive: 
iterative---recursive---backtrack---+determinate- --universal 
　　　　education: the model is sufficiently natural and simple that it can be made the conceptual basis of the model of computation for students. in particular it can be used as 
the conceptual model for a generalization of seymour papert's  little man  model of logo. the model becomes a cooperating society of  little men  each of whom can address others with whom it is acquainted and politely request that some task be performed. 
　　　　learning and modularity: actors also enable us to teach computers more easily because they make it possible to incrementally add knowledge to procedures without having 
	to rewrite all the knowledge which the computer already possesses. 	incremental extensions 
can be incorporated and interfaced in a natural flexible manner. protocol abstraction  hewitt 1; hart  nilsson  and fixes 1  can be generalized to actors so that procedures with an arbitrary control structure can be abstracted. 
extendability: 	the model provides for only one extension mechanism: 	creating new actors. 	however  this mechanism is sufficient to obtain any semantic extension that might 
be desired. 
　　　　privacf and protection: actors enable us to define effective and efficient protection schemes. 	ordinary protection falls out as an efficient intrinsic property of actors. 	the protection is based on the concept of  use . 	actors can be freely passed out since they will work only for actors which have the authority to use them. 	mutually suspicious  memoryless  subsystems are easily and efficiently implemented. 	actors are at least as powerful a protection mechanism as domains  schroeder  needham  etc.   access 
control lists  multics   objects  wulf 1   and capabilities  dennis  plummer  lampson . because actors are locally computationally universal and cannot be coerced there is reason to believe that they are a universal protection mechanism in the sense that all other protection mechanisms can be efficiently defined using actors. the most important issues in privacy and protection that remain unsolved are those involving intent and trust. we 
are currently considering ways in which our model can be further developed to address these problems. 
　　　　synchronization: 	it provides at least as powerful a synchronization mechanism as the multiple semaphore p operation with no busy waiting and guaranteed first in first out discipline on each resource. 	synchronization actors are easier to use and substantiate than semaphores since they are directly tied to the control-data flow. 
　　　　simultaneous goals: 	the synchronization problem is actually a special case of the simultaneous goal problem. 	each resource which is seized is the achievement and 
maintenance of one of a number of simultaneous goals. recently sussman has extended the previous theory of goal protection by making the protection guardians into a list of predicates which must be re-evaluated every time anything changes. we have generalized 
protection in our model by endowing each actor with a scheduler. we thus retain the advantages of local intentional semantics. a scheduler actor allows us to 
program excuses for violation in case of need and to allow negotiation and re-negotiation between the actor which seeks to seize another and its scheduler. richard waldinger has pointed out that the task of sorting three numbers is a very elegant simple example 
illustrating the utility of incorporating these kinds of excuses for violating protection. resource allocation: each actor has a banker who can keep track of the resources used by the actors that are financed by the banker. 
　　　　structuring: 	the actor point of view raises some interesting questions concerning the structure of programming. 
　　　　　　structured programs: we maintain that actor communication is well-structured. having no goto  interrupt  semphore  etc. constructs  they do not violate  the letter of the law.  some readers will probably feel that some actors exhibit  undisciplined  control flow. these distinctions can be formalized through the mathematical discipline of comparative schematology  patterson and hewitt . 
structured programming: some authors have advocated top down programming. we 
find that our own programming style can be more accurately described as  middle out . 
we typically start with specifications for a large task which we would like to program. we refine these specifications attempting to create a program as rapidly as possible. this initial attempt to meet the specifications has the effect of causing us to change the specifications in two ways: 
　　　　1: more specifications  features which we originally did not realize are important  are added to the definition of the task. 
　　　　1: the specifications are generalized and combined to produce a task that is easier to implement and more suited to our real needs. 
　　　　implementation: actors provide a very flexible implementation language. in fact we are carrying out the implementation entirely in the formalism itself. by so doing we obtain an implementation that is efficient and has an effective model of itself. the 
efficiency is gained by not having to incur the interpretive overhead of embedding the 
	implementation in some other formalism. 	the model enables the formalism to answer 
questions about itself and to draw conclusions as to the impact of proposed changes in the implementation. 
　　　　architecture: 	actors can be made the basis of the architecture of a computer which means that all the benefits listed above can be enforced and made efficient. programs 
	written for the machine are guaranteed to be syntactically properly nested. 	the basic unit 
of execution on an actor machine is sending a message in much the same way that the basic 
1 
	unit of execution on present day machines is an instruction. 	on a current generation 
machine in order to do an addition an add instruction must be executed; so on an actor machine a hardware actor must be sent the operands to be added. there are no goto  semaphore  interrupt  etc. instructions on an actor machine. an actor machine can be built using the current hardware technology that is competitive with current generation machines. 
	 now! now!  cried the queen. 	 faster! faster!  
lewis carroll 
　　　　current developments in hardware technology are making it economically attractive to run many physical processors in parallel. this leads to a  swarm of bees  style of programming. the actor formalism provides a coherent method for organizing and 
controlling all these processors. one way to build an actor machine is to put each actor on a chip and build a decoding network so that each actor chip can address all the others. in certain applications parallel processing can greatly speed up the processing. for example with sufficient parallelism  garbage collection can be done 1n a time which is 
proportional to the logarithm of the storage collected instead of a time proportional to the amount of storage collected which is the best that a serial processor can do. also the 
architecture looks very promising for parallel processing in the lower levels of computer 
audio and visual processing. 
 all the world's a stage  
and all the men and women merely actors. 
they have their exits and their entrances; and one man in his time plays many parts.  
 if it waddles like a duck  quacks like a duck  and otherwise behaves like a duck; then you can't tell that it isn't a duck.  
adding and reorganizing knowledge 
　　　　our aim is to build a firm procedural foundation for problem solving. the foundation attempts to be a matrix in which real world problem solving knowledge can be efficiently and 
naturally embedded. we envisage knowledge being embedded in a set of knowledge boxes with interfaces between the boxes. in constructing models we need the ability to embed more knowledge in the model without having to totally rewrite it. certain kinds of additions can be 
easily encompassed by declarative formalisms such as the quantificational calculus by simply adding more axioms. 	imperative formalisms such as actors do not automatically extend so easily. 	however  we are implementing mechanisms that allow a great deal of flexibility in adding new procedural knowledge. 	the mechanisms attempt to provide the following abilities; 
　　　　procedural embedding:. they provide the means by which knowledge can easily and naturally be embedded in processes so that it will be used as intended. 
　　　　conservative extension: they enable new knowledge boxes to be added and interfaced between knowledge  foxes. 
　　　　modular connectivity: they make it possible to reorganize the interfaces between knowledge boxes. 
　　　　modular equivalence: they guarantee that any box can be replaced by one which satisfies the previous interfaces. 
　　　　actors must provide interfaces so that the binding of interfaces between boxes can be controlled by knowledge of the domain of the problem. the right kind of interface promotes 
modularity because the procedures on the other side of the interface are not affected so long as the conventions of the interface are not changed. 	these interfaces aid in debugging since traps and checkpoints are conveniently placed there. 	more generally  formal conditions can be stated for the interfaces and confirmed once and for all. 
unification 
　　　　we claim that there is a common intellectual core to the following  now somewhat isolated  fields that can be characterized and investigated: 	digital circuit designers  data 
base designers  computer architecture designers  programming language designers  computer 
system architects. 
　　　　 our primary thesis is that there can and must exist a single language for software engineering which is usable at all stages of design from the initial conception through to the final stage in which the last bit 1s solidly 1n place on 
some hardware computing system.  
doug ross 
　　　　the time has come for the unification and integration of the facilities provided by the above designers into an intellectually coherent manageable whole. current systems which separate the following intellectual capabilities with arbitrary boundaries are now obsolete.  know thyself . 
we intend that our actors should have a useful working knowledge of themselves. 	that is  they should be able to answer reasonable questions about themselves and be able to trace the 
implications of proposed changes in their intentions. it might seem that having the implementation understand itself is a rather incestuous artificial intelligence domain but we 
	believe that it is a good one for several reasons. 	the implementation of actors on a 
	conventional computer is a relatively large complex useful program which is not a toy. 	the 
	implementation must adapt itself to a relatively unfavorable environment. 	creating a model of 
itself should aid in showing how to create useful models of other large knowledge based programs 
	since the implementation addresses a large number of difficult semantic issues. 	we have a 
number of experts on the domain that are very interested 1n formalizing and extending their knowledge. 	these experts are good programmers and have the time  motivations  and ability to 
1 
embed their knowledge and intentions in the formalism. 
 the road to hell is paved with good intentions.  
once the experts put in some of their intentions they find that they have to put in a great deal more to convince the auditor of the consistency of their intentions and procedures. in this way we hope to make explicit all the behavioral assumptions that our implementation 1s 
relying upon. the domain is closed 1n the  sense  that the questions that can reasonably be 
asked do not lead to a vast body of other knowledge which would have to be formalized as well. the domain is limited in that 1t is possible to start with a small superficial model of actors and build up incrementally. any advance is immediately useful in aiding and motivating future advances. there 1s no hidden knowledge as the formalism is being entirely implemented in itself. the task is not complicated by unnecessary bad software engineering practices such as the use of gotos  interrupts  or semaphores. 
intrinsic computation 
　　　　we are approaching the problem from a behavioral  procedural  as opposed to an axiomatic approach. our view is that objects are defined by their actors rather than by axiomatizing the properties of the operations that can be performed on them.  ask not what you can do to some actor; but what the actor can  will   do for you.  
alan kay has called this the intrinsic as opposed to the extrinsic approach to defining objects. our model follows the following two fundamental principles of organizing behavior: 
control flow and data flow are inseparable. 
　　　　computation should be done intrinsically instead of extrinsically i.e.  every actor should act for himself or delegate the responsibility  pass the buck  to an actor 
who will.  
although the fundamental principles are very general they have definite concrete consequences. for example they rule out the goto construct on the grounds that it does not allow a message to be passed to the place where control is going. 	thus it violates the inseparability of control 
and data flow. also the goto defines a semantic object  the code following the tag  which is not properly syntactically delimited thus possibly leading to programs which are not properly syntactically nested. similarly the classical interrupt mechanism of present day machines 
violates the principle of intrinsic computation since it wrenches control away from whatever 
instruction is running when the interrupt strikes. 
hierarchies 
the model provides for the following orthogonal hierarchies: 
　　scheduling: every actor has a scheduler which determines when the actor actually acts after it 1s sent a message. the scheduler handles problems of synchronization. another job of the scheduler  rulifson  is to try to cause actors to 
act in an order such that their intentions will be satisfied. 
　　intentions: every actor has an intention which makes certain that the prerequisites and context of the actor being sent the message are satisfied. intentions provide a certain amount of redundancy in the specifications of what is supposed to happen. 
　　monitoring: every actor can have monitors which look over each message sent to the actor. 
　　binding: every actor can have a procedure for looking up the values of names that occur within 1t. 
　　resource management: every actor has a banker which monitors the use of space and time. 
note that every actor had all of the above abilities and that each is done via an 
actor! 
	 a slow sort of country!  said the queen. 	 now here  you see  it 
takes all the running you can do  to keep in the same place. 	if you want to get somewhere else  you must run at least twice as fast as that!  
lewis carroll 
　　　　the previous sentence may worry the reader a bit as she  he  might envisage an infinite chain of actions  such as banking  to be necessary in order to get anything done. we short circuit this by only requiring that it appear that each of the above activities 1s done each 
time an actor is sent a message. 
 there's no use trying   she said:  one can't believe impossible 
things.  
	 i daresay you haven't had much practice   said the queen. 	 when i 
	was your age  i always did it for half-an-hour a day. 	why  sometimes i've 
believed as many as six impossible things before breakfast.  
lewis carroll 
　　　　each of the activities is locally defined and executed at the point of invocation. this allows the maximum possible degree of parallelism. our model contrasts strongly with extrinsic quantlficatlonal calculus models which are forced into global noneffective statements 1n order to characterize the semantics. 
 global state considered harmful.  
　　　　we consider language definition techniques  such as those used with the vienna definition language  that require the semantics be defined in terms of the global computational state to be harmful. formal penalties  such as the frame problem and the definition of simultaneity  must be paid even if the definition only effectively modifies local parts of the 
state. 	local intrinsic models are better suited for our purposes. 
1 
hardware 
　　　　procedural embedding should be carried to its ultimate level: the architecture of the machine. conceptually  the only objects in the machine are actors. in practice the machine recognizes certain actors as special cases to save speed and storage. we can easily reserve a portion of the name space for actors implemented in hardware. 
syntactic sugar 
 what's the good of mercator's north poles and equators  
tropics  zones and meridian lines   
so the bellman would cry: and the crew would reply 
 they are merely conventional signs!  
lewis carroll 
　　　　thus far 1n our discussion we have discussed the semantic issues intuitively but vaguely. we would now like to proceed with more precision. 	unfortunately in order to do this it seems necessary to introduce a formal language. 	the precise nature of this language 1s completely unimportant so long as it 1s capable of expressing the semantic meanings we wish to convey. 	for some 
years we have been constructing a series of languages to express our evolving understanding of the above semantic issues. the latest of these is called planner-1. 
　　　　meta-syntactic variables will be underlined. we shall assume that the reader 1s familiar with advanced pattern matching languages such as sn1l1  convert  qa1  and planner-1. 
　　　　we shall use  %a m%  to indicate sending the message m to the actor a. we shall use  s1 s1 ... sn  to denote the finite sequence s1  s1   ... sn. ft sequence s is an actor where  %s  i%  is element i of the sequence s. for example  % a c b  1%  is c. we will use     to delimit the 
simultaneous synchronous transmission of more than one message so that  al a1...an  will be 
defined to be  %a1  a1 ... an % . the expression  %a1 a1 ... an%   read as   a  then a1 ... finally send back an   willi be evaluated by evaluating al  a1  .... and an in sequence and then sending back   returning   the value of an as the message. 
　　　　identifiers can be created by the prefix operator =. for example if the pattern = x 1s matched with y  then a new identifier is created and bound to v. 
　　 but 'glory' doesn't mean 'a nice knock-down argument   alice objected. 
 when i use a word   humpty dumpty said  in rather a scornful tone  
 it means just what i choose 1t to mean-neither more nor less.  
　　 the question is   said alice   whether you can make words mean so many different things.  
　　 the question is   said humpty dumpty   which is to be master-that's all.  
lewis carroll 
humpty dumpty propounds two criteria on the rules for names: 
each actor has complete control over the names he uses. 
all other actors must respect the meaning that an actor has chosen for a name. 
we are encouraged to note that in addition to satisfying the criteria of humpty dumpty  our names also satisfy those subsequently proposed by bill wulf and mary shaw: the default is not necessarily to 
extend the scope of a name to any other actor. the right to access a name is by mutual agreement between the creating actor and each accessing actor. an access right to an actor and one of its acquantances is decoupled. it is possible to distinguish different types of access. the definition of a 
name  access to a name  and allocation of storage are decoupled. 	the use of the prefix = does not imply 
the allocation of any storage. 
　　　　one of the simplest kinds of actors is a cell. a cell with initial contents v can be created by evaluating  cell v  . given a cell x  we can ask it to send back its contents by evaluating 
 contents xj which is an abbreviation for  x #contents . for example  contents cell 1   evaluates to 1. we can ask it to change its contents to v by evaluating  x-y  . for example if we let x be  cell 1  and evaluate  x--1   we will subsequently find  that  contents x  will evaluate to 1. 
　　　　the pattern  by-reference p  matches object e  1f the pattern pmatches  cell e  i.e. a  cell   see below  which contains e. thus matching the pattern  by-reference =x  against e 1s the same as binding x to  cell e  i.e. a new cell which contains the value of the expression e.we shall use =   read as  receive message   to mean an actor which is reminiscent of the actor lambda in the lambda calculus. for example  =  x body  1s like  lambda x body  where x 1s an identifier. an expression  =  pattern body  is an abbreviation for  receive { #message pattern } body  where receive 1s a more general actor that is capable of binding elements of the action in addition to the message. 
evaluating 
 % =  pattern body  the-messaqe%   i.e. sending 
　　　　 =  pattern body  the-message  will attempt to match the-message against pattern. if the-message is not of the form specified by pattern  then the actor is not applicable to the-message. if the-message 
matches pattern  then body 1s evaluated. 
　　　　evaluating  % cases  f1 f1     fn   arg%  will send fl  the message arg and if it is not applicable then it will send f1 the message arg ...  and send fn the message aro 
the following abbreviations will be used to improve readability: 
 rules object clauses  for 
  cases clauses object  
 let object pattern-for-message body  for 
 % =  pattern-for-message body  objects  
1 



message mechanisms of the current small talk machine of alan kay and the port mechanism of krutat and balzer. being free of side effects allows us a maximum of parallelism and allows an actor to be engaged in several conversations at the same time without becoming confused. 
　　　　1: sending a message to an actor makes no presupposition that the actor sent the message will ever send back a message to the continuation. the unidirectional nature of sending messages enables us to define iteration  monitors  coroutines  etc.straight forwardly  
　　　　1: the actor model is nojt an  environment-pointer  instruction-pointer  model such as the contour model. a'continuation is a full blown actor  with all the rights and privileges ; it is not a program counter. there are no instructions  in the sense of present day machines  in our model. instead of instructions  an actor machine has certain primitive actors built in hardware. 
logic 
 it is behavior  not meaning  that counts.  
　　　　we would like to show how actors represent formulas in the quantificational calculus and how the rules of natural deduction follow as special cases from the mechanism of extension 
worlds. we assume the existence of a function anonymous which generates a new name which has 
never before been encountered. consider a formula of the form  every phi  which means that for every x we have that  phi x  is the case. the formula has two important uses: it can be asserted and it can be proved. we shall use an actor  =   read as  accept request   with the syntax 
　　　　  =  pattern-for-request body  for procedures to be invoked by pattern directed invocation by a command which matches pattern-for-request. 
　　　　our behavioral definitions are reminiscent of classical natural deduction except that we have four introduction and elimination rules  prove  disprove  assert  and deny  to give us more flexibility in dealing with negation. 
 then logic would take you by the throat  and force you to do it!  
lewis carroll 
data bases 
　　　　data bases are actors which organize a set of actors for efficient retrieval. there are two primitive operations on data bases: put and get. a new virgin data base can be 
created by evaluating  virgin . if we evaluate  w +＊  virgin   then  contents w  will be a virgin world. we can put an actor  at john airport  in the world  contents w  by evaluating 
 put at john airport  { #world{contents w    . we could add further knowledge by evaluating  put  at airport boston  { #world  contents w     to record that the airport is at boston. 
　　　　 put {city boston  { #world  contents w     to record that boston is a city. if the constructor extension is passed a message then it will create a world which is an extension of its message. eor example 
 put 
  on john  flight 1   
　　　　 extension-world ＊*-  contents w     will set extension-world to a new world in which we have supposed that john is on flight #1. the world  contents w  is unaffected by this operation. on the other hand the extension world is affected if we do  put   hungry john   contents w   . extension worlds are very good for modeling the following: 
world directed invocation 
　　　　the extension world machinery provides a very powerful invocation and parameter passing mechanism for procedures. the idea is that to invoke a procedure  first grow an 
extension world; then do a world directed invocation on the extension world. this mechanism generalizes the previous pattern directed invocation of planner-1 several ways. pattern directed invocation is a special case in which there is just one assertion in the wish world. world directed invocation represents a formalization of the useful problem solving technique known as  wishful thinking  which is invocation on the basis of a 
fragment of a micro-world. terry winograd uses restriction lists for the same purpose in his thesis version of the blocks world. suppose that we want to find a bridge with a red top which is supported by its left-leg and its right-leg both of which are of the same 
color. 	in order to accomplish this we can call upon a genie with our wish as its message. the genie uses whatever domain dependent knowledge it has to try to realize the wish.  realize 
 utopia 
 top left-leg right-leg color-of-legs} 
; the variables in the uptopia are listed above  
{ 
 color top red  
 supported-by top left-leg  
'supported-by top right-leg  
;ieft-of left-leg right-leg   color left-leg color-of-legs  kcolor left-leg color-of-legs }   
logical hypotheticals are logically possible alternatives to a world. 
         by the normalization theorem for intuitionistic logic our actor definition of the logical constant implies is sufficient to mechanize logical implication. the rules of natural deduction are a special case of our rules for extension worlds and our procedural 
definition of the logical connectives. 
alternative worlds are physically possible alternatives to a world. 
	perceptual viewpoints can be mechanized as extension worlds. 	for example suppose 
1 
rattle-trap is the name of a world which describes my car. then  front rattle-trap  could be a world which describes my car from the front and  left rattle-trap  can be the description from the left side. we can also consider a future historian's view of the present by  vlew-from-1 world-of-1 . mlnsky  considers these possibilities from 
a somewhat different point of view. 
the following general principles hold for the use of extension worlds: 
　　　　　　each independent fact should be a separate assertion. 	for example to record that  the banana banl is under the table tabl  we would assert: 
 banana banl  table tabl  under banl tabl  
instead of conglomerating  mcdermott 1  them into one assertion: 
 at 
 the banl  1s banl banana   
 place 
 the tabl  is tabl table   under   
a person knowing a statement can be analyzed into the person believing the statement and the statement being true. so we might make the following definition of knowing: 
 know  = 
 =   = person = statement  
 and 
 believes person statement  
 true statement     
thus the statement  moore 1   john knows bill's phone number  can be represented by the assertion: 
　　　　 knows john  phone-number bill pn1   where pn1 is a new name and  phone-number bill pn1  is intended to mean that the 
phone number of bill 1s pn1. the assertion can be expanded as follows: 
 believes john  phone-number bill pn1   
 true  phone-number bill pn1   
however the expansion is optional since the two assertions are not independent of the original assertion. 
 whatever logic is good enough to tell me is worth writing down   said the tortoise.  so enter it in your book  please.  
lewis carroll 
　　　　each assertion should have justifications derivations  which are also assertions and which therefore ... 
　　　　extraneous factors such as time and causality should not  be conglomerated  mcdermott 1  into the extension world mechanism. facts about time and causality should also be separate assertions. in this way we can deal more naturally and uniformly with questions involving more than one time. for example we can answer the question  how many times were there at most two cannibals in the boat while the missionaries and cannibals 
were crossing the river   also we can check the consistency of two different narratives of overlapping events such as might be generated by two people who attended the same party. retreival of actors from data bases takes facts about time and causality into account 1n the retreival. thus we still effectively avoid most of the frame problem of mccarthy. the 
ability to do this is enhanced by the way we define data bases as actors. 
　　　　a context mechanism was invented for qa1 to generalize the property list structure of lisp. rulifson explained 1t by means of examples of its use to mechanize identifiers. by use of the functions push-context and popjontext and an epam discrimination net  feigenbaum and simon  the context mechanism can be used to mechanize a version of tree-structured worlds  the tree-structured worlds of planner-1 were invented to get around the problem of having only one 
global data base not realizing that a context mechanism could be used to implement something like that. the tree-structured worlds were defined directly in terms of the hash-coding 
mechanism of planner which had the advantage of decoupling them from the identifier structure of planner. in addition by not conceiving an extension world analogue of p1p c1ntext large gains in efficiency over the context mechanism are possible. 
　　　　worlds can ask the actors put in them to index themselves for rapid retreival.we also need to be able to retrieve actors from worlds. simple retrieval can be done using patterns. 
for example 
 locations +＊  get  at         { #world  contents w  }   will set locations to an actor which will retrieve all the actors stored in  contents w  which match the pattern  at     {   . now  next locations  will thus retrieve either  at airport boston  or  at john airport . actually* the above 1s an over simplification. we shall let $real1ty stand for the current world at any given point and $utopia stand for the world as we would like to see 1t. we do not want to have to explicity store every piece of knowledge which we have but would like to beable to derive conclusions from what is already known: we 
can distinguish several different classes of procedures for deriving conclusions. 
　　　 mccarthy 1s at the airport.   put  at mccarthy airport   if a person 1s at the airport  then the person might take a plane from the airport  
 put-at    
      put  at = person airport   
 put  might  take-plane-from person airport      
          mccarthy 1s not at the airport.   deny  at mccarthy airport   if a person is not at th airport then he can't take a plane from the airport. 
1 
　　　　 mccarthy is not at the airport.   deny  at mccarthy airport   if a person is not at the airport then he can't take a plane from the airport. 
 deny-at = 
  =   deny  at =person airport   
 put  can't  take-plane-from person airport       
　　　　 it is not known whether mccarthy is at the airport    erase  at mccarthy airport   if it is not known whether a person is at the airport then erase whatever depends on previous knowledge that the person is at the airport  
 erase-at  = 
  =   erase  at -person airport   
 find  depends-on =s  at person airport   
 erase s     
　　　　 get mccarthy to the airport.   achieve { at mccarthy airport  }  to achieve a person at a place: 
find the present location of the person. 
show that it is walkable from the present location to the car. 
show that 1t is drivable from the car to the place  
 achieve-at  = 
  =   achieve   at =person =place     
 achieve 
 find   at person -present-location   
	 show 	{ walkable present-location car } 
 show { drivable car place }       
　　　　 show that mccarthy is at the airport.   show { at mccarthy airport }  to show that a thing is at a place show that the thing is at some intermediate and the intermediate is at the 
place. 
 show-at  = 
  =   show { at =th1ng =place }  
 show { at thing 'intermediate } 
　　　　　　　　　　 show { at intermediate place }     the actor show-at is simply transitivity of at. l! anything really better than anything else  
　　　　conniver can easily be defined trtterms of plawr-1. we do this not because we believe that the procedures of conniver are particularly well designed. indeed we have given reasons above why these procedures are deficient. rather we formally define these procedures 
to show how our model applies even to rather baroque control structures. 
　　　　conniver is essentially the conglomeration of the following ideas: landin's nonhierarchical goto-1  the pattern directed construction  matching  retrieval  and invocation of planner  landin's streams  the context mechanism of qaa  and balzer's and krutar's ports. 
in most cases  two procedures in conniver do not talk directly to each other but instead are required to communicate through an intermediary which is called a possibilities list. 
the concept of a possibilities list is the major original contribution of conniver.  what are these 
so wild and withered in their attire  
that look not like the inhabitants 
　　　　1' the earth  and yet are on't   
macbeth: act 1  scene 1 
substitution  reduction  and meta-evaluation 
 one program's constant is another program's variable.  
alan perils 
 programming  or problem solving in general  is the judicious postponement of decisions and commitments!  
edsger w. dijkstra  
 programming languages should be designed to suppress what is constant and emphasize what is variable.  
alan perlis 
 each constant will eventually be a variable!  
corollary to murphy's law 
　　　　we never do unsubstitution  or if you wish decompilation  unsimpllfication  or unevaluation . we always save the higher level language and resubstltute. the metaphor of substitution followed by reduction gives us a macroscopic view of a large number of computational activities. we hope to show more precisely how all the following activities f i t within the general scheme of substitution followed by reduction: 
　　　　evaluation  church  mccarthy  lnadin  can be done by substituting the message into the code and reducing  execution . 
　　　　deduction  herbrand  godel  heyting. prawltz  robinson  hewitt  weyhrauch and milner  can be done by procedural embedding. in this paper we have extended our previous work by defining the logical constants to be certain actors thus providing a procedural semantics for the quantlficational calculus along the lines indicated by 
natural deduction. 
confirming the consistency of actors and their intentions  naur  floyd  hewitt 
1 
1  waldlnger  deutsch  can be done by substituting the code for the actors into their intentions and then meta-evaluating the code. 
　　　　automatic actor generation. an important corollary of the thesis of procedural embedding is that the fundamental technique of artificial intelligence is automatic programming and procedural knowledge base construction. it can be done by the 
following'  methods: 
　　parameterization  church  mccarthy  landin  mcintosh  manna and waldinger  hewitt  of canned procedure templates. 
　　compilation  lombardi  elcock  fikes  daniels  wulff  reynolds  and wegbreit  can be done by substituting the values of the free variables in the code and then reducing  optimizing . for examples we can enhance the behavior of the lists which were behaviorally defined above to vectors which will run 
more efficiently on current generation machines. 
　　abstract impossibilities removal can be done by binding the alternatives with the code and deleting those which can never succeed  what we 
have in mind are situations such as having simultaneous subgoals  on a b  and  on b c  where we can show by meta-evaluation that the order given above can never succeed. 	gerry sussman has designed a program which attempts to abstract this fact from running on concrete examples. 	we believe that in this case and 
many others it can be abstractly derived by meta-evaluation. 
　　example expansion  hart  nilsson  and fikes 1; sussman 1; hewitt 1  can be done by binding the high level goal oriented language to an example problem and then reducing  executing and expanding to the paths executed  using world directed invocation  or some generalization  to create linkages between the variablized special cases. 
　　protocol abstraction  hewitt 1  1  can be done by binding together the protocols  reducing the resulting protocol tree by identifying 
indistinguishable nodes. 
　　abstract case generation to distinguish the methods to achieve a goal can be done by determining the necessary pre-conditions for each method by reducing to a decision tree which distinguishes each method. 
acknowledgements 
 everything of importance has been said before by somebody who did not discover it.  
alfred north whitehead 
　　　　this research was sponsored by the mit artificial intelligence laboratory and project mac under a contract from the office of naval research. we would be very appreciative of any comments  criticisms  or suggestions that the reader might care to offer. please address them to: 
carl hewitt 
room 1 
1 technology square 
m.i.t. artificial intelligence laboratory 
cambridge  massachusetts 1 
　　　　the topics discussed in this paper have been under intense investigation by a large number of researchers for a decade. in this paper we have merely attempted to construct a coherent manageable formalism that embraces the ideas that are currently  in the air . 
　　　　we would like to acknowledge the help of the following colleagues: bill gosper who knew the truth all along:  a data structure is nothing but a stupid programming language.  alan kay whose flex and small talk machines have influenced our work. alan emphasized the crucial importance of using intentional definitions of data structures and of passing messages to them. this paper explores the consequences of generalizing the message mechanism of small talk and simula-1; the port mechanism of krutar  balzer  and mitchell; and the previous call statement of planner-1 to a universal communications mechanism. alan has been extremely helpful in discussions both of overall philosophy and technical details. nick pippenger for his very beautiful iterate statememt and for helping us to find a fast economical decoding net 
for our actor machine. john mccarthy for making the first circular definition of an effective problem solving formalism and for emphasizing the importance of the epistemological problem for artificial intelligence. seymour papert for his  little man  metaphor for computation. allen newell whose kernel approach to building software systems has here perhaps been carried to near its ultimate extreme along one dimension. david marr whose penetrating questions led us to 
further discoveries. rudy krutar  bob balzer  and jim mitchell who introduced the notion of a port which we have generalized into an actor. robin milner is tackling the problems of lvalues and processes from the point of view of the lambda calculus. he has enphasized the practical as well as the theoretical implications of fixed point operators. robin's puzzlement over the meaning of  equality  for processes led to our definition of behavior. edsger dijkstra 
for a pleasant afternoon discussion. 	jim mitchell has patiently explained the systems 
implementation language mps. 	jeff rulifson  bruce anderson  gregg pfister  and julian davies 
showed us how to clean up and generalize certain aspects of planner-1. peter landin and john reynolds for emphasizing the importance of continuations for defining control structures. warren teitleman who cleaned up and generalized the means of integrating editors and debuggers in higher level languages. peter landin  arthur evans  and john reynolds for emphasizing the 
importance of  functional  data structures. 	danny bobrow and ben wegbreit who originated an 
implementation method that cuts down on some of the overhead. we have simplified their scheme 
1 
by eliminating the reference counts and all of their primitives  	c. a. r. hoare 1s independently 
investigating  monitors  for data structures. jack dennis for sharing many of our same goals in his common base language and for his emphasis on logical clarity of language definition and the importance of parallelism. bill wulff for our  .  notation on the conventions of the values of cells and for being a strong advocate of exceptional cleanliness in language. pitts jarvis and richard greenblatt have given us valuable help and advice on systems aspects. todd matson  brian smith  irene grief  and henry baker are 
aiding us 1n the implementation. chris reeve  bruce daniels  terry winograd  jerry sussman  gene charniak  gordon benedict  gary peskin  and drew mcdermott for implementing previous generations of these ideas in addition to their own. j.c.r. licklider for emphasizing the importance of mediating procedure calls. butler lampson for the notion of a banker and for the question which led to our criteria for separating an actor from its base. richard weyhrauch for pointing out that logicians are also considering the possibility of 
procedural semantics for logic. he is doing some very interesting research in the much abused field of  computational logic.  terry winograd  donald eastlake  bob frankston  jerry sussman  ira goldstein  and others who made valuable suggestions at a seminar which we gave at m.l.t. john shockley for helping us to eradicate an infestation of bugs from this document. greg pfister  bruce daniels  seymour papert  bruce 
anderson  andee rubin  allen brown  terry winograd  dave waltz  nick horn  ken harrenstien  david marr  ellis cohen  ira goldstein  steve zilles  roger hale  and richard howell made valuable comments and suggestions on previous versions of this paper. 
bibliography 
balzer  r.m.   ports-a method for dynamic interprogram communication and job control the rand corp.  1. 
bishop  peter   data types for programming generality m.s. june 1. m.l.t. 
bobrow d.  and wegbreit ben.  a model and stack implementation of multiple environments.  march 1. 
davies  d.j.m.  popler: a p1p-1planner  mip-1. school of a.i. university of edinburgh. 
     deutsch l.p.  an interactive program verifier  phd. university of california at berkeley. june  1 forthcoming. 
     earley  jay.  toward an understanding of data structures  computer science department  university of california  berkeley. 
     elcock  e.w.; foster  j.m.; gray  p.m.d.; mcgregor  h.h.; and murray a.m. abset  a programming language based on sets: motivation and examples. machine intelligence 1. edinburgh  university press. 
fisher. d.a.  control structures for programming languages  phd. carnegie. 1 gentzen g.  collected papers of gerhard gentzen .north holland. 1. 
greif l.g.  induction in proofs about programs  project mac technical report 1. feb. 1. 
     hewitt  c. and patterson m.  comparative schematology  record of project mac conference on concurrent systems and parallel computation. june 1  1. available from acm. 
     hewitt  c.  bishop p.  and steiger r.  the democratic ethos or 'how a society of noncoercable actors can be incorporated into a structured system'  sigplan-sigops interface meeting  savannah  georgia. april  1. 
     hewitt  c  and greif i.  actor induction and meta-evaluation acm sigact-sigplan symposium on principles of programming languages. boston  mass- oct  1. forthcoming. 
hoare  c.a.r.  an axiomatic definition of the programming language pascal  feb. 1. 
kay  alan c. private communication. 
krutar  r.  conversational systems programming  or program plagiarism made easy   first usa-japan 
computer conference. 	october 1  
lampson  b.  an overview of cal-tss . computer center  university of california  berkeley. 
liskov  b.h.  a design methodology for reliable software systems  the last fjcc. dec.1. pt. 1  1. mcdermott d.v.  assimilation of new information by a natural language-understanding system  m.s. mit. 
forthcoming 1. 
mcdermott  d.v. and sussman g.j.  the conniver reference manual  a.i. memo no. 1. 1. 
milner  r. private communication. 
minsky  marvin.  frame-systems: a theory for representation of knowledge  forthcoming 1. 
mitchell  j.g.  a unified sequential control structure model  nic 1. forthcoming. 
newell  a.  some problems of basic organization in problem-solving programs.  self-organizing systems. 1. 
papert s. and solomon c.  nim: a game-playing program  a.i. memo no. 1. 
     reynolds  j.c.  definitional interpreters for higher-order programming languages  proceedings of acm national convention 1. 
     rulifson johns f.  derksen j.a.  and waldinger r.j.  qa1: a procedural calculus for intuitive reasoning  phd. stanford. november 1. 
scott  d.  data types as lattices  notes. amsterdam  june 1. 
steiger  r.  actors . m.s. 1. forthcoming. 
sussman  g.j.  teaching of procedures-progress report  oct. 1. a.i. memo no. 1. 
waldinger r. private communication. 
wang a. and dahl 1.  coroutine sequencing in a block structured environment  bit 1-1. 
     weyhrauch  r. and milner r.  programming semantics and correctness in a mechanized logic.  first usa-japan computer conference. october 1. 
     winograd  t.  procedures as a representation for data 1n a computer program for understanding natural language  mac tr-b1. february 1. 
w1rth  n.  how to live without interrupts  or some such. vol. 1  no. 1  pp. 1. 
wulf w. and shaw m.  global variable considered harmful  carnegie-mellon university. pittsburgh  pa. 
sigplan bulletin. 1. 
1 
