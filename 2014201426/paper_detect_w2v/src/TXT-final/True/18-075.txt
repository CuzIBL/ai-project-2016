 
this paper describes span  a system designed to integrate a variety of problem solving tactics in a coherent package. the paper discusses some of the tactics that had been used in previous systems to overcome the combinatorial explosion that is inherent in any planning problem. it then continues with a description of span architecture. two case studies are presented. the first  from the blocks world  is already implemented  and the second  from the domain of bridge playing  is in the coding stage. span's limitations are discussed and directions for further research are considered. 
	i 	introduction 
much of the activity in artificial intelligence can be thought of as problem solving  so it is not surprising that  over the years  a lot of effort has gone into developing automatic problem-solvers. these efforts at producing domainindependent techniques usually have concentrated on solving simple problems. 
in a 1 revision of an article first published in 1  earl 
sacerdoti presented an overview of problem-solving tactics  sacerdoti 1   sacerdoti 1 . in that paper he states: 
 to date  there has been no successful attempt known to this author to integrate a significant number of the tactics we have described into a single system.  
this failure to integrate these tactics into a coherent package has been one of the main reasons that general domain-independent planning has met with limited success in solving non-trivial problems. 
span is a system for integrating a large variety of tactics into a cohesive package. the general architecture  along with those domain-independent parts necessary for planning in the relatively simple domain of the blocks world have been already implemented in the loops programming language on the 1 series xerox personal work stations. other domain-independent parts necessary for planning in more complex domains are currently being added. 
span's architecture allows us to combine the insights developed in sacerdoti's noah  sacerdoti 1   sussman's hacker  sussman 1   and waldinger's goal regression system  independently developed by warren  waldinger 1  
¡¡this work was funded in part by nasa grant #nag 1  darpa contract #n1-o1. and a fellowship from nl-industries. computing resources were supplied by xerox-parc and the sumex computing facility at stanford  nth grant #rr-1-ll . 
  warren 1  ; all of which were for ordering conjunctive sub-problems. the same framework is used to integrate these methods with tactics for choosing between alternatives. these techniques include splicing alternatives together  when neither is guaranteed to succeed   in addition to domainspecific comparisons of probability. a generalization of berliner's b* algorithm  berliner 1  can also be integrated into the system  to facilitate planning in a competitive domain. 
ii 	handling the combinatorial explosion 
typically  the world is modeled by a series of propositions which describe what is true in the world  i.e. its state  at a particular time. an action is usually modeled as a 
transformation from propositions that hold in one world model to propositions that hold in the new world model after the action has been executed. these transformations are referred to as operators. 
it may be the case that an operator requires certain conditions to be true in order for its action to be executable. these conditions are referred to as preconditions. an operator can be viewed as a solved problem  with the initial state specified by the preconditions  and the goal specified by the initial state and the transformation of the propositions. 
in the simplest planning case  each operator corresponds to a single action in the real world. these operators are known as primitive operators. typically  in any one state many different operators can be applied because their preconditions are true. furthermore  it is not always clear which operator gets one closer to the goal state. for this reason  simple search techniques face a combinatorial explosion  and thus are unable to solve anything other than very elementary problems. 
much of the history of planning has been concerned with getting around this combinatorial explosion  and thus increasing the applicability of automatic problem solvers. three ideas  in particular  have been useful in dampening the explosion. the first of these is the concept of abstraction. the second is the notion that some subproblems  particularly the difficult ones  can constrain the number of solutions to other sub-problems  and so should be tackled first. the third is the idea that  if possible  one should always apply the best operator for getting from the initial state to the goal. 
the advantage of abstraction is quite simple. if one can break down a large problem into a series of smaller problems  then solving all of the smaller problems will be easier than solving the original problem. the reason for this is that the breakdown into smaller problems is linear  whereas the effort to solve any particular problem is exponential. 
1 	d.berlin 
many versions of abstraction exist  including ignoring some details in the state description  ignoring some operators  or combining some operators to form a macro-operator. in the end  all of these techniques are equivalent to creating abstract operators. an abstract operator is like a primitve operator in that it has preconditions and transformation rules. however  unlike primitive operators  it cannot be translated immediately into actions that can be carried out in the real world. instead  it must be refined into a sequence of primitive operators. these primitive operators may add further preconditions of their own  and may specify further transformations. thus an abstract operator has abstracted out some of the detail involved in solving the problem it addresses. this notion of abstraction is at the heart of criticality lists in abstrips  sacerdoti 1  and the generalisation of the logic operators in gps  ernst 1 . 
the second point  that some problems constrain others  is used to determine which sub-problem to attack first. this is closely related to abstraction  since one of the criteria for defining an abstract operator is that it restrict the number of options available to solve other problems. indeed  one can view a partial ordering of which sub-problems to attack first as a mapping of the initial problem into an abstract domain that ignores the details of the other sub-problems. this point forms the basis of stefik's constraint satisfaction system  stefik 1 . it also forms the basis of an even more extreme form of problem solving: scripts or skeletal plans 
  friedland 1 . with scripts  once the abstract operator  ie. script  has been chosen  all that remains to be done is to instantiate the variables of primitive operations that compose it. the selection of primitive operations to compose the abstract operator is automatic. 
the third point is that it is not always possible to know which operators to choose and in what order to choose them  but that intelligent choice of operators can substantially improve the problem solving. this has led to a number of strategies  including the  don't choose until you have to  strategy of noah  the  make a random choice and fix it later  strategy of hacker  and the  choose an arbitrary order but change the order of the goals as necessary  strategy of waldinger's goal regression system. 
all of these insights and tactics have some merit  but is it possible to develop a system that unites these approaches  making use of each of them when appropriate  span is such a system. 
	hi 	span architecture 
as mentioned earlier  a problem can be represented by an initial state and a goal state. solving the problem consists of finding a sequence of primitive operators  whose consecutive application will result in a final state for which the goal conditions are true. 
at the top level of the span planning system there is a scheduler with an agenda of tasks. these tasks are domain independent  or  more accurately  their domain of expertise is planning. a typical example of a task is ordering conjunctive sub-problems. these tasks are represented as objects with slots to store relevant information. for example  a task to order conjunctive sub-problems will have pointers to the sub-problems. in addition  each task has an attached procedure that performs the task. this procedure is executed when the task is selected from the agenda. 
this mechanism is similar to the meta-planning of molgen  stefik 1   stefik 1 . the agenda here corresponds to its design layer. the problems associated with the tasks correspond to the planning layer  and each system has a simple interpreter. however  in span we have dispensed with a strategy level. in molgen  the only strategy choices available were least-commitment and guessing. not all the design operators are affected by differences in strategies  and local knowledge about the current state of the plan is likely to determine which strategy is the better choice  so this strategy knowledge is dispersed to the procedures that execute the design tasks. as in molgen  preference is given to least-commitment  and arbitrary choices are only made as a last resort. 
the key problem with any agenda-based system is deciding which task to do next. selecting the wrong task can result in a lot of wasted planning effort. several schemes exist for solving this problem. one technique is to provide priorities for each of the types of tasks. unfortunately  global differences in the types of tasks do not always provide sufficient information to get an optimal ordering. another is to poll each active task on the agenda  whose preconditions are satisfied  to see if it should be performed and to choose the one that is most confident the conditions are right for its execution. this involves a large overhead each time a task is to be selected. span actually uses a variant on this second technique: it assumes that each active task is confident that it can be performed  and so selects one at random. however  the procedure that performs the task has the ability to suspend its execution. thus  if a task is selected and decides it should not be done at this time  it has the ability to tell the system to choose another task. this produces a close approximation to the polling system with much less overhead. 
as a result of the decision to randomly choose an active task  the agenda actually consists of three separate lists: a 
list of active tasks  a list of suspended tasks  and a history list of completed tasks. at each cycle the scheduler randomly selects an active task and performs it. if there are no active tasks  then the suspended ones are reactivated. 
we will now examine the various types of planning tasks in span. 
	iv 	planning tasks 
solving a problem  when only the initial stale and goal are known  
the system first checks to make sure that the initial state is completely defined. this means that there is a direct link from the intial state of the original problem to the initial state of this sub-problem  and that this link does not go through unsolved sub-problems. the reason for this is to guarantee that what could be known about the initial state is known. this is not to say that everything about the initial state is known; there might be information that is hidden from the planner  but it does guarantee the system is detecting real differences between the initial state and the goal. if this is not true then the task suspends itself  until such time as it becomes true. 
assuming the initial state is defined  this general problem is approached using means-ends analysis. means-ends analysis is used because it is more flexible than forward or backward chaining. the goal is compared to the initial state and differences are determined. a sub-problem is proposed for each difference detected. these sub-problems are treated as an unordered set of conjunctive goals  whose collective solution constitutes a solution to the original problem. for each of these sub-problems a task is posted to find a sequence of operators that eliminates its difference. this is also known as reducing the difference detected. in addition  if more than one difference was detected  then a task is proposed to order the sub-problems. obviously  if only one such difference was detected  then there is only one subproblem to be ordered. 
reducing a detected difference 
when a difference is detected  a task is posted to reduce that difference. this task indexes a procedure that uses domain-specific knowledge about how to reduce the detected difference. the procedure may do many things. one possibility is to delay its execution  by suspending the task  until further information becomes available from other 

d.berlin 	1 

parts of the plan. if it does execute  it may use a special purpose algorithm  eg. a routing algorithm in a robot planner . alternatively  the procedure may propose an operator or a set of alternative operators. 
proposed operators may be abstract or primitive  and may be related to each other in any one of a number of ways. they may be an unordered set  or in a strict sequence as in a script. 
refining an abstract operator 
when an abstract operator is proposed it needs to be refined. this refinement process invokes a domaindependent procedure. the options available at this time are very similar to the options available when reducing a detected difference. further tests may be performed  or a 
sequence of sub-operators may be proposed. these suboperators may or may not be ordered  and there may or may not be alternative choices available. whenever an unordered sequence is proposed  a task to order the sequence is posted. similarly  whenever a collection of alternatives is proposed  a task to select an alternative is posted. 
ordering sub-problems 
this task corresponds to the problem most often considered in early planning research. the body of its procedure consists of a number of rules for ordering sub-problems. it will suspend itself if none of the rules is applicable  in the hope that eventually information will become available that will aid in this decision. if  since there are no other tasks left to perfom  it is forced to make a choice when no other rules apply  it will do so in an arbitrary manner. 
this task has much the same flavour as the techniques used by sacerdoti in noah  but it also incorporates other techniques  see case study 1 below . choosing from amongst alternatives 
pretty much ignored by mainstream planning  this task becomes crucial when some domain information is inherently uncertain  and thus no plan can be guaranteed to work. in these cases  one must consider strategies involving the gathering of further information  and issues of recoverability from failed plans  rather than just taking the one most likely to succeed. 
	v 	case studies 
we will now present two case studies. the first of these is an english-language trace of one of the blocks world examples that is already running on the system. the second is an example from the domain of declarer play in bridge and whose implementation has not been completed. this second example is more difficult than the blocks world examples  and demonstrates some of the additional issues that a domain-independent planner must address in more complex domains. 
case study 1: blocks world 
consider the following problem from the blocks world: the initial state consists of the block configuration where c is on top of a and block b is sitting separately on the table. this is represented by the conjunction:  on c a   clear b   clear c . the goal is a state in which the conjunction  on a b   on b c  is true. given the operators stack and unstack the solution for this problem is the sequence of actions:  unstack c a   stack b c   stack a b . 

we now present an english-language trace of span solving this problem. this trace assumes that tasks will be chosen from the agenda in the worst possible order  thus demonstrating the system's ability to delay the execution of tasks until an appropriate time. 
initially  the only task on the agenda is to solve this problem. this task is selected and the body of the procedure associated with this task performs means-ends analysis on the problem. the two detected differences are that both  on a b  and  on b c  are initially false and need to be true in the goal state. thus  the procedure creates a sub-problem for each difference detected  and adds to the agenda a corresponding task for each sub-problem to reduce the detected difference. since there is more than one sub-problem  an additional task is posted to order the subproblems. it is the execution of this third task  or its delay in execution  that determines the strategy taken in ordering conjunctive sub-goals. both sacerdoti's and sussman's approach can be implemented this way. merely by changing the body of the procedure associated with this task. as implemented  this procedure in span emphasizes sacerdoti's approach. 
assume the task of ordering the sub-problems is now selected. it will examine the preconditions and goals of the two sub-problems and decide it has no basis for choosing which to do first. it thus defers this decision and is placed on the suspended list. span will try again to order subproblems when there are no other tasks to perform. 
assume that the next task selected is the one associated with the sub-problem of making  on a b  true. the associated procedure uses the on function as an index to any operators that possibly could make  on a b  true. the only one suggested is the stack operator  which has preconditions that a and b both be clear initially. this produces two subproblems: first to get from the initial state to one in which  clear a   clear b  is true and second to get from the state where  clear a   clear b  is true to the goal where  on a b  is true. the second problem is solved by the primitive operator stack. the first results in the posting of a task to solve the problem. 
assume this new task is the next one selected. the initial state of the sub-problem is unknown  since we do not know what actions will be taken from the initial state of the original problem before this sub-problem is tackled. this is a result of leaving unordered the sub-problems of making  on a b  and  on b c  true. the strategy adopted is to delay making a decision by suspending the task. 
1 d. berlin 
the procedure invoked to make  on b c  true opperates in the same way. it suggests the stack operator with preconditions that b and c both be clear; which results in two sub-problems  one solved  and one task. the task  to make the preconditions true  is suspended because the initial state is not completely defined. 
at this point  there are no more active tasks so the three suspended tasks are reexamined. if one of the tasks involving the preconditions is selected  it gets suspended  so we can assume that the ordering sub-problem is the next task selected and actually performed. the associated procedure examines the preconditions of making  on b c  true and notes that this conflicts with the goal of making  on a b  true. thus it decides to order the  on b c  subproblem before the  on a b  problem. 
however  the procedure on ordering sub-problems does more. since stacking b on c is a primitive operation  and thus its exact actions are known  and since the preconditions of  on a b  don't conflict with the goal of  on b c   these preconditions may be regressed back through the body of  stack b on c . the heuristic used is to apply this technique of goal regression whenever possible. the reason is that it allows the earlier steps to reason with a more accurate picture of the complete goal. the result of this goal regression is to change the precondition for making  on b c  true to the conjunct:  clear b   clear c   clear a . now that an ordering for the sub-problems has been established   on b c  is the first sub-problem and its initial state is known to be the initial state of the original problem. thus when the task to solve the problem of making the conjunct  clear b   clear c   clear a  true is selected  the initial state is properly defined. means-ends analysis is applied and the difference detected is that  clear a  is false initially  since  on c a  is true. a task is posted to make  clear a  true. 
clearly this task must make  on c a  false in order to make  clear a  true.  on c a   which is implemented as an object  knows the unstack operator is a way of making the clause false. the task indexes this operator via the on clause. the unstack operator is applied without anv hitches 
and leads to the final plan:  unstack c a   stack b c   stack a b . 
the process of finding this solution applied some of the insights developed by sacerdoti along with the goal regression techniques developed by waldinger  also independently by warren . the reason this system was able to combine these methods was a flexible control structure which allowed procedural information specific to the type of task being performed to be invoked at the correct moment. the efficiency of using meta-level reasoning about planning depends on the tradeoff between the benefits of executing the best task and the costs of  a  reasoning at this level plus  b . partially executing tasks that are later suspended plus  c  deciding to suspend tasks. although this example in the blocks world is too simple to justify the overhead  we believe that  in general  the tradeoff will favor meta-level planning. 
case study 1: bridge 
the proposed architecture handles the previous example very smoothly  but it has been solved by other systems with much less overhead. the justification for the system proposed is the ease with which it can handle more complex problems. consider the following declarer play problem from the game of bridge: 

the contract is 1 no trump by south. the opening lead by west is the king of hearts. 
the declarer  south  needs to win at least nine of the thirteen available tricks to make his contract. he has eight immediate winners; three top spades  three top diamonds  the ace of hearts and the ace of clubs. there are two possible sources for the ninth trick. if the missing diamonds are split 1  then the first three rounds of diamonds will force them all to be played and the fourth diamond in the dummy  north  will be high. if the diamonds are not split evenly this plan fails. 
alternately  if east is holding the king of clubs  then south can lead a club from the dummy  winning the trick with the queen if east plays low and capturing the king with the ace  thus setting up the queen  if east plays the king. if west has the king then this plan fails. 
using techniques similar to those in the previous example  only the operators change   the planning process produces these two alternative plans. in addition  a task is posted to select between the alternatives. the associated procedure with this task first tries to order the alternatives so that if one branch fails the other can still be tried. in this particular case  the system determines that if the diamonds are tried first and don't split  then the club finesse can still be attempted. however  if the club finesse is tried first and fails the declarer may never get a chance to test the diamonds  since  if the hearts are not split 1  the defenders will win at least four hearts in addition to the king of clubs. thus a hybrid plan  to test the diamonds and  if they don't split 1  to take the club finesse  is produced. 
if this attempted hybridization had failed  the sytem would have looked at the relative probabilities of success for each alternative. this comparison could have been made using whatever method of uncertainty measurement was relevant for the particular domain  probably table look-up in this case . 
	vi 	limitations 
the system developed does have some inherent limitations. 
it assumes the world can be modeled as a series of discrete states and that operations on the world can be modeled as a transformation between these states. this discrete time assumption is basic to the model. 
furthermore  the strategies that have been developed have assumed that planning time is free. there is no consideration of limitations on planning resources. there has also been no consideration of the possibility that the world may change while the planning process is going on. these assumptions are not fundamental to the model  but i have not concentrated my efforts on handling these problems. 
	vii 	future work 
as mentioned earlier  this system has been developed in the blocks world domain  and is currently being extended to handle the domain of declarer play for the game of bridge. actual implementation in this domain may suggest better selection criteria for tasks  instead of the random selection now used. it may also confirm  or invalidate  the decision not to bother with an explicit strategy space. 
more importantly  more difficult examples within this domain will push on the strategies for choosing amongst alternative plans. these strategies have not yet been implemented because  in the blocks world domain  there has been no need. 
there will also be an opportunity to expand the types of tasks to include the collection of data and the execution of a partial plan. this interaction with the world will probably necessitate the establishment of priorities within the agenda  since execution tasks should be delayed until after the planning has been done  and some planning should be delayed until after new information that becomes available during the execution process is checked for relevance. 
as a final point  research in the bridge domain will bring the techniques specific to competitive planning into the fold. in particular  the b* algorithm can be adapted to the analysis of interacting hierarchical plans. in some cases it is even possible by graphical analysis of hierarchical plans to determine the critical paths along which two competing plans interact  and thus to avoid most of the combinatorics involved in competitive planning. 
epilog 
danny berlin died in early 1. he had already analyzed the applicability of the b* algorithm and the technique of graphical analysis of interacting plans  but he did not get to complete the implementation of the second example. this paper was written by him. the camera-ready copy was prepared by lucy m. berlin and his advisor bruce g. buchanan. 
