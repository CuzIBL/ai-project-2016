 
this paper proposes logic programs as a specification for robot control. these provide a formal specification of what an agent should do depending on what it senses  and its previous sensory inputs and actions. we show how to axiomatise reactive agents  events as an interface between continuous and discrete time  and persistence  as well as axiomatising integration and differentiation over time  in terms of the limit of sums and differences . this specification need not be evaluated as a prolog program; we use can the fact that it will be evaluated in time to get a more efficient agent. we give a detailed example of a nonholonomic maze travelling robot  where we use the same language to model both the agent and the environment. one of the main motivations for this work is that there is a clean interface between the logic programs here and the model of uncertainty embedded in probabilistic horn abduction. this is one step towards building a decisiontheoretic planning system where the output of the planner is a plan suitable for actually controlling a robot. 
1 	introduction 
since shakey and strips  fikes and nilsson  1   logic and robotics have had a tumultuous history together. while there is still much interest in the use of logic for high-level robotics  e.g.   lesperance et al  1; caines and wang  1    there seems to be an assumption that low-level 'reactive' control is inherently alogical. this paper challenges this assumption. 
　this paper investigates the idea of using logic programs as a representation for the control of autonomous robots. this should be seen as logic programming in the sense of logic + control  kowalski  1 ; we use a logic program to specify what to do at each time  and use an execution mechanism that exploits a derived notion of 'state* in order to make it practical. 
the main highlights of this approach are: 
1. an agent can be seen as a transduction: a function from inputs  sensor values  into outputs  action attempts or 
'scholar  canadian institute for advanced research 
1 action and perception 
actuator settings . these are 'causal' in the sense that the output can only depend on current inputs and previous inputs and outputs. this function will be represented as a logic program specifying how the output at any time is implied by current and previous inputs. the causality ensures that we have acyclic rules. 
1. the logic programs are axiomatised in phase space  dean and wellman  1   the product of space and time  i.e.  the predicates refer to times as part of the axiomatisation  in a similar manner to the event calculus  kowalski and sergot  1 . this allows us to axiomatise persistence as well as accumulation  integration  over time and differentiation with respect to time. 
1. the notion of 'state' is a derived concept; the state is what needs to be remembered about the past in order for the agent to operate in the present. the axiomatisation is in terms of how the 'current' action depends on current inputs and past inputs and other values; the state is derived so that the output  instead of being a function of the current inputs and all past history  is a function of the current inputs and the state. 
1. although the specification of what to do looks like a prolog program  it is not evaluated as a prolog program. instead we exploit the fact that the agent exists in time; that inputs are received in sequence  and that all previous inputs have already been received  and no subsequent inputs have been received  when the agent makes a decision. instead of treating this as a logic program that may need to do arbitrary computation reasoning about the past  we actively maintain a state. the reasoning about what to do at any time depends only on the current inputs and the remembered state. 
this perspective is useful for a number of reasons: 
1. it provides for a representation for an agent's behaviour in a language with a well defined semantics  see  apt and bezem  1  . 
1. it lets us model both the robot and the environment within the same language. the robot axioms can be evaluated in two modes. in the 'situated' mode  the agent gets sensor values directly from the environment  and acts in the environment in simulation mode  we also have a model of the environment  and can run the models together as a simulation of the integrated system. 

1. there is a clean way to integrate this with models of uncertainty  e.g.  for noisy sensors and sloppy and unreliable actuators . the logic programs here are of the form that can be used within a probabilistic horn abduction system  poole  1 . one of the aims of this work is to produce a representation for robot behaviour that is both suitable for controlling a real robot and also can be the output of a decision-theoretic planning system. 
1. the logic programs form an executable specification of what an agent should do. although they can be evaluated reasonably quickly using current logic programming technology  it may be possible to compile these specifications into circuits for robots  in a manner similar to  gaboury  1  . 
1. it shows how two traditions in ai  namely logic-based ai and robot programming   seemingly at odds  can be unified. whether we are successful in this remains to be definition 1 an agent specification module is a tuple  i 1 r l a where 
j is a set of fluents called the inputs. the inputs specify what sensor values will be available at various times. the range the the input trace is the cross product of the ranges of the fluents in the inputs. atom sense  f/  val  t  is true if input fluent fl has value val at time t. 
o is a set of fluents called the outputs. an output is a propositional fluent that specifies actuator settings at various times. these can also be seen as the actions of the agent  in particular  action attempts . the atom do fl  val  t  is true if the agent sets actuator fl to value val at time t  or to 'do' action fl = val at time t. 
r is a set of fluents called the recallable fluents. these are fluents whose previous value can be recalled. recallable fluents will be used to model persistence as well as integration and differentiation. 

seen. in particular  this paper should be seen as a proposal l is a set of fluents called the local fluents. these are fluents and an initial feasibility study - there is still much work that are neither inputs  outputs nor recallable. the predthat remains to be done before this is a competitor for icate val fl  val  t  is true if local fluent fl has value programming robots. 	val at time t. 
a is an acyclic logic program. a specifies how the outputs 
1. inspired by constraint nets  zhang and mackworth  are implied by the inputs  and perhaps previous values 1   this work shows how to model hybrid continuous- of the recallable fluents  using local fluents  arithmetic discrete systems. the axioms will all be true  in the limit  constraints and other  non-temporal  relations as interfor continuous time. we derive discrete events from con- mediaries. tinuous time. 
1 	representation 
the problem that we are trying to solve is to represent  simulate and build an agent that senses and acts in the world. the agent receives a sequence  trace  of inputs  percepts or sensor values  and outputs a sequence  trace  of outputs  actions or actuator settings . 
　we assume a time structure t that is totally ordered and has a metric over intervals. t can either be continuous or discrete. a trace is a function from t into some domain a. 
　a transduction is a function from  input  traces into  output  traces that is 'causal' in the sense that the output at time t can only depend in inputs at times t' where t'   t. an agent will be a specification of a transduction. 
　transductions form a general abstraction of dynamic systems  zhang  1; zhang and mackworth  1; rosenschein and kaelbling  1 . the problem that we consider is to use logic programs to specify transductions. 
　the language that we use is that of acyclic logic programs  apt and bezem  1    with a limited repertoire of predicates that explicitly refer to time. we assume that the acyclicity corresponds to temporal ordering  if time t  is before time t1 then predicates referring to time t  will be lower in the acyclic indexing that those referring to time t1 . we will use negation as failure - for those who do not like this  we mean the completion of the program  which forms a sound and complete semantics for acyclic programs  apt and bezem  1  . the axioms below assume a limited form of arithmetic constraints. a fluent  mccarthy and hayes  1  is a function that depends on time. each fluent has an associated set called the range of the fluent. a propositional fluent is a fluent with range {true false}. syntactically a fluent it a term in our language. 
	poole 	1 


1 	action and perception 

1 truth in the limit 
the axioms given for was and now are incomplete - they do not specify the structure of time. 
　if time is discrete1  then there are no interpretation problems with the axioms above. in particular  we make the predicate time ti  true for each 'time* * . the predicate was always refers to the previous time point  or to the last time point when the value was set   and there is always some finite duration of each time interval. 
　if time is continuous  there are semantic difficulties in interpreting these sentences  in particular the integration and differentiation formulae that allow for the setting of values at each time point . we cannot interpret the integration and differentiation axioms 'in the limit'  as in the limit  v = v1 and t = t ; the integration axioms become cyclic  and tautologies   and the differentiation axioms provide no constraints on the value of df. 
　in order to be able to interpret the above sentences we have to consider the limit as finite discretizations become finer and finer  in the same way that integration is defined . the axioms will talk about what is true for each discretization. the values that 'was' refers to will be well defined for each of these discretizations. the meaning for the continuous case will be what is true in the limit. 
　to define the limit  consider a uniform discretization with time interval dt   1. for each dt we consider the discretization that consists of the time points k x dt for some integer it. 

figure 1: coupled robot and environment 
1 	an example in detail 
we demonstrate the representation using an example of modelling a robot and an environment these two axiomatisations will highlight different features; the robot model will highlight reactive systems with remembered events; the environment model will highlight integration over time. 
　the example is of a maze travelling robot that is continuously trying to go east  i.e.  at 1＜ orientation   but may have to avoid obstacles. the robot can sense obstacles and its direction of travel  but only has control over its direction of steering. 


poole 	1 


1 	action and perception 

1 computation 
if we were to run the above axiomatisation as a prolog program  the code is hopelessly inefficient the problem is that we have to consider all previous times to check whether an event occurred  at least all previous times where inputs arrived . moreover to check whether an event occurred  we have to check all previous times to check whether a previous event occurred. as you can imagine  such computation is hopelessly slow. 
　in order to make this efficient  we take advantage of the fact that we are evaluating in time: at each time all previous observations have arrived and no subsequent observations have arrived. we exploit the fact that all of the references to the past are in terms of of was. instead of using the axioms defining was explicitly  we actively maintain a state  always remembering the latest values that were set. the predicate was can be implemented by looking up the lastest set values. in other words  the set values are remembered forming the state of the agent. the logic program is evaluated by proving the output from the current inputs and the current state. 
　figure 1 shows a simulation of the robot in the maze. it is simulated by discretising time with one time unit intervals. other discretizations  as long as they are not too coarse give similar results. 
　the above simulation  of both the robot and the environment   ran faster than 1 steps per second  on a 1 running sicstus prolog. partial evaluation should be able to speed this up  and it seems that it should be possible to compile the logic program specification into hardware  as does  gaboury  1  . thus it seems as though the logical specification of robot action is not impractical from an efficiency point of view. 
1 discussion and comparison 
this paper is not intended to just define yet another robot programming language. let us take the very general view of an agent as a 'causal' function from input history to outputs  zhang and mackworth  1; rosenschein and kaelbling  1 . suppose we want to use logic as a formal specification for the actions of the robot  for example in order to prove theorems about the robot behaviour. if we are to treat values of the inputs at various times and values of the outputs at various times as propositions  then the constraint imposed by the robot function is that it can't be the case that the inputs have certain values and the output is not the appropriate function of the inputs; but this is exactly the definition of a definite clause: inputs imply the outputs. 
　it might be argued that the logic here is too weak to represent what we want to  for example it cannot represent disjunction. we have to be careful here; if a robot is to do something  it cannot be unsure about its own actions. it must commit to one action in order to carry it out a robot cannot 'do' action a  v a1 without doing one of them. this does not mean that the agent cannot be ignorant  or unsure  of what other agents will do  or be unsure about what values it will receive from the environment for a general discussion of these issues  and a way to handle them within the logic presented here  by allowing independent 'choices' made by different agents and nature  see  poole  1 . 
1 noisy sensors and actuators 
the above axiomatisation showed how to model partial information about the environment  the agent had very limited sensing ability . in this section we sketch a way to model noisy sensors and actuators using a continuous version of probabilistic horn abduction  poole  1; 1 . 
　the general idea of probabilistic horn abduction is that there is a probability distribution over possible world generated by unconditionally independent random variables. a logic program gives the consequences of the random choices for each world. formally  a possible world selects one value from each alternative  disjoint set ; what is true in the possible world is defined by the unique stable model of the selection and the acyclic logic program  poole  1 . the probability of the world is the product of the probabilities of the values selected by the world. in this framework  the logic programs can still be interpreted logically  and the resulting framework  although based on independent random variables  can represent any probability distribution  poole  1 . 
　to model noisy sensors  we add an extra 'noise* term to the rules. for example  to represent additive gaussian noise for the compass sensor  with standard deviation 1  we can use the rule: 
	poole 	1 

actuator is also unreliable  then the errors explode. unreliable actuators can be modelled similarly to the noisy sensors  for example  

where a.error is treated analogously to cjnoise. 
　when the dynamics are linear and the noise is gaussian  the posterior distributions can be solved analytically  as in the kalman filter  see  dean and wellman  1  . 
1 constraint nets 
constraint nets  zhang and mackworth  1  form a modelling language for hybrid systems that combines discrete and continuous time  and discrete and continuous domains into a coherent framework. this is done by abstracting the notion of time so that it covers both discrete and continuous models of time  and using  events' as the interface between continuous and discrete time. 
　constraint nets are built from three basic transductions. transliterations  which do not depend on the past  are axiomatised here by allowing  acyclic  logic programs to specify how current outputs depend on current inputs. our was predicate corresponds to unit delays. transport delays of time r can be modelled as the atom now fl  v t -r  - to implement these we have to maintain a history of at least r long  and not 
just a state. 
1 logic control 
cocolog  caines and wang  1  is a logic for discrete control that shares many features of the discrete form of the logic here. the main difference is that in cocolog  the state of the system is an explicit term of the language. the language is also more complicated than the simple horn clauses used here and the main control loop is extra-logical. 
　the declarative control of nerode and kohn  uses prolog for control. their main aim is for a prolog program to prove that some action is optimal. their prolog rules are at a much different level than the simple rules used here  which are impractical when using prolog's back-chaining search strategy. 
1 golog 
golog  lesp&ance et al.  1  is a programming language for robots based on the situation calculus. unlike the proposal in this paper  golog programs are not sentences in a logic. rather the logic is at the meta-level providing a semantics for the algol-like golog language. 
　one intriguing idea is to use the logic programming approach here to write a low-level controller that interprets golog programs. this could be done by having two state variables  one that is the current action the agent is 'doing' and one is a list of actions 'to do'. the rules could be used to reduce expressions in time  for example to interpret action sequences we can use: 

similarly  we can interpret more complicated constructs such as while loops as well as monitoring 'primitive' actions  e.g.  we can see setting the goal direction in the above example as a high level action that decomposes into continuous action  and is monitored as to when it is complete . a full discussion of this is beyond the scope of this paper. 
1 event calculus 
the event calculus  kowalski and sergot  1; shanahan  1  provides a mechanism to represent persistent properties over intervals from events that make the properties true and false. what is new in this paper is deriving events from changes in continuous properties  having cumulative properties  and exploiting evaluation in time to gain efficiency. 
　there is quite a simple translation to map the event calculus into the framework of this paper. the event calculus uses the predicates: happens e t  is true if event e happens at time t; initiates e  p  is true if event e makes p true; terminates e  p  is true if event e makes p no longer true. 
these can be mapped into the fluent representation used here: 
	 rr	 v	 t
if we want the convention used in this paper that predicates are true in left closed intervals  we can represent holds p  t    meaning predicate p holds at time t  by: 

　one main advantage of our representation is that  when we act in time  and all of the set's are done in temporal ordering  and we maintain a state  then we can implement holds very fast  by looking up the last value that was assigned to the variable. 
　shanahan's notion of 'autotermination' is similar to our deriving events from continuous change. 
1 other mixes of logic and continuous time 
there have been other proposed mixes of logic and continuous time  e.g.   sandewall  1; shanahan  1; dean and siegle  1; trudel  1; pinto and reiter  1    but in all of these either  during the time span of a situation no fluents change truth values   pinto and reiter  1  or the axiomatiser needs to know a priori how properties accumulate  they effectively do integration off-line . for robot control  we do not know how the sensor values will change; the best we can do is to derive  estimate  integrals online. none of these other proposals let us do this. 
1 	conclusion 
this paper has argued the logic programs can be used effec-

1 	action and perception 

tively as a programming language for robot control. the logic program forms an executable specification of what the robot 

should do. the same language can be used for modelling the robot and the environment  and also multiple robots . this axiomatisation can be combined with probabilistic horn abduction  poole  1  to allow for modelling uncertainty in the environment  e.g.  exogenous events  noisy sensors and unreliable actuators . 
　this paper has not described some ideas about improving efficiency by adaptive sampling: by partially evaluating the logic program  we can determine what inputs we must look for in order for an event to occur. when running the robot  we can build into our sensors detectors for these conditions; when detected  we can run the program in a forward direction to derive events. in the simulation  we can query the environment to determine when these events would occur. such ideas are currently being pursued. 
acknowledgements 
thanks to alan mackworth and ying zhang for interesting discussions on hybrid systems. thanks to mike horsch for comments on a previous draft. this work was supported by institute for robotics and intelligent systems  project ic-1 and natural sciences and engineering research council of canada operating grant ogp1. 
