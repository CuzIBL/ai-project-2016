 
this paper addresses two problems concerning the issue of redundant information in resolution based reasoning systems. the first one deals with the question  how the derivation of redundant clauses can be substantially reduced a priori. the second one asks for a criterion to decide  which clauses need not be tested for reduncancy. in this paper we consider a particular kind of reduncancy  which we call ancestor subsumption  that is the subsumption of a resolvent by one of its ancestors. we give a complete syntactic characterization of clause sets producing ancestor subsumed clauses. given this characterization  a solution to the problem with generating redundant clauses is proposed. moreover  a suitable restriction of the  usually very expensive  subsumption test is derived from this result. sam's lemma will serve as an example for demonstrating various possibilities how to avoid the derivation of redundant clauses. 
1 	introduction 
the derivation of redundant information is one of the greatest obstacles to the efficiency of reasoning programs. wos  1  reports an attempt to prove sam's lemma  see 
guard 1  using hyperrcsolution  where 1 clauses identical to retained clauses and 1 clauses being proper instances of retained clauses were generated. even if these redundant clauses can be removed after their generation  they must be processed with demodulation  subsumption  and other procedures. moreover  the test on subsumption  being a very useful means for removing reduncancies  is rather expensive as chang & lee  1   eisinger  1   and some others remark. a strategy to prevent the generation of redundant clauses  or at least to reduce the amount of newly generated unneeded clauses  would thus prove very useful for increasing the power of reasoning systems. 
   on closer inspection of the proof of sam's lemma it turns out that many of the 1 duplicates are generated by double resolution with a clause of the form pxy v  pyx. such a duplicate is identical to its own  grandfather  in this resolution derivation. more general  we will deal with the situation that a resolvent is subsumed by one of its own ancestors  which we will call ancestor subsumption. ancestor subsumption is a particular kind of forward subsumption  ovcrbcek 1   that is the subsumption of a newly deduced clause by a given clause. one of the paper's objectives is to characterize clause sets that admit ancestor subsumption. this approach is based on the following observation: a resolvent of two clauses cannot be subsumed by one of its parent clauses  unless the other parent is selfresolving. this can be easily seen for the ground case: let 
c={l1 l1 ..ln} and d={-l1 .. kn  be ground clauses and assume  c subsumes the resolvent 
r= k1 .. kn l1 	-ln}. then l er must hold and from 
l1 {l1 ..jn} now follows l1  k1 .. kn}- hence d is a tautology. we will generalize this observation in the following way: a resolvent r cannot be subsumed by an ancestor c  unless the set of ancestors of r contains a cycle  the notion of a cycle was introduced by shostak  1  . noncyclic clause sets thus have the nice property of excluding ancestor subsumption. a prominent example for this class of clause sets is schubert1s steamroller  see stickel 1 . linear resolution has the property that the later a clause is derived in the linear deduction  the more ancestors it possesses. provided that a given clause set is known to disallow ancestor subsumption  a linear strategy thus seems most preferable in order to reduce the generation of subsumed clauses. 
   another question addressed by this paper is closely related to the first problem. the characterization mentioned above provides a means to avoid the generation of subsumed clauses only for noncyclic clause sets. but for other clause sets we can at least give a criterion to decide  which clauses have to be considered as potential subsumers in the subsumption test. being not self-resolving  for example  a clause can be excluded from being subsumer of its own  child . 
socher-ambrosius 	1    as cycles in clause sets are heavily responsible for the generation of redundant information  a technique to remove such cycles would prove very useful. this paper considers two approaches. a certain class of cycles  cycles representing the logical equivalence of some literals  can be made harmless by using them only as demodulators. consider for example a clause set containing the two clauses and  qvp  which form a cycle and give rise to an endless resolution derivation. these two clauses express that p and q are equivalent literals  which therefore can be substituted for each other without changing the truth value of the whole clause set. replacing for instance each occurrence of p in the clause set by q yields an equivalent clause set  where the two cycle clauses have become tautologies. this approach is in fact a demodulation on literals instead of terms. the wellknown problems with term rewriting  however  arise with literal demodulation  too. directing equations to rewrite rules requires the existence of a well founded ordering on terms. thus  according to the same reason  why the equation fxy =fyx cannot be directed to a rewrite rule  the equivalence pxy =pyx cannot be used as a demodulator. the second approach  which overcomes the problem with directing equivalences  consists in using cycles as the basic theory for performing theory resolution. the cyclic clauses  for instance the symmetry clause  disappear in a theory box  enabling in this case resolution between the clauses pab and  pba. 
1 basic notions 
in the following we assume the reader to be familiar with the standard terminology of first order logic. the few basic notions of clause graphs used in this paper can be found for instance in eisinger's  1  thesis. clauses are always considered as sets of literals  but written without set braces. the empty clause is denoted by 
   let  a denumerable set of variables. a substitution a is an endomorphism on the term algebra  which is identical almost everywhere on vand thus can be represented as a finite set  . a substitution p is called a renaming substitution  iff p is injective on its domain and  literal or clause l is called a variant 
 or a copy  of the literal or clause k  if there exists a renaming substitution p  such that  two substitutions are compatible  if there exists some substitution x with 
1 	cycles in clause sets 
this chapter provides a characterization of clause sets admitting ancestor subsumption. our main result is as follows: clause sets admitting ancestor subsumption possess cycles  whose elements are the far parents of the subsumed clause. 
first  we define the two basic notions of ancestor subsumption in terms of circular derivations and of cycles. the proofs of the following lemmata and theorems can be found in the full version  socher  1   of this paper. 
1 definition; 
a clause is self-resolving  if it resolves with a copy of itself. 
   the following lemma determines those clauses that possibly produce subsumed resolvents. for any clause d we define the deduction relation - d between clauses c and r by c - d r  iff r is a resolvent of c and d. 

   a semicycle d is a directed graph  whose nodes are labelled with clauses and whose links are r-links  labelled with substitutions and which satisfies the following conditions a  to c .  note that we do not distinguish between a node and its label.  
a  each node of d has the following form  figure 1 : 

fig.l 
with m incoming r-links and n outgoing r-links  and m 1  n 1 holds. 
b  there is a node co such that each cyclic path of d passes c1 there is a substitution t  which is a common instance of all substitutions of the r-links going into co and there is a common unifier a for all other links of d. 
c  a and t are compatible  with common instance x- the substitution % is called the cycle substitution of d. 
   the semicycle d is called complete  if a is an instance of t  that is la = ka for all literals l and k joined by a link going into c1. let d be a semicycle consisting of only one clause c. then a is the identity substitution andc is self-resolving. if  moreover  cd is complete  then c is a tautology. d is called a cycle  if each node has exactly one successor. 
   a cycle is just what shostak  1  and  1  calls a loop. this notion also corresponds to the notion of recursive predicates in the terminology of deductive databases  vieille 1  ohlbach 1  and logic programming. 
1 example; 
the clause sets d1 d1  and d1  which are shown in figure 
1  are semicycles; d1 is a cycle. it can be seen that each node of a cycle may be chosen to be the special clause co. as to semicycles  still several  but in general not all nodes have this property. for instance the clauses  rw and sw cannot be chosen to be c1. 
   the previous examples illustrated that in general there are several possibilities to choose a clause of a semicycle to be the special clause c1. the cycle substitution  however  is independent of this choice  according to the definition of semicycles. 

fig.1 
   the following two theorems provide a characterization of clause sets producing subsumed clauses. it turns out that those clause sets have a  cyclic  structure  varying from the weakest form for clause sets producing some ancestor subsumed resolvent to the strongest form of a cycle for clause sets producing only copies as resolvents. 
1 theorem; 
let c be a unit clause  let d be a set of clauses and let c- dr. 
a  if r is a variant of c  then d is a semicycle. 
b  if r is subsumed by c  then d contains clauses d1..dn such that for each d i  i€ {l .. n-l} the following hold: 
 i  there exist literals ki and li; and an r-link between 
li and ki+1. 
 ii  ln and k  are literals with the same predicate symbol  but different polarity. 
1 theorem; 
let d be a set of clauses. 
a  suppose for all clauses c the following holds: c- r implies that c and r are variants. then d is a complete cycle  all clauses of which are function and constant free. 
b  suppose for all clauses c the following holds: c- dr implies that r is an instance of c. then d is a complete cycle. 
c  suppose for all clauses c the following holds: c- dr implies that c subsumes r. then d is a complete semicycle. 
	socher-ambrosius 	1 
   note that the definition of the deduction relation - d does not capture ancestor resolution  which is part of complete linear strategics. 
1 example; 
let d be the clause set  which is shown in fig. 1. 

fig 1 
d allows a linear deduction with ancestor resolution as follows: 

where the last step is an ancestor resolution step. but d is not a semicycle. 
   the following lemma shows that it is sufficient to look for cycles in an initial clause set during a resolution deduction  as  new  cycles cannot be generated by resolution. for any clause set 1 r 1  denotes the resolution closure of 1  that is the smallest clause set containing s and closed under the resolution operation. 
1 lemma; 
let s be a set of clauses. then s contains a semicycle  iff 
r s  contains a semicycle. 	¡ö 
1 	removing cycles from clause sets 
besides being the very reason for the undecidability of first order logic  cycles in clause sets also turned out to be a main source of reduncancy for clause set resolution. thus the question arises as to what extent cycles can be excluded from producing lots of unneeded clauses. a first approach to this question is due to bibel  1 . he showed that under certain conditions  similar to those allowing the deletion of tautologies in clause graphs  cycles can be removed from clause sets. we will consider here two approaches  both restricted to proper cycles. however  we will also show by means of sam's lemma  that in particular cases there exists also an appropriate treatment of semicycles. 
   the first idea in order to shut down this source of reduncancy is to use cycles not directly for resolving. instead  they are taken as literal demodulators  wos 1 : 
cycles  expressing the equivalence of literals  can be transformed into rules  in the same way as equations can be directed yielding rules. consider for example a clause set containing among others the two clauses  pvq and -qvp. these two clauses represent the formula p=q  which can be directed yielding for instance the rule p- q. application of this rule means substituting q for each occurrence of p and  q for each occurrence of  p.  note that this effect can be achieved also with an ordering restriction  loveland 1   which precludes resolution with the q and  q literal in the two clauses.  however  the method of literal demodulators applies only for cycle clauses that can be directed  such as ground clauses or clauses with different predicate symbols. thus  a lot of relevant clause sets does not allow this approach. for instance  the  cyclic  clause  pxyvpyx  expressing the symmetry of p  cannot be directed. 
   another approach  which overcomes the problem with directing equivalences  is based on the idea of  compiling  cycles into a theory serving as the basis for theory resolution. theory resolution  first proposed by stickel  1   is a generalization of ordinary resolution. the literals resolved upon need not be syntactically complementary  it is sufficient for them to be complementary under some theory. in particular  each clause c = {l1.ln  defines a theory tc  in which  for instance  the set of literals {l1 .. -.ln} is complementary. taking clauses  or clause sets  as a particular theory to perform theory resolution is essentially the same idea as ohlbach's  1  link resolution. the set tc in general is not computable. yet  in order to perform theory resolution on a clause set 1  it is sufficient to compute the resolution closure r s  of 1. 
1 lemma; 
let s be a set of clauses and d e tsbe a clause  which is not a tautology. then there is some clause ce r 1   such that c subsumes d. 	¡ö 
	in order to find the substitutions 	  which make a set 
 l1 .. ln  of literals complementary under the theory ts  or  equivalently  which map the clause d:={-l1 ..  ln} onto an element of ts  it is sufficient  according to the previous lemma  to find some and a clause c e r   1     such that c subsumes da. thus  having a finite resolution closure r s   the set s guarantees the number of tsresolvcnts of two clauses to be finite. in particular  this is the case for cycles that produce only copies as resolvents  since these cycles are function free. the next lemma shows that the theory of a complete  function free cycle cd with cycle substitution a can be completely described by the equivalence of all literals of  da. 
1 lemma; 
let cd be a complete  function free cycle with cycle substitution a. then r d  =  -tlgkg il and k are literals 
occurring in cd . 	¡ö 

   in the following we describe a refutation of this clause set using positive hyperresolution together with theory 
resolution  as in chapter 1. the cyclic clauses c1 and c1  describing the symmetry of the min and max predicates  are 