
protocols structure interactions among communicating agents. a commitment machine models a protocol in terms of how the commitments of the various parties evolve. commitment machines thus support flexible behavior while providing a meaningful basis for compliance with a protocol. unfortunately  current formulations of commitment machines are not sufficiently general or rigorous.
this paper develops generalized commitment machines  gcms  whose elements are described generically in terms of inferences  and whose computations are infinite  thus supporting nonterminating protocols . this paper shows how a gcm can be understood as a nondeterministic bu：chi automaton  ba   whose acceptance condition accommodates infinite as well as finite executions.
deterministic ba are readily emulated by conventional software  e.g.  a script running in a web browser. in general  nondeterministicba may have no equivalent deterministic ba. however  under well-motivated technical conditions  a gcm yields a deterministic bu：chi automaton that  although not necessarily equivalent in automata theory terms  is sound  produces only computations allowed by the gcm  and complete  produces the effect of any computation allowed by the gcm .
1 introduction
protocols streamline communication and enable the development of interoperable agents by independent vendors. the participants in a protocol should be able to exploit opportunities offered by the environment  negotiate and exploit special relationships with others  and handle exceptions. unfortunately  conventional engineering techniques for specifying and enacting protocols are tedious and result in interactions that are unnecessarily rigid  yolum and singh  1 .
　work on commitment machines  cms  shows how representing and inferencing on commitments can produce flexible protocols while providing a basis for compliance  chopra and singh  1; winikoff et al.  1; yolum and singh  1 . to simplify comparison with previous work  we use netbill as an example protocol. in netbill  a customer requests a quote for some goods  followed by the merchant sending the quote. if the customer accepts the quote  the merchant delivers the goods. the customer then pays. after receiving the payment  the merchant sends a receipt to the customer. figure 1 l   or  left   is an fsm representation of netbill. figures 1 c    center   and  r    right   are discussed below.

figure 1: netbill automata: original  l ; terminating but unbounded  c ; and nonterminating r . states 1 are initial and 1 are final. section 1 explains state 1 of  r . c and s refer to message senders customer and merchant  respectively
　the above papers observe that the original netbill is quite rigid. it cannot handle natural situations such as  1  a merchant proactively sending a quote  mimicking the idea of advertising a price;  1  a customer sending an  accept  message before requesting a quote  as in cases of trust or urgency ;  1  a merchant sending the goods prior to the customer accepting  as in a trial offer . these papers show how to model protocols based on commitments  enabling each participant to perform a wider variety of actions yet ensure its own compliance and check others' compliance based on their actions.
　although promising  previous work on cms is not sufficiently general  rigorous  or clear in its assumptions. yolum and singh model actions in restrictively. their approach only indirectly models the discharge of a commitment. their strong point is a compilation of cms to finite state machines. winikoff et al. use the event calculus to reconstruct some of yolum and singh's work. they improve the methodology by which commitments are modeled  but don't study compilation as such. chopra and singh consider a richer  nonmonotonic theory of action based on causal logic. they don't discuss compilation except the general translation of causal logic into a transition system.
　as a case in point  current and emerging financial protocols are not adequately formalized. for example  price discovery protocols  which are crucial for wholesale foreign exchange transactions  are conventionally described via scenarios and text descriptions  twist  1 . however  such descriptions are ambiguous and unwieldy. they treat each of several cases separately  losing opportunities for generalization and compactness. our preliminary work with twist captures the key commitments and succinctly represents multiple scenarios using a few primitive patterns  that can be validated modularly. the value of commitments in modeling and analysis is clear; this paper strengthens their operational aspects.
　previous work assumes that a cm necessarily includes all states that are reachable through the actions modeled. however  the design of a protocol can involve considerations such as which states to include  e.g.  to respect integrity and security constraints  and participants' preferences. this is especially so when subtle organizationalrequirements or complex roles are involved. likewise  although nonmonotonic specifications can be valuable  monotonic representations that enumerate the modeled conditions facilitate verification of simplified  high-performance automaton-based implementations that nevertheless follow a specified protocol.
　this paper introduces generalized commitment machines  gcms   which are a more general and rigorous version of cms. it introduces a simple approach for modeling actions  so that we can clearly state the key requirements on them. the action models can be expressed in a variety of existing formalisms  including causal logic and event calculus. this paper handles the complete set of commitment operations.
　additionally  the semantics of gcms is based on infinite computations  thus providing a proper treatment of nonterminating  and even terminating  protocols. to motivate nontermination  notice that protocols can readily have cycles. figure 1 c  introduces a reject transition  which induces a cycle. thus unbounded computations can be produced. however  if our model is a traditional finite automaton  each computation would terminate in a final state of the automaton. by contrast  if we automatically restart netbill upon sending areceiptand interpret it as not having a final state but requiring that a good state  say  state 1  occurs infinitely often  then we would bring about infinite computations  figure 1 r  . a good state is one in which some desirable condition  relative to design goals  is achieved. in traditional applications of automata  a good state is typically one where a stimulus has been responded to. for gcms  a simple domain-independent basis may be that a good state is one where there are no pending commitments.
　more natural nonterminating protocols involve maintaining a relationship  as in an organization  rather than completing a transaction. participants of such protocols would continually send messages and respond as often as required. one can think of the underlying relationship as a standing agreement  analogous to those in real-life organizations or distributed systems. you don't want a multiagent system to terminate any more than you want your os to terminate.
　gcms are specified modularly via sets of inference rules. we cleanly separate rules involving  1  generic expectations from action theories   1  commitment operations   1  how commitment operations are  constituted  in the setting being modeled  and  1  how a protocol should function  i.e.   regulative  rules in force. here   1  and  1  are fixed;  1  and  1  vary for each protocol. the above kinds of rules can be captured in a variety of existing action formalisms. importantly  gcms are compiled in a novel manner into deterministic bu：chi automata  a well-known model of infinite computations  thomas  1 . automata facilitate verification; deterministic representations can be directly executed by a computer using a single thread  in constant space.
　briefly  our contributions are as follows. we seek a computational model of protocols that is natural for humans: thus it must reflect semantics. in general  producing an executable  deterministic representation can cause an exponential blow up and include unnaturalstates. using semantics  we can map gcms to deterministic automata with natural states.
1 technical framework
we introduce our action representation  and review commitments and bu：chi automata. below  x  y  z are agents; p  q  etc. are formulas; and α is an atomic proposition or its negation: identify α with   α.
1 generic action theory
the meaning of an action is specified in terms of the proposition it brings about  reflecting  causes  in causal logic or  initiates  in event calculus  under different conditions. each action is described via an action theory  Δ  i.e.  a set of axioms that capture how the state of a protocol evolves when an action occurs. for simplicity  the performer of the action is kept implicit in the action label. definition 1 describes action axiom schemas  which correspondto potential transitions  some of which might be allowed in a gcm .
definition 1means that q is a consequenceof performing action a in a state where p holds. 
   if p holds and  then performinga yields q. when q is  p  a overturns p; when q is false  that means a is impossible if p holds. the relationis closed under the inference rules below. an action theory Δ must respect these rules. below is a logical consequence of p.
		 consequence 
		 conjunction 
　the following is not an inference rule but a requirement that the  relation preserve consistency.
		 consistency 
		 inertia 
   inertia specifies that if α holds before a and isn't overturned by a  then α continues to hold after a. inertia is not required here but is a convenient property of action theories.
example 1 example of overturnand inertia: consider a state s where goods …  pay holds. now if payment is made  the new state is s where goods … pay holds.
1 commitments
a commitment is an explicitly manipulable directed obligation  in a context  ignored here for simplicity .
definition 1 a commitment cx yp relates a debtor x  a creditor y  and a condition p. specifically  x commits to y to bring about p. 
commitment actions
the creation and manipulation of commitments can be described using the following operations  modeled as actions.
  true create: establish
  p … cx yp discharge	: resolve and remove
: remove  by debtor 
  cx yp release: remove  by creditor 
  cx yp assign: change creditor
  cx yp delegate: change debtor
a debtor who cancels a commitment may be subject to penalties whereas a creditor may release a commitment  typically for organizational reasons  with no penalties.
definition 1 a conditional commitment ccx y p r  means that if antecedent p becomes true  then the debtor x will become committed to bringing about consequent r. 
　when a conditional commitment's antecedent becomes true  it is discharged and a commitment for its consequent is created  typically  z = y :
  ccx y q r  detach
when a conditional commitment's consequent becomes true  it is discharged and nothing else is needed  typically  z = x :
  ccx y q r  eliminate
constituting commitment actions
the above rules provide the semantics of commitment actions. in each setting  the actions would be performedin some domain-specific manner. in protocols  commitment actions correspond to message types. in some cases  the messages may combine the effects of multiple commitment actions. or  as in the case of partial returns and payments  multiple messages may be needed to implement one action. for example  paying $1 would replace a commitment to pay $1 by a commitment to pay $1. the domain action theory would capture such requirements.
example 1 consider	the	conditional	commitment ccm c pay receipt  meaning	that	the	merchant	would commit to sending a receipt if the customer pays.
  the customer pays first  making pay true. the conditional commitment is terminated and a new commitment  cm creceipt  is created in its stead  detach . when the merchant actually sends the receipt  i.e.  when the proposition receipt becomes true  then the commitment cm creceiptis discharged  discharge .
  before the customer pays  the merchant sends the receipt  makingreceipt true. the conditional commitment is terminated  but no other commitment is created: the customer did not commit to paying  eliminate .
1 mapping to existing logics
the inference schemas on  defined above are generic and can be represented in more than one existing formalism. hence  an interpreter for any of these formalisms can be plugged in to derive appropriate inferences. the following causal laws show how some commitment actions are captured in causal logic  chopra and singh  1  ′ 1 .
1. discharge: p causes  cx yp if cx yp
1. detach: maps to two expressions p causes  ccx y p r  if ccx y p r  p causes cx yr if ccx y p r 
1. eliminate: r causes  ccx y p r  if ccx y p r 
the following event calculus expressions capture the same actions as the above  winikoff et al.  1  fig. 1   time is explicit here  but not specifically used i this formalization :
1. discharge:
terminates e cx yp t  ○ holdsat cx yp t  … happens e t  … subsumesinitiates
1. detach: maps to two expressions
initiates e cx yp t  ○ holdsat ccx y p q  t  … happens e t  … subsumesinitiates
terminates e ccx y p q  t  ○
holdsat ccx y p q  t  … happens e t  …
subsumes initiates
1. eliminate: terminates e ccx y p q  t  ○
holdsat ccx y p q  t  … happens e t  …
subsumesinitiates
we could just as easily use ecasl  the extended cognitive
agent specification language  khan and lespe＞rance  1 .
1 buchi automata：
finite state machines  fsms  have long been used to specify protocols. the acceptance condition of fsms requires termination in a final state. but  as section 1 argues  many interesting protocols are nonterminating. to model such protocols requires that we consider automata over infinite words.
　bu：chi automata  ba  have finitely many states and the same transition rules as fsms. however  their acceptance condition handles nonterminating computations by requiring that a good state  see section 1  be visited infinitely often.
definition 1 a bu：chi automaton is a five-tuple  b	=
  where s is a set of states  a is the alphabet  s1 （ s is the start state  g   s is a set of good states  and δ   s 〜 a 〜 s is the transition relation. 
　below  ω is the first infinite ordinal. a computation τ =  is an ω-long alternating series of states and intervening actions. for a computation τ  inf τ  is the set of states that occur infinitely often in τ. throughout this paper  b is a ba and τ is a computation.
definition 1 τ is realized by b if and only if   i （ ω  and . 
figure 1 r  is an example ba with s = the set of vertices  a = the set of edge labels  s1 = 1  g={1} shown in reverse video  and δ = the set of edges. the computation that cycles through states 1  1  1  1  1  1  namely  : offer  1  c : accept  1  m : goods  1  c : pay  1  m : receipt is accepted by this ba  because it visits state 1 infinitely often. the computation that cycles through states 1  1  1 is not accepted because it does not visit state 1. figure 1 shows ba for the languages a ba+b ω and a a+b ω  respectively. notice that figure 1 r  accepts aω  but figure 1 l  doesn't. thus  viewed in automata theoretic terms  the two are obviously not equivalent.

figure 1:  l  nondeterministic ba;  r  deterministic ba
　the move to infinite computations complicates some aspects of the automata. importantly  whereas all nondeterministic fsms have an equivalent deterministic fsm  some nondeterministic ba have no equivalent deterministic ba. figure 1 l  is a famous example of a ba that cannot be determinized. a deterministic ba can be efficiently emulated by a script: if the ba is correct we know the script complies with the given protocol. this paper shows how to produce  if possible  a correct deterministic ba for a protocol.
1 generalized commitment machines
a generalized commitment machine  gcm  is specified via states whose content is captured via logical expressions  actions and an action theory to transition between the states  and a set of good states. terminating computations can be modeled by transitioning at their end to an artificial good state with a self-loop. given a state  the new state reached by performingan action is logically inferred. in effect  a gcm specifies meanings of the states  and lets inferencing do the rest.
　since we construct ba from the same set of states and actions as gcms  we use the same symbols s  s1  g  and a in both definitions. below  p 《 q means that p and q are logically equivalent  that is .
definition 1 a gcm is a tuple  where
s is a finite set of states  a is a finite set of actions    s1 （ s is the start state  Δ is an action theory  and g s is a set of good states. members of s are logically distinct:   si sj （ s :  si 《 sj     si = sj  ; false; any state stronger than a good state is also good:  sj （ g  . 
definition 1 τ is generated by a gcm p if and only if   i （
   and . 
throughout this paper  p  for  protocol   is a gcm. given q r （ s  a （ a  p transitions from q to r under action a if and only if. in effect  a gcm functions as an inferencedriven  nondeterministic  ba.
example 1 previous work formalizes netbill and other terminating protocols as commitment machines. a similar approach applies here. briefly  the modeling steps are:
  model the atomic propositions  such as request or pay.
  introduce the commitments needed. for example  accept abbreviates ccc m goods pay   i.e.  if customer c receives the goods  he would pay merchant m.
  identify the states in s. for example  state 1 in figure 1 means that the merchant has made an offer thus committing to delivering goods and sending a receipt upon payment: formally  request … promisereceipt … promisegoods.
  identify the actions in a: these are the messages exchanged  e.g.  sendaccept and sendgoods.
  assert action theory axioms  Δ:  1  sending an accept: true sendaccept★ accept;  1  delivering the goods and promising receipt: truesendgoods★ goods…promisereceipt.
  identify the good states in g. for example   1  the customer has made a request but no commitments have been made: request;  1  the merchant has delivered the goods and the receipt and the customer has paid: request…goods…pay…receipt.
example 1 a gcm analogous to figure 1 l . state 1 is p‥q; state 1  （ g  is p … q  and Δ includes the following axioms:
  and  1 .
　this example helps relate gcms to the well-known ba of figure 1 l   revisited in section 1 . a scenario where such a gcm may occur is if p and q refer to some organizational relationships. action a strengthens the relationship from p or q to p … q. action b confirms the relationship or can weaken it.  one can imagine that b was originally specified for two organizational roles  now being played by the same party. 
1 compiling gcms into buchi automata：
reasoning with declarative representations at runtime can be expensive  may increase the code footprint of the agents. many applications such as financial transactions  twist  1  call for flexibility when designing a protocol but rigid enactment to make performance guarantees. also  the popularity of ajax indicates the potential for simplified interacting agents. compiling a gcm into a deterministic ba is thus highly desirable. a gcm is in essence a nondeterministic ba. in general  an equivalent deterministic ba may not exist. but we can exploit the semantics of the protocol to produce  if possible  a deterministic ba that for practical purposes is equivalent.
1 determinism and soundness
the states  initial state  and good states of a gcm map straight to those of a ba. more importantly  to ensure determinism  we can choose no more than one transition for a given state and action: this is what algorithm 1 does.
　to understand the min calculation in algorithm 1  imagine that the gcm states are partially ordered according to logical consequence: si is placed below. for s   s  min s  is the unique minimum  if any  of s according to this order. for example  assume that performing a in s1 could yield s1 and s1  where . if  algorithm 1 would select  it would select s1; if neither  algorithm 1 would select nothing  thus omitting the a transition from s1. theorem 1 shows that the result is deterministic.
theorem 1 algorithm 1 yields a deterministic ba b. proof. assume b has two transitions for the same state and action  i.e. . algorithm 1 ensures and  i.e.  sj 《 sk. definition 1 ensures sj = sk. thus  b is deterministic. 

algorithm 1: compiling gcm p into a ba b
example 1 on example 1  algorithm 1 would yield the ba of figure 1 r  with states 1 and 1  state 1 in g  and transitions
  based on the axiom for based on applying consequence on the axiom for is not included  based on line 1 of the algorithm . thus  even though figure 1 l  and figure 1 r  are not equivalent  based on our knowledge of the meanings  they are practically equivalent.
　example 1 is fortunate. the compilation doesn't always work. the following develops additional steps to make compilation work  or to determine that it cannot work. correctness has two main aspects. soundness means that the compiled ba won't realize a computation that the gcm wouldn't have generated. completeness means that if the gcm can generate a computation  the compiled ba can realize it. because the ba's transitions are chosen from among those in the gcm  soundness is guaranteed. this is theorem 1.
theorem 1 let p be compiled into b. then any computation realized by b is generated by p. 
1 completeness via coherence
in general  because the ba may not include all the transitions of the gcm  it would not be complete. first  the ba may have no transition for a state and action  because none is the  unique  strongest  as required by algorithm 1. to address this  the basic idea is to restrict gcms such that if there is a transition for a state and action  then there is a strongest transition for the same state and action: by exploiting the action rule conjunction. definition 1 captures this as coherence. however  figure 1 l  shows a situation where a may occur in p and produce q1 and q1. that is  and both hold. in this situation  s. that is  coherence is violated.
definition 1 for s （ s a （ a  the projection of a on s  πa s  is the set of states s in s such that. a gcm is
coherent if 
and . here  n is the supremal state for s and a  meaning it is the strongest resulting state. 

figure 1:  l  lack of coherence;  r  failure of coverage. dashed ellipses represent potential states that are not in s
　second  a gcm computation may involve a transition that doesn't exist in the ba. to address this  the basic idea is that because of the action rule consequence  although a specific gcm computation may not be realized in the ba  a computation taking the strongest state at each step would be realized. thus the ba would be complete for practical purposes. definition 1 and lemma 1 capture this intuition.
definition 1 a computation is the semantic supremum of a computationif and only if τ begins at the same state  involves the same action sequence as τ  and for each transition exercised byexercises a transition where is the strongest consequence of performing. 
lemma 1 any computation that begins from s1 and is the semantic supremum of some computation in the gcm can be realized by the ba produced by algorithm 1. proof.	the proof is simply by transfinite induction on computations: consider prefixes of length from 1 to ω. 
　theorem 1 establishes our main completeness result finessed for coherent gcms and supremal computations.
theorem 1 given a coherent gcm compiled into a ba  for any computation generated by the gcm that begins from s1  there exists a semantic supremum computation realized by the ba.
proof.	by construction of a coherent gcm and lemma 1. 
1 producing coherent gcms
let's now consider the question of whether and how an arbitrary gcm p can be mapped into an equivalent coherent gcm p. producing a coherent gcm requires ensuring that supremal states exist for each action allowed in each state.

algorithm 1: producing a coherent gcm with states s
　algorithm 1's first foreach block maintains a set of the known minimal states in the gcm p being constructed  and examines each of them  including those newly added  to determine what new states are needed to ensure coherence. for figure 1 l   this would add q1 … q1 to u  and possibly to s .
　although this would yield a coherent gcm may generate computations that are unrelated to the computations in p. consider figure 1 r . here q1 … q1 is added to s. assume it turns out that our action theory supports but does not support that b can occur at q1 or at q1  i.e.  neither true nortrue hold . thus introducingq1…q1 would generate a computation  which is not generated by p. algorithm 1's second foreach block checks if the newly added states allow transitions that weren't allowed by any of the original states they entail. if so  the new gcm would generate computations not allowed by the original gcm  and so the algorithm terminates in failure. this establishes theorem 1.
theorem 1 for an arbitrary gcm p  if algorithm 1 succeeds  it produces a coherent gcm whose computations are generated by or are suprema of computations generated by p. 
1 discussion
gcms capture the intuitions of cms and provide additional descriptions and expressiveness. they put the work on cms on a sound footing and show how to incorporate them in conventional settings. gcms can apply to a wider variety of commitment protocols  not just those relating to terminating transactions. in general  ba cannot be determinized  but taking advantage of the semantics we can compile a gcm in many cases.
　other classes of automata on infinite computations exist. for example  ba can be determinized into mu：ller automata. however  determinizing involves at least an exponential blow up in the number of states. more importantly  doing so yields states that are not intuitive. this paper exploits meaning to find semantically equivalent automata. in essence  it maps an ω-language into a different ω-language  but one whose computations convey the same meaning as the original.
　previous work on cms has shown how cms can enhance a protocol by naturally allowing a wider range of computations while ensuring compliance. in general  a gcm need not include all the states possible from a given set of states and the action theory  which would lead to large ba.
　it is important to note that protocols or gcms are merely engineering artifacts. specifically  if algorithm 1 ends in failure  one might consider altering the gcm so that an acceptable coherent gcm is produced. from the standpoint of engineering  the selection of states is an important decision: not all states that are possible are created equal. when states are selected  criteria such as the following ensure that the resulting gcm captures a meaningful protocol:  1  from each state where a commitment holds  we can reach a state where the commitment is discharged;  1  like above  but for other commitment operations;  1  eventually the commitment or a commitment resulting from an operation on it is discharged. we lack the space to discuss methodology further. suffice it to say that such requirements can be readily verified via reachability analysis on the ba representation of a protocol.
　previous work on protocols either takes an operational stance or discusses semantics  but generally doesn't relate the two. labrou and finin  describe a grammar for constructing conversations or protocols. they also give a belief and intention based semantics  but the grammar and semantics are unrelated. by contrast  gcms provide a semantics for messages that is directly operationalized.
　mcburney and parsons' posit spaces protocol consists of five locutions: propose  accept  delete  suggest revoke  and ratify revoke . propose and accept are similar to conditional commitments. delete corresponds to release or discharge. suggest revoke and ratify revoke enable canceling of posits. unlike gcms  posit spaces do not support compilation to an automata representation.
　endriss et al.  study protocol conformance for an interaction protocol that is defined as a deterministic finite automaton  dfa . the dfa is completely specified directly  meaning that it would be rigid or unwieldy for humans to study. endriss et al. do not provide formalisms to enable agents to reason about their interactions as we have donehere.
acknowledgments
thanks to martin purvis for hosting me at the university of otago  dunedin  new zealand  where this paper was mostly written. thanks also to amit chopra  stephen cranefield  and the anonymous reviewers for helpful comments.
