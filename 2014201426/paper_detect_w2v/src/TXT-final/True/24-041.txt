 
to allow efficient parallel processing of prolog programs on distributed multiprocessors  a non-shared variable binding approach is required such that binding environments can be independently distributed among processors. this paper presents a binding scheme  which realises the independence of a clause's binding environment by eagerly instantiating variables across clause arguments. the application of the scheme on a prolog virtual machine has illustrated its features of efficiency in execution and simplicity in implementation. the preliminary performance evaluation has demonstrated the feasibility of the scheme. 
1 	background 
prolog has been widely recognised for the past decade as a powerful symbolic programming language. to improve the execution speed of prolog programs  much attention has been devoted to the parallel implementation of the language. one of the central issues is how variable bindings are represented and manipulated so that and/or parallelism can be supported most effectively. 
　the conventional approach to representing binding environments  bes  in prolog is known as the  three stack  approach  werren  1 . much of the work on parallel implementations of logic programs has been on efficient ways of implementing a parallel version of the  three stack  approach. the principle is that when a new process is spawned it can share the be of its parent process  and make its own variable bindings along the new branch on the stack. various kinds of execution model have been investigated for the efficient management of variable bindings. recent achievements in implementing these models on conventional von neumann computers have been highly successful  baron et al  1; ciepielewski  1; lusk et a i.  1 . the central idea in those parallel implementations is to build a virtual stack for each process so that it can share as much information as possible with its sibling processes. the binding schemes in these models have the following concepts in common: 
　a  variable bindings are kept locally in individual clauses; 
　b  unification of a goal and the head of an applicable clause often requires access to variables which may be bound earlier  
　c  the unification between two unbound variables is 
realised by binding one variable to the reference of the other. 
　the differences between these schemes are that  to dereference an ancestor variable  different types of auxiliary structures are used  e.g. binding arrays or hash windows  to allow each clause to store its own copy of the variable  conery  1 . 
　systems with centralised auxiliary structures may be called shared binding schemes. the major disadvantages of shared schemes are that  to access a variable which is bound at a very early stage  the dereference operation is sometimes costly; also the link of the bes generated at different resolution stages requires a centralised memory organisation to facilitate the auxiliary structure. these result from the history sensitivity of variable bindings  in other words  any variable binding has to be kept in order for descendent processes to access. 
in non-shared binding schemes  however  the number of 
bes seen by any process is restricted to one or two. such schemes overcome the above drawbacks but include a limitation due to tradeoff in extra copying and binding operations. among the few proposed non-shared binding schemes  the epilog model  wise  1  and the closed environments  conery  1  are most representative. epilog allows only one be to be accessed by a process  this is achieved by back-unification. in closed environments  locality is achieved by a two-stage closing operation on both parent and child environments. both of these approaches represent a radical attempt at achieving locality for a nonshared implementation. but back-unification in the former and closing operations in the latter are considered costly and sometimes wasteful in both computing power and use of storage  because variables are identified locally in individual processes in both systems. 
　in the following section  a new scheme is presented that identifies variables in a global space so that back-unification is reduced to simple variable exportation  and also reduces environment space to a minimum by eagerly instantiating variables in local processes. 
1. eager instantiation binding scheme 
to design a binding scheme suited to a scalable multiprocessor  high distributability of bes is desirable. in other words  bes should be distributed  rather than shared among processes. operations associated with shared stacks and registers should  therefore  be avoided. 
　it is generally true that high distributability is usually achieved at the cost of structure copying. if the amount of data to be copied is as large as the whole auxiliary structure for bes  the copying overhead may well outweigh the performance gain of distributing the processing. our first goal is to minimise the size of the bes to be copied. secondly  the binding scheme should be as readily supportive as possible for both or and and-parallelism. thirdly  it should be relatively inexpensive for the system to allow both parallel execution and sequential execution and to switch from one mode to another. 
　the eager instantiation binding scheme is designed to meet the above requirements. a major feature of the scheme is that the number of bes operated on by a process at any instant in time is restricted to one  this is the process' own be. 
　it is observed that  the evaluation of a process can be entirely independent of the precedent  sibling or parent  processes if the variables which appear in the input arguments of the process  and arc bound during the previous unification  have been substituted by their instances according to the previous be. in other words  as long as bindings created in the precedent process are applied to the corresponding variables before the variables are sent to the current process  any access to the variables needs not be dereferenced to the ancestor bes. 
　in this binding scheme  the above condition is guaranteed by variable instantiation operations  which ensure that any bound variables appearing in an argument will be substituted with their corresponding instances in the be. when structured terms contain variables for substitution  they are reproduced with the variables being substituted by their instances. instantiation operations have to be applied to the process arguments which are due to be transferred to the next process. 
　argument transfer may happen either a  between sibling processes  or b  from a parent process to its child process after head unification. in the first case  the instantiation of bound variables has to be made before the results of the process are sent to the output  by using the process' own be  and before the input to a sibling process  by using the binding results of the previous sibling process. this is called interface instantiation. in the second case  the instantiation has to be done after the head unification and before the evaluation of the child processes for the body literals. this is called face instantiation. once the evaluation of a child process terminates  the ancestor variables that were bound in the child process are paired with their binding instances and exported back into the parent process. this export operation  together with interface instantiation  achieves the same goal as the back unification operation in epilog  wise  1 . they ensure that the binding results of a process will not be required later by its parent or sibling processes. the face instantiation  on the other hand  serves to ensure that the child processes have sufficient binding information from their parent so that they need not to dereference back to it. 
　figure 1 illustrates the eager instantiation binding scheme applied to a clause. within the clause  process a has two goals b and c. after head unification of a  argument x is instantiated  face instantiation   and then transferred to goal 
b. when the evaluation of a child process which matches b 
1 	logic programming 
succeeds with x bound to a value v  then the variableinstance pair x/v is sent back to a to be used for the instantiation of y  shown as an arrow in figure 1 . it should be noted that more than one variable-instance pair may be produced  if x  introduced from the head  is a structured term containing more than one unbound variable. argument y  which may be bound to a structured term f x   is instantiated  to f v  - interface instantiation  before being sent to goal c. upon the successful evaluation of a  all arguments are instantiated according to a's updated be  interface instantiation  and then sent back to a's parent process. x and y in the example merely stand for clause arguments - they may be any terms. 

figure 1 eager instantiation scheme 
　when more than one child process matches goal b the multiple binding instances of x  resulting from the unification of these processes with b  will be stored in a special data structure  called stream  or vs. the variableinstance pair will be used for the instantiation of y  which generates a stream of y's instances. 
　from the above discussion  it is observed that full andparallelism is not allowed in principle with the scheme. but the scheme can effectively exploit restricted andparallelism  degroot  1j  which is parallel processing of run-time independent goals. there should be no interface instantiation between the independent goals because exporting variable-instance pairs from a child process is necessary only when the corresponding goal in the parent process has run-time data dependencies with one or more sibling goals. in other words  the child processes that are independent from each other at run-time can be evaluated in parallel without exporting their variable-instance pairs to the parent process. therefore  the arrowed line in figure 1 can be omitted in this case. 
　the binding scheme is called eager instantiation due to the fact that the instantiation operation is eagerly performed by the local process. once a variable has been bound  all subsequent occurrences of the variable will be replaced by its binding instance. by ensuring this  the scheme introduces more overheads on instantiation operations and structure copying  but it offers a simpler and more distributed parallel implementation by eliminating the need for accessing variables in the ancestor process. 
　with eager instantiation of procedure arguments  the evaluation of a logic program can be best interpreted in terms of procedural semantics  hogger  1 . every reduction step in a computation entails invoking some procedure  parent process  and thereby introduces new calls to the goals  child processes  in the procedure's body. the process of replacing a call by a goal in the body involves only making the call arguments and goal arguments correspond. this is very similar to the way in which the semantics of procedure calling is defined for conventional languages. the only difference is that logic programs make two arguments correspond by unifying them  whereas conventional languages impose different  simpler  semantics. the unification of a procedure may produce a be  which only effects the calls to the body goals. 
　in representing a variable  the concept of a  value cell   gabriel et al.  1  is not used. instead  a variable-instance pair is used to accommodate a variable and its binding  and is created dynamically only when the variable is bound. this arrangement  though  loses the advantages of a value cell  i.e. a variable instance can be directly accessed because its address is the variable itself and binding conflicts can be checked efficiently  but it brings the following benefits. 
　variables are represented uniquely by variable symbols  which are generated at run-time as the evaluation proceeds. it is unnecessary to provide memory space for unbound variables  whereas in a value cell implementation any variable  bound or unbound  occupies a physical space . therefore  there is no synchronisation problem associated with simultaneous writing to  binding  a variable by different processes. a variable-instance pair occupies two spaces for x/b  which is created only when the variable is bound to another term during unification.  in an or-parallel implementation using value cells  a value cell may also need two or more spaces . furthermore  a variable can be presented in a number of pairs if it is bound to different values as in or-parallel execution. 
　generally  the be size of a particular process can be minimised by optimisation. this is done by substituting variables in the instance parts with their own instances found in the same be  and removing the redundant variableinstance pairs which are no longer needed. the optimised be may occupy much smaller space than the space of value cells required for all variables. thus bes may be extensively copied between processors on requests in order to exploit more distributed processing capability. 
1 	application 	on 	a 	dataflow 	virtual machine 
the eager instantiation binding scheme was initially designed for a dataflow prolog execution model  called dialog  zhang  1 . the dialog model is built on a virtual machine and based on dataflow computation. 
　dataflow computation allows the operations which have received all their input data to be executed in parallel. the computational model is typically restated as two-dimentional graphs  known as dataflow graphs  which show the data dependencies among operations. 
　the dialog virtual machine consists of a number of virtual instructions  of which dataflow graphs representing individual prolog clauses are constructed. the instruction nodes in a dataflow graph are connected by arcs along which dataflow tokens are transferred. all the nodes whose input arcs have received tokens can be executed simultaneously. 
each node  after execution  may put a new token representing a result on its output arcs  and thus activate the following nodes. 
　to see how the eager instantiation binding scheme is applied  consider a simple example which shows one situation where variable instantiation is required: 

the dataflow graphs for individual clauses are shown in 
figure 1. a brief description of the function of instruction nodes in the graphs follows. more detailed descriptions on the instructions and some rules for generating dataflow graphs are given in  zhang  1 . 

figure 1 dataflow graphs for choose list program 
　the instructions represented in rectangular nodes perform procedure calls. a procedure call instruction transfers the argument values from the process named in the node to the clauses whose clause heads match the process  and thus activate the clauses. meanwhile  the instruction sets the returning pointers in the clauses pointing to the descendant processes in the parent process. 
　activated by an input term and a be  an instantiate node substitutes all the variables appearing in the term with their binding instances recorded in the input be  and sends the instantiated term to its output. an export node merges the input variable-instance pairs where the variables were created by the ancestor processes  and exports the new be to the parent process. 
　a unify instruction node unifies two input terms and generates an instance output 1 and an environment output e. the i output produces a common instance of the two terms. 
the e output delivers a be which records bindings of the variables appearing in the two terms. 
　the execution sequence of the above example is illustrated in figure 1. 
　the query implies that the first element of the chosen list must be found in element. when the query is executed  x1 and are applied to the graph of choose jist  figure 1 a  . according to the dialog virtual machine  head unification needs not to be applied to any stand alone variables in the head. therefore  in this example  x1 is sent straight to the first child process element  figure 1 b  . after unification of element  the be with one variableinstance pair  is produced and exported to the parent process choosejist  figure 1 c  . the second argument input is instantiated to before being sent to the 
　
second goal list  figure 1 d  . the child process list  activated by the instantiated argument  succeeds with the first clause and fails with the second  figure 1 e  . finally  the instantiated outputs a and  a  b  cf d  are returned to the corresponding two arguments of choose list  figure 1 f  . since variable x1 and x1 were imported from a parent process  the query in this case   their bindings 
and are exported through an export instruction  from element and list respectively  back to choosejisfs parent process. it is clear that the evaluation of the child process list need not access the be of element  nor the be of choose list. 

figure 1 snapshots of applying the scheme to choose list 
1 	implementation and performance 
the dialog model has been implemented in occam1 on a transputer system  zhang  1 . 
1 	data representation 
variables are identified by their variable symbols  and created when they have been bound. a be is represented as two arrays of integers  one storing variables  the other storing binding instances. two arrays together form a whole array of variable-instance pairs. when two unbound variables are unified  the variable-instance pair is represented thus: the more recently created variable is the binding instance of the other. 
1 	logic programming 
　constants are identified by pointers pointing to their values  which may be integers or character strings. 
　lists are identified by list pointers pointing to the starting addresses of the individual lists represented as: 
　structures are identified by structure pointers pointing to the starting addresses of the individual structures  represented as: 

　lists and structures are referred to as structured terms. the arity of a structured term is the total number of elements in the term. the total number of unbound variables is another important status of the structured term. it helps by eliminating unnecessary searches for variables in a nonvariable structured term  and also plays a key role in the implementation of restricted and-parallelism. 
1 	garbage 	collection 
the structure copying policy causes the memory space to be consumed rapidly. therefore  garbage collection is frequently needed to reclaim memory space occupied by structured terms no longer used. 
　the simple reference count garbage collection scheme is found to be sufficient to solve the problem. each structured term in the structure store has an extra tag indicating its reference count. when a structured term is first created  its reference count tag is assigned to be one. when the reference to the term needs to be copied  e.g. when a goal including the term is unified with a number of applicable clauses   the tag is incremented by one for each copy. conversely  whenever a reference to it is discarded  the reference count decrements by one. for example  when the term is updated by instantiating variables in it using the existing binding information  the updated term occupies a new space  and thus identifies itself as a different term. in this case  the reference to the old term can be discarded and replaced by a new reference. once the reference count of a structured term reaches zero  the memory space for that term can be reclaimed as the term is no longer used. 
1 	an abstract machine architecture 
in order to study the feasibility and run-time characteristics of the scheme  an abstract dataflow architecture has been simulated. it should be noted  however  that the binding scheme is equally suited to the implementation on many other kinds of architectures. the dataflow architecture is constructed as a ring connected by the following main components  figure 1 : an instruction store where compiled virtual instructions are stored; a packet queue based on a fifo for buffering packet flow; a number of homogeneous processing elements  pes ; a structure store for storing structured terms; and a distribution network for delivering result packets to the instruction store. 
　

figure 1 an abstract dataflow architecture 
　in this dataflow architecture  the information elements  called packets  are flowing simultaneously in different parts of the ring on behalf of different instructions for concurrent execution. hence the ring operates as a pipeline with all of its components actively processing or creating packets simultaneously. 
　when an instruction fails in its execution  the responsible pe immediately sends a  fail  signal to the instruction store so that no more instructions belonging to the same graph are allowed for execution. only when the graph is activated again may the  fail  signal be disabled. 
1 	performance 
six programs have been tested to evaluate the effect of the binding scheme. they have been hand-compiled into dataflow graphs to be stored in the instruction store. the programs are 
　1  determinate list concatenation for a list of 1 elements  append 1 ; 
　1  non-determinate list concatenation of a list of 1 elements with all results  append1 ; 
　1  quicksorting program of a list of 1 elements in a reversed order  qsort ; 
　1  naive reverse of a list of 1 elements  na rev ; 
　1  list checking of a list of 1 elements as a subset of a list of 1 elements  sublist ; 
　1  line presentation program for a cube  cube . 
　their evaluation reflects different characteristics: nondeterminism in  append1  and  sublist ; recursion in  appendl    append1    qsort  and  na rev ; graph copying in  sublist ; and stream processing in  cube . however  the programs do not cover the whole range of benchmarking  though they have closely met the requirements of this phase of evaluation. 
　the following is a description of the performance of the scheme  measured in terms of bes and structured data. in table 1  the maximum lengths  number of variable-instance pairs  of bes  envlen max  are less than three and the average be lengths  envlen ave  averaged over all accessing instants by pes  are less than two. this results from eager variable instantiation and the subsequent be optimisation that merges variable-instance pairs in place. 

table 1 measurements of be operations 
　a be stays in a pe after its processing. when another pe needs to access the same be next time  it will find  from the instruction store  the host pe where the be resides  and then copy it across. meanwhile  the pe sends its own identifier to the instruction store  thus associating itself with the copied be. after being processed  the be will stay in the second pe until it is required again. this lazy copying policy works on a probability basis because there is a probability that the be is required by the same pe for two or more successive updating operations  in which case copying is unnecessary. when only one pe is used in the system  the total number of bes copied by pes  envcpy tot  is zero  so is the copying percentage  % . the program  cube  involves no be operations  and thus no copying is needed. the copying becomes dominant  mostly over 1%  except  sublist  1%  when more  than 1  pes are involved. since the average be sizes are almost minimum  the copying overhead is reasonably affordable. 
　the eager instantiation binding scheme requires extensive copying of structured terms  which is a major shortcoming of the scheme. table 1 summarises the measurements on structured terms. the first row is the average number of structure elements involved in each program  strlen ave   averaged over all accessing instants by pes. the second row is the total number of accesses to the structured terms  stracc tot . it is found that the number of copying operations  strcpy tot  is proportional to the number of structure elements being processed  elecpy tot 1    and to the number of logic inferences in the programs. on average  there is 1 copying operation per logic inference. based on the evaluation results of the overall execution speed of the programs  zhang  1   the copying policy does not impose intolerable overhead   na rev  program  which copies 1 structured terms per logic inference on average  performs even better than others . the copying problem may  however  become more serious when longer structured terms are involved. 

table 1 measurements of structured terms 
　
　one way to reduce the amount of copying is to allow some elements to be shared among different structured terms. knowing that operations on structured terms in logic programs are overwhelmingly performed on list heads and tails  an intuitive idea is to separate heads and tails from other parts of lists. therefore  when a new list is created whose head or tail has been modified from an old one  it may share the remaining part of the old list. this is illustrated in figure 1. 

the situation in figure 1 happens when the list tail of list 
a is bound to a new list  whose elements correspond to e l e m e n t n   element n + 1  ...  element m-1  element tailb. this is one of the most common situations in list processing. as figure 1 suggests  the elements in list a  element 1  element 1  ...  element n-1 need not be copied. the newly constructed list b has its own version of arity  number of variables  first element  last element and tail element. it has the same pointer as in list a pointing to the remaining elements of the list. the list arities  i.e. n and m  here tell the different belongings of the two lists. the amounts of copying of structure elements when the improved list representation is used appears in elecpy tot 1   which is only about half  1 - 1%  of the amounts of copying using the non-shared representation  elecpy tot 1  . compared with the non-shared one  the shared representation introduces little extra overhead  that is incurred from tracing and copying a pointer. 
1 	conclusion 
a binding scheme called eager instantiation has been presented  which allows a variable to be bound and accessed locally in an individual binding environment so that no centralised auxiliary structure is required. therefore  orparallelism can be exploited effectively within a distributed processing environment. it is also easy to be extended for support of restricted and- parallelism. the application of the scheme on a dataflow virtual machine has also been described. the scheme has low implementational complexity and high distributability. 
　the dialog execution model utilising the scheme has been evaluated and reported elsewhere  zhang  1 . the performance obtained is encouraging on a simulated dataflow architecture with up to eight processors. it should be said  however  that the binding scheme is not architecture specific and is suitable for many other kinds of architectures. more complex programs that provide larger search spaces need to be tested to gain broader assessment of the scheme. 
1 	logic programming 
acknowledgment 
the first author would like to thank the uk science and engineering research council for the support of a postdoctoral fellowship. 
