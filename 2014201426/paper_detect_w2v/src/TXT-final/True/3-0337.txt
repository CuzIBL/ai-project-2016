
in this paper we present a framework of reasoning with inconsistent ontologies  in which pre-defined selection functions are used to deal with concept relevance. we examine how the notion of  concept relevance  can be used for reasoning with inconsistent ontologies. we have implemented a prototype called pion  processing inconsistent ontologies   which is based on a syntactic relevance-based selection function. in this paper  we also report the experiments with pion.
1 introduction
there are two main ways to deal with inconsistency in ontologies. one is to diagnose and repair it when we encounter inconsistency schlobach and cornet  1 . another approach is to simply avoid the inconsistency and to apply a non-standard reasoning method to obtain meaningful answers. in this paper  we will focus on the latter  which is more suitable for the setting in the web area. for example  in a typical semantic web setting  one would be importing ontologies from other sources  making it impossible to repair them  and the scale of the combined ontologies may be too large to make repair effective.
¡¡the classical entailment in logics is explosive: any formula is a logical consequence of a contradiction. therefore  conclusions drawn from an inconsistent knowledge base by classical inference may be completely meaningless. the general task of an inconsistency reasoner is: given an inconsistent ontology  return meaningful answers to queries.
¡¡reasoning with inconsistency is a well-known topic in logics and ai. many approaches have been proposed to deal with inconsistency  benferhat and garcia  1; beziau  1; lang and marquis  1; marquis and porquet  1 . the development of paraconsistent logics was initiated to challenge the 'explosive' problem of the standard logics. paraconsistent logics  beziau  1  allow theories that are inconsistent but non-trivial. there are many different paraconsistent logics. most of them are defined on a semantics which allows both a letter and its negation to hold for an interpretation. levesque's limited inference  levesque  1 

 
¡¡¡¡the work reported in this paper was partially supported by the eu-funded sekt project  ist-1 .allows the interpretation of a language in which a truth assignment may map both a letter and its negation to true. extending the idea of levesque's limited inference   schaerf and cadoli  1  proposes s-1-entailment and s-1-entailment for approximate reasoning with tractable results. based on schaerf and cadoli's s-1-entailment   marquis and porquet  1  presents a framework for reasoning with inconsistency by introducing a family of resource-bounded paraconsistent inference relations. several policies  e.g.  the linear order policy  are proposed.  chopra et al.  1  incorporates the local change of belief revision and relevance sensitivity by means of schaerf and cadoli's approximate reasoning method  and shows how relevance can be introduced for approximate reasoning in belief revision. both approaches  marquis'  and chopra's  depend on syntactic selection procedures for extending the approximation set.
¡¡our approach borrows some ideas from schaerf and cadoli's approximation approach  marquis and porquet's paraconsistent reasoning approach  and chopra  parikh  and wassermann's relevance approach. however  our main idea is relatively simple: given a selection function  which can be defined on the syntactic or semantic relevance  we select some consistent sub-theory from an inconsistent ontology. then we apply standard reasoning on the selected sub-theory to find meaningful answers. if a satisfying answer cannot be found  the relevance degree of the selection function is made less restrictive thereby extending the consistent subtheory for further reasoning.
¡¡the main contributions of this paper are: 1  a set of formal definitions to capture reasoning with inconsistent ontologies;  1  a general framework for reasoning with inconsistent ontologies based on selection functions  and  1  some preliminary experiments with an implementation of this framework using a rather simple selection function.
¡¡this paper is organised as follows: section 1 overviews inconsistency in the semantic web by examining several typical examples and scenarios. section 1 presents the framework of reasoning with inconsistent ontologies. section 1 discusses the selection functions section 1 presents the algorithms of pion. section 1 examines how the syntactic-relevance-based selection function can be developed. section 1 describes a
prototype of pion and its evaluation. section 1 discusses further work and concludes the paper.
1 inconsistency in the semantic web
here are several typical scenarios which may cause inconsistencies in the semantic web.
  inconsistency caused by mis-presentation of defaults. a notorious example is the bird ontology in which penguins are specified as the birds which cannot fly  however  it contradicts the default statement 'birds are flying animals'. another typical example is the madcows ontology1 in which madcow is specified as a cow which eats brains of sheep  whereas a cow is considered as a vegetarian by default.
  inconsistency caused by polysemy polysemy refers to the concept of words with multiple meanings. an example of an inconsistent ontology which is caused by polysemy is the marriedwoman example huang et al.  1   in which the concept 'married woman' is used to refer both to a woman who has a husband and to a woman who had a husband but may no longer have one.
  inconsistency through migration from another formalism when an ontology specification is migrated from other data sources  inconsistencies may occur. as has been found in  schlobach and cornet  1   the dice terminology  a dl terminology in the intensive care domain  suffered from a high number of unsatisfiable concepts due to its migration from a frame-based system. in order to make the semantics as explicit as possible  a very restrictive translation has been chosen to highlight as many ambiguities as possible.  schlobach and cornet  1  shows the inconsistent ontology specification in the brain example  in which a brain is considered to be both a body part and a central nervous system  whereas body parts and nervous systems are considered to be disjoint.
  inconsistency caused by multiple sources. when a large ontology specification is generated from multiple sources  in particular when these sources are created by several authors  inconsistencies easily occur. there are three possibilities for ontology reconciliation: merging  aligning  or integrating. no matter whether a new ontology is generated by merging or integrating multiple sources  in both cases general consistency objectives are rather difficult to achieve.
1 formal definitions
we do not restrict ontology specifications to a particular language  although owl and its underlying description logic are the languages we have in mind . in general  an ontology language can be considered to be a set that is generated by a set of syntactic rules. thus  we can consider an ontology specification as a formula set. we use a non-classical entailment for inconsistency reasoning. in the following  we use |= to denote the classical entailment  and use |¡Ö to denote some non-standard inference relation  which may be parameterized to remove ambiguities.
¡¡with classical reasoning  a query ¦Õ given an ontology ¦² can be expressed as an evaluation of the consequence relation ¦² |= ¦Õ. there are only two answers to that query: either 'yes'  ¦² |= ¦Õ   or 'no'  ¦² 1|= ¦Õ . a 'yes' answer means that ¦Õ is a logical consequence of ¦². a 'no' answer  however  means that ¦Õ cannot be deduced from ¦²  because we usually don't adopt the closed world assumption when using an ontology. hence  a 'no' answer does not imply that the negation of ¦Õ holds given an ontology ¦². for reasoning with inconsistent ontologies  it is more suitable to use belnap's four valued logic  belnap  1  to distinguish the following four epistemic states of the answers:
definition 1
 a  over-determined: ¦² |¡Ö ¦Õ and ¦² |¡Ö  ¦Õ.
 b  accepted: ¦² |¡Ö ¦Õ and ¦² 1|¡Ö  ¦Õ.
 c  rejected: ¦² 1|¡Ö ¦Õ and ¦² |¡Ö  ¦Õ.
 d  undetermined: ¦² 1|¡Ö ¦Õ and ¦² 1|¡Ö  ¦Õ.
¡¡for an inconsistency reasoner it is expected that is able to return meaningful answers to queries  given an inconsistent ontology. in the case of a consistent ontology ¦²  classical reasoning is sound  i.e.  a formula ¦Õ deduced from ¦² holds in every model of ¦². this definition is not preferable for an inconsistent ontology ¦² as every formula follows from it using classical entailment. however  often only a small part of ¦² has been incorrectly constructed or modelled  while the remainder of ¦² is correct. therefore  we propose the following definition of soundness.
definition 1  soundness  an inconsistency reasoner |¡Ö is sound if the formulas that follow from an inconsistent theory ¦² follow from a consistent subtheory of ¦² using classical reasoning  namely  the following condition holds:
¦² |¡Ö ¦Õ     ¦²1   ¦²  ¦²1|= ¡Í and ¦²1 |= ¦Õ .
¡¡in other words  the |¡Ö-consequences must be justifiable on the basis of a consistent subset of the theory. note however  that in the previous definition the implication should not hold in the opposite direction. if the implication would also hold in the opposite direction it would lead to an inconsistency reasoner  which returns inconsistent answers. for example if {a  a}   ¦²  then the inconsistency reasoner would return that both a and  a hold given ¦²  which is something we would like to prevent. hence  the inconsistency reasoner should not return answers that follow from any consistent subset of ¦²  but from specifically chosen subsets of ¦². in other words  the selection of specific subsets on which |¡Ö will be based is an integral part of the definition of an inconsistency reasoner  and will be discussed in more detail in the next section.
definition 1  meaningfulness  an answer given by an inconsistency reasoner is meaningful iff it is consistent and sound. namely  it requires not only the soundness condition  but also the following condition:
¦² |¡Ö ¦Õ   ¦² 1|¡Ö  ¦Õ.
an inconsistency reasoner is said to be meaningful iff all of the answers are meaningful.
because of inconsistencies  classical completeness is impossible. we suggest the notion of local completeness:
definition 1  local completeness  an inconsistency reasoner is locally complete with respect to a consistent subtheory ¦²1 iff for any formula ¦Õ  the following condition holds:
¦²1 |= ¦Õ   ¦² |¡Ö ¦Õ.
since the condition can be represented as:
¦² 1|¡Ö ¦Õ   ¦²1|= ¦Õ 
local completeness can be considered as a complement to the soundness property. an answer to a query ¦Õi on ¦² is said to be locally complete with respect to a consistent set ¦²1 iff the following condition holds:
¦²1 |= ¦Õi   ¦² |¡Ö ¦Õi.
definition 1  maximality  an inconsistency reasoner is maximal iff there is a maximal consistent subtheory such that its consequence set is the same as the consequence set of the inconsistency reasoner:
  ¦²1   ¦²   ¦²1|= ¡Í  ¡Ä   ¦²1   ¦²1 ¡Ä ¦²1   ¦²  ¦²1 |= ¡Í ¡Ä
 ¦Õ ¦²1 |= ¦Õ   ¦² |¡Ö ¦Õ  .
we use the same condition to define the maximality for an answer  like we do for local completeness.
definition 1  local soundness  an answer to a query ¦² |¡Ö ¦Õ is said to be locally sound with respect to a consistent set ¦²1   ¦²  iff the following condition holds:
¦² |¡Ö ¦Õ   ¦²1 |= ¦Õ.
namely  for any positive answer  it should be implied by the given consistent subtheory ¦²1 under the standard entailment.
proposition 1
 a  local soundness implies soundness and meaningfulness.  b  maximal completeness implies local completeness.
given a query  there might exist more than one maximal consistent subset and more than one locally-complete consistent subset. such different maximally consistent subsets may give different |¡Ö-consequences for a given query ¦Õ. therefore  arbitrary  maximal  consistent subsets may not be very useful for the evaluation of a query by some inconsistency reasoner. the consistent subsets should be chosen on structural or semantic grounds indicating the relevance of the chosen subset with respect to some query.
1 selection functions
an inconsistency reasoner uses a selection function to determine which consistent subsets of an inconsistent ontology should be considered in its reasoning process. the general framework is independent of the particular choice of selection function. the selection function can either be based on a syntactic approach  like chopra  parikh  and wassermann's syntactic relevance  chopra et al.  1   or based on semantic relevance like for example in computational linguistics as in wordnet  budanitsky and hirst  1 .
¡¡given an ontology  i.e.  a formula set  ¦² and a query ¦Õ  a selection function s is one which returns a subset of ¦² at the step k   1. let l be the ontology language  which is denoted as a formula set. we have the general definition about selection functions as follows:

figure 1: linear extension strategy.
definition 1  selection functions  a selection function s is a mapping s : p l ¡Ál¡Án ¡ú p l  such that s ¦² ¦Õ k   
¦².
definition 1 a selection function s is called monotonic if the subsets it selects monotonically increase or decrease  i.e.  s ¦² ¦Õ k    s ¦² ¦Õ k + 1   or vice verse.
for monotonically increasing selection functions  the initial set is either an emptyset  i.e.  s ¦² ¦Õ 1  =    or a fixed set ¦²1 when the locality is required. for monotonically decreasing selection functions  usually the initial set s ¦² ¦Õ 1  = ¦². the decreasing selection functions will reduce some formulas from the inconsistent set step by step until they find a maximally consistent set.
¡¡monotonically increasing selection functions have the advantage that they do not have to return all subsets for consideration at the same time. if a query ¦² |¡Ö ¦Õ can be answered after considering some consistent subset of the ontology ¦² for some value of k  then other subsets  for higher values of k  don't have to be considered any more  because they will not change the answer of the inconsistency reasoner.
1 strategies
an inconsistency reasoner that uses a monotonically increasing/decreasing selection function will be called an inconsistency reasoner that uses a linear extension strategy and a linear reduction strategy respectively.
¡¡a linear extension strategy is carried out as shown in figure 1. given a query ¦² |¡Ö ¦Õ  the initial consistent subset ¦²1 is set. then the selection function is called to return a consistent subset ¦²1  which extends ¦²1  i.e.  ¦²1   ¦²1   ¦² for the linear extension strategy. if the selection function cannot find a consistent superset of ¦²1  the inconsistency reasoner returns the answer 'undetermined'  i.e.  unknown  to the query. if the set ¦²1 exists  a classical reasoner is used to check if ¦²1 |= ¦Õ holds. if the answer is 'yes'  the inconsistency reasoner returns the 'accepted' answer ¦² |¡Ö ¦Õ. if the answer is 'no'  the inconsistency reasoner further checks the negation of the query ¦²1 |=  ¦Õ. if the answer is 'yes'  the inconsistency reasoner returns the 'rejected' answer ¦² |¡Ö  ¦Õ  otherwise the current result is undetermined  def.1   and the whole process is repeated by calling the selection function for the next consistent subset of ¦² which extends ¦²1.
¡¡it is clear that the linear extension strategy may result in too many 'undetermined' answers to queries when the selection function picks the wrong sequence of monotonically increasing subsets. it would therefore be useful to measure the succesfulness of  linear  extension strategies. notice  that this depends on the choice of the monotonic selection function.
¡¡in general  one should use an extension strategy that is not over-determined and not undetermined. for the linear extension strategy  we can prove that the following properties hold:
proposition 1  linear extension  an inconsistency reasoner using a linear extension strategy satisfies the following properties:  a  never over-determined 
 b  may be undetermined 
 c  always sound 
 d  always meaningful 
 e  always locally complete 
 f  may not be maximal  g  always locally sound.
¡¡therefore  an inconsistency reasoner using a linear extension strategy is useful to create meaningful and sound answers to queries. it is always locally sound and locally complete with respect to a consistent set ¦²1 if the selection function always starts with the consistent set ¦²1  i.e.  s ¦² ¦Õ 1  = ¦²1 . unfortunately it may not be maximal.
¡¡we call this strategy a linear one  because the selection function only follows one possible 'extension chain' for creating consistent subsets. the advantages of the linear strategy is that the reasoner can always focus on the current working set ¦²1. the reasoner doesn't need to keep track of the extension chain. the disadvantage of the linear strategy is that it may lead to an inconsistency reasoner that is undetermined. there exists other strategies which can improve the linear extension approach  for example  by backtracking and heuristics evaluation. we are going to discuss a backtracking strategy in section 1. the second reason why we call the strategy linear is that the computational complexity of the strategy is linear with respect to the complexity of the ontology reasoning. let n be the cardinality |¦²| of an ontology ¦² and let the complexity of |= be e.
proposition 1  complexity of linear extension  the complexity of |¡Ö in the linear extension strategy is n ¡¤ e.
in other words  the linear extension strategy does not significantly increase the complexity of the ontology reasoning  because typically e is already pspace-complete for standard concept languages  donini  1 .
1 syntactic relevance-based selection functions
 chopra et al.  1  proposes syntactic relevance to measure the relationship between two formulas in belief sets  so that the relevance can be used to guide the belief revision based on schaerf and cadoli's method of approximate reasoning. given a formula set ¦²  two atoms p q are directly relevant  denoted by r p q ¦²  iff there is a formula ¦Á ¡Ê ¦² such that p q appear in ¦Á. a pair of atoms p and q are k-relevant with respect to ¦² iff there exist p1 p1 ... pk ¡Ê l such that:  a  p p1 are directly relevant;  b  pi pi+1 are directly relevant  i = 1 ... k   1; and  c  pk q are directly relevant  i.e.  directly relevant is k-relevant for k = 1 .
¡¡the notions of relevance above are based on propositional logics. however  ontology languages are usually written in some fragment of first order logic. we extend the ideas of relevance to those first-order logic-based languages by restricting relevance to the co-occurrence of only the predicate letters or constant symbols. the following definition specialises the general definition of relevance for the case where ¦Õ is a formula in an ontology.
¡¡given a formula ¦Õ  we use i ¦Õ  c ¦Õ  r ¦Õ  to denote the sets of individual names  concept names  and relation names that appear in the formula ¦Õ respectively.
definition 1  direct relevance  two formula ¦Õ ¦× are directly relevant iff there is a common name which appears both in formula ¦Õ and formula ¦×  i.e.  i ¦Õ ¡Éi ¦×  1=  ¡Åc ¦Õ ¡É c ¦×  1=   ¡Å r ¦Õ  ¡É r ¦×  1=  .
definition 1  direct relevance to a set  a formula ¦Õ is relevant to a formula set ¦² iff there exists a formula ¦× ¡Ê ¦² such that ¦Õ and ¦× are directly relevant.
we can similarly specialise the notion of k-relevance.
definition 1  k-relevance  two formulas ¦Õ ¦Õ1 are krelevant with respect to a formula set ¦² iff there exist formulas ¦×1 ...¦×k ¡Ê ¦² such that ¦Õ and ¦×1  ¦×1 and ¦×1  ...  and ¦×k and ¦Õ1 are directly relevant.
definition 1  k-relevance to a set  a formula ¦Õ is krelevant to a formula set ¦² iff there exists a formula ¦× ¡Ê ¦² such that ¦Õ and ¦× are k-relevant with respect to ¦².
in inconsistency reasoning we can use syntactic relevance to define a selection function s to extend the query '¦² |¡Ö ¦Õ ' as follows: we start with the query formula ¦Õ as a starting point for the selection based on syntactic relevance. namely  we define: s ¦² ¦Õ 1  =  .
then the selection function selects the formulas ¦× ¡Ê ¦² which are directly relevant to ¦Õ as a working set  i.e. k = 1  to see whether or not they are sufficient to give an answer to the query. namely  we define:
s ¦² ¦Õ 1  = {¦× ¡Ê ¦² | ¦Õ and ¦× are directly relevant}.
if the reasoning process can obtain an answer to the query  it stops. otherwise the selection function increases the relevance degree by 1  thereby adding more formulas that are relevant to the current working set. namely  we have: s ¦² ¦Õ k  = {¦× ¡Ê ¦²|¦× is directly relevant to s ¦² ¦Õ k 1 }  for k   1. this leads to a  fan out  behavior of the selection function: the first selection is the set of all formulae that are directly relevant to the query; then all formulae are selected that are directly relevant to that set  etc. this intuition is formalized in the following:
proposition 1 the syntactic relevance-based selection function s is monotonically increasing.
proposition 1 if k ¡Ý 1  then s ¦² ¦Õ k  = {¦Õ|¦Õ is  k-1 -relevant to ¦²}
the syntactic relevance-based selection functions defined above usually grows up to an inconsistent set rapidly. that may lead to too many undetermined answers. in order to improve it  we can require that the selection function returns a consistent subset ¦²1 at the step k when s ¦² ¦Õ k  is inconsistent such that s ¦² ¦Õ k 1    ¦²1   s ¦² ¦Õ k . it is actually a kind of backtracking strategies which are used to reduce the number of undetermined answers to improve the linear extension strategy. we call the procedure an over-determined processing odp  of the selection function. note that the overdetermined processing need no to exhaust the powerset of the set s ¦² ¦Õ k  s ¦² ¦Õ k 1   because of the fact that if a consistent set s cannot prove or disprove a query  then nor can any subset of s. therefore  one approach of odp is to return just a maximally consistent subset. let n be |¦²| and k be n   |s|  i.e.  the cardinality difference between the ontology ¦² and its maximal consistent subset s  note that k is usually very small   and let c be the complexity of the consistency checking. the complexity of the over-determined processing is polynomial to the complexity of the consistency checking:
proposition 1  complexity of odp  the	complexity	of the over-determined processing is nk ¡¤ c.
note that odp introduces a degree of non-determinism: selecting different maximal consistent subsets of s ¦² ¦Õ k  may yield different answers to the query ¦² |¡Ö ¦Õ. the simplest example of this is ¦² = {¦Õ  ¦Õ}.
1 prototype of pion
1 implementation
we are implementing the prototype of pion by using swiprolog.1 pion implements an inconsistency reasoner based on an linear extension strategy and the syntactic relevancebased selection function as discussed in sections 1 and 1. the selection function returns the first maximal consistent subset for its over-determined processing. pion is powered by xdig  an extended dig description logic interface for prolog  huang and visser  1 . pion supports the tell requests in dig data format and in owl  and the ask requests in dig data format. a prototype of pion is available for download at the website: http://wasp.cs.vu.nl/sekt/pion.
1 experiments and evaluation
we have tested the prototype of pion by applying it on several example ontologies. these example ontologies are the bird example  the brain example  the marriedwoman example  and the madcow ontolog  which are discussed in section
1. we compare pion's answers with their intuitive answers which is supposed by a human to see to what extend pion can provide intended answers.
¡¡for a query  there might exist the following difference between an answer by pion and its intuitive answer.
  intended answer: pion's answer is the same as the intuitive answer;
  counter-intuitive answer: pion's answer is opposite to the intuitive answer. namely  the intuitive answer is 'accepted' whereas pion's answer is 'rejected'  or vice versa.
  cautious answer: the intuitive answer is 'accepted' or 'rejected'  but pion's answer is 'undetermined'.
  reckless answer: pion's answer is 'accepted' or 'rejected' whereas the intuitive answer is 'undetermined'. we call it a reckless answer  because under this situation pion returns just one of the possible answers without seeking other possibly opposite answers  which may lead to 'undetermined'.
for each concept c in those ontologies  we create an instance 'the c' on them. we make both a positive instance query and a negative instance query of the instance 'the c' for some concepts c1 in the ontologies  like a query 'is the c a c1 '. pion test results are shown in figure 1. of the four test examples  pion can return at least 1% intended answers. of the 1 queries  pion returns 1 cautious answers or reckless answers  and 1 counter-intuitive answers. however  we would like to point out that the high rate of the intended answers includes many 'undetermined' answers. one interesting  and we believe realistic  property of the mad cows ontology is that many concepts which are intuitively disjoint  such as cows and sheep  are not actually declared as being disjoint  keep in mind that owl has an open world semantics  and does not make the unique name assumption . as a result  many queries such as  is the cow a sheep  are indeed undetermined on the basis of the ontology  and pion correctly reports them as undetermined. the average time cost of the tested queries is about 1 seconds even on a low-end pc
 with 1 mhz cpu  1 mb memory under windows 1 .
¡¡the counter-intuitive results occurs in the madcows example. pion returns the 'accepted' answer to the query 'is the mad cow a vegetarian '. this counter-intuitive answer results from the weakness of the syntactic relevance-based selection function  because it always prefers a shorter relevance path when a conflict occurs. in the mad cow example  the path 'mad cow - cow - vegetarian' is shorter than the path 'mad cow - eat brain - eat bodypart - sheep are animals - eat animal - not vegetarian'. therefore  the syntactic relevance-based selection function finds a consistent sub-theory by simply ignoring the fact 'sheep are animals'. the problem results from the unbalanced specification between cow and madcow  in which cow is directly specified as a vegetarian whereas there is no direct statement 'a madcow is not a vegetarian'.
examplequeriesiacaraciaia rate % icr rate % bird1111brain111.1marriedwoman1111madcow111.1ia = intended answers  ca = cautious answers  ra = reckless answers  cia = counter-intuitive answers  ia rate = intended answers %   icr rate = ia+ca+ra % .
figure 1: pion test results¡¡there are several alternative approaches to solve this kind of problems. one is to introduce the locality requirement. namely  the selection function starts with a certain sub-theory which must always be selected. for example  the statement 'sheep are animals' can be considered to be a knowledge statement which cannot be ignored. another approach is to add a shortcut path  like the path 'mad cow - eat animal not vegetarian' to achieve the relevance balance between the concepts 'vegetarian' and 'not vegetarian'  as shown in the second mad cow example of pion testbed. the latter approach can be achieved automatically by accommodation of the semantic relevance from the user queries. the hypothesis is that both concepts appear in a query more frequently  when they are semantically more relevant. therefore  from a semantic point of view  we can add a relevance shortcut path between strongly relevant concepts.
1 discussion and conclusions
in this paper  we have presented a framework for reasoning with inconsistent ontologies. we have introduced the formal definitions of the selection functions  and investigated the strategies of inconsistency reasoning processing based on a linear extension strategy.
¡¡one of the novelties of our approach is that the selection functions depend on individual queries. our approach differs from the traditional one in paraconsistent reasoning  nonmonotonic reasoning  and belief revision  in which a predefined preference ordering for all of the queries is required. this makes our approach more flexible  and less inefficient to obtain intended results. the selection functions can be viewed as ones creating query-specific preference orderings.
¡¡we have implemented and presented a prototype of pion. in this paper we have provided the evaluation report of the prototype by applying it to the several inconsistent ontology examples. the tests show that our approach can obtain intuitive results in most cases for reasoning with inconsistent ontologies. considering the fact that standard reasoners always results in either meaningless answers or incoherence errors for queries on inconsistent ontologies  we can claim that pion can do much better  because it can provide a lot of intuitive  thus meaningful answers. this is a surprising result given the simplicity of our selection function.
¡¡in future work  we are going to test pion with more largescale ontology examples. we are also going to investigate different approaches for selection functions  e.g.  semanticrelevance based  and different extension strategies as alternatives to the linear extension strategy in combination with different selection functions  and test their performance.
