 
　　newer programming languages for artificial intelligence extend the class of available control regimes beyond simple hierarchical control. in so doing  a key issue is using a model that clearly exhibits the relation between modules  processes  access environments  and control environments. this paper presents a model which is applicable to diverse languages and presents a set of control primitives which provide a concise basis on which one can define almost all known regimes of control. 
1. introduction 
　　newer programming languages! for artificial intelligence  e.g.  planner1  conniver 1 bbnllsp.ly qa1' 1 extend the nature of control regimes available to the user. in this paper  we present an information structure model1 which deals with control and access contexts in a programming language; it is based on consideration of the form of run-time data structures which represent program control and variable bindings. the model is designed to help clarify some relationships of hierarchical function calls  backtracking  co-routines  and multiprocess structure. we present the model and its small set of primitive operations  then define several control regimes in terms of the primitives  and then consider extensions to handle cooperating sequential processes. 
1. the basic environment structure 
     in a language which has blocks and procedures  new nomenclature  named variables  can be introduced either by declarations in block heads or through named parameters to procedures. since both define access environments  we call the body of a procedure or block a uniform access module. upon entry to an access module  certain storage is allocated for those new named items which are defined at entry. we call this named allocated storage the basic frame of the module. in addition  certain additional storage for the module may be required for temporary intermediate results of computation; this additional allocated storage we call 
the frame extension. the total storage is called the total frame for the module  or usually just the module frame. 
     a  frame contains other information  in addition to named variables and temporaries. it is often useful to reference a frame by symbolic nomenclature. for this purpose  each frame has a framename  usually the procedure name . when a module is entered  its frame extension is initialized with two pointers  perhaps implicitly ; one  called a link  is a linked access pointer to the frame s  which contains the higher level free variable and parameter bindings accessible within this module. the other  called clink  is associated with control and is a generalized return which points to the calling frame. in algol  these are called the static and dynamic links  respectively. in lisph the two pointers usually reference the same frame  since bindings for variables free in a module are found by 
tracing up the call structure chain.  an exception is the use of functional arguments  and we illustrate that below.  
　　at the time of a call  entry to a lower module   the caller stores in his frame extension a continuation point for the computation. since the continuation point is stored in the caller  the generalized return is simply a pointer to the last active frame. 
     the size of a basic frame is fixed on module entry. it is just large enough to store the parameters and associated information. however  during one function activation  the required size of the frame extension can vary widely  with a computable maximum   since the amount of temporary storage used by this module before calling different lower modules is quite variable. therefore  the allocation of these two frame segments may sometimes  advantageously  be done separately and n on contiguously. this requires a link  blink  from the frame extension to the basic frame which contains the bindings. 
     when a frame is exited  either by a normal exit or by a non-local goto which skips the frame  e. g.   an error condition   it is often useful to perform clean-up action for the frame. examples include: close files opened by the frame which are no longer needed  restore the state of more global structures which have 
been temporarily modified by the frame  etc. terminal action for a frame is carried out by executing an exit function for the frame  passing it as argument the nominal value which the frame is returning as its 
result; the value returned by the exit function is the 
actual value of the frame. the variable values and the exit function are the only components of the frame which can be updated by the user; all the others are fixed at the time of frame allocation. figure 1 summarizes the contents of the frame. 
     figure 1a shows a sketch of an algorithm programmed in a block structure language such as algol 1 with contourslo drawn around access modules. bl has locals n and p  p has parameter n  and b1 locals q and l. figure 1b is a snapshot of the environment structure after the following sequence: bl is entered; p is called  just above p i   the program continuation point after this outer call ; b1 is entered; and f is called from within b1. for each access module there 
1 are two separate segments - one for the basic frame  denoted by the module name  and one for the frame extension  denoted by the module name* . note that the sequence of access links  shown with dotted lines  goes directly from p to b l * and is different from the control chain of calls. however  each points higher 
 earlier  on the stack. 
     a point to note about an access module is that it has no knowledge of any module below it. if an appropriate value   i . e .   one whose type agrees with the stored return type  is provided  continuation in that 
access module can be achieved with only a pointer to the continued frame. no information stored outside this frame is necessary. 
     figure 1 shows two examples in which more than one independent environment structure is maintained. in figure 1a  two coroutines are shown which share common access and control environment a. note that 
the frame extension of a has been copied so that 
returns from b and q may go to different continuation points. 	this is a key point in the model; whenever a frame extension is required for conflicting purposes  a copy is made. 	since frame a is used by two processes  if either coroutine were deleted  the basic frame for a should not be deleted. 	however  one frame extension a* could be deleted in that case  since frame extensions are never referenced directly by more than one process. 	since the basic frame a is shared  either process can update the variable bindings in it; such changes are seen both by b and q  in figure 1b  coroutine q is shown calling a function d with external access chain through b  but with control to return to q. 
	1. 	primitive functions 
     in this model for access module activation  each frame is generally released upon exit of that module. only if a frame is still referenced is it retained. all non-chained references to a frame  and to the environment structure it heads  are made through a special protected data type called an environment descriptor  abbreviated ed. the heads of all environment chains are referenced only from this space of descriptors.  the one exception is the implicit ed for the currently active process.  the primitive functions create an ed for a specified frame and update the contents of an ed; create a new frame with specified contents  and allow execution of a computation in that context; and access and update the exit function for a frame. note that none of the primitives manipulate the links of existing frames; therefore  only well-formed frame chains exist   i . e .   no ring structures . 
1  environ pos  - creates an environment descriptor for the frame specified by pos. 
1  setenv olded  pos  -- changes the contents of an existing environment descriptor olded to point to the frame specified by pos. as a side effect  it releases storage referenced only through previous contents of olded. 
1  mkframe epos apos  epos bpos bcopflg  -- creates a new frame and returns an ed for that frame. the frame extension is copied from the frame specified by epos  and the alink and clink are specified by apos and epos  respectively. the blink points to the basic frame specified by bpos  or to a copy of the basic frame if bcopflg=true. in use  arguments may be omitted; bcopflg is defaulted to false; apos  bpos and epos are defaulted to the corresponding fields of the frame specified by epos. thus mkframe epos  creates a new frame extension identical to that specified by epos. 
1  enveval forra apos cpos  - creates a new frame and initiates a computation with this environment structure. alink and clink point to frames specified by apos and epos  respectively; and form specifies the code to be executed  or the expression to be evaluated in this new environment. if apos or cpos are omitted  they are defaulted to the alink or clink of this invocation of enveval. 
thus  enveval form  is the usual call 	to 	an interpreter  and has the same effect as if the value of form had appeared in place of the simple call to enveval. 
1  setexfn pos fn  - places a pointer to a user defined function in the exitfn field of the frame pos. if the system is using the exitfn  this will create a new function which is the composition of the user function  applied first  and the system function. on frame exit  the exitfn will be called with one argument  the value returned by the frame code; the value returned by fn will be the actual value r e turned to the frame specified by clink. 
1  getexfn pos  - gets the user set function stored in exitfn of frame pos. returns nil if none has been explicitly stored there. 
1  framenm pos  -- returns the framename of frame pos. 
a frame specification  i.e.   pos  apos  bpos  epos  epos above} is one of the following: 
1. an integer n: 
a. n=1 specifies the frame allocated on activation of the function environ  setenv  etc. in the case of environ  setenv and mkframe  the continuation point is set up so that a value returned to this frame  using enveval  is returned as a 
value of the original call to environ  setenv or mkframe. 
b. n 1 specifies the frame n links down the control 
link chain from the n=1 frame. 
c. n 1 specifies the frame ini links down the access link chain from the n=1 frame  
1. a list of two elements  f n  where f is a framename and n is an integer. this gives the nth frame with name f  where a positive  negative  
value for n specifies the control  access  chain 
environment. 
1. the distinguished constant nil. as an access-link specification  nil specifies that only global values are to be used free. a process which returns along a nil control-link will halt. doing a setenv ed nil  releases frame storage formerly referenced only through ed  without tying up any 
new storage. 
1. an ed  environment descriptor . when given an ed argument created by a prior call on environ  environ creates a new descriptor with the same contents as ed; setenv copies the contents of ed 
into olded. 
1. a list   ed   consisting of exactly one ed. the contents of the listed ed are used identically to 
that of an unlisted ed. however  after this value is used in any of the functions  setenv ed.nil  is done  thus releasing the frame storage formerly referenced only through ed. this has been com-
bined into an argument form rather than allowing the user to do a setenv explicitly because in the call to enveval the contents are needed  so it cannot be done before the call; it cannot be done explicitly after the enveval since control might never return to that point. 
	1. 	non-primitive control functions 
     to illustrate the use of these primitive control functions  we explain a number of control regimes which differ from the usual nested function call-return hierarchical structure  and define their control structure routines in terms of the primitives. we include stack jumps  function closure  and several multiprocessing disciplines. in programming examples  we 
use the syntax and semantics of a lisp-like system. in an ordinary hierarchical control structure 
system  if module f calls g  g calls h  and h calls j  it is impossible for j to return to f without going back through g and h. consider some program in which a search is implemented as a series of such nested function calls. suppose j discovered that the call to g was inappropriate and wanted to return to f with such a message. in a hierarchical control structure  h and g would both have to be prepared to pass such a message back. however  in general  the function j should not have to know how to force intermediaries; it should be able to pass control directly to the relevant module. two functions may be defined to allow such jumpbacks.  these are implemented in bbn-lisp;1 experience has shown them to be quite useful.  the first function  retfrom form pos   evaluates form in the current con-
text  and returns its value from the frame specified by pos to that frame's caller; in the above example  this returns a value to g's caller  i.e.  p  the second 
function  retevakform  pos   evaluates form in the context of the caller of pos and returns the  value of the form to that caller. these are easily defined in terms of enveval: 
retfrom form pos  = enveval{form 1 pos  retevalform  pos  = envevalform  pos  pos  
 the second argument to retfrom establishes that the current environment is to be used for the evaluation of 
form.  
　　as another example of the use of retfrom  consider an implementation of the lisp error protection mechanism. the programmer  wraps a form in errorset   i.e.  errorset form  which is defined as cons eval form  nil . this  wrapping  indicates to 
the system the programmer's intent that any errors which arise in the evaluation of form are to be handled by the function containing the errorset. since the value of errorset in the non-error case is always a list consisting of one element  the value of form   an error can be indicated by forcing errorset to return any non-list item. 	hence  the system function error can be defined as retfrom nil  errorset 1   where 
uppercase items are literal objects in lisp. this jumps back over all intermediary calls to return nil as the value of the most recent occurrence of errorset in the hierarchical calling sequence. 
　　in the following  we employ envapply which takes as arguments a function name and list of  already evaluated  arguments for that function. envapply simply 
creates the appropriate form for enveval. 
envapply fn args aframe  cframe  = enveval list apply   list quote  fn   list quote  args    aframe  cframe  
　　a central notion for control structures is a pairing of a function with an environment for its evaluation. following lisp  we call such an object a funarg. 
funargs are created by the procedure function  defined function fn =list funarg  fn  environ 1   
that is  in our implementation  a funarg is a list of three elements: the indicator funarg  a function  and an environment descriptor.  the argument to environ makes it reference the frame which called function.  a funarg list  being a globally valid data structure  can be passed as an argument  returned as a result  or assigned as the value of appropriately typed variables. when the language evaluator gets a form  fen arg1 arg1 ... argn  whose functional object fen is a funarg  i. e.   a list  funarg fn-name ed   it 
creates a list  args  of  the values of  argl  arg1  . . . . argn and does envapply second fcn  args third fcn   1  the environment in this case is used exactly like the original lisp a-list. moses 1 and weizenbaum1 have discussed the use of function for preserving binding contexts. figure 1 illustrates the environment structure where a functional has been passed down: the function foo with variables x and l has been called; foo called mapcar x function fie   and fie has been entered. note that along the access chain the first free l seen in fie is bound in foo  although there is a bound variable l in mapcar which occurs first in the control chain. since frames are retained  a funarg can be returned to higher contexts and still work.  burge1 gives examples of the use of funargs passed up as values.  
　　in the above description  the environment pointer is used only to save the access environment. 	in fact  however  the pointer records the state of a process at the instant of some call  having both access and 
control environments. hence  such an environment pointer serves as part of a process handle. it is convenient to additionally specify an action to take when the process is restarted and some information to be passed to that process from the one restarting it. the funarg can be reinterpreted to provide these features. the function component specifies the first module to be run in a restarted process  and the arguments  evaluated in the caller  provided to that function can be used to pass information. hence  a funarg can be used as a complete process handle. it proves convenient for a running process to be able to reference its own process handle. to make this simple  we adopt the convention that the global variable curproc is kept updated to the current running process. 
　　with this introduction  we now define the routines start and resume  which allow control to pass among a set of coordinated sequential processes  i.e.   coroutines  in which each maintains its own control and access environment  with perhaps some sharing . a coroutine system consists of n coroutines each of 
which has a funarg handle on those other coroutines to which it may transfer control. to initiate a process represented by the funarg fp  use start  we use 
brackets below to delimit comments : 
start fp.args  = curproc - fp; 
  curproc is a global variable set to the current process funarg   ; 
envapply second fp  args third fp  third fp   
once the variable curproc is initialized  and any coroutine started  resume will transfer control between 
n coroutines. the control point saved is just outside the resume  and the user specifies a function  backfn  to be called when control returns  i.e.  the process is resumed. this function is destructively inserted in 
the funarg list. the args to this function are specified by the coroutine transferring back to this point. 
resume fnarg args backfn  = second  curproc  - backfn; 
 save the specified backfn for a subsequent resume back here  
setenv third curproc   1 ; 
　　 environment saved is the caller of resume  curproc - fnarg; 
 set up curproc for the coroutine to be activated  
envapply second fnarg  args third fnarg   third  fnarg   
 activate the specified coroutine by applying its backfn to args  
　　we call a funarg used in this way a process funarg. the state of a  process  is updated by destructively modifying a list to change its continuation function  and similarly directly modifying its environment descriptor in the list. a pseudo-multiprocessing capability can be added to the system using these process funargs if each process takes responsibility for requesting additional time for processing from a supervisor or by explicitly passing control as in conniver 1 a more automatic multiprocessing control regime using interrupts is discussed later. 
     backtracking is a technique by which certain environments are saved before a function return  and later restored if needed. 	control is restored in a strictly last saved  first restored order. 	as an example of its use  consider a function which returns one  selected  value from a set of computed values but can effectively return an alternative selection if the 
first selection was inadequate. that is  the current process can fail back to a previously specified fail set point and then redo the computation with a new selection. a sequence of different selections can lead 
to a stack of failset points  and successive fails can restart at each in turn. backtracking thus provides a way of doing a depth-first search of a tree with return to previous branch points. 
     we define fail and failset below. we use push l a  which adds a to the front of l  and pop l  which removes one element and returns the first element of l. failist is the stack of failset points. as defined below  fail can reverse certain changes when returning to the previous failset point by explicit direction at the point of failure.  to automatically undo certain side effects and binding changes  we could define  undoable  functions which add to failist forms whose evaluation will reset appropriate cells. fail 
could then eval all forms through the next ed and then call enveval.  
failset{   = push failist environ 1   
        1 means environment outside failset  fail message  = enveval message list pop failist    
     the function select defined below returns the first element of its argument set when first called; upon subsequent fails back to select  successive elements from set are returned. if set is exhausted  failure is propagated back. the code uses the fact that the binding environment saved by failset shares the variable fig with the instance of select which calls failset. the test of fig is reached in two ways: after a call on failset  in which case fig is false  and after a failure  in 
which case fig is true . 
select set undolist  = progt  fig  s1: if null set  then fail undolist   leave here and 
undo as specified  
fig - false; failsetot 
 fig is true iff we have failed to this point; then 
set has been popped  
if fig then go sl ; fig - true; returntpop set  ; 
end 
floyd  1 hewitt 1 and golomb and baumert 1 have discussed uses for backtracking in problem solving. sussman l 1 has discussed a number of problems with backtracking. in general  it proves to be too simple a form of switching between environments. use of the multiple process feature described above provides much more flexibility. 
1. 	coordinated sequential processes and parallel processing 
     it should be noted that in the model above  control must be explicitly transferred from one active environment to another  by means of enveval or resume . we use the t e r m   coordinated sequential process  to describe such a control regime. there are situations in which a problem statement is simplified by taking a 
quite different point of view - assuming parallel  cooperating sequential  processes which synchronize only when required  e. g.   by means of dijkstra's 1 p and v operations . using our coordinated sequential processes with interrupts  we can define such a control regime. 
     in our model of environment structures  there is a tree formed by the control links  a dendrarchy  of frames. one terminal node is marked for activity by the current control bubble  the point where the language evaluator is operating . all other terminal nodes are referenced by environment descriptors or by an access link pointer of a frame in the tree. to extend the model to multiple parallel processes in a single processor system  k branches of the tree must 
be simultaneously marked active. then the control bubble of the processor must be switched from one active node to another according to some scheduling algorithm. 
     to implement cooperating sequential processes in our model  it is simplest to think of adjoining to the set of processes a distinguished process  ps  which 
acts as a supervisor or monitor. this monitor schedules processes for service and maintains several privileged data structures  e.g.   queues for semaphores and active processes .  a related technique is 
used by premier  1   
     the basic functions necessary to manipulate parallel processes allow process activation  stopping  continuing  synchronization and status querying. in a single processor coordinated sequential process model  these can all be defined by calls  through 
enveval  to the monitor ps. specifications for these functions are; 
1  process form  apos  cpos  -- this is similar to enveval except that it creates a new active process p' for the evaluation of form  and returns 
to the creating process a process descriptor  pd  which acts as a handle on p'. 
in this model  the pd could be a pointer to a list which has been placed on a  runnable  queue in ps  and which is interpreted by ps when the scheduler in ps gives this process a time quantum. one element of the process descriptor gives the status of the process  e.g.   running or stopped. process is defined using environ  to obtain an environment descriptor used as part of the pd  and enveval  to call ps   
1  stop pd  - halts the execution of the process specified by pd - ps removes the process from runnable queue. the value returned is an ed of the current environment of pd. 
1  continue pd  -- returns pd to the runnable queues. 
1  status pd  - value is an indication of status of pd. 
1  obtain semaphore  - this dijkstra p operator transfers control to ps  by enveval  which determines if a resource is available  i. e   semaphore count positive . ps either hands control back to pi  with enveval  having decremented the the semaphore count  or enters p1 on that semaphore's queue in ps's environment and switches control to a runnable process. 
1  release semaphore  -- this dijkstra v operator increments the semaphore count; if the count goes positive  one process is moved from the semaphore queue  if any exist  onto the runnable queue and the count is decremented. it then hands control back to the calling process. 
     we emphasize that these six functions can be defined in terms of the control primitives of section 1. 
     scheduling of runnable processes could be done by having each process by agreement ask for a time resource  i . e .   obtain time   at appropriate intervals. in this scheduling model  control never leaves a process without its knowledge  and the monitor simply acts as a bookkeeping mechanism. 	alternatively  ordinary time-sharing among processes on a time quantum basis could be implemented through a timer interrupt mechanism. 	interrupts are treated as forced 

calls to environ  to obtain an ed for the current state   and then an enveval to the monitor process. the only problem which must be handled by the system in forcing the call to environ is making sure the interrupted process is in a clean state; that is  one in which basic communication assumptions about states of pointers  queues  buffers  etc. are true  e.g.  no pointers in machine registers which should be traced during garbage collection . this can be ensured if asynchronous hardware interrupts perform only minimal necessary operations  and set a software interrupt flag. soft-
ware checks made before procedure calls  returns and backward jumps within program will ensure that a timely response in a clean state will occur. 
　　the ed of the interrupted process is sufficient to restart it  and can be saved on the runnable queue within a process descriptor. because timer interrupts are asynchronous with other processing in such a simulated multiprocessor system  evaluation of forms in the dynamic environment of another running process cannot be done consistently; however  the ed obtained from stopping a process provides a consistent environment. because of this interrupt asynchrony  in order to ensure system integrity  queue and semaphore management must be uninterruptible  e.g.  at 
the highest priority level. 
     obtaining a system of cooperating sequential processes as an extension of the primitives has a number of desirable attributes. most important  perhaps  it allows the scheduler to be defined by the user. when parallel processes are used to realize a breadth-first search of an or-graph  there is a significant issue of how the competing processes are to be allotted time. provision for a user supplied scheduler establishes a framework in which an intelligent allocation algorithm can be employed. 
　　once a multi-process supervisor is defined  a variety of additional control structures may be readily created. as an example  consider multiple parallel returns - the ability to return from a single activation of a module g several times with several  different  
values. for g to return to its caller with value given by val and still continue to run  g simply calls process val  1 . then the current g and the new process proceed in parallel. 
1. conclusion 
　　in providing linguistic facilities more complex than hierarchical control  a key problem is finding a model that clearly exhibits the relation between processes  access modules  and their environment. this paper has presented a model which is applicable to languages as diverse as lisp  apl and pl/i and can be used for the essential aspects of control and access in each. the control primitives provide a small basis on which one can define almost all known regimes of control. 
　　although not stressed in this paper  there is an implementation for the model which is perfectly general  yet for several subcases  e.g.  simple recursion and backtracking  this implementation is as efficient as existing special techniques. the main ideas of the implementation are as follows  cf.  for details . the basic frame and frame extension are 
treated as potentially discontiguous segments. when a frame extension is to be used for running  it is copied to an open stack end if not there already  so 
that ordinary nested calls can use simple stack discipline for storage management. reference counts are combined with a count propagation technique to ensure 
that only those frames are kept which are still in use. 
　　thus  the model provides both a linguistic framework for expressing control regimes  and a practical basis for an implementation. it is being incorporated intobbn-lisp.1 
1. acknowledgments 
this work was supported in part by the advanced 
research projects agency under contracts dahc 1 and f1-1  and by the u.s. air 
force electronics systems division under contract 
f1-c-1. daniel bobrow was at bolt beranek and newman  cambridge  massachusetts  when many of the ideas in this paper were first developed. 
