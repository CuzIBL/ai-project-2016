 
in this paper we present a formalization of behavior-based planning for nonholonomic robotic systems. this work provides a framework that integrates features of reactive planning models with modern control-theory-based robotic approaches in the area of path-planning for nonholonomic robots. in particular  we introduce a motion description language  mdle  that provides a formal basis for robot programming using behaviors  and at the same time permits incorporation of kinematic models of robots given in the form of differential equations. the structure of the language mdle is such as to allow descriptions of triggers  generated by sensors  in the language. feedback and feedforward control laws are selected and executed by the triggering events. we demonstrate the use of mdle in the area of motion planning for nonholonomic robots. such models impose limitations on stabilizability via smooth feedback  i.e. piecing together open loop and closed loop trajectories becomes essential in these circumstances  and mdle enables one to describe such piecing together in a systematic manner. a reactive planner using the formalism of the paper is described. we demonstrate obstacle avoidance with limited range sensors as a test of this planner. 
1 	introduction 
the problems of obstacle avoidance and path planning with autonomous mobile robots have been studied in various settings.  lumelsky  1; lozano-perez  1; khatib  1; koditschek  1; shahidi et al.  1 . 
　*this research was supported in parts by grants from the national science foundation's engineering research centers program: nsfd cdr 1  the afosr university research initiative program  under grant afosr1  and afosr-f1-j-1  from nsf iri-
1   onr  n1-j-1   afosr  f1-1   the arpa/rome laboratory planning initiative  f1-c-1 and by ar1  mda-1-r-1  subcontract through microelectronics and design  inc.  
1 	action and perception 
these approaches either assumed that the planner had to have substantive a priori information about the location  shapes and sizes of obstacles  or assumed that the constraints on the robot  geometric and kinematic  were holonomic or integrable. in practice however most real world robotic systems have little a priori information about the shapes and size of the obstacles and in addition include kinematic constraints that are nonholonomic  see section 1 for more details on nonholonomic constraints . a few examples of nonholonomic systems are  models of a front wheel drive car  dextrous manipulation or assembly with robotic hands  attitude control of a satellite etc. as traditional path planners assume arbitrary motion they cannot be applied to nonholonomic robots as they result in nonfeasible trajectories i.e. trajectories that do not satisfy the constraints on the configuration variables. 
　more recently  researchers have been examining nonholonomic path planning in the presence of obstacles  laumond  1; barraquand and latombe  1; mirtich and canny  1; hu and brady  1 . however  while most of these planners provide some excellent results they are quite rigid in the choice of control laws used to steer the robots and often do not exploit the control laws available in control literature  for example  murray and sastry  1; sussmann  1; coron  1; de wit and sordalen  1 . they also assume near complete a priori information about the world and only account for small changes in the environment. 
　on the other hand behavior-based robots  brooks  1; arkin  1   that use real-time  sensor-based  approaches  have been able to handle more realistic models of sensing. perhaps best known among this work is brooks' use of task achieving behaviors as the primary level of task decomposition. he introduces the concept of a subsumption architecture which is essentially a structured and layered set of behaviors with increasing levels of competence. these  reactive  systems typically exploit domain constraints  using clever algorithms to allow fast processing of complex sensor information  cf.  horswill  1  . although this approach has significant advantages from the point of view of architectural design and programming flexibility  it has resisted mathematical formalization and is not amenable to tests for optimally. comparing two sets of behaviors  even within the same task  is complex and the domain-dependent nature of the solutions can cause these systems to be basically incommensurate - one may fail some times  one may fail at other times and comparison is difficult. in addition nature of these systems makes the improvement of behaviors over time difficult. 1 
　the inability to integrate the underlying geometry with real time sensor information stems from the lack of a powerful enough framework to integrate the two approaches. this paper is a step in the direction of providing such a framework  integrating features of reactive planning with modern control-theory-based approaches to steer nonholonomic robots. as the first step  we introduce a motion description language  mdle  that provides a formal basis for robot programming using behaviors  and at the same time permits incorporation of kinematic models of robots given in the form of differential equations. the structure of the language mdle  based on brockett's mdl brockett  1   allows descriptions of triggers  generated by sensors  in the language. feedback and feedforward control laws are selected and executed by the triggering events. 
　mdle is particularly well suited to the demands of nonholonomic motion-planning with limited range sensors. as nonholonomic robot models impose limitations on stabilizability via smooth feedback  brockett  1   the ability to piece together open-loop and closed-loop trajectories becomes essential. mdle enables one to describe such piecing together in a systematic manner. as an example of the strength of this language  we show that it can be used to support a reactive planner for nonholonomic motion planning in the presence of obstacles  using limited range sensors for obstacles detection. in addition  the system assumes no a priori information on the location and shapes of the obstacles. 
　in section 1 we give a brief description of nonholonomic constraints that motivates the mathematical model of the motion description language. in section 1 we present details of mdle  a language that provides a formal basis for specifying behaviors. an example of a path planner using the formalism of the language is presented in section 1. we then describe how we can update world models in section 1 and provide examples of the system's performance. section 1 includes final remarks and future directions for research. 


figure 1: nonfeasible trajectories due to nonholonomic constraints 
an algebraic constraint on the configuration space. a kinematic constraint is said to be integrate if there exists a vector valued function such that 
 1  
an integrable kinematic constraint is hence equivalent to a holonomic constraint. kinematic constraints that are not integrable are said to be nonholonomic. the constraint  1  defines a  1n - k  dimensional smooth manifold m = {{q q  a q q = 1}. these kinematic constraints generate a set of constraint forces so as to ensure that the system does not move in the direction of the rows of the constraint matrix  see fig 1 . in mechanical systems such constraints are often those of rolling without slipping  conservation of angular momentum etc. if the controls then the kinematics are sufficient to model the system and  1  can be written in the form of a drift free control system 
		 1  
with state x t  and control u t   and each b; is a vector field. often such drift free  completely  nonholonomic systems are controllable  cf.  murray et a/.  1  . in the rest of the paper we assume that a nonholonomic robot is modeled by differential equations of the form  1   and the system is controllable. 
1 	language for motion planning 
to formalize behaviors that control a nonholonomic robot  we must provide a formal basis for the motions  in terms of control laws  and a basis for such items as receipt of sensing information and behavioral changes  interrupts  upon receiving certain such items. mdle provides a formal language for specifying these items in a kinetic state machine1 which can be thought of as the continuous analog of a finite automaton. in the framework of mdle these kinetic state machines are governed by differential equations of the form 
		 1  
   1 the concept of kinetic state machines was first introduced by brockett  brockett  1 . 


1 	action and perception 

the system from a given initial state x1 to a final state xf is to use these partial plan to reach the final state  and then to store the result as a plan consisting of: t = is the partial plan consisting 
of only those behaviors and atoms in each behavior that have been executed for t   1. 
the length of a plan is given by and the time of execution of the plan is given by = 
 inote tnat as a partial plan is generated with limited information of the world  not all the behaviors and not every atom in a behavior generated by the partial plan may be executed at run time because there may be several fr's with the same f 's. for example  let us consider a behavior . let us assume that the atom is interrupted by now as explained earlier will begin to execute. but if the atom will not be executed and  depending ot course on e1  will begin to execute. 
 given an algorithm that generates a plan t we define a candidate measure of performance of the plan as 
 1  
where r is a normalizing factor having the units of time.  one need not limit oneself to such additive combinations although this is the only case used here.  
　defining a performance measure for a path planner is a rather difficult task as it is largely dependent on the goal the robot seeks to achieve. some path planners use the total time to achieve the goal as a measure of performance. in many situations one might be interested in not only the time but also on the smoothness of the path traversed or the number of times switching between different controls was necessary. for example consider the task of parallel parking of a car. one might be able to achieve the goal by using only open-loop controls but switching between them at regular intervals  hence possibly reducing the time to achieve the goal but compromising on the smoothness of the path. on the other hand if one uses a time dependent feedback law  the same task could be achieved  possibly by moving along a smooth trajectory but this time taking a longer time to achieve the goal. this indicates a trade-off between two competing requirements which is captured by the performance measure  1 . 
we now define the optimal performance of a plan as 
		 1  
here the minimization is performed over the subset of plans generated by the subset b of admissible behaviors. 
　due to space limitations  the above has been necessarily terse and short on examples. for more detail and for examples of kinetic state machines  behaviors and performance measures the interested reader is referred to  manikonda et a/.  1 . 
1 	path planning and obstacle avoidance 
using the language defined above  we now present a planner which allows us to do task-planning and obstacle avoidance for a nonholonomic robot with limited range sensors. as should be clear from the above  under our framework this involves the generation of partial plans given local sensor information  such that in a global sense the robot is steered towards the goal. although in general the partial plans generated will largely depend on the choice of the state machine  the differential equations governing the robot and the sensor information   in this section we describe a fairly general purpose planner and its implementation details in mdle. the task of the planner is out lined as follows: 
1. interpret local sensor information to generate a  control point  and an obstacle free neighborhood containing this  control point  to which the robot is to be steered. 
1. from the given alphabet select atoms  that could be used to steer the robot  in general  depending on the richness of the alphabet   there could be more than one behavior to steer the robot to the control point . 
1. calculate the scaling factor a  crucial  as it determines the speed of the robot . having calculated a  calculate or approximate  the duration for which each atom is to be executed. 
1. generate an optimal partial plan  by minimizing the performance measure  1 . the minimization is performed over the admissible behaviors. 
1. execute the partial plan and update runtime information regarding actual time of execution of behaviors in the partial plan  sensor information etc. 
1. given an updated world and partial plans generate an optimal plan. 
　planning is being done at two levels - global and local. for local planning  obstacle free  non feasible paths are generated using potential functions assuming that the robot is holonomic. a partial plan  feasible path  is then generated that obeys the constraints in the configuration variables. as feasible trajectories are only approximations to the trajectories generated using potential functions  collision with obstacles could occur while tracing them. while the robot is in motion  collisions are avoided by using the sensor information to trigger interrupts as described previously. 
　at a global level heuristics  along with the world map generated while the robot is en route to the goal  are used to solve the problem of cycles. in the remainder of this section we describe this planner in more detail. 
　critical to the planner is sensor information  location and calibration of sensors   the generation of  control points  and obstacle free neighborhoods  and selecting of atoms. each of these is explained in some detail in the following subsections. one should note here that the planner could be used with most nonholonomic robot  by selecting the corresponding alphabet and associating rules with the selection of atoms. in our simulations we have assumed that the robot is modeled along the lines of a unicycle. 


1 	action and perception 

　in the implementation of the planner  the data structure of a plan is a linked list of atoms  each atom being represented by a structure that has information regarding the scaling factors   the interrupt function e  the maximum time of execution of the kinetic state machine  the inputs  controls  and a pointer to the kinetic state machine. as mentioned earlier it is possible that while executing a partial plan only some of the behaviors may be executed as planned  some may be executed only for a fraction of the the intended execution time and others may not be executed at all. update plan updates the fields of each atom of the partial plan after it has completed its execution. once the plans/partial plans have been generated  these plans have to be executed. execute plan involves decomposition of the plan into behaviors and further into atoms. the kinetic state machine is allowed to evolve as explained in section 1  equation 1. fig. 1 shows some paths generated by the planner for a robot modeled along the lines of a unicycle.1 it is important to note that while the plan is being executed the sensors are being continuously scanned and are present in a low level feedback loop hence preventing any collisions with obstacles. 

figure 1: paths generated by the planner 
　as the local world is a list of nodes  each of which is added to the list as the robot generates partial plans it is possible that while generating a plan the robot may have to revisit a node  and hence introducing redundant information into the world. cleanup keeps track of these redundancies in the map and deletes/adds nodes in the list. 
1 	planning in the obstacle free disk 
to find the best direction of travel in the obstacle free disk we use the approach of potential functions. as in 
　1 it should be pointed out here that the obstacle-free disks generated by the planner violate the exact definition given above  but this is because in the simulator we have used only sensors of the eye to generate obstacle-free disks. for now  those obstacles that are not detected by the sensors are treated as being in the blind spots of the robot. 
the earlier work on path planning with potential tunctions  the idea behind our construction is based on electrostatic field theory - charges of the same sign repel and charges of the opposite sign attract in accordance with coulomb's law. hence we assign a positive charge distribution to the obstacles and the mobile robot and a negative charge distribution to the goal. the idea is to construct a vector field which will give the best direction of travel based on the location of the obstacles and the goal. 
　the robot is approximated to a point robot and as sensors can detect only points on the boundaries of the obstacles that lie in their line of vision  we treat obstacles as a collection of point charges and assign charges to them depending on which sensor detects them. the intersection of the resultant gradient field with the circumference of the obstacle free disks gives the desired location to which robot is to be steered.  one should observe here that unlike earlier approaches the gradient field is not directly used to steer the robot. as integral curves of the resultant gradient field may not result in feasible trajectories we use the resultant gradient field only to determine the scaling factors and xf on the circumference of the obstacle free disk.  
　once the initial and desired final state of the robot is known control inputs are chosen from those available in the language to generate feasible trajectories to steer the robot from the initial location to the final desired location. if more than one such control achieves the task then the performance measure can be used to select the optimum one. 
　as we are using a kinematic model of the robot an underlying assumption is that the robot is moving at low velocities and we can bring the robot to a halt simply by turning off the controls. to determine scaling factors  which are directly related to the velocities if the inputs to the equations governing the motion of the robot  we use the sum total of both the attractive and repulsive forces is used to determine the bounds on the velocities and hence the bounds on the scaling factors. a simple example of such a function is given by 

where fa and fr are the net attractive and repulsive forces acting on the robot. observe that when the robot is close to either the obstacle  the goal or both  it moves with a lower velocity hence making the kinematic model more realistic. 
　by intelligently choosing weights on the charges  see  manikonda  1  for more details  we can ensure that the robot either avoids the obstacle or gets close enough 
to an obstacle such that  in which case it traces the boundaries of obstacles to a point where it finds an edge or is heading in the direction of the goal. remark :it is important to mention here that as we are making no assumptions on the location sizes or shapes of the obstacles guaranteeing the existence of a path is very difficult  though empirical results have shown that if a path exists the robot has more often than not found it. more importance here is stressed on the ability of the 

planner to integrate real time sensor information with control-theory-based approaches to steer nonholonomic systems in a systematic way. as mentioned earlier nonholonomic robots impose limitations on stabilizability via smooth feedback and the planner developed under the framework of the language provides an elegant way of piecing together of various control strategies. 
tracing boundaries the real behavior-based aspects of our planner can be seen when tracing the boundaries of obstacles. planning in  is a closed loop 
planning strategy which essentially results in a trace behavior that traces the boundaries of the obstacles. given the limited sensor and world information it is probable that the direction of trace may have been wrong. hence we use a heuristic function euclidean distance between at which the trace behavior was started  as an estimate of how far the robot has strayed from the goal. the robot traces the boundary as long as where fs is some permitted distance from where the trace behavior was started. if then we retrace path and trace the boundary of the obstacle in the opposite direction. if terminal conditions for the trace are not met  we set 

remark: retracing a path under this framework is a rather simple task. observing that the system is a drift free system  retracing involves executing the past n partial plans in a reverse order with scaling factor. erates a feasible trajectory that can track this nonfeasible trajectory and lie entirely in such that we can replace 
　　after the execution of  i  and  ii  we now have partial plans that steer the robot from 
{1      n} such that the trajectory lies entirely in 
the planner now explores the possibility of finding  non feasible trajectories from 
1        n  k = 1         n such that these trajectories lie entirely in  and the performance of the plan that generates this trajectory is better than the earlier one. 
　fig. 1 shows paths generated by the planner after it has gained partial knowledge of the world it has explored in its first attempt to reach the goal. the bold solid lines denote the new trajectories  partial plans  generated after partial knowledge of the world has been gained. it clearly shows an improvement in the performance of the planner as the length of the plan is nearly a third of the plan generated in the first attempt. 
remarks:  i . one should note that generating plans of better performance does not necessarily imply that where is the new plan but could simply imply cnoosing the right scaling factors  such that 
. 
 ii . one need not restrict the generation on nonfeasible trajectories to straight line segments  but could instead use arc or even curves that best fit the centers of these obstacle free disks. 


1 	action and perception 

figure 1: paths generated by the planner 
1 	final remarks 
this paper is an attempt to bring together aspects of nonholonomic motion planning with robots as discussed by researchers in the communities of behavior-based planning and control theory. we provide a language  a framework and a hybrid architecture to integrate features of reactive planning methods with control-theoretic approaches to steer nonholonomic robots. the hybrid language permits planning using a set of behaviors but at the same time the incorporation of differential equations 

in the language makes it possible to formalize  compare and generate behaviors that improve over time  generate maps  etc. it is clear that in a task such as motionplanning using limited range sensors  it is helpful to be able to switch between behaviors that rely on the direct coupling of sensory information and actuators and steering using modern control-theory-based approaches. our system shows that these two can be smoothly integrated  at least for this form of nonholonomic robot path planning. future work includes extending the language to continue formalization of behaviors  including multiple kinetic state machines in the language and implementation of the planner to control a physical  as opposed to a simulated  robot. 
