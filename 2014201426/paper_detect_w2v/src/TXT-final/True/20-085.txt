an incremental theorem prover 
murray shanahan 
university of cambridge computer laboratory  cambridge cb1qg. 
england. 

a b s t r a c t 1 
when states of affairs are represented by theories  reasoning about them often involves making a small change to a set of axioms  and computing the consequences of that change for the set of theorems derivable from those axioms. a prolog-like theorem prover is described which  as it explores the space of possible proofs for a set of formulae  records the structure of that space. this information can be used to search efficiently for proofs for the same formulae with a slightly changed set of axioms. existing prolog interpreters throw away all such information  so that the entire space of possible proofs for each formula must be explored from scratch every time the set of axioms is changed  no matter how little that change affects the search space's structure. 
introduction 
a robot has to reason about actual or possible states of affairs. 
the problem of propagating the effects of changes in a state of affairs through a representation of that state of affairs  updating only those parts which are affected by the change and leaving the rest alone  is one aspect of the frame problem  hayes 1  dennett 1 . if a logic is used as the representation formalism  then information about a state of affairs will consist in a set of axioms and a set of inferred theorems. if a small change occurs in a state of affairs  bringing about a small change in the set of axioms  then it may be more economical to propagate the consequences of this change through the set of inferred theorems than to regenerate them from scratch. this paper is concerned to show how a prolog-like theorem prover may be built to work in this way  where the set of axioms is a set of definite clauses and the set of inferred theorems is a set of goal clauses  each with a corresponding set of answer substitutions. 
　　a prolog interpreter  kowalski 1  is a top-down resolution horn clause theorem prover. presented with a goal clause co and a set of definite clauses p  it searches for refutations of 
go in the form of a sequence of goal clauses co c 1 ...c n where 
cn is the empty clause and each c1.i is obtained by resolving 
g1 with some clause in p whose head unifies with the leftmost literal in c . each such refutation generates a corresponding set of variable bindings  called an answer substitution. since there may be many clauses in p whose heads will unify with 
   'this work it supported by the science and engineering research council of great britain. 
the leftmost literal of any given c   the theorem prover has to search a space of possible refutations  and for each refutation discovered it outputs the corresponding answer substitution. most extant prolog interpreters use backtracking to effect a depth-first search  choosing clauses from p in top to bottom order. 
　　having fully explored the search space  a non-incremental theorem prover throws away all record of how each substitution was computed - what sequences of resolutions were tried  which were successful and which were not. additions and deletions of clauses are then straightforward database operations  but every time refutations have to be found for a goal clause  the search space has to be explored from scratch. now  suppose that the use of the interpreter is characterised by the repeated presentation of the same set of goal clauses for a slightly changed set of definite clauses. the search spaces explored for each slightly modified set of definite clauses are then likely to overlap considerably. under these circumstances it is economical to employ an incremental theorem prover which maintains dependency structures showing how each set of answer substitutions is obtained. then  if a small change takes place in the set of definite clauses  the consequences of this change are propagated through the dependency structures to the set of answer substitutions. it is not necessary to regenerate the answer substitutions from scratch. the burden of computation is then shifted to the incremental modification of these dependency structures when the set of definite clauses is modified  reducing the search for answer substitutions to a simple lookup clearly  for this to be a viable proposal  the resulting savings must outweigh the overheads of recording the dependency structures and propagating the consequences of change. in this paper i will outline the construction of an incremental top-down resolution horn clause theorem prover  in which the maintenance of dependency structures incurs acceptable overheads. 
　　the incremental approach is exploited in reason maintenance systems  doyle 1  dekleer 1   which maintain a record of the logical dependencies within a set of propositions  and ensure that consistency is restored after each modification to that set however  research in this area has concentrated on forward-reasoning mechanisms rather than backward-reasoning ones like prolog. dependency information of the sort described is also used in reason maintenance systems to effect dependency directed backtracking  and similar techniques have been used in prolog interpreters  bruynooghe and pereira 1 . 
	shanahan 	1 

the incremental mechanism 
the mechanism i will describe performs the following operations  given a goal clause g1  a set of definite clauses p and corresponding dependency structures 1 add a clause p to p and update 1  delete a clause p from p and update 1  and output corresponding substitutions for all refutations of g1. of course  many other sets of operations are possible for instance  facilities might be included for modifying parts of clauses  and this would permit a finer grain of incremental modification of s. the techniques described extend naturally to the incremental modification of the dependency structures for a set of goal clauses. it is also possible to incorporate negation as failure  but i will not discuss this problem here  nor will i discuss the problems of dealing with infinite proof trees 
　　now  let us consider the exploration of a search space as a sequence of states s1 sn  where the transition from s  to s1 corresponds to one resolution step and possibly some backtracking assume that the search space for a goal clause g1 and a set of definite clauses p has been explored by passing through a sequence of states t and that this has generated a set of substitutions b suppose that p' is the same set of clauses as p but with one addition then  to explore the search space for go and p' is to pass through a sequence of states v where t' is t with a number of extra subsequences inserted  and the set of answer substitutions generated b' will be a superset of b similarly  suppose pi is the same set of clauses as. p bur with one deletion. then  to explore the search space for g1 and p' is to pass through a sequence of states t' where v is t with a number of subsequences removed  and the set of substitutions generated & will be a subset of b this analysis would be more complicated for a non-monotonic logic since the deletion of a clause could then add to the search space and the addition of a clause could subtract from it 
　　in each case  if a record of b and t is maintained then the search space for go and p can be explored by propagating the consequences of changing p to p' through t thus obtaining t'. and then propagating the consequences of changing t to v through b thus obtaining b in addition to preserving b and t. it is necessary to record which substitutions in b depend on which subsequences in t  and which subsequences of t depend on which clauses in p respectively the answer dependencies and the clause dependencies then  the deletion of a clause from p must bring about the remov.al of those subsequences in t which depend on it. giving t'  and each deletion of a state in t must bring about the deletion of those substitutions in b which depend on it giving b' also  it is necessary to record the predicate dependencies for each predicate in p. the set of points in t at which backtracking took place because of the exhaustion of clauses for that predicate then  the addition of a clause for a predicate must bring about the restoration of each state at which clauses for that predicate were exhausted. for each such restored state search is resumed  thus generating new subsequences to be inserted into t giving 1   and possibly producing new substitutions to be added to b  giving b' each such resumed search continues until a state is reached which is not dependent on the newly added clause  and will therefore already be in t 
1 reasoning 
each state corresponds to a sequence of goal clauses 
go  gn  where g -i is the result of resolving g  with some clause in p this can be conveniently represented by a list of clauses c1 .c n  i. where c  is the clause resolved with g  to obtain g1  and in practise this can be simply a list of pointers or indices into the database of clauses  clocksin and alshawi 1 . then  a sequence of states so-.sn could be represented by a sequence of such lists. but since  in general  a  will be an extension of some s; where j   t  the sequence can be better represented as a tree  whose shape will mirror that of the search space note that any given node in the tree will have one child for each clause in p for a particular predicate 
　　the three dependency structures mentioned above must be maintained with respect to this tree  the answer dependencies  the clause dependencies and the predicate dependencies. for each leaf in the tree  a record is kept of whether the path from the root to that leaf constitutes a refutation  and if so  the corresponding answer substitution in b is indicated for each clause in p. a list is kept of those nodes in the tree which point to that clause finally  for each predicate in p. a list is maintained of those nodes in the tree whose childrens' root nodes all point to clauses for that predicate 
　　the cost of building the dependency structures during search is one tree insertion and two list insertions  of the kind that do not require search  for each resolution step performed the time savings are obtained at the expense of a storage overhead which will be directly proportional to the complexity of the search space 
　　the deletion of a clause c proceeds a s follows for each node n in the clause dependencies fur c the tree from n downwards is removed the removal of a node requires that all references to that node are deleted from the dependency structures so that this does not involve search  the clause and predicate dependencies can be threaded through the tree  and the removal of a node is then preceded by the deletion of its entries in those lists whenever a leaf is reached  if that leaf is at the end of a refutation then the corresponding answer substitution is deleted from b so  the cost of deleting a clause is directly proportional to the total amount of search subspace whose existence depends on it if this is a small proportion of the overall search space then the savings resulting from adopting the incremental approach are correspondingly large. if it is a large proportion of the overall search space then the savings will be negligible and the extra cost will be of the same order as the cost of the original search 
　　the addition of a clause c for a predicate d proceeds like this. for each node s in the predicate dependencies of c the state reprsented by .v is restored and the search is resumed until an area of search space is reached which has already been explored  ie: until the interpreter backtracks past s  the state represented by the node n is restored by tracing back from n to the root of the tree  forming a list l of the nodes on that path  in root to node order   and starting with the goal clause g1  generating the sequence of goal clauses gi...g n by resolving each g  with the  i +   th member of l to obtain g. i since all the search subspaces thus explored have to be explored anyway  the only overhead of adopting the incremental 

approach is the initial cost of storing the dependency structures plus the cost of retracing the paths from each n to the root. as for deletion  the savings obtained will depend on the proportion of newly explored search space to overall search space. instead of reconstructing the state  further time savings can be made  at the cost of further storage overheads  by recording the whole structure of the search space  including variable bindings. 
　　the incremental mechanism described so far is capable of making savings when the effects of additions to and deletions from the set of definite clauses are confined to the outermost parts of the tree  near the leaves  or when they are confined to only a few branches and the tree is wide. the mechanism will also prove useful for clause replacements  the deletion of a clause followed by the addition of a clause for the same predicate  but it is often the case that the effects of a replacement are confined to a region near the root of the tree  leaving the peripheral foliage untouched. a finer grain of incrementality would be obtained if the mechanism avoided duplicating the work done below the affected area. 
　　a complete solution to this problem is very difficult  and a detailed description is far beyond the scope of this paper. the mechanism must remove those parts of the tree that are dependent on the replaced clause whilst saving the branches below. new nodes are grown to replace the removed sections  using the new clause  and the saved branches are grafted back onto each new section that did not lead to a failure. as a result of growing a new section  some variables may change their bindings  and the consequences of these changes must be propagated through the rest of the tree. this can involve a 
　　similar pruning  growing and grafting process to that already described  since some clauses that failed to match before will match now  whilst others that did match before will fail to now. again  sections of the tree will have to be lifted out and replaced  but this time a new section can have more offshoots than the one it replaces  so that when all the available saved branches have been grafted on  new ones have to be grown for any offshoots that are still incomplete. 
　　i conclude with a brief discussion of how an incremental theorem prover might be embedded in a horn clause planner similar to the one described by kowalski  kowalski 1 . the planner has to search for a sequence of actions a  .an such that t1...tn*i is a sequence of states of affairs where t{ is the initial state and tnr  is the goal state and each t1 is the result of performing action a  in state tx. representing states of affairs as theories  the planner would be built on the meta-level  and would use meta-level predicates such as 'demonstrate  theory  goal     add-clause  theory 1  clause  theory'1    bowen and kowalski 1  which would be built-in and whose implementation would be based on the incremental approach described note that the single predicate ''add-clause'1  will suffice for both addition and deletion of clauses. any action performed in state t  can bring about changes to the axioms of the theory representing t  the planner would use  add-clause  to effect this change  and the incremental theorem prover would propagate its consequences through the theory. then  in order to demonstrate some property of t -i  such as the nature or position of a given object the only computation required would be a simple lookup  assuming that the property was one that was 
also demonstrated for t . 
   of course  it is not necessary to use prolog for the metalevel problem solver as well as for the object-level representation formalism. but if prolog is used then the following extension to the incremental mechanism may be necessary. consider the solution of a goal  add-clause  it would be ineffi-
cient to keep entirely distinct copies of tl and t1  since then the expense of copying tl when a clause is added would obviate the advantages of the incremental approach. the same problem arises for deletion. rather  what is required is a single structure which represents both theories. this could be obtained by labelling some of the nodes in the tree with the contexts  sets of axioms  in which those nodes  and their children  are to be considered part of the tree  dekleer 1 . a detailed investi-
gation of such an extension is a subject for further research 
