 
we describe an intelligent tutor for lisp programming. 
this tutor achieves a set of pedagogical objectives derived from anderson's  1  learning theory provide instruction in the context of problem-solving  have the student generate as much of each solution as possible  provide immediate feedback on errors  and represent the goal structure of the problem-solving the tutorial interface facilitates communication and prevents distracting low-level errors field tests of the tutor in college classes demonstrate that it is more effective than conventional classroom instruction 
1. introduction 
　　constructing an intelligent tutoring system to teach complex cognitive skills is not only a practical application of cognitive science theory and methodologies  but is also arguably the strongest test of a learning theory. in this paper  we report our work on an intelligent tutor that effectively helps students learn to program in lisp. this tutor was designed according to a set of pedagogical principles derived from anderson's  1  act* learning theory  anderson  boyle  farrell  & reiser  1  anderson  boyle. & reiser  1 . we shall describe how the tutor achieves a set of pedagogical objectives  and present the results of recent field tests of the tutor in carnegie-mellon university classrooms. 
1. tutorial goals 
　　private tutoring is generally found to be the most effective form of instruction. we have found students working with private human tutors to learn material up to four times as quickly as those in the typical classroom situation  i.e.  attending lectures  reading texts  and working alone on homework problems . similarly. bloom  1  found students working with private tutors attained a better grasp of the material than a comparable group of students spending the same amount of time in the classroom. we have developed a number of pedagogical principles that explain the effectiveness of private tutoring  anderson  et a!.. 1  1   and have guided the design of an intelligent tutor for lisp on those principles. 
   most of the learning in acquiring a cognitive skill occurs while the student actually tries to solve problems in the domain. the major role of a tutor is to make the problemsolving episodes more effective learning experiences. our lisp tutor  called greaterp  goal-restricted environment for tutoring and educational research on programming   is a device for structuring students problem-solving and providing appropriate feedback and guidance to enable the student to effectively learn how to program thus  the tutor is an environment for writing lisp programs  and is able to provide instruction in the most effective context -- while the student is trying to solving problems using the target skills 
   a second pedagogical objective is that the student should do as much of the work as possible students learn more by doing than by being told the tutor must be able to adapt to the amount of assistance required for the student to be able to solve the problems thus the tutor must be able to monitor the student's problem-solving to determine if and when guidance is needed enough guidance must be provided to limit the student's floundering  and therefore enable the student to successfully solve the problem  without leading the student more than necessary. 
　　a third objective is that the tutor should provide immediate feedback. if the tutor is able to point out errors while they are being made rather than after the entire program is written  the student can then correct those errors and avoid large amounts of time wasted in trying to isolate program bugs. students often spend much of their learning time recovering from errors. these errors can interfere with acquiring the target skills  as students often get lost while trying to track down an error  perhaps misdiagnosing the cause of an error and changing correct parts of the program. furthermore  students are more likely to correctly debug their knowledge upon immediate feedback  because the rules they used to commit the error are still active in memory and thus more successfully modified than when memory search is required to find the responsible rule. in order for the tutor to provide effective immediate feedback  it must constantly monitor and understand the student's behavior. 

　　a final constraint on the design of the tutor is that it should represent the structure of the problem for the student. often instruction communicates the final form of an answer  e.g.  a program or a geometry proof  without focusing on the types of goals and subgoals generated in the problem-solving in order to produce such an answer  anderson et al.  1  1 . thus students are left to induce the procedures for obtaining such a solution with insufficient constraints  and in the early stages of learning often fall back upon generate and test strategies thus  it is important for the tutor to communicate the goal structure of lisp programming. 
　　we have tried to achieve these goals in 	a tutor that serves as a helpful 	 programming environment  	students 
can compose programs in this environment just as if they were using a smart structured editor. however  whenever the student makes a planning error  a coding error  or asks for assistance  the tutor provides helpful information so that the student can continue. the tutor will also interrupt if necessary to curtail floundering and help the student get back on a correct path to a solution. in addition  this environment is designed to represent the conceptual structure of programming problems more accurately than typical environments  e.g . screen editors  
1. the model-tracing methodology 
     the key to a tutor's success is the ability to fit each act of the student into a model of correct and incorrect methods for solving problems in the domain. a detailed analysis of each portion of the student's solution is necessary in order to diagnose errors and to provide appropriate guidance. we call the process of understanding the student's behavior as it is generated model-tracing. in this methodology  the tutor solves the problem along with a student  tracing the students reasoning as he or she enters each part of the solution. with each input typed  the tutor tries to figure out what correct rule or misconception would have led to that input being generated. if it is a correct rule  then the tutor stays silent and waits for further input if. on the other hand  the input is diagnosed as an error  then the tutor interrupts with advice. thus  to the extent that the student is following a path that will lead to a 
     correct solution  the tutor stays in the background  acting as an intelligent structured editor. upon request  or when the tutor diagnoses that the student is in trouble  the tutor provides the next step in the solution  enabling the student to continue. in addition  if the student has difficulty writing code  the tutor will assist the student in planning out the solution  and then return the student to writing code 
　　in order to implement the model-tracing methodology  the tutor draws on three components 
1. ideal student model the domain knowledge necessary to solve problems 
1. bug catalogue knowledge about the common mistakes and poor strategies of novice programmers. 
1. tutoring control module pedagogical strategies that structure the interaction with the student. 
	b. reiser et al. 	1 
	ideal student model 	the tutor must 	be 	able to solve 
 problems in the domain so that it can understand the student's behavior and assist in the problem-solving as required. however  an expert system could not adequately serve as the basis for the tutor. experts will solve problems using more advanced heuristics  macro-rules  and other techniques not yet in the curriculum for the student. instead  the tutor must not only be able to solve problems  but must be able to solve them as advanced students would do. the rules for reasoning in the domain that we want the student to acquire must be available to the tutor for the purposes of explanation  clancey. 1  thus the lisp tutor contains an ideal student model a simulation of the programming knowledge ideal students use in solving lisp problems. this ideal model is based on a detailed theory of how students learn to program  anderson farrell. & sauers. 1 . the ideal model for lisp programming is implemented in grapes  a goal-restricted production system  sauers & farrell  1 . the grapes architecture is particularly well suited for modelling the type of goal decomposition found in solving programming problems. each production in the ideal model contains a specification of the goal the rule will achieve and a description of the conditions under which the rule is applicable. table 1 shows the production rule that applies to code the function append in order to concatenate two lists. 
production rule in ideal model. 
if the goal is to combine list1 and list1 into a single list 
and list1 is a list and list1 is a list 
then 	use the function append and set subgoals to code list1 and list1 
a related buggy rule 
if 	the goal is to combine list1 and list1 into a single list 
and list1 is a list and list1 is a list 
then 	use the function list and set subgoals to code list1 and list1 
tutor's response to the bug: 
you should combine the first list and the second list  but 
list is not the right function. if you list together  a b c  and  x y z   for example  you will get   a b c   x y z   instead of  a b c x y z . list just wraps parens around its arguments. 
　　table 1. a correct and buggy production rule in the tutor's model. 

1 	b. reiser et al. 
   the ideal model contains both planning and coding production rules. the planning rules design an algorithm to achieve a particular program specification  and the coding productions then write the code to achieve the algorithm. in many cases  coding productions exist that map directly from the program specification to the code  bypassing the separate planning step. these more complex productions are necessary to handle cases where a more competent or advanced student does not require a separate planning phase  but can go directly to the code. thus  there must be enough redundancy in the ideal model to follow the many different paths through a problem that students of different backgrounds and abilities will require 
   a problem is specified to the tutor by setting a goal to code a function that computes a particular operation on one or more objects  and by specifying a set of facts in working memory that describe the relationships between the conceptual objects in the problem when the ideal model is given a problem to code a lisp function  it applies a large sequence of production rules to plan and then write the lisp code. 
   bug catalogue. associated with the rules in the ideal model there is also a large set of buggy rules which represent misconceptions novice programmers often develop during learning. buggy rules are incorrect variations of correct rules in the ideal model  brown & burton 1. sleeman  1 . a buggy rule may represent a poor strategy  semantic confusions between the basic lisp functions  misunderstandings about manipulating objects such as variables  erroneous use of syntactic constructs  e g . missing quotes  misgrouped parentheses   or other common slips a buggy version of the append rule is shown in 
table 1 
   in order to diagnose errors  the tutor compares the student input against the correct rules the ideal model is considering and the associated buggy rules relevant to the current state in the problem solution by dynamically modelling the student's path through a problem  the tutor always has a model of the student's intentions inferring intentions is necessary for responding appropriately to students misconceptions about programming  johnson & soloway  1 . 
　　tutorial rules a tutorial rule is associated with each production rule in the ideal model and with each rule in the bug catalogue. the tutorial rule is the bridge between the internal representation of the tutor and what the student inputs and sees on the screen first  each tutorial rule contains one or more patterns that enable the tutor to recognize if the student is executing the associated production rule. for example  the patterns for the correct rule and buggy rule in table 1 would be   append  and   list   respectively. in addition  the tutorial rule specifies how to explain the associated production rule to the student. tutorial rules associated with correct productions describe why the rule is applicable and what code should be written. those rules associated with buggy productions describe why the students answer is wrong  and provide a hint toward the correct solution. an explanation constructed by the tutor is shown with the buggy rule in table 1. the descriptions are constructed by instantiating english templates with the english descriptions for the various objects in the current problem  and with examples associated with those objects. 
　　tutoring control structure this module contains the pedagogical strategy of the tutor. it determines when to curtail the students floundering and interrupt with the next step in the solution  when to invoke a planning mode  and selects remedial problems tailored to the particular students weaknesses 
1. feedback and guidance in the lisp tutor 
   the tutor is designed to provide only as much guidance as necessary while encouraging the student to generate as much of the solution as possible thus  the tutor generally tries to provide hints rather than actual solutions. there are several types of guidance provided by the tutor. these involve responding to errors  providing hints and reminders for clarification  and helping the student plan a solution before coding. 
   the bug catalogue enables the tutor to respond effectively to student errors. as soon as the student makes a mistake  the tutor responds with an appropriate diagnostic message because students can write their code a small piece at a time with the tutor  the feedback appears as soon as one item of the code is wrong this is in contrast to the standard learning situation where a student receives feedback only after the entire function has been coded  or perhaps even an entire set of functions   and then tries to run the code the tutor also must respond to 
 undiagnosed  errors. these are student answers that fail to match either a correct rule or one of the buggy rules although the tutor can say nothing specific about why their code will not work  the tutor responds that it  doesn t understand that answer   and then describes the current goal in the problem solution. often this reminder clarifies the problem for the student  who is then able to enter the correct code. because the tutor has all the knowledge the student is expected to have at that point in the course  it is very rare that the student enters code that would actually work but is not recognized as correct by the tutor 
　　the tutor also provides guidance by hinting toward the correct solution if the student is having difficultly these hints take the form of queries and reminders about the current goals the student can also request a clarification of the current goal via a special clarity key if necessary the tutor can provide the next small piece of the code so that the student can continue. this is done at the students request via a special explain key. such a request causes the tutor to query the ideal model for the best production rule it is currently considering. at that point the tutorial rule associated with the production is' accessed to provide an explanation  and the production is executed  updating the code or the current plan 
　　the tutor will also intervene and cut off the student's attempts at coding when they are no longer fruitful  i.e.. when the student has made more than the maximum number of allowed errors for that portion of code. typically  the student is allowed to continue making errors as long as the errors are correctly diagnosed  on the theory that the error diagnosis and feedback can provide useful discriminations for the student. however the student is limited to two errors that fail to match bugs in the catalogue. errors such as entering drastically inappropriate 

functions or trying to code the wrong part of the problem indicate the student is confused enough that further attempts at coding that portion would not succeed. if the current portion of code is sufficiently complex  the tutor will initiate a  planning mode  to work out an algorithm to code the problem. that is  the tutor will work through the algorithm with the student  step by step  using an example. then  after the algorithm is constructed  the student can return to coding  presumably with a better idea of what he or she should be doing in order to get their code to work properly. if the current part of the problem is more straightforward  the tutor provides the next step  setting the student back on one of the correct solution paths. by providing the next portion of code  the tutor enables the student to work through the rest of the problem in cases where the student might otherwise have had to give up. as a consequence  students can tackle more and more difficult problems 
   one consequence of this immediate feedback is that students receive less practice debugging their code in fact  their only debugging is as they are writing the code --
i.e.  in trying to generate another portion of code after the tutor has diagnosed an error. however  we do not view this as a limitation. in fact  in the normal learning situation  learning to program necessarily confounds the skills of code generation  code evaluation  and debugging. to the extent possible  this tutor enables students to learn to generate code without the complications of having to simultaneously learn debugging skills. instead  separate lessons on debugging and evaluation can be included to train those skills independently 
1. the tutorial interface 
　　the tutorial interface is designed to facilitate student s learning by providing the environment with the intelligence to structure the code being entered and prevent  low-level  syntactic difficulties this is achieved by providing the student with an intelligent structured editor with which to enter code. the structured editor automatically balances parentheses and provides placeholders for the arguments of each function. the placeholders are provided by a template associated with each coding rule. for example  consider what happens when the student tries to define a new function. to begin  the student types a left parenthesis and the word defun. at that point the tutor recognizes the correct application of the defun rule  and redisplays the code as 

the symbols in brackets indicate arguments that must be coded  in this case referring to the name of the function  a parameter list  and the function body. the tutor places the cursor beneath the symbol   name   and illuminates it to indicate that this symbol must be coded next. 
   this structured editor relieves students of the burden of balancing parentheses. furthermore  the editor traps illegal characters and stops students from committing simple syntactic errors  such as forgetting parentheses or quoting function calls. for example  when a function call is required  typing any character other than a left parenthesis will produce a beep. typing a single quote would produce 
	b. reiser et al. 	1 
the message  function calls should not be quoted   while any other character would evoke the message  you should be typing a function call   followed by  function calls begin with a left parenthesis  if the error is repeated. this type of response is quickly understood by students with a minimal amount of distraction from what the student was intending to do. thus  the editor enables students to focus on those 
aspects of lisp that are conceptually more difficult. our results demonstrate that enabling students to pay more attention to the central conceptual issues in programming leads to faster learning of these major skills  yet with no deficit in the student's knowledge of syntax. 
   the structured editor also facilitates communication between the student and the tutor. the student types directly into the code  replacing one of the placeholding symbols  and thus it is always clear what part of the problem is being coded. in the question/answer format of most eductional software  the tutor and student can easily get  out of synch  on complex problems  where the student is not sure what part of the problem the tutor is discussing or querying 
   a simple windowing system is used to keep information current on the screen. the code window always displays the code written at the current point in the problem. a separate tutor message window is used to display messages from the tutor such as hints or diagnostic error messages. thus  the student can read these messages while retaining access to the code  including the last  possibly incorrect  student input. a third goals window reminds the student about the current goal in the problemsolving. 
   figure 1 demonstrates the tutor responding to a student error. in this case  the student is writing a function to create a list of numbers from 1 to n. here the student has forgotten to use the function return in order to return a value from the iterative function prog. the error message shown the in the tutor window  the top window  appears as soon as the student finished typing the atom result figure 1 demonstrates the planning capabilities of the tutor. upon having difficulty in coding a recursive function to compute the factorial of a number  the tutor helps the student plan the code with the use of concrete examples. 

	figure 1. 	the tutor's response to a student error. 
1 	b. reiser et al. 

 figure 1. the tutor aiding the student in algorithm design for a recursive function 
1. the goal structure of lisp programming 
   the tutor has been designed to communicate the conceptual structure of programming problems this is accomplished in part by using the placeholders to provide a template for the rest of the problem solution for example  when the student types the iterative construct prog  the tutor displays the general pattern for iteration 
 prog  local-variables  
  initialization 
 body   repeat  
  
this template helps structure the iterative problem for the student into a list of local variables  initializations of those variables  the body of the loop  i.e . the repeated actions   and the call to return to beginning of the loop. in accordance with the top-down nature of the task  many symbols are themselves expanded into more detailed symbols. for example  the iterative  body  includes a  terminating-case  and  updating-code  
   the tutor also communicates the goal structure in its guidance for planning lisp programs when requested or when the student encounters sufficient difficulty the tutor initiates a planning mode  where it leads the student through the design of an algorithm to accomplish the current portion of the problem. thus  the student learns how a complex problem can be broken down into simpler problems to be solved. in both coding and planning modes  special goals windows remind the student about the current goal in the problem solution. 
1. dynamic versus post-hoc student modelling 
　　one of the central pedagogical objectives in the tutor s design is the principle of immediate feedback. because of this principle  we have constructed the tutor so that each symbol of the student's input is processed and interpreted immediately  rather than waiting until the student completes some portion of the code  such as a function call  or perhaps the entire function definition the goal is to respond to the smallest unit of input that can disambiguate what the student is intending to do typically  the grain size for input in the tutor is a single lisp atom except for syntactic errors such as missing parentheses the tutor will respond as soon as the student finishes typing an atom such as the word append  list  side 1 etc if the tutor responded upon individual keystrokes  perhaps diagnosing as soon as the input did not fit with one of the correct rules  there would typically not be enough of an answer to enable the categorization of the error furthermore  it would not enable students to correct a typing mistake by deleting the incorrect letters on the other hand  a larger unit of input would inhibit the immediate feedback of the tutor  and increase the chance that the student would become lost thus  the tutor greatly limits the consequences of the student's errors students can learn from their errors  without the danger of spending an unproductive amount of time trying to track them down  perhaps even changing correct parts of the program  and finally loosing track of what they were trying to accomplish 
   the grain size of student input also has important ramifications for student modelling by trying to interpret each part of the student's answer as it is typed  the tutor has access to the current state of the ideal model thus. the tutor knows the exact state of the problem solution  and the current goal  and is in a better position to diagnosis the students error a limitation with the successful proust debugging aid  johnson & soloway. 1  that analyzes a program after it has been fully written is that proust often finds many alternative interpretations for a particular line of code due to the many possible buggy transformations of the various paths through a problem it is forced to consider on the other hand  the lisp tutor tracks student s problemsolving as it occurs  and thus can construct a more accurate model of the student's reasoning  because the ambiguous portion of code never is completed instead  the lisp tutor diagnoses an error at the first sign  so an entire line of code could never be omitted or misplaced many of the complex bug interactions that present such a problem for proust's analysis are thus avoided. 
1. generic and individualized student models 
　　the tutor is able to use its ideal model and bug catalogue to respond to the student's behavior during the problem-solving. the set of productions form a generic student model  a model of the set of target knowledge and possible misconceptions. thus  the generic student model contains rules which a particular student may know less well than others  and rules which the student may not posses at all. the generic student model is adequate for the type of immediate feedback and minimal guidance desired in this tutor the responses and explanations need only to be tailored to the particular problem context and students answer  but not to the strengths and weaknesses of a particular student. 

an individual student model is also kept by the tutor. 
this is in the form of an overlay of the generic model  goldstein  1 . each production in the ideal model contains a weighting  which is the tutor's measure of how well the student knows that rule. each time the student performs that rule correctly  the weight is increased  and each time the student exhibits an error concerning that rule  it is decremented. currently  these weights are used to assign remedial problems to the student each remedial problem is considered to see whether it involves production rules on which the student is weak. it may also be possible to use these weights in constructing explanations for errors for example  an error on a well-learned production is likely to be a careless slip rather than evidence for a serious misconception. it is a question for future research as to how one might want to differentially respond to such an error 
1. field tests of the tutor 
   the current version of the tutor consists of ten lessons  beginning with the basic functions of lisp  and including the topics function definitions. predicates and conditionals. structured programming. numeric and list iteration  and 
numeric and list recursion. the tutor contains 1 production rules in the ideal model and 1 buggy versions of those rules. these rules enable the tutor to diagnose and respond appropriately to between 1% and 1% of the student's errors  depending on the complexity of the lesson and the amount of testing of the lesson we have conducted that is. our well-worked lessons correctly diagnose 1% of the students' errors  while our newest implemented lessons diagnose only about 1%. 
   we have completed two major evaluations of the tutor a first evaluation compared students working with the tutor to a group working with a private human tutor  and to a group working essentially on their own  but with the help of a teaching assistant when necessary . these students were university of pittsburgh and carnegie-mellon undergraduates with no prior programming experience. the material covered six lessons  from basic lisp to recursion. all three groups scored approximately the same on final performance tests  but both tutoring groups learned the material much more quickly than the untutored group. students learned almost twice as quickly with the computer tutor  1 hours for six lessons  as without a tutor  1 hours   and nearly as quickly as those students with human tutors  1 hours  furthermore  a greater percentage of students tutored by either human or computer successfully completed the lessons in the time allotted. 
   in a second evaluation  we again compared students working with the tutor to another group working on their own. this evaluation was a six week mini-course offered to 
carnegie-mellon 	university undergraduates during 	the 	fall 
1 semester. the no-tutor group corresponds to the standard pedagogical situation where students attend lectures  read a text  and do homework unassisted. students had one previous programming course in pascal. all students went to the same lectures and read the same text. here students working with the tutor performed 1% better on the final exam  and learned the material 1% faster than those working without the tutor. 
	b. reiser et al. 	1 
   these results demonstrate that the lisp tutor appears to achieve its educational objectives. it is more effective than the standard pedagogical situation students learn more quickly and perform better on achievement tests. the benefits of the tutor are greater for the more difficult lessons  and are somewhat greater for less experienced students. 
   the tutor is currently used by many students learning their first programming language at cmu and to fulfill the university's programming course requirement. this selfpaced lisp course for humanities students consists of a 1 hours/week lecture and question and answer sessions  with the majority of the coursework involving students interacting with the lisp tutor to write programs. 
1. current directions 
　　our current work is focused on extending the current tutor to teach the skills of debugging and program comprehension. in the evaluation lessons  students will go through the code for a function  guided and monitored by the tutor  specifying the flow of control and the results of the function calls. in the debugging lessons  students will be asked to run functions  determine whether a bug exists  locate the bug  and then correct the code. in these skills  as in code generation  the tutor monitors the student's performance by comparing it with the ideal model  providing feedback upon errors and guidance when necessary. the principles used in the lisp tutor are also currently being explored as the basis for tutoring systems for other problemsolving domains such as algebra and geometry  boyle & 
anderson. 1  
