 
　horn clauses provide a useful framework for writing executable structural representations for digital circuits. this paper discusses how these representations can be used to diagnose faulty circuits using algorithmic program debugging techniques developed by shapiro. the sound theoretical basis of these techniques is one of the major advantages of this approach. this framework also provides a new perspective on some of the hardware diagnosis techniques suggested in the literature. 
i introduction 
　even after substantial effort the problem of diagnosing hardware faults remains a major research interest. earlier work in this area was based on the empirical approach  i.e. having statically compiled fault dictionaries and various ways of searching through them. this approach  which has been widely used in many conventional expert-systems  is based on the heuristic classification technique . the limitations of the classification-based approach to diagnosis have long been identified . the main problems with this approach  e.g. the lack of flexibility and extensibility  arise due to mixing control information with domain knowledge. an alternative model-based approach has been suggested by davis  and qenesereth . this approach uses explicit representation of the structure and behavior of the device; and instead of scanning a fault dictionary the principle of violated expectation  is used to localise the fault. 
　a fundamental problem with the research in model-based hardware diagnosis has been its distinct lack of theoretical foundations. with recent work in the field of software debugging which has strong theoretical motivation  this absence becomes even more conspicuous. not only has this led to a proliferation of seemingly different techniques  it has also shrouded the fundamental problems that need to be addressed before these techniques can be scaled up to handle real devices. the relationship between hardware and software being well known  at least at the coarse level of hardware granularity  there is a potential relationship to be explored between diagnosing hardware and debugging software. 
　this paper explores the relationship between algorithmic program debugging based on the model-inference system  mis  built by shapiro  and the techniques for hardware diagnosis using device models proposed independently by qenesereth and davis. as mis can be best illustrated in pure-prolog  we first describe how to represent a digital 
circuit as a prolog program. the next section summarises the program debugging component of the mis and explains 
1 	knowledge representation 
the terms used later in the paper. then we present two observations that enable hardware diagnosis to be conducted by the contradiction backtracing in mis. we illustrate the method on an example used by . then we illustrate how sequential circuits can be handled in this framework. finally we explain how the contradiction backtracing technique relates to the techniques that have been proposed by davis and qenesereth. 
ii circuit-description in prolog 
　circuits can be represented in pure-prolog by identifying a clause with a hardware module. the head of the clause gives the black-box view of the module - the predicate being the type of the module and the arguments being the ports of the module. this represents the top-level abstraction of the device  expressing its input-output behaviour with no reference to its internal structure. for instance a fulladder is represented as: 
ml adder 


　the internal structure of a module consists of its submodules and the connections between them. this information is represented by the body of the clause that describes the module. the body consists of a set of terms each representing a submodule  and the connections between these submodules are represented by sharing a variable between the terms. note that the order of submodules in the body of a module is completely irrelevant. this method of representing circuits in pure-prolog has been called the definitional method by clocksin . we extend this representation to require that each module carries its name as its first argument. the reason for this requirement  which are related to the diagnosis problem  will become clear later. 
 the above definition reflects the structural composition of the fulladder  and at the same time its execution under a prolog interpreter simulates the behaviour of the device. 

this representation also captures the hierarchical nature of the device  where hierarchy is achieved by including a call to a module in the definition of a higher-level module. the lowest level of the hierarchy consists of the basic elements represented as a set of unit clauses. for instance the logic gates can be represented as: 
xor name.o x x . and name 1   1 . xor name 1 1 . and name l  x x . xor name  1 1 . 
ill overview of mis 
 the program debugging techniques in mis apply when the programmer has a program p that on input x returns an incorrect output y. the goal of debugging is to locate the erroneous modules and possibly show how' they are failing. it is required that there exists a mechanism that can serve as an oracle for answering the queries of the form: 
'is y a correct output of module p on input x' and 
'what is a correct output of module p on input x' 
 these two types of oracle have been termed ground and existential oracles respectively. normally the programmer is expected to be able to answer such queries  hence act as the oracle. if the oracle can be mechanised debugging becomes completely automatic. 
 if m is an interpretation for a procedure p  an oracle simulation of p on x with m is defined as a computation of p on input x where every procedure immediately called by p on input x is simulated by a call to an oracle for m. the goal of an oracle simulation is to isolate the execution of a procedure call from the possible errors in subordinate procedure calls. a procedure p is correct in m if  for any x  the output of any oracle simulation of p on x with m is correct in the model m. if a procedure is incorrect then there is some x such that oracle simulation of p on x returns an output y which is not correct in m. such a simulation gives the desired counterexample to the correctness of p in m. 
　the simplest algorithm to debug an incorrectly terminating program p on input x is based on traversing the tree of procedures invoked on the input. the parent relation in the tree reflects the procedure invocation relation  and the sons in the tree are ordered according to the order in which the procedures are invoked. if a procedure p' on input x' returns an output y' the algorithm calls the ground oracle to check its correctness. if the oracle returns 'yes' the simulation continues. the procedure that returns 'no' is the incorrect procedure. the order in which the algorithm queries the oracle corresponds to the post-order traversal of the procedure invocation tree. various optimisations that attempt to minimise the number of queries asked have also been proposed . 
iv hardware diagnosis in mis 
　in order to apply the program debugging techniques to hardware diagnosis we have to address two problems. first  in the case of software modules once a module has been tested  it can be used or called in any number of places without further verification. on the other hand  we know that just because one and-gate has been shown to be fault-free does not mean every and-gate will be behaving correctly. this problem can be handled by ensuring that each physical instance of a module has a unique name as part of its definition. it is for this reason we require that each module carries as its first argument a name  part of which is built using its parents name. 
　secondly.in the case of program debugging  the debugger has the incorrect program  and the oracle  usually the programmer  has the information about the correct or intended behavior. but in the case of faulty hardware the debugger has complete knowledge of the intended behavior from the design descriptions  but the faulty theory is embedded in the device under diagnosis from which it can be extracted only by making some measurements. thus there is a complete duality between the knowledge available with the program debugging and hardware diagnosis systems. 
 in order to map hardware diagnosis onto program debugging we only need to recognise that the correctness of a theory is defined in reference to a model. thus diagnosis turns out to be finding the discrepancy between the theory and the model. whether the model or the theory is correct' in the real world is irrelevant for diagnosis. we can now treat the incorrect or faulty device as the intended behavior  i.e. the model  and its design description as the incorrect theory to be debugged. in this framework the device under diagnosis acts as the oracle both functional and ground  that can be used for answering the queries while 'diagnosing' the designed behavior. 
with these two observations  fault-diagnosis as proposed by 
davis  1  and genesereth  can be reproduced by the diagnosis algorithms in mis. for details of the debugging algorithms readers are referred to . the following script shows the queries asked to diagnose a fault. a goal such as: 
 - fp fadder fa 1 1 1   x . 
is a query to find the clause that would explain the behavior of full adder that results in  1  on inputs  1 1 . the debugging algorithm attempts to find the culprit module by querying the oracle. this is very similar to signal tracing which davis and genesereth have suggested. following is a trace for this simple example where the faulty module is and a1 : 

 oracles response is indicated in bold. the counterexample found indicates the faulty' module and how its behavior differs from the actual behavior. notice that although this faulty' behavior refers to module in the design-description  in practice we would really need to modify the oracle so that it matches the intended behavior. 
v diagnosing circuits with states 
　so far we have only considered combinational circuits circuits whose output is a function of current input signals only. in sequential circuits  on the other hand  the output is determined by the order in which the signal is applied  thus the history is important for the behavior. sequential circuits can be of two types: unclocked  asynchronous  or clocked  synchronous . asynchronous circuits can be modelled only at an abstraction higher than the time-domain in the definitional method. for synchronous circuits additional arguments are required to represent history. for example  a jk-flip flop will 
	gupta 	1 

vi conclusions & further work 
　there are two approaches to hardware diagnosis depending on whether the diagnosis system has complete or partial observability of signals in the device under diagnosis. in this paper we have demonstrated that in the framework where the diagnosis mechanism has complete observability  i.e. the oracle can take a measurement at any point in the device under diagnosis  hardware diagnosis can be conveniently modeled as algorithmic program debugging. this approach provides us a powerful framework for studying automatic fault correction as well. for instance  davis  recognises different kinds of failures that need to be considered commonly in hardware diagnosis: 
stuck-ats or floating pins short-circuits ports in unintended directionality 
　in the framework of mis each of these failures would constitute a refinement relation . we need to define the refinement relations for different kinds of hardware failures and 
the techniques for searching the refinement trees generated by them. 
　the ability to take measurements at arbitrary points in the device is possible only in a laboratory environment. in the field however the devices have a limited observability because only the signals coming out on the output ports can be seen. partial observability adds a fundamentally new dimension to fault-diagnosis. one approach would be find techniques to regain the effects of that resolution. in this regime  the crucial issues relate to the problem of test-generation. 
 there are important issues to be addressed in order to make the definitional representation of circuits easier to use. in particular the clocks do not hierarchically abstract  so the behavior of the circuit at the top-most level still needs to be looked at the lowest level of clock granularity. we need gradual temporal zooming-in appropriate to the behavior of the module under study . 
acknowledgements 
thanks are due to john lumley  bill clocksin  bill sharpe and andy buchanan for their valuable comments. 
