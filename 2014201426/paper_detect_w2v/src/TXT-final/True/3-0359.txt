
a pattern database  pdb  is a heuristic function stored as a lookup table. symmetries of a state space are often used to enable multiple values to be looked up in a pdb for a given state. this paper introduces an additional pdb lookup  called the dual pdb lookup. a dual pdb lookup is always admissible but can return inconsistent values. the paper also presents an extension of the well-known pathmax method so that inconsistencies in heuristic values are propagated in both directions  childto-parent  and parent-to-child  in the search tree. experiments show that the addition of dual lookups and bidirectional pathmax propagation can reduce the number of nodes generated by ida* by over one order of magnitude in the topspin puzzle and rubik's cube  and by about a factor of two for the sliding tile puzzles.
1 introduction
heuristic search algorithms such as a* and ida* are guided by the cost function f n  = g n  + h n   where g n  is the actual distance from the initial state to state n and h n  is a
heuristic function estimating the cost from n to a goal state. if h s  is  admissible   i.e. is always a lower bound  these algorithms are guaranteed to find optimal paths.
　pattern databases are heuristics in the form of lookup tables. they have proven very useful for defining heuristics for combinatorial puzzles and other problems  culberson and schaeffer  1; edelkamp  1; korf and felner  1 .
　the domain of a search space is the set of constants used in representing states. a subproblem is an abstraction of the original problem defined by replacing some of these constants by a  don't care  symbol. a pattern is a state of the subproblem. the pattern space for a given subproblem is a state space containing all the different patterns connected to one another using the same operators that connect states in the original problem. a pattern database  pdb  stores the distance of each pattern to the goal pattern. typically  a pdb is built by searching backwards  breadth-first  from the goal pattern until the whole pattern space is spanned. given a state s in the original space  a heuristic value for s  h s   is computed using a pdb in two steps. first  s is mapped to a pattern. then  this pattern is looked up in the pdb and the corresponding distance is returned as the value for h s .

figure 1: example of regular and dual lookups
　this paper is concerned with the first step  the mapping of a state s to a pattern that can be looked up in a given pdb. the standard mapping  called the regular pdb lookup in this paper  is illustrated in figure 1 a  and  b  for the 1-puzzle. patterns are created by ignoring all the tiles except for 1  1  1 and 1. each pattern contains tiles 1  1  1 and 1 in a unique combination of positions. the resulting {1-1}-pdb contains a unique entry for each pattern with the distance from that pattern to the goal pattern  shown in the lower part of figure 1 b  . figure 1 b  depicts the regular lookup in this
pdb for estimating a distance from a given state s to the goal  figure 1 a  . state s is mapped to a 1-1 pattern by ignoring all the tiles other than 1  1  1 and 1. then this pattern's distance to the goal pattern is looked up in the pdb. to be specific  if the pdb is represented as a 1-dimensional array  pdb  with the array indexes being the locations of tiles 1  1  1  and 1 respectively  the regular lookup for state s is pdb  because tile 1 is in location 1  tile 1 is in location 1  etc. the value retrieved by a regular pdb lookup for state s is a lower bound  and thus serves as an admissible heuristic  for the distance from s to the goal state in the original space.
　it is common practice to exploit special properties of a state space to enable additional lookups to be done in a pdb.  cullberson and schaeffer  1  describe several alternative lookups that can be made in the same pdb based on the physical symmetries of the 1-puzzle. for example  because of the symmetry about the main diagonal  the pdb built for the goal pattern in figure 1 b  can also be used to estimate the number of moves required to get tiles 1  1  1 and 1 from their current positions in state s to their goal locations. we simply reflect the tiles and their positions about the main diagonal and use the {1-1}pdb for retrieving the symmetric values. the idea of reflecting the domain about the main diagonal for having another set of pdbs was also used by  korf and felner  1; felner et al.  1  when solving the 1 and 1 tile puzzles with additive pdbs  see figure 1 below .
　because all valid  alternative pdb lookups provide lower bounds on the distance from state s to goal  their maximum can be taken as the value for h s . of course  there is a tradeoff for doing this-each pdb lookup increases the time it takes to compute h s . because additional lookups provide diminishing returns in terms of the reduction in the number of nodes generated  it is not always best to use all possible pdb lookups  cullberson and schaeffer  1 . a number of methods exist for reducing the time needed to compute h s  by making inferences about some of the values without actually looking them up in a pdb  holte et al.  1 .
　the main contribution of this paper is a new  alternative pdb lookup that is based on properties other than physical symmetries. we call it the dual pdb lookup. the dual lookup is always admissible but  unlike previously considered pdb lookups  it can return values in the search that are inconsistent. our second contribution is a simple but useful extension of the well-known pathmax method so that inconsistencies in heuristic values are propagated in both directions  childto-parent  and parent-to-child  in the search tree. our final contribution is that dual lookups  with bidirectional pathmax propagation  produce state-of-the-art performance for three standard test applications.
1 dual lookups in pattern databases
the states of many problems  such as the sliding tile puzzles  rubik's cube  towers of hanoi  etc.  are defined by assigning objects  e.g. tiles  cubies  disks  to locations.
　to explain the dual pdb lookup  consider again the {1-1}-pdb for the 1-puzzle defined above. the regular pdb lookup asks the question of what is the cost of getting tiles 1  1  1 and 1 from their current locations to their goal locations 
in general  the regular lookup focuses on a fixed set of objects  the ones that define the patterns   and bases its lookup on their current locations  which vary from state to state.
　in the dual pdb lookup the roles of locations and objects are switched. the dual pdb lookup focuses on a fixed set of locations - the goal locations of the objects in the pattern - and bases its lookup on the objects that occupy those positions  which vary from state to state. in particular  the dual pdb lookup of figure 1 asks this question: what is the cost of moving the tiles that are currently in the goal location of tiles 1  1  1 and 1 to their home locations  for the state s in figure 1 a   for example  the dual pdb lookup asks  what is the cost of getting tiles 1  1  1 and 1 from their current locations  the goal locations of tiles 1  1  1 and 1  to their goal locations  see figure 1 c .
the dual question cannot be answered directly because a pdb based on tiles 1  1  1 and 1 is not available. however  because costs in the 1-puzzle are symmetric and independent of the exact tiles involved  the dual question can be answered using the {1-1}-pdb. as shown in figure 1 d   if we replaces the names of tiles 1  1  1 and 1 with the name of the tile whose goal location they each currently occupy  the 1-1 goal pattern at the bottom of figure 1 c  turns into a 1-1 pattern that can be looked up in the 1-1 pdb. in particular  the dual lookup would retrieve the value pdb  because in state s tile 1 is in tile 1's goal location  tile 1 is in tile 1's goal location  etc.
　another example for dual looukups is the  n k -topspin puzzle which has n tokens arranged in a ring. any set of k consecutive tokens can be reversed  rotated 1 degrees in the physical puzzle . our encoding of this puzzle has n operators for each possible reversal/rotation. figure 1 a  shows the goal state of the  1 -topspin puzzle. figure 1 b  shows the result of reversing the tokens at locations 1  and figure 1 c  shows the result of reversing the tokens in locations 1 of figure 1 b .

1   1    1    1    1    1    1    1    1
1   1    1    1    1     *    *     *    * a  the goal state of top spin	 d  the goal pattern 
1   1    1    *     *    1    1     *    *1    1    1    1    1    1    1    1    
 b  locations 1 of  a  reversed e  the regular lookup for state  c 1    1    1    *    *    *    *    1    1    1    1    1    1    1    1    1    1    1
 c  locations 1 of  b   reversed	 f  the dual lookup for state  c 
figure 1:  1 -topspin states
　suppose patterns for topspin are defined by ignoring tokens 1. the resulting pdb provides distances to the goal pattern  shown in figure 1 d   from all reachable patterns. consider figure 1 c . the regular pdb lookup for this state is based on the pattern in figure 1 e   obtained from  c  by mapping tokens 1 to  * . since tokens 1 are in locations 1  1  1  1 and 1  respectively  the regular lookup would be pdb. for the dual lookup  we note that the goal locations of tiles 1  as in state  c   are occupied by tokens 1  1  1  1  1. the dual lookup  pdb  gives the cost of moving these tiles to their goal locations. this lookup corresponds to the pattern shown in figure 1 f .
　dual pdb lookups are possible where there is symmetry between objects and locations of the domain in the sense that each object is located in one location and each location occupies only one object. example domains where this is true are the topspin puzzle  section 1  and rubik's cube  section 1 . a counter example is the towers of hanoi where there is no symmetry between locations and objects. the 1 puzzle domain is more difficult because the blank has to be handled differently from the other tiles. nevertheless  even in this seemingly asymmetric domain  the pdbs can be constructed in such a way as to enable the dual symmetry  see section 1 .
1 bidirectional pathmax  bpmx 
regular pdb lookups produce consistent heuristic values during search  holte et al.  1 . dual lookups are admissible  but not necessarily consistent. for our topspin example  let hd be the result of a dual lookup on this pdb. in figure 1 b   tokens 1 are in their goal locations and therefore hd b  = 1. figure 1 c  is obtained from  b  by a single move. however  the dual lookup for this state uses the pattern in figure 1 f   which is two moves away from the goal pattern. therefore  hd c  = 1  which is inconsistent with hd b  = 1 since  c  is only one move from  b .
　 mero  1  described two methods of propagating heuristic values between a state and its children to take advantage of inconsistencies. let p be any state  {ci} the children of p  and dist p ci  the cost of reaching ci from p. mero's first propagation method  now known as pathmax  propagates heuristic values from p to its children: h p  dist p ci  is a lower bound on dist ci goal  and therefore can be used instead of h ci  if it is larger. mero's second method propagates heuristic values upwards  from the children of p to p. the path from p to the goal must pass through a child of p 1. thus  min h ci  + dist p ci   is a lower bound on dist p goal  and can be used instead of h p  if it is larger.
　previous work failed to notice that when operators are invertible  and costs symmetric   pathmax allows values to be propagated in both directions and is also applicable in undirected graphs. this might produce a more useful children-toparent propagation than mero's second method.

figure 1: propagation of values with inconsistent heuristics
　the bidirectional pathmax method  bpmx  is illustrated in figure 1. the left side of the figure shows the  inconsistent  heuristic values for a node and its two children. when the left child is generated  its heuristic  h = 1  can propagate up to the parent and then down again to the right child. to preserve admissibility  each propagation reduces h by the cost of traversing that path  1 in this example . this results in h = 1 for the root and h = 1 for the right child. when using ida*  this bidirectional propagation can cause many nodes to be pruned that would otherwise be expanded. for example  suppose the current ida* threshold is 1. without the propagation of h from the left child  both the root node
 f = g + h = 1 + 1 = 1  and the right child  f = g + h =
1 + 1 = 1  would be expanded. using the propagation just described  the left child will improve the parent's h value to 1  resulting in a cutoff without even generating the right child.
1 topspin
we have implemented the above ideas on the  1 -topspin puzzle. this domain has 1! = 1 〜 1 states. we generated a pdb of the leftmost 1 tokens  a pattern space of 1 〜 1... 〜 1 = 1 〜 1. since this puzzle is cyclic  we can assume that token number 1 is always in the leftmost
heuristicnodestimebpmx1r+1d1 1 / 11 / 11r+1d1 1 / 11 / 11r+1d+c1 1 / 11 / 111r+1d1 1 / 11 / 11r+1d+c1 / 11 / 111r+1d+c1 / 11 / 111r+1d1 / 11 / 11r+1d+c1 / 11 / 111r+1d1 / 11 / 11r+1d+c1 / 11 / 111r+1d+c1 / 11 /	11r+1d+c111table 1: solutions to the  1  topspin puzzle
position. thus  for implementation  both numbers above can be divided by 1. since all the values in the pdb were smaller than 1  each entry needs 1 bits and the pdb needs 1mb.
　a pdb of 1 tokens has actually 1 different ways of choosing which tokens are included. a pdb of tokens  1...1  can also be used as a pdb of  1...1    1...1   etc  with the appropriate mapping of tokens. thus  a single pdb gives us 1 regular heuristics and 1 dual heuristics. the search was done using ida*. many duplicate states can be avoided by forcing two unrelated operators to be applied successively in only one order. for example  the operator that reverses locations  1 1  is not related to the operator that reverses locations  1 1 . this operator ordering decreased the number of generated nodes by an order of magnitude.
　table 1 presents data for different heuristics and combinations. each value in the table is an average over a set of 1 random permutations. the average solution length for this test set is 1. all the experiments reported in this paper were run on a 1ghz pentium 1 pc with 1gb of memory.
　the table columns give the number of regular  'r'  and dual  'd'  lookups used  the presence of bpmx cutoff  'c'   the number of generated nodes  nodes and ratio to the same number of lookups with only-r result   the time  seconds and ratio   and the number of times that the bpmx cutoff occurred.
　the results show that a single dual lookup outperforms a regular lookup by a factor of 1 in generated nodes  1 in running time . this is because the dual lookup frequently  jumps  to different areas of the pdb and has a larger diversity of different heuristic values as will be further explained in section 1. the bpmx cutoff further improves this to a factor of 1 in nodes  1 in time . the bpmx cutoff was applicable 1 times  pruning 1 1 nodes  and averaging 1 nodes per instance of cutoff. these performance gains are achieved using no additional storage  just by looking at one pdb in different ways.
　the table also shows the results of using two lookups and taking their maximum. compared to two regular pdb lookups  two dual lookups  with bpmx  give an 1-fold reduction in nodes. this result is better than combining one regular and one dual lookup. when four lookups are used  again the dual-only lookup solution is better than the regularonly lookup solution. we see diminishing returns when more
heuristicnodestime1r+1d1 1 / 11 / 11r+1d1 1 / 11 / 11r+1d+c1 1 / 11 / 11r+1d1 1 / 11 / 11r+1d+c1 1 / 11 / 11r+1d+c1 1 / 11 / 11r+1d1 1 / 11 / 11r+1d+c1 1 / 11 / 11r+1d+c1 1 / 11 / 11r+1d+c1  1.1r+1d+c11table 1: solutions to rubik's cube from one 1-edges pdb
and more lookups are done. many lookups provide a diversity of heuristic values anyway. therefore  the improvement factor of any additional lookup  dual or regular  decreases.
　note that our fastest implementation uses 1 regular and 1 dual lookups took 1 seconds - 1 times faster than a single regular lookup. using 1 regular and 1 dual lookups produces the smallest search tree of only 1 generated nodes - a factor of 1 over a single regular lookup.
　we used our fastest implementation  1r+1d+c  to solve larger versions of topspin. topspin  1  is 1 〜 1 times larger than the  1  variant. we solved 1 instances for topspin  1 . the average solution length is 1  1 million nodes are generated and the search takes 1 seconds. for topspin  1   1 times larger   we tested on five problems with an average solution length of 1. these problems averaged 1 billion nodes and took 1 seconds.
1 rubik's cube
 korf  1  solved the 1 〜 1 〜 1 rubik's cube  containing roughly 1 〜 1 different reachable states. there are 1 movable sub-cubes  or cubies. they can be divided into eight corner cubies  with three faces each  and twelve edge cubies  with two faces each. as a first experiment  we built a 1-edge-cubies pdb  the largest that can be stored in 1gb of memory. there are 1 1 possible permutations of the 1 edge cubies. at 1 bits per entry  1mb are needed for this pdb. as with topspin  symmetries in the domain mean that there are multiple possible regular and dual lookups.
　table 1 presents results for a number of possible combinations of this setting  the table headings have the same meaning as in table 1 . the start states used were  easy -1 different states obtained by 1 random moves from the goal configuration  average solution length of 1 .
　the results are similar to the topspin experience  albeit slightly lower. again  the dual lookup and bpmx cutoffs result in large reductions in the search effort. however  for this puzzle by the time you hit four lookups  diminishing returns has taken over and the advantage of the dual has dissipated. our best implementations reduced the number of nodes generated  1r+1d+c  by a factor of 1  and the time  1r+1d+c  by a factor of 1. all this was possible with just one 1-edgecubies pdb stored in memory.
　 korf  1 's original 1 rubik's cube experiments were repeated  this time with dual pdb lookups. korf used three pdbs for this domain: one pdb for the 1 corner cubies and two pdbs for two sets of 1 edge cubies. since a legal move in this domain moves 1 cubies  the only way to combine these 1 pdbs is by taking their maximum. note that there are 1 corner cubies and all 1 are used by the 1-corner pdb. thus  performing a dual lookup for this particular pdb is irrelevant. here  the entire space of corner cubies is in the database and both lookups give the same result.
　results for the same set of 1 random instances used in  korf  1  were obtained. the results for korf's set of 1 + 1 pdbs were improved by a modest amount by adding the dual lookups for both 1-edge pdbs  from 1 billion nodes to 1 billion . increasing the edges pdb from 1 to 1 cubies and using a 1r+1r+1d+1d setting reduced the search to 1 billion nodes - an improvement of a factor of 1 over korf's initial setting. the improvements of adding dual lookups for the 1- and 1-edges pdbs are modest since most of the time the 1-corner pdb has the maximum value; this pdb is larger and contains more cubies than the 1- and 1-edge pdbs. we measured these rates over 1 million random instances. for the 1 + 1r + 1r + 1d + 1d setting  the 1-corner pdb had the maximum value in 1% of these cases while one of the lookups in the 1-edges cubies was the maximum in only 1% of the cases  the rest of the cases are a tie . these numbers were changed to 1% and 1% respectively for the 1 + 1r + 1r + 1d + 1d setting.
1 sliding-tile puzzles

1111
111111figure 1: partitionings and reflections of the tile puzzles
　we have also implemented the new ideas for the sliding-tile puzzles. for the 1-puzzle  we used the same 1 partitioning from  korf and felner  1   figure 1 . these pdbs are constructed so that their heuristic values can be added  felner et al.  1  together and preserve admissibility. the pdbs can be reflected across the diagonal  obtaining another set of 1   1 heuristics  also shown in figure 1 .
　dual lookups for this domain are not obvious. while there are 1 similar locations  the 1 tiles are not similar as there are 1 real tiles and one blank. given the location of the blank  then a horizontal line  or a symmetric vertical line  across the middle of the puzzle divides it into two regions of 1 locations. one region  call it a  has 1 locations which are occupied by 1 real tiles  and another region of 1 locations  b  which are occupied by 1 real tiles and the blank. performing a dual lookup for region a in the 1-tile pdb is identical to what was done in topspin and rubik's cube.
　a dual lookup in b is complicated by the blank. figure 1 shows four possible blank locations in b for a horizontal partitioning. other locations of the blank  as well as a vertical
ab cb cacddccddcab cb ca	general	
figure 1: four different  dual  1-tile pattern databases
partitioning into two regions  can be easily transformed into one of these 1 configurations  e.g.  by reflection . consider the regular 1-tile pdb of tiles  1...1   which corresponds to the 1 real tiles of region b of figure 1 a  . this pdb answers the question of how to move these real tiles from any possible configuration to their goal configuration. the dual lookup should answer the question of how many moves it takes to distribute the tiles that are currently located in locations  1...1  to their goal configuration. if these tiles are all real tiles  and the blank is in the corner  then getting this data from the regular pdb is as before. however  when the blank is not in the corner   the other cases of figure 1  one of the tiles occupying locations  1...1  is the blank. therefore  the answer from a dual lookup of the regular 1-tile pdb will also count moves of the blank while the real tile in the corner will be ignored. this might lose admissibility.
　there are two possible ways to solve this problem. the first is to artificially move the blank tile to the nearest corner. in effect  this means reducing the pdb value by one or two  to account for the extra blank moves  to preserve admissibility. now we can use the regular 1-tile pdb for a dual lookup  at the cost of a weaker heuristic  and  hence  additional search . a better idea is to add three more 1-tile pdbs for a total of four-one for each of the cases in figure 1. for each blank scenario we build a regular 1-tile pdb assuming that the blank is located in the relevant location. for example  for region b of figure 1 b  we build a pdb for the tiles {1 1 1 1} and assume that tile 1 is the blank tile. this pdb cannot be consulted as a regular pdb since we assume that tile 1 is the blank. however  for any partitioning where region b corresponds to this case  we can perform a dual lookup in this pdb and retrieve the correct value for the tiles that are currently located in locations {1 1 1 1}  or their reflections . similarly for the other blank locations.
　the frame on the left of figure 1 indicates the relevant pdb for the dual lookup of each possible blank location. in those locations where two pdbs are given  then the right label indicates the pdb to use for a horizontal partition while the left corresponds to a vertical partition. the amount of memory needed is 1kb for the 1-tile pdb and 1kb for a 1-tile pdb. thus the total memory needs  the 1-tile and 1-tile pdbs  is 1kb. the three extra pdbs needed to handle all the dual cases correctly represent a small increase of memory.
　table 1 presents results of the different heuristics averaged over the same 1 instances used in  korf and felner  1 .
heuristicav. hnodestime1r11 / 11 / 11r+1r*11 / 11 / 11d11 / 11 / 11d+c11 / 11 / 11d+1d*+c11 / 11 / 11r+r*+1d+1d*+c11 / 11 / 1table 1: results for the 1 puzzle
pdbsnodestimememory1r+1r*1 1111r+1r*+1d+1d*+c1 111table 1: 1 puzzle results
the average solution for these instances is 1. the first column indicates the heuristic used  with 'r*' and 'd*' representing the reflected regular and dual pdb lookups. the first row presents the results when only the regular pdb is used  while the second row took the maximum of the regular and reflected pdbs. note that these two rows are the same results obtained by  korf and felner  1  but on our current machine. the next three rows present results for different versions of the dual lookup. note that for this domain the bpmx cutoff yielded a reduction in nodes of only 1% for a single dual lookup. finally  the last row presents the maximum over the four pdb combinations. using dual lookups reduces the number of generated nodes by more than a factor of 1 and eliminated one third of the execution time compared to the best results of  korf and felner  1   line 1 of table 1 . to our knowledge using the four regular/dual normal/reflected pdb lookups gives the best existing heuristic for this puzzle. of historical note is that the number of generated nodes is now nearly 1 times smaller than when ida* first solved the 1-puzzle using only manhattan distance  korf  1 .
　similar experiments were performed using the 1-puzzle. the original 1-1 partitioning from  korf and felner  1   figure 1  needed storage for only two 1-tile pdbs since all the 1 〜 1 rectangles are symmetric. as before  we need additional pdbs to handle the blank. we use 1-tile pdbs: one for all the 1 〜 1 rectangles and their duals  but we need 1-tile pdbs for the irregular shape in the top left corner  see figure 1 . each 1-tile pdb needs 1mb and our new system needs 1 times as much memory.
　in  korf and felner  1  1 random instances of the 1puzzle were solved. table 1 presents the average results over the 1 easiest problems of that set  the 1 with the fewest nodes generated . the average solution length for this set is 1 moves. using both regular and dual lookups and their reflections reduces the number of generated nodes by a factor of 1 and the time by a factor of 1 when compared to the results of  korf and felner  1   first line of table 1 .
1 discussion
dual pdb lookups double the number of possible pdb lookups. they are effective for all the domains studied but perform differently on the various domains. there are two phenomena that need explantion. first  the bpmx cutoff was much better in topspin and rubik's cube  a factor of up to 1  than in the tile puzzles  only 1% . second  in topspin and rubik's cube a single dual pdb lookup  even without the bpmx cutoff  was better than a single regular pdb by a factor of up to 1  while in the tile puzzles it was worse.
　to explain this we define the inconsistency rate of a heuristic as the average difference between the heuristics of an arbitrary pair of neighboring states. for a consistent heuristic  this rate must not exceed 1  assuming a uniform edge cost of 1 . we measured this rate for 1 million pairs of states for each domain. for the dual lookups the rates were 1 for topspin  1 for rubik's cube  1-edge pdb  and only 1 for the 1-puzzle.
　values in pdbs are locally correlated. however  in topspin 1 tokens change their locations at each move  1 cubies for rubik's cube . the identity of the tokens queried by the dual lookup can dramatically change between consecutive steps. this is a dramatic  jump  to different place in the pdb. there is no locality of values with such a jump  meaning there is higher chance of getting a radically different heuristic value  better or worse . this causes ida* to generate less nodes as mistakes of heuristics  such as low estimations  are being corrected fast. this also increases the rate of inconsistency and thus the bpmx cutoff is performed frequently.
　in the 1-puzzle however  every operator only moves one tile. this means that in two consecutive pdb lookups  regular or dual  most of the indices stay the same - and you get similar values. furthermore  in most cases of the 1-puzzle  the blank and the tile that exchange their locations belong to the same set of 1 locations indicated by region b above. thus the identity of the 1 and 1 tiles for the dual lookups remain the same in consecutive steps. only when the blank crosses the partition line  such as moving from position 1 to position 1 in figure 1c  then the 1-tile set and the 1-tile sets for the dual lookups are changed and there is some chance for a dramatic jump and for inconsistency. however  even in this case the inconsistency rate is low because we add heuristics of two different subproblems which together report values for all the 1 tiles. thus  the identity of the tiles being reported is not changed. therefore  the diversity and inconsistency rate is low and the bpmx cutoff is not performed frequently.
　we can conclude that dual heuristics and bpmx cutoff are more effective in domains where each operator changes larger parts of the state and the identity of objects being reported in consecutive steps is different.
　another interesting phenomenon is the fact that unlike the other domains  in the 1 puzzle the pure dual pdb lookup was worse than the pure regular lookup and generated almost twice as many nodes. the reason for this is again the location of the blank. note that while the regular pdb lookup always consults the 1-tile pdb and the 1-tile pdb labeled a in figure 1  the dual pdb might also consult the other 1-tile pdbs  labeled b  c and d . this is because the regular lookup always aims for a region b configuration such that the blank is located in a corner  the goal state  while the dual lookup needs to consider other possibilities for region b. it turns out that getting the blank to the corner is a harder task and needs more moves. while the average value over all the entries of the pdb labeled a in figure 1 is 1  the average values of the pdbs labeled b  c and d are 1  1 and 1 respectively. thus  we expect that the values obtained by the dual lookups will be smaller than those obtained by the regular pdb. historically  the goal location of the blank is in the corner. however  if we set a goal state such that the blank is in location 1  as in figure 1.c  then the regular heuristic will always look in the weakest pdb while the dual heuristic will consult the other pdbs as well. we have made such experiments and indeed  the pure dual pdb lookup generated nearly 1% less nodes than the pure regular pdb.
　it is important to note that the dual lookups for the tile puzzles are of great importance. topspin and rubik's cube have many symmetries and thus enable many possible regular pdb lookups. in the tile puzzles  however  there is only one symmetry available for the state-of-the-art additive heuristic-the reflection about the main diagonal. thus  the dual idea doubles the number of possible lookups and achieved a speedup of a factor of 1 over the previous benchmarks.
1 summary and conclusions
we presented a new way of using pattern databases. we show that the dual lookup heuristic values are inconsistent  which allows additional opportunities for achieving cut-offs in the search. results on topspin  rubik's cube  and the sliding tile puzzles confirm the advantages of this new heuristic. to the best of our knowledge we have the best published optimal solvers for all three domains.
　inconsistent heuristics have a negative reputation; something to be avoided. we showed that there is nothing to fear with inconsistent heuristics and there can be real benefits.
