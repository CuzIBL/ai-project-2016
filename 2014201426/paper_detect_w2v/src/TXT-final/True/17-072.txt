 
　　　principled development techniques could greatly enhance the understandability of expert systems for both users and system developers. current systems have limited explanatory capabilities and present maintenance problems because of a failure to explicitly represent the knowledge and reasoning that went into their design. this paper describes a paradigm for constructing expert systems which attempts to identify that tacit knowledge  provide means for capturing it in the knowledge bases of expert systems  and apply it towards more perspicuous machinegenerated explanations and more consistent and maintainable system organization. 
1. introduction 
     swartout's xplain system  swartout 1  demonstrated the feasibility of producing expert systems with enhanced capabilities for generating explanations and justifications of their behavior. xplain was based on two key principles: explicitly distinguishing different forms of domain knowledge present in the knowledge base  and formal recording of the system development process. we will argue that these principles are vital both for explaining and for maintaining expert systems. this paper will propose a new paradigm for building expert systems  and consider the paradigms implications for providing automated assistance in two tasks commonly encountered in the course of developing and using expert systems: 
 generating explanations to clarify or justify the behavior and conclusions of the system; 
  extending or modifying the system's knowledge base or capabilities; 
     the paradigm we are proposing  which we call the explainable expert systems approach  calls for shifting the emphasis of knowledge engineers' efforts from procedural encoding to declarative knowledge representation. in this approach  development and use take place in an integrated support environment. knowledge engineers and domain experts collaborate to produce a rich semantic model of the declarative and procedural knowledge of the domain. their efforts produce a knowledge base which  augmented by advice about implementation considerations  is used to guide an automatic program writer through generation of the actual code for the expert system. the program writer maintains a record of its choice points and decisions  which constitutes the system's development history. the code is executed by an interpreter that maintains a record of the system's execution history. 
the research described in this paper was supported under darpa grant 
#mda 1-c-1. we would like to thank bob baker  jeck mostow  and dave wile for their comments on previous drafts we would also like to thank neil 
goldman  tom lipkis  norm sondheimer  don voreck  and dave wile for helpful input on other occasions.      all together  the knowledge base  the development history  the code  and the execution history  provide the basis for question-answering routines that allow developers and users to obtain information about the origins and rationales behind the system's code  as well as to the code itself. the availability of this extra information provides domain experts with more power to critique the system  to identify deficiencies  and to find those points in the system conception or implementation responsible for a deficiency. the availability of this extra information also provides end-users greater power to understand the abilities and limitations of the system. thus  although the ees paradigm does increase initial development costs  we expect that those costs will be repaid in greater acceptance by users  easier maintenance  and a greater degree of reusability that will smooth the development of related systems later on. to support this claim  let us briefly consider what the availability of extra knowledge means for the tasks mentioned earlier: explanation and maintenance. 
1. explanation 
　　　as we will elaborate in section 1  the availability of information from a domain knowledge base  a development history  and an execution trace yields the opportunity to provide richer explanations of the system than are available in conventional approaches. conventional expert systems  lacking these added knowledge sources  are restricted to explanations composed from canned text or by paraphrasing the system code. these suffer from a number of flaws. canned text cannot anticipate  or adapt to  all possible needs. since its maintenance is a separate and additional task from code maintenance  the text can quickly become invalid with respect to the true state of the system code. on the other hand  code paraphrasing is limited by the information that is represented in the code - and even more limited by the information that is not represented. explanation by code paraphrasing can describe actions in fairly low-level terms but it cannot  for example  describe high-level principles motivating those actions or explain why those actions instantiate some high-level principle. for example  in mycin  the general principle that the type of an infection may be determined using a weight-of-evidence scheme is encoded in several dozen rules  specific to particular types of infections  szolovits 1 . the general heuristic itself is never explicitly represented  and hence is not available for explanation. 
　　　more sophisticated explanations require that design knowledge behind the system be explicitly represented  which is one of the roles served by a richer domain knowledge base and a development history. our approach to explanation depends on a taxonomy of information goals  with explanation strategies associated with each information goal. an explanation strategy tells the system how to inspect the knowledge base in order to obtain information relevant to a particular goal. question answering involves inferring information goals from questions  then applying the appropriate strategy. 
1. maintenance 
     as we will elaborate in section 1  the use of an automatic program writer to derive code from more abstract specifications presents an opportunity to simplify the maintenance process. the need to modify a system's code generally arises for one of three reasons: 
  there is an invalid assumption or principle upon which the code was based; 
- an assumption or principle was valid  but the code failed to correctly instantiate it; 
- additional concerns  such as ease of implementation or efficiency considerations  make an alternative method of achieving some goal preferable. 
　　　in all of these cases  the primary tasks of a maintainor are to diagnose the cause of dissatisfaction with the current system  and to locate and modify all of the relevant code. in conventional systems  since the linkage between code and higher-level principles is not explicitly represented  there can be difficulties with both tasks. when the basis for some segment of code is either invalid or inappropriately realized  it may be very hard to reconstruct from the code alone what that basis should have been. when code is rewritten or superseded  it may be very difficult to determine what other code is affected. consider the same example mentioned above of mycin's weight-of-evidence scheme for determining infection types. if one wished to change this principle  dozens of rules would have to be located and modified. in the absence of any kind of pointers to those rules  it is easy to imagine some of those rules being missed  requiring multiple iterations of modification and testing to accomplish the modification. 
similar issues arise when the goal is to extend a system. 
say one wanted to add knowledge about a new infection type to 
mycin. obviously  the many rules pertaining to existing infection types could be used as examples to indicate the form of the new rules that would have to be added. again  though  in the absence of pointers into the code  one has no easy way of making sure that all the relevant rules are located. thus  one has no assistance in ensuring that all the necessary new rules are added  much less that they are correctly stated. 
     our approach is to provide support for the diagnosis phase of maintenance through the extended explanation capabilities  and for the code modification phase through the automatic program writer. as sections 1 and 1 will show  the approach calls for the system builders to provide a knowledge base containing descriptive knowledge of how the domain works  and abstract problem-solving methods that apply to classes of problems. a classifier  schmolze 1  identifies all instances of domain concepts for which a problem-solving method must be instantiated  and the automatic program writer generates code by integrating descriptive domain knowledge and problem-solving methods. thus  for example  mycin's weight-of-evidence scheme for infection types would be handled by specifying methods applicable to instances of infection types  the known infection types  and  possibly  a method for integrating the results of the method instances that will be generated. the program writer would use this information to generate the appropriate specific rules for each particular infection type. changing the principle or adding a new infection type both would be a matter of changing a small number of assertions in the knowledge base and then rerunning the program writer. 
r. neches et al. 
1. xplain: the precursor of the ees paradigm 
     the xplain system recognized two forms of domain knowledge  factual information vs. problem solving methods  and one kind of development  refinement by a hierarchical planner . for example  when xplain was used to generate a digitalis drug dosage advisor  its tactual knowledge  or  domain model   
included assertions such as: 
-high serum calcium levels can cause increased automaticity. 
  low serum potassium levels can cause increased automaticity. 
- high digitalis doses can cause increased automaticity. 
- increased 	automaticity 	can 	cause 	ventricular fibrillation. 
  ventricular fibrillation is a highly dangerous condition. 
this factual knowledge was augmented by problem solving methods  or  domain principles    such as  
- in adjusting the drug dosage recommendation  check for factors which can cause dangerous conditions that also can be caused by administering the drug. 
     applying this principle  and  of course  others  to the factual knowledge led xplain to generate procedures for adjusting dosage recommendations to account for serum calcium and serum potassium levels. as it generated that implementation from the two forms of knowledge  xplain recorded the steps it had taken. 
     recording the derivation of the actual low-level procedures from the domain principles enabled xplain-generated systems to give more principled answers to  why  questions. xplain's digitalis drug dosage advisor  for example  was capable of explaining that it was asking about the patient's serum calcium level as part of adjusting the recommended dosage  and that this was important because too high a dosage of digitalis could interact with the effects of serum calcium level to produce the dangerous condition of ventricular fibrillation. that is  the xplain-generated system could justify its request for a patient parameter both by paraphrasing the program code  and by constructing a justification for the parameter's significance based on an abstract model of the domain. 
     the separation of knowledge in xplain also seemed to hold promise for easing the process of extending the system. knowledge was modularized into  a  situations where patient factors could have undesirable interactions with the digitalis dosage; and   b  problem solving knowledge governing checking for such factors and adjusting the dosage accordingly. since xplain took responsibility for applying the problem solving rules to whatever factual knowledge was given to it  programming the system to handle a new situation and generate suitable explanations for its new behaviors would require making only a few assertions to describe the added factors  rather than writing large amounts of new code that bore great similarities to existing code. 

     in moving beyond xplain  we have identified a number of additional forms of knowledge and methods of development which are important to represent explicitly. three forms of knowledge seem particularly important: 
trade-offs define dimensions along which the relative success or utility of a problem-solving method should be measured  along with criteria for evaluating that success or failure  and knowledge about the likely effects of each problem-solving method along those dimensions. although the term might be taken in other ways  we mean it is a list of the strengths and weaknesses of a method with respect to general goals  rather than  say  in direct comparison to other methods . 
preferences are context-sensitive rules for ranking and selecting from alternative operators at a given choice point on the basis of their trade-offs. 
terminology refers to mappings between abstract concepts of a domain and their more concrete manifestations. 
1. the ees framework 
a broad view of the ees system is shown in figure 1. 
　　　the knowledge base is the foundation stone of the ees system. the domain model describes how the domain works. it contains  among other things  typological and causal linkages. while the domain model describes how the domain works  it does not indicate how problem solving should be done. domain principles represent problem-solving strategies and are used by the program writer to drive the refinement process. tradeoffs are associated with domain principles to indicate the beneficial and harmful effects of selecting a particular strategy to achieve a goal. preferences are associated with goals and are used to set priorities based on tradeoffs. mappings between abstract terms and the concepts that realize them  which had been included as part of domain principles in xplain   are broken out as a separate type of knowledge to allow terminology to be shared across domain principles. integration knowledge is used to resolve potential conflicts among knowledge sources. optimization knowledge represents ways of efficiently controlling the execution of the derived expert system. 

     the remainder of this section will illustrate the concepts introduced thus far by considering the development of a portion of a program enhancement advisor. the program enhancement advisor  pea  is an expert system that critiques lisp programs  offering advice and assistance on stylistic improvements. the portion we will be considering seeks to improve the readability and maintainability of programs by recoding conditional expressions which use lisp's cond into expressions that use alternative constructs like the if-then-else available in interlisp's  conversational lisp  package  interlisp 1 . 
1. the knowledge base 
the system's knowledge base is represented in nikl  moser 
1 . nikl is a refinement of kl-one  brachman 1   a semantic network based representational formalism. the semantics of nikl have been worked out sufficiently that automatic classification  schmolze 1  is possible given an existing network and a new concept  the nikl classifier automatically determines the appropriate place for the new concept in the subsumption hierarchy of the network  based solely on the structure of that concept. 
     the knowledge base contains several different kinds of knowledge  which are integrated together by the program writer to produce a working expert system. in the program enhancement advisor domain  the domain knowledge or descriptive knowledge of how the domain works  is the knowledge of program transformations: what their applicability criteria are and what effect they will have. a simplified portion of the nikl representation describing the transformation of a cond statement into a clisp if-then-else statement is shown in figure 1. space limitations preclude explaining the nikl representation's details  but the gist follows. the cond to if-then-else transformation classifies as a readability enhancing transformation because its result classifies as an easy to read construct. this latter classification holds because if-then-else is a keyword-marked construct which  in turn  is an easy-to-read construct because its parts are explicitly identified 
by keywords. in short  if-then-else is easy to read because each of its parts is explicitly identified by a keyword.  in section 1 we will consider how the system might mechanically create an explanation justifying the desirability of this transformation.  


figure 1: global view of the ees framework 

figure 1: simplified nikl representation of if-then-else transform 

       pea's problem-solving knowledge tells the system how to use its transformations to enhance a program. in particular  this includes strategies for scanning a program file to find places where transformations might be applied  for resolving conflicts among those possible transformation applications  and for finally applying the transformations. plans and goals are represented in nikl and are organized into a hierarchy by the nikl classifier. 
associated with each plan is a capability description which describes what the plan can do. this description is used by the system to find plans that can achieve goals. 
       the explicit representation of terminological knowledge  or the knowledge of how terms are defined and differentiated  is considerably facilitated by our use of nikl  because it is exactly 
the kind of knowledge that has to be represented for the nikl classifier to do its job. for example  in figure 1  a keywordmarked construct is defined as an abstract construct whose concrete syntax has keywords that identify parts of the concrete syntax as components of the abstract construct  this structural description is used by the classifier  and the program writer as described below  to find particular instances of keyword-marked constructs.1 
1. the refinement process 
　　　the first pass program writer creates the expert system in a top-down fashion  in this case  starting from the high level goal enhance program. as the writer implements goals  subgoals may be raised which in turn require implementation. the writer iteratively implements goals until the level of system primitives is reached. there are several means available to the system for finding implementations for goals: 
goal/subgoal refinement this is the familiar form of refinement by breaking a goal down into subgoals. this occurs whenever the system can find a plan that implements a goal. the system locates plans by searching up the classification hierarchy starting from the goal until it finds a plan whose capability description subsumes the goal. 
goal reformulation into cases when the system is unable to find a plan that implements a goal  it may reformulate that goal into several goals that can be implemented and together cover the possibilities presented by the original goal. below  we will illustrate several uses of this kind of reformulation in the program enhancement advisor. with the capability of reformulation into cases comes the need to be able to recombine the results of individual cases into an overall result for the general goal. this is where the system's integration knowledge comes into play. an example of its use in the program enhancement advisor is given below. 
user directed refinement most current expert systems do not accept much direction from the user. yet as expert systems move into domains where the 
   it is worth pointing out that in the xplain system  because its knowledge base did not support definition of terms and classification  terminological knowledge was represented implicitly in the domain rationale  as part of the domain principles we now feel that this mixing of terminology with problem-solving knowledge was inappropriate. terminology should be defined separately so that it can be consistent across domain principles. 
r. neches et al. 
goals are less clear cut  it becomes more important to allow the user to further specify goals. for example  in the program enhancement advisor  the top-level goal of enhancing a program is underspecified. it could be that to enhance a program means to make it more readable  or it could mean to make it more efficient or maintainable. exactly what is appropriate depends on knowledge that is outside the scope of the program enhancement advisor  so it makes sense to get advice from the user to further specify such goals. however  the system must constrain the user's ability to refine goals lest he push the system beyond its capabilities. we illustrate our approach to providing the user with a constrained ability to specify goals in the example below. 
　　　from the standpoint of explanation  it is important to distinguish each of these means for implementing goals  and to record their use. goal/subgoal refinements indicate to the explanation facility how a low-level goal fits into the overall strategy expressed by a higher level goal. modelling goal reformulation into cases explicitly is important because knowing that a particular goal was created due to implementation concerns usually means that that goal is unlikely to be interesting to users  but possibly quite important to system designers . finally  the explicit modelling of user preferences afforded by user directed refinement allows the system to tailor its explanations based on known user desires. 
1. an example 
　　　this section outlines a portion of the steps the program writer goes through in generating the program enhancement advisor. starting from the abstract goal of enhancing a program we will show how the system moves toward generating code to scan for specific transformation opportunities. figure 1 shows the development history that results from the implementation steps described below. 
　　　the system starts with the goal enhance program. the system finds a 1 step plan for performing this goal: 
1. find all applicable enhancement transformations; 
1. resolve 	any 	conflicts 	between 	candidate transformations; 
1. present recommendations to the user and ask for confirmation; 
1. act on the recommendations approved by the user. 
　　　in the development history  the writer records the implementation of the enhance program goal as a goal/subgoal refinement  see figure 1 . 
　　　when the system starts refining the first step of the plan  it encounters an instance of a user-directed refinement. the  dynamic-refinement  associated with the step scan for transformation opportunities specifies to the program writer that code should be created to allow the user to specify at run-time what kinds of enhancements should be scanned for. since the program writer cannot predict which kinds the user will request  it will plan code to cover ail kinds present in the 

knowledge base. suppose it finds two kinds of enhancements  those for enhancing efficiency and those for enhancing readability. the writer would post the goals scan for efficiencyenhancing transformations and scan for readabilityenhancing transformations as goals to be implemented. it would also create code for interrogating the user and invoking either or both of the subgoals based on the users desires. the system would then use its integration knowledge to combine the results of the subgoals. in this case  since the two subgoals return lists  the system uses a default strategy of appending the two lists together. 
　　　let's consider how the writer might further refine the goal of scanning for readability enhancing transformations. there is no direct method for implementing this goal  so the program writer examines higher methods in the hierarchy. at the level of scan program for transformation opportunities  the system finds two subconcepts that have specialized methods associated with them  see figure 1 . one of these scans for local transformations  that is  transformations like the cond = =  if-then else transform where the applicability criteria of the transform can all be verified within a single s-expression. the other scanning method scans for what we call distributed transformations  where the applicability criteria require looking at several places in the program. an example of the second type of transform would be one that verifies that it is possible to use records to replace explicit accessor functions. by examining its 
terminological knowledge  as expressed in nikl  the writer determines that together these two methods cover the space of possible transforms  so the single goal of scanning for readability enhancing transforms can be re-expressed as the two goals of 
scan for distributed readability enhancing transforms and scan for local readability-enhancing transforms. this is an instance of a goal being changed based on available domain techniques. 
     the system continues on in this fashion  refining general goals into increasingly more specific goals  until eventually the level of system primitives is reached. at that point the expert system is complete. 


figure 1: a simplified portion of the development history 


1. control issues 
　　　how would this approach be used to build expert systems with particular control structures  such as blackboard or backward-chaining architectures  we view this as a problem of specifying the interpreter that will execute code produced by the program writer. we evaluate three possible approaches below. 
　　　our current approach is to keep the expert system interpreter very simple  and explicitly express the architecture for the system in domain principles. the program writer compiles these principles into a program simple enough for the interpreter to handle. for example  if we wanted a system to perform diagnosis using backward-chaining  we would write a principle that would say  in essence   to determine whether a physiological state exists  conclude that it does if sufficient evidence for the physiological state exists.  the causal and associational relations that would determine what was evidence for what would be expressed as domain descriptive knowledge and integration knowledge would be used to integrate the results of multiple 
sources of evidence  
figure 1: a portion of the method hierarchy 
　　　this approach seems to be the most appropriate one for the two application domains we have considered  digitalis therapy and program enhancement. it allows us to cleanly and easily intermix different control strategies. also  because the interpreter is very simple  any sophisticated features of the expert system's architecture have to be explicitly derived in the development history  so that they can be explained. the major disadvantages are that it may result in an enormous development history  and that the program writer may not be sufficiently powerful to perform all of the derivation steps. 
　　　a second alternative would be to raise the level of the interpreter so that the system primitives captured the desired architecture. the program writer would create code for this architecture. the advantages and disadvantages of this approach are just the reverse of the first approach. we have not explored this approach; we prefer the explanatory benefits of the first approach. 
     the most desirable  but also most difficult  alternative would have the program writer create both a high-level interpreter from 

simple primitives and the code to run at that high level. a higher level interpreter would allow the development history to be smaller  and because the interpreter would be explicitly derived  its operation would be explainable. we have not yet explored this approach in detail. 
1. explanation: procedures for questionanswering 
　　　in previous sections we have described the types of knowledge included in the ees architecture and discussed how this knowledge is organized. in this section  we will describe the classes of questions we believe are important and discuss how the knowledge available within the ees framework enables us to provide answers to these questions. 
1. answering a broader range of questions 
　　　in expert systems which record only the program code  and not the knowledge and reasoning required to generate that code  explanation is necessarily limited to answering questions which depend only on access to that code. among such questions are primarily questions about behavior  such as: 
- how does/did the system perform  action   
- how is/was parameter used  
- what would be the result of  parameter setting}  
     there are  however  a number of other kinds of questions that might reasonably be asked by a system builder or user: 
questions of justification  e.g.  
- why is the system concerned with  value  goal  or action   
- why is  goal or action  necessary  desirable  or important   
- what is the significance of  result   
these questions all essentially seek information about the purpose underlying some aspect of the system  that is  about the relationship of that aspect to the goals of the system builder or user. answering them involves looking at the development history to determine the domain principle s  that generated the queried object  and from there finding further information by examining related terminology  trade-offs  and the preferences operative at the point in time under consideration. 
questions of timing or appropriateness  e.g.  
  when did the system consider/reject  goal  action  or 
conclusion   
  why did it consider/reject  goal  action  or conclusion  at  time reference   
-why didn't it consider/reject  goal  action  or 
conclusion  at  time reference   
     at one level  these are simply questions about the execution history of a system. treated as such  they can be answered by techniques such as those in davis' teiresias system  davis 1  that recorded triggering conditions for rules  and determined 
r. neches et al. 
absences that prevented near-miss rules from being satisfied. however  at a higher level  the questions again deal with intentions  i.e.  the reasons behind the selection conditions imposed on various knowledge items. answering such questions may be essentially the same process as justification questions  but it may also tap knowledge that went into deriving the control aspects of the system. 
 questions of definition or function  e.g.  - what does  term  mean  
- what are the effects of  action   
- what is the relationship between  term  value  goal  or action  and  term  value  goal  or action   
- what is the difference between  term  value  goal  or action  and  term  value  goal  or action   
     these are questions that involve paraphrasing either the development history  the domain model  or domain principles. in each of these cases  of course  paraphrasing depends on tapping knowledge about terminology. 
questions of capabilities  e.g.  
- what does the system know about  concept   
- what factors does the system consider/ignore in concluding  conclusion   
- what methods does the system use/avoid in achieving  goal   
     questions of this class are particularly likely to be stimulated by answers to previous questions. for example  in the case of the xplain digitalis advisor  the answer to a justification question was that the system was interested in serum calcium levels in order to reduce the recommended dosage if the level was abnormal. this naturally leads to the question   are there any other factors like serum calcium   answering such questions primarily involves searching through the domain model  examining type and causal linkages. 
1. information goals and answering strategies 
     in order to devise a process model for answering the range of questions discussed above  we found it useful to categorize the questions we wished to answer into several question types. associated with each question type are heuristics for determining the user's information goals. strategies associated with a particular information goal direct the system in searching the knowledge base and producing a response which satisfies the goal. other researchers in the area of question-answering have found it useful to identify question types and organize procedures for answering questions around these categories  buchanan 1    lehnert 1    mckeown 1 . we expect the additional step of separating question types and information goals will facilitate handling phenomena such as indirect speech acts. 
     a review of the strategies associated with each information goal is beyond the scope of this paper  as is a discussion of the interface which allows users to access question-answering capabilities. here we will concentrate on a discussion of one goal and the strategy for answering it. 
1. an example 
　　　in this section we present a detailed examination of the strategy used for information goals of the type justify result  which are reflected in questions such as '' why should this advice be followed   . 
　　　part of the question analysis process will categorize the question as resulting from one of the information goals known to the system. associated with the goal is the strategy to be used in generating an answer. for example  the strategy to be used in answering questions categorized as type justify result is as follows: 
1. search the development history for the  method  that produced   result . 
1. search upward through the development history for the  goal  that this  method  is a plan for achieving  skipping those goals which are implementation concerns as described in section 1  
1. state this  goal  by using its description in the domain model. 
1. state how  result  is an instance of a result of achieving  goal . 
     now  we will show how this strategy is used to generate a response to an example question of type justily result. suppose that the system had just presented the following result: 
there are several opportunities to replace conds in your program with the clisp if-then-else construct. 
　　　further suppose that the user then asks for justification of this result. once the user's question has been recognized as being of type justify result  the system will apply the strategy described above to produce the following explanation: 
the system scans your program looking for opportunities to enhance readability. specifically  it is looking for constructs in your code which may be transformed into easy-to-read constructs. the system 
considers if-then-else an easy-to-read construct because it has keywords which identify its abstract components. 
　　　in order to generate the first sentence  the system must perform the first two steps of the strategy shown above. it begins by searching through the development history looking for the  method  that produced  result .  at this point  result  is 
instantiated 	to: 	cond 	to if-then-eise 
transformation-opportunity . referring to figure 1  we see that the  method  which produced  result  is the one which scans over s-expreasions to check if transformations like cond to ifthen-else are applicable and if so  adds to the list of enhancement opportunities. 
　　　next  we search upward through the development history looking for the  goal  which this  method  is a plan for achieving. in performing this search  we skip over those goals which are results of the program writer's implementation concerns. such goals frequently arise when the program writer must reformulate a single goal into several cases which together cover this goal  see section 1 on goal reformulation into cases.  the development history records which goals were generated due to implementation concerns  see figure 1 . this enables the explainer to determine which goals must be skipped when looking for a goal that is appropriate to incorporate into an explanation to an end user. thus  the result of the search upward in the development history is the goal scan for readability enhancing opportunities. 
　　　next  we state this goal by using its description in the domain model  step 1 . as shown in figure 1  a readability enhancing opportunity is a transformation whose left hand side is a construct that appears in the user's code  and which is not an easy-to-read construct  and whose right hand side is an easy-toread construct. thus we would generate the second clause in the explanation above. 
finally  we use the domain model in conjunction with the 
nikl classifier to describe why  result   in this case cond to if-
then-else transformation-opportunity  qualifies as an instance of a result of having achieved the  goal  of scan for readability enhancing opportunities  i.e. why  result  is an instance of a readability enhancement opportunity. first  the explainer has built into it some general world knowledge about goals. this includes the knowledge that  when trying to satisfy a goal of search for objects of type x  finding an object of type x is a  result  of satisfying this goal  search and scan are concepts defined in the domain model with scan being a subconcept of search. therefore  what is left to determine is why this particular cond to if-then-else transformation-opportunity is an object of the desired type  i.e. why  result  is an instance of a readability enhancement opportunity. the nikl classifier is used to provide this information. in this case   result  is indeed a readability enhancement opportunity because its right hand side is an easyto-read construct  and because constraints needed to satisfy ancestor concepts are also present  e.g. the left hand side is a construct which appears in the user's code and is not a good construct.  
　　　using the information obtained from the classifier  we can generate the last sentence in the explanation above. we wish to say why a particular if-then-else is an easy-to-read construct. to do this we look at the concept under which this construct classifies. a particular if-then-else construct will classify under the generic if-then-else definition in the domain model. although it would not be particularly readable  we could therefore generate an explanation which states that if-then-else is an easy-to-read construct because it has a keyword if which identifies its predicate  and do likewise for the keywords then and else. however  since we wish to generate more abstract explanations  we have heuristics in the explainer which note such parallel structure and form generalizations. these heuristics enable the explainer to generate the last sentence in the explanation above. 
1. current status 
     as of this writing  the ees framework is entering the transition from design to implementation  as is the program enhancement advisor. using programs volunteered by research programmers in our laboratory and relying on the expertise of highly skilled builders of lisp-based systems  we have identified approximately a dozen enhancements that the program ought to 
be able to perform. we have set ground rules for representing concepts such as transformations  and the syntactic structure and semantic components of programming constructs. using these rules we have completed the representation of domain and problem-solving knowledge for the cond= =  if-then-else transformation and are in the process of encoding three others. design of a prototype version of the program writer is also almost complete. explanation strategies have been devised for six of our 1 question types  but none are yet implemented. 
1. conclusions 
　　　in the sections above  we have argued for a new paradigm of expert system development  in which deep models separate and explicitly represent the different forms of knowledge that go into the implementation of an expert system  and in which a recorded development history is kept to trace the intertwining of those different forms of knowledge into runnable code. we have considered some particular forms of knowledge and development that seem likely to be important  discussed our design for an ees system that makes use of them  and tried to show how that system might facilitate a broader range of explanations than is possible under current expert system technology. 
　　　in addition to its implications for explanation  we believe this approach also offers other benefits related to development and maintenance. separating the different forms of knowledge reduces the amount that has to be changed when moving to a new domain. the separation  combined with the support of the hierarchical planner  also means that less has to be done when adding new knowledge about a given domain; producing additional code to account for a new concept involves making a few assertions and re-running the program writer rather than engaging in extensive manual recoding. in addition to these maintenance-related benefits  there are also potential gains in the development process  since the discipline of explicitly specifying domain knowledge and principles is likely to make errors and 
inconsistencies more readily apparent. 
