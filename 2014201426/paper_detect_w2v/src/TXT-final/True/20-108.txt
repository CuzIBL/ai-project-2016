 
the mobile robot group at mit has been building robots using the subsumption architecture. this methodology decomposes a control system into a set of loosely coupled task achieving behaviors. in this paper we show how the constraints inherent in this approach naturally lead to a very simple computational design. to demonstrate its effectiveness we have built a new  small  fast robot based on these ideas. in this paper we discuss the performance of this robot and the theory behind its construction. 
1. introduction 
　　the mobile robot group at mit has been investigating brooks's subsumption architecture  brooks 1 . this architecture advocates decomposing control systems into ''taskachieving behaviors  where each behavior is a complete control system going from sensory inputs to motor outputs. several other researchers  kaebling 1  payton 1  arkin 1  minsky 1  have proposed similar systems. the unique aspect of the subsumption architecture is that it allows a control system to evolve by accretion of new  levels . once a behavior is debugged it is never changed; more sophisticated control systems are built around it. this is possible because of a simple  extensible arbitration scheme. 
　　the control system for the new robot described here is cast in the subsumption architecture framework and closely resembles that of our earlier robots  brooks and connell 1 . the difference is that  instead of running on a lisp machine or a special parallel processor  it has been hand compiled down to a couple hundred gates. we were able to accomplish this because  rather than trying to model an ever-changing world and then using this model to plan a course of action  each behavior simply tells what action to take in a specific situation. the subconscious reflex-like nature of this process allows us to eliminate complex intermediate representations and thus vastly simplifies the internal data-paths of a behavior. 
　　furthermore  not only do we use the world as its own model  we also use it as a communication medium between behaviors. indexing off the state of the real world is more reliable than predicting what will happen as the result of a particular action. it also allows us to coordinate many behaviors without incurring the high cost of tight internal 
support for this work was provided by the advanced research projects agency under office of naval research contracts n1-c-1 and n1-k-1. 
1 	robotics 

front ir 	back ir 
figure 1. tom's phytic*! structure. 
coupling. the following sections describe how these factors influenced the design of our newest robot. 
1. hardware 
　　tom  the robot described here  was built around the chassis of a remote controlled toy car. the car can drive forward and backward  and  by selectively braking one of the two front wheels  turn left or right  it cannot turn in place . tom's sensing apparatus consists of four infrared proximity detectors. three are mounted at the front  one pointing straight forward and two toed outwards 1 degrees. the fourth ir is mounted at the rear and looks directly backward  figure 1 . these sensors emit a modulated beam of light and look for a reflection above a certain threshold intensity. each sensor yields only one bit: either an obstacle present or the sensing path is clear. the front and back sensors are set for 1 inches while the sides are set for 1 inches. 
to control the car we use a single pal  programmable 
array logic  chip. internally  the chip is a collection of programmable and gates and fixed or gates. the chip has 1 outputs and 1 inputs  1 of which are feedbacks from the outputs. logically  an output is an or of up to 1 ands where each and can use any collection of inputs and their inverses. 
1. basic coordination 
　　in all our robots  the lowest level of competence consists of two behaviors. the first behavior treats obstacles as repulsive charges. it sums all the forces due to obstacles and  when they exceed a threshold  causes the robot to run away 
　　
on tom  he is incapable of either of these behaviors. instead  
　　
figure 1. the complete module diagram. note that as each behavior is added  the new control system retains all the structure of the older control systems. 
along the resultant vector. this behavior has no notion of what an obstacle is  it simply knows how to drive the car given certain sensor patterns. 
　　a second behavior pays special attention to the front depth-finders to make sure the robot is not chased into a wall: when something gets too close  this behavior halts all forward motion. note that we didn't try to build a unitary collison avoidance mechanism  instead we built a fairly reliable behavior and then patched it up in certain cases. note  also  that there is no communication between the two behaviors: the collide behavior only knows the runaway behavior is failing when it detects a certain configuration in the world. 
1. exploring the environment 
　　the simplest way to make tom explore is to give him an urge to go forward. we do this by adding another forwardpointing vector to the result of the potential field calculation. by adding a constant force we make the robot go straight forward in an open space but veer away when it detects an obstacle. like simon's ant  we trust the complexity of the environment to yield an interesting path. 
　　figure 1 shows the complete control system for tom. here  the exploratory behavior is wired up somewhat differently than in the control systems we have used in the past. with previous robots we broke the level zero runaway behavior into a potential summing module and a separate thresholding module. this allowed us to use the result of the force computation at higher levels. unfortunately  with one bit data paths  tom boils the potential field calculation down to plus  minus  and zero. since we only know the sign  not the magnitude  the wander module must recompute the force from the irs rather than just adding its vector to the previous result. 
1. the social robot 
　　tom's most sophisticated behavior is seeking a specific target. in the past we have had our robots find such things as corridors and doorways. however  due to the crude sensors we have built a second robot  jerry  indentical to tom. to encourage interaction  tom's seeking behavior is to find and follow jerry. 
　　there were two observations that guided our choice of a following algorithm. the first was that the target being pursued moved very rapidly. thus  if the sensors don't see the target  the pursuer should continue to go straight forward in an attempt to catch up. the other observation was that the target usually moved forward only  it seldom reversed. this means the pursuer should never back up - given the speed of the target  by the time the it actually started to go forward again the target would be hopelessly far ahead. 
　　the algorithm tom uses is shown in figure 1. we keep the strong forward vector from level one  represented by the large arrow in the middle  but we now make the side irs attractive normal to the direction of travel  they remain repulsive in the tangential direction . this is sufficient to cause the car to turn toward obstacles rather than away from them. it does this  however  without having any idea that there is a  thing  that it is chasing. note  also  that because the collide behavior is still operative  the car will stop before actually hitting the object it is following. 
　　an important part of multi-level systems like this one is determining when to switch from one behavior to another. in this case  the transition from the level one exploratory behavior to this level two seeking behavior is keyed to the activity of the side two irs. when the robot is in a complex portion of the environment  constantly veering around obstacles  the side irs are active a large portion of the time. conversely  when these sensors become inactive it usually means the robot is in a large open space. in such a case the vehicle switches into follow mode  actively seeking obstacles. note  however  that if the object being followed ever stops  the side irs come on and stay on causing the robot to eventually revert to the wander mode. 
1. implementation 
　　the interesting part is how a pal can be made to perform complex calculations such as the polar coordinate vector summation required by the potential field algorithm. let /;  lb  it  and ir be the forward  backward  left  and right proximity sensors respectively. these variables take a value of one or zero depending on whether the associated sensor 
	connell 	1 
　　

s an obstacle or not. we can now write an expression for 
the forward-backward force  ft: 

　　to put this on the pal we break it down into cases  much like is done in qualitive process theory  forbus 1 . 
the robot should go forward when  backwards when  and stay still when f1 = 1. we can see that the only case in which ft is postive is when the back ir senses an obstacle and  at most  one of the side irs is active. we can encode this as a boolean expression for when to go forward. using similar arguments for the other two cases we come up with the following expressions: 

g1 is true when the robot should be going forward and g* is true when the robot should retreat. notice that these expressions are in exactly the right form for the pal: an or of an ds. 
     the runaway behavior described by these expressions works fairly well except that the robot can't stop quickly. one way to decrease the stopping distance is to run the motor in reverse for a little while. as can be seen in figure 1  this active braking scheme is built on top of the existing control system. the go module determines when the robot should be moving and reports this on its output  a: 

when the reverse module sees the a line go low it knows that the robot is supposed to stop. it uses the output of the last module to determine which direction to run the motor. 
df means the car was advancing and so the motor should be run in reverse  while d* means the car was going backward so the motor should be run forward to slow it down. the command from the reverse module suppresses the output of the forward module. the suppresion is implemented by using the allowed motion signal  a  to select which module gets control: 

　　we now have a control system that causes the robot to run away from attackers. unfortunately  it occasionally 
1 	robotics 
causes collisions which could have been avoided. consider the case where all the proximity sensors detect obstacles. according to the expression for gb  the robot should go backwards even though it knows there is something in the way. we remedy this by adding a special collision avoidance behavior. as shown in figure 1  we do this by adding a new module  collide  which inhibits the output of the go module. the collide module looks at the commanded direction and the central irs to decide whether it is safe for the robot to move. the actual inhibition is performed by an ding the allowed motion signal  at with the invert of the halt case. 

　　the next two layers of the control system are implemented in a similar fashion on the same pal. 
1. conclusions 
     in this paper we have described tom  a working robot based on the subsumption architecture  and shown how it operates with a minimal amount of computing power. the simplicity of this design has allowed us to create several identical vehicles and let us start to explore the ways in which communities of creatures interact. 
acknowledgements 
　　thanks to rod brooks and the people in the mobile robot group  especially wendy wang and peter ning. 
