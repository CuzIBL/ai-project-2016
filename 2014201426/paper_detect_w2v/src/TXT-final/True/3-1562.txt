
in this paper we present an approach to representing and managing temporally-flexible behaviors in the situation calculus based on a model of time and concurrent situations. we define a new hybrid framework combining temporal constraint reasoning and reasoning about actions. we show that the constraint based interval planning approach can be imported into the situation calculus by defining a temporal and concurrent extension of the basic action theory. finally  we provide a version of the golog interpreter suitable for managing flexible plans on multiple timelines.
1 introduction
in real-world domains robots have to perform multiple tasks either simultaneously or in rapid alternation  employing diverse sensing and actuating tools  like motion  navigation  visual exploration  mapping  and several modes of perception. to ensure a suitable multiple-task performance  some approaches  e.g.  1; 1   have recommended that executive control processes supervise the selection  initiation  execution  and termination of actions. from these ideas  a new paradigm has been proposed  called the constraint based interval planning  cbi   which essentially amalgamates planning  scheduling and resources optimization for reasoning about all the competing activities involved in a flexible concurrent plan  see  1; 1; 1  . the cbi approach  and similar approaches emerged from the planning community  have shown a strong practical impact when it comes to real world applications  see e.g. rax   ixtet   inova   and rmpl  . however  from the standpoint of cognitive robotics it is important to ensure both optimal performance  in practical applications  and to provide a logical framework for ensuring coherence of actions preconditions and effects. the system coherence emerges as a core issue also when control processes negotiate resources allocation with individual perceptual-motor and cognitive processes; indeed  the executive has to establish priorities among individual processes to allot resources for multiple-task performance  see the discussion in  1; 1; 1  . therefore  different  concurrent  and interleaving behaviors  subject to switching-time criteria and current situation needs  lead to a new integration paradigm. in this paper we suggest that the reactive aspects that have to cope with flexible behaviors and the cognitive capabilities enabling reasoning about these processes  can be combined in the temporal flexible situation calculus. we present a new approach to flexible behaviors  that exploits the full expressiveness of the situation calculus  sc   1; 1   where computational concerns related to time can be monitored by a temporal network  obtained via a transformation of added constraints. to embed many concepts elaborated in the cbi framework we extend the sc with concurrency and time  extensions of sc with time was already explored in  1; 1; 1    deploying allen's interval relations   and further constraining the language to represent concurrent timelines. in this framework we can conjugate the advantages of the sc with the expressive power of the cbi paradigm. our aim here is twofold: on the one hand  it is made possible to introduce a separated timeline for each component of the dynamic system  i.e. each entity  which is part of an autonomous system  such as a robot   so that concurrency and flexibility can be clearly addressed; on the other hand the causal relationships among processes can be dealt with in the sc language  which provides a clear framework for preconditions and postconditions of actions and a simple solution to the frame problem. we show that the cbi perspective  with all its arsenal of specifications in terms of flexible time  alternation constraints  resources optimization  failure recovering  and tasks scheduling  can be imported into the sc   1; 1    defining a temporal and concurrent extension of the basic action theory  related approaches are  1; 1; 1; 1; 1; 1  . finally  we provide a version of the golog language and interpreter for manipulating flexible plans on multiple timelines.
1 preliminaries
1 situation calculus and golog
the situation calculus  1; 1  is a sorted first order language for representing dynamic domains by means of actions  situations  and fluents. actions and situations are first order terms  and situation-terms stand for history of actions  compound with the binary symbol do: do a s  is the situation obtained by executing the action a after the sequence s. the dynamic domain is described by a basic action theory bat =  ¦²  ds1  dssa  duna  dap . we refer the reader to  for a complete introduction to the sc. temporal concurrent situation calculus  tcsc  has been earlier introduced in  1; 1; 1 ; actions are instantaneous  and their time is selected by the function time . . durative actions are considered as processes  1; 1   represented by fluents  and durationless actions are to start and terminate these processes. for example  going hill s  is started by the action startgo hill t  and it is ended by endgo hill t1 .
golog. golog is a situation calculus-based programming language for denoting complex actions composed of the primitive  simple or concurrent  actions defined in the bat. golog programs are defined by means of standard  and not so-standard  algol-like control constructs: i. action sequence: p1;p1  ii. test: ¦Õ   iii. nondeterministic action choice p1|p1  iv. conditionals  while loops  and procedure calls. an example of a golog program is:
while  at hill 1  do
if    x going x  do ¦Ð t  t   1  ;startgo hill t  
¡¡the semantics of a golog program ¦Ä is a sc formula do ¦Ä s s1  meaning that s1 is a possible situation reached by ¦Ä once executed from s. for example  do a;p s s1  =. do p do a s  s1  ¡Ä poss a s  defines the execution of an action a followed by the program p. for more details on the sc and golog we refer the reader to .
1 constraint based interval paradigm
the constraint based interval framework  cbi   1; 1   is a well known framework for temporal planning systems combining temporal reasoning and scheduling  including  e.g.  rax   ixtet   and inova. the cbi paradigm accounts for concurrency and time  and action instances and states are described in terms of temporal intervals linked by constraints. we refer to the timeline-based version of the cbi  where a domain behavior is seen as the continuous interaction of different components  and each component is represented by state variables; a single state variable is a relevant feature of the components and represents a concurrent thread. both states and activities are uniformly treated as temporal intervals. the history of states for a state variable over a period of time is called a timeline. figure 1 illustrates two timelines  state variables  repr. the engine and the navigation processes of a mobile robot: initially  the robot is at p1  and stop; when it starts go p1 p1  the engine is running; the engine is stop again once the rover arrives at p1 . some temporal constraints among the activities are: at x  holds only if stop holds  go x y  is followed by at y .
domain constraints. a cbi model  mcbi= x j r  is defined by: i. a set x={x1 ... xn} of state variables  one for each component  e.g. xloc and xeng in fig. 1 ; ii. a
set j = {j1 ... jn} s.t. for each xi the set ji collects the associated temporal fluents pi j ~y   e.g. at x  and go x y  for location state variable in fig. 1; iii. a set of temporal constraints r={ri j}  usually called compatibilities: for each temporal fluent property pi j there is a compatibility relation ri j representing all its possible legal relations with the other temporal fluents  i.e. which temporal property must proceed  follow  be co-temporal  etc. to pi j in a legal plan. the latter are specified in terms of metric version of temporal relations a la allen . e.g. the arrows in fig. 1 illustrate the compatibility associated to the fluent at: at x  meets go x y   and at x  during stop.

figure 1: timelines and constraints
planning problem in cbi. given the cbi model mcbi  a planning problem is defined by pcbi =  mcbi pc   where pc is a candidate plan  representing an incomplete instance of a plan. the candidate plan defines both the initial situation and the goals. in particular  pc consists of : i. a planning horizon h; ii. a set of temporal properties to be satisfied for each state variable xi ¡Ê x  e.g. at p1  ends before 1 and after 1 in the timeline of figure 1 ; iii. the set of precedence constraints among fluents pk 1   pk 1  which are to hold on a timeline  e.g. at p1    at p1 ; iv. the set of constraints r={ri j} associated with the temporal properties pi j mentioned in the timelines. a fluent pi j ~x  mentioned in a candidate plan is fully supported  if all its associated constraints ri j are satisfied. e.g. in figure 1 at p1  and at p1  are fully supported. a candidate plan is said to be a complete plan if: i. each temporal property on each timeline is fully supported; ii. all timelines fully cover the planning horizon. given the planning problem  mcbi pc   the planning task is to provide a sufficient plan   i.e. a complete plan with the maximum flexibility: the planner is to minimally ground the  temporal  variables to allow for on-line binding of the values.
1 temporal flexible situation calculus
in this section we present the temporal flexible situation calculus framework  tfsc   which integrates the cbi paradigm  introduced above  into the language of sc.
actions. we define a partition {¦Áv;v ¡Ê c} of the set of actions according to the different components c the system has to care of. for example  the component pan-tilt-unit manages actions like start-scan spts .   or end-scan epts . . to induce the partition we introduce a type operator ¦Í  and extend the sc foundational axioms with the following definitions. let be a set specifying the types of actions  we assume this set finite. for each name of action the following holds:
hi a ¡Ähj a1 ¡ú  a = a1  for i1=j  and ¦Í a ~x  =¦Í a1 ~y  
  together with the unique
name for actions  here the indices stay only for different components names  a denotes an action variable  while a denotes the name of an action function.
situations. typization of actions induces also a partition on the set of situations whence on the set of histories. histories become streams of situations over timelines. typization is inherited by situations as follows:
 a.¦Í a  = ¦Í do a s1  . a s.¦Í a  = ¦Í s  ¡Ô
 a1.s = do a1 s1 ¡ú¦Í a  = ¦Í a1  ¡Ä ¦Í a1  = ¦Í s1 . 1 
¡¡for each component v ¡Ê c  a timeline is specified by a history of actions concerning v. the evolution of the set of timelines is a set of situations sc = {sv|v ¡Ê c}  called situation class  spanning different types. in other words   s.s ¡Ê sc abbreviates: 
. where ¦Í si  is the
type of situation si corresponding to some component i ¡Ê c  n=|c|. the sc class is equipped with the following ¡Üc relation:
¡¡¡¡¡¡¡¡sc1 ¡Üc sc ¡Ô  s1 s.s ¡Ê sc ¡Ä s1 ¡Ê sc1¡ús1 ¡Ü s.  1  do av sc  denotes the sequence resulting from adding the
action av to a type-compatible situation mentioned in sc.
time. time is part of the sorted domain of tfsc  as noted in section 1; we extend the time selection function from actions to situations  see  for a different notation   and situation classes as follows:
time s1  = t1. time do a s   = time a . time s  ¡Ü time s1  ¡Ô  a a1 s1.s = do a s1 ¡Ä	 1  s1 = do a1 s1  ¡Ä time a  ¡Ü time a1 .
 the time of a situation class sc  depends on the time of the situations in sc  so time sc  = t abbreviates:
 s s1.s ¡Ê sc ¡Ä time s  = t ¡Ä s1 ¡Ê sc ¡Ä time s1  = t1¡út ¡Ý t1.
 1 
consistency of the extension. the above axioms concerning types  time and situation classes  are added to the foundational axioms in ¦² and are conservative  i.e. obtained by extending the language   therefore the extended set  which we still denote with ¦²  must be consistent.
processes. processes span the subtree of situations  over a single interval specified by a start and end action. they are implicitly typed by the actions process: for each process there are two actions  starting and ending the process  abbreviated by sp  meaning starts process p and ep  meaning ends process p. a process is denoted by a fluent p ~x t  s    here t  is its start time . successor state axioms  ssp  for processes extend the set of ssa for fluents and are defined as follows:
p ~x t  do a s   ¡Ô a = sp ~x t  ¡Å
¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡p ~x t  s  ¡Ä  t.a 1= ep ~x t .	 1  for example  moving towards ¦È  can be defined as:
move ¦È t  do a s   ¡Ô a=smove ¦È t  ¡Å move ¦È t  s  ¡Ä  t1.a 1= emove ¦È t1 .
 action preconditions axioms define the conditions for the start and end actions to be executed. let p be a process  we say that it is linear if it does not mention any other process in the right-hand side of the definition. the set dssp of successor state axioms for processes is linear if all processes mentioned in it are linear. let dssp be a set of linear successor state axioms for processes  let the bat be d ¡È dssp = ¦² ¡È ds1 ¡È duna ¡È dss ¡È dap ¡È dssp then:
lemma 1 d ¡È dssp is consistent iff ds1 is.
proof  sketch . the proof relies on the relative consistency of the sc. furthermore  linearity of dssp ensures that there are no loops w.r.t. time  hence for each start and end action  as defined in the processes  it is not possible to introduce dependencies that could lead  for instance  to sp ~x t    sq ~y t1  and sp ~x t    sq ~y t1 .
intervals. intervals mention temporal variables  which are always free  and get assigned only according to a specified set of behaviors  in so being very well suited for representing flexible behaviors. in this paragraph we show how embedding intervals in the sc leads to the construction of a temporal network. the following formula ¦·  specifies the conditions for a process pi to hold on its induced timeline  from to t+i with arg. x:
		 1 
let p m o d s f e abbreviate the usual precedes  meets  overlaps  during  starts  finishes  equals  as defined in the temporal intervals literature  started in   with op ranging over all relations  and let ¦Ãop denote:
¦Ãp =  t+i   t j  ; ¦Ãm =  t+i = tj   ; ¦Ãs =  t i = t j  ; ¦Ãf =  t+i = t+j  ; ¦Ãe =  t+i = tj+ ¡Ä t i = t j  ; ¦Ão =  t i   t j ¡Ä t j   t+i ¡Ä ti+   tj+  ; ¦Ãd =  t i   t j ¡Ä t+j ¡Ý t+i ¡Å t i ¡Ü tj  ¡Ä t+j   t+i  .
 we represent the interval relations between processes  given in situation-suppressed form  i.e not mentioning situations   and taking the  end-time  t+ as argument  according to the following macro-definition  where the free variables mentioned in ¦·i  see  1  above  are just hidden:
	pi x t i  t+i   op pj x t j  t+j   = ¦·  i¡ú ¦·j ¡Ä ¦Ãop .	 1 
note that the metrical version  like in   including durative relations can be analogously defined. letting each operator in the macro being not commutative  inverse can be defined as
pi op 1 pj = pj op p1.
we assume that the domain theory dt is associated with temporal relations  as those given in  1   specifying the temporal interactions between processes as constraint patterns. for example  wanting to say that going has always to be preceded by beingat we would associate to dt the set {going  t g  t+g    p beingat  t b  t+b   . we call this set the temporal compatibilities abbreviated by tc.
   we denote i ¦Ó sc  the set of the  1  interval relations associated with the situation class sc  where ¦Ó is the set of time variables  varying over the intervals  t+ t    related to the set of timelines sc. the i ¦Ó sc  is obtained by abducing the time constraints on ¦Ó  according to a construction illustrated in the paragraphs below. for instance  for a suitable sc and we can get the set:
i ¦Ó sc =	{p1 t 1  t+1   s p1 t 1  t1+   p1 t1   t+1   o p1 t 1  t+1   
p1 t 1  t+1   d p1 t 1  t+1   p1 t1  t1+  d p1 t 1  t+1   
¡¡¡¡¡¡p1 t 1  t+1   s p1 t 1  t+1   p1 t 1  t1+   d p1 t1   t+1  }  whose constraints are depicted in the network of fig. 1.
temporal constraint network. the satisfiability problem we are concerned with is the following. let dt = d¡Èdssp¡È i ¦Ó sc  be a basic theory of actions  extended with time specifications  see eq.  1  above   successor state axioms for processes  time interval constraints  in which time variables are free  and with an associated set of compatibilities tc. we seek an assignment set for time variables  which is a feasible solution for the constraints  and s.t. a substitution of the

figure 1: a tcn representing a set of interval constraints on processes p1 p1 p1 p1
free variables for this set induces an interpretation  which is a model of dt ¡È i ¦Ó sc . to find such an assignment we appeal to the concept of general temporal constraint networks  tcn  introduced in meiri  following the one developed for discrete constraint networks . a tcn involves variables denoting both intervals and points  together with unary and binary constraints. a tcn is associated with a direct constraint graph where each node is labeled by a temporal variable and labeled-directed edges represent the binary relations between them  e.g. p e etc. . according to the underlying temporal algebra  tcns express different forms of reasoning  allen's interval algebra   the point algebra   metric point algebra   and so on  see in particular . let  be a set of time
variables  denoting intervals  i.e. each variable xi denotes an interval    and let r be a set of binary relations; the assignment set v = { s1 e1  ...  sn en  : si ei ¡Ê r si   ei} is called a solution set for r  if {x1 =  s1 e1  ... xn =  sn en } satisfies all the constraints defining r. the network is consistent if at least one solution set exists. in the sequel we shall identify a tcn with its labeled direct graph and denote with v a solution set. we also say that v satisfies the constraints.
mapping sc to tcn. let h : i ¦Ó sc  ¡ú1 tcn  h i ¦Ó sc   is a temporal network net  with cardinality m  specified by the nodes labeled by the defined processes {pi pj|pioppj}  mentioned in i ¦Ó sc .
¡¡by the above definitions the network net is consistent if there exists an assignment v to the temporal variables ¦Ó  which is a feasible solution for i ¦Ó sc . for example the set v ={ 1   1   1   1 } is a solution set for the variables  of the network depicted in figure 1  given the relations {m p d s f}. note that  in the macro definition  1   there are two parts  the left-hand component is the definiendum op   which is mapped into a temporal network  while the right-hand component is the definiens ¦·i¡ú ¦·j¡Ä¦Ãop  ¦Ó   which is interpreted into a structure of the sc  where the assignments for the free temporal variables ¦Ó are obtained by the tcn. a semantic correspondence  between the network and the formulae of sc  can be established as follows. let m=hd ii be a structure of sc  where d is a sorted domain and i an interpretation  we extend m with the above defined mapping h  i.e. mh=hd i hi. then mh is a model for d¡Èi ¦Ó sc   iff there is a consistent temporal network h i ¦Ó sc    under some assignment v to the free time-variables  satisfying i ¦Ó sc . given the above definitions we can state the following:
lemma 1 let dt be a consistent action theory.	dt ¡È
i ¦Ó sc  is consistent iff there exists a consistent temporal constraint network h i ¦Ó sc    under the assignment v   such that mh v |= vd ¡Ä ¦· ¦Ó .
proof sketch . let h i ¦Ó sc   be a consistent temporal network  under the assignment v . consider the formula ¦· ¦Ó  =  vi j¡Üm ¦·i¡ú ¦·j¡Ä¦Ãopij   with ¦Ó the set of free time-variables in ¦·  and we let m be a model for dt. m can be extended to a model for all the ¦Ãopij according to v   as follows.
for each process pi build a chain of situations of the kind
  with
¦Ò a sequence such that epi is not mentioned in ¦Ò  and the free-temporal variables are from ¦Ó according to the pi timeline in sc. extend the structure m to one for dt ¡È si ¦£i by choosing from v a suitable assignment to the free variables ¦Ó  appearing in each ¦£i  and according to the constraints in the ¦Ãopij  corresponding to those in i ¦Ó sc   and such that each sequence is satisfied. this is always possible  because each process is made true of a situation by a start action  and false by an end action  by the sequence construction  on a timeline. then v is an assignment to ¦Ó s.t.  mh v   is a model for dt ¡È si ¦£i ¦Ó . finally it is enough to show that any model for dt ¡È si ¦£i ¦Ó   is a model for ¦· ¦Ó . 1
¡¡by lemma 1 dt ¡È i ¦Ó sc  is consistent iff ds1 ¡È i ¦Ó sc  is consistent. logical implication can be now defined as follows. let mh = hd i hi  and ¦Â ¦Ó  be a formula with all its free temporal variables among ¦Ó:
dt ¡È i ¦Ó sc  |= ¦Â ¦Ó  iff for any h  for any v 	 1  mh v |= dt ¡È i ¦Ó sc  implies mh v |= ¦Â ¦Ó .
tcn construction. the tcn construction involves the following inference mechanisms: i. abduce i ¦Ó sc  to obtain the temporal network topology h i ¦Ó sc  ; ii. implement the temporal constraints into situations  according to the network. we show the inference process through an example. let tc = {p1 m p1}  be the compatibilities specified in the domain theory. let 
  then the abduced
constraints  according to tc  sc and ¦Ó  are:

 1 
from the above constraints a three nodes network h i ¦Ó sc   would be constructed. the time range of the solutions to the network - given the free temporal variables and the situation class sc - is a flexible situation class  which is a triple of the kind hsc ¦Ó ii  where i ¦Ó  is the constraint over the freevariables  e.g..
progression. we want to determine if  according to the timing and advancements of the current situation class  we can forget about past scheduled processes and think of future resources allocation. this is the well known progression problem  in the sc. we face here a simplified version of the progression problem  and with regressable formulas  which is all we need. let us state the problem as follows. given a sentence    one needs first to determine the set of situations in sc to which it can be progressed  given the timelines  and a candidate interval t =  t  t+ . to this end one has to order the situation terms in   according to the relation ¡Üsc introduced in  1   and get the smallest situations set  w.r.t. ¡Üsc  mentioning t; let it be min. we now consider the domain theory  which is equal to dt but with ds1 replaced by a set wmin = { |dt |=  }  where   mentions only ground situations ¦Ò  with {¦Òi}=scmin  but no free variables of sort time. let ¦µ t1 ...tn  be a sc formula mentioning situations {¦Òi} ¡Ýsc min  which are ground but for possible free variable of sort time all among t1 ... tn. then
lemma 1 .
theorem 1 dt ¡È i ¦Ó sc  |= ¦µ t1 ... tn  iff wmin ¡È i ¦Ó sc  |= ¦µ t1 ... tn 
proof.  sketch  one direction follows by cut. for the other direction  suppose dt ¡È i ¦Ó sc  |= ¦µ t1 ... tn   let us regress ¦µ t1 ... tn  along the different timelines  this can be done by separating ¦µ into a dnf  and considering each conjunct separately  we regress it with respect to min  and let g be the regressed formula - note that no change is needed in regression to account for regressed sentences as time variables will be kept as they are  without turning to quantified variables through successor state axioms  as they are universally quantified in linear dssp . then by definition of wmin  g ¡Ê wmin hence  by the previous lemma  the claim follows.
1 flexible high level programming in golog
golog syntax.	given the extended action theory presented above  the following constructs inductively build golog programs:
1. primitive action: ¦Á.
1. nondeterministic choice: ¦Á|¦Â. do ¦Á or ¦Â.
1. test action: ¦Õ . test if ¦Õ is true in the current sit. class.
1. nondet. arg. choice: choose ~x for prog ~x .
1. action sequence: p1;p1. do p1 followed by p1.
1. partial order act. choice: p1   p1. do p1 before p1.
1. parallel execution: p1kp1. do p1 concurrently with p1.
1. conditionals: if ¦Õ then p1 else p1.
1. while loops: while ¦Õ do p1.
1. procedures  including recursion.
golog semantics. the macro do p sc sc1 h  gives the semantics for the above constructs; where p is a program  sc and sc1 are situation classes  and h specifies the finite horizon.
  null program:
do nil sc sc1 h  =  time sc  ¡Ü h ¡Ä  s. s ¡Ê sc ¡Ô s ¡Ê sc1 
  primitive first program action with horizon:
do ai;prog sc sc1 h  =   si.si ¡Ê sc ¡Ä poss ai si ¡Ä time si  ¡Ü h ¡Ä  time ai  ¡Ü h ¡Ä do prog do ai sc  sc1 h ¡Å time ai    h ¡Ä do prog sc sc1 h  
 here  if the first program action is applicable to si ¡Ê sc  and ai can be scheduled after the horizon then it is neglected  i.e. each action  which can be started after the horizon can be postponed .
  partial order action choice:
do prog1   prog1 sc sc1 h  =  do prog1 : prog1 sc sc1 h ¡Å
 a.select a sc  ¡Ä do prog1   a   prog1 sc sc1 h 
here  either the second program can be directly executed  or it is possible to insert a primitive action a  selected by a suitable fluent predicate select a s  representing the selection criterion  set to true if no selection holds .
  parallel execution:

  test action:
do ¦Õ ;prog sc sc1 h  =  ¦Õ sc  ¡Ä do prog sc sc1 h 
here ¦Õ sc  stands for generalization of the standard ¦Õ s  in the sc extended to situation classes  e.g. p1 sc  ¡Ä p1 sc  is for
p1 s1 ¡Äp1 s1  with s1 s1 ¡Ê sc  i.e. each fluent is evaluated w.r.t. its specific timeline.
  the semantics of nondet. action choice  nondet. argument selection  conditionals  while loops  and procedures is defined in the usual way.
flexible temporal behaviors in golog. the cbi planning problem  mcbi pc  introduced in section 1 can be easily coded and solved in the tfsc framework. given a dt representing the timelines and processes in mcbi  a candidate plan pc can be encoded by a golog program progc. this is possible once we introduce  for each interval constraint for pi j ~r  in pc  a golog procedure of the kind:
proc 
 where ¦×ij is the macro  1  associated with the process  i.e. i-th process in the j-th timeline   and ¦Ã any temporal constraint. for example  go d e  ends in  1  can be represented as proc.
 given the ¦Ði j procedures  a partial specification of a single timeline tj can be easily defined using the   operator: proc plan tj ¦Ð1 j   ¦Ð1 j   ¦Ð1 j   ...   ¦Ðk j  
given a set of timelines {ti}  a candidate plan pc can be represented as a parallel execution of the plan ti: proc progc  plan t1 : nil k ... k plan tk : nil  .
since a cbi complete plan p is associated with a fully supported set of timelines {t i} and a set of constraints i ¦Ó   see section 1   we can introduce a mapping g transforming a cbi plan p into a flexible situation hsc ¦Ó ii. the following holds.
proposition 1 given a cbi planning problem  mcbi pc   where pc is a candidate plan   for any complete plan p of  mcbi pc   maximally flexible in the time variables ¦Ó  there exists a dt  a golog program progc  where
       dt ¡È i ¦Ó sc  |= do progc ini sc ¦Ó  h . with hsc ¦Ó ii a flexible situation  and such that: g p  = hsc ¦Ó ii the proof is omitted.
example. we assume an autonomous rover  which has to explore the environment and perform observations. while the robot is moving the pant-tilt unit must be pointing ahead ptidle. to point to a location x the rover must be stopped there  at x   while the pan-tilt scans in direction z: ptscan x z . hence  we consider two components: pant-tilt  navigation. each component has a set of processes: jpt={ptidle  ptscan z x }; jnav={at x   go x y }. each of these is to be encoded in the dt as in  1   e.g. ptscan t z x do a s   ¡Ô a = spts z x t  ¡Åptscan t z x s  ¡Ä   t1.a = epts z x t1 . the temporal compatibilities tc among the activities are defined by a set of temporal constraints patterns  defined by macros  1   e.g.:
go x y t1 t1  m at y t1 t1 ; at x t1 t1  m go x y t1 t1 ; go x y t1 t1  d ptscan z x t1 t1 ; ptscan z x t1 t1  d at x t1 t1 .
 consider a partial specification for the rover behavior: from time 1 to 1 it must remain at p1   and at time 1 the pant-tilt is ptidle; the rover mission is to observe p1  in direction ¦È before 1 and after 1  and be back at p1 before 1. this candidate plan  can be encoded in the following golog program:
proc mission 
¦×atnav p1 1  
	pt	pt
.
 given the horizon h = 1  and an initial situation class ini  a possible complete plan is a flexible situation hsc ¦Ó ii  with sc ¦Ó ={¦Ònav ¦Ó1  ¦Òpt ¦Ó1 }  s.t. dt ¡È i ¦Ó sc  |= do mission ini sc ¦Ó  1   e.g.
¦Ònav=do  sat p1  eat p1  sgo p1 t1  ego p1 t1   sat p1 t1  eat p1 t1  sgo p1 t1  ego p1 t1   s1 ;
¦Òpt=do  spti 1  epti t1  spts t1  epts t1  spti t1  epti t1  s s1  
 and i ¦Ó  is the minimal set of constraints solving the h i sc ¦Ó   temporal network  i.e. 
 }.
implementation. we provided a constraint logic programming  clp   implementation of the golog interpreter. since the golog interpreter is to generate flexible temporal plans  it must be endowed with a constraint problem solver. analogous to  we rely on a logic programming language with a built-in solver for linear constraints over the reals  clp r  . we appeal to the ecrc common logic programming system eclipse 1. currently  we are deploying the golog interpreter as the control engine of a monitoring systems for robotics applications.
