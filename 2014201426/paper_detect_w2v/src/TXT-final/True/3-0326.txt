
data complexity of reasoning in description logics  dls  estimates the performance of reasoning algorithms measured in the size of the abox only. we show that  even for the very expressive dl shiq  satisfiability checking is data complete for np. for applications with large aboxes  this can be a more accurate estimate than the usually considered combined complexity  which is exptimecomplete. furthermore  we identify an expressive fragment  horn-shiq  which is data complete for p  thus being very appealing for practical usage.
1 introdcution
description logics  dls   baader et al.  1  are state-ofthe-art knowledge representation formalisms with applications in many areas of computer science. very expressive dls such as shiq are interesting mainly due to their high expressivity combined with the clearly defined model-theoretic semantics and known formal properties  such as the computational complexity of reasoning. in particular  the combined complexity of checking satisfiability of a shiq knowledge base kb is exptime-complete in |kb|  schild  1; tobies  1 .
¡¡exptime-completeness is a rather discouraging result since |kb| can be large in practice. however  similar to a database  kb consists of a schema part t   called the tbox  and a data or fact part a  called the abox. for applications with a fixed schema but varying data part  data complexity  measured in the size of a only  provides a more precise performance estimate.
¡¡here  we assume that the abox of kb is extensionally reduced  i.e. it involves only roles and  possibly negated  atomic concepts. thus  the terminological knowledge is strictly separated from assertional knowledge  so |a| is the measure of  raw  data. for such a kb  we show that checking kb satisfiability is np-complete in |a|  and that instance checking is co-np-complete in |a|. since this might still lead to intractability  we identify horn-shiq  a fragment of shiq analogous to the horn fragment of first-order logic. namely  horn-shiq provides existential and universal quantifiers  but does not provide means to express disjunctive information. we show that  for horn-shiq  the basic reasoning problems are p-complete in |a|. to develop an intuition and to provide a more detailed account of these results  we compare them with similar results for  variants of  datalog  dantsin et al.  1 .
¡¡our results are important since they provide a formal justification for hoping to provide tractable algorithms for very expressive description logics. furthermore  horn-shiq subsumes dl-lite  calvanese et al.  1   a logic aiming to capture most constructs of er and uml formalisms  while providing polynomial algorithms for satisfiability checking and conjunctive query answering  assuming an unbounded knowledge base  but a bound on the query size . hornshiq additionally allows qualified existential quantification  conditional functionality and role inclusions  while allowing for a reasoning algorithm that runs in time polynomial in the size of data.
¡¡in  schaerf  1   the complexity of concept subsumption was contrasted with combined and data complexity of instance checking for various fragments of alc. this work provides a lower bound for the data complexity of reasoning in shiq.
1 preliminaries
description logics. given a set of role names nr  a shiq role is either some r ¡Ê nr or an inverse role r  for r ¡Ê nr. a shiq rbox r is a finite set of role inclusion axioms r   s and transitivity axioms trans r   for r and s shiq roles. for r ¡Ê nr  we set inv r  = r  and inv r   = r  and assume that r   s ¡Ê r  trans r  ¡Ê r  implies inv r    inv s  ¡Ê r  trans inv r   ¡Ê r . a role r is said to be simple if trans s  ¡Ê r/   for each s    r  where    is the reflexive-transitive closure of  .
¡¡given a set of concept names nc  the set of shiq concepts is the minimal set such that each a ¡Ê nc is a shiq concept and  for c and d shiq concepts  r a role  s a simple role and n a positive integer  then  c  c   d   r.c and ¡Ý ns.c are also shiq concepts. we use    ¡Í  c1   c1   r.c  and ¡Ü ns.c as abbreviations for a    a  a    a     c1    c1     r. c  and   ¡Ý  n + 1 s.c   respectively. concepts that are not concept names are called complex. a literal concept is a possibly negated concept name.
¡¡a tbox t is a finite set of concept inclusion axioms of the form c   d. an abox a is a finite set of axioms c a   r a b   and  in equalities a ¡Ö b and a 1¡Ö b. a knowledge table 1: semantics of shiq by mapping to fol
translating concepts to fol
¦Ðy a x  = a x 
¦Ðy c   d x  = ¦Ðy c x  ¡Ä ¦Ðy d x  ¦Ðy  c x  =  ¦Ðy c x 
¦Ðy  r.c x  =  y : r x y  ¡ú ¦Ðx c y 
¦Ðy ¡Ý ns.c x  =
	 y1 ... yn :	s x yi  ¡Ä	¦Ðx c yi  ¡Ä	yi 1¡Ö yj
translating axioms to fol
¦Ð trans r   =  x y z : r x y  ¡Ä r y z  ¡ú r x z 
¦Ð c a   = ¦Ðy c a 
¦Ð r a b   = r a b 
¦Ð a   b  = a   b for   ¡Ê {¡Ö 1¡Ö}
     translating kb to fol ¦Ð r  =  x y : r x y    r  y x 
	¦Ð kb  =	r¡Ênr ¦Ð r  ¡Ä	¦Á¡Êt¡Èr¡Èa ¦Ð ¦Á 
x is a meta variable and is substituted by the actual variable. ¦Ðx is obtained from ¦Ðy by simultaneously substituting in the definition x i  for all y i   respectively  and ¦Ðy for ¦Ðx.

base kb is a triple  r t  a . kb is extensionally reduced if all abox axioms of kb contain only literal concepts.
¡¡the semantics of kb is given by translating it into firstorder logic by the operator ¦Ð from table 1. the main inference problem is checking kb satisfiability  i.e. determining if a first-order model of ¦Ð kb  exists. an individual a is an instance of a concept c w.r.t. kb if ¦Ð kb  |= ¦Ðy c a   which is the case iff kb ¡È { c a } is unsatisfiable.
¡¡the logic alchiq is obtained by disallowing transitivity axioms in shiq rboxes  and alc is obtained by disallowing rboxes  inverse roles and number restrictions. a logic l is between logics l1 and l1 if it contains at least the primitives from l1 and at most the primitives from l1.
¡¡we measure the size of concepts by their length  and assume unary coding of numbers  i.e. |¡Ü nr.c| = n+1+|c|  and use |r a b | = |   a a | = 1.
disjunctive datalog. a datalog term is a constant or a variable  and a datalog atom has the form a t1 ... tn  or t1 ¡Ö t1  where ti are datalog terms. a disjunctive datalog program with equality p is a finite set of rules of the form a1 ¡Å ... ¡Å an ¡û b1 ... bm where ai and bj are datalog atoms. each rule is required to be safe  i.e. each variable occurring in the rule must occur in at least one body atom. a fact is a rule with m = 1. for the semantics  we take a rule to be equivalent to a clause a1¡Å...¡Åan¡Å b1¡Å...¡Å bm. we consider only herbrand models  and say that a model m of p is minimal if there is no model m¡ä of p such that m¡ä   m. a
ground literal a is a cautious answer of p  written p |=c a  if a is true in all minimal models of p. first-order entailment coincides with cautious entailment for positive ground atoms.
reducing kb to disjunctive datalog. the results in this paper are based on our algorithm from  hustadt et al.  1b . for a shiq knowledge base kb  this algorithm computes a table 1: types of alchiq-clauses
1 r x y  ¡Å inv r  y x 1 r x y  ¡Å s x y 1pf x  ¡Å r x f x  1pf x  ¡Å r f x  x 1p1 x  ¡Å p1 f x   ¡Å	fi x ¡Ö/1¡Öfj x 1p1 x  ¡Å p1 g x   ¡Å p1 f g x    ¡Å ti¡Ö/1¡Ötj where ti and tj are of the form f g x   or x1p1 x  ¡Å	 r x yi  ¡Å p1 y  ¡Å	yi ¡Ö yj1r a b  ¡Å p t  ¡Å	ti¡Ö/1¡Ötj
where t i  are a constant b or a functional term fi a positive disjunctive datalog program with equality dd kb  which is equisatisfiable with kb.
¡¡a minor obstacle in computing dd kb  are the transitivity axioms which  in their clausal form  do not contain a
¡¡literal in which all variables of a clause occur. such clauses are known to be difficult to handle  so kb is preprocessed into an equisatisfiable alchiq knowledge base   kb . roughly speaking  a transitivity axiom trans s  is replaced with axioms of the form  r.c    s.  s.c   for each r with s    r and c a concept occurring in kb. this transformation is polynomial  so in the rest of this paper w.l.o.g. we assume kb to be an alchiq knowledge base.
¡¡the next step is to translate   kb  into clausal first-order logic. assuming ¦Ð is defined as in table 1  ¦Ð   kb   is transformed into a set of clauses ¦® kb  using structural transformation to avoid an exponential blowup  nonnengart and weidenbach  1 . roughly speaking  the structural transformation introduces a new name for each complex subformula of ¦Ð   kb  . a specialized version of the structural transformation is presented in detail in section 1.
¡¡a core property of ¦® kb  is that it only contains clauses of one of the forms given in table 1; such clauses are called alchiq-clauses. for a term t  p t  denotes a disjunction of the form    p1 t  ¡Å ... ¡Å    pn t   and p f x   denotes a disjunction of the form f ¡Å ... ¡Å pn fm x    notice that this allows eachto contain positive and negative literals .
¡¡next  the rbox and tbox clauses of ¦® kb  are saturated by basic superposition  bachmair et al.  1; nieuwenhuis and rubio  1 -a clausal equational theorem proving calculus. due to space limitations  we are unable to present the rules of basic superposition; it can be considered to be an optimized version of the well-known paramodulation calculus. let ¦£ be the saturated set of clauses. in this key step  all non-ground consequences of kb are computed. in  hustadt et al.  1b   we have shown the following key property:     an application of a basic superposition inference rule to alchiq-clauses produces an alchiq-clause. the proof examines all inference rules and clause types.
¡¡furthermore  by examining the types of clauses from table 1  one can show the following property:     for a finite kb  the number of alchiq-clauses unique up to variable renaming is exponential in |kb|. the proof is a straightforward counting exercise since the number of variables and the depth of functional terms in alchiq-clauses are bounded. each inference step can be carried out in polynomial time 
so by     and      after at most exponentially many steps  all alchiq-clauses are derived  and saturation terminates.
¡¡satisfiability of ¦® kb  can be decided by further saturating ¦£ ¡È ¦® a  by basic superposition. since ¦£ contains all non-ground consequences of ¦® kb   all remaining inferences will produce only ground clauses  and will not involve clauses of type 1 and 1. these inferences can be simulated in a disjunctive datalog program by transforming ¦£ into a function-free clause set  and by introducing new constants playing the role of ground functional terms  as described next.
¡¡we define an operator ¦Ë transforming ¦£ as follows:  i  each functional term f a  is replaced with a new  globally unique constant af;  ii  each term f x  is replaced with a new  globally unique variable xf;  iii  for each variable in a clause introduced in step  ii   ¦Ë appends a literal  sf x xf   where sf is a new predicate unique for the function symbol f;  iv  if some variable x occurs in a positive  but not in a negative literal in a clause  then the literal  hu x  is appended to the clause;  v  for each function symbol f and each constant a
¡¡from ¦® kb   the facts sf a af   hu a  and hu af  are added. the set of  function-free  clauses obtained by applying ¦Ë to ¦£ ¡È ¦® a  is denoted with ff kb . an example of applying ¦Ë to a clause of type 1 is shown below.
 c x  ¡Å d f x    ¦Ë  sf x xf  ¡Å  c x  ¡Å d xf 
¡¡now each remaining ground inference by basic superposition in ¦£¡È¦® a  can be simulated by a sound inference step in ff kb   and vice versa  hustadt et al.  1b   so kb and ff kb  are equisatisfiable. since ff kb  does not contain functional terms and all its clauses are safe  each clause can be rewritten into a positive disjunctive rule; let dd kb  be the resulting set of rules. the following theorem summarizes the properties of dd kb :
theorem 1   hustadt et al.  1b  . for kb an alchiq knowledge base  the following claims hold:  i  kb is unsatisfiable iff dd kb  is unsatisfiable;  ii  kb |= ¦Á iff dd kb  |=c ¦Á  for ¦Á of the form a a  or s a b   a a concept name  and s a simple role;  iii  kb |= c a  iff dd kb¡È{c   q}  |=c q a   for c a complex concept  and q a new concept name;  iv  the number of rules in dd kb  is at most exponential in |kb|  the number of literals in each rule is at most polynomial in |kb|  and dd kb  can be computed in time exponential in |kb|.
1 data complexity of reasoning in shiq
for an extensionally reduced shiq knowledge base kb  an upper bound for the data complexity follows from the reduction of kb to dd kb . before presenting the details  we first discuss the intuition behind this result.
¡¡by theorem 1  |dd kb | is exponential in |kb|. however  a closer inspection of the reduction algorithm reveals that the exponential blowup is caused by the rules obtained by saturating alchiq-clauses of types 1 - 1  which correspond to tbox and rbox  but not to abox clauses. hence  the size of the rules of dd kb  is exponential in the size of tbox and rbox; however  the size of the facts in dd kb  is linear in the size of the abox. therefore  data complexity of checking satisfiability of dd kb  corresponds to data complexity of checking satisfiability of a positive disjunctive datalog program  and is thus in np. intuitively  this is due to nice property of shiq that tbox and rbox reasoning does not  interfere  with abox reasoning  i.e. all non-ground consequences of kb can be computed without taking the abox into account. notice that this result holds even for binary number coding.
lemma 1  membership . for kb an extensionally reduced shiq knowledge base  satisfiability of kb can be decided in non-deterministic polynomial time in |a|.
proof. let c be the number of constants  f the number of function symbols in the signature of ¦® kb   and s the number of facts in ¦® kb   which is equal to the number of facts in a . by definition of ¦Ë  the number of constants in dd kb  is bounded by  1 = c + cf  cf accounts for constants of the form af   and the number of facts in dd kb  is bounded by  1 = s + c + 1cf  c accounts for facts of the form hu a   one cf accounts for facts of the form sf a af   and the other cf accounts for facts of the form hu af  . all function symbols are introduced by skolemizing tbox concepts  r.c and ¡Ý nr.c. since |t | and |r| are constant  f is also a constant  so both  1 and  1 are linear in |a|.
¡¡hence  |dd kb | can be exponential in |kb| only because the non-ground rules in dd kb  are obtained from exponentially many clauses of types 1 - 1. since these clause types do not contain abox clauses  the number of clauses obtained after saturation is obviously exponential in |t | + |r| only. since we assume that the latter is constant  both the number of rules in dd kb  and their length are bounded by constants  so |dd kb | is polynomial in |a|  and can be computed from kb in time polynomial in |a|.
¡¡as kb and dd kb  are equisatisfiable  the data complexity of checking satisfiability of kb follows from the data complexity of checking satisfiability of dd kb   which is np-complete  dantsin et al.  1 : assuming dd kb  contains r rules and at most v variables in a rule  the number of literals in a ground instantiation ground dd kb   is bounded by   in each rule  each variable can be replaced in  1 possible ways . assuming r and v are constants    = |ground dd kb  | is polynomial in |a|. satisfiability of ground dd kb   can be checked by nondeterministically generating an interpretation of size at most    and then checking whether it is a model. both tasks can be performed in polynomial time  so the overall algorithm is obviously non-deterministically polynomial in |a|. 
¡¡the hardness of the satisfiability checking problem follows from  schaerf  1  lemma 1.1 . actually  the lemma shows co-np-hardness of instance checking  by a reduction of satisfiability of 1-cnf propositional formulae. the reduction produces an extensionally reduced abox and a single tbox axiom  so it applies in our case as well. hence  we immediately obtain the following result:
theorem 1. let kb be an extensionally reduced knowledge base in any logic between alc and shiq. then  i  deciding kb satisfiability is data complete for np and  ii  deciding whether kb |=    c a  with |c| bounded is data complete for co-np.
1 a horn fragment of shiq
horn logic is a well-known fragment of first-order logic where formulae are restricted to clauses containing at most one positive literal. the main limitation of horn logic is its inability to represent disjunctive information; however  its main benefit is the existence of practical refutation procedures. furthermore  data complexity of query answering in horn logic without function symbols is p-complete  dantsin et al.  1   which makes it appealing for practical usage.
¡¡following this idea  in this section we identify a horn fragment of shiq  where disjunction is traded for p-complete data complexity. roughly speaking  in horn-shiq  only axioms of the form dci   d are allowed  where each ci has the form a or  r.a  and d has the form a  ¡Í   r.a   r.a  ¡Ý nr.a or ¡Ü 1r. whereas such a definition succinctly demonstrates the expressivity of the fragment  in general it is too restricting: e.g.  the axiom a1 a1    b is not horn  but it is equivalent to horn axioms a1 b   ¡Í and a1 b   ¡Í. similarly  a non-horn axiom a    r.  r.b  can be transformed into horn axioms a    r.q and q    r.b by introducing a new name q for the subconcept  r.b. to avoid dependency on such obvious syntactic transformations  we give a rather technical definition of horn-shiq.
¡¡we first adapt the notions of positions and polarity in firstorder formulae to dl. a position p is a finite sequence of integers; the empty position is denoted with  . if a position p1 is a proper prefix of a position p1  then and p1 is above p1  and p1 is below p1. for a concept ¦Á  the subterm at a position p  written ¦Á|p  is defined as follows: ¦Á|  = ¦Á;   d |1p = d|p;  d1   d1 |ip = di|p for   ¡Ê {   } and i ¡Ê {1}; ¦Á|1 = r and ¦Á|1p = d|p for ¦Á =  r.d and   ¡Ê {   }; and ¦Á|1 = n  ¦Á|1 = r and ¦Á|1p = d|p for ¦Á =    nr.d and
   ¡Ê {¡Ü ¡Ý}. a replacement of a subterm of ¦Á at position p with a term ¦Â is defined in the standard way and is denoted as ¦Á ¦Â p. for a concept ¦Á and a position p such that ¦Á|p is a concept  the polarity of ¦Á|p in ¦Á  denoted as pol ¦Á p   is defined as follows:
pol c    = 1;
pol c1   c1 ip  = pol ci p  for   ¡Ê {   }  i ¡Ê {1};
pol  r.c 1p  = pol c p  for   ¡Ê {   };
pol ¡Ý nr.c 1p  = pol c p ; pol  c 1p  =  pol c p ; pol ¡Ü nr.c 1p  =  pol c p .
intuitively  pol ¦Á p  equals 1 if ¦Á|p occurs in ¦Á under an even number of explicit and implicit negations  and  1 otherwise.
definition 1. in table 1  we define two mutually recursive functions pl+ and pl   where sgn 1  = 1 and sgn n  = 1 for n   1. for a concept c and a position p of a subconcept in c  let pl c p  = pl+ c|p  if pol c p  = 1  and let pl c p  = pl  c|p  if pol c p  =  1.
¡¡a concept c is a horn concept if pl c p  ¡Ü 1 for each position p of a subconcept in c  including the empty position   . an extensionally reduced alchiq knowledge base kb is horn if  for each axiom c   d ¡Ê kb  the concept  c d is horn. an extensionally reduced shiq knowledge base kb is horn if   kb  is horn.
table 1: definitions of pl+ and pl 
d	pl+ d 	pl  d 
 c	pl  c 	pl+ c 
dci	maxi sgn pl+ ci  	i sgn pl  ci  
	ci	i sgn pl+ ci  	max
 r.c 1  r.c sgn pl+ c   1
 n 1 n
¡¡it is easy to see that  for a concept c without complex subconcepts  pl+ c  yields the maximal number of positive literals in clauses obtained by clausifying  x : ¦Ðy c x . to clausify a concept c containing a complex subconcept at a position p  one should consider if c|p occurs in c under positive or negative polarity. e.g.  in    a    b  the concepts a and b occur effectively positive  and   is effectively  . hence  pl+ c|p   pl  c|p   counts the number of positive literals used to clausify c|p  provided that c|p occurs in c under positive  negative  polarity. the function sgn ¡¤  takes into account that c|p will be replaced in c by structural transformation with only one concept name  even if clausification of c|p produces more than one positive literal. e.g.  to clausify c =  r. d1   d1   the structural transformation replaces d1  d1 with an new concept name q  yielding c¡ä =  r.q; then clausifying c¡ä produces a clause with only one positive literal. now a concept c is horn if the maximal number of positive literals obtained by clausifying subconcepts of c is at most one.
¡¡if a concept c has a complex subconcept at position p  special care has to be taken in introducing a new name ¦Á for c|p. consider the horn concept c =  r.d1    r. d1. to apply structural transformation to c  one might replace  r.d1 and  r. d1 with new concept names q1 and q1  yielding concepts  q1    r.d1   q1    r. d1 and q1   q1. the problem with such a straight-forward application of structural transformation is that a horn concept c was reduced to a nonhorn concept q1   q1  so the structural transformation destroyed horn-ness. to remedy this  we modify the structural transformation to replace each c|p with a literal concept ¦Á such that clausifying ¦Á and c|p requires the same number of positive literals. in the above example  this would mean that  r.d1 should be replaced with q1  but  r. d1 should be replaced with  q1  yielding concepts  q1    r.d1  q1    r. d1 and q1    q1  which are all horn.
¡¡although transitivity axioms are translated by ¦Ð into horn clauses  recall that the algorithm from section 1 replaces them with axioms of the form  r.c    s.  s.c . now pl+  r. c    s.  s.c   = 1 + pl+ c   so if pl+ c    1    kb  is not a horn knowledge base. hence  the presence of transitivity axioms can make a knowledge base non-horn.
definition 1. let c be a concept and ¦« a function mapping c to the set of positions p 1=   of subconcepts of c such that c|p is not a literal concept and  for all positions q below p  c|q is a literal concept. then def c  is defined recursively as follows  where ¦Á = q if pl c p    1  and ¦Á =  q if pl c p  = 1  with q a new atomic concept  and    q  = q:
  def c  = {c} if ¦« c  =    or
  if ¦« c  1=    then choose some p ¡Ê ¦« c  and let
¡¡¡¡¡¡¡¡¡¡¡¡{ ¦Á   c|p} ¡È def c ¦Á p  if pol c p  = 1 def c  =
{ ¦Á    c|p} ¡È def c  ¦Á p  if pol c p  =  1
¡¡let cls    denote the set of clauses obtained by clausifying a formula   in the standard way and let
cls c  = sd¡Êdef c  cls  x : ¦Ðy d x  .
for an alchiq knowledge base kb  ¦® kb  is the smallest set of clauses such that:  i  for each role name r ¡Ê nra  cls ¦Ð r     ¦® kb ;  ii  for each rbox or abox axiom ¦Á in kb  cls ¦Ð ¦Á     ¦® kb ;  iii  for each tbox axiom c   d in kb  cls  c   d    ¦® kb .
¡¡by  nonnengart and weidenbach  1    x : ¦Ðy c x  and vd¡Êdef c   x : ¦Ðy d x  are equisatisfiable  so ¦® kb  and ¦Ð kb  are equisatisfiable as well.
lemma 1. for a horn-shiq knowledge base kb  each clause from ¦® kb  contains at most one positive literal.
proof. we first show the following property  * : for a horn concept c  all concepts in def c  are horn concepts. the proof is by induction on the recursion depth in def. the induction base for ¦« c  =   is obvious. consider an application of def c   where c is a horn concept and p a position of a subconcept of c  such that c|p is not a literal concept and  for each position q below p  c|q is a literal concept. observe that in all cases  we have pl+ ¦Á  = pl c p  and pl+  ¦Á  = 1   pl c p . we now consider two cases  depending on pol c p :
  pol c p  = 1. now we have pl+  ¦Á   c|p  = pl+  ¦Á  + pl+ c|p  = pl+  ¦Á  + pl c p  = 1. furthermore  pl c p  = pl c ¦Á p p   so c ¦Á p is horn.
  pol c p  =  1. now we have pl+  ¦Á    c|p  = pl+  ¦Á  + pl  c|p  = pl+  ¦Á  + pl c p  = 1. furthermore  pl c p  = pl c  ¦Á p p   so c  ¦Á p is horn.
hence  each application of the operator def decomposes a horn concept c into two simpler horn concepts  so  *  holds. furthermore  for each c|p or  c|p in the definition of def  each immediate subconcept is a literal.
¡¡for d ¡Ê def c   by definition of ¦Ð from table 1  it is easy to see that pl+ d  gives the maximal number of positive literals occurring in a clause from cls  x : ¦Ðy d x  . thus  if c is a horn concept  all clauses from cls c  contain at most one positive literal. finally  clauses obtained by translating rbox and abox axioms of   kb  also contain at most one positive literal.	
¡¡as stated by the following lemma  a basic superposition inference  when applied to horn premises  produces a horn conclusion. the full proof of the lemma is given in  hustadt et al.  1a .
lemma 1. if all premises of an inference by basic superposition contain at most one positive literal  then inference conclusions also contain at most one positive literal.
proof.  sketch  consider a resolution inference with clauses a ¡Å c and  b ¡Å d  where all literals in c are negative and at most one literal in d is positive. obviously  the number of positive literals in the conclusion c¦Ò ¡Å d¦Ò is equal to the number of positive literals in d. similarly  consider a paramodulation inference from a clause s ¡Ö t ¡Å c into a
clause a ¡Å d  where all literals in c and d are negative. obviously  the conclusion a¦Ò t¦Ò p ¡Å c¦Ò ¡Å d¦Ò has only one positive literal. similar considerations hold for a paramodulation into a negative literal.	
¡¡by lemma 1 and 1  if kb is a horn-shiq knowledge base  then dd kb  is a non-disjunctive program. this is enough for the following result:
theorem 1. for kb an extensionally reduced horn knowledge base in any logic between alc and shiq  deciding kb  un satisfiability  and deciding whether kb |=    c a  with |c| bounded  is p-complete in |a|.
proof. membership in p is a consequence of the fact that dd kb  is a non-disjunctive program  whose satisfiability can be checked in polynomial time  dantsin et al.  1 .
¡¡for hardness  consider the well-known p-complete problem of deciding whether a path from a node a1 to a node an in a graph g exists  papadimitriou  1 . for a graph g  let kbg be a knowledge base containing the assertions edge a b  and edge b a  for each edge ha bi in g  the axioms c a1  and  c an   and the tbox axiom c    edge.c. obviously  a1 is reachable from an if and only if kbg is unsatisfiable  thus implying p-completeness of unsatisfiability checking. the other inference problems can be reduced to unsatisfiability as usual.	
1 discussion
to better understand the results from the previous two sections  we contrast them with well-known results for  disjunctive  datalog  dantsin et al.  1 . since datalog has been successfully applied in practice  this analysis gives interesting insights into the practical applicability of dls.
¡¡interestingly  the data complexity of datalog variants and of corresponding shiq fragments coincide. namely  without disjunctions  a shiq knowledge base and a datalog program always have at most one model  which can be computed in polynomial time. with disjunctions  several models are possible  and this must be dealt with using reasoning-by-cases. intuitively  one needs to  guess  a model  which increases data complexity to np.
¡¡the key difference between datalog and dls is revealed by considering the effects that various parameters have on the complexity. for a datalog program p and a ground atom ¦Á  checking whether p |= ¦Á can be performed in time o |p|v   where v is the maximal number of distinct variables in a rule of p  vardi  1 . namely  the problem can be solved by grounding p  i.e. by replacing  in each rule of p  all variables with individuals from p in all possible ways. the size of the grounding is bounded by |p|v  and propositional horn logic is p-complete  giving the above estimate. now in general  v is linear in |p|  so the size of the grounding is exponential; thus  the combined complexity of datalog coincides with the combined complexity of shiq. however  in practical applications v is usually small  so it makes sense to assume it is bounded. under this assumption  datalog actually exhibits polynomial behavior.
¡¡by an analogy  one might try to limit the length of concepts in axioms or the number of variables. for the former  structural transformation can be used to polynomially reduce  long  axioms with complex concepts to  short  axioms with just elementary concepts. for the latter  we note that dls are closely related to the two-variable fragment of first-order logic: e.g.  alc concepts correspond to first-order formulae with only two variables regardless of nesting  see  e.g.   baader et al.  1  ch. 1  . therefore  the number of variables in dl axioms is  intrinsically  bounded  assuming a bound on the numbers occurring in number restrictions . hence  neither restriction actually reduces complexity.
¡¡we summarize our discussion as follows: assuming a bound on the axiom length  but not on the number of axioms  satisfiability checking in datalog is  non-deterministically  polynomial  but in dls it is exponential. the reason for this is that dls such as alc provide existential and universal quantification and general inclusion axioms  which can be used to succinctly encode models with paths of exponential length. the saturation step eliminates function symbols introduced by existential quantification  but it also incurs an exponential blowup in the program size to account for such paths. hence  although combined complexity of both datalog and dls is exponential  the reasons for this are different.
¡¡in  baader et al.  1  ch. 1  two sources of complexity in dls have been identified: or-branching caused by the existence of several possible models  and and-branching caused by the existence of paths within a model. our results show that or-branching is not so  bad  as and-branching: the former incurs  only  an increase to np  whereas the latter incurs an increase in complexity to exptime.
1 conclusion
in many application of dls  the tbox can be assumed to be rather stable - like a database schema - whereas the abox is varying and possibly very large - like a database extension. hence  we study the complexity of reasoning in expressive dls measured in the size of the abox. in particular  we show that checking satisfiability of a shiq knowledge base is np-complete  and that checking unsatisfiability and instance checking are co-np-complete in the size of the abox. furthermore  we identify horn-shiq  a fragment of shiq which  analogously to horn logic  does not allow to represent disjunctive knowledge  and for which the basic reasoning problems are p-complete in the size of theabox.
¡¡our results indicate that reasoning with large aboxes may be feasible if the tbox is not  too  large and if we stay within horn-shiq. to verify these assumptions  we are currently implementing our algorithms and plan to conduct a thorough performance analysis.
acknowledgments
we thank enrico franconi for a stimulating discussion which lead us to the results presented in this paper.
