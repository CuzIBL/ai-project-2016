
due to large search spaces  diagnosis of combinational circuits is often practical for finding only single and double faults. in principle  system models can be compiled into a tractable representation  such as dnnf  on which faults of arbitrary cardinality can be found efficiently. for large circuits  however  compilation can become a bottleneck due to the large number of variables necessary to model the health of individual gates. we propose a novel method that greatly reduces this number  allowing the compilation  as well as the diagnosis  to scale to larger circuits. the basic idea is to identify regions of a circuit  called cones  that are dominated by single gates  and model the health of each cone with a single health variable. when a cone is found to be possibly faulty  we diagnose it by again identifying the cones inside it  and so on  until we reach a base case. we show that results combined from these hierarchical sessions are sound and complete with respect to minimum-cardinality diagnoses. we implement this method on top of the diagnoser developed by huang and darwiche in 1  and present evidence that it significantly improves the efficiency and scalability of diagnosis on the iscas-1 circuits.
1 introduction
in this work we consider fault diagnosis of combinational circuits  where the observed  abnormal  input and output values of a circuit  together with its implementation  are given to a diagnosis engine  which finds possible sets of faulty gates that explain the observation.
¡¡a diagnosis tool implementing a model-based approach was recently presented in  huang and darwiche  1   where systems to be diagnosed are modeled as propositional formulas in conjunctive normal form  cnf   which are then compiled into decomposable negation normal form  dnnf   darwiche  1 . this tool  which we shall referto as hd1  was shown particularly to improve in efficiency and scalability over an earlier tool  torta and torasso  1  based on compiling system models into ordered binary decision diagrams  obdd   bryant  1 .
 okx¡Å a¡Å c
	ad	 okx¡Åa¡Åc
b oky¡Åb¡Å d
 oky¡Åc¡Å d
 oky¡Å b¡Å c¡Åd
figure 1: a circuit and its cnf encoding.
¡¡consider the example in figure 1  reproducedfrom  huang and darwiche  1 . hd1 models the circuit as a propositional formula where each signal of the circuit translates into a propositional variable  a b c d . for each gate an extra variable  okx oky   is introduced to model its health. the propositional formula is such that when all health variables are true  the remaining variables are constrained to model the functionality of the gates. for instance  the first two clauses shown in the figure are equivalent to the sentence okx    a    c   modeling the health of the inverter x.
¡¡given a  typically abnormal  valuation of the inputs and outputs of the circuit  called an observation  a  consistencybased  diagnosis is then a valuation of the health variables that is consistent with the observation and system model. for instance  given the observation  a ¡Ä b ¡Ä  d  one diagnosis is  okx ¡Ä oky   meaning that the inverter x is broken and the and-gate is healthy. it is known that once the system model is compiled into dnnf  one can compute a compact representation of all diagnoses in time linear in the size of the dnnf  darwiche  1 .
¡¡a major advantage of hd1 is that dnnf is known to be a strictly more succinct representation than obdd and supports efficient algorithms that compute diagnoses of arbitrary cardinality as well as minimum cardinality  darwiche  1 . when this approach is applied to large circuits  however  compilation of system models into dnnf can become a bottleneck due to large numbers of health variables.
¡¡we propose a solution to this problem based on hierarchical diagnosis. we start with an abstraction of the circuit where certain regions of the circuit  called cones  are  carved out  based on a structural analysis. the abstract model  being generally much simpler  allows larger circuits to be compiled and their diagnoses computed. the cones are diagnosed only when they are identified by the top-level diagnosis as possibly faulty. we discuss the intricacies involved in properly diagnosing the cones so that redundancy is avoided and results

figure 1: a circuit with cones.
combined from the hierarchical diagnosis sessions are sound and complete with respect to minimum-cardinalitydiagnoses. we implement our new approach on top of hd1. using iscas-1 benchmark circuits  we show that we can now diagnose some circuits  with arbitrary fault cardinality  for the first time. for circuits that can already be handled by hd1  we also observe a significant improvement in diagnosis time.
1 notation and definitions
we shall use the circuit in figure 1 as a running example. the numbers shown alongside the gate outputs are values of the signals  which can be ignored for the moment.
1 circuits  dominators  and cones
we use c to denote the circuit as well as the set of gates of the circuit including the inputs  as trivial gates . we identify a gate with its output signal. the set of inputs of the circuit is denoted ic and the set of outputs oc. for example  ic = {p q r} and oc = {t u v } for the circuit in figure 1.
¡¡one may observe that certain regions of this circuit have only limited connectivity with the rest of the circuit. for example  the dotted box containing gates {a d e h p} is a sub-circuit that contributes a single signal  a  to the rest of the circuit. the box containing gates {d h p} is another such example. we refer to such a sub-circuit as a cone  also known as fan-out free formula  lu et al.  1b; 1a    which we now formally define.
¡¡the fan-in region of a gate g ¡Ê c is the set of all those gates that have a path passing throughg going to some output gate. the fan-in region of gate a in figure 1  for example  is {a b d e h p q}.
definition 1.  dominator  a gate x in the fan-in region of gate g is dominated by g  and conversely g is a dominatorof x  if any path from gate x to an output of the circuit contains g  kirkland and mercer  1 .
¡¡the notion of cone then corresponds precisely to the set of gates dominated by some gate g  which we denote by ¦¤g. for example  the dotted box mentioned above corresponds to ¦¤a = {a d e h p}. from here on  when the meaning is clear  we will simply use g to refer to the cone rooted at g.
1 abstraction of circuit
a circuit can be abstracted by treating all maximal cones in it as black boxes  a maximal cone is one that is either contained in no other cone or contained in exactly one other cone which is the whole circuit . for example  cone a can be treated as a virtual gate with two inputs {p b} and the output a. similarly  cone a itself can be abstracted by treating cone d as a virtual gate. an abstraction of a circuit can hence be defined as the original circuit minus all non-root gates of maximal cones  or more formally:
definition 1.  abstraction of circuit  given a circuit c  let c = c if c has a single output; otherwise let c be c augmented with a dummy gate collecting all outputs of cs. the abstraction ¦¨c of circuit c is then the set of gates x ¡Ê c such that there is a path from x to the output that does not contain any dominator of x other than x and o.
¡¡for example  c as e cannot reach any output without passing through a  which is a dominator of e. similarly  a as its only path to a contains d  which is a dominator of h.
1 dnnf-based diagnosis
before presenting our new algorithm we briefly review the baseline diagnoser hd1  huang and darwiche  1   which is based on compiling the system model  circuit in our case  from cnf to dnnf  darwiche  1 .
¡¡dnnf is a graph-based representation for propositional theories. specifically  each dnnf theory is a dag  directed acyclic graph  with a single root where all leaves are labeled with literals and all other nodes are labeled with either and or or; in addition the decomposability property must be satisfied: children of any and-node must not share variables.
¡¡once a system model is convertedinto dnnf  consistencybased diagnoses  as well as minimum-cardinality diagnoses  can be computed in time polynomial in the size of the dnnf  darwiche  1 . the key is that decomposability allows nonobservables to be projected out in linear time  and allows diagnoses computed for children to be combined at a parent and-node simply by cross-concatenation  note that diagnoses computed for children can naturally be unioned at a parent or-node .
¡¡our new algorithm aims to improve the efficiency and scalability of this approach in the context of circuit diagnosis. we will continue to model a circuit as a cnf formula and rely on dnnf compilation to compute diagnoses. the main innovation is a structure-based method to reduce the number of health variables required for the model and hence the difficulty of compilation  while maintaining the soundness and completeness of the diagnoser. in the rest of the paper we will assume that only minimum-cardinality diagnoses are sought.
1 hierarchical diagnosis
the key idea behind our new algorithm is to start by obtaining the abstraction ¦¨c of a circuit c as defined in section 1  and then diagnose c pretending that only gates in ¦¨c could be faulty. this is the basic technique that will significantly reduce the number of health variables required in the system model  allowing us to compile and diagnose larger circuits. once this top-level diagnosis session finishes  if a gate appearing in a diagnosis is the root of a cone  which has been abstracted out  then we attempt to diagnose the cone  in a similar hierarchical fashion.
¡¡two things are worth noting here before we go into details. first  cones are single-output circuits and hence the diagnosis of cones will alway produce diagnoses of cardinality one. second  the diagnosis of a cone is not performed simply with a recursive call as one may be tempted to expect. indeed the later diagnosis sessions are very distinct from the initial toplevel session. the reason has to do with avoiding redundant computation  which we will discuss later in the section.
¡¡we now present in detail our hierarchical diagnosis algorithm  which we will refer to as hdiag. pseudocode of hdiag is given in algorithm 1.
1 algorithm
step 1  dominators 
hdiag starts by identifying the nontrivial dominator gates in the circuit  a trivial dominator is one that dominates only itself . first the dominators of every gate are obtained. the dominators of a gate are the gate itself union the intersection of the dominators of its parents  kirkland and mercer  1   which can be found by a simple breadth-first traversal of the circuit starting from the outputs. during this process the nontrivial dominators can be identified. finddominators implements this procedure on line 1 of algorithm 1.
¡¡in our example  the dominator sets for t  u  v   a  b  c are {t} {u} {v} {a} {b} {c}  respectively; the dominator set for d is {d a} and for h is {h d a}. it can be easily seen that the gates t  u  and v are trivial dominators whereas d and a are nontrivial dominators.
step 1  cones and their inputs 
each nontrivial dominator defines a cone that can be abstracted out. next we identify the inputs of these cones by a depth-first traversal of the circuit. suppose g is a cone. the inputs ig of g can be found by traversing the fan-in region of g so that if we reach either an input of the circuit or a gate that does not belong to ¦¤g  we add it to ig and backtrack. findcones implements this procedure on line 1 of algorithm 1.
¡¡for cone d in our example  we traverse the fan-in region of d in the order d h p b. gates p and b are added to the inputs of cone d. we backtrack fromd. the inputs of cone d are thus {p b}.
step 1  top-level diagnosis 
the rest of the algorithm proceeds in two phases. in the first phase we have the  abnormal  observation for the whole circuit. we first propagate the values of the inputs bottom-up  setting the  expected  value of each internal gate of the circuit. these values are saved for reference later. the observed outputs of the circuit are then set which may be abnormal. propagateinputs  savevalues  and setobsoutputs on lines 1 and 1 of algorithm 1 implement these procedures.
¡¡the health of the abstraction of the circuit  ¦¨c  is then diagnosed. this is achieved by associating a health variable with every gate in ¦¨c. ¦¨c contains all the dominaalgorithm 1 hdiag : hierarchical diagnosis algorithm

function hdiag   c  obs   inputs: {c: circuit/set of gates}  {obs: set of  gate bool } output: {set of sets of gates}
local variables: {oc ic ¦° t : set of gates} {¦« d:set of sets of gates}  {¦¸ : cnf  set of gates }
1: oc ¡û outputs  c  
1: ic ¡û inputs  c  
1: finddominators  oc    findcones  oc  
1: propagateinputs   c ic obs    savevalues   c  
1: setobsoutputs   oc obs  
1: t ¡û traverse ¦¨c   oc ic    attachoks  t  
1: ¦¸ ¡û genmodel  c oc ¡È ic  
1: ¦« ¡ûcallhd1  ¦¸ obs    orderbydepth  ¦«  
1: restorevalues    
1: d ¡û ¦Õ
1: for all ¦° ¡Ê ¦« do 1: d ¡û d ¡È findeqdiagnoses  ¦°  
1: return d


algorithm 1 traverse ¦¨c : traverses top level function traverse ¦¨c   oc ic   inputs: {ocic  set of gates} output: {set of gates} local variables: {q k t: set of gates}  {y o} : gate
1: o ¡û singleoutput  oc   1: q ¡û {o}  t ¡û ¦Õ
1: while  isempty  q  do
1:	y ¡û pop  q   1:	if
1:t ¡û t¡È {y }1:if  isdominator   y   || y == o then1:k ¡û children   y    q ¡û q ¡È k1: return t

tors of the top-level hierarchy plus all the non-dominators that sit between those dominators and the outputs oc of the circuit. traverse¦¨c traverses the top-level hierarchy of the circuit. singleoutput on line 1 of algorithm 1 implements the attachment of dummy gate described in definition 1. traverse¦¨c is implemented so that as soon as it encounters an input of the circuit or a nontrivial dominator  other than root  see line 1 of algorithm 1   it backtracks  the inputs are excluded as they are assumed to be healthy . attachoks associates health variables with each gate in this hierarchy.
¡¡now we create an abstract system model similar to the full model used in  huang and darwiche  1 . the abstract model contains a system description  in cnf  over the set of observables  ic ¡Èoc  and nonobservables  c  ic ¡Èoc  . the model is generated by the function genmodel and returned as ¦¸. note that only the clauses representing the gates marked by attachoks will have additionalhealth variables. hd1 is then called with ¦¸ and the observationto performthe diagnosis. the diagnoses thus obtained will be referred to as top-level diagnoses. if a nontrivial dominator g ¡Ê ¦¨c is reported to be possibly faulty  we then enter the second phase by diagnosing the cone under g.
¡¡for example  in figure 1  given the inputs  all the outputs of the circuit should be 1  but  all of them are 1 in our obalgorithm 1 findeqdiagnoses : diagnosis of cones

function findeqdiagnoses   ¦°   inputs: {¦°  set of gates}
output: {set of sets of gates}
local variables: {e ¦«: set of sets of gates}  {p r c ix q t s: set of gates}  {x y : gate}  {¦¸ : cnf  set of gates }  {obs: set of  gate bool }
1: e ¡û {¦°}  d ¡û {¦°} 1: while  isempty  e   do
1:	p ¡û pop  e  
1:	propagatefault   p  
1: for all x ¡Ê p such that x is a cone and is not the whole circuit do
1:	if
1:	q ¡û q ¡È {x}
1:	c ¡û traversecone   x    ix ¡û inputs   c  
1:	t ¡û traverse ¦¨c   {x} ix    attachoks   t  
1:	¦¸ ¡û genmodel   c {x} ¡È ix  
1:	obs ¡û valuation  {x} ¡È ix  
1:	¦« ¡û callhd1   ¦¸ obs    setdiags  x ¦«  
1:	else 1:	¦« ¡û diags  x  
1:	for all r ¡Ê ¦« do
1:	y ¡û pop   r  
1:	if then
1:	s ¡û substitute   x y p  
1:	e ¡û e ¡È {s}  d ¡û d ¡È {s}
1:	restorevalues    
1: cleardiags  q   1: return d

servation. we introduce health variables for the set of gates ¦¨c ic = {t u v a b c}  create a model of the abstraction of the circuit  and pass the model along with the observation  t ¡Ä  u ¡Ä  v ¡Ä p ¡Ä q ¡Ä r to hd1. one of the diagnoses returned by hd1 is  oka¡Ä okb ¡Ä okc or  to use an alternative notation  {a b c}  in the rest of the paper we will use this latter notation expressing a diagnosis as a set of faulty gates . since a is a cone  we enter the second phase.
step 1  diagnosis of cones 
suppose that ¦° = {x g1 ... gn} is a diagnosis found in the top-level phase and that x ¡Ê ¦° is  the root of  a cone. it should be clear that given the faulty output b of x  if there is a gate y ¡Ê ¦¤x that  when assumed faulty  permits the same value b at x  then replacing x with y will yield a valid global diagnosis. this way we try to expand our top-level diagnoses in the procedure findeqdiagnoses  line 1 of algorithm 1   given in algorithm 1.
¡¡mainly  for each cone x in each top-level diagnosis ¦°  we find a diagnosis for x hierarchically. we identify x as a sub-circuit with the single output x and the inputs ix. the minimum cardinality of diagnoses for x is always one as we mentioned earlier. we then replace x with its singleton diagnoses  in ¦°  one by one  to produce new global diagnoses. this process is iterated until we reach a base case  no cones left to be diagnosed . we treat each ¦° and all diagnoses generated from it as a single class of diagnoses and use it to avoid redundant computation  explained in section 1 .
¡¡cone x could be diagnosed as is done for the whole circuit but there is more to be done in order to find correct diagnoses.
specifically  we need a set of values for the inputs and output of cone x as an observation to pass to hd1. first of all we restore expected values of the gates in the circuit  line 1 of algorithm 1  before we call findeqdiagnoses.
¡¡we want to diagnose cone x under the assumption that all of the gates gi ¡Ê ¦° are also faulty  so we need to propagate the fault effect of all gi into the sub-circuit. since faults in circuits propagate bottom-up  we put the set of gates in each diagnosis in decreasing order of their depth in the circuit  orderbydepth on line 1 of algorithm 1 . a fault is processed simply by flipping the output of the faulty gate and propagatingits effect. this is donefor each g ¡Ê ¦° separately in the order in which they appear in ¦°. this has the desired effect of setting an observation across cone x  ix ¡È {x}  that is consistent with the observation of the overall circuit. cone x is now ready for diagnosis.
¡¡note that  again  only the abstraction ¦¨x of cone x is diagnosed. as we mentioned earlier  however  this is not simply a recursive call to algoritm 1  but needs to be handled differently  algorithm 1 . traversecone  line 1  identifies and returns the set of gates of the cone  i.e.  ¦¤x . valuation returns a set of  gate  bool  pairs which represents the currently assigned values to the set of gates {x} ¡È ix passed as input  line 1 . the returned set serves as an observation across the cone. given the cone  its observables and nonobservables  the health of its abstraction is diagnosed using hd1 and the set of singleton diagnoses ¦« found is saved  line 1 . these diagnoses can be retrieved by diags  line 1 . substitute   x y p  generates a new diagnosis by replacing x with y in p  line 1 . finally  we clear these diagnoses before returning from the function  line 1 .
¡¡the diagnosis of cones is similar to that of the overall circuit given in algorithm 1. there are  however  a few details worth mentioning:  i  every cone is diagnosed hierarchically  i.e.  for a cone x we diagnose only the top-level hierarchy ¦¨x of x.  ii  in a single call to findeqdiagnoses every cone is diagnosed once  ensured by line 1 of algorithm 1 . this is sufficient and will be explained later.  iii  once a new diagnosis is generated by substitution  it is added to the set e for further processing  line 1 of algorithm 1 .  iv  the fault effect of a diagnosis is propagated before the diagnosis is processed  and undone afterwards.  v  as substitutions are made  the gates in a newly generated diagnosis may not have the depth order discussed above; however  we do not re-order them for reasons that will be clear soon.
¡¡continuing with our example  we reorder {a b c} as {b a c}. we flip b to 1  propagate the effect that flips e to 1 and d to 1. a remains 1 at this stage; we then flip a to 1  gate c is irrelevant to the diagnosis of cone a . note that the correct output of cone a should be 1 given its inputs p 1  and b 1 . we place health variables at the gates ¦¨a ia = {a d e}  generate a model for cone a  and pass it to hd1 with the observation  a ¡Ä p ¡Ä  b  which returns three diagnoses of cardinality one: {a} {d} {e}. note that {a} is a trivial diagnosis. substituting d and e for a in the top-level diagnosis {b a c}  we get two new diagnoses: {b d c}  {b e c}.

figure 1: redundancy scenarios.
1 avoiding redundancy
since cones can be shared among different diagnoses  a cone is potentially visited more than once before all final diagnoses are computed. it may or may not be redundant to diagnose one cone multiple times. there are three cases to consider:
  suppose that in a top-level diagnosis  a cone s appears in two diagnoses {s t} and {s u}  shown in figure 1a. it can be seen that neither t nor u lies in the fan-in region of cone s. thus no fault at t or u can affect values at the inputs or output of cone s. this means that diagnosis of s can be obtained once and can be used in the processing of both of the top-level diagnoses. this case is currently not implemented in our code.
  in figure 1b  both t and u lie in the fan-in region of the cone s. thus faults at t or u can affect values at the inputs and output of cone s. however  if we consider a fault at t and its effect across s  at the inputs and output of s   it may not be same as a fault at u and its effect across s. thus the diagnosis of cone s during the processing of {s t} may be completely different from that during the processing of {s u}. hence cone s has to be diagnosed twice in this case. this is why we clear the diagnoses before we return from findeqdiagnoses in algorithm 1.
  in figure 1c  we assume that only {s t} is a top-level diagnosis whereas {s u} is a diagnosis obtained during the processing of {s t} such that {u} is a cardinality one diagnosis for cone t. hence the value seen at the output of t due to a fault at t would be the same as if seen due to a fault at u. therefore  the effect of both faults  individually  across s would be the same and hence s needs to be diagnosed only once for both diagnoses. this idea extends to any level of substitution when diagnosing cone u further yields new diagnoses. for this reason we do not reorder the gates in the newly generated diagnoses  in findeqdiagnoses  according to their depth. this case is taken care of on line 1 by the if condition in findeqdiagnoses.
1 soundness and completeness
we now prove the following theorem  relying on the fact that the baseline diagnoser hd1 has the same property.
theorem 1. hdiag is sound and complete with respect to minimum-cardinality diagnoses.
¡¡proof. let c be the circuit in question. we show that every diagnosis found by hdiag is a minimum-cardinalitydiagnosis  soundness  and every minimum-cardinality diagnosis is found by hdiag  completeness .
soundness: it should be clear that all diagnoses found by
hdiag are in fact valid. moreover  they all have the same cardinality because  1  all top-level diagnoses found in step 1 have the same cardinality by virtue of hd1 and  1  substitutions in step 1 do not alter the cardinality as cones whose roots are in ¦¨c cannot overlap  i.e.  two gates in a top-level diagnosis cannot be substituted by the same gate in step 1 .
¡¡hence it remains to show that the cardinality of these diagnoses  call it d  is indeed the smallest possible. suppose  on the contrary  that there exists a diagnosis ¦° of a smaller cardinality: |¦°|   d. now  let each gate in ¦° be replaced with its highest dominator in the circuit to produce ¦°. clearly   remains a valid diagnosis   ii  c  and  iii 
.  i  and  ii  imply that ¦° is a diagnosis for the abstraction ¦¨c.  iii  implies. this means that the top-level diagnoses for ¦¨c found in step 1 are not of minimum cardinality  contradicting the soundness of the baseline diagnoser hd1.
¡¡completeness: let ¦° be a diagnosis of minimum cardinality d. let each gate in ¦° be replaced with its highest dominator in the circuit to produce ¦°. again  we have  i  and  ii  as above  and moreover . this implies that ¦° will be found by hdiag in step 1 by virtue of the completeness of hd1 in diagnosing ¦¨c. ¦° itself will then be found by substitutions in step 1 by virtue of the completeness of the diagnosis of cones  which can be easily established by induction as all diagnoses for cones are of cardinality one . 
1 experimental results
in order to compare the efficiency and scalability of our approach with that of  huang and darwiche  1   we ran both systems on a set of iscas-1 circuits using randomly generated diagnostic cases. for each circuit  we randomly generated a set of input/output vectors accordingly to the correct behavior of the circuit. we then randomly flipped k outputs  with k ranging from 1 to 1  in each input/output vector to get an  abnormal  observation  the minimum cardinality of the diagnoses was often close to the number of flipped outputs . all experiments were conducted on a 1ghz pentium 1 with 1gb of ram running on diskless linux  and a time limit of 1 hour was imposed on each experiment.
¡¡the results are given in table 1. the fourth column shows the number of health variables introduced by hdiag for the top-level diagnosis. recall that the baseline approach hd1 requires a health variable for every gate. it is clear that the proposed technique significantly reduces the number of health variables required. we also observe that for most circuits  hdiag was able to solve a significantly larger number of cases than hd1. in particular  hd1 could not solve any of the cases for the last two circuits  where hdiag succeeded. in the last two columns of the table  we also compare the running times of the two systems on cases they both solved. the new approach clearly results in better efficiency.
¡¡finally  we note that both programs reported exactly the same set of diagnoses for each case they both solved  as we expect given theorem 1.
circuitgatesconeshealth vars
for hdiagcasescases solvedtime on common caseshdiaghd1hdiaghd1c1111.1.1c1111.1.1c1111.1.1c1111.1.1c1111--c1111--table 1: comparing hdiag and hd1 on iscas-1 circuits.1 related work
in  smith et al.  1   the authors used satisfiability  sat  solvers to find single and double stuck-at faults in iscas-1 circuits. multi-plexers are injected ahead of each gate such that the selection line of the multi-plexer chooses between the original and the faulty output line from a particular gate. thus a satisfying assignment for the propositionaltheory projected on the multi-plexers is actually a diagnosis. the sat solver is restarted with an added clause to find multiple diagnoses. the cardinality of the diagnoses is enforced through an additional adder circuit involving the selection lines with a comparator to compare against the desired cardinality. to improve the performance  the task is divided into two phases. in the first phase  multi-plexers are injected only at the structural dominators of circuit. in the second pass  the faults are found in their respective fan-in cones. this way of exploiting the circuit structure is similar to our approach. however   smith et al.  1  reports results on only single and double stuck-at faults.
¡¡in  feldman and van gemund  1  a hierarchical diagnosis algorithm is developed and tested on reverse engineered iscas-1 circuits  hansen et al.  1  that are available in high-level form. the idea is to decompose the system into hierarchies in such a way as to minimize the sharing of variables between them. this can be done for well engineered problems and they have formed hierarchies by hand for iscas-1 circuits. the system is represented by a hierarchical cnf where each hierarchy is represented by a traditional cnf. this representation can be translated to a fully hierarchical dnf or a fully flattened dnf or a partially flattened dnf dictated by a depth parameter. after a hierarchical dnf is obtained  a hierarchical search algorithm is employed to find the diagnoses. there are similarities and obvious differences between this and our approach. one similarity is that both approachesaim to reduce the complexity of diagnosis by exploiting the structural hierarchy of the system to be diagnosed. one major difference is that hierarchical dnf is not decomposable and does not support some of the efficient operations that dnnf supports. we reduce the time and space complexity of the baseline approach while still computing the common diagnosis queries efficiently.
1 conclusions
from the model compilation viewpoint  the first benefit we gain is that we significantly reduce the number of health variables needed in the model  allowing the diagnosis to scale to larger circuits. as a related benefit  some parts of the circuits may never be analyzed since a cone is only analyzed if it is part of a diagnosis computed in the higher level. as a third benefit we can now produce the complete set of minimumcardinality diagnoses in a compact form  as a set of top-level diagnoses  each representing a class of diagnoses that can be obtained by substitutions. overall  our approach results in improved efficiency and scalability as demonstrated against a recent diagnosis tool on iscas-1 circuits.
acknowledgments
thanks to alban grastien  jussi rintanen  andrew slater  and the anonymous reviewers for their feedback on an earlier version of this paper. national ict australia is funded by the australian government's backing australia's ability initiative  in part through the australian research council.
