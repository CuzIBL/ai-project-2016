 
　　　this paper shows how an extension of the resolution proof procedure can be used to construct problem solutions. the extended proof procedure can solve problems involving state transformations. the paper explores several alternate problem representations and provides a discussion of solutions to sample problems including the  monkey and bananas  puzzle and the 'tower of hanoi  puzzle. the paper exhibits solutions to these problems obtained by qa1  a computer program bused on these theorem-proving methods. in addition  the paper shows how qa1 can write simple computer programs and can solve practical problems for a simple robot. 
key words: theorem proving  resolution  problem solving  automatic programming  program writing  robots  state transformations  question answering. 
　　　automatic theorem proving by the resolution proof procedure ′ represents perhaps the most powerful known method for automatically determining the validity of a statement of first-order logic. in an earlier paper green and raphael  illustrated how an extended resolution procedure can be used as a question answerer-e.g.  if the statement  1x p x  can be shown to follow from a set of axioms by the resolution proof procedure  then the extended proof procedure w i l l find or construct an x that satisfies p x . this earlier paper  1  showed how one can axiomatize simple question-answering subjects   1  described a question-answering program called qa1 based on this procedure  and  1  presented examples of simple question-answering dialogues with qa1 . in a more recent paper  the author  1  presents the answer construction method in detail and proves i t s correctness   1  describes the latest version of the program  qa1  and  1  introduces state-transformation methods into the constructive proof formalism. in addition to the question-answering applications illustrated in these earlier papers  qa1 has been used as an sri robot1 problem solver and as an automatic program writer. the purpose of this paper is 
this research is a part of project defender and was supported by the advanced research projects agency of the department of defense and was monitored by rome air development center under contracts af 1 -1 and f1-c-1. 
this preprint is a preliminary version and is subject to modification prior to publication. 
references are listed at the end of this paper. twofold:  1  to explore the question of predicate calculus representation for statetransformation problems in general  and  1  to elaborate upon robot and program-writing applications of this approach and the mechanisms underlying them. 
　　　exactly how one can use logic and theorem proving for problem solving requires careful thought on the part of the user. .judging from my experience  and that of others using qa1 and qa1  one of the f i r s t d i f f i c u l t i e s encountered is the representation of problems  especially statetransformation problems  by statements in formal logic. interest has been shown in seeing several 
detailed examples that illustrate alternate methods of axiomatizing such problems-i.e.  techniques for  programming  in first-order logic. this paper provides detailed examples of various methods of representation. after presenting methods in sees. i and i i   a solution to the classic  monkey and bananas  problem is provided in sec. i i i . next  sec. iv compares several a l ternate representations for the  tower of hanoi puzzle. two applications  robot problem solving and automatic programming  are discussed in sees. v and vi  respectively. 
	1. 	an introduction to 
state-transformation methods 
　　　the concepts of states and state transformations have of course been in existence for a long time  and the usefulness of these concepts for problem solving is well known. the purpose of this paper is not to discuss states and state transformations as such  but instead to show how these concepts can be used by an automatic resolution theorem prover. in practice  the employment of these methods has greatly extended the problemsolving capacity of qa1 and qa1. mccarthy and hayes present a relevant discussion of philosophical problems involved in attempting such formalizations . 
　　　first we w i l l present a simple example. we begin by considering how a particular universe of discourse might be described in logic. 
　　　facts describing the universe of discourse are expressed in the form of statements of mathematical logic. questions or problems are stated as conjectures to be proved. if a theorem is proved  then the nature of our extended theorem prover is such that the proof is  constructive - i . e .   if the theorem asserts the existence of an object then the proof finds or constructs such an object. 
　　　at any given moment the universe under consideration may be said to be in a given state. 
-1-
　　　we w i l l represent a particular state by a subscripted s-e.g.  s l 1 . the letter s  with no subscript  w i l l be a variable  ranging over states. a state is described by means of predicates. for example  if the predicate at objectx b s1  is true  then in state s1 the object  object!  is at position b. let this predicate be axiom al: a l . at  object! b s1   . 
the question  where is object! in state s!   can be expressed in logic as the theorem  r1x at object1 x s1  . the answer found by using system qa1 to prove this theorem is  yes  x = b. 
　　　changes in states are brought about by performing actions and sequences of actions. an action can be represented by an action function that maps states into new states  achieved by executing the action . an axiom describing the effect of an action is typically of the form 
 vs  p s  1 q f  s    
where s is a state variable p is a predicate describing a state f is an action function  corresponding to some action  that maps a state into a new state  achieved by executing the action  
q is a predicate describing the new state. 
 entities such as p and f are termed  situational fluents  by mccarthy.  
　　　as an example  consider an axiom describing the fact that object1 can be pushed from point b 
　　　to point c. the axiom is 
a1. 	 vs  at object 1 b s  	1 
at object! c push object! b c s   . 
the function push object! b c s  corresponds to the action of pushing object! f r o m b to c.  assume  for example  that a robot is the executor of these actions.  
　　　now consider the question   does there exist a sequence of actions such that object1 is at point c   equivalently  one may ask  'does there exist a state  possibly resulting from applying action functions to an i n i t i a l state s1  such that object1 is at point c   this question  in logic  is  1s at object1  c s    and the answer  provided by the theorem-proving program applied to axioms al and a1  is  yes  
s = push object  b f c s  .  suppose a third axiom1 indicates that objec1 can be pushed from c to d: 
a1. 	 vs  at object! c s  =  atcobject1 jdjpushfobject   c   d   s     l . 
together  these three axioms imply that starting in state s1   object1 can be pushed from b to c and then from c to d. this sequence of actions  a program for our robot  can be expressed by the composition of the two push functions  push object 1  c d push object 1  b c s 1   . the normal order of function evaluation  from the innermost function to the outermost  gives the 
correct sequence in which to perform the actions. 
　　　to find this solution to the problem of getting object1 to position d  the following conjecture is posed to the theorem prover:  does 
there exist a state such that object1 is atposition d   or  stated in logic
 1s at object1  d s  . 	the answer returned is 
 yes  s = push object 1  c d push object 1  b c s!  .  
　　　the proof by resolution  given below  demonstrates how the desired answer is formed as a composition of action functions  thus describing a sequence of necessary actions . the mechanism for finding this answer is a special l i t e r a l   * the  answer l i t e r a l .   this method of finding an answer is explained in detail in ref. 1. for our purposes here  we w i l l just show how it works by example. in the proof below  each answer l i t e r a l is displayed beneath the clause containing i t . at each step in the proof the answer l i t e r a l w i l l contain the current value of the object being constructed by the theorem prover. in this example the object being constructed is the sequence of actions s. so i n i t i a l l y the answer l i t e r a l answer s  is added to the clause representing the negation of the question.  one can interpret this clause  clause 1  as  either object1 is not at d in state s  or s is an answer.   the state variable s  inside the answer l i t e r a l   is the  place holder  where the solution sequence is constructed. the construction process in this proof consists of successive instantiations of 
s. an instantiation of s can occur whenever a l i t e r a l containing s is instantiated in the creation of a resolvent. each instantiation* of s f i l l s in a new action or an argument of an action function. in general  a particular inference step in the proof  either by factoring* or resolving*  need not necessarily further instantiate s. for example  the step might be an inference that verifies that some particular property holds for the current answer at that step in the proof. the final step in the proof yields clause 1   an answer is push object  c d push object  b c s         which terminates the proof. 
* 
we assume the reader is familiar with the vocabulary of the f i e l d of theorem proving by resolution as described in refs. 1  1  and 1. 

-1-

proof 
1 . 
1 . 1 . 
1. 
1. 
1. 
1. 	c o n t r a d i c t i o n 	resolve 	1 

       for the p a r t i c u l a r proof exhibited here  the order of generating the s o l u t i o n sequence during the search f o r the proof happens to be the same order in which the p r i n t o u t of the proof indicates s is i n s t a n t i a t e d . this order consists of working backward from the goal by f i l l i n g in the l a s t a c t i o n i then the n e x t - t o - l a s t a c t i o n   e t c . in general  the order in which the s o l u t i o n sequence is generated depends upon the proof s t r a t e g y   since the proof strategy determines the order in which clauses are resolved or f a c t o r e d . the 
proof t h a t t h i s method always produces correct answers  given in ref. 1  shows that the answers are c o r r e c t regardless of the proof strategy used. 
	i i . 	refinements of the method 
       the purpose of t h i s section is to discuss v a r i a t i o n s of the formulation presented in the previous s e c t i o n and to show how other considerat i o n s such as time and c o n d i t i o n a l operations can be brought i n t o the formalism. the reader who is i n t e r e s t e d i n a p p l i c a t i o n s r a t h e r than a d d i t i o n a l m a t e r i a l on representation may omit sees. i i   i i i   and iv  and read sees. v and v i . 
a. 	an a l t e r n a t e formulation 
       the f i r s t subject we s h a l l discuss is an a l t e r n a t e to the previously given f o r m u l a t i o n . we s h a l l r e f e r to the o r i g i n a l   presented in sec. i  as f o r m u l a t i o n i  and t h i s a l t e r n a t e as f o r m u l a t i o n i i . formulation i i corresponds t o a system-theoretic notion of s t a t e t r a n s f o r m a t i o n s . the s t a t e transformation f u n c t i o n f o r a system gives the mapping of an a c t i o n and a s t a t e i n t o a new s t a t e . let f represent the s t a t e t r a n s f o r mation f u n c t i o n   whose arguments are an a c t i o n 
and a s t a t e and whose value is the new s t a t e 
obtained by applying the a c t i o n to the s t a t e . let  a1  be the a c t i o n s   and n i l be the n u l l a c t i o n . let g be a f u n c t i o n t h a t maps two actions i n t o a s i n g l e composite a c t i o n whose e f f e c t is the same as t h a t of the argument actions applied s e q u e n t i a l l y . for example  axioms of the f o l l o w ing form would p a r t i a l l y define the s t a t e t r a n s formation f u n c t i o n f : 
b l . 	 vs  p s  =  q f   a i  s  l 
b1. 	  v s     f   n i l   s   	= si 
b1. 	  v s   a 1   a j     f   a j   f   a 1   s     	= f   g    a    s    . 
     the predicates p and q represent d e s c r i p t o r s of s t a t e s . 	axiom bl describes the r e s u l t of an action a x 	applied to the class of states that are equivalent in that they a l l have the property p s  . 	the r e s u l t i n g states are thus equivalent in that they have property q   s   . 	axiom b1 i n d i cates t h a t the n u l l a c t i o n has no e f f e c t . 	the equation in b1 says t h a t the e f f e c t of the composite a c t i o n sequence 	g a a 1 .  	is the same as t h a t of actions a1 and 	aj 	applied s e q u e n t i a l l y . the question posed in t h i s formulation can include an i n i t i a l s t a t e - e . g .   	a question might 
be   meaning  does there e x i s t a 
sequence of actions x that maps s t a t e sy i n t o a 
s t a t e s a t i s f y i n g the predicate q   observe that we are not i n s i s t i n g on f i n d i n g a p a r t i c u l a r sequence of a c t i o n s   but any sequence that leads us to a s a t i s f a c t o r y s t a t e w i t h i n the t a r g e t class of s t a t e s . 
     this representation is more complex  but has the advantage over the previous r e p r e s e n t a t i o n that both the s t a r t i n g s t a t e of a transformation and the sequence of actions are e x p l i c i t l y given as the arguments of the s t a t e - t r a n s f o r m a t i o n f u n c t i o n . thus  one can q u a n t i f y over  or specify i n p a r t i c u l a r   e i t h e r the s t a r t i n g s t a t e o r the sequence  or b o t h . 
     next we s h a l l show how other considerations can be brought i n t o a s t a t e - t r a n s f o r m a t i o n f o r m a l ism. both the o r i g i n a l f o r m u l a t i o n  i  and the a l t e r n a t e   i i   w i l l be used as needed. 
b. no change of state 
     this kind of statement represents an i m p l i c a t i o n t h a t holds f o r a f i x e d s t a t e . an axiom t y p i c a l of t h i s class might describe the r e l a t i o n ship between movable o b j e c t s ; e . g .   if x is to the l e f t of y and y is to the l e f t of z  then x is to the l e f t o f z . 

c. time 
     time can be a f u n c t i o n of a s t a t e   to express the t i m i n g of actions and s t a t e s . 	for example  	if the f u n c t i o n time s  	gives the time of an 

- 1 1 -

the above figure shows that action i leads to either b or c from a. the function f is singlevalued but we don't know its value. the goal d can be reached from b by action j  or from c by action k. in the formalization given below it is possible to prove that the goal is reachable although a correct sequence of actions necessary 
-1-



that a conditional operation is needed to create a single conditional answer. this information provides a useful heuristic for the program-writing applications of qa1: when a clause having two answer l i t e r a l s is about to be generated  let the proof strategy call for the axioms that describe the conditional operation  such as m1 and m1 . these axioms are then applied to create a single conditional answer. 
　　　waldinger and lee have implemented a programwriting program prow that also uses a resolution theorem prover to create constructive proofs  but by a different method than that of qa1.  the second method for creating conditionals by combining two answers is closely related to a technique used in prow.  information about  1  the target program operations   1  the general relationship of the problem statement and axioms to the allowed target program operations including the test conditions  and  1  the syntax of the target language  is embedded in the prow program. in qa1 this information is a l l in the axioms-such as axioms m1  m1  and m1. 
h. 	acquisition of information 
where path a b i  means that i is a path from a 
to b. 	the question  1s at c s  results in the solution  

　　　axiom n1 illustrates an important aspect of this formalism for problem solving: if a condition  such as the robot's  is made state dependent  then we must specify how this condition changes when the state is changed. thus in axiom n1 we must indicate that the robot's location is not changed by asking for a path. in a pure theoremproving formalism  this means that if we want to know any condition in a given state  we must prove what that condition i s . if a large number of state-dependent conditions need to be known at each state in a solution  then the theorem prover must prove what each condition is at each state in a conjectured solution. in such a case the theorem prover w i l l take a long time to find the solution. mccarthy refers to this problem as the frame problem  where the word  frame  refers to the frame of reference or the set of relevant conditions. discussion of a method for easing this problem is presented in sec. v. 

　　another situation that arises in problem solving is one in which at the time the problem is stated and a solution is to be produced  there is insufficient information to completely specify a solution. more precisely  the solution cannot name every action and test condition in advance. as an example  consider a robot that is to move from a to c. the action i leads from a to b but no path to c is known  as illustrated below. 
1. 	assignment operations 
　　　an assignment operation is one that assigns a value to a variable. an example of an assign-
ment is the statement a  - h a    meaning that the value of a is to be changed to the value of the function h a . in our representation  we shall use an assignment function-i.e.  assign a h a   . using formulation ii this function is described by the axiom 

however  once point b is reached  more information can be acquired-for example  a guide to the area 
lives at b and w i l l provide a path to point c if asked. 	or perhaps once point b is reached  the 
robot might use i t s sensors to observe or discover paths to c. 
　　　to formalize t h i s   assume that the action ask-path b c  w i l l result in a proper path to c  
when taken at b. for simplicity  assume that the name of the path is equal to the state resulting from asking the question. using formulation i i   
	i i i . 	an example: 
the monkey and the bananas 
　　　to i l l u s t r a t e the methods described earlier  we present an axiomatization of mccarthy's  monkey and bananas  problem. 
　　　the monkey is faced with the problem of getting a bunch of bananas hanging from the ceiling just beyond his reach. to solve the problem  the 
monkey must push a box to an empty place under the bananas  climb on top of the box  and then reach them. 

one suitable set of axioms i s : 
1-

　　　the constants are monkey  box  bananas  and under-bananas. the functions are reach  c l i m b   and 
move  meaning the f o l l o w i n g : 
reach m z s  the s t a t e r e s u l t i n g from the action of m reaching z  s t a r t ing from state s 
climb m b s  	the s t a t e r e s u l t i n g from the action of m climbing b  s t a r t ing from s t a t e s 
move m b u s  the s t a t e r e s u l t i n g from the a c t i o n of m moving b to place u  s t a r t i n g from s t a t e s. 
the predicates are: 
	movable b  	 b is 	movable 
	at m u s  	m is at place u in s t a t e s 
	on m b s  	m is on b in s t a t e s 
has m z s  m has z in state s climbable m b s  m can climb b in s t a t e s 
reachable m b s  m can reach b in state s. 
the axioms 	a r e : 
mb1. movable box  
mb1. 
the question is  does there exist a state s  sequence of actions  in which the monkey has the bananas   
question: 
the answer is yes  s = reach monkeyibananas climb monkey  
box move monkey box under-bananas 
　　　by executing this function  the monkey gets the bananas. the monkey must  of course  execute the functions in the usual order  starting with the innermost and working outward. thus he f i r s t moves the box under the bananas  then climbs on the box  and then reaches the bananas. 
　　　the printout of the proof is given in the appendix. 
 iv. formalizations for the tower of hanoi puzzle 
　　　the f i r s t applications of our questionanswering programs were to  question-answering  examples. commonly used question-answering examples have short proofs  and usually there are a lew obvious formulations for a given subject 

area. 	 the major d i f f i c u l t y in question-answering problems usually is searching a large data base  rather than finding a long and d i f f i c u l t proof.  
typically any reasonable formulation works well. as one goes on to problems like the tower of hanoi puzzle  more effort is required to find a representation that is suitable for efficient problem solving. 
　　　this puzzle has proved to bo an interesting study of representation. several people using qa1 have set up axiom systems for the puzzle. apparently  a  good  axiomatization--one leading to quick solutions--is not entirely obvious  since many axiomatizations did not result in solutions. in this section we w i l l present and compare several alternate representations  including ones that lead to a solution. 
　　　there are three pegs-pegx  peg1  and peg1. there are a number of discs each of whose diameter is different from that of a l l the other discs. i n i t i a l l y a l l discs are stacked on pegx  in order of descending size. the three-disc version is 
illustrated below. 
* the astute reader w i l l notice that the axioms leave much to be d e s i r e d . 	in keeping w i t h the  toy problem  t r a d i t i o n we present an u n r e a l i s t i c 	axiomatization o f t h i s u n r e a l i s t i c problem. the problem's value l i e s in the f a c t that it 	is a reasonably i n t e r e s t i n g problem that may be f a m i l i a r to the reader. 
-1-

the object of the puzzle is to find a sequence of moves that w i l l transfer a l l the discs from peg1 to peg1. the allowed moves consist of taking the top disc from any peg and placing it on another peg  but a disc can never be placed on top of a smaller disc. 
　　　in order to correctly specify the problem  any formalization must: 	 1  specify the positions of the discs for each state;  1  specify how actions change the position of the discs; and  1  specify the rules of the game  i . e .   what is legal. 
　　　let the predicate on specify disc positions. in the simplest representation the predicate on specifies the position of one disc-e.g.  on disc peg   s  says that in state s disc 1 is on peg1. this representation requires one predicate to specify the position of each disc. the relative position of each disc either must be specified by another statement  or else if two 
discs are on the same peg it must be implicitly understood that they are in the proper order. perhaps the simplest extension is to allow the predicate another argument that specifies the position of the d i s c - i . e .   
on disc1 peg  positiong s . again  this requires many statements to specify a complete configuration. 
　　　since various moves are constructing stacks of discs  and since stacks can be represented as l i s t s   consider as an alternative representation a l i s t to represent a stack of discs. let the function l x y  represent the l i s t that has x as i t s f i r s t element  representing the top disc in the stack  and y as the rest of the l i s t  representing the rest of the discs in the stack . this function i corresponds to the  cons  function in lisp. let n i l be the empty l i s t . the state-
ment on i  disc1     d i s c 1   n i l      pegx  s  asserts that the stack having top disc  disc x   and second disc  discg   is on peg-1 . this representation illustrates a useful technique in logic-namely  the use of functions as the construction  and selection  operators. this notion is consistent with the use of action functions as constructors of sequences. 
　　　next  consider how to express possible changes in states. perhaps the simplest idea is to say that a given state implies that certain moves are legal. one must then have other statements indicating the result of each move. this method is a b i t lengthy. it is easier to express in one statement the fact that given some state  a new state is the result of a move. thus one such move to a new state is described by  vs  on   k d i s c 1 n i l   jpeg 1 s  a on nil.pegg s  a on l disc 1   j♀ disc1   n i l      peg1  s  1 on nil peg1  move disc1   peg1  pega  s   a o n   d i s   inil   peg1  move disc1   peg1pegg  s   a 1n l disc 1  je disc 1  nil    peg1  move disc1 peg1  pegg s    . 
 vs x y z p 1 pj .  pk d  on l d x  .pi s  a on y p  s  
a on z pk s  1 on x pi move d pi p1  s   a 1n l  d y  p .  move d p1 p. s   a on z p k  move d p i  pj  
s    specifies a whole class of moves. the problem here is that additional restrictions must be added so that i l l e g a l states cannot be part of a solution  in the previous formalism  one could let the axioms enumerate just the legal moves and states  thus preventing incorrect solutions. 
　　　the f i r s t method for adding restrictions is to have a predicate that restricts moves to just the legitimate states. since the starting state is legal  one might think that only legal states can be reached. however  the resolution process  set-of-support strategy   typically works backward from the goal state toward states that can reach the goal state-such states are sometimes called  forcing states.  thus illegal but forcing states can be reached by working backward from the goal state. this does not allow for incorrect solutions  since the only forcing states that can appear in the solution must be those reached from the starting state  which is a legal state  . the restriction of moving only to new legal states thus prevents an error. but the search is unnecessarily large  since the theorem prover is considering i l l e g a l states that cannot lead to a solution. so a better solution is to eliminate these illegal forcing states by allowing moves only from legal states to  legal states. this is perhaps the best specification  in a sense. such an axiom is  vs x y z p i  p .  p k  d  1n 1 d x  p i   
s  a on y pj s  a on z p k  s  a legal l d x   a 
legal x d y   a distinct p. p  p   1n x p   
	1 	j 	k 	1 
move d p  p  s   a o n   1   d   y     p .   m o v e   d   p i   p p s  
a on z p  move d p  p  s    . the predicate legal x  is true if and only if the discs are listed in order of increasing size.  one can  cheat  and have a simpler axiom by omitting the predicate that requires that the state resulting from a move have a legal stack of discs. since the set-of-support strategy forces the theorem prover to work backward starting from a legal final state  it w i l l only consider legal states. however  one is then using an axiomatization that  by i t s e l f   is incorrect.  the additional legal predicate is a typical example of how additional information in the axioms results in a quicker solution. the predicate distinct p. p. pk  means no two pegs are equal. 
　　　the clauses generated during the search that are concerned with illegal states are subsumea by ~legal predicates such as  vs ~legal ♀ disc1    disc 1  x   . 	the stacks are formed by placing one new disc on top of a legal stack. 	if the new top disc is smaller than the old top disc then it is of course smaller than a l l the others on the stack. 	thus the legal stack axioms need only to 

　　　with this method it is possible to enumerate a l l possible moves and configuration combinations. however  it is s t i l l easier to use variables to represent whole classes of states and moves. thus specify that the top disc is smaller than the second disc for a stack to be legal . this blocks the construction of incorrect stacks. 

one complete axiomatization is as follows: 

　　　instead of naming each disc  the disc number n is an argument of the function d n  that represents the nth disc. this representation i l l u s trates how the proof procedure can be shortened by solving frequent decidable subproblems with special available tools-namely  the lisp programming language. the theorem prover uses lisp  the  lessp  function  to evaluate the less n m  predicate-a very quick step. this mechanism has the effect of generating  wherever needed  such axioms as ~less 1  or less 1  to resolve against or subsume literals in generated clauses. similarly  lisp evaluates the distinct predicate. 
　　　note that the move axiom  ax1  breaks up into three clauses  each clause specifying the change in the task for one particular peg. 	the process of making one move requires nine binary resolutions  and two binary factorings of clauses. 
　　　s t i l l other solutions are possible by using special term-matching capabilities in qa1 that extend the unification and subsumption algorithms to include l i s t terms  set terms  and certain types of symmetries. 
　　　in another axiomatization  the complete configuration of the puzzle in a given state is 
specified by the predicate on. 	on'  means that in state s  stack x in on peg1  stack y is on peg1  and stack z is on peg1. 	thus if the predicate 
holds  the stack d1 - d1 is on pegx and d1 is on peg1. the predicate legal again indicates that a given stack of discs is allowed. 

　　　in this last-mentioned formalization  using 1 axioms to specify the problem  qa1 easily solved this problem for the three-disc puzzle. during the search for a proof  1 clauses were generated buy only 1 of the clauses were accepted. of the 1  1 were not in the proof. the solution entails seven moves  thus passing through eight states  counting the i n i t i a l and final states  . the 1 clauses not in the proof correspond to searching through 1 states that are not used in the solution. thus the solution is found rather easily. of course  if a sufficiently poor axiomatization is chosen-one requiring an enumeration of enough correct and incorrect disc positions- the system becomes saturated and fails to obtain a solution within time and space constraints. an important factor in the proof search is the elimination of extra clauses corresponding to alternate paths that reach a given state. in the above problem it happens that the subsumption heuristic eliminates 1 of these redundant clauses. however  this particular use of subsumption is problem dependent  thus one must examine any given problem formulation to deter-
mine whether or not subsumption w i l l eliminate alternate paths to equivalent states. 
　　　the four-disc version of the puzzle can be much more d i f f i c u l t than the three-disc puzzle in terms of search. at about this level of 
d i f f i c u l t y one must be somewhat more careful to obtain a low-cost solution. 
　　　ernst formalizes the notion of  difference  used by gps and shows what properties these differences must possess for gps to succeed on a problem. he then presents a  good  set of differences for the tower of hanoi problem. utilizing this information  gps solves the problem for four discs  considering no incorrect states in its search. thus ernst has chosen a set of differences that guide gps directly to the solution. 
　　　another method of solution is possible. first  solve the three-disc puzzle. save the solution to the three-disc puzzle  using the answer statement  . then ask for a solution to the four-disc puzzle. the solution then i s : move the top three discs from peg1 to peg1   m o v e disc1 from peg1 to peg1 ; move the three discs on peg1 to peg1 . this method produces a much easier solution. but this can be considered as cheating  since the machine is  guided  to a solution by being told which subproblem to f i r s t solve and store away. the use of the differences by gps similarly lets the problem solver be  guided  toward a solution. 
　　　there is another possibly more desirable solution. the four-disc puzzle can be posed as the problem  with no three-disc solution. if the solution of the three-disc puzzle occurs during the search for a solution to the four-disc puzzle  and if it is automatically recognized and saved as a lemma  then the four-disc solution should follow easily. 
　　　finally  if an induction axiom is provided  the axioms imply a solution in the form of a recursive program that solves the puzzle for an arbitrary number of discs. aiko hormann discusses the related solutions of the four-disc problem by the program gaku  not an automatic theorem-proving program . the solutions by lemma finding  induction  and search guided by differences have not been run on qa1. 
　　　　v. applications to the robot project a. introduction to robot problem solving 
　　　in this section we discuss how theorem-proving methods are being tested for several applications in the stanford research institute a r t i f i c i a l intelligence group's automaton  robot . we emphasize that this section describes work that is now in progress  rather than work that is completed. these methods represent explorations in problem solving  rather than f i n a l decisions about how the robot is to do problem solving. an overview of the current status of the entire sri robot project is provided by nilsson . coles has developed an english-to-logic translator that is part of the robot. 
　　　we use theorem-proving methods for three purposes  the simplest being the use of qa1 as a central information storage and retrieval system that is accessible to various parts of the system as well as the human users. the data base of qa1 is thus one of the robot's models of i t s world  including i t s e l f . 
　　　a second use is as an experimental tool to test out a particular problem formulation. when a suitable formulation is found  it may then be desirable to write a faster or more efficient specific program that implements this formulation  perhaps involving l i t t l e or no search. if the special program is not as general as the axiom system i s   so that the special program f a i l s in certain cases  the axioms can be retained to be used in the troublesome cases. both solutions can be made available by storing  as the f i r s t axiom to be t r i e d   a special axiom that describes the special solution. the predicate-evaluation mechanism can then call lisp to run the special solution. if it f a i l s   the other axioms w i l l then be used. 
　　　the third use is as a real-time problem solver. in the implementation we are now using  statements of logic-clauses-are the basic units of informat i o n . statements are derived from several sources: teletype entries  axioms stored in memory  clauses or statements generated by the theorem prover  and statements evaluated by programs-subroutines in lisp  fortran  or machine language. these 
programs can use robot sensors and sensory data to verify  disprove  or generate statements of logic. 
　　　the sri robot is a cart on wheels  having a tv camera and a range-finder mounted on the cart. there are bumpers on the cart  but no arms or grasping agents  so the only way the robot can manipulate i t s environment is by simple pushing actions. given this rather severe restriction of no grasping  the robot must be clever to effectively solve problems involving modifying i t s world. we present below some axioms for robot problem solving. 
　　　the f i r s t axiom describes the move r o u t i n e s of the r o b o t : 
r l . 
this axiom says t h a t if the robot is and there is a path to p 1   the robot w i l l be at p 1 a f t e r moving along the p a t h . the predicate path i n d i c a t e s t h e r e e x i s t s a r o b o t - p a t h   p a t h l 1   from place p1 to place . a r o b o t - p a t h is a path adequate f o r the r o b o t ' s movement. the terms a n d d e s c r i b e the p o s i t i o n o f the r o b o t . 
       in g e n e r a l   	it may be very i n e f f i c i e n t to use the theorem prover to f i n d the 	path 1 	such t h a t path p  p   p a t h l 1   	is t r u e . 	several e x i s t i n g fortran subroutines  	having s o p h i s t i c a t e d 
problem-solving c a p a b i l i t i e s of t h e i r own  may be used to determine a good path through obstacles on l e v e l ground. we w i l l show l a t e r a case where the theorem prover may be used to f i n d a more obscure kind of p a t h . for the less obscure paths  the axiom rl is merely a d e s c r i p t i o n of the semantics of these fortran programs  so t h a t new and meaningful programs can be generated by qa1 by using the e f f i c i e n t path-generating programs as subprograms. the   p r e d i c a t e - e v a l u a t i o n   mechanism is used to c a l l the fortran p a t h f i n d i n g r o u t i n e s . the e f f e c t o f t h i s e v a l u a t i o n mechanism is the same as if the f a m i l y of axioms of the form path  f o r a l l p 1 and 
p1 such t h a t p a t h l 1 e x i s t s   were a l l stored in memory and a v a i l a b l e to the theorem prover. 
       the second axiom is a push axiom t h a t describes the e f f e c t of pushing an o b j e c t . the robot has no arm or graspers  j u s t a bumper. i t s world c o n s i s t s of l a r g e o b j e c t s such as boxes  wedges  cubes  e t c . these objects are roughly the same size as the robot i t s e l f . 
       the basic p r e d i c a t e that s p e c i f i e s the p o s i t i o n of an object is ato  meaning a t - o b j e c t . the p r e d i c a t e 

i n d i c a t e s t h a t o b j e c t 1   having s t r u c t u r a l d e s c r i p t i o n   d e s c r i p t i o n     i s i n p o s i t i o n   p o s i t i o n 1 '   in s t a t e '. at the time of t h i s w r i t i n g   a p a r t i c u l a r set o f   s t a n d a r d   s t r u c t u r e d e s c r i p t i o n s has not yet been s e l e c t e d . so f a r several have been used. the simplest d e s c r i p t i o n is a 
p o i n t whose p o s i t i o n is at the estimated center o f g r a v i t y o f the o b j e c t . this d e s c r i p t i o n i s used f o r the fortran  push in a s t r a i g h t l i n e   r o u t i n e . since a l l the o b j e c t s i n the r o b o t ' s world are polyhedrons  reasonably simple complete s t r u c t u r a l d e s c r i p t i o n s are p o s s i b l e . for example  one s t r u c t u r a l d e s c r i p t i o n consists of t h e set of polygons t h a t form the surface of the polyhedron. in turn the s t r u c t u r e of the polygons is given by the set o f v e r t i c e s i n i t s boundary. c o n n e c t i v i t y of s t r u c t u r e s can be s t a t e d e x p l i c i t l y or else 

implied by common boundaries. the position of an object is given by a mapping of the topologicallydescribed structure into the robot's coordinate system. such structural descriptions may be given as axioms or supplied by the scene-analysis programs used by the robot. 
　　　a basic axiom describing the robot's manipulation of an object is r1. 
  
　　this axiom says that if object 1  described by description 1  is at position 1  and object 1 is movable  and object 1 can be theoretically 
rotated and translated to the new position 1  and there is an object-path from 1 to 1  then object 1 
w i l l be at position 1 as a result of pushing it along the path. the predicate rotate-translatable  desc1 pos1 pos1  checks the necessary condition that the object can be theoretically rotated and translated into the new position. the predicate 
object-path desc1 pos1 pos1 path1  means that pos1 is the estimated new position resulting from pushing along push-path  
　　let us now return to the frame problem. 	more specifically  in a state resulting from pushing an object  how can we indicate the location of objects which were not pushed  	one such axiom is r1. 
this axiom says that a l l objects that are not the same as the pushed object are unmoved. the predicate evaluation mechanism is used to evaluate same and speed up the proof. one can use this predicate evaluation mechanism  and perhaps other fast 
methods for handling classes of deductions  such as special representations of state-dependent information and special programs for updating this information-which is done in the robot    but another problem remains. 	observe that axiom r1 assumes that only the objects directly pushed by the robot move. 	this is not always the case  since an object being pushed might accidentally strike another object and move i t . 	this leads to the question of dealing with the real world and using axioms to approximate the real world. 
b. 	real-world problem solving: 	feedback 
　　　our descriptions of the real world  axiomatic or otherwise  are at best only approximations. for example  the new position of an object moved by the robot w i l l not necessarily be accurately predicted  even if one goes to great extremes to calculate a predicted new position. the robot does not have a grasp on the object so that some slippage may occur. the floor surface is not uniform and smooth. the weight distribution of objects is not known. there is only rudimentary kinesthetic sensing feedback-namely  whether or not the bumper is s t i l l in contact with the object. thus it appears that a large feedback loop iterating toward a solution  is necessary: form a plan for pushing the object  possibly using the push axiom   push according to the plan  back up  take a look  see where the object i s   compare the position to the desired position  start over again. the new position  to some level of accuracy  is provided by the sensors of the robot. this new position is compared to the position predicted by the axiom. if the move is not successful  the predicate  provided by sensors in the new state  that reasonably accurately gives the object's position in the new state must be used as the description of the i n i t i a l state for the next attempt. 
　　this feedback method can be extended to sequences of actions. 	consider the problem: find sf such that 	is true. 	suppose the starting state is sq  with property suppose the axioms are as follows: 
	the sequence of actions 	trans-
forms state so with property po so  into state having property 
corresponding to each  theoretical  predicate 
is a corresponding  real-word  predicate 
         the truth value of is determined by sensors and the robot's internal model of the world. it has b u i l t - i n bounds on how close its measurements must be to the correct values in order to assert that it is true.* the proof 
implies the following description of the result after each step of execution of 

at this time  a many-valued logic having degrees of truth is not used  although this is an interesting possibility. 

new information is present  such as is the case when the robot hits an obstacle that is not in i t s model  the model is updated before a new solution is attempted. the position of this new object of course invalidates the previous plan-i.e.  had the new object's position been known  the previous plan would not have been generated. 
　　　the new solution may s t i l l be able to use that part of the old solution that is not i n v a l i dated by any new information. for example  if p 1 holds  it may s t i l l be possible to reach the jth intermediate state and then continue the planned sequence of actions from the jth state. however  the object-pushing axiom is an example of an axiom that probably w i l l incorrectly predict results and yet no further information  except for the new position  w i l l be available. for this case  the best approach is probably to iterate toward the target state by repeated use of the push axiom to generate a new plan. hopef u l l y   the process converges. 
　　　for a given axiomatization feedback does not necessarily make it any easier to find a proof. however  knowing that the system uses feedback allows us to choose a simpler and less accurate axiom system. simple axiom systems can then lead to shorter proofs. 
　　　one can envision formalizing this entire problem-solving process  including the notion of feedback  verifying whether or not a given condition is met  updating the model  recursively calling the theorem prover  etc. the author has not attempted such a formalization  although he has written a first-order formalization of the theorem prover's own problem-solving strategy. this raises the very interesting possibility of self-modification of strategy; however  in practice such problems l i e well beyond the current theorem-proving capacity of the program. 
c. 	a simple robot problem 
　　　now let us consider a problem requiring the use of a ramp to r o l l onto a platform  as i l l u s trated below. 
　the goal is to push the box b1 from position to x1 . to get onto the platform  the robot 
must push the ramp  to the platform  and then r o l l up the ramp onto the platform. 
　　　a simple problem formulation can use a special ramp-using axiom such as r1. 
with the obvious meaning. quick but leaves much to be desired in terms of generality. 
　　　a more general problem statement is one in which the robot has a description of i t s own capabilities  and a translation of this statement of its abilities into the basic terms that describe its sensory and human-given model of the world. it then learns from a fundamental level to deal with the world. such a knowledge doesn't 
make for the quickest solution to a frequentlyencountered problem  but certainly does lend itself to learning  greater degrees of problemsolving  and self-reliance in a new problem situation. 
　　　closer to this extreme of greatest generality is the following axiomatization. 
r1. 
this axiom says that r describes a rectangle having ends x a n d t h e maximum slope is less than a constant the robot's width w1   the space above r to the robot's height hq is clear  and the rectangle r has a solid surface. 
two paths can be joined as follows: 

r1. 
　　　from these two axioms  r1 and r1    the push axiom  r1   and a recognition of a solid object that can be used as a ramp  a solution can be obtained in terms of climb  push  join  etc. this more general method of solution would of course be slower than using the special ramp axiom. on the other hand  the more general method w i l l probably be more useful if the robot w i l l be required to construct a ramp  or recognize and push over a potential ramp that is standing on its wide end. 
　　　the danger in trying the more general methods is that one may be asking the theorem prover to rederive some significant portion of math or physics  in order to solve some simple problem. 
	v i . 	automatic programming 
a. 	introduction 
　　　the automatic writing  checking  and debugging of computer programs are problems of great interest both for their independent importance and as useful tools for intelligent machines. this section shows how a theorem prover can be used to solve certain automatic programming problems. the formalization given here w i l l be used to precisely state and solve the problem of automatic generation of programs  including recursive programs  along with concurrent generation of proofs of the correctness of these programs. thus any programs automatically written by this method have no errors. 
　　　we shall take lisp  ' as our example of a programming language. in the lisp language  a function is described by two entities:  1  its value  and  1  its side effect. side effects can be described in terms of their effect upon the state of the program. methods for describing state-transformation operations  as well as methods for the automatic writing of programs in a state-transformation language  were presented in secs. i and i i . for simplicity  in this section we shall discuss  pure  lisp  in which a lisp function corresponds to the standard notion of a 
　　　function-i.e.  it has a value but no side effect. 
　　　thus we shall use pure lisp 1 without the program feature  which is essentially the lambda calculus. in this restricted system  a lisp program is merely a function. for example  the lisp function car applied to a l i s t returns the f i r s t element of the l i s t . thus if the variable x has as value the l i s t  a b c   then car x  = a. the lisp function cdr yields the remainder of the l i s t   thus cdr x  =   b e     and car cdr x   = b. there are several approaches one may take in formalizing lisp; the one given here is a simple mapping from lisp's lambda calculus to the predicate calculus. lisp programs are represented by functions. the syntax of pure lisp 1  is normal function composition  and the corresponding syntax for the formalization is also function composition. lisp  predicates  are represented in lisp-and in this formalization-as functions having either the value nil  false  or else a value not equal to nil  true . the semantics are given by axioms relating lisp functions to l i s t structures  e.g.   vx y car cons x y   = x  where cons x y  is the l i s t whose f i r s t element is x and whose remainder is y. 
　　　in our formulation of programming problems  we emphasize the distinction between the program  represented as a function in lisp   that solves a problem and a test for the validity of a solution to a problem  represented as a predicate in logic . it is often much easier to construct the predicate than it is to construct the function. indeed  one may say that a problem is not well defined until an effective test for its solution is provided. 
　　　for example  suppose we wish to write a program that sorts a l i s t . this problem is not fully specified until the meaning of  sort  is explained; and the method of explanation we choose is to provide a predicate r x y  that is true if l i s t y is a sorted version of l i s t x and false otherwise.  the precise method of defining this relation r w i l l be given later.  
　　　in general  our approach to using a theorem prover to solve programming problems in lisp requires that we give the theorem prover two sets of i n i t i a l axioms : 
　　　 1  axioms defining the functions and constructs of the subset of lisp to be used 
　　　 1  axioms defining an input-output relation such as the relation r x y   which is to be true if and only if x is any input of the appropriate form for some lisp program and y is the corresponding output to be produced by such a program. 
　　　given this relation r  and the lisp axioms  by having the theorem prover prove  or disprove  the appropriate question we can formulate the following four kinds of programming problems: checking  simulation  verifying  debugging   and program writing. these problems may be explained using the sort program as an example as follows: 
  1  checking: the form of the question is r a b  where a and b are two given l i s t s . by proving r a b  true or false  is checked to be either a sorted version of a  or not. the desired answer is accordingly either yes or no. 
  1  simulation: 	the form of the question is  1x r a x   where a is a given input l i s t . 	if 
the question  is answered yes  then a sorted version of x exists and a sorted version is constructed by the theorem prover. 	thus the theorem prover acts as a sort program. 	if the answer is no  then it has proved that a sorted version of x does not exist  an impossible answer if a is a proper l i s t   . 
 the form of the question is vhere g x  is a program written 

	d e r i v a b l e from o t h e r s   	but are included f o r c l a r -
by the user. this mode is known as v e r i f y i n g   dei t y . the v a r i a b l e s x  y  and z are bound by 
bugging  p r o v i n g a program c o r r e c t   or proving a u n i v e r s a l q u a n t i f i e r s   	but t h e q u a n t i f i e r s are 
program i n c o r r e c t . 	if the answer to 	 vx r x g x   omitted f o r the sake of r e a d a b i l i t y wherever is yes  	then g x  	s o r t s every proper input l i s t and p o s s i b l e . 	the f o r m u l a t i o n is given below: 

the program is c o r r e c t . if the answer is no  a 
counterexample l i s t c  that the program w i l l not 
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　predicates s o r t   must be constructed by the theorem prover. this mode r e q u i r e s i n d u c t i o n axioms to prove t h a t 
looping or r e c u r s i v e programs converge. 	null x  
list x  
	 1  program w r i t i n g : 	the form of the question is 
                                                                       atom x    v x     e y   r   x   y   . 	in t h i s synthesis mode the program is to be constructed or else proved impossible to 	x = y c o n s t r u c t . 	if the answer is yes  then a program  say f   x     must be constructed that w i l l sort a l l 	functions 

meaning x = n i l x is a l i s t x is an atom x is equal to y 
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　meaning proper input 	l i s t s . 	if the answer is no  an unsortable l i s t 	  i m p o s s i b l e   	in t h i s case  must be p r o -	car x  	the f i r s t 	element of the l i s t x. duced. 	this mode also requires i n d u c t i o n axioms. 
	cdr x  	the rest of the l i s t x. 
the form of the problem statement shown here is o v e r s i m p l i f i e d f o r the sake of c l a r i t y . the exact cons x y  if y is a l i s t then the value of form w i l l be shown l a t e r . cons x y  is a new l i s t t h a t has 
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　x as i t s f i r s t element and y as in a d d i t i o n to the p o s s i b i l i t y of 	 yes  answer 	the r e s t o f the l i s t   	e . g .   and the  no  answer  there is always the p o s s i b i l -	c o n s   l     1   	= 	  1 1   . 	if y is i t y of a 	 no proof found  answer if the search is 	an atom instead of a l i s t   halted by some time or space bound. 	the e l i m i n a -	cons x y  has as value a  dotted t i o n of d i s j u n c t i v e answers  which is assumed in 	p a i r     e . g .   c o n s   l   1   	= 	  1 - 1   . t h i s s e c t i o n   was explained in sec. b. 
cond x y z  	the c o n d i t i o n a l statement  	if x = n i l then y else z. 	note t h a t the 
these methods are summarized in the f o l l o w i n g syntax o f t h i s f u n c t i o n i s s l i g h t l y 
t a b l e . the reader may view r x y  as representing d i f f e r e n t than the usual lisp syntax 
some general desired input-output 	r e l a t i o n s h i p . 
	n i l 	the n u l l 	 empty  	l i s t c o n t a i n i n g no 
	programming 	form of 	desired 	elements. 
	problem 	question 	answer 	equal x y  	e q u a l i t y t e s t   whose value i s 	  n i l   
if x does not equal y. 
 1  checking 	r a b  	yes or no 
	atom x  	atom t e s t   whose value i s 	  n i l   i f 
 1  simulation 	 ex r a x  	yes  x = b 	x is not an atom. 
or no n u l l   x   	n u l l t e s t   whose value i s 	  n i l   i f 
 1  v e r i f y i n g 	  v x   r   x   g   x     	yes 
	or no  x = c 	x is not equal to n i l . 
 1  program 	 vx  	ey r x y  	yes  	y - f   x   
	w r i t i n g 	or no  x = c 	axioms 
　　　we now present an a x i o m a t i z a t i o n of lisp f o l - l i : x = c a r   c o n s   x   y     lowed by two axiomatizations of the sort r e l a t i o n r 
 one f o r a s p e c i a l case and one more g e n e r a l   . 	l1: 	y = c d r   c o n s   x   y     
b. 	axiomatization of a subset of lisp 	l1 : 	~atom x  =  x = cons  car  x    c d r   x     
       a l l lisp f u n c t i o n s and predicates w i l l be l1: ~atom cons x y   w r i t t e n i n small l e t t e r s . the f u n c t i o n s 
  e q u a l   x   y         a t   x       and 	  n u l l   x     evaluate t o 	l1: 	atom nil  
  n i l   i f f a l s e and something not equal t o   n i l     say   t     i f t r u e . the predicates o f f i r s t - o r d e r l1: x = n i l 1 cond x y z  = z l o g i c t h a t are used to describe lisp are w r i t t e n i n c a p i t a l l e t t e r s . these  o f course  have t r u t h l1: x f n i l 1 cond x y z  = y v a l u e s . 
	l1: 	x = y = equal x y  # n i l 
　　　the v e r s i o n of lisp described here does not d i s t i n g u i s h between an s-expression and a copy of l1: atom x  = atom x  # n i l t h a t s-expression. there is some redundancy in 
the f o l l o w i n g f o r m u l a t i o n   i n t h a t c e r t a i n f u n c - l1: null x  - n u l l   x   # n i l t i o n s and predicates could have been defined in terms of o t h e r s ; however  the redundancy allows us c. a s i m p l i f i e d sort problem to s t a t e the problem more c o n c i s e l y . a l s o   some before examining a more general s o r t problem  
axioms could have been e l i m i n a t e d since thev are 	consider the f o l l o w i n g very simple s p e c i a l case. 
-1-



sort x  a lisp sort function  to be constructed  giving as its value a sorted version of x. merge x u  a lisp merge function merging x into the sorted l i s t u  such that the l i s t returned contains the elements of u  and also contains x  and this l i s t is sorted. p x u y  a predicate stating that y is the result of merging x into the sorted l i s t u. 　　　we define p x u y   that y is u with x merged into i t : 
s1. 
thus p x u y  holds if and only if the fact that u is sorted implies that y contains x in addition to the elements of u  and y is sorted. one such merge function is merge x u  = cond null u  cons x u   cond lessp x car u     cons x u  cons car u  merge x  cdr u     . 
　　　the axiom required to describe the merge function is : 
s1. 
　　　this completes a description of the predicates on  sd  r  and p. together  these specify the input-output relation for a sort function and a merge function. before posing the problems to the theorem prover  we need to introduce axioms that describe the convergence of recursive functions. 
e. 	induction axioms 
　　　in order to prove that a recursive function converges to the proper value  the theorem prover requires an induction axiom. an example of an induction principle is that if one keeps taking  cdr  of a f i n i t e l i s t   one w i l l reach the end of the l i s t in a f i n i t e number of steps. this is analogous to an induction principle on the nonnegative integers  i . e .   let  p  be a predicate  and  h  a function. then for f i n i t e l i s t s   

is analogous to 

for nonnegative integers. 
　　　there are other kinds of induction c r i t e r i a besides the one given above. unfortunately  for each recursive function that is to be shown to converge  the appropriate induction axiom must be carefully formulated by the user. the induction axiom also serves the purpose of introducing the name of the function to be written. we w i l l now give the problem statement for the sort program  introducing appropriate induction information 
where necessary. 
f. 	the sort problem 
　　　examples i l l u s t r a t i n g the four kipds of problems are shown below. 
　 1  checking: 

	a: 	yes 
　 1  simulation: 

　 1  verifying: now consider the verifying or debugging problem. suppose we are given a proposed definition of a sort function and we want to know 
if it is correct. suppose the proposed definition is 
s1. 	
thus sort is defined in terms of car  cdr  cond  n u l l   merge  and sort. each of these functions except sort is already described by previously given axioms. we also need the appropriate induction axiom in terms of sort. of course  the particular induction axiom needed depends on the 
definition of the particular sort function given. for this sort function the particular induction axiom needed is s1. 
theorem prover: 

	a: 	yes 
　 1  program writing: the next problem is that of synthesizing or writing a sort function. we assume  of course  that no definition such as s1 is provided. certain information needed for this particular problem might be considered to be a part of this particular problem statement rather than a part of the data base. we shall phrase the question so that in addition to i t s primary purpose of asking for a solution  the question provides three more pieces of information:  a  the question assigns a name to the function that is to be constructed. a recursive function is defined in terms of i t s e l f   so to construct this definition the name of the function must be known  or else created internally .  b  the question specifies the number of arguments of the function that is to be considered. 

-1-

 c  the question  rather than an induction axiom  gives the particular inductive hypothesis to be used in constructing the function. 
in this formi the question and answer are 

thus the question names the function to be  sort  and specifies that it is a function of one argument . the question gives the inductive hypothesis- that the function sorts cdr x -and then asks for a function that sorts x. when the answer y is found y is labeled to be the function sort x  . 
　　　using this formulation qa1 was unable to write the sort program in a reasonable amount of time  although the author did find a correct proof within the resolution formalism*. 	the creation of the merge function can also be posed to the theorem prover by the same methods. 
g. 	discussion of automatic programming problems 
       the axioms and conjectures given here i l l u s trate the fundamental ideas of automatic programming. however  this work as well as earlier work and others pro-
vides merely a small part of what needs to be done. below we present discussion of issues that might profit from fruther investigation. 
　　　loops. one obvious extension of this method is to create programs that have loops rather than recursion. a simple technique exists for carrying out this operation. first  one writes just recursive functions. many recursive functions can then be converted into iteration-i.e.  faster-running loops that do not use a stack. mccarthy1 gives criteria that determine how to convert recursion to iteration. an algorithm for determining cases in which recursion can be converted to iteration  and then performing the conversion process is embedded in modern lisp compilers. this algorithm could be applied to recursive functions written by the theorem-proving program. 
　　　separation of aspects of problem solving. 	let us divide information into three types: 	 1  information concerning the problem description and semantics. 	an example of such information is given 
in the axiom  or axiom si that defines a 
sorted l i s t .  1  information concerning the target programming language  such as the axiom cond x y z  = z   .  1  information concerning the interrelation of the problem and the target language  such as  less x y  = lessp x y  
after this paper was written the problem was reformulated using a different set of axioms. in the new formulation qa1 created the sort program  sort x  = cond x merge car x  sort cdr x    nil . 
these kinds of information are not  of course  mutually exclusive. 
　　　in the axiom systems presented  no distinction is made between such classes of information. consequently  during the search for a proof the theorem prover might attempt to use axioms of type 1 for purposes where it needs information of type 1. such attempts lead nowhere and generate useless clauses. however  as discussed in sec.ii-g  we can place in the proof strategy our knowledge of when such infor-
mation is to be used  thus leading to more efficient proofs. 	one such method-calling for the conditional axioms at the right time  as discussed in sec. ii-g- has been implemented in qa1. 
　　　the prow program of waldinger and lee1 provides a very promising method of separating the problem of proof construction from the problem of program construction. in their system  the only axioms used are those that describe the subject-i.e.  state the problem. their proof that a solution exists does not directly construct the program. instead  information about the target programming language  as well as information about the relationship of the target-programming language to the problem-statement language  is in another part of the prow program-the  post-processor.  the post-
processor then uses this information to convert the completed proof into a program. the postprocessor also converts recursion into loops and allows several target programming languages. 
　　　if our goal is to do automatic programming involving complex programs  we w i l l probably wish to do some optimization or problem solving on the target language i t s e l f . for this reason we might 
want to have axioms that give the semantics of the target language  and also allow the intercommunication of information in the problem-statement language with information in the target language. two possibilities for how to do this efficiently suggest themselves:  a  use the methods presented here in which a l l information is in first-order logic. to gain efficiency  use special problemsolving strategies that minimize unnecessary interaction;  b  use a higher-order logic system  in which the program construction is separated from the proof construction  possibly by being at another level. the program construction process 
might then be described in terms of the f i r s t order existence proof. 
　　　problem formulation. 	the axiomatization given here has considerable room for improvement: 	missing portions of lisp include the program features and the use of lambda to bind variables. 	the functions to be written must be named by the user  and the number of arguments must also be specified by the user. 
　　　heuristics for program-writing problems. two heuristics have been considered so far. the f i r s t consists of examining the program as it is constructed  by looking inside the answer l i t e r a l   . even though the syntax is guaranteed correct  the answer l i t e r a l may contain various nonsense or undefined constructions  such as car nil  . any 

-1b-

clause containing such constructed answers should be eliminated. another heuristic is to actually run the partial program by a pseudo-lisp interpreter on a sample problem. the theorem prover knows the correct performance on these sample problems because they have either been solutions or else counterexamples to program-simulation questions that were stored in memory  or else they have been provided by the user. if the pseudolisp interpreter can produce a partial output that is incorrect  the partial program can be eliminated. if done properly  such a method might be valuable  but in our limited experience  its usefulness is not yet clear. 
　　　higher-level programming concepts. a necessary requirement for practical program w r i t ing is the development of higher-level concepts  such as the lisp  map  function  that describe the use of frequently employed constructs  functions  or partial constructs. 
　　　induction. 	the various methods of proof by induction should be studied further and related to the kinds of problems in which they are useful. the automatic selection or generation of appropriate induction axioms would be most helpful. 
　　　program segmentation. another interesting problem is that of automatically generating the specifications for the subfunctions to be called before writing these functions. for example  in our system  the sort problem was divided into two problems: first  specify and create a merge function  next specify a sort function and then construct this function in terms of the merge function. the segmentation into two problems and the specification of each problem was provided by the user. 
	vii . 	discussion 
　　　the theorem prover may be considered an  interpreter  for a high-level assertional or declarative language-logic. as in the case with most high-level programming languages the user may be somewhat distant from the efficiency of  logic  programs unless he knows something about the strategies of the system. 
　　　the f i r s t applications of qa1 and qa1 were to  question answering.  typical questionanswering applications are usually easy for a 
resolution-type theorem prover. examples of such easy problem sets given qa1 include the questions done by raphael's sir1 slagle's deducomv and cooper's chemistry questionanswering program. usually there are a few 
obvious formulations for some subject area  and any reasonable formulation works well. as one goes to harder problems like the tower of hanoi puzzle  and program-writing problems  good and reasonably well-thought-out representations are necessary for efficient problem solving. 
　　　some representations are better than others only because of the particular strategy used to search for a proof. 	it would be desirable if the theorem prover could adopt the best strategy for 
-1 
a given problem and representation  or even change the representation. i don't believe these goals are impossible  but at present it is not done. however  a library of strategy programs and a strategy language is slowly evolving in qa1. to change strategies in the present version the user must know about set-of-support and other program parameters such as level bound and term-depth bound. to radically change the strategy  the user presently has to know the lisp language and must be able to modify certain strategy sections of the program. in practice  several individuals 
who have used the system have modified the search strategies to suit their needs. to add and debug a new heuristic or to modify a search strategy 
where reprogramming is required seems to take from a few minutes to several days  perhaps averaging 
one day. ultimately it is intended that the system w i l l be able to write simple strategy programs i t s e l f   and  understand  the semantics of its strategies. 
　　　experience with the robot applications and the automatic programming applications emphasize the need for a very versatile logical system. a suitable higher-order logic system seems to be one of the best candidates. several recent papers are relevant to this topic. a promising higher order system has been proposed by robinson. banerji discusses a higher order language. one crucial factor in an inference system is a suitable method for the treatment of the equality relation. discussion of methods for the treatment of equality is provided by wos and robinson  and robinson and wos  and kowalski. mccarthy and hayes＜ include a discussion of modal logics. 
　　　the theorem-proving program can be used as an experimental tool in the testing of problem formulations. in exploring d i f f i c u l t problems it can 
be useful to write a computer program to test a problem formulation and solution technique  since the machine tends to sharpen one's understanding of the problem. i believe that in some problemsolving applications the  high-level language  of logic along with a theorem-proving program can be a quick programming method for testing ideas. one reason is that a representation in the form of an axiom system can correspond quite closely to one's conceptualization of a problem. another reason is that it is sometimes easier to reformulate an axiom system rather than to rewrite a problemsolving program  and this ease of reformulation facilitates exploration. 
　　　resolution theorem-proving methods are shown in this paper to have the potential to serve as a general problem-solving system. a modified theorem-
proving program can write simple robot problems  and solve simple puzzles. much work remains to be done before such a system is capable of solving problems that are d i f f i c u l t by human standards. 
acknowledgment 
　　　i would like to acknowledge valuable discussions with dr. bertram raphael and mr. robert yates. 

