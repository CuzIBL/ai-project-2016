 
analogical planning provides a means of solving problems where other machine learning methods fail  because it does not require numerous previous examples or a rich domain theory. given a problem in an unfamiliar domain  the target case   an analogical planning system locates a successful plan in a similar domain  the bast case   and uses the similarities to generate the target plan. unfortunately  the analogical planning process is expensive and inflexible many of the limiting factors reside in the base selection step  which drives the analogy formation process. this paper describes two ways of increasing the effectiveness and efficiency of analogical planning. first  a parallel graph-match base selection algorithm is presented. a parallel implementation on the connection machine is described and shown to substantially decrease the complexity of base selection. second  a base-case merge algorithm is shown to increase the flexibility of analogical planning by combining the benefits of several base cases when no single plan contributes enough information to the analogy. the effectiveness of this approach is demonstrated with examples from the domain of automatic programming. 
1 	introduction 
analogy is a powerful planning tool. engineers and scientists rarely attack a problem in an unfamiliar domain from scratch. instead  then rely on their experience with solving problems in similar domains. they adapt known techniques  map constraints from a solved problem to the new problem  and modify existing solutions to fit the current problem specification. given a novel problem  the target case   an analogical planner selects a similar  solved problem  the base case   computes a mapping between the base and target problem descriptions  and uses the mapping the adapt the base solution to the current domain. when examples are lacking and domain theory is scarce  the intelligent agent draws on past experience in similar situations to attack a new problem. 
1 	learning and knowledge acquisition 
　although analogy is considered to be a powerful tool for machine planning  it is also viewed as an expensive task which is rarely applied to large-scale problems. as buchanan states  analogical reasoning is a  pipe dream when matched against the harsh standards of robustness of commercial applications   buchanan  1 . a second limitation of analogical planning systems is flexibility. in inductive learning systems  when the learner is not performing well enough more examples can be input to improve the hypothesis. in analogical learning systems  the strength of the output plan depends solely on the amount of similarity between base and target and on the strength of the relationship between known and inferred information. if no base cases sufficiently match the target  the system cannot  perform as needed. 
　the purpose of this research is to strengthen the effectiveness and efficiency of analogical planning  making it a more useful tool for machine learning. this paper describes a method of achieving the staled goal by focusing on the aspect of analogical planning that is the least researched and perhaps the most limiting: base selection. the base selection process is very expensive  yet the selected base case greatly affects the outcome of the planning process. in this paper  two improvemerits to base selection are discussed. first  a parallel graph-match base selection algorithm is described that reduces the complexity of the search process. second  a method of merging congruent base cases when no single base case sufficiently matches the target is demonstrated to improve the flexibility and applicability of analogical planning. this approach is illustrated on automatic programming examples  and is shown to transform analogy into an effective  efficient planner for large-scale problems. 
1 	analogical planning 
analogy can be defined as an inference that if two or more things agree in some respects they will probably agree in others. the strength of the analogically-
generated inferences depends on the type and strength of the relationship between the known shared properties and the inferred shared properties. 
　the three main steps of analogy plan formation are base selection  map formation  and inference generation. given the target problem that needs a solution  the analogical planner selects a base problem that has a successful plan and that shares crucial properties of the problem with the target. when the appropriate base case has been found  the system constructs the analogical mapping. once the mapping is formed  the analogy system uses the information describing the base and the base -  target mapping to infer the target plan. 
　for example  a programmer rarely develops his code from scratch. instead  he pulls ideas and pieces of code from similar programs he has written in the past  and modifies them to fit the peculiarities of the current goal. if he wants to implement a program that computes realnumber division to a specific accuracy  he may benefit most from analogically deriving the program. first  he finds a program in his database that computes the cuberoot of a real number to a specific precision  base selection . he senses the underlying similarities between the type of information used and the goal of the programs and pinpoints the correspondences  map formation . using these correspondences  he maps the existing code to fit the current situation  and enters the new analogicallyimplemented program into his database  inference gen-
eration . 
   much of analogy research has focuses primarily on the creation of the base -  target mapping. centner's  clement and centner  1; centner  1; centner and toupin  1  theory of systematictty shows that humans use analogies between concepts whose underlying structures are the same. other popular methods of map formation include carbonell's transformational analogy approach  carbonell  1  which uses means-
ends analysis to reduce the difference between base and target  and the explanation-based approach of kedarcabelli  kedar-cabelli  1   which constructs an explanation of the difference between base and target concepts. 
 .analogical reasoning  though generally considered intuitive and compelling  is often looked upon as a computationally infeasible form of learning. this feeling is fueled by the fact that much attention has been given to the task of finding coherent mappings between base and target. on the other hand  little attention has been given to computationally-complex tasks such as base selection. work focusing on the base selection task includes case-based reasoning research  hammond  1a; hammond  1b; kolodner et al.  1  which uses plan keywords to organize the databa.se and select a base case. 
1 	parallel analogical planning 
a goal of this research is to design an analogical planning system efficient and effective enough to apply to large-scale problem domains. the implemented system is based on a graph match algorithm  which compares two plans represented as graphs to determine the similarity of the plans. the system is called a n a g r a m  analogical graph match . given a target problem specification represented in graph form  anagram's colored graph match technique generates a plan which will achieve the target goal. 
   each plan in anagram's database is represented as a directed acyclic graph. the nodes in the graph represent object names and attributes  and the links represent relations between objects. a base case is selected if the structure of the base graph matches the structure of the target graph  embodying centner's theory of systematicity . 
　the system accepts as input two subgraphs  representing the target problem's initial-state description and goal-state specification. a n a g r a m searches through the database  finding the best match for both subgraphs. using the output of the individual graph matches  a n a gram then maps the base plan over to the target domain to generate a solution for the target problem. if the resulting plan is unsuccessful  or if no sufficiently similar base cases are found  the system attempts to merge several base cases that are similar to each other and to the target problem. the result is a virtual base graph that eliminates anomalies and generalizes various options in the plan to the extent that it covers the target domain. 
1 	parallel graph m a t c h 
anagram's graph match algorithm is implemented on a connection machine 1  a single-instruction-multipledata  simd  machine with 1 processors. the algorithms are implemented in *lisp  a parallel extension of common lisp. a n a g r a m makes use of parallel computation in two aspects of base case selection. the graph match algorithm which compares a base graph with the target is implemented in parallel  and each base case in the database is examined simultaneously. 
　in the parallel graph match  the data structure representing each graph node is stored in a separate cm processor. each node in the first graph looks for a match at the same time with a node at the same level in the second graph. an integer is assigned to each node in the base graph. when a match is found for a node from the base graph  the corresponding target node is assigned the same integer when testing if node n1 matches n1  the link labels and the integers assigned to the parents and children of n1` are matched with the corresponding labels and integers for n1. 
　the data structure describing each node contains the level of the node in the graph 1  the node label  and a tuple which consists of the incoming link labels and corresponding parent nodes as well as the outgoing link labels and corresponding child nodes. initially  nothing is known about parent or child nodes  so the parent/child integer slots are set to    . each node simultaneously looks for a match by comparing levels and tuples. if two complete tuples match  the tuples are complete if they have no    s   the match is added to the global map  gmap  and a unique integer is assigned to the two nodes. if a tuple is incomplete  it generates a list of partial matches. when one or more matches are found  each node in both graphs simultaneously updates its tuples. assigned integers are propagated across the links. once the tuples are updated  matches between incomplete tuples are checked once again - if they no longer match  the algorithm returns failure. 
　　1 the level of a node in a dag is defined here as the shortest path length from the node to any leaf in the dag. 
	cook 	1 

　if no unique matches are found for any of the nodes  the algorithm takes one node from the list of nodes having more than one candidate match  and randomly selects a match for the node. if there are nodes from the first graph that cannot be matched with any node from the second graph  the algorithm returns failure. the process is successfully completed when a match is found for each node in the first graph. 
1 	parallel base selection 
probably the greatest speedup occurs when base selection is parallelized. normally  the base selection process is very time consuming because each potential base solution must be compared with the target problem specification. fortunately  each of these comparisons is independent  of t he others  so the bases can be examined in parallel. 
　the time saved by performing base selection in parallel is enormous  as would be expected. however  as the database grows large  it is not possible to examine each of the base cases in parallel because of the limit on the number of processors. on the connection machine it is possible to create virtual processors  extra processors which overlay the existing physical processors . using the virtual processors eventually degrades the performance of the algorithm  however  and even with the existence of virtual processors it is not possible to examine a huge database completely in parallel because of memory limitations. 
   fur this reason  as the database becomes very large  indices are attached to each entry in the database. the indices chosen are ones which do not add new information to the graphs; rather  they compress the information contained in the graph. these features include graph invariants such as the size of the graph and the degrees of each node. some indices also encapsulate information contained in the graph such as the list of operators used in the plan. entries in the database with the same indices are then grouped together. when base selection is performed  the algorithm uses the attributes of the tar-
get specification to select a group of base cases from the database  and examines these base cases in parallel. in fact  the number of cases allowed in each database sub-
group can be calculated from the size of the individual plans and the number of processors available on the ma-
chine  so that it is always possible to examine the plans within a single group in. parallel. 
1 	example 
this section illustrates the application of anagram's parallel algorithms to automatic programming. analogy proves to be a valuable tool for automatic programming. instead of constructing programs from scratch or working from abstract theories  many scientists start with existing program segments that achieve similar goals  and modify them to meet their current needs. 
   the following example is based on a program segment described by dershowitz  dershowitz  1 . the base program  a program that computes the cube-root of a within an error tolerance e  is used to generate a program that computes c/d within an error tolerance e. figure 1 
1 	learning and knowledge acquisition 

figure 1: base and target goal-state subgraphs 
illustrates the goal-state subgraphs of the base and target plans. 
   a n a g r a m successfully matches the initial-state subgraphs and the goal-state subgraphs. tables 1 and 1 show the tuples representing the nodes in the two goalstate subgraphs at the end of the graph match. the first column represents the node label  the second column lists the integer assigned to the node  the third column shows the corresponding tuple  and the fourth column lists the candidate matches / final match for the node. note that the tuples are represents as  { child-integer outlinklabel  } { parent-integer inlink-label  } . 

　the result of the match is the set of node-to-node matches that comprise the global map: 



figure 1: graph match results 
　the mapping is used to transform the base program into a program that achieves the target goal. the code 
segments are shown below 

　after the target plan generation is complete  the plan is tested. if the plan is not successful  anagram may attempt a new analogy  merging several base cases to form a more flexible analogy. this process is described is section 1. if the plan is successful  the new plan is indexed by its features and added the database. 
1 	analysis 
figures 1 and 1 show the results of running the parallel and sequential graph match and base selection algorithms. for these experiments  a database of graphs representing program specifications was created. in the first experiment  the graph sizes range from 1 to 1 nodes. noise was minimized by generating 1 graphs of each desired size. three implementations of the graph match algorithm were tested. the first curve represents the sequential version of the algorithm implemented on a texas instruments explorer ii. the second curve shows the results of the parallel implementation running on a 
connection machine 1. the third curve represents the 

figure 1: base selection results 
algorithm running on the cm 1 without taking advantage of the parallelism. 
　the results shown in the graph match graph come very close to expectation. the actual complexity of the graph match algorithm is  where n is the number of nodes in the graph  h is the height of the graph  and p represents the number of physical processors residing on the machine. this is linear speedup from the sequential algorithm  which has complexity o n1 . 
　the second experiment compares sequential and parallel implementations of the base selection algorithm. from a database of 1 graphs  one base case was chosen. when the entire database must be searched  the complexity of the sequential algorithm is proportional to the size of the database  while the parallel algorithm is almost constant. the sequential algorithm actually has complexity o bn1   while the parallel algorithm is 

　the results of testing these algorithms reveals that an analogy system implemented on a massively parallel machine is a powerful and efficient planning tool. taking advantage of available hardware allows analogical planning to be applied to complex problems without unreasonable time expense. 
1 	merging congruent cases 
implementing an analogy system on a parallel machine transforms analogical planning into an efficient process. however  the tool still suffers from a lack of flexibility. in particular  a base case must be found that is sufficiently similar to the target to analogically generate each step of the target plan. because in actuality there exists a great diversity among graph representations of plans  
	cook 	1 

the chance of finding such a similar base case is slim. although analogical learning is sometimes preferred to inductive learning because it does not require multiple examples  there are many instances in which multiple base cases would strengthen an analogy. 
　one example of using multiple base cases is incremental analogy  burstein  1 . one base case may provide some of the information needed for the target  but not all. another base case may provide the remaining needed information  but nothing else. an analogy formed between the target and either one of these bases would be insufficient  but the merging of the two separate analo-
gies results in a complete  useful analogy. 
　a second way of using multiple base cases is to merge similar base cases  resulting in a  virtual  base case. this virtual base case is more beneficial to the analogy than a single case  because it removes anomalies and generalizes alternative operations. furthermore  merging base cases focuses the analogy on the relevant  aspects of the base cases  because those aspects of previous plans that are beneficial to the target are retained in the virtual base. base cases that are sufficiently similar in 
structure to be merged together are termed congruent base cases.1 
1 	the merge a l g o r i t h m 
 this section describes how a n a g r a m merges congruent base cases to enhance its analogy-formation and problem-solving capabilities. the issue of deciding when to merge plans is first addressed  and then the merging method is described. 
　anagram uses the graph-merge algorithm in the following cases: 
  a match is found between the target initial/goal states and the base initial/goal states  but the intermediate steps in the base case are not mappable or cannot be applied in the target domain. 
  no base case matches perfectly  but several match rather closely. moreover  the unmappable parts either 1  are generalizable in a way that map to the target plan  or 1  they do not overlap  the base cases fail to match the target at distinct points in the target graph . 
   when selecting bases for merging  the algorithm chooses cases based on ease of generalization. the types of graph merge are  in order of preference : 
1 merging graphs with distinct base/target differences. the simplest and most beneficial method of merging occurs when the candidate base graphs match each other and their differences with the target do not overlap  as shown in figure 1. the mappable portions of each base are retained in the virtual base graph. 
1. relaxing order constraints. the graph match algorithm looks only for matches between nodes at corresponding levels in the graphs. often an operator 
1
　　this term is borrowed from geometry  where two triangles are congruent if they have the same angles and propor-
tions of side lengths. 
1 	learning and knowledge acquisition 

figure 1: distinct base case merge 
re-ordering will make a base case fit the target exactly. comparing multiple plans whose only difference is the order of operations  it becomes apparent that maneuvering the operators may also solve the target problem. when this situation arises  anagram looks for correlations between the order of operations and ordering constraints in the initial or goal state. 
1. disjunction/'generalization of subgraphs. when comparing subgraphs whose  defective  parts do overlap  a n a g r a m generalizes the overlapping subgraphs. the methods of generalization correspond to those found in most induction systems  such as adding disjunctions and climbing generalization trees. the purpose of the generalization is to abstract the non-mappable subgraphs to th extent that the generalized subgraph will cover the target case. as the number of base cases included in the generalization increases  the method of merging base graphs begins to behave similar to pure indue tion. 
1 	example 
this section describes an application of anagram's graph merge algorithm to a problem in the domain of automatic programming. in this example  the target goal is to construct a program that uses in order traversal to traverse a given binary tree. the initial and goal state descriptions are given: 

　among the base cases residing in the database are the algorithms for preorder and postorder tree traversal. the matches are equally good with either base case  so the selection process arbitrarily chooses the preorder plan. however  the resulting program is 
begin inorder 

unless null tree  
vlist := append vlist  x  inorder left-son x   vlist  inorder right-son x   vlist  
end 
   this does not solve the problem  remember that the graph matcher does not consider re-ordering the operators . the system then compares the preorder and postorder algorithms  and notices that the operators are the same in the two algorithms  but the order of application is different. the goal description in both base cases places ordering constraints on the output: 

   by comparing the order of operators with the order imposed by the goal description  anagram observes that the placement of y corresponds with the append operation  lcft-son y  with the recursive call to the left son  and right-son y  with the recursive call to the right son. a n a g r a m is able to generate a virtual base graph that contains the correspondences between the three operators and the desired order of elements in vlist. the resulting target plan shown below is successful. 
begin inorder 

end 
1 	conclusions and future directions 
 this paper presents two steps that make analogical planning a more effective and efficient machine learning tool. there are many extensions of this research which could push the advancement of the area even further. searching for and combining partial matches would be a beneficial alternative to merging base cases. developing a fuzzy graph match would allow a broader range of analogies to be created. other aspects of the analogical planning task could be parallelized  such as inference generation. in addition  other parallel architectures should be analyzed for their potential to speed up the analogy process. for example  a hypercube m1md architecture could be used to develop multiple independent analogies for the same target  or expand multiple partial matches 
simultaneously. 
   in this paper  the parallel graph match and base selection algorithms were described as implemented on the connection machine. the results were substantially faster than results from the comparable sequential method. in addition  a method of combining the benefits of several successful plans by merging multiple base cases was presented. the extension of analogy to utilize multiple base cases was shown to increase the effectiveness of analogical planning in large problem domains. by designing efficient parallel analogy algorithms  and by extending the applicability of analogical planning  this research offers a valuable step toward the automation of analogical planning. 
