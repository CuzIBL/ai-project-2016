 
in our research  we explore the role of negotiation for conflict resolution in distributed search among heterogeneous and reusable agents. we present negotiated search  an algorithm that explicitly recognizes and exploits conflict to direct search activity across a set of agents. in negotiated search  loosely coupled agents interleave the tasks of 1  local search for a solution to some subproblem; 1  integration of local subproblem solutions into a shared solution; 1  information exchange to define and refine the shared search space of the agents; and 1  assessment and reassessment of emerging solutions. negotiated search is applicable to diverse application areas and problem-solving environments. it requires only basic search operators and allows maximum flexibility in the distribution of those operators. these qualities make the algorithm particularly appropriate for the integration of heterogeneous agents into application systems. the algorithm is implemented in a multi-agent framework  team  that provides the infrastructure required for communication and cooperation. 
1 	introduction 
the current state of knowledge-based technology is such that almost every application system is built from scratch. in order to move beyond the prohibitive cost of constantly reinventing  rerepresenting  and reimplementing the wheel  researchers are beginning to examine the feasibility of building application systems with reusable agents  neches et a/.  1 . a reusable agent is designed to work without a priori knowledge of the agent set in which it will be embedded  instead using a flexible  reactive approach to cooperation. although this flexibility can lead to inefficient problem solving  an agent can often gather information about the agent set as problem solving progresses to improve efficiency. 
　　this research was supported by arpa under onr contract #n1-j-1. the content of the information does not necessarily reflect the position or the policy of the government  and no official endorsement should be inferred. 
1 	distributed al 
　multi-agent systems do not traditionally acknowledge the role of conflict among agents as a driving force in the control of problem-solving activity. in reusable-agent systems  however  conflict is inevitable since agents are implemented at different times by different people and in different environments. we present a distributedsearch algorithm  negotiated search  that uses conflict as a source of control information for directing search activity across a set of heterogeneous agents in their quest for a mutually acceptable solution. 
　the negotiated-search algorithm has been successfully incorporated into two implemented systems. in  lander and lesser  1b   we describe distributed search in the context of a seven-agent steam condenser design system and discuss how different operator/agent assignments within the negotiated-search algorithm affect problem solving. in  lander and lesser  1a   a two-agent contract negotiation system is presented  and negotiated search is compared to a search strategy that is tailored to characteristics of that environment. through analysis of the environment and search algorithms  we show the versatility and effectiveness of negotiated search in reusable-agent systems while also pointing out that customized search strategies are inflexible but can improve system performance when they can be applied. in this paper  we describe negotiated search from an application-independent perspective. 
　the need for a flexible algorithm to support reusability and heterogeneity motivates particular aspects of negotiated search: 
  conflict  negotiation  and democratic determination of acceptability are integral parts of the algorithm. 
  agent coordination is accomplished through clearly defined individual roles in the evolution of a shared solution. these roles are realized as operators that accomplish state transitions on shared solutions. 
  operators represent standard and widely available search and information-assimilation capabilities. a particular agent may instantiate all defined operators or some subset of defined operators. 
  whenever possible  feedback is used to refine the perceived search spaces of individual agents to more closely reflect the true composite search space. 
team agents are not hostile and will not intentionally 

mislead or otherwise try to sabotage another agent's reasoning. they are cooperative in the sense that an agent is willing to contribute both knowledge and solutions to other agents as appropriate and to accept solutions that are not locally optimal in order to find a mutuallyacceptable solution. each agent is a stand-alone system with specific capabilities that allow it to be included in an integrated multi-agent system. we assume that agents can be heterogeneous in architecture  inference engines  evaluation criteria and priorities for solutions  and in long-term knowledge. each agent does its own internal scheduling and has private data  knowledge  and history mechanisms. 
　in negotiated search  agents interleave the tasks of 1  local search for a solution to some subproblem; 1  integration of local subproblem solutions into a shared solution  the composite solution ;1  negotiation to define and refine the shared search space of the agents; and 1  assessment and reassessment of emerging solutions. 
　in the remainder of the paper  we first motivate the development of our negotiated-search model by presenting an intuitive description of negotiation and  from this foundation  constructing an algorithmic model of the negotiation process. the next section details negotiated search from a state-based perspective similar to that used by von martial to describe negotiation protocols in distributed planning  von martial  1 . we then present seven basic negotiated-search operators. the final section briefly describes the status of the implementation and extensions to this model that are not covered in this paper. 
1 	an initial perspective on negotiation 
in this section  we begin with an intuitive description of negotiation: 
   one agent generates a proposal and other agents review it. if some other agent doesn't like the proposal  it rejects it and provides some feedback about what it doesn't like. some agent may generate a counter-proposal. if so  the other agents  including the agent that generated the first proposal  then review the counter-proposal and the process repeats. as information is exchanged  conflicts become apparent among the agents. agents may respond to the conflicts by incrementally relaxing individual preferences until some mutually acceptable ground is reached. 
this example captures the primary characteristics that one would expect to see: 
  proposals are generated by one or more agents 
  agents evaluate proposals based on their individual criteria for solution acceptability 
  agents provide feedback about what they like or don't like about particular proposals  resulting in a progressively better understanding of the shared requirements for solutions over time 
　　1  sat hi similarly uses the term compoaition as the name of a specific search operator that combines local information  sathi and fox  1  
  agents can play different roles in the negotiation process  e.g.  an agent can be a reviewer for another agent's proposal and then be a generator for a counter-proposal 
  conflicts exist among the agents' requirements for acceptable solutions 
  agents incrementally relax their solution require-ments to reach agreement 
  the decision to accept or not accept a proposal is a joint  democratic process 
　some extensions to the definition are required. for example  it assumes that a proposal becomes a solution when it is accepted by all agents. however  this assumption rules out situations in which high-level problems are decomposed and each agent works on some subproblem. in this case  the proposal an agent makes does not represent a complete solution but rather some component of a solution that interacts with other components through shared attributes. evaluation is then indirect since an agent cannot evaluate proposals for interacting components that are outside of its domain of expertise. in negotiated search  an agent evaluates an external interacting-component proposal by creating and evaluating a compatible local proposal  i.e.  one that has the same values for shared attributes   thereby focusing on how the external proposal affects local quality. 
　although a proposal includes the information required to implement a solution  it provides only a surface-level view of the reasoning that went into creating it. it is sometimes possible to make guesses about other agents' requirements that could be used in generating counterproposals. however  in the general case of reusable agents  external local evaluation criteria for solutions cannot be predicted  nor can they be inferred from the  snapshot  provided by a proposal. for proposals and counter-proposals to be related  there must be a deeper understanding of the shared search space of the agents. this understanding is achieved through a feedback system that can be separate from the proposals. 
1 	negotiated search 
artificial intelligence researchers have previously used the term negotiation with respect to conflict resolution and avoidance  adler et a/.  1; klein  1; lander and lesser  1a; sycara  1; werkman  
1   task allocation  cammarata et a/.  1; durfee and montgomery  1; davis and smith  1   and resource allocation  adler et a/.  1; conry et a/.  1; sathi and fox  1; sycara et a/.  1 . negotiation is sometimes treated as an independent process that is used to select one of a set of existing alternative solutions  zlotkin and rosenschein  1  rather than as an inherent part of a solution-generation process. it can be difficult under conditions where agents are hostile and unwilling to share private information  sycara  1 . negotiation can occur among peers  cammarata et a/.  
1; lander and lesser  1b   through a mediator or arbitrator  sycara  1; werkman  1   or hierarchically through an organization  durfee and montgomery  1; davis and smith  1 . it can occur at 

either the domain or control level of problem-solving. laasri et. al. describe the recursive negotiation model  a general model of multi-agent problem solving that details various situations that can potentially benefit from negotiation  laasri et al  1 . in examining this model  it becomes clear that negotiation is a pervasive process that remains relatively untapped by current computational systems. in developing the negotiated-search model  we have tried to capture the key requirements for negotiation without restricting the domain  task decomposition  or organizational model of the agent set. 
   several researchers have developed algorithms and heuristics for constraint-directed distributed search in situations involving multiple homogeneous agents  sathi and fox  1; sycara et al  1; yokoo et a/.  1  1 we extend this work to handle situations where heterogeneous agents may have different or multiple local problem-solving paradigms  instantiate different search operators  and where agents may not be able to provide specific information to other agents or understand information received from other agents. the negotiatedsearch algorithm is particularly suitable to this style of problem solving because 1  the required search operators represent standard search capabilities; 1  the search operators can be flexibly assigned across the agent set according to the search capabilities of each agent; and 1  agents use incremental relaxation of solution requirements to reach mutual acceptability as an inherent part of problem solving. 
1 	t h e search process 
search is initiated by a problem specification that details the form of a solution and values  preferences  or constraints on some attributes of that solution. this specification is placed in a centralized shared memory as are emerging composite solutions.1 some agent s  uses constraining information from the specification and its local solution requirements to propose an initial partial solution called a base proposal the base proposal is then extended and evaluated by other agents during future processing cycles. when a particular solution cannot be extended by some agent due to conflicts with existing solution attributes  there are two possible outcomes: 1  if the conflict is caused by the violation of some hard  nonrelaxable  requirement  the solution path is pruned  e.g.  arc 1 in figure 1 ; or 1  if the conflict is caused by the violation of some soft  relaxable  solution requirement  the solution is saved and viewed as a potential compromise  e.g  arc 1 in figure 1 . in the first case  no more work will be done on that solution  and  to the extent that the violated requirement can be communicated to and assimilated by other agents  future counter-proposals will not violate that same requirement. in the second case  the violated requirement may eventually be relaxed and  if that happens  the potential compromise will become a 
1
　　 agents may control different resources and have different constraints on solutions  but they share a single underlying problem-solving paradigm and knowledge representation. 
1
　　 each agent also has a local short-term memory where it stores intermediate results and/or component proposals that are linked to composite solutions in shared memory. 
viable solution again. future counter-proposals will take the violated requirement into account but are not guaranteed to avoid the same conflict  since other alternatives may be worse. 
   in both of the above cases  conflict is used as the trigger for the communication of feedback information. in multi-agent systems  it is always problematic to decide what information should be exchanged and when that exchange should take place. in general  agents want to minimize the amount of information they share since it is expensive both to communicate information and to assimilate information. on the other hand  sharing information that will specifically help another agent avoid future conflicts is generally cost effective since it eliminates the expense of generating unproductive solution paths  lander  1 . in negotiated search  an agent that receives conflict information from another agent can choose whether or not to prune its own search to respect that information  see section 1 . 
   multiple solution paths can be concurrently investigated in negotiated search. agents are free to initiate solutions at any time either because there aren't any promising solutions in the current solution set or because they have no other work to do. advantages to maintaining multiple paths include exploiting the potential for concurrent activity and having the ability to directly compare different potential compromises. there are disadvantages to concurrently exploring multiple solution paths however: there will be multiple partial solutions that have to be stored at all times  requiring additional memory resources. there is also overhead involved in focusing on a promising solution path at a particular point in problem solving  both from the local and global perspectives  and in managing the links between solution components along each path. the number of open solution paths is highly dependent on the domain  the number of agents  and the control policies of individual agents. this number can be controlled through parameter settings in team and through the specification of which negotiated-search operators will be active for each agent in the agent set. 
1 	a state-based v i e w of n e g o t i a t e d search 
figure 1 provides a state-based view of the transition of a composite  shared  solution from its initial state  a problem specification  to a termination state  an infeasible solution  an unacceptable solution  or a complete acceptable solution . in this figure  states are defined in terms of three attributes of composite solutions: acceptability  completeness  and search-state. the possi-
ble values for acceptability are acceptable  unacceptable  and infeasible. possible values for completeness are complete and incomplete. note that complete means that all agents have had the opportunity to extend or critique the solution. a solution with all required components can still be waiting for critiques from other agents and is not considered complete in that case. search-state can take the values initial or closed. 
　a negotiated-search operator is a search function applied by an agent. each operator has a generic form that is expressed in an agent language defined by team  spec-


figure 1: a state-based view of negotiated search 
ifying its inputs  outputs  and functionality. the decision to apply a particular operator to a problem-solving situation is made by an agent within its local view of the problem-solving situation. the arcs in figure 1 are negotiated-search operators that can be applied by some agent to a solution. 
　each agent instantiates one or more of the negotiatedsearch operators: initiate-solution  extend-solution  critique-solution  and relax-solution-requirement in ad-
dition  team instantiates the terminate-search operator. these operators will be described in detail below  but we provide an overview here to provide a sense of their functionality. initiate-solution is applied by an agent to generate a base proposal that will be used as the basis for a new composite solution. extend-solution is applied by an agent to: 1  add a component proposal to a composite solution; 1  evaluate the composite solution from a local perspective; and 1  provide feedback information if conflicts are detected. critique-solution is applied to: 1  evaluate a composite solution  without generating a component proposal ; and 1  provide feedback information if conflicts are detected. relax-solution-requirement is applied to: 1  select a local requirement to relax; 1  update the local database to effect the relaxation; and 1  reevaluate existing solutions in light of the relaxation. terminate-search is applied by team to change the state of the problem solving from initial to closed  thereby changing the termination status of solutions. 
the negotiated-search algorithm is applied by a set of 
agents  a. let and assume that al 
initiates a solution  a1 extends the solution  and a1 critiques some aspect of that solution. we examine a typical search in which a conflict occurs. a1 first applies the operator initiate-solution to a problem specification and produces a partial acceptable solution  arc i . then a1 applies extend-solution without detecting a conflict. although the solution now has all components specified  it is not complete until all critiques have also been received. therefore the solution is now partial and acceptable  arc 
s  . a1 next applies critique-solution  detects a conflict  and evaluates the solution as unacceptable  are 1 . this solution remains as it is for some amount of time while the agents are working on other solution paths. when further search fails to produce an acceptable solution  a1 decides to relax the requirement that made this solution unacceptable. the solution is now acceptable to a1 and  since it was already complete  it reaches the termination state of complete acceptable solution  arc 1 . in this way  various paths through the state diagram can be achieved by the agent set. 
　although the above example describes a sequential ordering of operator applications  team permits concurrency except where there are domain-dependent operator preconditions that force sequential execution. concurrency requires that team have mechanisms for handling conflicts that occur due to the simultaneous development of extending proposals and criticisms. these mechanisms are discussed in  lander  1 . 
1 	negotiated search operators 
in this section  we present a detailed description of the negotiated-search operators. notice that the operators depicted in figure 1 work at the surface level of problem solving: they move a particular solution through various states to a termination state. they do not address the issue of feedback and its effect on problem solving. later in this section  we will present two operators that an agent applies to assimilate conflict information into its knowledge base  thereby refining its view of the search space. 
1 	initiate-solution 
initiate-solution is the basic operator for initiating solutions. it is applied within the agent's view of solution requirements: local requirements  those imposed by the problem specification  and any known external requirements learned from other agents. given these requirements  it creates the base proposal. initiate-solution is executed by one or more agents at system start-up time  and may be repeatedly executed as earlier proposed solutions are rejected by other agents or if alternative solutions are desired. if earlier solutions have been proposed and rejected  the initiating agent may have received conflict information that will influence the generation of new base proposals. 
　at least one agent must instantiate initiate-solution; however  instantiating it at multiple agents is likely to result in a more diverse set of solution paths and more thorough coverage of the composite solution space. depending on characteristics of the agents and agent set  it may also have a distracting effect. trade-offs between coverage and distraction are a ubiquitous problem in distributed systems and are discussed generally in  lesser and erman  1  and specifically with respect to negotiated search in  lander and lesser  1b   
　when no base proposal can be found under the existing set of requirements  an agent can relax requirements 

to expand the search space. if there are requirements on solutions that come from information communicated by another agent  external requirements   the initiating agent can ignore one or more of these requirements in its own search. notice that the other agent does not actually relax the requirements. in this way  each agent chooses the set of requirements  both internal and external  it will attempt to satisfy. when known external requirements are violated  the proposal is suggested as a possible compromise rather than a fully acceptable solution. the external agent that has its requirements violated in the compromise proposal cannot be forced to accept it. because the selection of a mutually acceptable solution is democratic  each agent votes on the acceptability of a solution. the external agent that has the violated requirement s  can initially vote that the solution is unacceptable but  if it does not find a better alternative  it may eventually agree to accept this compromise. 
　if there are no relaxable external solution requirements or if the external requirements are inflexible  an agent can relax some local requirement. if no base proposal can be found at any level of external or internal requirement relaxation  the agent returns a failure along with any conflict information it can generate that describes why it failed. team returns a failure if no agent can generate a new base proposal and all previously created solutions have been found to be infeasible. 
1 	critique-solution and extend-solution 
the critique-solution operator is applied by an agent to evaluate a partially or fully specified composite solution. the extend-solution operator is applied by an agent to extend and evaluate a partially specified composite solution. these two operators will be described jointly because of their similarity. the input for these operators is a composite solution that was initiated by another agent. the output for critique-solution is an evaluation  and when a conflict is detected  conflict information. the output for extend-solution is a proposal  an evaluation  and  when a conflict exists  conflict information. 
　the extend-solution operator is required in domains where solutions comprise interacting components and each component is developed by an expert agent. the component that an agent develops with extend-solution must be compatible with the solution being extended  it must have the same values for solution variables that overlap . the agent executing the operator searches for a compatible proposal under its known solution requirements and the requirements imposed by the assigned parameter values of the solution to be extended. 
　although we will not discuss critique-solution further  the following discussion of extend-solution generally applies to both operators  except that critiquesolution evaluates the existing composite solution rather than creating and evaluating a compatible proposal. in extend-solution  if a compatible proposal is found that 
does not violate any local solution requirements  it is returned as an acceptable proposal. if the best compatible proposal found violates some relaxable  soft  local solution requirements  where the best proposal is one that maximizes local evaluation   it is returned as unacceptable along with information that describes the conflict. although currently unacceptable  future requirement relaxations may change its status and  therefore  the solution is saved as a potential compromise. in the final case  no compatible proposal can be found without violating nonrelaxable  hard  requirements of the executing agent. in this case  the agent fails and the solution path is marked as infeasible. conflict information is returned whenever possible that describes why the path is infeasible  i.e.  what hard requirements were violated. 
1 	relax-solution-requirement 
relaxation of solution requirements is a necessary part of negotiated search. in order to terminate problem solving  agents must reach mutual acceptability on one or more solutions. acceptability is defined as an attribute of a composite solution as shown in figure 1. if any agent locally evaluates a solution as unacceptable  the solution is considered globally unacceptable. however  as can be seen in that figure  a solution that is unacceptable at some point in time can later become acceptable when the agent or agents that reject it relax their solution requirements. 
　there are three primary forms of relaxation  unilateral relaxation  feedback-based relaxation  and problemstate relaxation. unilateral relaxation occurs when an agent decides to relax a requirement due to its inability to find a solution under the problem specification  i.e.  the agent finds that  given the problem specification and its initial solution requirements  it cannot produce a locally acceptable proposal. this situation occurs in the application of the initiate-solution operator as described in section 1. 
　feedback-based relaxation occurs when an agent relaxes a solution requirement because of some explicit information about the requirements of some other agent s   i.e  a conflict is found between relaxable local solution requirements and less flexible external solution requirements. this occurs when external information has been received by an agent and is being assimilated as described in section 1. 
　problem-state relaxation is a reaction to the lack of overall problem-solving progress. in the current team framework  problem-state relaxation occurs at specific processing-cycle intervals: for example  all agents may relax a solution requirement after 1 processing cycles. alternatively  the user can specify the relaxation parameter separately for each agent  so that one agent may relax after 1 processing cycles while another will relax after 1 processing cycles. problem-state relaxation occurs because the problem may be overconstrained by the full agent set. the ability to formulate  communicate  and assimilate constraining information is not guaranteed to be complete and precise across the agent set and the reality is that agents can't always determine whether the composite search space is overconstrained. therefore  they must have some heuristic method  as well as the deterministic methods above  for deciding when it is appropriate to relax requirements.1 because of problemstate relaxation  we can guarantee that if any initial proposal is generated that can result in a feasible solution  either that solution will eventually become acceptable to all agents  or some other solution will become acceptable to all agents and deadlock will not occur. 
1 	terminate-search 
the operator terminate-aearch is applied by team  rather than by an agent  to change the search phase of the algorithm from initial to closed when some  user-specified  number of acceptable proposals been found.1 as seen in figure 1  when this change occurs  partial and complete unacceptable solutions move from intermediate to termination states. any partial acceptable solutions are completed however to ensure that good partial solutions are not abandoned. 
1 	assimilating information 
there are two operators associated with assimilating information at an agent: store-received-information and retrieve-information. store-received-information takes conflict information from other agents  syntactically checks to see if the information already exists in the local knowledge base and  if not  stores it so that it can be retrieved. a received requirement may be indexed by various attributes including the name of the sending agent  the flexibility of the requirement  the names and acceptable values of constrained solution attributes  and  in the case of ordered solution attributes  whether the requirement defines a minimum or maximum boundary on potential values  e.g.  x   1. 
　retrieve-information is an operator that extends or replaces an agent's default capability to retrieve relevant constraining information from its knowledge base. because an agent's internal knowledge is expected to be locally consistent  the default retrieval mechanism generally does not handle cases where conflicts may exist in the retrieved requirements. requirement retrieval occurs during solution initiation  extension  and criticism. the goal of the retrieval process is to find the most restrictive  but non-conflicting  set of solution requirements that constrain a solution for the current local search problem. different types of requirements require different treatment  but to provide a concrete example of retrieval  we present the algorithm used for selecting boundary constraints on numerical solution attributes in our application systems. potentially relevant constraints are retrieved and sorted into maximum and minimum boundary groups. the most restrictive maximum constraint  max  and the most restrictive minimum constraint  min  from each group are selected  where most restrictive means the highest value from the min group and the lowest value from the max group . then the 
   1 using the number of processing cycles as a heuristic is a simplistic approach. more sophisticated mechanisms for applying problem-state relaxation based on characteristics of problem-solving situation  rather than on time  are discussed in  lander  1 . 
   1 this is a simplified version of the team termination policy that integrates agent acceptability and  optionally  a domaindependent global evaluation of solutions. 
algorithm loops through the following sequence until a set of minimum and maximum values is found or until it is determined that no non-conflicting set exists. 
　loop: if the value of max is greater than or equal to the value of min  return max and min since a nonconflicting set has been found. otherwise  if the flexibility of max is greater than the flexibility of min select the next most restrictive maximum constraint  max  and go to loop. otherwise  if the flexibility of max is less than the flexibility of min  select the next most restrictive minimum constraint  min  and go to loop. otherwise  the flexibility of max is equal to the flexibility of min. then: if max is locally owned  select the next most restrictive minimum constraint  min  and go to loop. if max is not locally owned and min is locally owned  select the next most restrictive maximum constraint  max  and go to loop. if neither max nor min is locally owned  select the next most restrictive minimum constraint  min  and go to loop. 
　in reusable agent sets  operator diversity is expected- not every agent will instantiate every operator including the store-received-information and retrieve-information operators. because of this  when an agent formulates and sends conflict information to another agent  there is no guarantee that the receiving agent will use that information appropriately. therefore  although conflict information is shared willingly and cooperatively in negotiated search  agents do not depend on other agents to react in a fixed way to that information. 
1 	agent-level control of operator application 
figure 1 describes domain-independent state preconditions that must be satisfied before an agent can apply one of its operators to a particular solution. however  because there are multiple solution paths  and because some operators are not directly involved in solution generation  e.g.  store-received-information   an agent may have multiple operators ready to execute at any given time. the order in which an agent schedules local operators is not mandated by either team or by the negotiatedsearch algorithm. however  because an agent's perception of the world changes over time  the order in which particular operators are executed does affect system performance and the effect of local scheduling on the overall behavior of the system should be considered. some general policies for local scheduling are useful in most situations  i.e.  agents should assimilate any new information received before initiating or critiquing solutions. the degree of sophistication required in local scheduling though is highly dependent on the application and the complexity of required interactions. 
1 	conclusions 
negotiated search is a flexible and widely applicable distributed-search algorithm. it specifically addresses issues that arise in multi-agent systems comprised of reusable and heterogeneous agents. the algorithm acknowledges the inevitability of conflict among the agents  and exploits that conflict to drive agent interaction and guide local search. 
   negotiated search has been implemented in team  a generic framework for the integration of reusable agents  and consequently  in two application systems built on top of team: steam  a seven-agent system for the mechanical design of steam condensers ; and agree  a two-agent system for buy/sell contract negotiation . testing and analysis of the algorithm within the context of the application systems is described in other work  lander  1; lander and lesser  1a; lander and lesser  1b . 
results from experiments conducted with negotiated search show that the algorithm can produce high-quality solutions. they also support the claim that the algorithm is flexible enough to work in reusable-agent systems where the search operators are randomly distributed across the agent set. we see negotiated search as a default algorithm-one that will provide reasonable solutions in a reasonable amount of time without problem-specific customization. as a complementary approach to developing this general algorithm  we are developing customized algorithms that require specific agent characteristics or inter-agent relationships to exist. by taking advantage of these characteristics  it is often possible to improve solution quality and/or processingtime performance. team supports the dynamic selection of a search algorithm  thereby enabling an agent set to switch to a customized algorithm if the requirements for application of the algorithm are met. this work is described in  lander  1 . 
acknowledgements 
we thank margaret connell and kevin gallagher for their support in this project. gbb  a system integration tool from blackboard technology group  was used as the basic platform on which our framework was built. 
