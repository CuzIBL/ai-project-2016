 
       in t h i s paper we present a branch and bound  b&b  f o r m u l a t i o n f o r f i n d i n g the minlmax value of a game t r e e and show  that in case a subset w i t h the best bound is chosen f o r branching  the r e s u l t i n g a l g o r i t h m is i d e n t i c a l to the sss* algorithm which stockman  has shown to be better than the alphabeta algorithm f o r game t r e e searching. we propose p a r a l l e l implementations of b&b search f o r the m i n i -
max evaluation of game trees which lead to a p a r a l l e l implementation of sss*. the branch and bound approach provides a u n i f i e d way of formulating and analyzing t r e e searching algorithms such as sss* and alpha-beta. viewing sss* t h i s way  i t s correctness proof is much easier than given in stockman  as is a correctness proof for p a r a l l e l implementations of sss*. 
i n t r o d u c t i o n 
       viewing game trees as and/or trees it can be shown  that search f o r the minlmax value of a game t r e e is equivalent to searching for the maximum valued s o l u t i o n t r e e   where the value of a s o l u t i o n t r e e is defined to be the minimum of a l l i t s t i p 
values. the a l g o r i t h m   sss*  based on state space search  was introduced by stockman f o r computing the minlmax value of game trees and shown to be b e t t e r than alpha-beta. we formulate a general branch & bound procedure to f i n d the optimum s o l u t i o n t r e e in the space of a l l possible s o l u t i o n trees represented by a game t r e e and show that sss* can be viewed as a 
p a r t i c u l a r p r a c t i c a l implementation of the b&b p r o cedure. we also i n d i c a t e b r i e f l y how t h i s formulat i o n a p p l i e s to the d e f i n i t i o n and a n a l y s i s of alphabeta and p a r a l l e l sss*. 
       a b&b procedure can be viewed as a technique for f i n d i n g the optimum value  maximum or minimum  of a r e a l valued f u n c t i o n f  over a possibly i n f i n i t e domain s  without computing the value of the f u n c t i o n f o r every member of the domain. the o r i g i n a l set is repeatedly decomposed  branch operation  i n t o smaller and smaller s e t s . lower and upper 
bounds of the f u n c t i o n f f o r these sets are c a l c u l a t e d . assuming we are searching for the maximum  if the lower bound on f f o r a set x exceeds the upper bound f o r any other set y  set y can be ignored  bounding operation  since some member of set x w i l l 
* this research was supported by nsf grant ecs-1 to the laboratory f o r pattern analysis. always have a higher f value compared to a l l members of set y. if it can be shown that f o r any member x of set x there e x i s t s y as a member of set y such that f   y     f   x     then y dominates x and set x can be excluded from f u r t h e r consideration without loss of o p t i m a l i t y . this dominance r e l a t i o n was used in kohler & s t e i g l l t z  and is f u r t h e r d i s cussed in i b a r a k i   1   . branch and bound procedures have been widely used f o r combinatorial o p t i m i z a t i o n problems. our study of p a r a l l e l sss*  and p a r a l l e l alpha-beta  suggests that other b&b p r o cedures f o r v a r i o u s o p t i m i z a t i o n problems can also be implemented in p a r a l l e l . 
a branch & bound procedure f o r sss* 
       let s denote the set of a l l s o l u t i o n trees r e presented by a game t r e e   tt denote the c o l l e c t i o n of sets of s o l u t i o n s trees under consideration f o r branching and bounding  u be the upper bound d e fined on a set of s o l u t i o n trees and d be the domiance r e l a t i o n . the s e l e c t i o n of the set w i t h m a x i mum upper bound  from it  is denoted by s tt  . the f o l l o w i n g b&b a l g o r i t h m terminates w i t h the optimum s o l u t i o n t r e e : 
1.   i n i t i a l i z e   	tt  - s; u s   ＊ +   . 
1.  select  choose the set w i t h the highest upper bound: m  - s tt . 
1.  dominance test  if the chosen set dominates other sets e l i m i n a t e them. 
1 .  termination test  i f a l l the s o l u t i o n trees represented by the set m have some unexplored t i p nodes in common  go to step 1; else if the set is a s i n g l e t o n   terminate-the optimum d e c i s i o n t r e e has been found. if the set is not a s i n g l e t o n and does not have common t i p s go to step 1. 
1.  branch  divide the set m in several subsets. associate w i t h each generated subset the upper bound associated w i t h the parent set m. put a l l the generated sets i n t o it. 
1.  evaluate  explore the t i p node ti which is common to a l l s o l u t i o n trees in the set and u p date the upper bound: u m  * min  u m   v a l u e   t l   } ; put the set back i n t o tt and go to step 1. 
figures 1 & 1 show how the a l g o r i t h m works. 
　　　
1 
　　　
　　　the algorithm terminates with the optimum solution tree because ve start with the complete set of solution trees  divide it into smaller and smaller sets  and eliminate a set only if we are certain that the optimum tree does not l i e in i t . termination occures when a singleton set having been completely explored   i . e .   its upper bound is i t s true value  is chosen in step 1 as a set with the highest upperbound. at that point one can be certain that no other set has a solution tree better than the one chosen. the algorithm is bound to termi-
nate because we start with a f i n i t e set of f i n i t e size solution trees. in each iteration of the a l gorithm we are either eliminating some set of solution trees from further consideration or evaluating some unevaluated tips of some solution trees. 
　　　the detailed presentation of sss* in stockman  is not as transparent as the above b&b formulation but it can be easily seen that sss* is equivalent to the b&b procedure presented above. sss* maintains a l i s t of states of traversals  called open   each representing a set of solution trees and the current upperbound associated with i t . state expansion directly corresponds to branching  and purging of states from open corresponds to eliminating the dominated sets of solution trees. thus sss* can be considered a practical implementation of the above b&b procedure. sss* is of interest because it was proved by stockman that it never explores a node that alpha-beta can ignore. for pract i c a l distributions of t i p value assignments stockman experimentally showed that sss* explores s t r i c t l y fewer game tree nodes than alpha-beta. we have shown that by defining a particular depth f i r s t strategy for selection in the above procedure  one gets the well known alpha-beta algorithm. with a different choice of select  branch and evaluate functions we can come up with the  scout  algorithm proposed by j. pearl . several other competing algorithms also can be derived in this manner. the above branch & bound method provides a unified approach to formulating and analyzing various search algorithms for and/or trees. 
an asynchronous parallel procedure; 
preliminaries 
　　　while performing set divisions  node expansions in sss*  if the upperbounds of a l l sets  of solutions trees  under consideration are reduced to some value u'  then the b&b procedure w i l l s t i l l find the true optimum solution tree if i t s value happens to be less than uv. however if the value of the optimum tree is greater than or equal to u' then the algorithm w i l l terminate with the value u  let bb s u'  be the value returned by b&b if at some time before it terminates upperbounds of a l l sets are lowered to u'- and let u* be the value of the optimum tree. then 
u*   u' bb s uf  - u*; 
　　　　　u*  - u' bb s u'  - u  the validity of this statement can be easily proven by thinking of the act of lowering the upperbounds of the sets as adding an extra leaf node with value u' to a l l the solution trees under consideration. since the optimum value of a solution tree is the minimum of a l l the values at the tips  this modification w i l l keep the optimum value intact if it was already below u'. 
　　　it is easy to show that the number of tip nodes evaluated by b&b  or sss*  is a monotonically increasing function of the i n i t i a l bound associated 
with the starting set of solution trees. the i n i t i a l bound represents the guessed value of the optimal solution tree. the more accurate this guess  the more effective the dominance relation becomes. in alpha-beta  this corresponds to making more cutoffs when better alpha and beta bounds are known. experiments have shown that if game tree node values are chosen independently from a uniform distribution between 1 and m  then the dependence of the number of nodes expanded on the i n i t i a l bound is as shown in figure 1. as long as the chosen bound is above the true minimax value  the smaller bound provides the correct minimax value at a significantly lower cost. this fact can be used in a seemingly very efficient asynchronous parallel procedure for searching game trees  which compares favorably with baudet's parallel implementation of alpha-beta . 
parallel implementation of sss* 
　　　let us assume that the minimax value of a game tree lies between -m and -hn with uniform probability. if we have just one processor we would start b&b with -hn as the i n i t i a l upper bound for the complete set of solution trees. as branching and node expansion proceed  upper bounds for various generated subsets would become lower and lower. at termination we would find that the upper bound of a set  which has just one completely explored solution tree  becomes equal to its own optimum value and is higher than the upper bounds of a l l the other sets. 
　　　with multiple processors we could start several b&b procedures  one on each available processor  each with a different i n i t i a l upper bound as shown in figure 1. any time a process lowers i t s current global upperbound it can be guaranteed that the minimax value is less than or equal to this lowered global upper bound. thus in fig. 1  if process *n' manages to lower its upper bound we can guarantee that the minimax value lies between -m and bn where bn is the current global upper bound of process n. if process n is allowed to proceed it w i l l terminate with the correct minimax value.  note that in the beginning we could only guarantee that process 1  with the i n i t i a l global upper bound of +m  would terminate with the correct optimum value . it is clear that processes 1 through n-1 can safely reduce their global upper bounds to some 
values below bn and thus perform the look ahead function which was previously performed by proces-
ses 1 to n. thus among the n processes at least one is guaranteed to find the optimum value and the others perform a look ahead function. at any time a process searching in a lower range finds that i t s global upper bound is correct  i . e .   it can be lowered  it can take over as 'master' and the other processes can perform the look ahead. these parall e l processes work independently and communicate only if the bounds are lowered. therefore this 
　　　
 1 
　　　

1 
