 
¡¡in this paper  we show how we conceive the proof of theorems by sructural induction our aim is to facilitate the proof of the theorems which can lead  in a context of automatic theorem proving  to very lengthy  or even impossible  proofs 
we use a very simple tool  the i-matching or inductionmatching  which allows us  on the one hand to define an original procedure of generalization  and on the other hand to define an original way of generating lemmas. 
1 introduction 
   in this article we intend to show how we understand the problem of the generalization of the theorems. we shall propose two examples with this help  we shall demonstrate that the solution we propose is : 
   1 clearly justified by our aim of facilitating the proof of theorems 
   1 clearer than the solutions proposed by boycr and 
moore  aubin  and also includes them 
1 the formal system 

   in kodratoff-castaing  a    we presented an automatic theorem proving based on the principle of structural in duction |1|. we followed on from the works done by boyer and moore   aubin i1 | and huet and hullot . our method is now implemented in lisp  vax . 
generally  when we want to prove a theorem using structural induction  we first have to prove one or more basic cases and then  one or more induction steps  in our method we try a new and we hope an original approach  to prove the induction steps. we use a very simple tool which we call l matchimg  induction -matching  . briefly  it is used as follows  for a more detailed explanation see our previous article |1| : let m =  n be any induction steps to be proven  m be any hypothesis and n the associated conclusion. if there is any substitution o such that : o m  - n  and the induction variables chosen do not belong to the domain of substi tution  then the induction step m =  n is proved. such a substitution o characterizes the induction -matching. it also shows that the hypothesis m is general enough to consider the conclusion n as an instance of m  and to put n among all the accepted hypotheses . 
it is obvious that only easy theorems can be proved by induction - matching. if the matching of m toward n fails   we try to remove the causes of the matching failures either by generalizing the theorem  or by generating intermediate lemmas. so  proving theorems in our method is in fact solving the problems of matching. 
   we suppose that all the conditions which allow us to manipulate the theorems  and to prove them by using induction in abstract data types are verified . that's to say: 
   1 the domain  type support  is generated by a family of constructors supposed not to be related we can define  on this domain  the following well-founded ordering  
denoted by   ; x   y iff x is a subterm of y 
   1 the functions are complicity defined by a set of ax loms . from these axioms  one can obtain a canonical rewrite system named r. 
   1 the particular properties of the functions given by the users are contained in the set of equations e. 
   in this paper  we apply our method to the following two examples : 
r     eql  app x  app x x    app app x x  x   t1 :  eqll  rev x   foo x nil  . 
  new address : lipn. univ. de paris nord 
avenue j-r element f 1 villetaneuse ' the first theorem shows that the function app  append in lisp  is associative. the second shows the equivalence between two programs which compute the reverse of a list. the domain is the set of lists of integers   denoted by list. it is generated by the two constructors  nil   cons   where cons is the binary operator cons : int x list -  list  lnt denotes the set of natural integers  generated 

   when we dispose of a canonical rewrite system  we can evaluate any term m and find its normal form  denoted by ml  by applying the rules in any order. but  it may happen in some particular case  that we have to define a precise order in the application of the rewrite rules. in this article  we use call- by- need evaluation . we show how we can apply it. 
we proceed by steps . first  we try to reduce m at the empty sequence of occurrences  i.e. wc try to apply one of the rewrite rules which gives the definition of the leftmost function symbol in m. if we succeed  we reduce m and obtain a new term m' to which we apply again the same process of evaluation. if we fail  we let  u1 up  be the sequence of the occurrences of subterms of m  which must be evaluated in order to apply one of the previous rewrite rules. then  we reduce m successively at the occurrences u1  up by applying the same process of evaluation. 
the call-by-need evaluation stops either in the case where the normal form of m is an element of the domain  or in the case where the subterms of m to the occurrences u1 up .denoted by m/u1  m/up   are variables. in this case   to use aubin's terminology  we say that these variables are recursion variables  or are in the recursion position. generally  we can also say that the subterms of m which must be evaluated in the call-by-need rule  are in the recursion position. 
	j.castaing 	1 
example : 
we evaluate the term m =  eql  app x  app x x    app app xx x  . 
step-1 : we try to reduce m at the empty sequence of occurrences. we have to evaluate the subterms of m at the occurrences 1 and 1  in order to apply one of the four rules r1 r1  which give the definition of eql. 
step-1 : for evaluating the subterm m/l  we must instanciate the variable at the occurrence 1. for evaluating the subterm m/1  we must evaluate the subterm m/1  
stcp-1; we have to instanciatc the variable at the occurrence 1.1. 
the two occurrences of the variable x  1 and 1.1  are in the recursion position. 
1 generalization : existant solutions 
   the need for an efficient procedure of generalization has been expressed in  1 1   in such a procedure  we have to define a criterion of choice of the subterms to be generalized in a theorem  verify the new proposition obtained  and give a new way of proceeding if the generalized proposition obtained is a false one. otherwise  the method proposed fails. 
   we now analyse boyer and moore s and aubin's solutions. 
   boyer and moore choose the subterms to be generalized according to their syntax. they replace  in the theorem to be proved  some syntatically identical subterms by the same new variables. this simple procedure suits the proving of a large class of theorems  because it is used in a framework of the strategy of crossfertilization . this strategy reduces the induction steps p' = q' =  p =h  q'  where p'.q' and p arc recursively defined functions  to a new lemma p = h p'  to be proved. if the term p is defined by g p'   then the new theorem to be proved g p'  = h p'  can be generalized to g u  = h u   where u is a new variable. we must be careful if we want to extend the application of this principle  because the new proposition obtained can be a false one. for example  if we generalize the theorem t1 by this principle  the new theorem obtained by replacing the subterms  app x x  by a variable u is in fact a false one. 
   thus  we can make some remarks about the boyer and moore 's solution. their principle docs not indicate how to go on if the proposition obtained is a false one. their principle cannot be fully justified. one can only establish that very often  the generalized theorem can now be proved 1 	j.castaing 
   aubin proposes two heuristics of generalization in order to improve on the boyer and moore s principle in these two heuristics  he chooses the subterms to be generalized according to their position in the theorem. he distinguishes a recursive function from a tail-recursive function. in practice  the distinction between these two kinds of functions is the presence in a tail-recursive function of accumulators which are variables  whose role is to contain the partial result of the evaluation of the function. for example  the function foo whose definition is given in the paragraph above  is a tail-recursive function  because the variable y is an accumulator  while the function app is a recursively defined one. 
   for recursive functions  he uses the same criterion for selecting induction variables  and for choosing the subterms to be generalized  he chooses the induction variables among the recursion ones so  he selects among the set of occurrences of the same subterm in the theorem  those which are in position of recursion  and gives them the same name 
for example  he generalizes the theorem r  by replacing the occurrences 1 and 1 of the same variable x   by a new variable u he thus obtains the new proposition to be proved   eql  app u  app x x    app  app u x  x  . 
   generally  if the new proposition obtained is a false one  he analyses the subterms which are left in the theorem  and tries to generalize those which are syntatically identical to the recursion subterms. 
   for tail-recursive functions  aubin generalizes the constants which are in the position of accumulators. the principle used is called  indirect generalization   because the subterms to be generalized are now in the accumulator position  and not in the recursion position. 
aubin justifies his choice by the following remark : if the theorem to be proved is an equivalence one  the presence of these constants causes the failure of the proof by cross-fertilization. 
let us verify this remark with the help of theorem t1. 
example: 
t1 -  eql  rev x   foo x nil   
let m = t1  x ; let n = t1  x  -  cons a x  ! =  ecjl  app  rev x   cons a nil    foo x  cons a nil   . 
the induction step is m -  n. to cross-fertilize is to apply the hypothesis as a rewrite rule. we can extract two rewrite rules from m. the first one   foo x nil  -   rev x   can not be applied  the presence of the constant nil in the accumulator position of the function foo  leads the matching of  foo x nil  with  foo x  cons a nil   to fail the second rule   rev x  -   foo x nil  reduces the induction step to a new lemma  ta -  eql  app  foo x nil   cons a nil    foo x  cons a nil   . 
in order to prove t1. we have to prove the induction step t1  x  =  r1  x  -  cons b x  . by applying again the same strategy of cross-fertilization  we can now establish that the presence of the constants nil and  cons a nil  at the occurrences 1.1 and 1 prevents us from using the hypothesis as a rewrite rule. so  the proof of t1 fails according to the argument given by aubin. 
   if the new proposition obtained by replacing the same constants by a new variable is a false one   and that is the case in our example  the proposition obtained  ecjl  rev x   foo x v   being a false one   aubin proposes to make appear some new constants in the theorem  that he also generalizes. we describe how he proceeds. he matches m with n and looks for the other causes of the failure let us suppose that the matching fails because the substitution is attempted on a function symbol. he tries to remove this failure by applying a procedure called a procedure of expansion . he introduces in m the function symbol which is responsible for the failure  and completes its definition in order to obtain a new hypothesis m' equivalent to m. this last condition is satisfied if the function introduced has a neutral element. 
example : 
m =  eql  rev x   foo x nil  . 
n =  eql  app  rev x   cons a nil    foo x  cons a nil   . the matching of m with n fails at the occurrence 1  because the substitution is attempted on the function symbols rev and app  and fails at the occurrence 1  for the reason given by aubin. 
according to the procedure of expansion  aubin introduces at the occurrence 1 the symbol app  and completes its definition by adding the term  rev x  followed by the neutral element of app which is nil. 
the new hypothesis obtained is m' -  eql  app  rev x  nil  
 foo x nil  . now  the generalized expression of m'   eql  app  rev x  v   foo x v  . is the new theorem to be proved. 
   the two solutions given by aubin allow us to extend the class of theorems which can be proved. but  we can point out some weaknesses. 
the heuristic used for recursive functions is not fully justified. indeed  the new variable introduced in the theorem is considered as an induction variable at the next step  when the same method is applied again : we do not know whether the proof of the new theorem obtained can now be facilitated or even carried out. moreover  we do not like the combinatorial aspect which is associated to the choice of the subterms to be generalized. the second heuristic proposed is more interesting. it is justified by the intention of its autor to use the hypothesis as a rewrite rule. on the other hand  we think that the aubin's way of continuing  when the generalized proposition is a false one  can be extended without considering the different kinds of functions. the real purpose is to remove the causes of the failure of the matching of m with 
n. we now show  using theorem t1 as an example  that the subterms choosen by aubin  at the occurrences 1 and 1.1  are in fact a part of all the subterms which arc responsible for the matching failure. 
example : 

   1 we detect a contradictory substitution on the variable x  x  - x and x  -  cons a x  at the occurrences 1  1.1. 1.1  1. 
   1 the substitution is attempted on the function symbols cons and app at the occurrence 1. the subterms responsible for the matching failure are at the occurrences 1  1  1.1  1.1  1. aubin generalizes the subterms at the occurrences 1  1.1  which are only two causes of the matching failure. 
our method systematizes this approach. 
1 our solution 
   it consists of two steps  the first one will be exemplified by the proof of theorem t1 the second one by the proof of theorem tz. 
we assume that the basic cases arc proved let m =  n be any induction step. if m i-matches with n then the induction step m =  n is proved. let us suppose that the i-matching fails. as we have already indicated in the introduction  the i-matching is a particular matching such that the induction variables do not belong to the domain of of the substitution. so  we can deduce that either the matching fails  or one of the induction variable belongs to the domain of the substitution. 
we put in the two lists lm and ln  all the subterms of m and n which are responsible for this failure  each of them being labelled by its occurrence in m or in n. 

a. first step : generalization 
deflnition-1 : we say that wc  savagely  generalize the term m at the occurrences u1  uq  if we replace the subterms of m at these occurrences by new distinct variables v1... vq. 
	j. castaing 	i1 
deflnition-1 : let m/ui be an element of the list lm. let m/ u1 m/ uin be the set of all the subterms of m which are syntatically identical to the subterm m/ ui if we generalize m to the occurrences ux uin  we call the new variables introduced  vl vn  separated variables 
deflnition-1 : we collect a set of separated variables 
vi vkl if we give them the same variable name  let be u  
the susbtitution r -   v   - u vk  - u  symbolizes this collection. 
basic idea 
¡¡broadly speaking  we apply a strategy which generalizes too much  and then find for particular values of the variables  the conditions which make the generalization true so  we savagely generalize m at the occurrences u1  uq  given in the list lm. let mg  x  v1 ...vg  be the generalized expression obtained  where x is the set of all the variables of m different from the vi. generally  this expression is a false proposition. we look for the conditions on the variables vi's  so that mg  x v1... vg  can now be specialized in a new proposition which is true  and upon which we apply our method of proof once again. 
   in practice  it is very difficult to find the conditions on the vi. if m contains a predicate of equality  to specialize mg  x  v1 .... vq  is in fact to solve some equations of diophantinc type. so  we limit ourselves to simply finding the equality relations between the variables vt's. we now show how we proceed. 
practical application 
we consider the first cause of failure in lm  m = m/u1. 
   1 we savagely generalize m at the occurrences of all the subterms of m which are syntatically identical to m. let v1....vn be the sequence of separated variables introduced in m. we successively give the particular values e1 em to the variables of x  and we compute the normal forms mg-1 = mg  x  - e1  v1 vn  mg-m = mg  x  em  v1  vn . these particular expressions only contain separated variables 
   1 let i = 1. we apply the call-by-need evaluation to the term mg-i. let vri =  vi vk  be all the recursion variables of mg-i. 
   1 let vri =  -u  vn  - vrt be the set of all separated variables which arc left  if any are left . we first collect the variables of vri by giving them the same name u  then we also collect the variables of vrt' by giving them the same name v. let r be the substitution which symbolizes these two collections. 

1 	j.castaing 


lm= f  rcvx   1    nil  1    
ln =    app  rev x   cons a nil    1     cons a nil   1  . 
e =   app x nil  = x . 
as the reader can remark  we fail on generalizing t1. so  we reduce m at the occurrence 1 by the rule x -   app x nil .  we obtain the new hypothesis m' =  eql  app  rev x  nil   foo x nil  . the i-matching of m' with n fails  and lm' is   nil  1    nil  1  . we come back to the first step after removing the equation  app x nil  = x from e. so  e is now an empty set. 
we savagely generalize the term m' at the occurrences 1 and 1. we obtain mg  x  v1 vz  =  eql  app  rev x  v1  
 foo x v1  . we give to the variable x the particular value x 
= nil  and the normal form of mg  x  - nil  v1 v1  becomes  eql v1 vg . we collect these two variables which are recursion variables : v = v1 - v1. the new theorem to be proved is now t1 =  ccjl  app  rev x  v   foo x v    let us prove theorem t1. the basic case t1  x  - nil  is reduced to true by our rewrite system. the induction step is 
m =  n  where 
¡¡m = t1  x  =  eql  app  rev x  v   foo x v   
¡¡n = t1  x  -  cons a x    =  eql  app  app  rev x   cons a nil   v   foo x  cons a v   . 
the subterm  foo x v  i-matches with the subterm  foo x 
 cons a v   with the substitution o =  v  -  cons a v    x does not belong to the domain of a . so  the new theorem to be proved is now t1 =  eql  app  rev x   cons a v    app  app  rev x   cons a nil   v  . our procedure of generalization proposes as a new theorem t1 =  eql  app u  cons a v    app  app u  cons a nil   v    which can now be proved by using the i-matching. we have facilitated the proof of theorem t1. 
conclusion 
   we can now specify the reasons which allow us to think that our method includes those of boyer and moore and aubin. 
   1 our procedure of generalization contains the two heuristics used by aubin for the choice of the subterms to be generalized. 
   1 we use the same strategy of proof as these autors when we apply the procedure of expansion  or when we cross-fertilize. 
	j.castaing 	1 
1 