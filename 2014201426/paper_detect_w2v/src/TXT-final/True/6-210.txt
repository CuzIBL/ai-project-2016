 
temporal constraint satisfaction problems allow for reasoning with events happening over time. their expressiveness has been extended independently in two directions: to account for uncontrollable events  and  more recently  to account for soft temporal preferences. the motivation for both extensions is from real-life temporal problems; and indeed such problems may well necessitate both preferences and uncertainty. this paper proposes the study of temporal problems with both preferences and uncertainty  and puts forward some methods for their resolution. 
1 motivation and background 
research on temporal reasoning  once exposed to the difficulties of real-life problems  can be found lacking both expressiveness and flexibility. planning and scheduling for satellite observations  for instance  involves not only quantitative temporal constraints between events and qualitative temporal ordering of events  but also soft temporal preferences and contingent events over which the agent has no control. for example  on one hand  slewing and scanning activities should not overlap  but may if necessary. on the other hand  the duration of failure recovery procedures is not under the direct control of the satellite executive. to address the lack of expressiveness  preferences can be added to the framework; to address the lack of flexibility to contingency  handling of uncertainty can be added. some real-world problems  however  have need for both. it is this requirement that motivates us. 
　in a temporal constraint problem  as defined in dechter et al   variables denote timepoints and constraints represent the possible temporal relations between them. such constraints are quantitative  describing restrictions on either durations or distances of events  in terms of intervals over the timeline. in general such problems are np-complete. however  if each temporal constraint has just one interval - hence 
the constraints have form where denote the timepoints - then we have a simple temporal problem  stp  that can be solved in polynomial time. 
'partially supported by the epsrc under grant gr/n1. 
f
    partially funded by the italian miur projects napoli and cover  and the asi  italian space agency  project ariscom. 
　to address the lack of expressiveness in standard stps  the simple temporal problems with preferences  stpp  framework merge stps with semiring-based soft constraints  rossi et al  1 . soft temporal constraints are specified by means of a preference junction on the constraint interval   where a is a set of preference val-
ues. the set a is part of a semiring. in general  stpps are np-complete. however  if the preference functions are semi-convex  that is  they have at most one peak   the constraints are combined via an idempotent operation  like max or min   and the preference values are totally ordered  then finding an optimal solution of a stpp is a polynomial problem. two solvers for stpps with the features above are presented by rossi et al. . the first  path-solver  enforces path consistency in the constraint network  then takes the subinterval on each constraint corresponding to the best preference level. this gives a standard stp  which is then solved for the first solution by backtrack-free search. the second solver  chop-solver  is less general but more efficient. it finds the maximum level y at which the preference functions can be 'chopped'  i.e. reduced to the set 
this set is a simple interval for each i. hence we obtain a standard stp  stpy. by binary search  the solver finds the maximal y for which stpy is consistent. the solutions of this stp are the optimal solutions of the original stpp. 
to address the lack of flexibility in execution of standard 
stps  vidal and fargier  introduced simple temporal 
problems under uncertainty  stpus . here  again as in a 
stp  the activities have durations given by intervals. the timepoints  however  fall into two classes: requirement and contingent. the former  as in a stp  are decided by the agent  but the latter are decided by 'nature': the agent has no control over when the activity will end; he observes rather than executes. the only information known prior to observation is that nature will respect the interval on the duration. controllability of a stpu is the analogue of consistency of a stp controllable implies the agent has a means to execute the timepoints under his control  subject to all constraints. three notions are proposed. a stpu is strongly controllable if there is a fixed execution strategy that works in all realisations  that is  an observation of all contingent timepoints . checking strong controllability is in p  vidal and fargier  1 . a stpu is dynamically controllable if there is a online execution strategy that depends only on observed timepoints in the 

poster papers 	1 

past and that can always be extended to a complete schedule whatever may happen in the future. checking dynamic controllability is also in p  morris et al  1 . a stpu is weakly controllable if there exists at least one execution strategy for every realisation. checking weak controllability is co-np  vidal and fargier  1 . the three notions are ordered by their strength; strong  dynamic  weak. 
　in this paper we introduce a framework which allows one to handle both preferences and uncertainty in temporal problems. this is done by just merging the two pre-existing models of stpps and stpus. we also adopt the notion of controllability  to be used instead of consistency because of the presence of uncertainty  and we adapt it to handle preferences. we then investigate the complexity of checking such notions of controllability  and we develop algorithms to perform such checks. the main results are for strong and weak controllability  which we show to maintain the same complexity as in stpus under the same hypothesis that make stpps polynomial  solvable. as future work  we plan to study dynamic controllability  and to implement our algorithms to compare their performance experimentally. 
1 	simple temporal problems with preferences and uncertainty  stppu  
a stppu is a stpp with timepoints partitioned into two classes  requirement and contingent  just as in a stpu. since some timepoints are not controllable by the agent  the notion of consistency of a stp p  is replaced by controllability  just as in a stpu  with the three notions suitably extended. while all three notions of controllability used for stpus can be adapted to stppus  for this short paper we will focus on just weak and strong controllability. a stppu is optimally strongly controllable if there is a fixed execution strategy that works in all realisations and is optimal in each of them. rather than optimality  one could be interested in 
just reaching a certain quality level: a stppu is a-strongly controllable  where a is a preference level  if there is a fixed execution strategy that works in all realisations and is above a in each of them. a stppu is optimally  resp. a-  weakly controllable if there exists at least one optimal  resp.  above a  execution strategy for every realisation. 
1 	checking optimal and a strong controllability 
it can be proved that checking either optimal or a strong controllability is in p. the method we propose relies on two known algorithms. the first is path-solver  which enforces path consistency on a stpp. the second is strongcontrollabillty stpu   vidal and fargier  1   which checks if a stpu is strongly controllable. the main idea is to apply strong-controllability stpu  to a special stpu  which we will call popt  that can be constructed starting from the stpp p' obtained by applying path-solver to a stppu p. 
more precisely  the algorithm takes as input a stppu p and performs the following steps:  1  forgetting the uncertainty  treat p as a stpp and apply path-solver to it  obtaining the stpp p'   1  collapse the non-contingent intervals of p' to those parts which have the highest preference level  and then neglect the preferences  obtaining a stpu popi;  1  apply strong-controllability to popt. theoretical results that we have proven  but omit for lack of space  show the correctness of the algorithm:  1  if a stppu is optimally strong controllable  then the stpu obtained by neglecting preferences is strongly controllable;  1  a stppu p is optimally strong controllable if and only if the stpu popt is strongly controllable. 
we have also generated a different algorithm by combining 
strong-controllability with chop-solver. this algorithm is less general but more efficient. both algorithms we propose are polynomial  with a time complexity 1 n1 x rx /   where n is the problem size  r is the range of the largest interval  and / is the number of preference levels. 
　for a-strong controllability  we rely on theoretical results similar to those above  and we propose two algorithms. given a  the first one checks a-sc by: cutting the intervals to those parts whose preference is above a  and applying strong controllability checking to the resulting stpu. the time complexity is 1 n1 x r . the second algorithm finds the highest a at which p is a-sc  by performing a binary search for the highest a  checking strong controllability at each step. its time complexity is 1 p x n1 x r   where p is proportional to the precision we want in returning the result. 
1 	checking optimal and a weak controllability 
optimal weak controllability of a stppu is equivalent to weak controllability of the corresponding preference-stripped stpu. thus we can use the existing stpu algorithms for checking weak controllability. for checking a-weak controllability  we propose two approaches. the first chops the stppu at level a by considering only those parts of its intervals which have preference level above a  semi-convcxivity guarantees that the result is always a single interval   and then applies weak-controllability to the stpu so obtained. the second approach generates the realisations that arise by considering the contingent intervals reduced to just their upper or lower bound  other realisations need not be considered   vidal and fargier  1    and checks the consistency of all such realisations. both algorithms are exponential in the number of contingent constraints. 
