
max-sat is an optimization version of the wellknown sat problem. it is of great importance from both a theoretical and a practical point of view. in recent years  there has been considerable interest in finding efficient solving techniques  alsinet et al.  1; xing and zhang  1; shen and zhang  1; de givry et al.  1 . most of this work focus on the computation of good quality lower bounds to be used within a branch and bound algorithm. unfortunately  lower bounds are described in a procedural way. because of that  it is difficult to realize the logic that is behind.
in this paper we introduce a logical framework for max-sat solving. using this framework  we introduce an extension of the davis-putnam algorithm  that we call max-dpll  and the resolution rule. our framework has the advantage of nicely integrating branch and bound concepts such as the lower and upper bound  as well as hiding away implementation details. we show that max-dpll augmented with a restricted form of resolution at each branching point is an effective solving strategy. we also show that the resulting algorithm is closely related with some local consistency properties developed for weighted constraint satisfaction problems.
1 introduction
since the eighties  both boolean satisfiability and constraint satisfaction have been the topic of intense algorithmic research. in both areas  the goal is to assign values to variables in such a way that no forbidden combination of values appear in the solution. in satisfiability  forbidden combinations are specified by means of clauses. in constraint satisfaction they are specified by means of arbitrary constraints. given its similarity  it is hardly a surprise that both research communities have developed closely related techniques.
¡¡in both fields  the original decision problem  sat and csp  respectively  has been augmented to deal with unfeasible problems  namely  not all the clauses or constraints can be satisfied . the new goal is to find an assignment that best respects the clauses/constraints. two well-known examples are max-sat  hansen and jaumard  1  and weighted csp  wcsp   bistarelli et al.  1   where most of recent algorithmic work has focused. in both cases the importance of the clauses/constraints is given by a weight and the goal is to minimize the sum of weights associated with the clauses/constraints violated by the assignment. it is known that max-sat instances can be translated into wcsp instances and vice versa  de givry et al.  1 . in both cases the main solving technique are enumeration algorithms based on branch and bound search.
¡¡in the csp side  several local consistency properties have been recently generalized to the wcsp framework  cooper  1; larrosa and schiex  1; 1; de givry et al.  1 . as a result  a new family of algorithms have been proposed. besides being efficient  these algorithms have a highly desirable property: they can be neatly described as a basic backtracking search in which certain local consistency property is enforced at every search state.
¡¡in  de givry et al.  1   it was shown that max-sat instances could be efficiently solved by translating them into equivalent wcsp instances and later using a wcsp solver. the level of local consistency maintained by the wcsp solver was fundamental in the efficiency of the algorithm.
¡¡in this paper we analyze the interpretation of wcsp local consistency properties and related algorithms when applied to max-sat instances. to facilitate the connection  we start by providing a reformulation of max-sat in which it is possible to explicitly express a lower and an upper bound of the optimal cost  section 1 . such reformulation makes possible an elegant extension of dpll in which each branching point is just a max-sat instance  similarly to what happens with dpll in sat  section 1 . in section 1 we present our main contribution: a generalization of the resolution rule  x¡Åa x¡¥¡Åb   a¡Åb  and the proof that neighborhood resolution  i.e.  a restricted form of resolution  suffices to enforce  weighted  node and arc consistency. in section 1 we put our approach in context with other max-sat algorithms. finally  in section 1 we provide conclusions and directions of future work.
1 preliminaries
in the sequel x = {x1 ... xn} will denote a set of boolean variables. they take values over the set {t f}  which stands for true and false  respectively. a literal l is either a variable x or its negation ¡¥x. l¡¥stands for the negation of l.
¡¡if variable x is instantiated to t  noted x ¡û t literal x is satisfied and literal ¡¥x is falsified. similarly  if x is instantiated to f  ¡¥x is satisfied and x is falsified. an assignment is an instantiation of a subset of the variables. the assignment is complete if it instantiates all the variables in x  otherwise it is partial . an assignment satisfies a clause  i.e.  a disjunction of literals  c iff it satisfies one or more of its literals. it satisfies a set of clauses f iff it satisfies all its clauses. a satisfying complete assignment is called a model. given a boolean formula encoded by a set of clauses f   the sat problem consists in determining whether there is any model for it or not.
¡¡we will use the symbol 1 to denote the empty clause which  obviously  cannot be satisfied. when 1 ¡Ê f we say that there is an explicit contradiction.
¡¡when there is no model for the formula f   one may be interested in finding the complete assignment with minimum number of violated clauses. this problem is known as maxsat.
1 an equivalent reformulation of max-sat
there is a weighted version of max-sat in which  weighted  clauses are pairs  c w  such that c is a classical clause and w is the cost of its falsification. in weighted max-sat f is a set of weighted clauses. the cost of an assignment is the sum of weights of all the clauses that it falsifies. the goal is to find complete assignments with minimal cost. we make the usual assumption of weights being natural numbers.
¡¡it is easy to see that max-sat and weighted max-sat have exactly the same expressive power. a max-sat instance can be rewritten as a weighted instance replacing every clause c by a weighted clause  c 1 . a weighted maxsat instance can be rewritten as a max-sat instance replacing every weighted clause  c w  by w copies of clause c. clearly  weighted max-sat encodings may be exponentially more compact than max-sat. thus  in the following  we will assume  without loss of generality  weighted max-sat.
¡¡following previous work in weighted constraint satisfaction  larrosa and schiex  1   we assume the existence of a known upper bound k of the optimal solution. this is also done without loss of generality because  if a tight upper bound is not known  k can be set to the sum of weights of all the clauses.
¡¡consider the set f of weighed clauses. we say that a model is a complete assignment with cost less than k. maxsat is the problem of finding a model of minimal cost  if there is any.
¡¡observe that weights w ¡Ý k indicate that the associated clause must be necessarily satisfied. thus  we can replace every weight w ¡Ý k by k without changing the problem. thus  without loss of generality we assume all costs in the interval
 1..k  and  accordingly  redefine the sum of costs as
a¨’b = min{a+b k}
in order to keep the result within the interval. for convenience of notation  we will refer to k as  . we say that a weighted clause is hard  or mandatory  iff its weight is  . observe that max-sat with   = 1 is equivalent to sat.
example 1 consider the formula { x 1   y¡¥ 1   x¡¥ ¡Å y 1   x¡Åy 1 }  with   = 1. the second clause is hard. the assignment x = f y = f is not a model because its cost is 1¨’1 =  . the assignment x ¡û t y ¡û f is a  optimal  model with cost 1.
¡¡note that in max-sat truth tables are tables with a cost associated to each truth assignments. a brute-force solving method consists in computing the truth table of the input formula and finding the minimal cost model. for instance  the truth-table of the previous formula is 
x ycostf f1¨’1 =  f t1¨’  =  t f1t t ¡¡it is worth mentioning the role of the empty clause  1 w . since it cannot be satisfied  w will be added to the cost of any model. therefore  w is an explicit lower bound of the optimal model. when the lower bound and the upper bound have the same value  i.e.   1    ¡Ê f   the formula does not have any model and we call this situation an explicit contradiction.
1 generalization of dpll to max-sat
1 max-sat basic simplification rules
sat solvers take advantage from some equivalence rules that are used to simplify the cnf formula without changing its set of models. not all of these formulas can be applied directly to max-sat. in this section we state some useful max-sat specific rules. we use the notation  p ... q     r ... s   where p q ... are weighted clauses. it means that if there are in f weighted clauses matching with  p ... q   they can be replaced by  r ... s . a and b are arbitrary disjunctions of literals.
  br1:   a     a¡Åb w       a    
  br1:   a w   a u       a w¨’u  
  br1:	if  w ¨’ u =    then   a w   a ¡Å b u    
¡¡  a w   a¡Åb       br1:   a 1        
¡¡br1 shows that classical absorption can only be applied when the absorbing clause is hard. br1 generalizes the standard idempotency of the conjunction: in max-sat the weights of the repeated clauses must be added in the resulting clause. br1 is used to harden a soft clause. br1 indicates that cost-free clause can be eliminated. the correctness of these equivalences is direct and we omit the proof.
example 1 consider the formula { x 1   x 1   x ¡Å y 1   x ¡Å y ¡Å z 1 }  with   = 1. we can apply br1  which produces { x 1   x¡Åy 1   x¡Åy¡Åz 1 }. now  we can apply br1  producing { x 1   x¡Åy     x¡Åy¡Åz 1 }. finally  br1 produces { x 1   x ¡Å y   }. the equivalence between the original and the final formula can be checked by constructing and comparing the costs of the two truth-tables.
1 max-dpll
davis putnam  dpll  is the most popular algorithm for sat and the starting point of most state-of-the-art solvers  davis et al.  1 . it takes as input a cnf formula f and decides whether or not there exists a model. in this section  we present a natural extension of dpll to max-sat that we call max-dpll. let f be a weighted cnf formula and   its upper bound. max-dpll f     returns the cost of the optimal model of f if there is such a model  else it returns  . the following description is inspired by the description of dpll given in  bacchus  1 .
¡¡as in classical sat  max-dpll performs basic simplifications on its input prior to invoking itself recursively. the instantiation of a variable by forcing the satisfaction of a literal l  denoted f  l  produces a new formula generated from f as follows: all clauses containing l are eliminated  and l¡¥ is removed from all clauses where it appears. unit clause reduction  ucr  is another simplification rule that selects a clause  l     namely  a unit hard clause  and instantiates the corresponding variable in accordance to the literal in that clause. unit propagation  up  is the algorithm that performs ucr and the basic simplification rules br1 until either  a  a contradiction is achieved  or  b  there are no more possible simplifications to do.
example 1 consider the application of up to the formula { 1   x¡¥ 1   x 1   y 1   y¡¥ 1   x¡¥ ¡Å y¡¥ ¡Å z 1 }  with   = 1. rule br1 transforms it into
{ 1   x¡¥     x 1   y 1   y¡¥ 1   x¡¥ ¡Å y¡¥ ¡Å z 1 }. ucr instantiates x and produces¡¥ { 1   y 1   y¡¥ 1   y¡¥ ¡Å z 1 }. again br1 produces { 1   y     y¡¥ 1   y¡¥¡Å z 1 }  which allows ucr to instantiate y  { 1   z 1 }. again br1 produces { 1   z   }  which ucr to instantiate z producing the trivial { 1 }. the model of the original formula  x¡¥ y z  can be constructed by tracking back the truth assignments made by ucr.
¡¡a recursive description of max-dpll is given in algorithm 1. first  up is applied to the input formula  line 1 . if the resulting formula contains a contradiction  the algorithm returns   and backtracks  line 1 . else  if it does not contain any variable the trivial cost of the optimal model is returned  lines 1 and 1 . otherwise  an arbitrary literal l is selected  line 1 . the formula is instantiated with l and l¡¥ and maxdpll is recursively called with each case  lines 1 and 1 . observe that the first recursive call is made with the   inherited from its parent  but the second call uses the output of the first call. this implements the typical upper bound updating of branch and bound. finally  the best value of the two recursive calls is returned  line 1 . note that if max-dpll is executed with a sat instance  i.e.    = 1  it behaves exactly as dpll.
¡¡figure 1 reports some empirical evaluation of max-dpll on 1-variable random instances of max-1-sat and max-1sat generated with the cnfgen generator.1 the horizontal axis indicates the number of clauses and the vertical axis indicates the search effort as the number of visited nodes. each
function max-dpll f     : nat
1f :=up f  ;
1if  1    ¡Êf then return  ;
1if f = 1/ then return 1;
1if f = { 1 w } then return w;
1l :=selectlit f  ;
1v :=max-dpll f   l     ;
1v :=max-dpll f   l¡¥  v ;
1return v;
algorithm 1: max-dpll. f is a set of weighted clauses with all weights in the interval  1 ...   . if the weighted formula has models  max-dpll returns the cost of the optimal one  else it returns  
point is the mean over 1 instances. the results of maxdpll are those labelled as up  ignore  for the moment  the other curves . as can be observe  the performance of the algorithm degenerates as the number of clauses increases.
¡¡max-dpll can be enhanced by dominance rules that exploit situations where it is easy to detect that one literal is never worse than its negation. a well-known sat case  also applicable to max-sat  is the pure literal rule. it says that if there is a literal such that it appears in the formula and its negation does not appear  then all clauses mentioning it can be removed. more sophisticated dominance rules for maxsat and wcsp can be found in  xing and zhang  1; de givry  1 .
1 resolution for max-sat
while dpll seems to be the best option to find models  resolution might be more appropriate to detect contradictions.  robinson  1  showed that the resolution rule is sound and complete for sat  although it is usually too space consuming. in the sat context  the performance of dpll has been improved by the addition of limited forms of resolution at each search node  gelder  1; rish and dechter  1; bacchus  1; drake et al.  1  in order to anticipate the detection of dead-ends. in this section we generalize the resolution rule to max-sat. then we show that some local consistency techniques used in  larrosa and schiex  1  are just the application of a restricted form of the weighted resolution rule.
¡¡first we define the subtraction of weights  	 : let a b ¡Ê  1 ...    be two weights such that a ¡Ý b  a
the weighted resolution rule  res  is defined as 
m 
 m 
   x¡¥¡Åa¡¥ ¡Åb m 
where a and b are arbitrary disjunctions of literals and m = min{u w}. variable x is called the clashing variable. observe that in the u = w =   case the fourth and fifth new

	1 1 1 1
n. of clauses
figure 1: experimental results on random max-1sat  top  and max-1sat  bottom .
clauses can be removed  by br1   yielding a rule similar to classical resolution. observe as well that in the u = w     case  the second and third new clauses will have weight 1 and can be removed  by br1 . in the u 1= w case  either the second or the third new clause will have weight 1 and can be removed  by br1 . recall that in res  the left-hand clauses are replaced by the right-hand  while in classical resolution right-hand clauses are just added.
theorem 1 the transformation rule res is sound. namely  it preserves the set of models and their cost.
proof 1 the following table contains in the first columns all the truth assignments  in the second column the cost of the assignment according to the clauses on the left-hand of the res rule  and in the third column the cost of the assignment according to the clauses on the right-hand of the res rule. as it can be observed  the costs the are same  so the resulting problem is equivalent.
x a bleftrightf f fumf f tumf t f1f t t1t f fwmt f t1t t fwmt t t1¡¡the interest of res is that it makes explicit some previously hidden connection between variables in a and b. it is well known that in the sat case  i.e    = 1  the rule is complete  its application suffices to achieve a contradiction . we are still investigating under which other cases the completeness of res is guaranteed. one important problem we have detected is that the fourth and fifth new weighted formulas  i.e.   x¡Åa¡Åb¡¥ m    x¡¥¡Åa¡¥ ¡Åb m   may not be in conjunctive normal form.
1 neighborhood resolution
neighborhood resolution  cha and iwama  1  is the classical resolution rule restricted to pairs of clauses that differ only in the clashing variable. similarly  in the max-sat context we define the neighborhood resolution rule  nres  as res restricted to the a = b case  which simplifies to 
m 
a 
 x¡¥¡Åa 
whith m = min{u w}. this rule is specially useful because it projects to a costs that were implicit in the formula. we demonstrate the interest of nres considering its application to bounded-size clauses. let nresk denote nres restricted to |a| = k. nres1 yields 
 1 
 um 
 w
¡¡this rule is extremely useful because it produces a direct increment of the lower bound  which may raise a contradiction  or produce new unit clause reductions.
example 1 consider	the	formula
{ x 1   x¡¥ 1   y 1   y¡¥ 1   z 1 } with   = 1. up is unable to simplify the problem. nevertheless  nres1 can be applied to the first and second clauses producing { 1   x¡¥ 1   y 1   y¡¥ 1   z 1 }. appling nres1 to the third and fourth clauses produces { 1   x¡¥ 1   z 1 }. using br1 we obtain { 1   x¡¥     z   }. the two unit clauses can be reduced  producing { 1 }.
¡¡it is interesting to observe that the application of nres1 is somehow similar to the computation of the lower bound of  alsinet et al.  1 . the practical importance of adding nres1 to max-dpll is illustrated in figure 1. the lines labelled up+nres1 report the efficiency of max-dpll when up is augmented with nres1 until quiescence. as it can be observed nres1 produces huge savings over the very inefficient max-dpll.
the rule nres1 is 
m  l 
 x¡¥¡Ål 
this rule is also of great interest because it increases the weight of a unary clauses  which may allow further application nres1 and ucr.
example 1 consider the formula { x ¡Å y 1   x¡¥ ¡Å y 1   y¡¥ 1   z 1  with   = 1. neither up nor nres1 can simplify the problem. however  nres1 produces { y¡¥ 1   y 1   z 1 } which allows nres1 to transform the problem into { 1   z 1 }. we can apply br1 to the unary clause obtaining { 1   z   . now  ucr produces { 1 }.
the practical importance of adding nres1 to max-
dpll is also illustrated in figure 1. the lines labelled up+nres1+nres1 report the efficiency of max-dpll when up is augmented with nres1 and nres1 until quiescence. as it can be observed  the addition of nres1 also produces huge gains. for the sake of completeness  we also evaluate the effect of nresk for k   1. obviously  in 1-sat it does not have any effect  since the application of nresk requires clauses of length k +1. in 1-sat  nres1 can only be applied in the original ternary clauses. its effect is reported in figure 1 under the label up+nres. it can be observed that nres1 has a very limited effect.
1 neighborhood resolution and local consistency
in this section we relate the simplification rules discussed along the paper with local consistency properties developed for wcsp. in order to do so  we recall that the usual way to map a max-sat instance with a wcsp is to group clauses mentioning exactly the same set of variables and associate them to a cost function f defined as follows: let v   f be the group of clauses over the set of variables y   x. v defines a cost function f with scope y. let t be an instantiation of the variables in y. if t falsifies a clause  c w  ¡Ê v   f t  = w  else f t  = 1. now it is straightforward to redefine the wcsp local consistency properties in max-sat terms. in the following consider a boolean formula f where w 1  denotes the weight of the empty clause; w i  and w i¡¥  the weights of the the unary clauses xi and ¡¥xi  respectively; anal-

ogously w ij   w ij¡¥   w ij¡¥   and w ij  are the weights of the four possible binary clauses over xi and xj. if any of these clauses is not in f the corresponding weight is 1.
definition 1 f is node-consistent  nc  iff for all variable xi  w 1 ¨’w i      and w 1 ¨’w i¡¥     .
theorem 1 algorithm up enforces the nc property.
proof 1 suppose that f is not nc. then there is some clause  l w  ¡Ê f such that w 1 ¨’w =  . therefore br1 can be applied replacing clause  l w  by  l   . it will allow the application of ucr which will eliminate the clause.
definition 1 f is star node-consistent  nc*  iff it is nc and for all variable xi  w i  = 1 or w i¡¥  = 1
theorem 1 let up +nres1 denote the algorithm that applies up and nres1 until quiescence. it enforces nc*.
proof 1 we only need to proof that the application of nres1 guarantees that for all variable xi  w i  = 1 or w i¡¥  = 1. assume that 1   w i  ¡Ü w i¡¥ . there are two possible situations. the first one is w i¡¥  =  . in that case up will trigger ucr and xi will disappear from the formula. the second situation is w i¡¥     . then  the application of nres1 will add w i  to w 1  and replace  xi w i    x¡¥i w i¡¥   by
.
¡¡the algorithm to enforce nc* introduced in  larrosa and schiex  1  proves the following result 
corollary 1 up +nres1 can be implemented with time complexity o n   where n is the number of variables in the formula.
definition 1 f is arc-consistent  ac*  iff it is nc* and for all pair of variables  xi xj   min{w ij  w ij¡¥ } = 1 and

min{w ij¡¥   w ij } = 1
theorem 1 let up +nres1 +nres1 denote the algorithm that applies up  nres1 and nres1 until quiescence. it enforces arc-consistency  ac* .
proof 1 we only need to proof that the application of nres1 guarantees that for all pair of variables  xi xj  

min{w ij  w ij¡¥ } = 1 and min{w ij¡¥   w ij } = 1. we proof the first condition  the second is similar . assume that 1   w ij  ¡Ü w ij¡¥ . there are two possible situations. the first one is that w ij  =    which implies w ij¡¥  =  . in that case nres1 will add  xi    to the formula. then  ucr will be trigger and xi will disappear from the formula. the second situation is w ij     . then  the application of nres1 will add w ij  to w i  and replace  xi ¡Åxj w ij    xi ¡Åx¡¥j w ij¡¥   by .
¡¡the algorithm to enforce ac* introduced in  larrosa and schiex  1  proofs the following result.
corollary 1 up +nres1 +nreo can be implemented with time complexity o n1   where n is the number of variables in the formula.
1 neighborhood resolution and state-of-the-art max-sat lower bounds
in the last years several algorithms for max-sat have been proposed  alsinet et al.  1; xing and zhang  1; shen and zhang  1 . all these works have in common a basic branch and bound algorithm. they mainly differ in the lower bound that they use.  shen and zhang  1  show that their lower bound is better  i.e.  higher than or equal  than  alsinet et al.  1  and  under some reasonable conditions  it is also better than  xing and zhang  1 . in the following  by means of two examples  we show that up +nres1 +nres1 is not comparable with them.
¡¡consider the formula { x ¡Å z 1   x¡¥ ¡Å z 1   y ¡Å z¡¥ 1   y¡¥ ¡Å z¡¥ 1 }. both  xing and zhang  1  and  shen and zhang  1  would compute a lower bound 1. however  nres1 can be applied twice  producing the equivalent formula { z 1   z¡¥ 1 } and now nres1 would transform the problem into { 1 }  which means a lower bound of 1.
¡¡consider now the formula { x 1   y 1   x¡¥¡Åy¡¥ 1 }. while both  xing and zhang  1  and  shen and zhang  1  would compute a lower bound of 1  nres cannot be applied  so the implicit lower bound of our algorithm would be 1. nevertheless  it is important to observe that  if we encode this problem as a weighted csp and enforce a stronger form of consistency called existential directional arc consistency  edac*  de givry et al.  1   we transform the formula into the equivalent { 1   x ¡Å y 1 } which also has an implicit lower bound of 1. the performance of enforcing edac* on random max-sat instances is also illustrated in figure 1. as it can be seen  it clearly provides further improvement over the application of the nres rule. experiments on max-sat using weighted csp technology can be performed using the freely available toolbar solver.1
1 conclusions and future work
motivated by the success of  de givry et al.  1  in solving max-sat instances as weighted csps  we have studied the interpretation of wcsp local consistency properties within the max-sat context. the result of our work is a logical framework for max-sat in which the solving process can be seen as a set of transformation rules. interestingly  our approach leads to a natural extension of the davis-putnam algorithm as well as an extension of the resolution rule  res . the application of a limited form of res  called neighborhood resolution  nres   provides an interesting and effective algorithm. we have shown the relation between the application of nres and some local consistency properties in weighted csp. finally  we have also shown that nres provides  implicit  lower bounds not subsumed by state-of-the-art maxsat solvers.
¡¡we believe our work leaves several directions of future work. first  it would be interesting to analyze under which conditions the application of res provides a complete method for max-sat. since it has been shown that directional resolution is just an instantiation of adaptive consistency  rish and dechter  1   it would also be interesting to know if there is any relation between the application of res and the more general bucket elimination  dechter  1 .
¡¡our framework facilitates the relation between max-sat and weighted csp solving. the resolution rule that we have introduced seems only valid to enforce node and arc consistency. however  it is known in the wcsp context that stronger forms of local consistency such as edac* may be more effective in practice  de givry et al.  1 . thus  it seems natural to search for new transformation rules such that  when added to nres  can achieve higher levels of local consistency.
references
 alsinet et al.  1  t. alsinet  f. manya  and j. planas. improved branch and bound algorithms for max-sat. in proc. of the 1th sat  pages 1  1.
 bacchus  1  fahiem bacchus. enhancing davis putnam with extended binary clause reasoning. in proceedings of the 1th aaai  pages 1  1.
 bistarelli et al.  1  s. bistarelli  h. fargier  u. montanari  f. rossi  t. schiex  and g. verfaillie. semiring-based csps and valued csps: frameworks  properties and comparison. constraints  1-1  1.
 cha and iwama  1  byungki cha and kazuo iwama. adding new clauses for faster local search. in proc. of the 1thaaai  pages 1  portland  or  1.
 cooper  1  m. cooper. reductions operations in fuzzy or valued constraint satisfaction. fuzzy sets and systems  1 :1  1.
 davis et al.  1  m. davis  g. logemann  and g. loveland. a machine program for theorem proving. communications of the acm  1-1  1.
 de givry et al.  1  s. de givry  j. larrosa  p. meseguer  and t. schiex. solving max-sat as weighted csp. in proc. of the 1th cp  pages 1  kinsale  ireland  1. lncs 1. springer verlag.
 de givry et al.  1  s. de givry  f. heras  j. larrosa  and m. zytnicki. existential arc consistency: getting closer to full arc consistency in weighted csps. in proc. of the 1th ijcai  edinburgh  u.k.  august 1.
 de givry  1  s. de givry. singleton consistency and dominance testing for weighted csp. in proc. of the 1th intl. workshop on soft constraints and p