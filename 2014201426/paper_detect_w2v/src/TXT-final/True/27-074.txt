 
detecting interactions and resolving conflicts is one of the key issues for generative planning systems hierarchical task network  htn  planning syetems use critics for this purpose critics have provided extra efficiency and flexibility to htn planning systems  but their procedural -and sometimes domain-specific nature has not been amenable to analytical studies as a result  little work is available on the correctness or efficiency of critics this paper describes a principled approach to handling conflicts  as implemented in umcp 1   an htn planning system critics in umcp have desirable properties such as systematicity and the preservation of soundness and completeness 
1 	introduction 
detecting interactions and resolving conflicts is one of the key issues for planning systems the importance of this issue was realized as long ago as the 1s in early ai planning systems such as strips  fikes and nilsson  1  and hacker  sussman  1  the introduction of task networks and task decomposition in noah  sacerdoti  1  provided an even richer set of interactions and resolution methods  and a component of noah called the critic mechanism was designed for handling these interactions critics helped prune the search space by detecting dead ends in advance and by resolving many types of conflicts as soon as they appeared critics could also draw upon domain-specific information to do their job more efficiently the power of the critic mechanism was quickly realized and adopted by hierarchical task network  htn  planning systems  tate  1  
vere  1  wilkms  1  
'this work was supported in part by nsf grants ddm 
1  iri-1 and nsf eec 1  afosr  f1-1   the arpa/rome laboratory planning 
initiative  f1-c-1   and onr giant n1-j-
1 any opinions  findings  and conclusions or recommendations expressed in this materia  are those of the authors and do not necessarily reflect the views of the national science foundation or onr 
1
 universal method-composition planner 
some of the critics identified by saeerdoti  
 based in part on su1sman e  earlier work  include 
  resolve conflicts the conflicts handled by this critic  later referred to as 'deleted-condition  interactions  have received the bulk of the attention in the literature 
  eliminate redundant preconditions this critic both handled  phantom  conditions and found cases where two different procedural networks added the same primitive prior to usage 
in addition to the interactions handled by these critics  several other situations that can arise in planning have been identified in the literature 
  for his deviser system vere  has discussed temporal interactions between the times at which actions must occur 1 he has used temporal windowing and performed an analysis thereof to eliminate possible reductions 
  wilkins' sipe system  w llkins  1  has added sev-eral different mechanisms for recognizing resource interactions and for allowing user preferences to be considered when making a choice among reductions 
  yang  nau  and hendler  yang et al   1  have discussed a general  action-precedence tm  interaction that  while less general than deleted-condition interactions  can be exploited in some planning situations they also have discussed a 'simultaneous action' interaction that arises in some domains 
  to handle iteration in plans  drummond  has proposed several extensions to the procedural net  and an extension to saeerdoti's resolve-conflicts 
critic 
  nonlin  tate  1  and 1-plan1  tate et al   1  provide various condition types which can be used to reduce the search space in 1-plan1  constraint managers support decision making of the planner by providing complete information about the constraints they are managing 
  a number of special-purpose  domain dependent  planning systems have identified interactions occurring only in the particular domain for which the sys-
1 see also  dean  1  

tem is being developed typically special-purpose heuristics are introduced to exploit this knowledge 
　as can be seen  the many interactions which need to be handled during planning go beyond the  relatively  well-understood deleted-condition interaction to handle these interactions  implemented planning systems usually use critice or similar mechanisms unfortunately it is difficult for a user to exploit these planning systems effectively  1 e reasonably efficiently and correctly  without an in-depth understanding of the implementation detail of the critic mechanisms to reason about analytical properties of such mechanisms  1 e system-
aticity  soundness  completeness   a general model of interactions and critics is clearly needed 
　the work described in  erol et al   1a  1b  presents a formal model for htn planning  which provides a constraint-based representation for interactions 
among fasks and enables principled approaches to conflict detection and handling m htn planning this paper presents conflict management and constraint handling techniques based on that framework among the properties of these techniques are soundness  completeness and systematicity these techniques have been implemented in umcp  an htn planning system 
1 	an overview of htn planning 
here is a brief informal description of htn planning 
for a precise formal description  see  erol et al   1a  1b  
　htn planning representations for actions and states of the world are similar to those used in strips-style planning 1 each state of the world is represented by the set of atoms true in that state actions  which in htn planning are usually called primitive tasks  correspond to state transitions  l e each action is a partial mapping from the set of states to the set of states 
　the primary difference between htn planners and strifs-style planners is in what they plan for  and how they plan for it in strlps-style planning  the objective is to find a sequence of actions that will bring the 
world to a state that satisfies certain conditions or  attainment goals   planning proceeds by finding operators that have the desired effects and by making the preconditions of those operators into subgoals in contrast  htn planners search for plans that accomplish task networks  which can include things other than just attain-
ment goals  and they plan via task decomposition and conflict resolution  which shall be explained shortly 
　a task network is a collection of tasks that need to be carried out  together with constraints on the order in which tasks can be performed  the way variables are instantiated  and what literals must be true before or after each task is performed unlike strips-style planning  the constraints may or may not contain conditions on what must be true in the final state for-
　　1 the term  strip s-style  pluming   used to refer to any planner  either total- or partial-order  in which the planning operators are  strip soperators   i e   operator consisting of 
three lists of atoms a precondition net  an add list  and a delete list  
	er1l.etal 	1 

　figure 1 the standard htn planning procedure executed directly  because they represent activities that may involve performing several other tasks for example the task of traveling to new york can be accomplished in 
several ways  such as flying  driving or taking the train flying would involve tasks such as making reservations  going to the airport  buying ticket  boarding the plane  and flying would only work if certain conditions were satisfied availability of tickets  being at the airport on time  having enough money for the ticket etc 
　ways of accomplishing non-primitive tasks are represented using constructs called methods a method is a syntactic construct of the form  a d  where a is a nonprimitive task  and d is a task network it states that one way to accomplish the task α is to achieve all the tasks in the task network d without violating the constraints in d for example  the task network in figure 1 presents one possible way of accomplishing on v1 thus  achieve on v1 v1     d  is a method for blocks world domain  where d is the task network in figure 1 
　an htn problem is represented as a triple p =  d  1 d   where d is the task network we need to plan for  / is the initial state  and v is the set of operators and methods associated with the planning domain 
　a number of different systems that use heuristic algorithms have been devised for htn planning  tate  1  vere 1  wilkins  1   and several recent papers have tried to provide formal descriptions of these algorithms  yang  1 rambhampati and hendler  1  figure 1 presents the essence of these algorithms htn planning works by expanding tasks and resolving conflicts iteratively  until a conflict-free plan can be found that consists only of primitive tasks 
　expanding or reducing each non-primitive task  steps 1  is done by finding a method capable of accomplishing the non-primitive task  and replacing the nonpnmitive task with the task network produced by the method details of how to do the task expansion is presented in  erol et al   1a  1b  
　the task network produced in step 1 may contain conflicts caused by the interactions among tasks the job of finding and resolving such interactions is performed by critics this is reflected in steps 1 and 1 of figure 1 after each reduction  a set of critics is checked so as to recognize and resolve interactions between this and any other reductions thus  critics provide a general mechanism for detecting interactions early  so as to reduce the amount of backtracking 
1 	planning in u m c p 
one way of finding solutions to htn planning problems is to generate all possible expansions of the input task network to primitive task networks  then generate all possible ground instances  assignment of constants to variables  and total ordermgs of those primitive task networks and finally output those whose constraint formulae evaluate to true however  considering the size of the search space it is more appropriate to try to take advantage of the structure of the problem  and prune large chunks of the search space by eliminating in advance some of the variable bindings  orderings or methods that would lead to dead-ends to accomplish this umcp uses a branch-and-bound approach  kanal and 
kumar  1  
　a task network can be thought of as an implicit representation for the set of solutions for that task network umcp works by refining a task network into a set of task networks whose sets of solutions together make up the set of solutions for the original task network those task networks whose set of solutions are determined to be empty are filtered out in this aspect  umcp nicely fits into the general refinement search framework described in  kambhampati et al 1  
　figure 1 contains a sketch of the high-level search algorithm in umcp search is implemented by keeping an open-list of task networks in the search space that are to be explored  by altering how task networks are picked from the open-list and how they are in-
serted depth-first  breadth-first  beat-first and various other search techniques can be employed step 1 checks 
whether in is a solution node  if all tasks in in are primitive  the constraint formula is the atom true  and the list of constraints that have been committed to be made true but not yet made true is empty  then all task ordermgs and variable assignments consistent with the auxiliary data structures associated with in are plans for the original problem b those plans can be easily enu-
1 constraints and the data structure* will be discussed in 

merated if tn is not a solution node  then it is refined by some refinement strategy ft  and the resulting task networks are inserted back into the open-list 
　three types of refinement strategies used in umcp are task reduction  constraint refinement  and user-specific critics task reduction involves retrieving the set of methods associated with a non-primitive task in tn  expanding in by applying each method to the chosen task and returning the resulting set of task networks userspecific critics is one of the places where umcp can be tailored for specific domains if a domain-specific refinement strategy is available it can be used to improve the performance of the planner this paper will focus on constraint refinement 
1 	constraint handling in u m c p 
1 	o v e r v i e w 
this section contains an overview of the constraint handling mechanisms in umcp  which serve as domain independent critic they are designed to preserve soundness  completeness  and systematic!tv details for each type of constraint are summarized in the next section 
for a full description  see  erol  1  
　the three types of decisions in htn planning are the choice of method for each non-primitive task  the choice of constant to assign to each variable  and the ordermgs of tasks of those three the choice of method is directl} reflected in the task network  1 e in the list of tasks and the constraint formula  auxiliary data structures are required for the other two thus  along with each task network  umcp keeps a list of possible values for each variable values until the size of the list exceeds a threshold  and a partial order graph of task nodes both of those structures will be referred to as commitments dealing with some constraints might not be possible at the current level of detail in a task network  dealing with those constraints has to be postponed until the task network is refined further until then those constraints are stored in a list called the promissorj list  the list of constraints the planner has committed  to make true but has not done so yet  
　the four phases of constraint refinement in umc p are constraint selection  constraint update constraint propagation and constraint simplification which are carried out sequentially 
　constrain/ selection involves deciding which constraints in the constraint formula or in the commitments to work on constraint selection returns a list of constraint formulae  where each formula is a conjunct of atomic constraints the list of constraint formulae is selected in such a way that  a  the formulae in the list are mutually inconsistent in the presence of com muments  in order to preserve systematicity   and  b  the list covers all possibilities  in order to preserve com pleteness  some examples of constraints that may be selected include  1  an atomic constraint1 and its negation   n  a conjunct of unit clauses from the constraint 
detail in the next section 
   ＜an atomic constraint refers to any instance of the types of constraints discussed in section 1 
formula  or  in  a set of possible constraints for a variable - l e if the set of possible values for a variable v are {trucki truck1 trucks}  umcp may branch out on the constraints  v = zrucifci    v = jrucjfe1   v = trucks  
　for each constraint formula in the list computed in the constraint selection phase  the constraint update phase computes a task network for every possible way of mak-
ing the selected formula true by further restricting the commitments of the task network for each atomic constraint in the selected constraint formula  the following steps are executed first it is evaluated  if it evaluates to true  it can be ignored  if it evaluates to false  the task network fails  otherwise further restrictions are placed on the commitments  variable bindings  orderings etc   to make the constraint necessarily true in all further refinements of the task network there might be multiple possible ways of accomplishing that  thus even atomic constraint update computes a list of task networks rather than a single task network however  umcp does constraint update in such a way that there is no overlap among the set of solutions to the task networks in this list for some constraints  at the current level of detail in the task network  it might not be possible via restrictions on commitments to ensure that the constraint will be true in all further refinements those constraints are simply recorded in the promissory list 
　in the constraint propagation phase  umcp evaluates and simplifies the constraints in the promissory list of each task network produced during the constraint update phase if anv of those constraints evaluate to false  the task network fails  those that evaluate to true are removed from the promissory list constraint update is performed on the remaining simplified constraints if possible at the current level of detail in the task network this phase is repeated until no more propagation is possible 
　umcp contains evaluation and simplification routines for every type of constraint  as described in the next section these routines are used in the constraint simplification phase to evaluate and simplify the constraint formulae of the task networks produced  during the propagation phase for instance if part of a conjunct evaluates to true that part is dropped  if it evaluates to false the whole conjunct evaluates to false disjuncts are treated analogously thosp task networks whose constraint formulae evaluate to false are pruned 
1 	details 
this section describes how constraint evaluation and update is done for each tvpe of constraint update always involves evaluating the constraint and it fails whenever the constraint evaluates to false this is omitted from the explanations bflow for brevity 
variable binding constraints 
type 	 v = a  
evaluation return true if constant a is the only possible value for variable v1  return false if a is not a possible value for v  return   v = a  otherwise update to make it true  set the possible value list for v to a  replace v with a throughout the task network to 
	erol  etal 	1 



  completeness any solution for tn is also a solution for some task network in r tn  thus constraint refinement does not eliminate any valid solutions umcp satisfies this property because any time a constraint is selected m constraint selection phase  its negation is also selected  unless it contradicts with the commitments or the constraint formula   and all possible ways of making a constraint true are tried in the constraint update phase 
  systematicity the set of candidate solutions for each task network in r tn  are mutually disjoint thus umcp does not examine the same candidates multiple times the way systematicity is accomplished in umcp is by making sure  a  the branches in constraint selection are mutually exclusive  i e any two conjuncts have a common literal  positive in one  negated in the other    b  there is no overlap among the solution sets to the task networks produced in update phase 
1 	related work 
causal links are used by pocl planners such as snlp  mcallester and rosenbhtt  1  to establish preconditions and to detect threats causal links are also employed by umcp in the form of special state constraints stored in the promissory list snlp b threat removal process is similar to how umcp handles those special constraints in its constraint propagation phase 
　 chapman  1  introduced the mtc  modal truth criterion  to tell whether a literal is true at a given point in a partiallj-ordered plan in order to evaluate state constraints  umcp uses an extended version of the mtc that also accounts for compound tasks umcps extended mtc algorithm runs m quadratic time-and it is directly applicable for computing chapman & m tc for which the other known algorithms run in cubic lime 
　noah  sacerdoti  1  employs its resolve conflicts critic to deal with deleted-condition interactions which are explicitly represented by state constraints in umcp the constraint refinement techniques of umcp guarantees these interactions will be handled without sacrificing soundness or completeness 
　umcp evaluates each constraint before trying to make it true  and skips those constraints that are already true  and hence it emulates noah s eliminate redundant preconditions critic 
　htn planners often allow several type1 of conditions in methods how to deal with those conditions has been a topic of debate 
　nonlin  tate  1  evaluates filter conditions as soon as they are encountered  using the qa  question answering  mechanism qa returns false unless it can verify those conditions to be necessarily true  even if the conditions are possibly true thus  nonlin often backtracks over filter conditions which would have been achieved by actions in later task expansions or by more ordering and variable binding commitments as a result  nonlin may fail to find a solution when a solution ex ists  or may miss a short and simple solution and do much more work to find a longer and more complicated 
solution 
　at first glance  the problems such as these might seem to argue against the use of filter conditions at one extreme  using filter conditions immediately to prune the search space sacrifices completeness  and at the other extreme  postponing their use until the plan is complete 
 so as to preserve completeness  is inefficient 1 
　although the above argument ib partially correct  it ignores a third possibility that lies between the two extremes in general  to preserve completeness  a planner cannot use a filter condition to prune the bearch space unless the filter condition evaluates to  necessarily false -but this does not necessarily require that the task network has been expanded into a primitive and tot ally-ordered plan instead  umcp simply records the filter conditions in the promissory list and prunes the task network only when one of them becomes necessarily 
false 
　more specifically  umcp handles filter conditions and other constraints as follows 
  some instances of variable binding  ordering  and state constraints can be dealt with immediately for example  conditions  e g   an object s type  that are not affected by the actions are represented by constraints of the form  initially /  such constraints can be evaluated at anv time b  querying the initial state  and they can be committed to by appropriately restricting the possible values for the variables i n / 1 
  those constraints that cannot be dealt with imme-diately are stored in the promissory list  and are processed in the constraint propagation phases 
constraints in umcp go through three stages thev first appear in constraint formula then possibly in the promissory list if they cannot be dealt with at the time they are selected in constraint selection phase  and finally they are reflected in restrictions on possible values for variables and task ordenngs this three-stage approach facilitates dealing with the disjunctions in the constraint formula  and by postponing its processing of 
some types of constraints umcp preserves completeness without sacrificing efficiency 
1 	conclusion 
dealing with numerous types of interactions 1 an important aspect of planning systems the work described in  erol et al 1a  1b  has provided a formal framework for representing interactions and conflicts via constraints  and in this paper we have introduced techniques for constraint handling as a mean1 for detecting interactions and resolving conflicts those techniques preserve soundness completeness  systematicity  and they have been implemented in umcp  an htn planning system 
　　b in fact  collins and prvor  have made a similar argument against filler conditions in the context of planning with strips-btyle operators 
1
srpe  wilkinb  1b  uses a  soil hierarchy  for thib pur 
pose the only difference in umcp is that umcp allows al bitraiy boolean formulae constructed from all types of constraints  instead of a conjunct of constraints as in sd e 
	erouetal 	1 

　by instantiating the constraint selection strategy in different ways  various commitment strategies discussed in the literature can be used by umcp for example  variable instantiation can be done before anything else  as in nonlin   all primitive tasks can be totally ordered as soon as they appear in task networks  or task expansions can be deferred until all conflicts have been resolved  least commitment  currently we are designing experiments to empirically evaluate these techniques 
　umcp'e constraint-handling mechanism provides the capabilities of many domain-independent critics discussed in the literature  and umcp'fl user-specific critics module can be used to incorporate domain-specific critics aa well the modular and formal nature of umcp makes it readily extensible we are currently exploring ways of extending umcp's constraint-handling mechanism to handle numerical and complex temporal constraints bo that it can do deadline and resource management  and provide the capabilities of other domainindependent critics 
