
translation to boolean satisfiability is an important approach for solving state-space reachability problems that arise in planning and verification. many important problems  however  involve numeric variables; for example  c programs or planning with resources. focussing on planning  we propose a method for translating such problems into propositional sat  based on an approximation of reachable variable domains. we compare to a more direct translation into  sat modulo theory   smt   that is  sat extended with numeric variables and arithmetic constraints. though translation to sat generates much larger formulas  we show that it typically outperforms translation to smt almost up to the point where the formulas don't fit into memory any longer. we also show that  even though our planner is optimal  it tends to outperform state-of-the-art sub-optimal heuristic planners in domains with tightly constrained resources. finally we present encouraging initial results on applying the approach to model checking.
1	introduction
satisfiability testing is a significant method for solving statespace reachability problems. in 1 and 1  the winners of the track for optimal planners at the international planning competition translated bounded-length planning to sat testing. in model checking  determining by sat testing if or if not error states are reachable in a fixed number of steps often succeeds where bdd methods fail  clarke et al.  1 .
모many important planning and verification problems  however  naturally involve numeric variables and constraints. for example  c programs  or planning with operators that consume resources. the question arises as to how to best generalize the  encode as sat  approach to numeric problems. so far  two different methods have been pursued:
 a  interprete numbers as bitstrings  and numeric operationsas bitwise operations.  implement  these operations in a propositional cnf.
 b  translate not to boolean satisfiability but to  sat modulo theory   smt   that is  sat extended with numeric variables and arithmetic constraints.
in software verification  both method  a  and method  b  have been explored  for example by clarke et al  and ganzinger et al   respectively. in planning  so far only method  b  has been explored  namely in lpsat  wolfman and weld  1  and tm-lpsat  shin and davis  1 .
모the disadvantage of method  a  is that it involves the cumbersome implementation of bitwise operations in a cnf. the disadvantage of method  b  is that the expressivity of smt languages comes at a price: the solvers are much more complex than sat solvers  and do generally not scale as well. herein  we explore a third option:
 c  approximate the reachable variable domains  i.e.  determine sets dt v  so that  for every variable v  every value that v can have after t transitions is contained in dt v . these finite domains can then serve as the basis for a boolean encoding  where atoms represent numeric variables taking on particular values.
of course  this method will only work if the sets dt v  do not grow too large. the underlying intuition is that the actual number of distinct values a numeric variable can achieve in a bounded-length problem is often quite small. our experimental results confirm this.1
모we focus on planning. we approximate reachable variable domains by constructing a  numeric relaxed planning graph   nrpg  inspired from work on generating heuristic functions  hoffmann  1; kupferschmid et al.  1 . we add some more intelligence in order to obtain smaller dt v . based on the nrpg we obtain propositional cnfs in a manner inspired by kautz and selman . the cnfs are handed over to the state-of-the-art sat solver minisat  een and sorensson 몮 1 . the plan length bound starts at 1 and is incremented until the first satisfiable formula is found - this way  the generated plans are optimal  have minimal length . we call the resulting planning system numreach/sat.
모we run large-scale experiments on a broad variety of planning problems. we could not compare to the existing planning systems using method  b  since lpsat is outdated and tm-lpsat is not available  see also section 1 . so  for this comparison  we implemented such a system ourselves  called numreach/smt.1 this is identical to numreach/sat except for the encoding of numeric variables. the smt formulas are handed over to the state-of-the-art smt solver mathsat  bozzano et al.  1 . numreach/sat consistently out-
performs numreach/smt almost up to the point at which the  larger  sat encodings no longer fit into memory.
모we also compare our planners to the  sub-optimal heuristic planner  family  namely to metric-ff  hoffmann  1   lpg  gerevini et al.  1   and sgplan  chen et al.  1 . these planners are fast  they respectively won the competitions 1  but are usually not compared to optimal planners since such a comparison is unfair. however  we find that  in contrast to the usual competition results  in our context optimal planners are quite competitive. numreach/sat outperforms all the heuristic planners in a basic domain with tightly constrained resources. this is an important result for the planning community  suggesting to seriously reconsider numeric planning.1 we finally present initial  encouraging results on using our approach in model-checking domains.
1	approximating variable domains
to spell out the algorithm building the nrpg  we need some notations. i  v  and a respectively denote the initial state  set of numeric variables  and action set of the planning task. the initial state is a set of propositions - those that are initially true; also  it assigns a value to every variable v 뫍 v. a numeric constraint has the form  where 뫍
1 are expresssions made of
constants  operators in {+     /}  and variables x   v respectively y   v. each action a 뫍 a consists of its precondition prea  and a set ea of effects. each effect e 뫍 ea consists of its condition cone  its adds adde  and its deletes dele. additionally e is annotated with a set of numeric effects of the form v := exp. adds and deletes are  as usual  proposition sets. preconditions prea and effect conditions cone are conjunctions of propositions and numeric constraints. the semantics are defined in the obvious standard way.
1. t := 1  p1 := i  for all v 뫍v: d1 v  := {i v }
1. while t   b do

1. at := {a | a 뫍 a  pt dt|x  |= prea x }

1. et := {e |  a 뫍 at : e 뫍 ea  pt dt|x  |= cone x }
1. pt+1 := pt 뫋{p |  e 뫍 et : p 뫍 adde}
1. for all v 뫍v: dt+1 v  := dt v 뫋{c |

1.  ca=뫍expat  ec몬|뫍x e  ap뫌t ec몬|ty   v|=  :=preexp  ax   뫇뫍cone  c몬e뫍   dyt |}x뫋y :
1.
1.	endwhile
figure 1: the numeric relaxed planning graph  nrpg  algorithm  approximating reachable variable domains.
모pseudo code for the nrpg is shown in figure 1. the algorithm keeps track of sets pt of reached propositions  and of sets dt x  of reached values  the reached variable domains   at time steps t. note the slight abuse of notation for i in line
1. by b  line 1   we denote the plan length bound we are currently considering. by writing 뷋 y  for a conjuntion 뷋 of propositions and numeric constraints  lines 1  1  1   we mean thaty   x is the set of all variables mentioned by the numeric

constraints in 뷋. by dt  lines 1  1  1   we denote the crossproduct of the dt v  for v뫍v  i.e.  dt :=dt v1 뫄...뫄dt vn  where v = {v1 ... vn}. for a set c of value vectors  or for a single value vector 몬c  by c|x respectively 몬c|x  lines 1  1  1  1  we denote the vector  set  restricted to the variables x.

for a set p of propositions p  a set c of value vectors  and a conjunction 뷋 x  of propositions and numeric constraints 

we say that  p c|x  |= 뷋  lines 1  1  1  iff 뷋's propositions

are a subset of p  and there exists 몬c 뫍 c so that 몬c|x satisfies 뷋's numeric constraints. by exp c몬   line 1  for an expression and value vector  we mean the outcome of inserting the values into the expression.
모in words  the nrpg is built as follows. the reached propositions and variable domains are first set to the initial values. then one iterates over time steps t until the desired bound is reached. in each step  the action set at is the set of all actions whose precondition can be satisfied at t. the same is done for the effect set et. the propositions reached at t +1 are those that are either reached at t  or added by an effect at t. the reached variable values at t +1 are those that are either reached at t  or that are the result of an effect at t and a value vector reached at t that satisfies the conjunction of the precondition and condition of the respective action and effect - intuitively  this means that the insertion of new values is  guarded  by the corresponding conditions.
example 1. consider a task with a single variable v  which is initially 1  and a single action whose only effect has the condition v 뫟1 and the effect v :=v 1. we will have d1 v ={1}  d1 v  = {1}  and d1 v  = {1 1}. then the algorithm will stop - since the effect v := v 1 is guarded by the condition v 뫟 1  the value v =  1 is not inserted into d1 v .
모the nrpg is admissible  i.e.  every value reachable for a variable v within t steps is guaranteed to be contained in dt v . however  the algorithm is exponential in the arity - the number of variables mentioned by - conjunctions of preconditions  effect conditions  and effect expressions: if the
maximum such arity is k  and the largest involved variable domain has size m  then the number of vectors to be considered is bounded only by mk. hoffmann  avoids this blow-
up by keeping only the max and min value of each dt v   and accordingly approximating the satisfaction of  linear  numeric constraints. kupferschmid et al  largely avoid the blow-up by treating every numeric constraint in separate rather than addressing conjunctions  thus potentially decreasing the above k a lot.1 our rationale here is that: 1. in difference to these works we need to compute the nrpg only once  rather than in every state of a forward search. 1. the arity of numeric constraints  and even conjunctions of them  tends to be small in many planning domains - e.g.  expressing constraints on resource availability usually involves only a single variable. indeed  in our experiments we did not find a single domain where this potential blow-up was a problem. another potential blow-up turned out to be more severe: the size of the domain of a variable v grows exponentially in t if every sequence of actions results in a different value for v. this happens in one of our test domains  where v is a resource  and every action using the resource has a random float cost. a remedy to this would be to give up on admissibility of the nrpg  and  with that  give up plan optimality   and try greedy approximations of variable domains instead. one could  for example  build a non-numeric planning graph first and then build the variable domains only for a seemingly relevant subset of the actions  e.g.  a relaxed plan . we leave this topic open for future work. herein we show that  in 1 out
of 1 numeric domains from the international planning competition  the problem does not occur: if the granularity of numeric effects is less than that of random floats  many action sequences result in the same value.
모we finally remark that one could also insert more intelligence into the nrpg  to prune non-reachable variable values. for example  an extension of graphplan mutex reasoning  blum and furst  1  might turn out to be beneficial in some domains. we leave this open for future work.
1	sat and smt encodings
we first describe the smt encoding underlying numreach/smt  since that encoding is simpler. we then explain how to obtain the sat encoding underlying numreach/sat. the smt encoding makes use of decision variables for propositions  numeric variables  actions  and effects  at time steps. precisely  there are the decision variables: pt for all 1 뫞 t 뫞 b and p 뫍 pt; vt for all 1 뫞 t 뫞 b and v 뫍 v; at for all 1 뫞 t   b and a 뫍 at; and et for all 1 뫞 t   b and e 뫍 et. all variables except the xt are boolean. there are the following clauses  illustrated with example 1 :
  initial state: specify the initial values of propositions and numeric variables. for example  {v1 = 1}.
  conditions: an action at t implies its preconditions at t. an effect at t implies its conditions at t. for example  { et vt 뫟 1}.
  actions and effects: an effect at t implies the corresponding action at t. an action at t implies  for each effect e  that either e occurs or one of e's conditions is false. for example  { at  vt 뫟 1 et}.
  effect state change: an effect at t implies its adds and  negated  deletes at t +1  and implies its numeric effects between t and t +1. for example  { et vt+1 = vt  1}.
  frame axioms: any proposition that is true at t stays true at t + 1 unless it is deleted. any proposition that is false at t stays false at t +1 unless it is added. any numeric variable has the same value at t and t +1 unless it is affected. for example  {vt+1 = vt et}.
  goal: the goal condition is true at time b.
  mutex: interfering actions and effects do not occur in the same step. actions/effects interfere if they harm each other's preconditions/conditions/adds  or if they affect the same numeric variable.
모note here that this specification makes use of the nrpg  in the definition of the set of decision variables. this corresponds to our current implementation. however  since one could easily define an smt encoding that does not use the nrpg  the runtime for building the nrpg is not included into the numreach/smt runtimes in our experiments.
모for numreach/sat  the nrpg is essential  and its runtime is  of course  included . the encoding is identical to the above  except for the treatment of numeric variables. precisely  instead of the vt variables  we now have one separate  boolean  decision variable  v = c t for all t  v  and c 뫍 dt v . we further have  for all t  one decision variable cstrt for every numeric constraint  every different cstr   occuring in the task. finally we have  for allt  one decision vari-

able cstr-몬ct for every cstr x  and every value tuple 몬c 뫍 dt|x that satisfies cstr. the intended behavior is that cstr-몬ct is true iff the values it specifies are true  and that cstrt is true iff one of its value tuples is true. we ensure this behavior with the following additional clauses:
  constraints: for cstr x   cstrt is equivalent to the dis-
junction of all cstr-몬ct where 몬c 뫍 dt|x satisfies cstr.
  value tuples: for cstr x   each ctr-몬ct is equivalent to the conjunction of  x1 = c1 t ...  xk = ck t  where x = {x1 ... xk} and 몬c =  c1 ... ck .
with this  the  conditions  clauses and the  actions and effects  clauses translate effortlessly  since we have a decision variable for every numeric constraint occuring in a precondition or an effect condition. we can use these variables just like the variables for propositions. similarly  the frame clauses for numeric values now look almost like those for propositions  for example {et   v = 1 t  v = 1 t+1} - if e is not applied  and v = 1 at t  then v = 1 at t +1. the only aspect that becomes somewhat complicated are the  effect state change  clauses for numeric variables. what we say is  for every numeric effect v := exp x  of effect e 뫍 e a   and for every tuple  x1 = c1 ... xk = ck  in x that complies with at least one tuple in dt satisfying pre a 뫇con e   either e is not applied  or one of  xi = ci t is false  or  x = exp c몬  t+1 is true. for example  { et   v = 1 t  v = 1 t+1}.
	instance	sat	smt	ff	sgplan	lpg
depots 1.1.1.1.1.1depots 1.1.1.1.1.1depots 1.1-111depots 1.1.1.1.1.1depots 1.1-111settlers 1.1.1.1.1.1settlers 1.1.1.1.1.1settlers 1--111settlers 1.1.1.1.1.1settlers 1.1-111settlers 1--111settlers 1---11zeno 1.1.1.1.1.1zeno 1.1.1.1.1.1zeno 1.1.1.1.1.1zeno 1.1.1.1.1.1zeno 1.1.1.1.1.1rovers 1.1.1.1.1.1rovers 1.1---1rovers 1.1.1.1.1.1rovers 1.1.1.1.1.1rovers 1.1.1.1.1.1rovers 1.1--11rovers 1.1.1--1rovers 1.1.1-11rovers 1.1--11rovers 1.1---1rovers 1.1---1rovers 1mem---1rovers 1mem----table 1: runtime results in seconds  in four of the six 1 competition domains  see text . dashes mean time-out  1 seconds   mem out of memory  1gbyte . some domain and planner names abbreviated as obvious.
focus of the competition has shifted away from numeric planning  though as we will see that is far from being  solved  . the 1 numeric domains are thus still the main benchmark for this context. they are named depots  driverlog  rovers  satellite  settlers  and zenotravel. depots is a combination of logistics and blocksworld  with  e.g.  numeric restrictions on the load status of trucks . driverlog has trucks that need drivers; the numeric variables  distances walked and driven  are mentioned only in the optimization metric. rovers is about gathering rock/soil samples and images  with energy usage and a recharge operator that can be applied only in  sunny spots . satellite is about gathering images  also with energy usage  no recharge . zenotravel is a simple logisticstype problem with fuel usage and a refuel operator that can be applied anywhere anytime. table 1 shows our data.
모driverlog is left out of table 1 since all tested planners ignore the optimization metric - and with it the numeric variables - anyway. satellite is left out of the table because in this domain our approach is trivially nonsense: any  satellite  can turn between any two  directions ; doing so costs the respective  slew time  in energy; in the competition instances  the slew times are assigned basically as random floats. because of the latter  every sequence of turning actions has a differrent summed up cost  yielding a different possible numeric value. so the reachable variable domains grow exponentially in the depth of the nrpg  which exhausts memory even in the smallest instance of the competition suite. we find it doubtful whether such a scenario  random float costs  makes much sense - why would one need to distinguish between arbitrarily many different action costs  to explore this topic further  in section 1 we run an experiment explicitly scaling the size of the set of numbers from which action costs are drawn.
모each competition test suit contains 1 instances; every instance solved by numreach/smt was also solved by numreach/sat. for depots and zenotravel  table 1 shows data for the 1 largest instances solved by numreach/sat. for settlers  we show the 1 smallest instances  which contain everything solved by numreach/sat and metric-ff  even the small settlers instances are comparatively large  requiring plans with several dozen steps . for rovers  since we consider that particularly interesting  we show all instances except the smallest ones. from a quick glance  one sees that numreach/sat convincingly outperforms numreach/smt in all these domains. this underlines the merits of our approach quite impressively. for the sub-optimal planners  neither of depots  settlers  and zenotravel constitutes much of a problem. the single exception is metric-ff in settlers  which is only marginally faster than numreach/sat. in rovers  however  numreach/sat outperforms not only numreach/smt but also metric-ff and sgplan  being beat only by lpg.1this is due to the nature of energy consumption and recharge in this domain: to recharge  one has to first reach a sunny spot. metric-ff and sgplan presumably spend excessive time in large dead ends where there is not even enough energy left to reach such a spot. lpg's search has a more stochastic restarting nature  which is less affected by this. in the next section we run an experiment explicitly scaling the constrainedness of resources.
1	transport
we constructed a simple transportation domain  called transport  to run some targeted experiments. a truck moves in a weighted graph. a set of packages must be transported between nodes. actions move along edges  and load/unload packages. each edge costs its weight in fuel. there is no refuelling  so once the truck ran out of fuel it's  game over .1while this domain is simplistic  we believe it serves well as an abstract model of the relevant issues in planning with resources. in particular  we can scale the instances on variable domain size and on resource constrainedness  as follows. our instance generator takes the parameters n  p  m  and c. first a random connected  undirected  graph with n nodes is created. then p packages are added  with random origins and destinations. the edge weights are uniformly drawn from the set {1 ... m}. then a domain-specific branch-and-bound procedure  which we developed especially for this purpose  computes the minimum amount of fuel  minfuel  needed to solve the task. the initial fuel supply of the truck is set to minfuel . this way  the size of the reachable variable domains can be controlled by m  and the resource constrainedness can be controlled by how close c is to 1.

figure 1: scaling variable domain size.
모in our first experiment  we aim to see how variable domain size affects the planners  so we scale m. we keep n and p fixed to 1  which is challenging but feasible. we fix c = 1  which is relevant since  as we shall see  in this region the sat-based approach is more efficient than all state-of-the-art heuristic planners. runtime plots for numreach/sat and numreach/smt are in figure 1; each data point is the mean value of 1 instances. we see that numreach/sat has a strong advantage with low m; as expected it gets worse with growing m  while numreach/smt reacts only very slightly to the value of m.
모we ran another experiment where we scaled m further  over m = 1 ... 1. as expected  numreach/smt's behavior does not change much  while numreach/sat degrades further. with a time-out of 1 seconds  numreach/sat's solution percentage as we increase m in steps of 1 is 1  1  1  1  1  1  1  1. we remark that the limiting factor here is neither nrpg building nor cnf building nor even sat reasoning: the size of the cnfs is what makes the solution rate drop. as a rule of thumb  until around 1 million clauses numreach/sat beats numreach/smt  between 1 and 1 million clauses numreach/smt beats numreach/sat  and after that  which in our experiment here happens starting with m = 1  the propositional cnfs don't fit into 1gbyte memory any longer. note that this provides a simple rule to automatically choose between numreach/sat and numreach/smt: just compute the number of clauses in the propositional cnf  and apply a threshhold.
모we emphasize that in the competition domains table 1  the advantage of numreach/sat over numreach/smt is much larger than even for m = 1 in figure 1. presumably  numreach/smt has more trouble than numreach/sat with the mix of planning aspects in these domains - remember that transport is very basic.
모the experiment shown in figure 1 scales c between 1 and 1. n and p are fixed to 1  m is fixed to 1. the left hand side y axis is log-scaled runtime. each data point is the average over 1 instances  where time-out is 1 seconds  which is inserted into the average computation in unsolved cases. to complement this  the right hand side y axis shows the percentage of solved instances. numreach/sat's curve is the horizontal line; all instances are solved  so no solution percentage is shown. note that the seemingly linear nature of

figure 1: scaling resource constrainedness.
the heuristic planners' runtime curves  as we move towards c = 1  is just an artefact of the runtime cutoff. the sharp drops in solution percentage more reliably reveal the main message of figure 1: heuristic planners are efficient when resources are plenty  but they tend to fail when resources are scarce. ours is the first experiment making this important point absolutely clear. even though numreach/sat is optimal  it outperforms the heuristic planners. this inverts  almost  every result of the planning competitions since 1. note that transport is not an awkward artificial problem  but a natural and relevant application of planning.
1	jugs-and-water
in the jugs-and-water domain  one has a set of jugs of varying sizes  and one wants to achieve a given fill status for all the jugs. actions fill or empty a jug  or pour the content of one jug into another one. thus  in this domain  numeric variables  fill status of jugs  are not resources but constitute highly interacting phenomena  perhaps similar to rubic's cube or so  from the  point of view  of a general purpose solver. we obtained random instances with n jugs and m maximum jug size by choosing jug size uniformly from {1 ... m}  and then using a repeated greatest common divisor computation to obtain solvable goals.
모in some way  m here corresponds to the m parameter of transport: it scales the possible variable value ranges. however  very much unlike transport  in jugs-and-water m has a huge effect on instance hardness. the larger m is  the longer will the plan typically be  making it much harder to find. table 1 shows results scaling n and m simultaneously. for readability  we only show the solution rates. we could not run lpg since that cannot handle conditional effects  of the action pouring the content of one jug into another . numreach/sat vastly outperforms numreach/smt. the same goes for metric-ff  giving another example of the unusual dominance of an optimal over a sub-optimal planner. it is unclear to us what the reason for sgplan's efficiency is.
1	model checking
to point out that our new method might make sense in some cases of model checking as well  we have run a few preliminary experiments. we modelled some model checking toy examples in pddl. many of those examples make use of

111111111111111
111111111111111
111111111111111
111111111111111table 1: solution rate for the jugs-and-water domain. 1 instances per data point  time-out 1 seconds.
arrays  with arithmetics on the array indices. this is very awkward to model in pddl  without an explicit notion of arrays. after some exploration of the relevant literature  we ended up using variants of the  fischer protocol for mutual exclusion  and the  bakery protocol for mutual exclusion   the latter has an array  but no arithmetics on the indices . in both cases  there are n processes  at most one of which should be in a  critical region  at any point in time. in both cases  versions with bugs are mentioned in the literature; these versions we mapped into pddl.1 planning in these domains is about finding sequences of transitions ending in a state where at least two processes are in the critical region. for the  fischer  domain  we obtained very good scaling. with n = 1 1 1 processes  numreach/sat | numreach/smt runtime is 1|1  1|1  1|1  1|1  1|1  1|1  showing a consistent advantage for numreach/sat. in the bakery domain  we obtained much worse scaling. for numreach/sat  this is due to an awkward encoding we needed for a max operation  making the nrpg grow rather quickly. for numreach/smt  excessive time is taken in satisfiability testing. concretely  for n = 1 ... 1 the data we get is the following  showing sat time for numreach/sat | nrpg time for numreach/sat | smt time for numreach/smt:
1|1|1  1|1|1  1|1|1  1|1|1  1|1|1  1|1|1  1|1|1  1|1|   1. the advantage for numreach/sat in terms of sat solving time is dramatic.
1	conclusions and further directions
we have developed a third technique for the application of satisfiability testing to solving state-space reachability problems in numeric domains. our empirical results suggest that  at least in planning  the technique is very competitive.
모we recommend to the planning community to reconsider numeric planning. our results in resource-constrained transportation indicate that the relevant issues there may be quite different from what we have got used to elsewhere.
모in the future  we intend to explore the two lines of research modifying our current nrpg technique  outlined in section 1: 1. try to make the nrpg more intelligent by additional reasoning. 1. try to avoid any blow-ups altogether by a more greedy approximation of variable domains. we also consider it interesting to explore how method  a  - encoding numbers as bitvectors - will work in numeric planning.
