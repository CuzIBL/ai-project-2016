 
we demonstrate that theorem provers using model elimination  me  can be used as answer complete interpreters for disjunctive logic programming. more specifically  we introduce a mechanism for computing answers into the restart variant of me. building on this  we develop a new calculus called ancestry restart me. this variant admits a more restrictive regularity restriction than restart me  and  as a side effect  it is in particular attractive for computing definite answers. the presented calculi can also be used successfully in the context of automated theorem proving. we demonstrate experimentally that it is more difficult to compute  nontrivial  answers to goals  instead of only proving the existence of answers. 
keywords. automated reasoning; theorem proving; model elimination; logic programming; computing answers. 
¡¡the aim of this paper is twofold: firstly  we prove that theorem provers using model elimination  me  can be used as answer complete interpreters for disjunctive logic programming. secondly  we demonstrate that in the context of automated theorem proving it is much more difficult to compute  non-trivial  answers to goals  instead of only to prove the existence of answers. 
¡¡concerning the first aspect it is important to note that there is a lot of work towards model theoretic semantics of positive disjunctive logic programs  and of course there are numerous proposals for non-monotonic extensions. however  with respect to interpretation  i.e. proof-theoretic investigations the situation is not so clear. at first glance one might be convinced that any first order theorem prover can be used for the interpretation of disjunctive logic programs  since a program clause a  v ... v am  - b  a ... a bn is a representation of the clause a1 v ... v am v - b1 v ... v -bn. indeed  in  lobo et al  1  sli-resolution is used as a calculus for disjunctive logic programming. from logic programming with horn clauses  however  we learn that for a procedural interpretation of program clauses it is crucial that clauses can only be accessed by the literals ai  i.e. by the head literals. technically  this means that only those contrapositives are allowed to be used  which contain a positive literal in the head. the approach from  lobo etal  1  completely ignores this aspect by using sli resolution which requires all contrapositives. 
¡¡there are proposals for first order proof calculi using program clauses only in this procedural reading  e.g. plaisted's problem reduction formats  plaisted  1   or the nearhornprolog family introduced by loveland and his co-workers 
 loveland  1 . these approaches introduce new calculi or proof procedures  for which efficient implementations still have to be developed.  for a thorough discussion we refer to  baumgartner and furbach  1a .  our aim was to modify me such that it can be used for logic programming in the above sense. this gives us the possibility to use existing theorem provers for disjunctive logic programming. as a first step towards this goal  we introduced in  baumgartner and furbach  1a  the restart variant of me and proved its refutational completeness. in this paper  we introduce an answer computing mechanism into restart model elimination  proofs of all stated theorems can be found in the long version  baumgartner et al  1  . furthermore we define a variant called ancestry restart me which allows extended regularity checking  i.e. loop checking  wrt. the ordinary restart me. additionally  this variant prefers proofs which allow for definite answers. 
¡¡for the second aspect  namely computing answers  we accommodated our protein system  baumgartner and furbach  1b  for answer computing as described below. we demonstrate with some of smullyan's puzzles  smullyan  1  that it is much more difficult to compute answers instead of only to prove unsatisfiability. for this we give a comparative study of high performance theorem provers  including otter  setheo and our protein system. 
1 from tableau to restart model elimination 
1 tableau model elimination 
in this subsection we use the clause notation  mirroring the fact that we review a calculus which is  as it stands  not suited for programming purposes. we use a me calculus that differs from the original one presented in  loveland  1 . it is described in  letz et al.  1  as the base for the prover setheo. in  baumgartner and furbach  1  this calculus is discussed in detail by presenting it in a consolution style  eder  1  and compared to various other calculi. me  in this sense  manipulates trees by extension and reduction steps. in order to recall the calculus consider the clause set 
{{p  q   {-p  q} {-q  p   {-p  -q}}  
baumgartner  furbach  and stolzenburg 	1 


1 	automated reasoning 

the inference rule restart is defined as follows: 
where 
1. is a path multiset  and 
1. leaf p  is a positive literal  and 
1. l=first  p . 
a strict restart me derivation from the clause set s consists 
of a sequence  and a substitution where 
1. po is a path m u l t i s e t c o n s i s t i n g of paths of length 1  with l  also called the goal 
clause   and for i = 1... n 
1. pi is obtained from vi-  by means of an extension step with an appropriate clause c from s and mgu 
1. pi is obtained from pi-  by means of a reduction step and or 
1. pi is obtained from pi-1 by means of a restart step. 
¡¡the path p is called selected path in all three inference rules. a restart step followed immediately by an extension step at the just obtained path is also called a restart extension step. finally  a refutation is a derivation where vn = {}.  end definition  
¡¡note that in extension steps we can connect only with the head literals of input clauses. since in general this restriction is too strong  we have to  restart  the computation with a fresh copy of a negative clause. this is achieved by the restart rule  because refutations of programs in goal normal form always start with -goal  i.e. the copied literal first p  = -goal; furthermore  only extension steps are possible to -goal  introducing a new copy of a negative clause  cf. figure 1  right side . 
¡¡the reduction operation is permitted from negative leaf literals to positive ancestor literals only. this condition can be relaxed towards disregarding the sign  which then yields the non-strict calculus version. see  baumgartner and furbach  1a  for a discussion of the differences. the reader aware of this work will notice that in the present text we define the calculus slightly different. this happens in order to conveniently express another calculus variant defined below. 
¡¡note that the restart me calculus does not assume a special selection function which determines which path is to be extended or reduced next. correctness and completeness of this calculus follows immediately from a result in  baumgartner  1 . from the definition of the inference rule extension  it follows immediately  that this calculus only needs those contrapositives of clauses which contain a positive literal in their heads. 
1 	computing answers 
in this section we introduce the notion of computed answers and we state an answer completeness result for restart me. we assume as given a program p together with one single query where the gis are positive literals. we will often abbreviate such a query as  - q  where q stands for the conjunction of gis. the clause set s is the transformation of  into goal normal form. in the following definition of computed answer we collect applications of the query clause  but not applications of negative clauses from the program p. 
definition 1  answers  if  - q is a query 
are substitutions for the variables from q. then 
is an answer  for s . an answer 	is a correct 
answer if 	. let now a restart me 
refutation of s with goal clause  - goal and substitution a be given. assume that this refutation contains m extension steps with the query  i.e. it contains m-times an extension step with 
the clause goal +- qpi where pi  is the renaming substitution of is a 
computed answer  for s . 	 end definition  
theorem 1  lifting theorem for restart model elimination  let s' be a set of ground instances of clauses taken 
from a clause set s. assume there exists a restart me derivation  with goal clause c1 € s'. then there exists a restart me derivation d = po  p1 ...  pn from s with some goal clause and substitution o such that pn is more general than pn.  a path set p is more general than a path set q iff for some substitution 1 we have ps = q.  
¡¡furthermore  there exists a substitution such that pi is obtained from by an extension step with clause c e s' if and only if pi is obtained from pi-1 by an extension step with a clause such that   where p is the renaming substitution applied in that extension step. 
¡¡the first part of the theorem will be used in the proof of refutational completeness  because for a refutation on the ground level  i.e. a derivation of p'n = {}  only the empty path set pn - {} can be more general   while the second part will be used in the proof of answer completeness  theorem 1 . in particular  to obtain this we have to demand one single substitution 1 which maps any of the clauses  used in extension steps to the respective clause on the ground level. clearly  this result is harder to establish and more relevant than a lifting result for sli-resolution in llobo et al.  1  which  moves the quantification inside : in our words  they state that for every application of an input clause at the ground level there exists an application at the first-order level  and there exists a substitution to map this instance to the ground level. 
theorem 1  answer completeness of restart me  // is a correct answer for a program p  then there exists a strict restart me refutation from s with com-

¡¡informally  the theorem states that for every given correct answer we can find a computed answer which can be instantiated by means of a single substitution 1 to a subclause of the given answer  and hence implies it . unfortunately we can not obtain a result stating that the computed answer contains less  or equal  literals than the given answer. 
¡¡all proofs are stated in the long version of this paper  baumgartner et al  1 . 
1 	definite answers and regularity 
from theorem proving with me we know that the regularity check is an important means for improving efficiency. regularity for ordinary me means that it is never necessary to 
baumgartner  furbach  and stolzenburg 	1 

construct a tableau where a literal occurs more than once along a path. expressed more semantically  it says that it is never necessary to repeat in a derivation a previously derived subgoal  viewing open leaves as subgoals . 
¡¡as an interesting side effect it turns out that this variant offers considerable benefits with respect to logic programming: occasionally one is interested in the question whether a given program with query admits a definite answer  i.e. an answer which is a single conjunction of atoms  but not a disjunction. of course  in general  a non-definite program does not always admit a definite answer  but some programs do. it is the latter class of problems we are interested in now. 
¡¡the key idea to the direct computation of definite answers is to restrict the use of the query to one single application in 
the refutation  namely at its top. then  by definition  definite answers are obtained. however  such a restriction is incom-
plete. but if restart me is modified in such a way that every negative literal along a branch  not only the topmost literal  may be used for the restart step then completeness is recov-then p is called globally regular. a path set is called  block-
wise  globally  regular iff every path in it is  blockwise  globally  regular. similarly  a derivation is called  blockwise  glob-
ally  regular iff every of its path sets is  blockwise  globally  regular. 	 end definition  
¡¡condition 1 states that all positive literals along a path are pairwise different  and condition 1 states that negative literals inside blocks are pairwise different  where by a block we mean a smallest subpath delimited by positive literals or the ends of the path. condition 1 means that a negative literal may be equal to one of its ancestors only if it follows a positive literal  i.e if it is used as a restart literal. thus we have a global 
regularity condition  except for restart literals. in all example refutations given so far  all branches are blockwise regular. 
however  the refutation in figure 1  right side  is not globally ered. this follows from a more general result which states that regular  as can be seen by the two occurrences of -q in the we can restrict to globally regular refutations  i.e. no literal rightmost path. from this example we learn that restart me is 
except the literal used for the restart occurs more than once incompatible with the global regularity restriction. however along a branch . let us now introduce all this more formally. it holds: 
definition 1  ancestry restart model elimination  the 	theorem 1  completeness of ancestry restart model ¡¡unfortunately  regularity is not compatible to restart me. in this section we will present a variant of restart me  the ancestry restart variant  which allows for extended regularity checks. this variant is motivated by loveland's unh-prolog  loveland and reed  1 . calculus ancestry restart me is the same as strict restart me elimination  let f be a head selection function and s be an  definition 1   except that the inference rule restart is mod- unsatisfiable clause set in goal-normal form. then there exists ified by replacing the condition 1. by the new condition 1'.: a globally regular ancestry restart me refutation ofs starting with  - goal and selection function f. 1'. l is a negative literal occurring in p. in this context l is 
	also called the restart literal. 	we can use this result to obtain the desired completeness 
result for definite answers. 
the modified rule is called ancestry restart.  end definition  
the term  ancestry  in the definition is explained by the use theorem 1  answer completeness of ancestry restart of ancestor literals for restart steps. note that any reduction me  ancestry restart me is answer complete in the sense from a positive leaf literal to a negative ancestor literal can be of theorem 1. in particular  if is a correct definite ansimulated in ancestry restart me by a restart step followed by swer for a program p  then there exists an ancestry restart a strict reduction step. thus  non-strictness is  built-in  into me refutation from p with computed answer such that 
ancestry restart me. 	 for some substitution furthermore  the input 
clause goal  - q is used exactly once  namely at the first 
note that the ancestry restart rule includes the restart rule 
¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡extension step of  - goal. since the first literal can be used for the restart as well. 
¡¡clearly  in terms of a proof procedure the ancestry restart the last theorem enables us to enumerate definite answers rule induces a larger local search space than the restart rule. on only  by simply restricting the use of goal  - q to one extenthe other side  refutations may become much shorter. indeed  sion step at the beginning. so we have the desirable properties this is the rationale for our proof procedure to search the restart of loop checking by regularity and the computation of definite literals from the leaf towards the top. as a further benefit of answers. this search order note that a definite answer will be enumerated 
before a non-definite answer. 
¡¡now we are going towards an appropriate completeness result wrt. definite answers. as mentioned above  this result shall be a consequence of a more general result concerning a regularity restriction. let us define this notion precisely: 
definition 1  regularity  let p be path written as follows  the as and bs are atoms : 1 	implementation 
all variants and refinements of me discussed so far  i.e. the restart  strict and ancestry variants  possibly with selection function   loop checking by regularity and factorization  are implemented in the protein system  baumgartner and furbach  1b . it is a first order theorem prover based on the prolog technology theorem proving  pttp  technique  imple-mented in eclipse-prolog. 
¡¡since me is a goal-oriented  linear and answer complete calculus  it is well suited as an interpreter for disjunctive 
1 	automated reasoning 

logic programming. protein facilitates computing disjunctive and definite answers. in its newest release their is also a flag which allows us to look for definite answers only. 
1 comparative theorem prover study 
in the sequel  we want to tell about our experiences in computing answers by using theorem provers. first of all  we had to overcome some technical problems because theorem provers usually do not supply answers besides  yes  or  possibly   no . - we will illustrate our experiences with a puzzle example which allows for indefinite and definite answers. 
1 knights and knaves 
the example follows problem #1 in  smullyan  1 . a similar example is studied in  ohlbach  1 . the natural language description of the problem is stated below. there  the last two pieces of information 1 and 1 explicitly state some knowledge about inferencing. we need them in order to be able to cope with the information in 1 because our description language is first order. 
1. on an island  there live exactly two types of people: knights and knaves. 1. knights always tell the truth and knaves always lie. 1 landed on the island  met two inhabitants  asked one of them:  is one of you a knight   and he answered me. 1. what can be said about the types of the asked and the other person depending on the answer i get  - 1. we assume  that either a proposition or its negation is true. 1. if the disjunction of two propositions is true then at least one of them must be true. 
¡¡in our formalization of the problem below  the formulae in 1 and 1 express the corresponding pieces of information from above. depending on the case considered  we choose one of the formulae  a  or  b  in 1. we view the fact that a person denies a question as that he says that the thing in question is not true using the binary predicate says  instead of a ternary predicate . formula 1 can be considered as the query. we have to express the pieces of information 1 and 1 explicitly by introducing the unary predicate true. the transformation of the formulae below into clausal form is straightforward and therefore omitted here. it consists of 1 clauses. - the symbol denotes exclusive or. 
¡¡we can prove the query in many different ways. as a consequence we get many trivial and hence useless answers. the  most  trivial one - a four part disjunction - can be obtained in both cases. we only need formula 1 and the query in order to infer it. but it only says that each of both persons are either knights or knaves. in case  a   if the asked person says yes  we can get an indefinite answer consisting of only three disjuncts. 
in the other case  b  there exists a definite answer. it follows a list of these possible answers where x / y is an abbreviation of true isa asked x   true isa other  y  . 
1. knave/knave v knave/knight v knight/knave v knight / knight  trivial  
1. knave /knave v knight /knave v knight / knight 
 indefinite  
1. knave 	/knight 	 definite  
¡¡before turning to our experiments we want to mention some interesting facts. firstly  answer completeness requires that we are able to compute the indefinite and definite answer in the respective cases. secondly  to derive these answers we need a clause set which is not minimal unsatisfiable; notice that the clauses of 1 and 1 together are  minimal  unsatisfiable yielding the trivial answer. thirdly  1 extension steps are needed to derive the indefinite or the definite answer respectively  while only 1 extension steps are needed to derive the trivial answer  in both cases . - these remarks indicate that it should be more difficult to find the more precise answers. 
1 experimental results 
we tried to get the answers from above automatically by using the theorem proving systems otter  mccune  1  which is a resolution-style theorem proving program coded in c for first order logic  with equality   setheo  letz et a/.  1  which is a top-down prover for first order predicate logic based on the calculus of the so-called connection tableaux which generalizes weak me  implemented in c  and protein  baumgartner and furbach  1b  which we already introduced in section 1. - we used the clause ordering given by the problem description  but our experiments show that the  run time  results depend on the ordering. 
otter has some problems with computing answers be-
cause it enumerates resolvents but not all  refutational  proofs. especially during the subsumption test  it did not take the answer literals into account which are provided for computing answers. that is the reason why otter with  forward and backward  subsumption is not answer complete. an example which illustrates this is case  a  where the search stops after finding 1 times only the trivial answer with binary resolution. however  we find a proof by using hyper-resolution with factorization immediately within 1s. - there is a solution to the problem with subsumption; it can be shown that we only have to take the answer literals into account during the subsumption steps. unfortunately  it is not  yet  possible to test otter in this setting and find out whether this improves the behaviour  because it is not built in. 
¡¡we generate answers with setheo by using global variables. the answers are kept in a list. by this and other technical tricks  we find the indefinite answer within 1s and the definite answer within 1s. that is quite good and may be explained by the subgoal reordering heuristics built into setheo  which are not  yet  incorporated into our system. but in addition  setheo also has subsumption constraints which are used in the default setting. it is not quite clear  whether these constraints destroy answer completeness in setheo. - table 1 shows the timings for otter and setheo. all timings are measured on a sparc 1. the symbol oo denotes the fact that no proof was found within 1 hour; that is true for otter applied to case  b  of our example. 
baumgartner  furbach  and stolzenburg 	1 protein is answer complete; that has been stated in this paper. it finds out the indefinite and definite answer for the respective case. the table in figure 1 also shows some timings for finding these answers with protein. we tried both  plain and restart me. in case of the restart variant we also tried its refinements: with or without ancestry restart or selection function  no contrapositives . we tried to compute the desired answers with settings where all solutions are computed in case  a   indefinite answer . for the case  b   definite answer  we used the setting where only definite answers are searched for. by this  we get a significant speed up of the search. as one can see  using restart helps for this problem  since plain me does not find the desired answers quickly  although it does so for trivial answers. but it is not quite clear which flags should be used in addition. 
¡¡we investigated more puzzle examples from  smullyan  1 . all our experiments corroborate the following facts: resolution has difficulties in solving puzzles because of the problem with subsumption; model elimination is better suited although it could not solve all puzzles that we tested. for example  otter needs 1s on puzzle #1 while protein only needs 1s. further investigations are necessary. it seems that also a model generation approach is very adequate  manthey and bry  1  for these kind of problems because they often allow for finite models. last but not least  we want to point out that both  otter and setheo do not support a procedural reading of program clauses - they need all contrapositives - but protein does; and that is useful if we want to use logic as a real programming language. 
1 	conclusion 
to conclude  it seems to be very promising to use me as a base calculus for computing answers in disjunctive logic programming. in this paper  we introduce  among others  the ancestry restart variant which is quite well suited for this purpose. we also give some practical evidence. nevertheless  further investigation is necessary in order to find out yet more efficient calculi and to incorporate nonmonotonic extensions. 
acknowledgements 
we would like to thank francois bry  jurgen dix  bertram fronhofer  reinhold letz and william w mccune for helpful discussions  and olaf menkens and dorothea schafer for their implementational work. 
1 	automated reasoning 
