
mechanism design is the study of preference aggregation protocols that work well in the face of self-interested agents. we present the first general-purpose techniques for automatically designing multistage mechanisms. these can reduce elicitation burden by only querying agents for information that is relevant given their answers to previous queries. we first show how to turn a given  e.g.  automatically designed using constrained optimization techniques  single-stage mechanism into the most efficient corresponding multistage mechanism given a specified elicitation tree. we then present greedy and dynamic programming  dp  algorithms that determine the elicitation tree  optimal in the dp case . next  we show how the query savings inherent in the multistage model can be used to design the underlying single-stage mechanism to maximally take advantage of this approach. finally  we present negative results on the design of multistage mechanisms that do not correspond to dominant-strategy single-stage mechanisms: an optimal multistage mechanism in general has to randomize over queries to hide information from the agents.
1 introduction
in multiagent settings  often an outcome  e.g.  presidents  joint plans  allocations of resources  must be chosen based on the preferences of a set of agents. since the preference aggregator generally does not know these preferences a priori  the agents must report their preferences to the aggregator. unfortunately  an agent may have an incentive to misreport its preferences in order to mislead the aggregator into selecting an outcome that is more desirable to the agent than the outcome that would be selected if the agent revealed its preferences truthfully.
¡¡mechanism design is concerned with the creation of preference aggregation rules that lead to good outcomes in spite of such strategic behavior by agents. classical mechanism design providessome generalmechanisms  which  undercertain assumptions  satisfy some notion of nonmanipulability and maximize some objective. typically  such mechanisms do not rely on  even probabilistic  information about the agents' preferences  e.g.  the vickrey-clarke-groves  vcg  mechanism  1; 1; 1    or can be easily applied to any distribution over preferences 1; 1; 1; 1 . however  these general algorithms only work in restricted settings  e.g.  they may require the possibility of side payments  or work only for specific objectives  and may not reflect the designer's objectives.
¡¡recently  automated mechanism design  amd  has been proposed as a means to design mechanisms automatically for the setting at hand  1; 1 . this approach  based on constrained optimization  produces optimal special-purpose mechanismseven in settings for which no goodgeneral mechanisms are known  or for which impossibility results preclude the existence of good general mechanisms for the class of instances. while amd is a relatively new approach  it has already started to be adopted in applications  for example  in strategic sourcing  reserve price setting in asset recovery  and recommender systems . however  all prior work on general-purpose amd has focused on singlestage mechanisms  in which all agents reveal their preferences completely and simultaneously. this is problematic for several reasons. first and foremost  agents may need to invest significant computational  cognitive or other resources to determine their preferences over outcomes  1; 1; 1 . for instance  when bidding on trucking tasks in a combinatorial reverse auction  an agent needs to solve  for each subset of tasks  a complex vehicle-routing problem . second  the agents lose all privacy about their preferences. third  it can requirea large amountof communication. while the third reason applies only when the space of possible preferences is large  the first two reasons are significant even in settings with few outcomes or possible preference functions.
¡¡much of this computation  communication  and privacy loss is unnecessary when certain aspects of an agent's preferences have no influence on the final outcome. for instance  if a second agent can perform a task at much lower cost than a first  we need not determine precisely how suboptimal assign-
ing the task to the first agent is. unfortunately  single-stage mechanisms cannot take advantageof this: we cannota priori rule out the need to know the first agent's precise preferences for the task-this only becomes apparent after receiving information from the second.
¡¡our solution is to use multistage mechanisms  where the aggregator queries the agents about certain aspects of their preferences  and chooses the next query to ask  and who to ask it of  based on answers to earlier queries. in a nongame-theoretic setting  a move to multistage protocols can yield an exponential savings in bits communicated . in mechanism design settings  such a move can yield an exponential savings in communication and the aggregator's computation .
¡¡multistage mechanisms have been manually designed for several applications  such as voting   single-item auctions  e.g.     and combinatorial auctions  see reviews  1; 1  . automated design of multistage mechanisms has been addressed for specific settings in parallel with our work  1; 1; 1 . prior work has studied the design of multistage mechanisms in strategic multi-party computation  1; 1   but the issues in that setting  e.g.  that an agent may be tempted not to invest the effort necessary to determine its private information  are very different from those we address. in this paper  we introducethe first general techniquesforautomated design of multistage mechanisms. we adopt a very specific methodology: first design a single-stage mechanismusing existing techniques for amd; this is then converted into a multistage mechanism using one of several techniques we propose. we also show how the multistage model can be used to to influence the design the underlying single-stage mechanism to maximally take advantage of the savings inherent in the multistage model. as such  relying on an intermediate single-stage mechanism incurs no loss.
1 the model
1 automated design of single-stage mechanisms
in this subsection  we review the relevant definitions and results from the single-stage amd literature. in a single-stage amd setting  we are given: 1  a finite set of outcomes o  payments to/from agents can be part of the outcome ; 1  a finite set of n agents; 1  for each agent i   a  a finite set of types ¦¨i   b  a probability distribution ¦Ãi over ¦¨i  in the case of correlated types  there is a single joint distribution ¦Ã over ¦¨1¡Á...¡Á¦¨n   and  c  a utility function ui : ¦¨i¡Áo ¡ú r;1  an objective function g : ¦¨1 ¡Á...¡Á¦¨n ¡Áo ¡ú r whose expectation the designer wishes to maximize. note that utility functions are parameterized by type; while the ui are common knowledge  the types encode  private  preferences . the restriction to a finite type space is somewhat limiting. however  continuous spaces can be handled via suitable discretization of the type space.1 possible designer objectives are many  e.g.  social welfare  or maximizing the sum of agent utilities for the chosen outcome .
¡¡by the revelation principle   we can restrict attention to truthful  direct revelation mechanisms  where agents report their types directly and never have an incentive to misreport them. in general  mechanisms may choose the outcome randomly. thus  a mechanism consists of a distribution selection function p : ¦¨1 ¡Á ... ¡Á ¦¨n ¡ú ¦¤ o   where ¦¤ o  is the set of probability distributions over o. a mechanism is a dominant strategy mechanism if truthtelling is optimal regardless of what other agents report. in other words  for any agent i  type vector  ¦È1 ... ¦Èi ... ¦Èn   and alternative report ¦È i ¡Ê ¦¨i  we have eo|¦È1 .. ¦Èi .. ¦Ènui ¦Èi o  ¡Ý eo|¦È1 .. ¦È i .. ¦Ènui ¦Èi o . if telling the truth is optimal only given that the other agents are truthful  we have a bayes-nash equilibrium  bne  mechanism. that is  in a bne mechanism  for any i  ¦Èi ¡Ê ¦¨i  and alternative report ¦È i ¡Ê ¦¨i 
we have e ¦È1 .. ¦Èi 1 ¦Èi+1 .. ¦Èn |¦Èieo|¦È1 .. ¦Èi .. ¦Ènui ¦Èi o 	¡Ý
.
¡¡in settings where participation is voluntary  the amd formulation also includes participation  or individual rationality  constraints: no agent is worse off participating in the mechanism than not. techniques for handling them in singlestage amd can be applied to our multistage case without modification.
¡¡given that the mechanism is allowed to choose the outcome at random  the problem of designing an optimal singlestage mechanism can be solved in polynomial time  given that the number of agents is constant  using linear programming . the decision variablesof that linear programare the following: for every type vector ¦È and every outcome o  there is a decision variable p ¦È o  that determines the probability of that outcome given that type vector. it is straightforward to check that the incentive compatibility constraints above  as well as the expectation of the objective  are linear functions of these variables  which gives us the linear program. generating and solving this linear program is all that is required to have a basic approach to automatically designing single-stage mechanisms  and it is in fact the approach that we use in this paper to generate single-stage mechanisms.
1 automated design of multistage mechanisms
in multistage amd  the input includes-in addition to the input for single-stage amd-a set of queries q and a set of answers a. assuming a single answer set  rather than distinct aq for each query q  comes without loss of generality. one set of special interest is a = {yes  no}. each query q is associated with a particular agent i  of whom q would be asked  1 and the answer that the agent would give to q  when answering truthfully  is given by the function a : q ¡Á ¦¨i ¡ú a  where a q ¦Èi  is i's truthful answer to query q when i's type is ¦Èi. this implies that there is only one truthful response to any q ¡Ê q; thus  each query partitions the agent's type space. upon receiving answer a to q from agent i  the mechanism can infer  assuming truthfulness  i's type is in {¦Èi ¡Ê ¦¨i : a q ¦Èi  = a}.
¡¡a multistage mechanism m corresponds to a given singlestage mechanism s if  for each type vector ¦È reported by the agents  both m and s choose each outcome o with the same probability. suppose m corresponds to some s where truth-telling is dominant. it is not hard to see that m has truthtelling as an ex-post equilibrium  regardless of the the results of previous queries revealed.  a vector of strategies is an ex-post equilibrium if for each agent  following the strategy is optimal regardless of the types of the other agents given their strategies.  that is  truth-telling is optimal  regardless of an agent's beliefs  whenever all other agents answer queries truthfully.thisimplies that we never need to randomize over query choice  though this no longer holds if s is not a dominant-strategy mechanism  as we will see later . ex post implementation is weaker than dominant strategies  but stronger than bne. note that even if s is a dominant-strategy mechanism  m need not be: if an agent makes her answer dependent on the history of queries asked  another agent may have an incentive to lie about her type in order to influence which queries the former is asked.
¡¡for these reasons  apart from the last technical section in the paper  we focus exclusively on multistage mechanisms that correspond to dominant-strategy single-stage mechanisms. thus  we can restrict ourselves to mechanisms that select the next query deterministically based on answers to prior queries; moreover  we need not worry about incentives.
¡¡under these restrictions  a multistage mechanism is defined by: 1  a tree with nodes v and edges e; 1  for each internal  non-leaf  node v  an agent i and a query q to that agent; 1  a one-to-onecorrespondencebetween possible answers to the query at node v and children of node v; 1  for each node v and outcome o  a probability that  given that we reach v  we stop asking queries and choose outcome o.  in the case where v is a leaf  these probabilities must sum to one.  an elicitation tree is a multistage mechanism without outcome probabilities. we denote by iv the information set at node v  i.e.  the set of type vectors consistent with the answers that lead to v . we generally assume an elicitation tree is complete: il is a single type vector for any leaf l.1
¡¡we study several variants of multistage amd. we consider the possibility starting with a given single-stage mechanism  e.g.  computed by single-stage amd software  and turning it into a corresponding multistage mechanism  as well as allowing our multistage perspective to influence the choice/design of the underlying single-stage mechanism. we also consider multistage design when the elicitation tree  hence the query order  is given beforehand  and when we impose no constraints on the form of the tree.
1 a small example
in this section  we illustrate various notions for automatically designing multistage mechanisms using a simple example. suppose a divorcing couple jointly owns a painting  and an arbitrator has to decide the fate of the painting. there are 1 options:  1  the husband keeps the painting;  1  the wife keeps it;  1  the painting remains jointly owned  but is hung in a museum;  1  it is cut into pieces which are given to the husband; and  1  it is cut up with pieces given to the wife. the husband and wife each have two possible types: type l   low   is associated with relative indifference toward the painting  and type h   high   with deep attachment. each has type l with probability 1 and type h with probability 1. to maximize social welfare  the arbitrator would like to give the painting to whomever cares for it more; but since a party who cares little would prefer having it over not  the arbitrator must design appropriate incentives to ensure truthful reporting. the utility function for each party is the  same.  keeping the painting gives utility 1  type l  or 1  h . the other party getting the painting gives utility 1  foreither type . the museum outcome gives utility 1  l  or 1  h . receiving pieces gives utility  1 while not even getting the pieces gives utility  1  for either type .1
¡¡our goal is to find a dominant-strategy  possibly randomized  mechanism  without payments  that maximizes expected social welfare. first we find the optimal single-stage mechanism. solving this example using the methodology described earlier yields the following randomized mechanism  the probabilities are rounded :
wife lwife hhusband lmuseum1 wife keeps;
1 husband gets pieceshusband h1 husband keeps;1 husband keeps;1 wife gets pieces1 wife keeps;
1 wife gets piecesin spite of the symmetry between the husband and the wife  the mechanism is asymmetric. of course  other optimal solutions exist  e.g.  where the roles of husband and wife are interchanged .
¡¡now we consider how to turn this single-stage mechanism into a corresponding multistage mechanism  i.e.  with the same outcome probabilities . first  suppose the elicitation tree is given  with the wife's type elicited first. fig. 1 shows the optimal multistage mechanism.  why this is so will become apparent.  this mechanism saves one query with probability 1 ¡¤ 1 = 1.
¡¡if the elicitation tree  query order  is not fixed  the optimal mechanism is that given in fig. 1. it turns out that greater savings can be obtained by eliciting the husband's type first: this mechanism saves a query with probability 1 ¡¤  1 + 1  = 1.  this is due to the asymmetry of the singlestage mechanism from which we are starting. 
¡¡suppose queries to the husband are slightly more expensive than those to the wife  so that we would rather save on husband queries  unlike the previous mechanism . if we allow a different optimal single-stage mechanism  namely the analog of the one above with the husband and wife roles switched  which remains optimal due to the problem symmetry   then the optimal multistage mechanism that corresponds to this

figure 1: the optimal elicitation tree given the single-stage mechanism and given that the wife is queried first. when an internal node has a probability-outcome pair associated with it  we terminate early at that node with that probability  with that outcome; with the remaining probability  we move on to the next query.

figure 1: the optimal mechanism when asking the husband first.
saves a query to the husband  rather than the wife  with probability 1  giving greater cost savings.
¡¡finally  if we are willing to sacrifice optimality of the single-stage mechanism to obtain greater query savings  this may again change the mechanism. for example  if we make the cost of querying sufficiently large  it will be optimal to not ask any queries  and always choose the same outcome.
¡¡one interesting additional motivation for automatically designing multistage mechanisms is that the tree-based representation of a multistage mechanism may be easier to understand for a human than the tabular form of a single-stage mechanism-especially if the tree is relatively small.
¡¡the trees in the figures are reminiscent of decision trees in machine learning  and boolean function representation. in decision tree learning  the tree classifies an example based on the answers to a sequence of queries about features of the example. similarly  a multistage mechanism determines the outcome for a particular type vector based on the answers to a sequence of queries about the agents' types. there are significant differences  however  in the form of the trees. for example  decision trees typically do not use randomization in determining the classification. moreover  decision trees never determine the classification at an internal node of the tree  whereas we probabilistically terminate the querying process in our trees.1 our tree transformations do have an analog in decision tree learning  where reordering is often considered for the purposes of simplicity and generalization ; but again the motivation  details  and meaning of such transformations are quite distinct.
1 converting a single-stage mechanism into a multistage mechanism
in this section we develop methods for converting a given  e.g.  automatically designed  single-stage mechanism into an equivalent multistage mechanism which saves on elicitation costs. the analog of this in decision trees would be constructing a  short  decision tree  given that  for each complete instantiation of all the features  we have already decided how we want to classify examples with that instantiation. in the first subsection we develop methods for the case where the elicitation tree  query order  is given. in the second subsection we generalize the approach to the case where the elicitation tree is not given  but can be chosen endogenously.
1 given elicitation tree
we first solve the simplest of our problems: converting a single-stage mechanism into the most efficient multistage mechanism for a given elicitation tree. this problem can be motivated by considering exogenous constraints on query order  e.g.  agents available at different times  or when the optimal ordering is readily available . more importantly  this setting serves as a stepping stone to more general techniques below. our key technique is to  propagate up  probability from the leaves to internal nodes where this is possible.
lemma 1 let multistage mechanism m correspond to single-stage mechanism s. suppose that for some internal node v in the elicitation tree  with exit probability ev  and outcome o  all the leaves of the subtree tv rooted at v assign a probability of at least p   1 to outcome o  and none of the internal nodes of tv have any exit probability . then the following modificationcorresponds to s:  1  at node v  exit with o with probability  1   ev p;  1  subtract p from the probability assigned to o at each leaf of tv;  1  divide all the outcome probabilities at leaves tv by 1   p.
proof: consider the probability  that outcome o will be selected given type vector . if ¦È does not lead to v  clearly is the same in m and m; so assume that it does. if   the outcome we exit early with   then the probability of selecting is now the early-exit probability p  plus the probability that we do not exit early but choose outcome o later  which is
. hence
the total probability is; i.e.  it did not change. if
  then the probability of selectingis the probability that we do not exit early with o and choose outcome o later  which is .
hence for any with the same probability. 
¡¡we note that the ability to propagate probability up in this manner even when the distributions at the leaves are not identical makes this different from the standard framework in communicationcomplexity theory.  in addition  we may have a restricted query language  and we have a prior distribution over the inputs. 
¡¡if we propagate up as much probability as possible  we obtain the optimal mechanism  for a given s and tree :
theorem 1 suppose we apply lemma 1 to every pair  v o   starting at the root and working our way down to the leaves. then the resulting multistage mechanism saves the most queries  or  in the case of different query costs  the greatest query cost  among multistage mechanisms corresponding to the given single-stage mechanism and the given elicitation tree.
¡¡as an example  we derive the mechanism of fig. 1. we start from a mechanism that saves no queries  fig. 1 .

wife gets pieces w.p. .1
figure 1: multistage mechanism that saves no queries at all.
¡¡at the node after the husband reports  high   the husband keeps the painting with p ¡Ý .1 in all subsequent leaves. so we can propagate this probability up  fig. 1 .

figure 1: some probability propagated up.
¡¡at the same node  the wife gets the pieces of the painting with p ¡Ý .1 in all subsequent leaves. propagating this up results in the mechanism of fig. 1.
¡¡the following corollary characterizes the probability of exiting early at or before a given node. this will be helpful in our use of the  propagatingprobabilities up  techniquewithin all of the algorithms discussed later in the paper.
corollary 1 in a multistage mechanism that saves a maximum number of queries  for any type vector ¦È such that node v will be reached if the mechanism does not exit early  the probability that we will reach v and not exit early at v  given that ¦È is the type vector  is . hence 
given that ¦È is the type vector and we have not exited early at or before node v  and we transition from node v to node w 
the probability of exiting early at node w is
.
1 endogenously determined elicitation tree
in this section we develop methods for converting a singlestage mechanism into a multistage one  without constraints on the elicitation tree  query order . we first providea greedy algorithm  and show two ways in which it can  fail   i.e.  yield an arbitrarily small fraction of the query savings available . we then give an optimal dynamic program.
greedy algorithm
our greedy algorithm chooses the query at each stage so as to maximize the probability of being able to exit immediately after this query given the preceding queries and responses. letting u i q aq  denote the information state that results from being in information state i and then receiving answer a to query q  we define the algorithm as follows.
definition 1 the greedy algorithm chooses the query to ask at node v from the set argmax.
	¡Ê	¡Ê
the greedy algorithm does what we intend:
theorem 1 the greedy algorithm chooses a query that maximizes the probability of exiting immediately after it.
theorem 1 the greedy algorithm chooses the query for node v in time o |q| ¡¤ |a| ¡¤ |o| ¡¤ |¦¨| .
¡¡unfortunately  the greedy algorithm can be arbitrarily far from optimal  even when all queries have equal cost :
proposition 1 there exist single-stage mechanisms s for which the greedy algorithm achieves only an arbitrarily small fraction of the possible query savings  even when s is deterministic  there are only three players  two types per player  and three outcomes; alternatively  even when priors over types are uniform  there are only three players  two types per player  and five outcomes .
¡¡this is a worst-case result; it is likely that the greedy algorithm will perform quite well in practice.
dynamic programming algorithm
unlike the greedy algorithm the dynamicprogrammust build the entire tree. the program works by computing  for every possible information state i  the minimum possible expected number of queries n i  from that point on  given that we have not exited early. as before  let u i q a  be the information state that results from receiving answer a to q at
i. let e i q a  be the probability of exiting immediately after receiving answer a to q at i  given that we did not exit early at i. by corollary 1  we can compute e i q a  as
p	p ¦È o . we obtain the recurrence
¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡o¡Êo n i  = minq¡Êqc q +x p a|i q  1 e i q a  n u i q a  
a¡Êa
¡¡using the fact that n {¦È}  = 1 for every type vector ¦È  we use this recurrence to compute the value of n i  for every i  starting with the small i and working up to larger ones.
theorem 1 the dynamic programming algorithm computes the value of n i  for all i in time o |q|¡¤|a|¡¤|o|¡¤|¦¨|¡¤1|¦¨| .
¡¡we can retrieve the optimal multistage mechanism from this as follows: when we arrive at information state i and do not exit early  choose a query from argminp a|i q  1   e i q a  n u i q a  .
1 designing optimal multistage mechanisms
so far we have discussed how a given single-stage mechanism can be converted into an equivalent multistage mechanism. here we will no longer take the single-stage design as a constraint. we develop a method for designing the singlestage mechanism in such a way that we get large savings in queries when we transform it into a multistage mechanism using the techniques described earlier. we focus on the case where the elicitation tree  query order  is given. it turns out that  using corollary 1  we can directly integrate the eventual query savings into the linear programming formulation for amd described earlier.
¡¡we say that node v is on the elicitation path for type vector ¦È if ¦È would lead us to ask the query at v  given that we do not exit early . for every internal node v in the tree  we add a term to the amd objective  which maximizes the designer's objective  that indicates the probability of saving the query corresponding to this node.1  we say that we save the query corresponding to v when v is on the elicitation path  but we exit early at or before v.  thus  the term in the objective for v is c v p v e v  where c v  is the cost of the query at node v  p v  is the probability of v being on the elicitation path  and e v  is the probability that we will exit early at or before v  given that v is on the elicitation path. p v  is a constant  but e v  is a variable that depends on how we set the outcome probabilities for the leaves. specifically  by
corollary 1  we know that. the min operator is not linear  so we cannot add this expression to the lp objective directly. we work around this by letting
  where e v o  is the probability of exiting
early at or before v with outcome o  given that v is on the elicitation path. then  for every o ¡Ê o and ¦È ¡Ê sv  we add the constraint e v o  ¡Ü p ¦È o .
¡¡because linear programs can be solved to optimality in polynomial time  and the formulation above is polynomial in the number of outcomes and the number of types per agent  but not in the number of agents   the following theorem follows immediately:
theorem 1 the extension of the single-stage amd formulation described above computes the optimal multistage mechanism for the given elicitation tree  taking query costs into account  in time polynomial in the number of outcomes and the number of types per agent  but not in the number of agents .
¡¡this also begets an  inefficient  algorithm for generating the optimal multistage mechanism when neither the singlestage mechanism nor the elicitation tree is given: apply the above algorithm to every possible elicitation tree.
1 mechanisms without dominant strategies
so far  we have restricted our study to multistage mechanisms whose single-stage correspondentshave truth-telling as a dominant strategy. as discussed  this is helpful because in such multistage mechanisms  telling the truth is an ex-post equilibrium  so we need not worry that information revealed to agents by the mechanism will introduce strategic behavior. nevertheless  we may also be interested in converting single-stage mechanisms that do not have dominant strategies  such as bne mechanisms  to multistage mechanisms  e.g.  because such mechanisms can achieve a higher objective value than dominant-strategy mechanisms .
¡¡here we present initial results on converting bne mechanisms into multistage mechanisms. these results are negative: they show that restricting ourselves to particular natural classes of multistage mechanisms may come at a loss of optimality. thus  to design optimal multistage mechanisms  we need to search a broader space of mechanisms.
proposition 1 even when the primary objective is social welfare and we use bne as our solution concept  there exist settings in which immediately revealing the result of every query incurs a loss in objective value.
¡¡the next result that we establish is that restricting ourselves to mechanisms that always choose the next query deterministically can come at a loss.
proposition 1 there exist settings in which:
1. the primary objective is social welfare;
1. the optimal single-stage bne incentive compatiblemechanism is unique;
1. the unique optimal  in terms of query savings  elicitation tree to ask the queries for this mechanism is not  even bne  incentive compatible;
1. there exists an elicitation tree for this mechanism thatrandomizes over the next query selected  is  bne  incentive compatible  and has almost the same query savings as the optimal elicitation tree  and thus strictly greater query savings than any deterministic  bne  incentivecompatible elicitation tree for this mechanism .
¡¡a potential alternative to randomization by the mechanism is to obtain the randomization from mixed  i.e.  randomized  strategies of the agents in mechanisms that are not truthful direct-revelation mechanisms.
1 conclusions
we extended the constrained-optimization based techniques for automated mechanism design to the design of multistage mechanisms  allowing reduction in elicitation burden by querying agents sequentially  and only querying them for information that is relevant given previous query responses. we focused primarily on the design of multistage mechanisms that correspond to dominant-strategy singlestage mechanisms  since these ensure truth-telling is an expost equilibrium  no matter what is revealed about other agents' answers . we described several techniques for converting single-stage mechanisms into multistage  both with and without fixed elicitation trees  and also showed how to augment single-stage amd to produce single-stage mechanisms that can be maximally exploited in the conversion to multistage. finally  we presented negative results on the design of multistage mechanisms that do not correspond to dominant-strategy single-stage mechanisms.
