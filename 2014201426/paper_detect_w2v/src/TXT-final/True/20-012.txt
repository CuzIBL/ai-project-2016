 
     the paper is organised around a particular problem of anaphoric definite reference. a solution to this problem requires sentence processing which allows semantic representations to be evaluated incrementally  as a phrase is read from left to right. the paper shows how a proposal made by mellish  1   to regard incremental semantic evaluation as a constraint satisfaction task  can provide a natural solution to the problem of reference. the incorporation of combinatory categorial grammar allows a straightforward relationship to be stated between the incrementally assembled syntactic and semantic representations. 
i introduction 
     the concern of this paper is to show how a computational model of incremental interpretation suggests a solution to a particular problem of definite reference. suppose we have a context in which there arc three rabbits  rl  r1  and r1   two hats  hi and h1  and one box  bl   where one rabbit is in a hat and one is in the box: 

if both speaker and hearer are aware of this context  the second rabbit  r1  can be referred to by means of the following complex np: 
 1  the rabbit in the hat 
this expression can be uttered without any previous talk of rabbits or hats. what is interesting about it is the use of the definite determiner in the inner  simple np  the hat. as a whole  the expression in  1  sounds perfectly natural  and so suggests that a unique hat is identifiable to the hearer. but given that there are two hats  and not one  in the scene  why is the definite permissible  any compositional accounts of np semantics  including those of winograd  1  and hirst  1   would judge  1  to be infelicitous. such theories would require the somewhat convoluted version in  1   if a definite is to be used at all to specify the hat 
 1  the rabbit in the hat with a rabbit in it 
     a semantics organised around the criterion of incremental interpretation should have less trouble with  1 . if we assume that a hearer incrementally evaluates a semantic representation - after each word  say - the empty hat in the scene will never really be considered a viable candidate for the inner np. when the word rabbit is reached  a hearer can collect together in his mind the set of rabbits in the context. after the preposition  this set can be refined to contain only rabbits which are in something and  most importantly  the hearer can start thinking about another set of objects  those which have rabbits in them. there is only one hat in this new set and so by the time the inner np is processed a definite determiner sounds natural. how can we pin this idea down in more explicit  computational terms  
ii reference and constraint satisfaction 
     mellish  1  has proposed that the general process of incremental reference evaluation  sketched above  can be directly expressed by a constraint satisfaction algorithm of the kind presented by mackworth  1 . consider the following predicates  which may arise from the fragment the rabbit in  ignoring the determiner : 
 1  rabbit el  in el e1  
constraint satisfaction involves determining  for each of the variables el and e1  the entities in the discourse which satisfy the predicates  and collecting these into candidate sets for each variable.  we shall refer to these variables as extension variables.  given the context provided for  1  above  this operation will label el with the set  r1.r1  and e1 with  h1 b1 . the advantage of the scheme is at once clear: satisfying the constraints in  1  determines a candidate set for e1 as well as el  and so the reference of any np which follows the fragment is already partially-evaluated. this offers a natural solution to the problem of non-compositionality exhibited in  1 ; a solution which is difficult to obtain in compositional semantic systems. 
     the following treatment of our problematic phrase illustrates two significant improvements on mellish's own account of anaphoric definite reference. first  the phrase is evaluated strictly word-by-word  in left-to-right order  there is linguistic  psychological and intuitive support for this general position  steedman  1  . in contrast  mellish's system would evaluate the two nouns before considering the preposition which relates them. second  the relationship between syntactic and semantic descriptions is made explicit. mellish himself points out that his system  lacked precision  on this issue  mellish 1 . 
lll the model 
     the model sees syntax as controlling the way in which semantic representations are combined. and the goal is to pro-
	haddock 	1 

vide an incremental semantics  so that a phrase receives its interpretation in stages  after each word is read. if this process is to accord with the rules of syntax  then the grammar too must be incremental. 
     a framework which might be helpful in this respect is combinatory categorial grammar  ades and steedman  1   
	stecdman  1  . 	like all categorial grammars  combinatory 
grammar employs a rule of function application to combine functions and arguments: 
 1  x/y + y 	x 
steedman adds further combinatory rules  including function composition 
 1  x/y + y/z -  x/z 
as we shall sec  function composition is especially relevant to the issue of incrementation because it allows  incomplete  constituents  such as the rabbit in or you can believe that i like  to be elegantly described. 
　　　how can a constraint-based semantics be tailored to a system of combinatory grammar  suppose we associate a constraint with each nominal word and an extension variable with its category. the noun box could have the following entry in the lexicon: 
 1  box := ne1 : box c1  
box is defined   :=   as being an n linked to the variable e1. the identity of this variable is arbitrary; all mat matters is that each word in the string is given a novel extension variable  to avoid unintended name clashes. the definition above associates a constraint with the noun  indicating that any value assumed by e1 must name a box in the context. function categories differ only in that they are coupled to mappings between variables. consider the category for a determiner  np/n: given a noun to the right  this yields an np. with semantics attached  the definite determiner appears as: 
 1  the := np e l /n e l : unique el  
this simply states that the variable associated with the noun is the same as the one associated with the np  el. this ensures that the constraint arising from the determiner  unique el   will restrict the set of candidates that apply to the noun  whatever they turn out to be. 
　　　the combination rules of the grammar have responsibility for relating these representations to each other. in relating the above determiner and noun  for instance  the variables el and e1 should be identified  because they are really both about the same set of candidate entities. thus  in addition to the usual cancellation in the syntax  the rules of application and composition must equate extension variables. this is achieved by imposing a constraint of equality on the variables concerned  and the application of the to box appears as the reduction in  1 . 
 1  npe l /n c l + 	ne1 	np e l 	: 	equal el e1  
the constraint of equality expresses the fact that the candidates for el must be the same as those for e1; all constraints which apply to el must also apply to e1  and vice versa. 
     let us now go back to the phrase in  1   and consider the representations bestowed upon its component parts. prepositions are functions taking an np argument on their right to form another function  which must modify a noun on the left. they are therefore categorised as  n n /np  where the leftward application of the inner function is indicated by a backward slash v. because of its relational standing  in maps between two distinct extension variables: 
1 	natural language 
 1  in :=  n e 1  n c 1  /np c 1 : in e1.e1  
thus  e1 will be identified with the variable of the head noun and related to e1  which represents the prepositional object. 
     any noun is form-class ambiguous between its primitive category  n  and a type-raised category  n/ n n   a function over noun-modifying functions. type-raising gives a noun like rabbit the opportunity to compose with in  categorised as  n n /np. note that this operation simply alters the noun's syntactic status  and does not complicate the semantics: 
 1  rabbit := n c 1 / n e 1  n e 1   : rabbit e1  
the means by which the parser decides between the two noun categories is beyond the scope of the present paper; suffice it to say that the choice is made in accordance with  the principle of referential failure  of altmann  1 . in the following analysis of  1   we will assume the type-raised version of rabbit  which expects modifying material  and the primitive version of hat  which closes the whole np. 
     the constraint arising from a definite article  introduced above as unique el   is different in kind to the constraints arising from rabbit  hat and in it is defined as follows: 
 1  unique en  is true iff the candidate set for en is singleton 
whereas a constraint like rabbit en  is a predicate over the particular discourse entities which make up the set for en  unique en  is a predicate over the set as a whole. as such  umque en  is a  meta-constraint : it makes a check on the degree to which a given candidate set is constrained. there is another aspect of  1  which distinguishes it from the rest. whereas rabbit en  has its effect as soon as the word rabbit is read  the constraint in  1  is only enforced when the np corresponding to the variable en is syntactically closed. 
     finally  a note on parsing. the input string is processed by a non-deterministic variant of a shift-reduce parser  working from left to right in the string and reducing whenever it can. the details of the algonthm are omitted from the following trace  and the interested reader is referred to pareschi and steedman  1   and haddock et al  1  for further discussion of parsing issues. 
	iv 	the rabbit in the hat 
     the table in  1  indicates the successive states of the system as it reads each of the five words in  1  and makes a combination with the previous constituent. 
　　　the first move in processing the phrase is to read the category of the initial determiner  np e j/ne l   and add its condition to the constraint satisfaction process  csp . this simply asserts that el is expected to have a single candidate  when the corresponding np is closed.  notice that the constraint is labelled with an asterisk in  1a   because it applies only at the time of syntactic closure.  the second word is now read  as defined in  1 . this places a condition of rabbitness on the variable e1  which at present is unconnected to el. the addition of rabbit c1  prompts the csp to search for suitable values for e1 in the context  and it finds three entities fitting the description: r l   r1 and r1. the two categories can now be combined  using composition. this cancels n   and n e 1   producing the category in  1b . a constraint of equality arises from the reduction  meaning that el and e1 are treated as alternative names for the same set. 
     the preposition  defined in  1   is now processed  introducing two new variables to the csp. satisfying the relation therc-

fore produces two new sets of candidates: one for all containing objects  e1  and one for all objects contained  e1 . the subsequent composition with the category in  1b  matches e1 with e1. this removes the first rabbit  rl  from the set for el  which equals e1  as rl is not contained in anything.  1c  records the current category and present state of the csp. notice that the second hat  h1  is not included in the set of candidates from which the inner np must later take its reference  because it does not contain r1 or r1. 
     the second determiner is read  with the category np 1/n 1. reducing the-rabbit-in with the does nothing to further renne the set of containing objects  but the system now expects this particular set to be a singleton when the phrase is complete. as  1d  indicates  the incremental evaluation of the rabbit in the has created two distinct sets of candidates  for the two nps in the phrase. the variables el  e1 and e1 all denote the set  r1 r1   holding possible referents for the complex np  while e1 and e1 specify {h1 b1  for the inner phrase. 
     the final noun introduces the category ne1   and adds the constraint hat e1  to the csp. the rule of application is used for the first time  closing the phrase  and producing the final category in  1e . identifying e1 with e1 eliminates the box  bl  and constrains each candidate for el  = e1 = e1  to be in the remaining hat  hi. so r1 goes out. we are left with two singleton sets  thus ensuring the success of the two checks for definiteness. the conditions unique e1  and unique el  are indeed enforced at this stage  because both the simple np  corresponding to e1  and the complex np  corresponding to el  have been closed by the application to hat. 
acknowledgements 
i wish to thank mark steedman and henry thompson for the supervision of this project. the work has also benefitted from the comments of: gerry altmann  einar jowsey  ewan klein  colin matheson  chris mellish  and remo pareschi. i am grateful to 
jo calder  robert dale  jon oberiander  and the two reviewers for reading and commenting on earlier versions of this paper. the work reported here was supported by serc research quota award 1. 
