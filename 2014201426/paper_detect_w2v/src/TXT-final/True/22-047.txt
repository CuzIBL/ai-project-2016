 
mrec is a new recursive best-first search algorithm which combines the good features of a* and ida*. it is closer in operation to ida*  and does not use an open list. in order to execute  all mrec needs is sufficient memory for its implicit stack. but it can also be fed at runtime a parameter m which tells it how much additional memory is available for use. in this extra memory  mrec stores as much as possible of the explicit graph. when m = 1  mrec is identical to ida*. but when m   1  it can make far fewer node expansions than ida*. this can be advantageous for problems where the time to expand a node is significant. extensive runs on a variety of search problems  involving search graphs that may or may not be trees  indicate that mrec with m = 1 is as good as ida* on problems such as the 1puzzle for which ida* is suitable  while mrec with large m is as fast as a* on problems for which node expansion time is not negligible. 
1 	introduction 
among best-first search algorithms  a* is the most widely used  because it is relatively simple to implement and executes quite fast on the average. but if runs short of memory when trying to solve random instances of the 
1-puzzle. ida*  korf  1   on the other hand  solves 1-puzzle problem instances with ease. it is also straightforward to implement  and unlike a*  uses very little memory. but it is not able to take advantage of any additional memory that may be available. in this paper we present a new recursive best-first search algorithm mrec that combines the good features of a* and ida*. it is closer in operation to ida* and does not use an open list. it runs on both trees and graphs  and takes care of loops in a simple and natural way. to solve a problem  all mrec needs is enough memory for its implicit stack. but mrec can also be fed at runtime a parameter m indicating how much extra memory it can use. when m = 1  mrec and ida* are essentially identical in operation. when m is large  mrec keeps the entire explicit search graph in memory in an effort to restrict the total number of node expansions. in fact  no node is expanded more than once by mrec when sufficient memory is available. this is advantageous for problems where node expansion is time consuming. at intermediate values of m  mrec keeps as much of the explicit search graph in memory as possible. in such cases  mrec may expand a node more than once. in computer experiments undertaken by us on a wide variety of search problems  mrec compares most favourably in running time with both a* and ida*. mrec has the additional advantage that it readily generalizes to and/or graphs  and is even able to accommodate directed cycles in such graphs  sen  1 . 
1 	how mrec operates 
mrec can be viewed as a generalization of ida*. the heart of the algorithm is a recursive procedure explore  which gets called upon at each iteration to explore the explicit search graph below the root node s. explore moves down a path in the explicit graph  making recursive calls to itself  until it encounters a tip node  i.e. a node which has no successors in the explicit graph. if sufficient memory is available  it expands the tip node n and adds the new nodes and edges to the explicit graph; otherwise  it peeps below n in the manner of ida*  performing what may be called a virtual expansion of n.  in this case  the successors of n and the corresponding edges do not get added to the explicit graph . as in ida*  a cutoff value is used for monitoring the downward movement. thus mrec has a very simple structure. for convenience of explanation we have broken up explore into two smaller procedures expand and update. each explored node n in the graph has an associated value b n  which gives the best estimate currently known of the minimum cost of a path from n to a goal node; b n  initially equals the heuristic estimate h n . the procedure expand expands a tip node and adds the newly generated nodes and edges to the explicit graph. the procedure update explores the graph below a node and updates the b-values of nodes. when memory is in short supply  it makes a virtual expansion of the tip node. in the algorithm below  we store the output solution path in outpath. the explicit search graph and its associated parameters are assumed to be accessible to all the procedures. 
	sen and bagchi 	1 

nodes remain tip nodes  but b-values of tip nodes increase as the exploration goes down deeper into the implicit search graph. when m is small  many nodes get expanded again and again  as in ida*. with increase of m  the total time spent on node expansions goes down  but some time is consumed in updating the explicit graph. 
example: for the network g shown in fig. i the node expansion sequence when m = 1 is 
which is the same as that for ida*. this assumes that successors are generated from left to right. with unlimited memory  the explicit graph at termination is shown in fig.1. when the available memory can accom-
note that if for a successor n  of n  we have b ni    b n  
- c nin    then ni gets explored. if  however  we have b n    b n  - c n ni  for every successor n1 of n  then b n  gets updated to min{b n   + c n n  |. when memory is available  the explicit graph grows in size with more nodes and arcs getting added to it. when memory is not available  the explicit graph does not change and tip 
1 	search 

modate two expanded nodes with their successors  the explicit graph at termination is shown in fig.1. solid lines indicate edges present in the explicit graph  while dotted lines indicate edges which have been explored but not saved in memory. nodes not saved in memory are marked by '*' 

we 	now 	enumerate 	some 	interesting 	properties 	of mrec: 
1. when m = 1  mrec expands nodes in the same sequence as ida*. for m   1  the node expansion sequences would not in general be identical. however  suppose we ignore reexpansions of a node  and only consider expansions of new nodes by the two algorithms. then the node expansion sequences would again be identical. 
1. the node expansion sequence of mrec  even with unlimited memory  may not conform to that of a*. in general  mrec and a* output different solution paths. 
1. mrec never expands a node more than once if sufficient memory is available for storing the explicit graph. when available memory is limited  mrec may expand a node repeatedly; but the total number of node expansions never exceeds the number made by ida*. 
1. when the heuristic estimate function is admissible  mrec finds a minimal cost solution path  just like a*. but the solution paths found by the two algorithms can be different. for inadmissible heuristics  even the costs of the output paths found by mrec and a* can be different. on the other hand  mrec and ida* always output the same solution path. 
1. the worst-case running time of mrec  like that for a* and ida*  can be exponential in the number of nodes in the search graph. 
1 	experimental results 
to compare the running times of mrec  a* and ida*  we ran the three algorithms on a variety of search problems. programs were written in pascal  and the 
	sen and bagchi 	1 

machine used was the vax 1. a large number of runs were taken for each of the following problems  and also for some other problems not shown here  sen  1 . the tables in this paper give a selection of the results that were obtained. care was taken to implement the algorithms as efficiently as possible. the open set of a* was implemented as a priority queue. for search graphs that are not trees  a hashing technique was employed to check for duplicate nodes. in the tables  mrec  m =   refers to the implementation of mrec assuming available memory is unlimited; it is then unnecessary to check in explore whether the memory bound has been exceeded. again  when m = 1  expand has no role to play since all expansions are virtual expansions; in this case  all references to expand can be eliminated from the code. 
a  1-puzzle and 1-puzzle : the goal node was fixed  and random  solvable initial configurations were generated. the search graph was represented as a tree. the manhattan distance function was used as the heuristic. this heuristic is known to be admissible and consistent. one hundred instances of the 1-puzzle were solved by a*  ida* and mrec  table 1 . the running time of mrec does not vary with change of m  so we arbitrarily chose m to be large. the table shows the running times  the number of nodes generated  and the number of nodes expanded  mean and standard deviation . for the 1-puzzle  1 randomly generated instances were solved using ida* and mrec  table 1 . for mrec  m is specified in terms of the number of nodes that can be stored in memory. as can be seen  there is very little variation in the running time of mrec as m is changed. the reason is that the time to expand a node and to calculate the heuristic estimates of successors is small; it is of the same order as the time taken to update the explicit graph and to retrieve stored values from it. 
b  travelling salesman problem  tspjt   little et al  1  : the well known method of little et al. for solving the travelling salesman problem employs a depthfirst branch-and-bound technique. the search graph is a tree. the method can be easily modified to make the search best-first instead of depth-first. for the 1-city problem  1 cost matrices were randomly generated. the matrices were asymmetric  and the costs did not necessarily satisfy the triangle inequality as can be seen 
table 1 : tspjt 
cities = 1 no. of rum = 1 time in mean cost = 1 algorithm seconds node gen node exp mean mean mean a* 1 1 1 mrec 	 m=¡Þ  1 1 1 1 	search 
from table 1  a* and mrec  m = ¡Þ  take almost the same time. since the expansion time of a node is appreciable  there is no point in running either ida*  or mrec with small values of m  on this problem. the original depth-first formulation of  little et al.  1  runs almost as fast as a* or mrec  m = ¡Þ   and needs very little memory; on those grounds it would seem to be the preferred method. 
c  rectangular cutting stock problem  crgkp   viswanathan and bagchi  1  : here we are given a single rectangular stock sheet s of length l and width w which must be cut  using guillotine cuts only  into n demanded rectangles of specified dimensions in such a way that total value is maximized and demand constraints on demanded rectangles are not violated. for given values of l  w and n  1 problems were randomly generated  and a* and mrec  m = ¡Þ  were run on them. the running times were almost the same for the two algorithms  since the node expansion time is very high  table 1 . the method of solution given in  viswanathan and bagchi  1  is such that depth-first methods become inapplicable  so ida*  or mrec with small values of m  cannot be run at all. 
table 1 : crgkp 
length = 1 	width = 1 	no. of rectangles = 1 
mean optimal value = 1 	no. of runs = 1 
time in algorithm 	seconds node gen node exp mean mean mean a* 	1 1 1 mrec  m=¡Þ  1 1 1 d  general d-ary tree : suppose we are given a uniform d-ary tree of unlimited depth with bi-directional edges of unit cost. there is a single goal node at a distance n from the root. the heuristic estimate of a node n is given by h n  = r.h* n   where h* n  is the actual length of the shortest path from n to a goal node  and r is a random number between 1 and 1. the problem is to find a minimal cost solution path using a best-first search method  assuming of course that n is not known to the method . for d = 1 and n = 1  1 problem instances were generated. the goal node position  at the specified depth  was randomly selected and h*-values were computed for all nodes; h-values were then generated using random values of r and tabulated in advance. these h-values were used in the search  and results are shown in table 1. here node expansion time is very small  but ida* tends to make too many expansions  and mrec  m = ¡Þ  appears to be the method of choice. 
e  travelling salesman problem  tsp g   pearl  1  
p.1  : the method of solution of the travelling salesman problem described in  pearl  1  p.1  generates a 

search graph that is not a tree. the method is not efficient  and large instances of the travelling salesman problem cannot be solved  but it was nevertheless selected for study since very few search problems generate search graphs that are not trees. in our implementation  we randomly generated the x and y coordinates of each city  and computed and stored the distance matrix for use by all the algorithms. for the problem illustrated in table 1  ida* is not shown because it took a very long time to execute. the heuristic estimate function being consistent  no node is expanded more than once by a*; moreover  node expansion time is appreciable. the running times of a* and mrec  m = ¡Þ  are almost the same  and the running time of mrec increases sharply as m decreases. this is particularly noticeable here because the search graph is not a tree. here  m can be viewed as the number of nontip nodes  along with their successor lists  that can be stored in the explicit graph. it is easy to express the total number of nodes in the explicit graph as a function of the number of nontip nodes and the branching factor  sen  1 . 
1 	concluding remarks 
our findings from the experimental study are summarized below: 
1. when m is very small  mrec runs like ida*  and is suitable for problems such as the 1-puzzle. when m is large  mrec runs as fast as a* on problems for which node expansion time is high. it is thus capable of serving the functions of both a* and ida*. 
1. mrec can take advantage of additional memory and improve its performance by reducing the total number of node expansions when more memory is available. 
¡¡¡¡in ending  we describe another memory constraint algorithm limmark  sen  1 . this non-recursive algorithm is derived from the marking algorithm marka  bagchi and mahanti  1   and uses the idea of arc marking. marking algorithms have the general advantage that they do not need to maintain large lists like open. but a disadvantage of marka is that it always requires the entire explicit graph to be stored; moreover  it fails to work if the network has loops. limmark was designed to get around these limitations. in practice  limmark was found to be much slower than ida* on the 1-puzzle and 1-puzzle problems although it made far fewer node expansions. but the main idea on which it is based appears to be worth consideration : deleting some  nonpromising  nodes and arcs from the explicit graph in order to accommodate newly generated nodes and arcs when memory is in short supply. this idea can 
	sen and bagchi 	1 

be tried out in certain problem domains. extension of the same idea to recursive implementations also appears to hold some promise. mrec  as it stands now  makes a virtual expansion of a tip node when memory is unavailable; it is unable to store the graph below the tip node in such a case. next time when it explores the same node  it is forced to reexpand the node. what could have been done instead is to remove some  nonpromising  nodes and successor arcs from the explicit graph and add the successor list of the newly expanded node to the graph. for example  we can remove nodes and arcs from the least recently explored path. this could  in principle  reduce the number of reexpansions of a node. the strategy will succeed provided we are able to find out nonpromising nodes and arcs easily; an improper choice can lead to oscillations  the algorithm throwing a node out of the explicit graph but entering it again soon after. for the 1-puzzie and 1puzzle problems  the manhattan distance function is the commonest heuristic. when such a weak heuristic function is used  all paths in the explicit graph tend to appear equally promising and the method cannot be suitably applied. the idea is nevertheless interesting and deserves further study. a modified version of procedure explore incorporating the above idea is given below. 
there is no need here of any virtual expansion of a tip node in update. 
procedure explore n:node;vor bnode:integer ; 
begin 
if n is a goal node then begin terminate := true; return; end; 
if n is a tip node then 
begin 
if sufficient memory not available for 
storing successors of n 
then remove nonpromising nodes and arcs 
from the explicit graph; 
expand n ; 
end; 
update n bnode ; 
end; 
¡¡¡¡a memory constraint algorithm of a somewhat different kind  called ma*  has recently been proposed by chakrabarti et al. . ma* is based on a*  and uses an open list. expansions are so controlled that successors get generated and added to open one at a time. nonpromising nodes get thrown out of open when the memory bound is exceeded. data on running time of ma* is unavailable  but as in the case of other pruning algorithms like limmark  the overheads are likely to be high. a comparative assessment of mrec and ma* has not been made yet. 
¡¡¡¡the algorithm mrec  m = ¡Þ  can be readily generalized to heuristic search in and/or graphs with loops  see the recursive algorithm rec a in  sen  1  . no existing marking algorithms for heuristic search in and/or graphs is able to take care of loops. moreover  all established algorithms for and/or graphs 
1 	search 
are non-recursive in nature. we expect algorithm rec a to run quite fast; its average performance is likely to be as good as  if not better than  that of existing marking algorithms for and/or graphs. it would be easy to reformulate rec  a to run under memory constraints. a detailed theoretical and empirical study of algorithm rec a is yet to be undertaken. an alternative memory constraint algorithm for and/or graphs can be found in  chakrabarti et al  1 . 
