 
we recently proposed a data structure  called associative-commutative discrimination nets  that supports efficient algorithms for  manyto-one  term matching in the presence of associative-commutative functions. in this paper we discuss the integration of such discrimination nets into an actual equational theorem prover and report on corresponding experiments. the general associativecommutative matching problem is known to be np-complete  but can be solved in polynomial time if the given terms are linear  i.e.  do not contain multiple occurrences of the same variable. we therefore have implemented a two-stage matching procedure. first we check whether a match exists for the linearized versions of the given terms  where different occurrences of the same variable are replaced by different new variables . if a match for the linearized terms does exist  we then determine whether there is also a match for the original  non-linear terms  i.e.  whether the proposed substitutions for different occurrences of the same variable are consistent . our experimental results indicate that this approach works very well in theorem proving  where most matching attempts actually fail and are filtered out during the first stage  so that the second  more expensive stage of the algorithm is only needed in comparatively few cases. 
1 	introduction 
matching and unification are two fundamental operations in theorem proving. unification is part of deductive inference rules such as resolution  whereas matching is needed for subsumption  normalization by rewriting  and other mechanisms for simplifying formulas and eliminating redundancies. experimental evidence indicates that the efficiency of resolution-type provers mainly depends on these simplification mechanisms. for instance  in rewrite-based equational theorem provers  most of the time  about 1 to 1%  is spent on term rewriting and normalization-operations that both require matching- 
1 	automated reasoning 
and relatively little on deducing new formulas via unification. in resolution-type theorem provers the deletion of subsumed clauses is critical for performance. in short  efficient implementations of matching are indispensable for such provers  cf.  mccune  1j. we should also point out that pattern matching algorithms are a key component in many other applications  including functional and logic programming  ramesh et a/.  1  and rule-based expert systems  forgy  1 . 
　it is becoming increasingly clear that many applications of theorem proving require efficient methods for reasoning about associative-commutative functions. in this paper we discuss our work on extending the equational theorem prover reveal by efficient algorithms for matching in the presence of associative-commutative function symbols. 
1 	preliminaries 
we consider terms built from function symbols and variables. the letters s and t are used to denote terms  / and g to denote function symbols  and x  y  and z to denote variables. the expression  denotes the subterm off at position p. positions may  for instance  be represented in dewey decimal notation. the top-most position is denoted by and hence the sequences 1 and 1 denote positions in   with = 
and 
　let ac be a set of associativity and commutativity axioms 
for some function symbols /. we also write if / is such an associative-commutative symbol and write s =ac t to indicate that s and t are equivalent under associativity and commutativity. a term t is said to acmatch another term s  and s is called an ac-instance of t  if there exists a substitution   such that 
it is convenient to represent terms equivalent under 
ac by flattened terms. let l be the set of all rewrite rules  called flattening rules  



	bachmair  et al 	1 

1 	automated reasoning 

1 implementation of ac-matching 
the -ac-matching problem is an np-complete problem  but can be solved in polynomial time if pattern terms are linear  benanav et a/.  1 . we have therefore designed ac-matching as a two-phase process. in the first phase  an ac-discrimination net for the linearized versions of patterns is used as a filter: if no ac-match exists for the linearized patterns  then there certainly exists none for the original patterns. if in the first phase some terms are identified as ac-matches  we need to check in a second phase whether any of these matching terms can be extended to ac-matches in the presence of non-linearity. a straightforward ac-matching algorithm is used in this second phase. our experimental results provide strong evidence that in typical theorem proving problems most of the patterns can be eliminated during the first phase  so that the expensive second phase is invoked only sparingly and the two-phase approach results in substantial performance gains. 
1 term representation 
we adopt a variant of the data structure for flat terms used in hiper  see  christian  1  for details. flattened versions of terms equivalent under ac are unique only up to permutation congruence. for instance  the two terms / a  b  c  and / c  a  b  are ac-equivalent if 
. we define a unique representative for each acequivalence class by using a total ordering on function symbols and variables and lexicographically extending it to a total ordering on terms. the minimal term in an equivalence class serves as the unique representative. 
for example  if 	then 
1 standard discrimination nets 
let us next discuss the design and implementation of discrimination nets. we first consider standard discrimination nets  which provide the basis for ac-discrimination nets. in theorem proving  the set of  pattern  terms that need to be represented in a discrimination net change dynamically. we have chosen a non-deterministic variant of such nets in which insertion and deletion of patterns can be performed easily.  the main difference between deterministic and non-deterministic nets is that the latter require backtracking in order to identify all matches. deterministic nets require no backtracking  but may use more space.  
　pattern terms are stored at the root of the net. each leaf maintains a list of pointers to the patterns in the matchset associated with the leaf node. with each node we maintain a linked-list representing the  labelled  edges from that node. this list is kept sorted  according to the edge labels   so that the traversal of the net can be implemented by a linear search through this list. example 1 figure 1 shows the discrimination net for the set {f x  a  1   / b  a  a   / x  a  y }  where the underlying ordering on symbols is x y a b f. 
　this variant of discrimination nets essentially corresponds to the third variant described in  mccune  1 . in contrast to hiper and also our earlier description of discrimination nets in  bachmair et al.  1   we distinguish between different  non-ac  variables. although 

such a distinction may potentially result in more backtracking and consume more memory  it has the advantage that checking for the consistency of substitutions for  non-ac  variables can be done during traversal of the net  so that failures caused by inconsistencies can be discovered earlier. to allow for consistency checking we maintain a global substitution table and  whenever descending to a branch corresponding to a  non-ac  variable x  compare the entry for x  if present  in the substitution table with the current subterm of the input term. 
1 	ac-discrimination nets 
recall that ac-nets require additional operations such as bipartite matching using secondary automata  intersection of matchsets produced by ac-subnets and reporting the result from one level of the net to the next higher level. we first describe data structures that are needed for these operations. with each ac-node v we associate a set  of ac-subterms. these subterms are stored in a linked list; each element in the list is called a control block and corresponds to one ac-subterm. in the 
control block for a term  we maintain information relevant to bipartite matching and secondary automata transitions. when a pattern term is deleted  all control blocks corresponding to its ac-subterms must also be deleted. to facilitate deletion  each pattern is assigned an unique id number and all control blocks derived from the pattern inherit this id  which is then used as a search key during deletion. the search is implemented as a simple linear search in the linked list associated with lv. 
　for each pattern  there is a pointer from the control block of each ac-subterm t at ac-nesting depth / to the control block of an ac-superterm1 of t at ac-nesting depth / - 1. similarly  if a term t is in the matchset of a leaf  there is a pointer from the leaf to the control block of the closest ac-subterm enclosing this t. 
example 1 suppose k a c  f y c   and k a c  f a b    
	are two patterns. 	we have l1 - 
{/ y  c  / a b } represented by the list of control blocks c and d. the enclosing ac-subterm of / y  c  and 
   1  an ac-superterm of t is a super term of t with acfunction symbol at its root. 
	bachmair  etal 	1 

1 	putting it all together 
we are now ready to explain the operation of an indiscrimination net based upon the above representation. at each ac-node  we do the following steps. we check whether  i  the number of arguments in the pattern exceeds those in the subject; or  ii  if the pattern has no variable arguments and has fewer non-variable argument than the subject. in such cases  the pattern is marked unmatchable and no further action is done on behalf of it. for patterns which pass the above test  secondary automata are used to determine the existence of a maximum bipartite matching for the corresponding bipartite graph. secondary automata are used for small bipartite graphs  deriving from pattern terms with few nonvariable ac-arguments . if the number of non-variable arguments is large  we use a general bipartite matching algorithm  papadimitriou and steiglitz  1 . in the experiments reported below  we never had to resort to a general bipartite matching algorithm. 
　on successful completion of the above steps  we include the ac-subterm in the matchset for the ac-node. this matchset is intersected with those computed at other ac-nodes at the same level of the net. we use stickel's algorithm  mccune  1  to do list intersection. specifically  suppose l1  l1 and l1 are three lists. 
1 	automated reasoning 

we first mark the elements of l1 with 1. then those elements of l1 that are marked with 1 are marked with 1. finally  elements of l1 that are marked with 1 are the results of l1 n l1 n l1. since an intersection has to be done at each ac-node  we can use the number of ac-nodes visited for each level as the current value of the mark. finally  when a leaf node r is reached  the matchset mr associated with r is also intersected with the outcome of earlier intersections at this level. 
example 1 with the ac-discrimination net in figure 1  suppose the subject is k f a  c  c / a  1   and we have just entered node 1. upon processing / a  c  through the subnet at node 1  only b is marked with 1  since f a x  of the second pattern is matched  but not f a b  of the first pattern. then  although both terms / a  b  and / a  b  in l1 are in the matchset computed at node 1  only b gets marked with 1 because it is marked currently with 1. therefore  the second pattern is selected by the net. 
1 experimental results 
we next present experimental results we obtained with our implementation on a sparc 1 with 1 mb of memory. we first compare ac-discrimination nets with straightforward ac-matching  and then show the effect of the resulting savings in the context of a theorem prover. finally  we show that the use of acdiscrimination nets does no compromise on the performance of a theorem prover on problems without associativity and commutativity. 
1 ac-matching 
the first data set provides an indication of the effectiveness of ac-discrimination nets. we took a set of 1 terms from a typical theorem proving application in otter  mccune  1   and built an ac-net for it. then each one of these terms is used as a subject  resulting in a successful ac-match  of course . the resulting times are compared with a straightforward acmatching algorithm that uses no discrimination net. we ran the algorithms in two different modes:  i  to identify the first matching term  and then stop   or  ii  to find all matching terms. we also repeated these tests for a smaller subset of 1 terms.1 the results are summarized in table 1. it can be seen that ac-discrimination nets result in a three- to four-fold speedup for finding the first matching term  which is the variant needed for rewriting . all times are in seconds. 
1 ac-completion 
we then ran a number of experiments with our equational theorem prover reveal. all problems contained associative-commutative function symbols. they include the following: 
1. grobner: the grobner base of a certain ideal in a polynomial ring in two variables over integers is computed via completion; 
　1 we should note that the terms in the original otterexamples do not contain ac-symbols; but we declared one of the  binary  symbols to be ac. 

1. grpfini1: a canonical rewrite system is computed for an abelian group of order 1  specified with three generators; 
1. jacobson: commutativity is proved for rings satisfying x* = x ; 
1. moufang: the sesquilinearity of the associator is proved for  non-associative  alternative rings; 
1. robbinh : it is proved that any robbins algebra is a huntington algebra  and hence a boolean algebra  if there exists an element c  such that c + c = c ; 
1. robbinh1 : similar to robbinh  but under the assumption that there exist elements c  d such that c -f d - c ; 
1. uqsl1 : certain properties of some 'unitary quantum groups' are proved 
　table 1 summarizes timings for these and several other ac-problems. we compare the performance of the prover with ac-discrimination nets  under columns 'acn' in the table  with a more naive strategy 'nat without ac-nets. one of the key components of our prover is the normalization of terms by rewriting  which requires  ac- matching. given a set t of rewrite rules and a term s to be normalized  the prover takes one rule from t and tries to match it at the root of s. in case of failure  the next rule in t is tried  and so on  until either a match is found or else all rules in t are exhausted. in the latter case  the process is restarted at the next position of s. we measured  a  the time to normalize terms with respect to the current rewrite system and  b  the total time leading to proofs. the speedups are given for both the normalization and for total computing times. the speedups for normalization  naturally  are significantly greater than those for total times. 
　since the prover needs to find only one matching pattern  from table 1 we may expect an average speedup of about 1 for finding the first matching pattern. since in normalization about half the time is spent in finding a match  we can expect to improve normalization by a factor of 1 on the average. this is consistent with the speedup figures for normalization in table 1. finally  about 1% of the total computing time is spent in normalization and the rest on other operations  such as unification  for deduction of so-called critical pairs   etc. so we can expect a speedup of about 1% on the 
	bachmair  et al 	1 

many-to-one ac-matching in two phases. in the first phase only those patterns are selected that ac-match under the assumption that all  ac  variables are different  i.e.  linear . the consistency of the substitutions computed for  ac  variables are checked in the second phase. the experimental results show that a high percentage of patterns are filtered out in the first phase  leaving very few patterns for the more complex consistency checking in the second phase. for instance  for our benchmark problem uqsl1  no more than one pattern was selected by the ac-discrimination in 1% of the cases  no pattern was selected in 1% and one pattern in 1% of the cases . we also ran experiments with different search strategies and obtained similar results. in particular  we want to mention that on robbhin1 we were able bring down the total time from 1 minutes to 1 minutes using ac-discrimination nets. all these* 

average for completion. this is again consistent with the speedups in table 1 we obtained for our examples. 
　finally  we like to mention that memory consumption of the ac-discrimination nets for the problems in table 1 never exceeded the memory required for storing the patterns  i.e.  the extra memory needed at most doubled. 
1 	non-ac problems 
as mentioned earlier  standard discrimination nets have been used quite successfully to solve many-to-one nonac-matching problems. it is critical that the performance of our ac-matching algorithm do not degrade when used for non-ac problems. table 1 shows that this has been accomplished in our implementation. all the problems in there are non-ac the second column are the timings obtained by standard discrimination net while the third column pertains to acdiscrimination nets. observe that the overhead of using ac-discrimination net for non-ac problems is negligible. 

1 	summary 
in this paper  we have presented the design  implementation and experimental results of an ac-discrimination net based ac-matching algorithm. this algorithm has been integrated into the equational theorem prover reveal  which we used for our experiments. our implementation exploits the fact that although ac-matching is ivp-complete  it can be solved in polynomial time if patterns are restricted to linear terms. it solves the 
1 	automated reasoning 
results and the speedups we obtained provide strong evidence that ac-discrimination nets and secondary automata are indeed useful tools for significantly improving the performance of theorem provers for ac problems. 
acknowledgements. we would like to thank the anonymous reviewers for their helpful comments. this research was supported in part by the nsf under grants cda-1  int-1 and ccr-1. 
