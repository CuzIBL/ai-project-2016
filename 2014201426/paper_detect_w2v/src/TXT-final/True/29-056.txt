 
a new generation of reactive  model-based executives are emerging that make extensive use of componentbased declarative models to analyze anomalous situations and generate novel sequences for the internal control of complex autonomous systems. burton  a generative  model-based planner offers a core element that bridges the gap between current and target states within the reactive loop. burton is a sound  complete  reactive planner that generates a single control action of a valid plan in average case constant time  and compensates for anomalies at every step. burton will not generate irreversible  potentially damaging sequences  except to effect repairs. we present model compilation  causal analysis  and online policy construction methods that are key to burton's performance. 
   conventional wisdom has largely pushed deductive reasoning out of the reactive control loop for nearly a decade. however  recent search for the surprisingly elusive  hard satisfiability problem foretells a healthy return to deductive methods  williams & nayak 1b; kautz & selman 1  based on risc-like search engines. this paper pushes this perspective down to reactive time scales  reporting on a model-based planner  called burton  that is at the core of a modelbased executive's reactive control loop. by solving the np hard component of deductive problems at compile time  burton exploits the expressiveness of np hard methods  without assuming the risk of falling off the elusive cliff. 
　burton's parent model-based executive is particularly well suited to controlling the complex internal behaviors of large scale autonomous systems  we call immobile robots  williams & nayak 1a . what distin-
guishes this executive is its ability to sense and control hidden state variables indirectly  and the use of component models to identify these novel interaction paths. a marriage between this model-based executive and a classical  method-based executive provides a hybrid with an expressive scripting language and an extensive capability to generate novel responses to anomalous 
1 	planning and scheduling 
model-based executive 
p. pandurang nayak 
recom technologies 
nasa ames research center  ms 1 
moffett field  ca 1 usa 
e-mail: nayakflptolemy. arc. nasa. gov 
situations. significant parts of this hybrid executive will be demonstrated in late 1 on nasa's deep space one autonomous spacecraft  pell et al. 1 . 
　the paper begins with an example from the spacecraft domain  and then introduces our concurrent transition system modeling formalism. next we introduce model-based execution as identifying a current state  mode identification   generating an optimal target state  mode reconfiguration   and generating a control action to move towards the target  model-based reactive planning . the rest of the paper presents the burton model-based reactive planner through a series of domain restrictions  model compilation  policy construction and online planning algorithms. 
example: autonomous spacecraft 
first consider the underlying task. figure 1 shows an idealized schematic of the main engine subsystem of the cassini spacecraft and valve driver circuitry. it consists of a helium tank  two propellant tanks  two main engines  regulators  latch valves  and pyro valves. the helium tank pressurizes the propellant tanks. when propellant paths to a main engine are open  the propellants flow into the engine and produce thrust. the pyro valves are used to isolate parts of the engine. they can open or close only once. 
　valves are controlled by valve drivers. commands to the driver are sent via a control unit  vdecu . the driver and vdecu can be on or off  and recoverably or permanently failed. a recoverably failed component can be repaired by resetting it. a valve's state changes as a result of a command only if the corresponding driver and vdecu are on and healthy. 
　in planning an orbit insertion maneuver  a high-level deliberative planner  e.g.   muscettola 1   generates a sequence of behavior goals  such as producing thrust. the reactive executive achieves this goal using its component models to generate control sequences that open the relevant set of valves leading to a main engine. valves are commanded open indirectly  and the 


	williams & nayak 	1 

　a model-based executive  uses a specification of a transition system to determine the desired control sequence in three stages-mode identification  mi   mode reconfiguration  mr  and model-based reactive planning  mrp . mi and mr set up the planning problem  identifying initial and target states  while mrp reactively generates a plan solution. more specifically  mi incrementally generates the set of most likely plant trajectories consistent with the plant transition model and the sequence of observations and control actions. this is maintained as a set of most likely current states. 
mr uses a plant transition model and the most likely current state generated by mi to determine a reachable target state that satisfies the goal configuration. mrp then generates the first action in a control sequence for moving from the most likely current state to the target state. after that action is performed mi confirms that the intended next state is achieved. mi and mr are discussed in  williams & nayak 1b . this paper focuses on mrp. 
1 	planning and scheduling 
　given the similarity of transitions and strips operators  burton's problem appears similar to strips planning  weld 1 . however  the critical difference is the distinction between classical planning and machine control. the primitive control action in a strips plan is to invoke a plan operator  which directly modifies the state. model-based planners  on the other hand  exert control by establishing values for control variables  which interact with internal state 
     1  while repairing a failure is irreversible  it is important to allow a reactive executive to repair failures. 


	williams & nayak 	1 

an initial state assignment 1 and a set of goal assignments y1 burton meets five desiderata. first  it only generates non-destructive actions  i.e.  an action will never undo the effects of previous actions that are still needed to achieve top-level goals. second  burton will not propose actions that lead to deadend plans  i.e.  it will not propose an action to achieve a subgoal when one of the sibling subgoals is unachievable. third  burton is complete  i.e.  if a planning problem that satisfies requirements 1 is solvable  then burton will generate a plan. however  burton is not guaranteed to generate all valid plans. fourth  burton ensures progress to a goal  except when execution anomalies interfere  i.e.  the nominal trajectory traversed by burton for a 
fixed target is loop free. fifth  burton operates at reactive time scales-its average runtime complexity is 
constant. this speed is essential to providing a modelbased executive with response times comparable to traditional executives  firby 1; simmons 1 . 
　burton avoids runtime search  requires no algorithms for threat detection  and expends no effort determining future actions or planning for subgoals that are not supported by the first action. traditional planners need such mechanisms to avoid destructive actions and deadend plans  weld 1 . burton accomplishes this speedup by exploiting the requirement  stated earlier  that all actions except repairs be reversible  and by exploiting certain topological properties of component connectivity that frequently occur in designed systems. the development of burton's basic sequencing algorithm is the topic of the next three subsections  with the introduction of repair actions introduced in the fourth subsection. finally  to achieve average case constant time burton precompiles plans into reactive policies  without requiring enormous amounts of storage. this is the topic of the fifth subsection. 
exploiting causality 
a major leverage point comes from exploiting the topological properties of component connectivity. the input/output connections of the compiled plant frequently do not contain feedback loops. when they do occur they are typically local and can easily be eliminated through careful modeling. to be precise: 
definition 1 a causal graph g for  compiled  transition system 1 is a directed graph whose vertices are the state variables of s. g contains an edge from v1 to v1 if vl occurs in the antecedent of one of v1's transitions. requirement 1 the causal graph must be acyclic. 
　　here on  each goal is a target variable assignment generated by mr  not the configuration goal input to mr. 
1 	planning and scheduling 

　line 1 tests whether or not a conjunction of top-level goals can be achieved  as explained in the subsection after next. this involves a simple table lookup to see if each goal is labeled reversible. burton only introduces subgoals that can be achieved  hence the test is needed at the top level only. line 1 works upstream along the causal graph of variables selecting the next unsatisfied  sub goal assignment to be achieved. this upstream progression is achieved by exploiting a topological ordering  as explained in the next subsection. 

line 1 takes the first step towards achieving the selected goal. given an initial assignment y = e  and a component transition system for y  a goal assignment y = ef is achieved by traversing a path along transitions of y from ei to ef. respecting restriction 1  burton only traverses transitions with reversible effects or that perform a repair. as explained in the next section  the transitions that satisfy this restriction are those labeled allowed. line 1 identifies the first transition along this path from ei to ef. line 1 subgoals on the state conditions of this first transition  which results in burton moving further upstream. if one or more state conditions is unsatisfied then a next control action is computed in line 1  and returned. if all state conditions are satisfied  then the transition is ready to be traversed and line 1 returns the transition's control conditions as the next control action. 
a v o i d i n g d e s t r u c t i v e actions 
burton avoids generating destructive control actions 
 desiderata 1  by exploiting the acyclic nature of the causal graph. the only variables needed to achieve an assignment y = e are y's ancestors in the graph. for example  turning on the driver requires use of the 
vdecu but not the valve. in addition  requirements 
1 and 1 guarantee that invoking transitions for y and its ancestors  when performed one at a time  will not affect any other state variables. 
　this suggests that burton can achieve a conjunction of goal assignments in an order that moves along the causal graph from descendants to ancestors  i.e.  a goal conjunct is achieved only after conjuncts that are its descendants. for example  open is achieved by working on = open then dr  - off. the same ordering holds for conjunctive subgoals  that is  state conditions of required transitions. 
　destructive subgoal interaction may occur when a variable appears upstream as a subgoal to two con-
juncts. to avoid this danger subgoals are achieved in 
depth first order  achieving one conjunct before starting on a second. for example  is achieved by turning on the driver  opening the valve  and finally turning the driver off. achieving subgoals in depth first order also ensures that burton always makes progress towards the goal  desiderata 1 . 
　depth first goal progression  together with the goal ordering constraint  is sufficient to ensure nondestructive actions. depth first progression is imposed by line 1 of nextaction. line 1 imposes the ordering constraint without runtime cost through topological numbering. at compile time each state variable is given a topological number  tn   by performing a depth first search of the graph and numbering variables on topological numbering imposes a total ordering that satisfies the constraint  whenever a is a strict descendant of b in the causal graph. hence the proper order of goal achievement for all conjunctive subgoals is determined at compile time by sorting the conditions of each transition by increasing topological number. burton respects an upstream progression in line 1  simply by working successively through the sorted list of conditions. 
a v o i d i n g deadends t h r o u g h reversibility 
requirement 1 stated that burton only perform reversible transitions  desiderata 1 stated that burton avoid deadend plans  that is plans with unachievable subgoals  and desiderata 1 specified completeness. to be reactive burton must achieve these without search. each hinges on the following lemma: 
lemma 1  is reachable from  by reversible transitions exactly when a and b are separately reachable from  by reversible transitions. 
proof: assume without loss of generality that tn b . we previously showed that if a is achieved first  it won't be disturbed while achieving b. the transitions used to achieve a are reversible  hence if nothing else each variable other than a can be restored to its 
value in 1 and then b can be achieved. ＆ 
　suppose burton has labeled as reversible every assignment that is reachable from initial state 1 using reversible transitions. by lemma 1 a conjunction of goal assignments is achievable exactly when each conjunct is marked reversible. hence burton can determine plan achievement at runtime simply by using one table lookup per top-level goal  line 1  next action . 
　deadend plans  hence search  are eliminated by removing the possibility of unachievable subgoals. assume burton labels a transition allowed only if its state conditions are each labeled reversible. then sequences of allowed transitions between reversible assignments contain no unachievable subgoals. these are the transitions generated by line 1 of next act ion. by lemma 1 all other sequences lead to deadends or involve irreversible transitions  hence burton generates some plan if one exists  desiderata 1 . of course burton can't generate all plans since subgoal interleaving isn't allowed. finally  since depth first progression generates the control sequence in order  burton generates the first control action without wasting work on the rest of the plan  hence achieving reactivity. 
　the labeling of assignments and transitions is precomputed for compiled transition system s' with initial state  by labelsystem  and is linear in the size of s'. 
	williams & nayak 	1 


　labelsystem starts at the roots of the causal graph  using topological numbering to move to a descendant only after its ancestors have been processed. line 1 simply executes the definition of allowed. note when l/i is a root  none of its transitions contain state conditions  and hence are trivially allowed. lines 1 and 1 identify reversible assignments. an assignment y = e* can be reversibly achieved if there exists a path along allowed transitions from initial value ei to ek and back. equivalently  the set of y's reversible assignments is the strongly connected component  scc  of y's allowed transition that contains ei. 
　for example  starting with initial value off  the scc for the vdecu  hence its reversible assignment set  is {off  on}  with both resettable and failed excluded. next  the driver has allowed transitions between on and off due to the vdecu's scc. with initial value on  the scc for the driver is {off on}. 
finally  note that labelsystem is called infrequently. 
actions generated by burton only move within the sccs of reversible assignments  leaving the labeling unchanged. a relabeling is needed only if an exogenous action or failure moves to an assignment that was not labeled reversible. 
failure states and repair 
to dramatically expand burton's utility we incorporate repair actions. the occurrence of failures are outside burton's control  since there are no nominal transitions that lead to failure. hence a repair sequence is irreversible  albeit essential  and thus not covered by the development thus far. we extend burton to permit repair sequences if they minimize irreversible effects. burton never uses a failure to achieve a goal assignment if the failure is repairable. however  if it is not repairable  then burton is allowed to exploit the component's faulty state. for example  suppose a switch is needed to be open  and it is permanently stuck open. since stuck-open is irrepairable but has the desired effect  burton exploits the failure mode. 
　relaxing the reversibility constraint  if a state variable y is assigned a failure ef  then burton is permitted to traverse a sequence of allowed transitions from ef 
1 	planning and scheduling 
to a nominal assignment  when such a path exists. if only one path exists  then y's reversible assignments are defined to be those in the scc of the first nominal assignment reached along the path. for example if the driver is initially at resettable then it may transition to on using reset  and the scc is {off  on}. if no path exists to a nominal assignment  then the reversible assignments are those in the scc that contains ef. for example  if the driver is at failed  then the scc is simply {failed}. although not discussed here  burton also handles the case where multiple paths to different sccs exist. 
　although burton can now traverse irreversible transitions to effect repair  none of the assignments along this trajectory  up to the selected scc can be used to satisfy a state condition or goal assignment. hence this extension does not endanger burton's previously discussed properties. 



　burton's feasible policies are analogous to optimal policies in control theory. an important difference is that burton constructs a set of concurrent policies  rather than a single policy for the complete state space. the latter grows exponential in the number of state variables  and is infeasible for models like the spacecraft  which contain over 1 state variables and well over 1 states. in contrast  the concurrent policies grow only linearly in the number of state variables. 
　for a fixed target and no intervening failures  burton generates successive control actions as a depth first traversal through the policy tables. this traversal maps out a subgoal tree  and burton maintains an index into this tree during successive calls. to generate a sequence burton traverses each tree edge exactly twice and generates one control action per vertex. since the number of edges in a tree is bounded by the number of vertices  the amortized average case complexity of generating each control action is a constant. desiderata 1  reactivity  is achieved. 
related work and conclusions 
burton combines causal models used in model-based reasoning with state transitions used in planning. other researchers have combined model-based diagnosis with planning  primarily to generate repair plans  priedrich k nejdl 1; sun k weld 1 . the main difference is that these systems include a strips  rather than model-based  planning component with utility-theoretic measures for selecting amongst alternate plans. their computational complexity make them inapplicable for on-board reactive execution. 
burton differs from traditional strips planners 
 weld 1  in that plan operators  transitions  are generated by a compilation process from an underlying causal model of the system that includes both within and across state constraints  respectively . furthermore  the compiled transition system is a specialized version of the general planning problem that burton solves by a worst-case linear time  average case constant time algorithm. in contrast  general planning is pspace-complete. korf  1  defines a set of subgoals to be serializable if they can be solved in order without ever violating a subgoal solved earlier in the order. the requirement that the causal graph is acyclic ensures that burton is only presented serializable sets of subgoals. 
　finally  traditional reactive executives  firby 1; simmons 1  differ from burton's model-based executive in that the former use explicitly scripted procedures to provide reactive execution  while the latter uses deductive reasoning from a causal model that combines an off-line compilation phase with an on-line policy generation phase. other differences include the fact that traditional executives provide a richer set of control structures such as parallel execution  while burton's executive provides a more sophisticated diagnosis and monitoring capability embodied in mi. 
　in summary  burton is a sound and complete generative planner that uses expressive transition system models to provide the reactive sequencing capability of a model-based executive. it exploits off-line model compilation and the topological properties of component connectivity to incrementally generate control actions in average case constant time. these control actions are guaranteed to be non-destructive  while ensuring progress towards the goal and avoiding deadend plans. 
acknowledgements: we would like to thank jim kurien and dan weld for helpful comments on the paper. 
