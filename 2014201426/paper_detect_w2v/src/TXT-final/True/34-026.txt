 the knowledge of utopia u1 has become in the course of abstractly planning backwards. now it seems possible that w1 might be r. so create a new hypothesis h. 
1 


1 

 predicate logic as programming languagal the deficiencies of the predicate calculus as a programming language are traced back to the tmtli-tlieoretic  tarski 1  semantics of logic. the nub of  he difficulty seems  o be the way in which meaning is defined  in that axioms may convey truth but not pragmatic information we explain how the behavioral semantics alleviate some of the difficulties with truth-theoretic semantics. this work is presented using r o t o r s   a semantic concept in which no active process is ever allowed to treat anything as an object; instead a polite request must be extended to accomplish what is desired. 
necessity of a. unified formalism 
　　　for some years now we have been working to achieve the goal of a unified formalism and semantics for knowledge based systems. the record of our progress is published in the proceedings of the international joint conferences on artificial 
intelligence beginning with the first conference in 1. in the course of this research we have developed the thesis of procedural embedding of knowledge the useful knowledge off a domain is intrinsically bound up with the specialized procedures for its use. an important corollary is that the fundamental technique for the representation of knowledge is 
procedural knowledge base construction 
        more specifically: i uill argue that computation is best regarded as a proem* of controlled deduction. it will he further argued that the two otpeett specifying the control mechaninm  of programming are heat tcftftraird expliciritly  as the kindt of language involved have quite dittinct $emanticm.  
pal hayes:  computation and deduction  
　　　a satisfactory theory for the representation of knowledge should have one unified totally integrated formalism and semantics. for example we should not have one formalism and semantics for expressing declaratives and a separate  as proposed by hayes  formalism and semantics for expressing procedures. having two formalisms  with different semantics  erects an arbitrary pernicious barrier between two ends of a useful continuum. one technique which shows great promise toward automating the development of procedural knowledge base acquisition is that of progressive refinement of plans  dljkstra  wirth 1; cheatham and wegbreit 1; hewitt 1  1} this technique involves the transition from very high-level goal-oriented procedures to more particular efficient implementations for special circumstances. as such it spans the spectrum from relatively domain-independent goal-oriented 
 declarative   	modes 	of 	computation 	to 	particular efficient 
 procedural  modes the facility with which progressive refinement of plans can be automated depends on having one formalism and semantics to span the above spectrum 

　　　the definition of t r u t h as formalized by tarskl for the quantificational calculus is one of the crowning achievements of mathematical logic it has clarified the semantics of ordinary mathematical theorems and led to the development of truth-theoretic model theory which is a flourishing mathematical field in its own right we contend that it is less satisfactory as a semantic base for a theory of action and change tarskian semantics characterizes predicate logic in the following sense: goclel proved that for the first order quantificational calculus that the class of sentences deducible by the classical laws of logic is exactly the same as the ones which are true by tarskl's definition the notion of truth formalized by tarski is very smooth but we contend that it glosses over semantic distinctions that are crucial to the development of knowledge-based systems 
　　　the deductions of plans in a planner-like formalism have the potential to carry more conviction  in the sense of richard weyhrauch and other logicians  than proofs in the classical predicate logic  for example a proof of a formula of the form    imptice ψ  carries conviction if it demonstrates a  causal  connection from   to ψ.  this is because our minds are better at grasping constructive relationships between plans than global relationships established by asserting that a class of axioms is true or consistent two plans can affect each other only if there is a behavioral causal connection of  wheels and. cogs . we seem to be able to design  control and debug plans better than axioms 
　　　in the rcal world no formal principle is universally literally true any rule can be stretched beyond its range of applicability to produce contradictions except in mathematics all useful principles are hemmed in with qualifications  hedges  and caveats knowledge is better expressed procedurally in the form of tough minded skeptical plans that actively attempt to guard against their misuse the business of actively searching out hidden anomalous situations is as important as the business of making deductions that carry conviction indeed  much of the conviction carried by a set of plans is dependent on their ability to withstand repeated  meticulous  rigorous attempts at refutation from as many directions of attack as can be conceived no principles  including the classical laws of logic  are sacred against criticism when anomalies are detected. 
　　　no satisfactory method for testing the consistency of non-trivial sets of axioms in the quantificational calculus has been developed for example inconsistent formulations of the  blind hand problem   a particular toy robot problem  have been produced in the quantificational calculus their inconsistency has been discoveted almost by accident as proofs by contradiction get shorter and shorter until the negation of the desired consequence is found to be superfluous to the proof! people are quite tolerant of minor inconsistencies the inability of the quantificational calculus to tolerate any inconsistency at all in formulating problems is a sign of excessive semantic rigidity an example of the kind of problem engendered by this rigidity when dealing with common sense knowledge is given below. in general we feel that a contradiction is evidence for a bug in one's plans or world model and that to satisfactorily resolve the bug  it may be necessary to examine al  the assumptions being made instead of oniy tne most recent one. currently mere are no guuu ways to debug classes of axioms  whereas there is a well established and rapidly developing technology for debugging procedures  miniky and papert 1  sussman 1; goldstein 1; hewitt and smith 1 . 

1 

       we agree with the above comment of hayes  except that we have a different notion of semantics for the language of the predicate calculus  the way in which the rulrs of natural deduction follow from the procedural mechanisms of plasma  demonstrates how deduction can usefully be considered to be a special case of computation. furthermore  by implementing the useful part of the behavior of the quantificational calculus in plasma  we will obtain a behavioral semantics of the quantificational calculus from the underlying actor semantics of plasma consider a formula of the form  which means that for every x we have that  the case the procedural meaning of the formula consists of plans for how it can be used. the plans we are attempting to develop for v and the other logical operators are reminiscent of natural deduction except that we have four introduction and elimination rules  demorwtrate  refute  assort  and deny  to give us more flexibility in dealing with negation.  example is the following plan: 
　　　the gigo plan graphically illustrates a fundamental problem with the truth-theoretic semantics for the predicate calculus the presence of the gigo rule in the quantificational calculus casts a shadow of doubt on the reliability of all of the computations of the system. for example the following set of assertions  mcdermott 1  is not consistent however. a problem solving system should not be able to conclude that 1 ＊ 1 from the inconsistencyl 

a more reasonable conclusion is that fred might be an 

ostrich or a penguin. we feel that this problem of inconsistency is ripe for further research along the lines of mcdermou  1 sussman   goldstein  1  kuipers  rubin  1 smith and hewitt  1 erman and lesser  1 and mclennan 
. 
our intent in attempting to formulate plans like the above is to try to characterize the useful behavior of 
we do not intend for them to be used as the code to define a general uniform proof procedure. instead they are intended to be used as template schemata in progressive refinement to construct 
more specialized domain dependent plans. the classical rules of logic are intended to generate all the true sentences from a given class of true sentences. our behavioral definitions are intended 
to define the justifiable behavior of the logical operators that however  it is easy to generate gigo using classical-negation and carries conviction. indirect proof. we are working to develop a more limited form of indirect proof in which the contradiction mutt depend in an essential way on the hypothesis being refuted. the behavioral semantics of depending-on needs to be carefully worked out to produce a deduction system that more nearly captures the logicians' notion of conviction as discussed above. again a key technique for attacking the problem is to explicitly record for every assertion the rules and hypotheses used in its derivations 
further work 
　　　the plasma system described in this paper is currently being implemented at the mit artificial intelligence laboratory. the best version which currently runs was coded in lisp by howie shrobe a better humanly engineered version has been designed and coded by carl hewitt in plasma with the extensive aid of marilyn mclennan. the new implementation has been translated into lisp by the members of a seminar this spring with the following participants: russ atkinson  mike 
freiling  kenneth kahn  marilyn mclennan  keith nishihara  
1 

howie shrobe  kathy van sant  and aki yonezawa the translation was made possible by lisp macros written by russ atkinson which makes the lisp code of the implementation closely resemble the plasma which it implements a rough draft of a primer by brian smith and carl hewitt for the new implementation exists 
       next fall the implementation will be used as a basis on winch to build the higher level problem solving mechanisms described in this paper in order to implement some knowledge-based problem solving systems one project is the implementation of a programming apprentice the emphasis thus far in the project has been the elucidation and formalization of the semantic principles involved procedures for analysis have been chosen for their ability to illustrate particularly difficult semantic problems. examples that have been analyzed are pure queues  hewitt and smith   hash tables  rich and shrobe  impure queues  yonezawal and various versions of the readers-writers problem  greif  each of these- examples is about one page of code in a high level language. but it takes an average programmer a half hour or so to really understand each one if it is being encountered for the first time we would like to continue this approach by analyzing even more difficult examples such as the disk directory system of a timesharing system and the steele-dijkstra parallel garbage collection algorithm. however  in addition we plan to take a larger system consisting of about ten or fifteen pages of code in order to test our techniques on whole systems. in this regard  following a suggestion of michael dertouzos. we plan to try the programming apprentice on a budgetary assistant program that aids in the construction and balancing of budgets. 
acknowledgements 
　　　this paper is a greatly elaborated written version of a talk delivered at the  special session on formalisms for artificial intelligence  at ijcai-1 at stanford in august 1 the research reported in this paper was sponsored by the mit artificial intelligence and laboratory and project mac under the sponsorship of the office of naval research 
　　　writing this paper would not have been possible without extensive conversations with richard weyhrauch. candy rullwinkle  kenneth kahn  marilyn mclennan  keith nishihara. and guy steele made helpful comments and criticisms which considerably improved the intelligibility of this paper. mitch marcus suggested an improved title for the paptr and also made very helpful suggestions. conversations with allen brown  
martin van emden  pat hayes  bob kowalski  marvin mtnsky  
allen newell. earl sacerdoti  gerry sussman  and richard 
waldinger have proved to be of great value in writing this paper. although this paper has emphasized the deficiencies of truth-theoretic semantics for knowledge-based programming  we have learned a great deal from studying systems for attempting to use predicate logic as a problem solving formalism and interacting with the implcmentors of such systems ira goldstein  howie shrobe  and gerry sussman contributed valuable suggestions and criticisms on how to clarify the goals of this paper. 
bibliography 
davie.  d j m.  popler: a pop-1 planneit mip-1. school of a-l. university of edinburgh. 
davie*  d . j . m.  representing negation in   planner system  proceedings el aisb cenference july  1. svssex. 
1 
