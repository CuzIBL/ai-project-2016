 
simulation represents a powerful tool for reasoning about possible worlds  and  more generally  can be regarded as an important design aid. the design of physical systems is often accomplished by a cycle of a c t i v i t i e s   including phases that construct models  test the model's behavioral consequences by simulation  diagnose the causes for poor behavior in terms of design weaknesses  and propose model changes. in t h i s paper we present an overview of ross  a domain-independent language for w r i t i n g simulations in a wide variety of domains. ross has two d i s t i n c t components. f i r s t ross embeds a kernel that is s u f f i c i e n t l y powerful to create procedural models of complex systems. second  ross includes important tools that assist the user at several other stages of the design cycle; s p e c i f i c a l l y   in diagnosing system performance problems  and in proposing i n t e l l i g e n t model changes. we show specific examples of how ross's meta-description capabilities enable it to provide a friendly design environment. 
	1 	introduction 
　　　there are many situations in which one wants to understand the performance of a dynamic system without manipulating it in the real world. several considerations might prompt t h i s . for example  the real world  version  might perform too slowly   e . g .   an economic system   or it might y i e l d p o t e n t i a l l y devastating consequences   e . g .   a nuclear reactor . in these and other cases one wants to be able to reason about how the systems would behave  not observe their behavior. frequently  however  i n t u i t i v e methods that humans use for doing such reasoning are inaccurate  and mathematical  analytic  methods  though accurate  are of limited value  since it is d i f f i c u l t to capture formally the complexities of many dynamic systems. 
　　　simulation represents a p o t e n t i a l l y useful tool for reasoning about  possible worlds ' that avoids the imprecision of i n t u i t i o n   at the same time providing a more powerful formalism than mathematics for modeling target systems. more generally  our view is that simulation can be regarded as an important design and in a wide variety of tasks. if simulation runs can be used to conveniently test the behavioral properties of a real-world system  then  in situations where the s t r u c t u r a l characteristics of the system are user-controlled  the designer can use test information as a basis for judging and modifying the system's structure. ideally  a series of such generate and test cycles should converge on a system with the desired behavioral properties. we therefore see the design of many complex structures as an i t e r a t i v e process in which candidate designs are proposed  t h e i r implications followed out via simulation--a form of lookahead--  and then modified on the basis of the results of simulation. this design cycle is shown graphically in figure 1. 
the cycle is more than a high-level description of the processes involved in creating physical objects  or programs. the development of economic forecasts  m i l i t a r y strategies  and s c i e n t i f i c theories can a l l be p r o f i t a b l y thought of as design problems. 

       in t h i s paper we discuss ross  a language for constructing simulations of specific systems in p a r t i c u l a r domains. ross embodies a procedural modelling approach to simulation. by this we mean that the to-be-simulated system is represented computationally as procedures that are isomorphs of the functional components of the real world system  
1 

at a given level of d e t a i l . the ross language provides the user with a repertoire of commands or building blocks that f a c i l i t a t e the construction of procedural models of the target system. unlike most simulation languages  ross heavily exploits ai techniques. we believe that i t s several ai heritages make it superior to other simulation languages as a powerful tool for system design  as 
well 	as 	for 	reasoning 	about or t e s t i n g of given systems. 
1 design goals for ross 
　　　given our view that simulation is an important reasoning and design tool for complex  dynamic domains  we placed several requirements on the ross language. 
1. the language 	primitives 	must 	be 	domain independent. 
1. the language primitives must be expressively r i c h . 
1. the language must support design. 
1. the language must have user supports that make construction  or knowledge engineering simple. in p a r t i c u l a r   the environment must make it easy to   t i n k e r   with models-- to consider of alternate model designs  and alternate model assumptions. 
1. the language must support diagnosis. in order for users to employ a simulation to reason about systems and t h e i r possible designs they need to understand what aspects of a given design are responsible for good and bad system performances. this kind of inference is often d i f f i c u l t   thus  we want to include in ross techniques that simplify or even automate t h i s process. 
1. the language must be readable. a language that produces readable  e n g l i s h - l i k e   codeyields simulations that are simple to comprehend  hence enhances v e r i f i c a t i o n   modification  and diagnosis. 
in summary  the ross language can be divided into two functional components. the f i r s t component  or ross kernel  comprises the p r i m i t i v e   domain independent ross commands by which users construct 
procedural models. we have aimed at making the kernel as powerful and as easy to comprehend as possible  to f a c i l i t a t e the a c t i v i t i e s denoted by the  define  box in the design cycle. the second component consists of a set of user oriented aids. they are meta-simulation tools in the sense that they do not d i r e c t l y involve the construction of procedural models  but are c r i t i c a l in f a c i l i t a t i n g the  evaluation    inference   and  proposal   phases of the design cycle which embeds simulation as a part. thus  ross is best thought of broadly as a design/inference language rather than narrowly as a simulation language. 
	i l l 	an overview of ross 
　　　in developing ross we have pursued several complementary paths towards the goal of building a good design environment. these include: 
1. the development of an object-oriented kernel programming language with powerful commands for creating and manipulating objects that represent system components. 
1. the development of an  english  front-end for the language. this enables the user to enter commands as n a t u r a l   readable statements which are then i n v i s i b l y parsed into executable lisp-like forms. 
1. the development of techniques to f a c i l i t a t e and improve the q u a l i t y of user design changes  most notably s e l f - d e s c r i p t i o n . self-descriptions offered by a simulation object y i e l d a precise idea of what the object does  thus focusing any design modifications. 
1. p a r t i a l l y automated f a c i l i t i e s for analysis and summary of simulation r e s u l t s . ross embeds several objects that do not procedurally model system 
components but instead are meta-simulation actors that monitor simulation a c t i v i t i e s   and record r e s u l t s . these include an historian  reporter and statistician. 
	they 	are 	normally 	i n v i s i b l e 	as 	they 
  l i s t e n   to simulation performance; the user does not need to e x p l i c i t l y t e l l other objects to send messages to them. 
1. automated abstraction techniques that provide high level descriptions of the 
detailed events of simulation runs  making it easier to see important overall performance trends. 
1. graphic output that discloses macro-features of simulation performance more readily than numeric or verbal output. we are also aiming towards graphic input f a c i l i t i e s that w i l l allow users to a l t e r simulation features dynamically. graphics is important for design as well as diagnosis. 
　　　to develop and test these several t o o l s   we have implemented a specific simulation  in the domain of strategic a i r - b a t t l e s . i n i t i a l results have been encouraging. using our i n i t i a l version of ross we have found it r e l a t i v e l y straightforward to divide the domain into d i s t i n c t classes of conceptual e n t i t i e s   e . g .   penetrators  f i g h t e r s   radars   and to specify t h e i r behaviors in a modular fashion. our object-oriented approach has allowed us to simulate at the level of individual b a t t l e u n i t s   not merely large  r e l a t i v e l y meaningless  aggregations. on the other hand  t h i s level of d e t a i l has not prevented us from modelling large encounters  up to 1 objects in a single b a t t l e   . a more detailed discussion of the i n i t i a l 
1 

ross simulation system can be found in   1   .  1  discusses of some of ross's abstraction c a p a b i l i t i e s . in t h i s paper we focus on a few aspects of the ross language that f a c i l i t a t e the construction of procedural representations of complex systems  and that make it a useful tool for simply and i n t e l l i g e n t l y proposing design modifications. 
iv 	the 	ross kernel: tools for modeling systems. 
　　　ross began as an outgrowth of the director language   1   . the language is an amalgam of object-oriented programming techniques  
 exemplified by smalltalk  1     1     and the flavors system  1   as well as and director   and frame-based representation languages  such as frl   1      1 . in the s p i r i t of object-oriented programming  we view the components of to-be-modelled systems as actors or objects  and t h e i r interactions as message-passing. each object representing a system component has two aspects: memory and behaviors. memory comprises properties that refer to the object's s t a t i c state. a behavior specifies how an object is to respond to a p a r t i c u l a r type of message. generally  then  to construct a simulation in ross  a user must f i r s t create an object for each system component  define i t s s t a t i c properties  and f i n a l l y give i t s behaviors by s t i p u l a t i n g the messages it can process  and the actions it w i l l take in response to each message type. once these steps are accomplished  generating a simulation is simply a 
matter of introducing t r i g g e r i n g events into the system. 
　　　figure 1 shows a ross command in which three objects are being created by another   g e n e r i c - f i g h t e r     and several of their memory-variables are being set. this is done by sending a message to the object that specifies the things it should create. figure 1 shows a ross command in which the same object has a new behavior defined. this says that when generic-fighter receives a message matching  a penetrator has entered radar coverage   it should execute the computations following  do . actions t y p i c a l l y involve sending messages to other objects. thus an i n d e f i n i t e l y long  causal chain  of actions may result from a single transmission. note that behavior d e f i n i t i o n   as object creation  is done by message-passing. 


figure 1. a ross command for behavior d e f i n i t i o n . 
　　　there are several features that make the specification of objects and behaviors simple. f i r s t   ross commands have an english-like q u a l i t y that makes ross code simple to read. second  ross  as other object-oriented languages  encourages  egocentric  programming. that i s   you specify object behaviors by saying what you would do if you were that object. more generally  ross encourages a style of programming that is naturally suited to domains in which there are multiple interacting components or actors. ross takes an important design decision out of the user's hands by requiring him to take system objects as the basic unit of representation. often  this organization is just what is needed  since in many domains it is best to factor simulation knowledge in terms of system components. 
　　　t h i r d   ross provides methods to avoid redundant behavior s p e c i f i c a t i o n . object-oriented and frame languages both support class hierarchies. as figure 1 indicates  ross makes a d i s t i n c t i o n between generic objects  like generic-fighter  and instance objects  like f i g h t e r 1 . to run a specific simulation one t y p i c a l l y must create hundreds of objects. however  these objects normally f a l l into one or more of a few classes  where a l l of the members of a class are behaviorally i d e n t i c a l . class hierarchies exploit t h i s by allowing the user to associate behaviors with the generic object  l e t t i n g each instance i n h e r i t those behaviors as needed  without requiring instances to e x p l i c i t l y contain them. for example  in figure 1  a behavior is being defined for fighters as a whole. ross ensures that t h i s is retrieved when  say  fighter1 is passed the message  penetrator1 has entered your radar coverage  in addition  the class structure of ross objects also allows en masse specification of instance objects  as demonstrated in figure 1. 
	these features make knowledge 	engineering 	in 
ross r e l a t i v e l y straightforward. given a new simulation domain  one can begin to construct procedural models in ross as soon as the basic component parts of the system are known  and their behaviors catalogued. even if many objects need to be defined  one can often accomplish this through a small number of commands  by exploiting generics and inheritance. moreover  the english-like character of ross commands makes the language easy to learn  and allows domain experts who may be 
1 1 
programming novices to p a r t i c i p a t e d i r e c t l y in simulation construction. the ross kernel  therefore  provides a friendly environment for system d e f i n i t i o n . we now focus on some extensions of t r a d i t i o n a l object-oriented programming concepts in ross that enable it to f u l f i l l several other of the requirements for a good design t o o l . 
	v 	the ross environment: novel features. 
　　　several features of ross are r e l a t i v e l y novel to object-oriented programming languages. these include: 
1. frl-like frames for representing actors or objects. among other things  this allows the association of if-added and if-cranged demons with objects. this insures that the appropriate alterations to dependent objects occur automatically when an object's memory or i t s behaviors are changed. 
1. multiple inheritance  which enables an object to have several generic parents. several d i f f e r e n t parents e f f e c t i v e l y provide multiple views or perspectives on the same object  where each view contains d i f f e r e n t kinds of knowledge about the object. pie    and the mit flavors system   1     also exploit multiple inheritance in an object-oriented programming environment. 
1. treating messages  message-patterns  and actions as objects. 
for several reasons  we feel that the most novel and useful extension of object-oriented programming involves the use of messages  message-patterns  and actions as objects. broadly  this has f a c i l i t a t e d language development by allowing the representation of meta-knowledge of messages and actions  knowledge about actions and messages . as users  we know important things about these entities--how they should be displayed  how valuable they are  how much time they take to execute  and so on. important assessments often hinge on such knowledge  so by creating message and action objects that embody t h i s expertise  we provide actors that can help decision-making. 
　　　below we present a concrete example demonstrating the value of representing actions as objects in the design and a l t e r a t i o n of system models. 
vi the ross environment: an example of design support features. 
　　　several features are important in good design change  and imply properties c r i t i c a l for a useful design environment: 
1. i n t e l l i g e n t a l t e r a t i o n of designs presupposes an understanding of the code being changed. when the to-be-altered structure is a piece of code w r i t t e n by someone else  it may be d i f f i c u l t to comprehend in a few glances. a language that supports design should have f a c i l i t i e s for improving a user's comprehension. 
1. i n t e l l i g e n t a l t e r a t i o n of designs implies searching a limited space of possible changes. incoherent changes should never be considered  or should be caught before they become part of an altered system. a language that supports design should be 
able to help the user detect bad changes  thus l i m i t i n g the search space of the design problem. 
1. i n t e l l i g e n t a l t e r a t i o n of designs allows for backtracking. one is normally very reluctant to change a good design if it w i l l be d i f f i c u l t to get back to this state. on the other hand  it is often important to get beyond s a t i s f i c i n g designs to nearly perfect  ones. thus  to keep design quality monotonically increasing over many changes  and to improve the quality of the f i n a l product  a design language should be able to remember old versions  or more generally retain a world line  of each of a user's designs. |1  
1. i n t e l l i g e n t a l t e r a t i o n insures consistency of changes. the complexity and quality of the dynamic systems we can design is threatened by the fact that design components are not independent. when this is so  overall design improvements often cannot be made by s t r i c t l y local changes. however  it is t y p i c a l l y very d i f f i c u l t to see the remote changes that are entailed by a local a l t e r a t i o n ; so we often s e t t l e on a design that is imperfect  but at least consistent. a good design language 
should help the user keep track of dependencies between the components of his designs  and should be able to assist i n    possibly by automating   the propagation of global effects of local changes. 
figure 1 shows a trace of a user interactively a l t e r i n g the behavior of one of a simulation object; s p e c i f i c a l l y   changing the a c t i v i t i e s a fighter should engage in when receiving the message  a penetrator has entered radar coverage . this example demonstrates several of the ways ross meets the above requirements for a good-design change environment  by exploiting meta-knowledge of actions. the user's commands are in lower case; ross responds in upper case. 
　　　at  1  the user begins his f i x of the suspect behavior by sending a message to the generic-action  the parent of a l l objects that are actions . the computation ross requires to process this command is somewhat complex and merits elaboration. generic-action is the natural place to store a l l expertise associated with action-objects in general. the generic-action responds to the request by finding a behavior that it owns or inherits whose pattern matches the incoming 
1 1 

message. generic-action f i r s t asks fighter to return the name of the object containing the code to be executed when a fighter receives the specified message.  this name is not accessible to the user  which is why messages cannot be passed d i r e c t l y to action instances . now generic-action passes a   p r i n t yourself  message to that action instance. in f a c t   action instances do not know how to p r i n t themselves. it would be i n e f f i c i e n t to store t h i s behavior with instances  since a l l actions p r i n t a l i k e . so  to comply with the request  ross next searches for  and finds  the appropriate p r i n t i n g expertise indexed under generic-action--the action instance's parent. this 
is used to p r i n t the target action. 
 1  generic-action  recall f i g h t e r ' s behavior for  a to pen has entered radar coverage . 
my behavior is: 
myself  if you have detected the penetrator  prepare missile f i r i n g 
on the penetrator 
otherwise t e l l your f i l t e r center  you have detected nothing. 
 1  * a c t   recall your author. 
my author is davem  date of creation 1/1. 
 1  * a c t   change your code. 
enter new code 
myself  if you have detected the penetrator  prepare missile 	f i r i n g on the penetrator and l o i t e r 
otherwise t e l l your f i l t e r center  you have detected nothing. 
ok now give an english explanation 
when a penetrator is in range of a given f i g h t e r   if that fighter detects the penetrator  prepare to f i r e a missile  and l o i t e r . if the penetrator is not detected  then this fact should be reported. 
fighters interact with filter centers and penetrators  so you might want to alter their behaviors to be consistent with this new behavior. 
figure 1. a session where ross aids user in design change. 
　　　note that an english version of the action is printed  not the less readable underlying lisp code. here is a simple example of how ross improves the design environment by increasing a designer's comprehension of what he is about to change. this is enabled  in t u r n   by permitting actions to be objects. once actions are treated as referenceable e n t i t i e s   they can have expertise and several kinds of description associated with them. in p a r t i c u l a r   one can store several sorts of 
 translations  of an action with the object. the schematic structure of an action instance is shown 
in figure 1. 
 action-instance act ion-name  gensym  
code  ross code  l i s p  lisp translation of ross commands  compiled  compiled behavior  english  user-given english rendering  author  code's author  date  most recent update   figure 1. a schematic view of an action. 
　　　at  1  the user requests the action to report who constructed i t . this is another meta-description associated with the action  and provides an a p r i o r i test on the code's c r e d i b i l i t y - if an expert is not responsible for the code  it is more suspect. 
　　　at  1  the user enters into an extended interaction w i t h i n a single command. he offers a modified behavior   a   l o i t e r   message has been added   and is prompted for a new english explanation to be stored with the action-object  once the given ross code is determined to be s y n t a c t i c a l l y legal and translatable into underlying lisp. as the f i n a l phase of this i n t e r a c t i o n   ross checks to see if it knows any dependencies between fighters and other objects that might cause a the change in fighters to 
propagate to other structures. this is accomplished through demons in the if-changed slot of f i g h t e r . currently this slot must be f i l l e d by the user; ross cannot yet synthesize i t s own constraint expressions  1 . if the code placed in such slots is merely an alert concerning dependencies   as in the present case   the user w i l l have to make remote changes by hand  but  at least ross makes him aware of the need for change. if the code in if-changed slots is a bona fide dependency contract  ross can take care of constraint propagation i t s e l f   thus insuring global consistency of changes. 
　　　at the end of this session  ross automatically takes care of a few important book-keeping d e t a i l s   including:   i   a l t e r i n g the action object's date    i i   changing i t s author    i i i   possibly compiling new code  and   iv  archiving the previous behavior version. these details w i l l f a c i l i t a t e future changes  including possible retractions of the current a l t e r a t i o n . 
1 
vii 	conclusions 	acknowledgments 　　　the above session is a only simple example of how ross's knowledge of action objects is structured and how it may be used by the ross system to p a r t i a l l y automate design change  freeing 
 the user to focus on the more creative aspects of system construction. currently  we have an ever-expanding l i s t of possible ways to further exploit knowledge associated with messages and actions  and to improve ross by including these types of objects as message-passing e n t i t i e s . for example  the meta-description associated with message objects is useful in the data analysis and diagnosis phases of design as well as in proposing design changes. moreover  some uses go beyond the implementation of design and diagnosis supports. to take a b r i e f example  message objects enhance the power of ross's english front-end by permitting the ross parser defer decisions concerning the intensional or extensional interpretations or a ross phrase. these choices cannot be made using a context-free grammar; information concerning the  pragmatic  intent of the phrase must be used to select among the two interpretations. we currently solve t h i s problem by l e t t i n g the ross parser pass both interpretations to message-objects whose message-pattern-objects are queried to determine which action should be invoked. the message-pattern objects can either i n h e r i t the standard technique for message receipt or  if some specific context dependent actions need to be performed  they can define t h e i r own matching/application algorithm. this may appear to make the ross parser unacceptably slow  but 
e x p l o i t i n g messages as objects in another way  to  memo ize message searches  allows speed 
optimization * 
　　　much of the power behind the idea of representing actions and messages as objects comes from being able to implement multiple views of the same object. as users we understand several things about  say  messages; not only that they are the product of simulations  but that they should be printed in a p a r t i c u l a r way  that they have a certain importance as data  that they often come before or after other events  and so on. yet  t y p i c a l l y   simulation programs  know  only that messages are things they pass from object to object. knowledge of these d i f f e r e n t views comes into play in d i f f e r e n t phases of the process of design and simulation data c o l l e c t i o n . if a 
　　　simulation program- does not embed these types of knowledge e x p l i c i t l y   it cannot help the user accomplish some of the a c t i v i t i e s that are outside simulation in a narrow sense but which we regard as important components of the larger inference and design process. by t r a n s f e r r i n g these several we g r a t e f u l l y acknowledge the contributions of sally goldin  phil klahr  russ greiner and alan kay to the development of the ideas presented herein. alan borning  sally goldin and phil klahr also provided useful comments on an e a r l i e r d r a f t of t h i s paper. 
