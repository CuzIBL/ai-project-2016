 
integrity checking has been investigated extensively in the field of deductive databases. methods have been developed to optimise the checking of an update by specialising the constraints for the information that could have been affected by it. the optimisation has been applied to sets of updates resulting from the execution of unspecified update procedures. this paper investigates the compilation of integrity checking into the procedures themselves. the paper introduces a  procedural  update language  and describes how constraints are compiled into procedures expressed in this language. the compilation yields conditions on the original database state that guarantee safety of the update. the paper also shows why compilation into procedures offers important possibilities for optimisation not available in the earlier framework. 
1 	introduction 
integrity constraint enforcement is important for preventing incorrect data being entered in data and knowledge bases. in databases only quite simple constraints are generally enforced by the system  such as types and functional dependencies. however most applications require more complex constraints. 
　an integrity enforcement technique has been developed which separates the integrity constraints from the update procedures. first proposed in the context of relational databases  nic1  the technique has been extensively researched in the context of deductive databases 
 sk1; dec1; lst1; bdm1  and the references in  bmm1 . 
   under this approach the integrity constraints are expressed as logical statements - effectively yes/no queries - and stored in the knowledge base. the system just checks the constraints that could have been affected by the update  and even then only what has  or could have  changed. we call this specialised integrity checking. it will be described in more detail in the next section. 
　to date integrity specialisation has been applied for updated literals  single inserts and deletes   for sets of updated literals  and for intentional updates  inserts/deletes satisfying a certain condition . however it is normally assumed that the set of updates is the result of an update procedure which is not visible to the specialiser. specialisation is applied to the resulting update  not to the update procedure. 
　in this paper we show how to specialise integrity constraints for the update procedures themselves. this yields significant reductions in the amount of checking that has to be done at update time. the reason is that update procedures often perform partial integrity enforcement automatically. for example the procedure for hiring an employee will require that he has a salary which is a real number  and that he belongs to a department etc. 
　in this paper we show how to compile integrity checking into update procedures in such a way that redundant checking is minimised. the aim is to eliminate any further checking at update time of constraints which are  from the design of the update procedure  bound to be satisfied after the update. the idea of compiling constraints into update procedures was first suggested in  sto1   however the techniques applied here are quite different. effectively we perform specialised integrity checking for update procedures at compile time. 
　in section 1 we study integrity checking methods in deductive databases. the next section describes the update language used for encoding update procedures. in section 1 we explain how integrity constraints are compiled into these procedures. 
　specialised integrity checking implies a requirement  for reasoning over multiple database states. however itis shown that this requirement can be compiled away so that there is no need for such a facility at update time. in fact the result of compilation is a safe update procedure comprising a condition  which is simply a query against the current database state  and then the original update procedure. 
1 	constraints on deductive databases 
1 	constraints in deductive databases 
deductive databases extend relational databases by supporting intentional data and logical dependencies amongst the data. a deductive database is a set of program clauses  divided into facts and rules. a program 
	wallace 	1 
clause is a formula head  body  with a  head   head  and a  body   body . the head is an atom  comprising predicate and arguments. the body is a conjunction of literals. a fact is a clause with an empty body. a goal is a clause with an empty head. the goal  - g expresses the query g. we use the logic programming syntax for predicates  functions and variables  eg: 
grandparent fred  	y   parent fred  	x  parent x  y  
we will not exclude compound terms from our rules. in other words our underlying relational model need not be in first normal form. we assume  however  that appropriate syntactic restrictions on clauses are enforced to ensure completeness and termination of query evaluation. such restrictions are described in  rbs1   for example. 
the rules yield a notion of dependency: 
definition 1 an atom a  directly depends  on a literal 
u if a is the head of an instantiated database rule whose body contains u or its negation. the negated literal directly depends on u if a does. 
　we assume that for each constraint  q  there is a rule inconsistent in the ruleset. therefore a knowledge base is inconsistent if and only if inconsistent is derivable as a consequence. 
　in this paper we do not consider rule updates  therefore a database state comprises a fixed set of rules and an updateable set of  base  facts. we assume  without loss of generality  that the clauses defining a database predicate are either all base facts  or else they are all rules. predicates defined by base facts are called  base  predicates  and those defined by rules are  derived  predicates. as the result of an update certain new base facts are added to the database  and certain base facts are dropped. these are termed the  directly  updated literals  or  direct updates . also as a result of an update certain new facts are derivable  and certain previously derivable facts are no longer derivable. these are termed the  indirectly  updated literals  or  indirect updates . 
1 	integrity constraint specialisation 
the derived literals affected by an update are often assumed to be included in those dependent on the direct updates. 
definition 1 a dependent update is an indirect update that directly depends either on a direct update  or on another dependent update. 
　efficient integrity checking methods in deductive databases  see 