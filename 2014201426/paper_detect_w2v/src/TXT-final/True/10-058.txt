learning simple arithmetic 
pavel brazdil 
department of a r t i f i c i a l intelligence 
university of edinburgh 
scotland 
　　　sussman  1  has shown that strategies could be reordered according to experience. in his examples no conflicts were experienced after reordering. we shall i l l u s t r a t e that conflicts do arise and present a way of trying to overcome them. the program written  els  accepts a set of partially ordered horn clauses as input and a sequence of problems to solve. the search tree obtained is examined in order to generate a priority ordering for the clauses used. if conflicts are detected  els tries to determine the conditions under which the clauses involved should be applied. for example  suppose the problem 1=x is to be solved and we are given the clauses: assoc: subs: subz: sue : 
pred: 
　　　generally  the problems are solved in a breadth f i r s t manner  but priority orderings between individual clauses are respected. first a l l clauses that match the given subgoal are chosen. in our case both the clauses 'subs' and 'subz' match the i n i t i a l goal 1-x  as this goal matches x1+x1=x1. both clauses are actually tried in the search  since i n i t i a l l y there is no priority ordering specified between them. if it had been specified that 'subz subs'  only the clause 'subz' would have been t r i e d . 

figure 1. the search t r e e f o r 1=x. the new p r i o r i t y orderings obtained are shown on the r i g h t . 　　　figure 1 shows a part of the search tree produced by els when solving the goal 1=x. the search tree contains a number of choice points. every time a choice is made els makes a note of which clause was given preference. after a successful solution has been reached  marked 'yes'   the preferences noted on the solution path are integrated with the existing p r i o r i t y orderings and then used to guide future searches. 
　　　the integration is not just a matter of adding the new orderings to the old ones as conflicting requirements can occur. in our example we have one such conflict. first we require 'subz subs' and then 'subs subz'. to resolve the conflict  els looks back into the search tree. it assumes that one of the variable assignments in the clause 'subs'  or 'subz'  is c r i t i c a l . in order to make a good guess which is the c r i t i c a l assignment  it compares the application which lies on the solution path  marked 'allow'  with an application which lies just off the solution path  marked 'avoid' . a new clause is generated on the basis of this comparison. care is taken so that it would mismatch the application marked 'avoid'  but further unnecessary specializations are avoided. 
in our case els generates the clause ' s u b s . l ' . thus: 
allow subs: avoid subs: new subs.l: 
　　　the new clause 'subs.l' is added to the original set of clauses together with the p r i o r i t y ordering 'subs.ksubs' and ' subs. ksubz '   which replaces the p r i o r i t y ordering 'subs subz'. the problem 1=x can now be solved without search. the knowledge thus acquired helps the system to solve a number of similar problems  such as 1=x and  1+l +1=x  which are both solved without search. the work described here is currently being extended to the domain of simple equation solving. 
　　　our work is also related to waterman  1 . the key point in our approach is analysis of the past search for the purpose of conflict resolution. i n i t i a l l y only p r i o r i t y orderings are used to describe a solution path  but if a conflict is detected  the old search tree is revisited in order to pull out more information about the clauses i n volved in the conflict. 
