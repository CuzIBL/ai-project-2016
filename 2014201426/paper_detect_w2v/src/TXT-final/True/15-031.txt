procedural expert systems 

	michael 	georgeff  
	artificial 	intelligence 	center  
　sri international  1 ravenswood ave.  
menlo park  co.  1. 
a b s t r a c t 
　　　　　a scheme for explicitly representing and using expert knowledge of a procedural kind is described. the scheme allows the explicit representation of both declarative and procedural knowledge within a unified framework  yet retains all the desirable properties of expert systems such as modularity  explanatory capability  and extendability. it thus bridges the gap between the procedural and declarative languages  and allows formal algorithmic knowledge to be uniformly integrated with heuristic declarative knowledge. a version of the scheme has been fully implemented and applied to the domain of automobile 
engine fault  diagnosis. 
′1 introduction 
　　　　　expert systems have been very successful in a wide variety of applications  michie 1 . the purpose of these systems is to acquire the formal and heuristic knowledge of specialists in some particular domain  and then to use this knowledge to solve problems that the specialists would normally tackle. the domains in which expert systems have proved most successful are those where heuristic knowledge is important  either because the related problems are ill-defined or are too complex for purely formal methods to be tractable  buchanan and duda 1 . 
　　　　　some of this specialist or expert knowledge is best expressed as a set of facts and axioms or rules about those facts. tor example  here is some declarative knowledge from the automotive domain  sully and unstead 1 : 
what faults reduce gasoline flow from the pump  
a choked suction line or dirty filter. 
a cracked diaphragm. 
dirt under a valve. 
leakage from the pump or discharge line. 
　　　　　rule-based expert systems seem to model this aspect of expert knowledge quite well. here is a typical rule for one of the above faults : 
if there is reduced gasoline flow in the fuel pump 
then conclude that the suction line may be choked. 
　　　　　the success of these rule-based expert systems stems largely from the fact that the knowledge representation is appropriate to the problem domains that they address. indeed  the authors usually stress the importance of choosing the  right  domain  buchanan and duda 1 . 
	umberto 	donollo  
	department 	of computer 	science  
	monash 	university  
	clayton  	victoria  	1  
australia. 
　　　　　on the other hand  some of our knowledge about solving problems may be viewed as procedural knowledge that describes sequence* of things to do or goals to be achieved. this kind of knowledge is often difficult and cumbersome to describe in a declarative manner  winograd 1 . in fact  even though some procedural knowledge can be incorporated in pure rule-based systems  it is there only because the rule interpreter executes the rules procedurally in some specified order. this means that procedural knowledge and the establishment of contexts in which a particular inference is valid can only be represented implicitly in the system  e.g.  by ordering the clauses of a premise and thus ensuring a particular sequence of evaluation . 
　　　　　this can create dependencies and interrelationships that tend to make the knowledge base not quite as modular or flexible as perhaps was originally intended. because of the homogeneity of the rule representation  it is not possible to distinguish between those rules for which the order of invocation is important and those for which it is not. this is not only bad methodology  but it impairs the explanatory capability of the system and reduces the possibilities for efficient implementation on multiprocessor machines. 
　　　　　note that we are not saying that such knowledge cannot be represented declaratively - all we are saying is that in some domains it cannot easily or naturally be so represented  which complicates the construction of the expert system and reduces thr explanatory capability of the system  see  clancey 1  for a more detailed discussion of these points . 
　　　　　these problems have encouraged some researchers to investigate ways of representing procedural knowledge explicitly. in the simplest cases  special mechanisms are introduced  such as heterogeneous sets of rules that are dissimilar in nature from the rest of t he knowledge base  e.g.  the therapy rules in mycin  shortliffe 1    or precedence relations  which require that certain rules be invoked before others  e.g.   contexts  in prospector  reboh 1  . alternatively  specialist procedures may be used for certain sections of the problem-solving process. however  these approaches are either not sufficiently general to express much procedural knowledge  or tend to destroy many of the desirable properties of the system  such as explanatory capability  modularity  and  most importantly  the ease with which knowledge can be integrated incrementally into the existing store of knowledge. 
　　　　　another problem with many rule-based expert systems is that one of the primary reasons for the rule representation - that is  being able to use and examine such knowledge in different ways in different situations - is rarely realised. for example  many rule-based systems are restricted to either invoking rules on the basis of facts becoming known  data-driven 
1 	m. georgeff and u. bonollo 
invocation   or invoking them on the basis of certain goals be-
coming important  goal-directed invocation . furthermore  the facts and goals that give rise to the invocation are required to occur explicitly within the rule itself  i.e.  as rule antecedents or consequents  respectively. while this simplifies the representation  it is a very restrictive assumption and does not readily permit the kind of hypothetico-deductive reasoning used by most problem-solving experts  clancey 1 . 
　　　　　for example  the system should be able to be goaldirected  yet also be able to alter its line of reasoning and set up different hypotheses  goals  if a particularly unusual fact is 
observed. one might also want a certain rule to be invoked only when a certain goal was  or was not  being attempted  yet still want it to be data driven  in the context of this goal  if a particularly significant fact was observed. for example  a lump in some tissue should perhaps invoke a rule to investigate the possibility of cancer  but not when the current hypothesis is a viral infection  where such lumps are usually caused by reacting glands . 
　　　　　in this paper we describe a scheme for explicitly representing procedural knowledge while still retaining the benefits of rule-based systems. th  basis of the scheme is to use a representation that is sufficiently rich to describe arbitrary sequences of actions in a simple and natural way  while at the same time avoiding explicit procedure  calling   see  georgeff 1  . the scheme also allows a wider class of invocation criteria than is available in most rule-based  expert systems. we shall call systems that are based on this scheme procedural expert systems. 
　　　　　to evaluate the scheme  we have implemented a system called peritus * a knowledge engineering tool which allows the creation of procedural expert systems specific to any chosen problem domain  bonollo and georgeff 1 . although we shall not discuss this system in any detail  for most of our examples we shall use an actual run from the domain of automobile engine fault diagnosis. 
′1 the knowledge representation 
　　　　　the basic structure of a procedural expert system  pes  is similar to that of most rule-based expert systems. that is  it consists of  1  a knowledge base for storing information about both the problem domain and the specific problem being examined  and  1  an inference mechanism for manipulating this knowledge  buchanan and duda 1 . 
　　　　　the knowledge base itself comprises a data base containing facts about the problem and a set of specialized inference procedures called knowledge areas  ka . 
　　　　　a knowledge area consists of an invocation part and a body. the invocation part is an arbitrary logical expression that 
may include conditions on both currently known facts and currently active goals. a ka can only be invoked if this expression evaluates to  true   in which case the ka is considered to be potentially useful in solving the problem at hand. 
　　　　　the body of a ka can be viewed as a specialized inference procedure. in essence  it is simply a procedure that establishes sequences of subgoals to be achieved  facts to be dis*  peritus  is the latin word meaning ''skillful  or  expert . covered  and draws conclusions  establishes other facts  on the basis of achieving  or not achieving  these subgoals. 
　　　　　despite the procedural nature of the kas  the system is deductive in the sense that once a fact has been added to the data base  it cannot be subsequently deleted. judgmental reasoning is accomplished by associating probabilities or certainties with both the facts and the inference procedures  in much the same way as for the more usual rule-based systems. 
1 representing procedural knowledge 
　　　　　procedural control is specified by using a recursive transition network  rtn . the arcs of the rtn are labeled with predicates  tests  and functions  actions   in much the same way as for an augmented transition network  atn   woods 1 .* 
　　　　　a given arc of the network can be traversed only if the predicate labeling that arc evaluates to  true . all possible paths in the rtn are explored  beginning at a specified start 
state and ending at a specified final state.  of course  only those paths with arcs whose associated predicate evaluates to  true  may be followed.  this is unlike the procedure adopted for atns  which exit as soon as one path has been traversed to the final state. the order in which the paths are explored should be considered as undegned  i.e.  the validity of the inference procedure should not depend on this ordering . however  in the implementation described in this paper  paths are explored in a depth-first manner. 
　　　　　a typical ka body is shown in figure 1.  start  is the start state and  end  the final state of the network; the tests on arcs are indicated by a ''  . now if  for example  all the arc tests evaluated to  true   the transitions tr1  tr1  tr1  tr1 and tr1 would all be made  and the actions a1  a1  a1 and a1 all executed  in that order  before the ka exited. if  on the other hand  test t1 fails  then only the transitions tr  and tr1 would be effected  and only action a1 would be executed. 
the functions and predicates labeling the arcs of the 
rtn can be any computable functions or predicates. 	in the 
peritus system  these are specified in lisp and can make use of variables local to the ka. free variables are not allowed. 
　　　　　there is also a special class of functions and predicates that access the data base and add new facts to it. some of these predicates ask whether certain facts are true or not  and will set up subgoals to ascertain these facts if they are not currently known  i.e.  not currently in the data base . we shall call these predicates goal-invoking predicates. as in most goaldirected systems  goal-invoking predicates can be viewed as a form of implicit subroutine call. similarly  some of the functions labeling the arcs may draw conclusions that add facts to the data base  thus making it possible for previously requested subgoals to be achieved. 
in essence  the rtn is used to define a language over the predicates and functions that label the arcs of the network  see  georgeff 1  . this language determines the allowable sequences of predicate and function evaluation  but not necessarily deterministically. instead of an rtn  it may be preferable to use some other  sufficiently expressive  means of describing sequences  such as  for example  temporal logic . 
　　　　　for example  consider the following procedure for isolating an electrical-system fault in an automobile engine that will not start  gregory 1 : 
spark-plug test: disconnect a spark plug lead and see if a spark jumps to the cylinder head on attempted engine start. if the spark is satisfactory or blue  then the spark plug may be faulty. if the spark is absent  weak  or yellow  proceed to the next test. 
coil-lead test:  instructions on how to test the spark from the coil  if the spark is satisfactory or blue  proceed to the next test. if the spark is absent  weak  or yellow  then the low-tension circuit is suspect; proceed to the low-tension test. 
distributor test: if there is evidence to suggest that the hightension leads from the distributor are not operating properly  conclude that they may be faulty. if the high-tension leads appear to be in order  conclude that the distributor may be at fault. 
low-tension test: instructions about how to perform this test  if a test lamp lights on the ignition side of the coil but not on the distributor side  conclude that the coil and/or the coil lead may be faulty. if the test lamp doesn't light on the ignition side of the coil  conclude that the low-tension circuit may be faulty. 
　　　　　a ka corresponding to this procedure is shown in diagrammatic form in figure 1. there are a number of things to note about the body of this ka  we shall consider the invocation part later . first.  when facts are required to be established  e.g.  as in  spark is satisfactory or blue   other kas may be invoked to ascertain this information. in this case  an  ask-user  ka might be invoked  but in general many kas might respond before the fact is established  as might be the case  for instance  in checking the status of the high-tension leads . 
　　　　　second  note how very important is the order in which the facts are ascertained. the conclusions to be made at any stage are context-de.pendent  i.e.  they depend critically on the knowledge that certain alternatives have already been ruled out  or in . in general  the conclusions may also depend on the tests and actions being carried out in a particular time order  such as listening for a scraping noise after applying the brakes in order to establish the condition of the disc pads . note also just how much heuristic information is contained in this ordering  how we start off with the spark plugs rather than the coil  partly because they are easy to rectify  partly because they are the more common fault  and then proceed from one end of the circuit to the other. to discard this information  or to represent it implicitly   leads not only to inefficient problem-solving  but also to a behaviour that is difficult to explain and difficult to follow  clancey 1 . 
　　　　　the rtn formalism can also represent other control constructs  including iteration and recursion. such control con-
*as in mycln-like systems  shortliffe 1   a request for a fact establishes a goal that is a generalization of the fact. thus  any subsequent test for an instance of that generalization will find the necessary information already in the data base and will not need to reinvoke kas to determine it. 
m. georgeff and u. bonollo 1 
structs are needed when it is desired to examine different instances of a given object type. for example  we might have a ka  or ka  schema   for determining whether or not a single spark plug is faulty. this ka would be invoked whenever a goal was set up to determine the status of some particular spark plug. however  by using iteration  represented as a loop in an rtn   we can also set up this goal for any arbitrary number of spark plugs in the engine  thus creating multiple instances of the spark plug ka. the ability to explicitly establish goals in this way can be very useful when one wishes to examine different instances of a given object type in a specified order  e.g.  such as testing the spark plugs in firing order  or when a certain conclusion depends on interactions among instances. 
　　　　　we can thus view the rtn as specifying sequences of subgoals to be achieved and  depending on the conditions obtaining  as drawing conclusions about the current problem. this is similar to the way in which  for example  rules in goal-directed systems  e.g.  emycin  van melle 1   are used to set up subgoals to be achieved  and then make conclusions on the basis of these subgoals having been achieved. the scheme described in this paper differs in that the achievement of subgoals may be explicitly sequenced in quite complex ways  and the conclusions reached may be valid only if this sequencing is maintained. 
1 representing utilitarian knowledge 
　　　　　the invocation part of a ka is any arbitrary expression that evaluates to  true  or  false . a ka can be invoked only if this expression evaluates to  true   in which case the ka is considered to be useful in solving the current problem. one can thus view invocation expressions as domain-specific meta level rules  davis 1  that constrain the application of kas to situations in which they are likely to be useful.* 
　　　　　an invocation expression can include functions that examine the current goals and functions that respond to new data. the current system uses a goal stack to keep track of all current goals and uses a goal function to test whether a given goal  or generalization  is present on the goal stack. the goals on the goal stack form an inference chain whereby for each goal gi  the goal    which is closer to the  top   may be viewed as a subgoal to be determined as part of the process of establishing 1i- a fact function is also provided to ascertain whether or not a given fact occurs in the data base.** 
　　　　　an invocation expression consisting solely of the goal function results in standard goal-directed invocation  whereas an expression consisting solely of the fact function results in standard data-driven invocation. for example  two simple kas from the automotive domain are shown in figure 1. in figure 
1 a   the ka is goal-directed  and corresponds to a standard 
* invocation expressions serve solely to determine the set of useful kas  not to order them. in this sense they are a more limited form of metarule than discussed by davis. on the other hand  they are more general in that they can  rule in  some alternatives that under a purely goal driven or data driven system would not be considered. 
**thc implemented system uses judgmental criteria and a minimum certainty factor can be required of the requested fact. this allows kas to be invoked on the basis of incomplete or uncertain knowledge. 
1 m. georgeff and u. bonollo 
myc in-like rule. this ka will be invoked only if some current goal is to identify a fuel system problem  and the required information is not currently known  i.e.  in the data base . invocation of the ka will then test whether there is reduced fuel flow in the fuel pump  possibly invoking other kas to ascertain this. if reduced fuel flow is concluded  the  single  arc of the network can bo traversed and the fuel system problem identified  with some degree of certainty  as being a choked suction line. 
　　　　　an example of a data-driven ka is given in figure 1 b . note that the test in the body of the ka seems redundant in this case  as the ka would not have been invoked if it had not already been known that the oil was contaminated with water. however  it is important from a methodological point of view to require that the body of a ka be valid irrespective of the invocation condition. under these conditions  if the inference procedures forming the bodies of all the kas in the knowledge base are consistent  the system will be consistent. alteration of the invocation conditions to improve performance will not affect the validity of any conclusions made  thus allowing the system to be  tuned  in safety.  of course  completeness is not guaranteed; because of inappropriate invocation criteria a certain ka may never be invoked and thus a valid inference never made.  the apparent inefficiency of having to check the data base twice for  in this case  the condition of the oil could be eliminated during a compilation stage. 
　　　　　kas can also be partly goal-directed and partly datadriven  as is the case for the ka shown in figure 1. it will be invoked if one of the current goals is to identify an ignition fault and it is noticed that one of the trouble symptoms is that the engiue does not start. the system can thus be opportunistic in the sense that kas might be invoked because certain facts are noticed during an attempt to establish particular goals. 
　　　　　in general  any arbitrary expression can be used in the invocation part of a ka. such expressions can include negation  conjunction  and disjunction of both goals and facts. universal and existential quantification over existing object instances are also allowed. 
′1 the inference mechanism 
　　　　　the system's main task  at a particular point in time  is to discover all it can about the current goals by executing relevant kas. to do this  an invocation mechanism is called implicitly by the currently executing ka when some currently unknown fact is requested or when some new conclusion is drawn. the mechanism evaluates the invocation part of all instances of the kas occurring in the knowledge base to decide which ones are  relevant   i.e.  for which of them the invocation part evaluates to  true  . these relevant kas are then executed or invoked in turn until either they have all been executed or a definite conclusion has been reached about one of the current goals on the goal stack. 
　　　　　the invocation mechanism is outlined in figure 1. the set s is initialized to contain all relevant instances of the kas occurring in the knowledge base. the function eclect s   destructively  selects an element p from the set of applicable instances of kas 1  and execute p  executes the body of p. 
　　　　　of course  for efficiency purposes  and to prevent asking the same question more than once  we do not want to reinvoke instances of kas that have already been traversed. we therefore mark these instances as  used   which effectively deletes them from the knowledge base. 
　　　　　execution of a ka body consists simply of traversing the body of the ka  as described in section 1. in fact  peritus actually compiles the networks into lisp code  in a manner similar to atn com pilers  see  bonollo and georgeff 1  . this makes the system much more efficient than if kas were evaluated interpretively. 
　　　　　it is very important to note that although the body of a ka sets up sequences of goals to be achieved  it may be that during its execution some data invoked ka suggests an alternative hypothesis and thus changes the course of events. progress through the original ka is then suspended  and will only be resumed when the alternative hypothesis has been fully investigated. if we had more control over the selection of tasks  say  by using metalevel kas   the currently executing ka could also be suspended simply because other goals  hypotheses  became more interesting. thus  it is preferable to view ka bodies as placing constraints on the sequencing of goals  while not precluding the possibility that certain observations may  at least temporarily  interrupt this sequencing. 
1 definite conclusions about goals 
　　　　　elements on the goal stack represent hypotheses that the system is trying to establish. once a hypothesis that occurs on the goal stack is confirmed with certainty  it is pointless to continue considering alternative paths in the current ka. furthermore  if this hypothesis is not on top of the goal stack  it is also desirable to terminate all kas that are trying to establish additional supporting hypotheses  i.e.  all subgoals of the just-
concluded goal . 
　　　　　the current implementation achieves this by  tagging  calls to kas with the goal that was the top goal at the time a particular instance of the invocation mechanism was called. a conclusion as to this goal can then cause immediate exit of the current ka being explored. this results in an explicit alteration of the normal function return sequence by  throwing  * to the instance of the invocation mechanism whose  tag  is the hypothesis that has just been confirmed. any intermediate calls to this mechanism are discarded and the goal stack is automatically restored to a state in which the just-concluded goal is the top goal. 
　　　　　however  this can present difficulties when it comes to deciding which instances of kas should be marked as  used  and hence not available for reinvocation. the problem is that a  throw  to some previous state in the goal stack can pre-empt complete traversal of some kas  i.e those that were working on subgoals of the just-concluded goal   and we might be throwing away the knowledge needed to reach other conclusions  about other goals  if these kas were not able to be reinvoked. 
　　　　　the solution currently adopted is to mark these partly used kas as fully used  thus possibly jeopardizing the completeness of the system but not its consistency. this is not entirely 
*this is implemented via the catch and throw primitives present in most lisp implementations  e.g.  franz lisp  foderaro 
1  . 
satisfactory  however  and other alternatives need to be investigated. tor example  it might be better if partly used kas were left unmarked  i.e.  unused   allowing for possible reinvocation. it would then be important to ensure that multiple re-use of an instance of a ka would not affect the validity of any conclusions made  and that i/o operations were encased in kas that always exited naturally  i.e without  throwing  . 
1 incorporation of judgmental knowledge 
　　　　　the scheme described above can readily be extended to include judgmental mechanisms for application in domains where facts and inference rules  or inference procedures  exhibit some degree of uncertainty. in the peritus system  the judgmental scheme is based on certainty theory  shortliffc and buchanan 1 . however  procedural expert systems are not tied irrevocably to this philosophy and there is no reason not to apply other criteria in dealing with judgmental knowledge. 
　　　　　to implement  the judgmental mechanism  each arc test in the body of a ka is enclosed in an interface function. the purpose of this interface function is to provide judgmental criteria for deciding whether the result of a test is  true enough  to continue progress along the are. in the current system  the criteria used are as follows : 
i. any test that returns nil is mapped to a certainty factor of 
1. 
ii. any test returning a non nil value that is not a certainty factor is mapped to a certainty factor of 1. 
iii. any test that returns a certainty factor is left unchanged. 
　　　　　the interface function then returns  true  if this new certainty factor is greater than an arbitrary threshold of 1. 
　　　　　as the functions which add new facts to the data base need to know the certainties associated with each of the tests  or premises  that precede them  a stack of the certainties associated with the tests on the current path is maintained and can be accessed by these conclude functions. when an arc test evaluates to  true   the certainty factor associated with that test is pushed onto the stack as a side effect of the interface function. the stack is popped at the end of a path or after the last transition from a state has been attempted. 
1 a sample consultation 
　　　　　portions of a sample consultation in the domain of automobile engine fault diagnosis are given opposite. the procedural expert system that produced this dialogue was constructed by using peritus  the pertinent knowledge being extracted more or less directly from various automobile literature  e.g.   sully and unstead 1    gregory 1  . typical examples of the kas used by the system are shown in figures 1 and 1. 
m. georgeff and u. bonollo 1 
 various initial data is first entered  
 does the engine start  	no 
 at this point  a data driven ka is invoked on the basis of the engine not starting  
	f u e l 	c h e c k ! ! 
 is there adequate fuel in the tank  	yes 
 and now the ka shown in figure 1. is invoked  
	ignition 	system trouble shoot procedure: 
 1  disconnect a spark plug lead and position the terminal within 1 mm of the cylinder head. 
 1  have an assistant switch on the ignition and attempt to start the engine 
 1  observe the spark  if any  that jumps the gap to the cylinder head 
press the   r e t u r n   key when you are ready 	-  
 ilow would you describe the spark  why   the user wants to know why the system needs this information  
i was trying to determine one of the ignition system faults  and i noticed that the engine does not start. 
 the user now continues with the trouble shoot  
  	weak 
 1  disconnect the coil lead from the distributor cap and carry out the procedure previously described for the spark plug lead in points  1  to  1 . 
press the   r e t u r n   key when you are ready 	-  
 iiow would you describe the spark from the coil lead  weak 
 1  we will now check whether the low tension current is reaching the ignition coil. use a test lamp between the coil low tension terminals and a good earth. ensure that the contact breaker points are open or insulated when making the test. 
press the   r e t u r n   key when you are ready 	-  
 does the lamp light on the ignition side of the coil  	yes 
 does the lamp light on the distributor side  	no 
 the system has now discovered all it can and gives its report  
a u t o m o b i l e 	suspected faults 	r e p o r t : 
there is evidence  1  to suggest that the ignition coil is faulty. 
there is evidence  1  to suggest that the coil lead is faulty. 
1 m. georgeff and u. bonollo 
′1 conclusions 
　　　　　procedural expert systems appear to provide a means for representing a specialist's declarative and procedural knowledge of some problem domain without sacrificing any of the 
desirable properties of standard rule-based expert systems. 
　　　　　there are a number of important features of the system that are critical to achieving this. first  kas are not directly  called   but are invoked only when they can contribute to finding some current goal or when some particularly relevant fact is observed. as kas cannot be directly called  neither can they directly call any other ka. they thus serve only to specify what goals are to be achieved and in what order. second  the system is  in general  nondeterministic  and any number of kas may be relevant at any one time. these properties enable the knowledge base of the system to be modified and augmented without forcing substantial revision. 
　　　　　furthermore  the representation of the inference procedures in the form of an augmented rtn is simple and homogeneous  which aids both in the acquisition of knowledge and in verifying correctness. this simplicity also aids the system in explaining its reasoning. in the simplest case  the goal stack can be traversed to answer  how'' and  why  questions  as in mycinlike systems . hut  by tracing the bodies of the kas as well  the system can also describe the context in which hypotheses are being explored. this kind of explanation is of course not deep  but the formalism itself does not preclude the development of a richer explanation system. indeed  the fact that at least some of the procedural knowledge of the expert is explicitly represented can only lead to better explanatory capabilities. 
　　　　　the procedural control component is also very general  allowing at one extreme the construction of purely declarative programs  while  at the other extreme  it allows purely deterministic procedural programs. thus  procedural expert systems bridge the gap between the declarative languages and the proce-
dural languages. indeed  one way of viewing these systems is as a generalization of the usual procedural languages to include a 
deductive data base and a more general invocation mechanism. 
　　　　　the fact that the knowledge representation allows the specification of procedures means that the inference mechanism of the system can itself be written by using the same representation. for example  the description of the current invocation mechanism given in figure 1 is already in this form. 
　　　　　the generality of the invocation scheme makes it possible for the system to pursue a diagnosis in a goal-directed way  yet react opportunistically and change the direction of the consultation if an event occurs that suggests an alternative diagnosis. in fact  after using primarily goal-directed systems like mycin  the way in which data invoked kas suddenly wake up and begin exploring alternative diagnoses was a constant surprise to the authors  not always pleasant! . as invocation expressions can be arbitrarily complex logical expressions  they can represent quite complex knowledge about the use of kas. for example  although we have not explored it here  the scheme allows invocation based on observed differences between goals and facts  and kas can thereby be invoked in a means-ends fashion. 
　　　　　there are a number of questions that still remain to be answered  and this will require further experimentation with the system. for example  it may be that the class of invocation expressions used by the present system is too broad. when arbitrary expressions are allowed  knowledge about the use of kas 
can be very difficult to reason about. this might create problems if more detailed explanations were required or if metalevcl kas were to try to manage invocation. furthermore  there would then be fewer possibilities for compiler optimizations  which could result in unacceptable real-time performance. 
bonollo  u. and georgeff  m.p.  peritus: a system that 
aids the construction of procedural expert systems   to appear as computer science tech. report  monash university  melbourne  australia  1. 
 buchanan  b.c.  and duda  r.o.   principles of rulebased expert systems   to appear in m. yovits  ed.  advances in computers  vol 1  academic press  new york. 
clancey  w.j.   the epistemology of a rule-based expert a framework for explanation   to appear in 
artificial intelligence. 
 davis  r.   metarules: reasoning about control   memo aim 1  mit ai lab  mit. mass.  march 1. 
 foderaro  john k.  the franz lisp manual  university of california at berkeley. 1. 
georgeff  michael p.   procedural control in production 
	systems   artificial intelligence  vol 1  pp. 	1  
	gregory's sp manual no. 1: falcon 	fairmont xd 
series 1 cylinder service and repair manual  gregory's pub. co.  sydney  1. 
 michie  d.   expert systems   the computer journal  vol 1  pp 1  1. 
reboh  r.  knowledge engineering techniques and tools in the prospector environment   tech note 1  artificial intelligence center  sri international  menlo park  ca.  1. 
shortliffe  e.i i. computer based medieal consultations: 
mycin  american elsevier  new york  1. 
 shortliffe  e.h. and buchanan  b.c.   a model of inexact reasoning in medicine   mathematical bioscicnces  vol 1  pp 1  1. 
 sully  f. k. and p. j. unatead.  automobile engines questions and answers  1rd. ed.  newnes technical books  buttcrworth and co.  publishers  ltd  london  1. 
van melle  w.  a domain-independent system that aids 
in constructing know ledge-based consultation programs  memo hpp-1  report no. stan-cs-1  computer science department  stanford university. june 1. 
winograd  t.   frame representations and the declarative procedural controversy   in bobrow  d. and collins  a. representation and understanding   academic press  new york  1. 
 woods  w. a.   transition network grammars for natural language analysis'*  comm. acm.  vol 1  1. 

	m. georgeff and u. bonollo 	1 
