 	ii 	hee& of ol&zll hierarchies 

     we highlight the growing body of systems in ai and outside where is-a hierarchies of procedures co-occur with more traditional onea of objects  and we classify the various types of specialisations. we then give formal definitions which approximate their intended meanings and  f i n a l l y   examine their u t i l i t y using as a criterion the way in which they aid program verification. 
i motivation 
     inheritance  is-a  hierarchies have been one of the trademarks of semantic network knowledge representations in ai. although originally used for describing objects only  there is growing evidence both from within and outside ai that hierarchies of events/procedures are also useful  1 1 1 . it is therefore of some interest to take a brief look at possible formal foundations to the notion of specialization for procedures  and compare them according to some uniform criterion. 
     we beging by reviewing briefly the intended use of procedure specialization in some of the systems which currently support this idea. in simula   1     smalltalk.1  and pie   the principal use of 
 is-a is for sharing code through inheritance; the goal is to save the programmer from the error-prone process of copying the material several times. in psn   1     the is-a hierarchy of programs provides the semantic basis for defining a l l other hierarchies  e.g. person is-a animal only i f   among others  the to-add program of person is-a the to-add program of animal . in taxis  1 1   generalization/specialization is the principal abstraction tool of a methodology for information system design and implementation. for example  as part of a university records system  the designer could introduce the many rules about what courses students can or must take by describing f i r s t the transaction for enroling any atudent in any course  and then specializing it to  among others  a transaction for enroling graduate atudenta into undergraduate courses  one for enroling part-time atudents  etc. in this caae apeclalization is used as a discipline for introducing the detaila of a system where consistency and completeneaa are at a premium. finally  rich  and others use hierarchiea to organize libraries of program plana in order to f a c i l i t a t e locating them in program synthesis/analysis tasks. 
     in this section  we w i l l consider in more detail the varioua ways of defining the notion of specialization for activities. probably the earlieat uae of inheritance hierarchies occurs in simula-1 . here  one defines a class a by giving its parameters pa and matching apeoiflcationa sa  declarationa da  and a body of operatlona ia;inner;fa. one can then describe a subclass b by giving only the additional parts pb  sb  db  ib and fb with the effect that claaa k with parameters pa and pb  ... and body 
ia:ib:inngr:fb:fa la created. we w i l l call this textual inheritance and observe that its function is code sharing. this is a syntactic definition slnoe the claas simulation can be considered to be is-a the claaa linked-list  in contrast to the more standard ai view that a l l objects in a subclass must be viewable as objects of the superclass  at least in some way. 
     smalltalk-1   1     and i t s descendant pie  1  provide objects grouped into classes  where a claas is defined by the messages it recognizes and the methods  procedures  used to respond to each message. a subclass can add traits of its own or override those of i t s superclass by providing a new method for handling a message. smalltalk has a defau.lt version of inheritance: if a method for a message to a claas is not explicitly specified  one looks up the chain of superclasses for a method. thla provided a great deal more freedom than in 
simula  where one cannot modify the body of the auperclaaa  and in fact leads towards the opposite end of the spectrum where any two procedurea can be is-a related. one can imagine intermediate ayntactic versions of is-a where  for example  one la allowed to specialize an if-atatement only by replacing it with another if-atatement. 
     some researchera  e.g.   1 1   adopt a stricter view of is-a in which a subclass is a subset of i t s superclass  albeit one about which more la known ; thua  if a l l employees must earn more than $1 then janitora must do so also  if 
janitor is-a employee. such a stricter interpretation for apeclalization is advocated for ai representations in   and in databases la motivated by the observation that when processing the elements of a claas in a loop  it la often uaeful to assume that they a l l satisfy the integrity constraints stated for that claaa. 
1 

for reasons of symmetry  we are then lead to a different  more semantic definition of is-a  one where the execution of a specialized procedure can be viewed in some sense as the execution of the more general one. on the basis of current experience  e.g.   1 1    it seems that if b and a are procedures such that b is-a a  then  ideally   1  a should complete successfully in a l l situations where b does    i l   the final or intended effects of b should include at least those of a  and   i i l   b should be allowed to have some additional effects. a typical example of this would be specializing the procedure which creates a new employee to the one which creates a new 
janitor. 
     for the remainder of this paper assume that a l l procedures are expressed in a  core  language  which allows simple variables  assignment and conditional statements  as well as a while-loop construct.* if we view the program as modifying machine states described by variables and their values  then we can define the semantics of a 
     program a by  among others  ra  the set of i n i t i a l / f i n a l state pairs connected by a  or pa  the set { p q !p true in s  q true in s '    s s'  in ra  where p and q are formulas in some fol over states. 
	we can start by defining 	 1 : 	b is-a a 	i f f 
rb c ra ; this ensures  i  and   i i   above but unfortunately forces a and b to be identical whenever both are defined in the same state  thus contradicting   i l l   . the same holds for the other semantics of programs in   1     including requiring pa ¡ê pb. to be more selective  one can define the difference a s s'  between states as the set of changes from s to s'  i.e.  the set of pairs  x e   where x is a variable with value e in state s' but with a different value in s. this leads to rule  1 : b is-a a i f f for every  s s f   in rb there is  s s   in ra such that a s s   c a s s'  . this is the basis of the notion o f n e t side effect  which is one of the underlying conditions of specialization in . alternatively  consider a procedure a to be  defined  by some particular pair of assertions  prea  posta  in pa and then let 
  u   : b is-a a i f f preb = prea & p  postb = posta & q for some p  q; this is the surface notation for specialization in   1   . another possibility is to let free f  stand for the set of free variables in a formula or program f  and let fa be { p q  in ra i free p   free q  c free a }. 
one might then define  ¡ê*! : b is-a a i f f fa c 
fb   and thus obtain another characterization of 
is-a which  like  1  and  1   captures conditions   i       i i   and   i i i   and yet constrains the additional effects of b so that they do not  oontradict  those of a. 
     observe that a l l of the above definitions rely solely on the effect of the programs  not on their internal structure  and henoe the familiar notion 
  similar results hold in more general oases  although the definitions need to be more complex. 
of inheritance is missing. both  and  attempt to oomblne into a hybrid definition the structural aspects of the procedure  parameters  statements  roles  with the semantic restrictions noted above in order to allow both inheritance of parts and a limited extension/modification of the more general procedure. in particular  in specializing a procedure one can usually specialize  a  the parameters  by imposing additional conditions on them   b  the component statements  tests and primitive operations  and  c  one can extend the specialized procedure by adding new parameters and components. by using an fol which allows procedures  etc. as domains to be quantified over  this can be stated rather elegantly    as b x  = a x  a r x  where a is the characteristic predicate of procedure class a  which has already been specified axiomatically. one is lead to suppose that in  pure  prolog  where there are no side-effects  the condition for b is-a a could simply be b = a; the reason for this is that prolog programs consist of clauses and a more specialized program would be  true  in fewer cases than the more general one  i . e .   it would have additional or  stronger  clauses. 
	i l l 	 is-a  tttpabcmss sl pbqcepvebs 
ahe ymirimtiph 
     in addition to the various uses for the specialization hierarchy noted in section 1  one can observe that through inheritance common parts of procedures are factored out into higher classes. now notice that these could  among others  be tested and verified independently  and this validation could then be  shared  by a l l the specializations of a procedure  i . e .   presumably we need verify only the additions/modifications.* this could be a partial answer to the problem in program verification of how one breaks up in a motivated manner the proof of a large program into smaller  yet coherent parts. consider  for example  verification using the standard 
floyd-hoare partial correctness assertions  pea's  p{a}q . an important application of this occurs 
in databases  where one would like to prove that a l l transactions maintain the integrity constraints invariant  so that the system would not have to check them after every update.   it may therefore be of interest to compare the various definitions of is-a on independent grounds: how do they support such proof sharing. 
     the existence of a commonly used rule of inference: p{c q  q{d}r k p{c;d}r makes textual inheritance  as in simula  an attractive approach because it suffices to prove q{d}q in order to deduoe p{c;d}q from p{c q. unfortunately  this is not a necessary condition  as illustrated by c i 
  the problem of re-validating programs which have been altered has also been considered in . 
 * an extensive example of verifying a group of procedures organized in an is-a hierarchy is presented in . 

1 


1 
