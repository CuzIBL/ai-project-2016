 interpretation of programs for model-based debugging
	wolfgang mayer	markus stumptner
advanced computing research centre
university of south australia
 mayer mst  cs.unisa.edu.au

abstract
developing model-based automatic debugging strategies has been an active research area for several years. we present a model-based debugging approach that is based on abstract interpretation  a technique borrowed from program analysis. the abstract interpretation mechanism is integrated with a classical model-based reasoning engine. we test the approach on sample programs and provide the first experimental comparison with earlier models used for debugging. the results show that the abstract interpretation based model provides more precise explanations than previous models or standard non-model based approaches.
1 introduction
developing tools to support the software engineer in locating bugs in programs has been an active research area during the last decades  as increasingly complex programs require more and more effort to understand and maintain them. several different approaches have been developed  using syntactic and semantic properties of programs and languages.
¡¡this paper extends past research on model-based diagnosis of mainstream object oriented languages  with java as concrete example . we show how abstract program analysis techniques can be used to improve accuracy of results to a level well beyond the capabilities of past modelling approaches. in particular  we discuss adaptive model refinement. our model refinement process targets loops in particular  as those have been identified as the main culprits for imprecise diagnostic results. we exploit the information obtained from abstract program analysis to generate a refined model  which allows for more detailed reasoning and conflict detection.
¡¡section 1 provides an introduction to model-based diagnosis and its application to automatic debugging. section 1 outlines the adaption of the program analysis module of our debugger and discusses differences between our and the classical analysis frameworks. section 1 contains results obtained though a series of experiments and compares the outcome with other techniques. a discussion of related and future work concludes the paper.

figure 1: mbsd cycle
1 model-based debugging
model-based software debugging  mbsd  is an application of model-based diagnosis  mbd   techniques to locating errors in computer programs. mbsd was first introduced by console et. al.   with the goal of identifying incorrect clauses in logic programs; the approach has since been extended to different programming languages  including vhdl  and java .
¡¡the basic principle of mbd is to compare a model  a description of the correct behaviour of a system  to the observed behaviour of the system. traditional mbd systems receive the description of the observed behaviour through direct measurements while the model is supplied by the system's designer. the difference between the behaviour anticipated by the model and the actual observed behaviour is used to identify componentsthat  when assumed to deviate fromtheir normal behaviour  may explain the observed behaviour.
¡¡the key idea of adapting mbd for debugging is to exchange the roles of the model and the actual system: the model reflects the behaviour of the  incorrect  program  while the test cases specify the correct result. differences between the values computed by the program and the anticipated results are used to compute model elements that  when assumed to behave differently  explain the observedmisbehaviour. the program'sinstructionsare partitioned into a set of model componentswhich formthe building blocks of explanations. each componentcorrespondsto a fragmentof the program'ssource text  and diagnoses can be expressed in terms of the original program to indicate a potential fault to the programmer  see figure 1 .
¡¡each component can operate in normal mode  denoted  ab  ¡¤   where the component functions as specified in the program  or in one or more abnormal modes  denoted ab  ¡¤   with different behaviour. intuitively  each component mode corresponds to a particular modification of the program.
example 1 the program in figure 1 can be partitioned into five components  c1 ... c1  each representing a single statement. for components representing assignments  a possible ab mode is to leave the variable's value undetermined. another possibility is to expand the assignment to a set of variables  rendering their values undetermined. for loops  the number of iterations could be altered.
¡¡the model components  a formal description of the semantics of the programming language and a set of test cases are submitted to the conformance testing module to determine if the program reflecting the fault assumptions is consistent with the test cases. a program is found consistent with a test case specification if the program possibly satisfies behaviour specified by the test case.
¡¡in case the program does not compute the anticipated result  the mbsd engine computes possible explanations in terms of mode assignments to components and invokes the conformance testing module to determine if an explanation is indeed valid. this process iterates until one  or all  possible explanations have been found.
¡¡formally  our mbsd framework is based on reiter's theory of diagnosis   extendedto handle multiplefault modes for a component. mbsd relies on test case specifications to determine if a set of fault represents is a valid explanation  where each test case describes the anticipated result for an execution using specific input values.
definition 1  debugging problem  a debugging problem is a triple where p is the source text of the program under consideration  t is a set of test cases  and c denotes the set of components derived from p.
the set c is a partition of all statements in p and contains the building blocks for explanationsreturned by the debugger. for simplicity of presentation  it is assumed that there is a separate component for each program statement.
	a	set	of	fault	assumptions ¦¤	= 
{ab  c1  ... ab  ck } is a valid explanation if the model modified such that components ci may exhibit deviating behaviour  while the remaining components exhibit normal behaviour  no longer implies incorrect behaviour.
definition 1  explanation  a fault assumption ¦¤ is a consistent explanation for a debugging problemiff for all test cases t ¡Ê t  it cannot be derived that all executions of p  altered to reflect ¦¤  violate t:
.
i and o represent the input values and assertions describing the correct output values specified in a test specification  respectively.   ¡¤   denotes the semantic function of the programming language and the fault assumptions. ¨’ denotes the application of the fault assumptions in ¦¤ and test assertions o to p. ¡Í denotes an infeasible program state.

1 int i=1
1 int x=1
1 while  i ¡Ü n  {
1 x=x + i	  correct is x = x   i  
1 i=i + 1
1 }
o : assert  x==1 
figure 1: example program and test specification
example 1 assume component c1 representing line 1 of the program in figure 1 is abnormal. in this case  there is no execution that terminates in a state satisfying x == 1. therefore  a fault in line 1 cannot explain the program's misbehaviour. in contrast  if the value of x is left undetermined after line 1  an execution exists where the program satisfies the assertion. therefore  c1 is a potential explanation.
¡¡while the definition of an explanation is intuitive  the precise test is undecidable and must be approximated. different abstractions have been proposed in the literature  ranging from purely dependency-based representations  to predicate abstraction . the following section introduces an approximation based on abstract interpretation   a technique borrowed from program analysis.
1 model construction
models developed for vhdl and early models for java were based on static analysis and represented the program as a fixed model representing the program's structure. as test cases were not taken into account  it was necessary to represent all possible executions and fault assumptions. while this approach has been used successfully to debug vhdl programs  the dynamic method lookup and exception handling lead to large models for java programs.
¡¡mayer and stumptner  propose an approach where the model is constructed dynamically  taking into account only executions that are feasible given a test case. the approach is based on abstract interpretation  of programs  generalised to take fault assumptions and test case information into account. in the following  the basic principles are introduced. more detailed presentations are given in  1; 1 .
1 abstract interpretation
the model is derived from a graph representing the effects of individual statements of the program.
definition 1  program graph  a program graph for a program p is a tuple where v is a finite set of vertices  e   v ¡Á v a set of directed edges  andv and s¦Ø ¡Ê v denote distinct entry and exit vertices.
the vertices of the program graph represent sets of program states; the edges represent the effects of program instructions  transforming sets of program states into new sets of states. the initial vertex  is associated with the initial program state i described by the test specification. an execution of a program starts in the initial state in s and proceeds following the
	s : n¡ú 1	s  = i 
s 1 =   i= 1   s  
s 1 =   x= 1   s 1   s 1
s 1 =     i¡Ü n   s 1  s 1  
	s1	s 1 =   x =x + i   s 1 
s 1 =   i =i + 1   s 1  s 1 =   i   n    s 1 
s ¦Ø =   x == 1    s 1 
figure 1: program graph and abstract equation system
edges until the final vertex ¦Ø has been reached. the program states in s¦Ø represent the result computed by the program.
example 1 figure 1 depicts the program graph derived from the program in figure 1  where ¦¤ =   . each program statement is represented as an edge  connecting the program state before the statement is executed to the successor state. the loop statement in line 1 induces two possible successors: one transition representing the case where the loop is entered  and one transition representing loop termination. starting in the initial state where   the flow graph induces a trace that traverses the loop four times and the stops in s¦Ø with
.
in case the initial state is not fully specified or parts of an intermediate state become undetermined due to fault assumptions  a potentially infinite number of paths must be followed to determine the states in s¦Ø.
¡¡to ensure every analysis of the graph is finite  the concrete program states and the concrete semantics of the program are replaced with abstract versions. formally  the abstract interpretation framework  uses complete lattices to represent concrete  s  and abstract states  s   such that
  is a safe abstraction of
notes infeasibility and  represents all possible states. resents the abstract state ordering  and  and  denote the least upper bound and greatest lower bound operator  respectively.
the key component in this framework is a pair of functions
   galois connection    where ¦Á maps sets of concrete program states to their abstract representation and ¦Ã implements the reverse mapping. the semantic functions operating on the abstract domain can then be defined as.
an approximation of the program execution can be obtained by translating the program graph into a set of equations and computing the fixpoint solution. in case the abstract lattice is of infinite height and the program graph is cyclic  widening operators     must be applied to ensure termination. widening operators selectively discard information from the abstract states to guarantee that the computation of mutually dependent equations eventually converges.
¡¡similar equations systems and fixpoint solutions can be derived for backward analyses  where for any given s ¦Ø an approximation of s is computed such that the program is guaranteed to terminate in a state in ¦Ã s ¦Ø . in our work we apply a variant of bourdoncle's bidirectional method  where forward and backward analyses are applied repeatedly to refine approximations.
example 1 using backward analysis it can be derived that if the program in figure 1 should terminate in s¦Ø with  then n ¡Ü 1 must hold in s  assuming that n has been left undetermined in i .
1 dynamic model creation
to utilise abstract interpretation for debugging  definition 1 must be lifted to the abstract domain  replacing   ¡¤   and i with their abstract counterpartsand i   respectively. for o translation is not necessary  as it is assumed that o is represented as assertions in the programming language and can be evaluated using.
¡¡in our framework  we apply the well-known non-relational interval abstraction  to approximate concrete program states. further  we use the simple abstraction described in  to ensure dynamically allocated data structures are represented finitely.
¡¡in contrast to purely static program analysis  we do not assume a fixed program graph modelling all possible executions. instead  the graph is constructed dynamically  using inputs i and assertions o fromthe test case specifications. only the paths that may be executed when starting in a state i are created. paths that contain ¡Í are ignored. once a program state is reached where multiple paths could be followed  we apply the conventionalequation-based analysis to the remaining execution. our framework can thus be placed in the middle grounds between purely static analysis  and dynamic analysis .
¡¡the algorithm for determining consistency for a program p with fault assumptions ¦¤ and test case t is outlined as follows:
1. add the assertions in t to p and apply ¦¤ to p.
1. construct the initial program graph using the forwardabstract semanticsand initial state i .
1. apply backward analysis to approximate the initial program states not implying assertion violations later in the execution.
1. analyse program graph in forward direction using thenew initial programstates to eliminate values that cannot be realised.
1. repeat from step 1 until a fixpoint is reached.
1. in case the initial program state is is ¡Í  no execution satisfying all test case specifications can be found and ¦¤ is not a valid explanation. otherwise  ¦¤ is consistent and another test case is considered.
the benefits of the dynamic approach are as follows:
 i  the equation system is concise. this is a significantadvantage when dealing with paths representing exceptions  as in java runtime exceptions may be thrown by a large number of statements. however  typically only a few of these paths are actually followed in an execution.
 ii  ambiguity in control flow is reduced compared to thepurely static approach. this is an important advantage for the precision of the abstraction of dynamic data structures  which deteriorates dramatically in the presence of loops in the program graph.
 iii  simple non-relational abstractions are sufficient to obtain good results if values for most related variables are known. expressions can be partially evaluated  leading to tighter bounds for the remaining variables.
 iv  in case all values potentially accessed by a calledmethod are known in a program state and the method does not include ab components  the fixpoint computation can be replaced with native execution.
¡¡the fixpoint analysis is limited to the regions of the execution where the values of abstract states critical to the region's execution are undetermined. as many fault assumptions affect only a minor part of a program state  execution can proceed normally in unaffected regions. consequently  many alternative branches that must be considered by purely static abstract interpretation can be eliminated.
example 1 assume	that	the	mbsd	examines ¦¤ =
{ab  c1 } for our running example. in this case  execution proceeds normally until line 1 is reached. the execution of ab  c1  leads to a state where  and x is undetermined. as i is known  the execution of statement 1 can proceed normally and no ambiguity in the control flow arises at line 1. in fact  the entire trace reduces to a linear chain. backward analysis derives that the value of x must hold after statement 1 was last executed. the remaining occurrences of x have undetermined values. since the initial state in the graph is not ¡Í  ¦¤ is consistent and is considered a valid explanation.
1 iterative refinement
the partially determined abstract states facilitate further iterative model refinement. abstraction of the effects of loops and recursive method calls can be improved if the known states before and after a loop or method call contain conflicting values. in this case  the execution is either inconsistent  or the loop  or method  must be expanded further. in case the loop  call  has been shown to terminate  for example  through syntax-based methods presented in   or a limit on the number of iterations  recursive calls  has been set by the user  the loop  call  can be expanded. as a result  values lost through widening and heap abstraction may be regained  potentially leading to a contradiction elsewhere. similar improvements can be achieved through informed restructuring of the model based on automatically derived or user-specified properties of program regions. for space reasons we illustrate the refinement approach in the context of our running example and rely on  for more detailed discussion.
example 1 assume the mbsd engine examines the candidate explanation ¦¤ = {ab  c1 }. as the loop condition is assumed incorrect  the loop condition cannot be evaluated uniquely. this implies that the number of loop iterations is not known and the program state s1 after the loop is approximated using intervals:. the upper bound of the intervals is due to the widening operator. the assertion x==1 may be satisfied in s1  leading to. backward analysis reveals that must also hold after the loop. this state conflicts with the program state before the loop  which contains
. subsequently  the loop is expanded in an attempt to prove that ¦¤ does not represent the true fault. the process repeats and stops after six expansions  leading to a state
. at this point  it can be proved
that the assertion is violated and s¦Ø : ¡Í. a subsequent backward pass derives and eliminates ¦¤ from the set of potential explanations.
1 fault assumptions/structural flaws
similar to model-based hardware diagnosis   previous mbsd approaches have great difficulty with faults that manifest as structural differences in the model. the dynamic modelling approach described here is more flexible in that fault assumptions modifying variables that were originally not affected by a component's behaviour can now be addressed appropriately. the modelling of dynamically allocated data structures benefits in particular  as the scope of fault assumptions can now be determined more precisely compared to the crude modelling in previous mbsd approaches  which led to a large fraction of undesirable explanations. together with more expressive specifications of the correct behaviour   we believe that extended fault modes can deal effectively with complex faults.
1 evaluation
this section presents experimental results obtained from the model described in the previous sections and compares the results with other mbsd approaches  as well as results obtained by slicing . readers interested in a theoretical comparison of the different models are referred to .
1 slicing
the classic principle of program slicing  is to eliminate all statements from a program that cannot influence the value of a distinguished variable at a given location in the program.
the pair denotes the slicing criterion.
the working hypothesis is that typically  only a small fraction of a program contributes to a variable's value; the rest can be pruned away to reduce debugging effort.
¡¡static backward slicing starts at the variable and location mentioned in the slicing criterion and recursively collects all statements that may influence the variable's value in any program execution. further  all statements that may cause the location to be skipped are also included. this process repeats until a fixpoint is reached. while static slices can be computed quickly even for large programs  the remaining program often remains large.
¡¡dynamic slicing aims at reducing the number of statements by considering only dependencies that arise between statements executed for a particular test case execution. similar to static slicing  dependencies for a variable are followed and all statements contributing to the variable's value are collected. while dynamic slices are typically much smaller than their static counterparts  for programs with many control dependencies or long data-flow chains  results remain similar.
example 1 the static slice of the program in figure 1 w.r.t. the slicing criterion includes statements 1  1 and 1. the remaining statements are ignored as they are not relevant for the computation of i. for this test case dynamic slicing computes the same result. the difference between the two approaches can be seen in case the loop is executed only once: the static slice for contains all statements  while the dynamic slice does not include statement 1.
1 dependency-based mbsd
a numberof dependency-basedmbsd approacheshavebeen introduced in . wotawa  has shown that these approaches provide results equivalent to static or dynamic slicing in case only a single abnormal variable is observed. in the following  we limit our attention to results obtained through slicing without explicitly stating that the same results hold for dependency-based mbsd.
1 value-based mbsd
value-based models  vbm   extend beyond simple dependency tracking and model the effects of program statements explicitly. in contrast to the abstract interpretationbased approach discussed here  the vbm does not abstract from the concrete semantics and relies on statically constructed models. while the model is effective for programs where dependency-based representations do not provide accurate results  the poor abstraction causes the model to collapse when loop iterations or recursive method calls cannot be determined precisely.
1 experimental results
a set of test programs have been used to evaluate the performance of different debugging approaches. some programs were taken from the siemens test suite 1  transcribed to java   a debugging test bench commonly used in the debugging community; others have been retained from earlier tests of the vbm and dependency-based models.
¡¡a summary of he results obtained is given in figure 1. loc denotes the number of non-comment lines in the program's source code  comp represents the number of diagnosis components used to construct explanations  sslice  dslice and exec denote the number of statements in the static slice  dynamic slice and the number of executed statements  respectively. vbm and aim denote the number of statements returned as potential explanations for the vbm and the model described in this paper  and time is the averagediagnosis time in seconds  wall-clock time  required forthe aim. the results of the aim and the vbm are limited to single fault explanations. due to limitations of the implementation of the vbm  some diagnoses listed for the aim may not be included in the vbm's results. initial experiments with multiple faults indicated that the number of explanations does not differ significantly from static slicing and does not warrant the additional overhead necessary for the aim and vbm.
¡¡for each program  n variants with different faults were created and tested with up to eight test cases per variant. the test results reported are the averages for each program over all variants and test cases. slight improvements could be observed when using two rather than a single test case; no significant differences could be detected in any of the test programs  with the exception of adder  when using more than two test cases. this can be attributed to the structure of the selected programs  where a large fraction of statements and test cases are executed for all test cases.
¡¡it can be seen that static slicing and dynamic slicing in many cases cannot improve much compared to the entire program and the statements executed in test cases. similarly  dynamic slices often improve little compared to the executed statements  as all statements contribute to the final result. comparing vbm and aim  it can be seen that the aim improves over the vbm in most cases. in fact  the case where the vbm provides fewer explanations is due to explanations missed by the vbm. comparing aim and slicing: the aim providessignificantly fewer explanations  but is computationally more demanding.  slicing approaches typically compute solutions in a few milliseconds . note that vbm and aim are not currently optimised for speed and rely on a java interpreter written in visualworks smalltalk.
1 related work
delta debugging  aims at isolating a root cause of a program failure by minimising differences between a run that exhibits a fault and a similar one that does not. differences between program states at the same point in both executions are systematically explored and minimised  resulting in a single  root cause  explaining why the program fails.
¡¡model checking has recently been applied to locate faults  1; 1  by comparing abstract execution traces leading to correct and erroneous program states. likely causes for a misbehaviour can be identified by focussing on traces that deviate only slightly from passing and failing test cases.
¡¡error traces have also been applied to synthesise potential corrections of faulty programs  given a specification of the program's correct behaviour . symbolic evaluation is used to compare symbolic representations of program states as computed by the program versus states necessary to satisfy the post condition of the program. differences in the predicates allow to heuristically synthesise replacement expressions correcting single faults in the program. the approach is able to provide corrections automatically only if a formal specification is given  which is not required for mbsd.
1 conclusion
we introduced the basic principle of model-based software debugging and illustrated a model centred around abstract simulation of programs. differences to previous approaches were outlined and results obtained using different debugging strategies were compared. notable improvements over other approaches have been achieved  in particular for  difficult  programs where traditional debugging techniques do not perform well.
¡¡the abstract interpretationbased model has been shown to achieve considerable improvement compared to slicing and previous model-based debugging approaches  with a reduction of the average number of explanations from 1% for static slicing to roughly 1%. conversely  the model is computationally more demanding and will require optimisation to be applicable to mid-sized or large programs in an interactive setting.
adder	1	1.1	1	1	1	1binsearch111111.1.1binomial11.1.1 1 11bubblesort11111hamming11111.1.1permutation111111polynom1111.11.1sumpowers11.1.1.111tcas111.1n/a1.1name	n	loc	comp	sslice	dslice	exec	vbm	aim	time  s 
total	1	1	1	1	1	1	1	1	1
%	1	1	1	1	1
figure 1: debugging results¡¡current ongoing and future work includes  i  broadening fault modes to deal with a wider range of complex faults  such as assignments to incorrect variables  missing or swapped statements  etc.  and  ii  providing simple user interaction for incremental specification of complex program behaviour. recent advances in automatic abstraction and program verification  could lead the way to an mbsd engine with a fast but powerful adaptive abstract conformance checker.
