 
current specialized planners for query processing are designed to work in local  reliable  and predictable environments. however  a number 
of problems arise in gathering information from large networks of distributed information. in this environment  the same information may re-
side in multiple places  actions can be executed in parallel to exploit distributed resources  new goals come into the system during execution  actions may fail due to problems with remote databases or net-works  and sensing may need to be interleaved with planning in order to formulate efficient queries. we have developed a planner called sage that  addresses the issues that arise in this environment. this system integrates previous work on planning  execution  replanning  and sensing and extends this work to support simultaneous and interleaved planning and execution. sage has been applied to the problem of information gathering to provide a flexible and efficient system for integrating heterogeneous and distributed data. 
1 	introduction 
the task of information gathering requires locating  retrieving  and integrating information from large numbers of distributed and heterogeneous information sources. in this environment  flexibility and efficiency are critical. the usual approach of generating a static plan for processing information and then executing it is inflexible and may be very inefficient if problems arise during query processing. the problem is that there may be many information sources from which to choose  actions may fail  the system has incomplete knowledge about 
    the research reported here was supported in part by rome laboratory of the air force systems command and the advanced research projects agency under contract number f1-c-1  and in part by the national science foundation under grant number iri-1.'}. the views and conclusions contained in this paper are those of the author and should not be interpreted as representing the official opinion or policy of rl  arpa  nsf  the u.s. government  or any person or agency connected with them. 
1 	planning 
the available information  and new goals may arise at any time. 
¡¡to address these problems  we have developed a planning system that builds on previous work on planning  execution  sensing  and replanning. the planner  which we call sage  was implemented by augmenting ucpop  penherthy and weld  1; barrett et al.  1  with the capabilities to produce parallel execution plans  wilkins  
1; knoblock  1   interleave planning and execution  ambros-ingerson  1; etzioni et al   1   support run-time variables for sensing  ambros-ingerson  1; etzioni ct al  1   perform replanning where appropriate  and plan for new goals as they arise. we have integrated all of these capabilities into a single  unified system in which planning  sensing  and replanning can be performed during execution. this allows the system to replan portions of the plan that is currently being executed  receive and plan new tasks within the context of the executing plan  and interleave sensing actions with planning in order to improve efficiency 
¡¡before describing the integration of planning and execution  we first describe the information gathering task and how it can be cast as a planning problem in a general planning framework  section 1 . next  we present our approach to tightly integrating planning and execution  section 1 . this integration is used to support planning for new goals  replanning for failure  and the interleaving of sensing actions to gather additional information for planning  section 1 . we compare this work to previous work in planning as well as information gathering and query processing  section 1 . finally  we conclude with a discussion of the contributions of the paper  section 1 . 
1 	planning for information gathering 
information gathering requires selecting  integrating  and retrieving data from distributed and heterogeneous information sources in order to satisfy a query. the relevant data must be selected from numerous  possibly overlapping or replicated sources. integrating the information may be costly  especially when combining data from different sites. retrieving the information may be time consuming due to the distribution of data and the contention for limited resources. 
to solve this problem  we have developed a planner called sage that builds on the ucpop partial-order planner  barrett et ai  1 . ucpop provides an expressive operator language that includes conjunction  negation  disjunction  existential and universal quantifiers  conditional effects  and a functional interface that allows preconditions to be implemented as lisp functions. we extended this planner to support simultaneous action execution and to tightly integrate planning and execution. the execution is presented in the next section  and the support for simultaneous actions was previously addressed in  knoblock  1  and will be briefly described here. 
   partial-order planners  such as ucpop  produce plans with actions that are unordered. however  if two actions are left unordered they can be executed in either order  but not simultaneously. to execute actions in parallel in a partial-order planner requires that  1  actions can be executed simultaneously without changing the outcome of the individual actions  and  1  any potential resource conflicts must be captured in the representation of the operators in order to avoid conflicts during execution we assume that the first condition holds  as it does in the information gathering domain described below  and we extended the planner to support the second condition. to support reasoning about resources  we added an explicit resource declaration to the action language  which describes the resources required when executing an action. we also augmented the planner to identify and remove potential resource conflicts. with these extensions  any actions left unordered in the final plan can be executed simultaneously. 
   in the remainder of this section we describe how the information gathering task is cast as a planning problem in sage. this problem requires producing a plan for generating a requested set of data. this involves selecting the sources for the data  the operations for processing the data  the sites where the operations will be performed  and the order in which to perform the operations. since data can be retrieved from multiple sources and the operations can be performed in a variety of orders  the space of possible plans is large. 
   an information gathering goal consists of a description of a set  of desired data as well as the location where that data is to be sent . for example  table 1 illustrates a goal which specifies that the set of data be sent to the output device of the sims information mediator  arens e1 a/.  1; knoblock ef a/.  1 . the goal also specifies the data to be retrieved and is defined using the syntax of the query language of the loom knowledge representation system  maccregor  1 . this particular query requests all port names of seaports that are sufficiently deep to accommodate  breakbulk  ships. 
   the initial state of a problem defines the available information sources  e.g.  databases  and the servers  e.g.  an oracle dbms  they are running on. the example shown in table 1 defines two servers  an oracle database server running on an hp workstation  called hp-oracle  and an another oracle server running on a sun workstation  called sun-oracle. both servers contain identical copies of the geo and assets databases. in addition to this information  a description of the contents 

   for this domain  sage uses a set of ten general operators to plan out. the processing of a query. they include a move operator for moving a set of data from one information source to another  a j o i n operator that combines two sets of data into a combined set of data  and a select-source operator for selecting the information source for retrieving a set of data. the other op-
erators perform additional processing of data  select  compute  and assignment  or reformulate queries using background knowledge  generalize  s p e c i a l i z e   d e f i n i t i o n   and decompose . each operator is instantiated at planning time with the particular set of data being manipulated as well as the database where the manipulation is being performed. 
¡¡consider the operator shown in table 1  which defines a join performed in the local system. this operator is used to achieve the goal of making some information available in the local knowledge base of the sims information mediator. it does this by partitioning the request into two subsets of the requested data  retrieving that information into the local system  and then joining the data together to produce the requested set of data. the a v a i l a b l e preconditions are achieved by other operators and the j o i n - p a r t i t i o n precondition is defined by a function that produces the relevant partitions of the requested data. 

	knoblock 	1 
   this planning domain differs from many of the domains that previous planning work has focused on in two significant ways. first  there are few interactions between the operators. the main source of interaction arises in handling resource conflicts when two operators require access to the same server. second  it is not sufficient to find any solution to a problem; the goal is to find an efficient solution. the first difference makes the problem somewhat easier  while the second difference makes the problem significantly harder since it may require searching a large space of plans. 
   in order to generate query access plans efficiently  we have carefully constrained the space of possible plans. we wrote the operators such that they generate only the relevant portions of the search space. some examples of this are: first  the operators only reason about joins in the local system  since joins in the remote systems will be handled by the remote database management system and the planner has no control over how or in what order these are performed. second  the operators consider only joins across data that are distributed in different information sources. it will generally be less efficient to pull two sets of information from the same information source and perform the join locally rather than in the remote source. third  since we usually do not have write access to the remote databases  information can only be moved from the remote systems to the local system or directly to the output. however  even with a set of carefully designed operators  the search space may still be very large since the operations can be performed in different orders  and there may be multiple replicated and overlapping sources from which the information can be retrieved. 
   to further constrain the overall search for an efficient plan  we also employ standard database estimation techniques to write an evaluation function to guide the search. the planner uses the evaluation function in a branch-and-bound search  estimating the cost of each intermediate plan and selecting the plan with the lowest overall execution cost. the cost of each operation is estimated by maintaining information about the size of each relation and the number of different possible values for each attribute of a relation. assuming a uniform distribution of the data  we then estimate the amount of intermediate data that will be retrieved and manipulated  which is usually the dominant cost in handling multidatabase queries. using the estimated cost of each operation  we can then compute an estimate for the over-
1 	planning 
all cost of a plan  taking into account the parallelism of some of the actions. the evaluation function allows the planner to compare different partial plans; those plans that are more expensive than the plan eventually selected will never be expanded further. 
¡¡the final plan generated for the example query in table 1 is shown in figure 1. this plan shows where the information is retrieved from and how the information is manipulated to produce the requested data. the system works backward from the goal to produce a plan to retrieve the data. in this particular plan the final move operator is used to achieve the original goal of sending the requested data to the output; it also generates the subgoal of getting the data into the local system. next  the system considers how to get the data into the local system and since the information is not available in any single information source  it selects the j o i n operator  which decomposes the original goal into two simpler information goals. each of these simpler goals is then achieved by using the select-source operator to select a relevant source for each of the requests and translate the requests into subgoals that use the terminology of the selected information source. these goals are in turn achieved by moving the information from the remote information sources into the local system. when this plan is executed  all of the information is brought into the local sims mediator  where the draft of the ship can be compared against the depth of the seaports. once the final set of data has been generated  it is sent to the output. 
   the approach of searching the space of plans to find the best one is similar to what is done in other systems for producing query plans for relational databases  selinger et a/.  1 . these systems typically generate the space of query access plans  constraining the space of plans with appropriate domain-specific heuristics  and then evaluate the plans and select the best one. an important difference from traditional query planning systems is that in those systems the source from which the information is to be retrieved is fixed  whereas part of the planning process described here includes the selection of an appropriate information source. while this makes the problem harder  it also provides a much more flexible approach to integrating distributed and heterogeneous sources of information. 
¡¡so far we have described the approach to generating query plans for information gathering in a distributed and heterogeneous environment. in addition to gener-

ating a plan  the system must also execute it. however  unlike traditional database environments  there are a number of problems and issues that arise when dealing with distributed and autonomous information sources. information sources may be unavailable  queries may fail  new information requests may arise that compete for resources with the currently executing plan  and additional information may be required to select an appropriate plan or formulate an efficient query. in the remainder of this paper we will describe how planning and execution are tightly integrated and how this integration is used to address the issues that arise during execution. 
1 	integrating planning and execution 
planning and execution are tightly integrated by considering execution as an integral part of the planning process. this is done by treating the execution of each individual action as a necessary step in completing a plan. the goal of the planner becomes producing a complete and executed plan rather than just producing a complete plan. just as achieving all of the preconditions of a plan is required for a complete plan  executing each of the actions is also part of the final result. 
   sage keeps track of the current status of every action in the plan by marking them as either unexecuted  executing  completed  or failed. this is similar to how execution was integrated into i p e m  ambros-ingerson  1 . the underlying planner  ucpop  maintains a list of flaws  which is an agenda of things that need to be done to complete a particular plan. these flaws include open conditions  which are subgoals that have not yet 
been achieved  and threats  which are potential interactions between operators that must be resolved by adding ordering or binding constraints we integrated execution in sage by adding two new types of flaws: an unexecuted action flaw and an executing action flaw. whenever a new operator is added to a plan  the corresponding flaw indicating that the action is unexecuted is also added to the agenda. the executing flaw is used to handle the fact that actions are not instantaneous and in some cases may take considerable time. a plan is not complete until all unexecuted and executing flaws have been removed. 
   the choice of when to execute an action in a plan is important  since undoing an executed action may be costly or impossible. an action cannot be executed until every precondition of the action has been both planned and achieved by executing the preceding actions. even after an action is executable  sage delays execution as long as possible to avoid committing to a partially constructed plan prematurely. once an action has been executed  it is viewed as a commitment to the plan in which the action occurs - the planner cannot consider any plans that are not refinements of the plan being executed. the idea is that the planner should find the best complete plan before any action is executed. then once execution is initiated  it resolves any failed subplans or new goals before executing the next action. this means that the planner will never execute an action until the corresponding plan is selected as the best available. 
since executing an action may take considerable time  the planner cannot simply execute an action and wait for the results. instead  sage creates a subprocess that executes the action and notifies the planner once it has completed. in order to keep track of the actions currently being executed  the corresponding unexecuted flaw is removed from the agenda and the executing flaw is added. at any one time there may be a number of actions that are all executing simultaneously. on each cycle of the planner  the system checks if any executing actions have completed. once an action is completed  the executing flaw is removed from the agenda. if it completes successfully  the action is marked as completed. other actions that depend on this action may now be executable if all of the other preceding actions have also been executed if an action fails  the failed portion of the plan is removed and then replanned  as described in the next section. 
   sage's top-level algorithm for tightly integrating planning and execution is summarized in table a. the planner starts with an initial plan  where the goals are the open conditions. initially  the set of current plans contains only this initial plan. it repeats the algorithm until it produces a plan in which every action has been executed. the planner considers only refinements of the current plans. whenever an action is executed  an ac-
tion terminates  or a new goal is added  the set of current plans is replaced by a new set containing only this new plan. the first two conditions in this algorithm ensure that the planner finds a plan with no open conditions or threats before it commits to a plan and initiates any actions. 
remove a plan from the set of current plans and apply the first applicable condition: 
  if there are any threats  resolve them by adding additional constraints to the plan. add the possible refinements to the current plans  
* if there arc any open conditions  add additional actions or ordering links to achieve them. add the possible refinements to the current plans.  as described in the next section  open conditions that contain runtime variables for sensing will be postponed.  
  if any executing actions have completed: 
- if the action completed successfully  record the results and update the plan. if the plan is complete  return the results. otherwise  replace the current plans with this new plan. 
- if the action failed  remove the failed portion of the plan  update the model to avoid generating the same plan again  and replace the current plana with this new plan. 
  if there are any new goals to solve  add them to the open conditions and replace the current plans with this new plan. 
  if any unexecuted actions are now executable  create a process to execute them and replace the current plans with this new plan. 
table 1: algorithm for planning and execution 
¡¡this algorithm supports simultaneous planning and execution. before the system initiates execution of any 
	knoblock 	1 

action  it constructs an initially complete plan. however  once execution starts  an action could fail  a new goal could arise  or the system may require additional information  sensing  to continue planning. in any of these cases  once the new open condition has been added to the list of flaws  the system can augment the executing plan to achieve these conditions while it continues executing any actions that have already been initiated. in the next section we describe these capabilities in more detail. 
1 advantages of integrating planning and execution 
integrating the planning and execution allows the system to plan for new goals as they arrive  replan failed actions  and exploit sensing operations  all while the system is executing other actions in a plan. 
1 	p l a n n i n g f o r n e w g o a l s 
interleaving planning and execution allows the system to handle new goals while the system is in the midst of executing a plan that achieves some other goals. this is important  since execution may require substantial amounts of time and it may be impractical and inefficient to wait for one task to complete before starting the next task. in addition  it may not be possible to treat the new goal as an independent task since it may compete with the executing plan for the same resources. the handling of new goals is captured in the algorithm described in table 1. when a new goal arises  the system adds this goal to the currently executing plan and then refines that plan to solve the goal. 
   consider an example where a new goal is given to the system while it is executing the plan in figure 1. assume that the system has already executed some of the actions and is in the midst of executing others  as shown in figure 1. when a new goal arises to retrieve the description of the long beach seaport  the planner notices the pending goal on the next cycle and then searches for appropriate additions to the currently executing plan to solve this goal. while the system is generating this plan  the action in progress  shown by the action in the box 
1 	planning 
with thick lines  continues to execute  since actions are run as separate processes. 
¡¡the resulting plan is shown in figure 1. the advantage of planning this new goal in the context of the existing plan is that shared work can be exploited and any potential resource conflicts are considered in the planning process. in this case  the goal requires access to the geo database  which is already in use by the other executing query. as a result  the system uses the geo database running on the sun-oracle server  since the other action that required this resource has already completed. the separate top-level goals are treated as independent goals  so if a subplan fails it will not cause unrelated goals to fail. in addition  as soon as any lop-level goal is complete  the results are sent to the calling process. this allows the planner to run continuously and return results as soon as they are obtained rather than waiting for a plan to complete. 
1 	r e p l a n n i n g f a i l e d a c t i o n s 
integrating planning and execution allows the system to gracefully handle action failures and replanning. since the planner may have expended considerable effort in executing a plan so far  we want to avoid throwing out the entire plan and starting from scratch when an action fails. instead  the planner should replan the failed portion of the plan  while maintaining as much of the executing plan as possible. this is currently supported by requiring the designer of a domain to define a set of domain-specific failure handlers. when a failure occurs  the failure handler is called with the action that failed and the type of failure  and the failure handler is expected to remove the failed portion of the plan and update the model to avoid the same failure when the failed actions are replanned. this replanning can be performed while other unaffected actions continue to execute. a more complete replanning capability could be incorporated by using the approach developed in the systematic plan adaptor  spa   hanks and weld  1   which systematically searches the space of plan modifications. 
¡¡in the information gathering domain  the ability to replan upon failure can be exploited to handle query failures by redirecting a query to a different informa-

tion source. an execution failure may occur because a database or network is down. in this case the failure 
handler would remove the actions for retrieving the data from a specific information source and would mark the information source as unavailable to avoid generating the same plan. the planner would then attempt to replan the query; if another information source is available it would generate an alternative plan 
   an example of a failed action that can be replanned is shown in figure 1. the actions in the shaded boxes are the failed actions and the actions above the failed ones are the replanned actions. since the replanned move action requires the same resource as the action currently being executed  an ordering constraint is added between these two actions. this constraint prevents the replanned move action from being executed until this other action completes. 
1 	s e n s i n g t o p l a n 
integrating planning and execution allows the system to interleave sensing actions with the planning. earlier work on sensing in planning  ambros-ingerson  1; etzioni et a/.  1  proposed the idea of incorporating run-time variables in the planner to allow the planner to reason about the sensed information. run-time variables appear in the effects of operators and essentially serve as place holders for the value or values returned by the action at the point it is executed. these variables are useful because the result can be incorporated and used in other parts of the plan. an issue that arises in the use of run-time variables is that until desired information is available  the planning may have to be postponed or a plan with all possible contingencies will have to be produced in order to deal with the possible returned values. sage supports run-time variables and delays working on any open condition that involves such a variable. however  unlike previous planners  sage can begin execution of other actions while it is waiting for the sensed information and then continue planning while these actions continue to execute. 
   for information gathering  there are two important uses of run-time variables. first  the run-time variables can be used to retrieve information from one source and that  information is then used to formulate queries to another source. second  the run-lime variables also can be used to retrieve information which is then used in the selection of the most appropriate information sources. we have already implemented the first use  which is described below  and we investigate the second in  knoblock and levy  1 . 
¡¡the capability for gathering information to use in the formulation of another query can be added to the system by adding two more operators to the domain  shown in table 1. the first operator is simply an action to execute a query in the local system and bind the result to  iresult . as in uwl  run-time variables are annotated with an exclamation mark. the only precondition of this operator is that the information is available in the local system and the only effect is that the data is bound to the result. note that the system will have to generate a subplan and execute it in order to get the information into the local system. 

	knoblock 	1 
¡¡the second operator  called use-sensed-info  retrieves information and uses it  in the formulation of another query. the heart  of this operator is the gather-data precondition  which is a function that determines whether a query can be decomposed such that some of the information can be retrieved and incorporated directly into another query. if so  then it decomposes the original query into a modified query and a 
sub-query  which will get executed first to return an answer. the result will then be inserted directly into the modified query through the run-time binding. 
¡¡consider the example query described in the previous sections. instead of executing two parallel queries  the system can first gather the information on the ship draft and incorporate that information directly into the second query  as shown in figure 1. in this plan the binding for the  max-draft   is incorporated directly into the query against the geo database. while the two queries must then be done sequentially  it will greatly reduce the amount of intermediate data that needs to be retrieved from the second query. also  there will be no local processing  so the result can be sent directly to the output. 
1 	related work 
there are a variety of systems that have tightly integrated planning with some combination of execution  sensing  and replanning. there is work on reactive planning  e.g.   firby  1; beetz and mcdermott  1    which emphasizes the ability to react to unexpected situations rather than assume that a plan will usually work. this view is appropriate for some domains  such as robot planning  but not in domains such as information gathering where the cost of execution will usually be much higher than the cost of reasoning about actions. in a partial-order planning framework  ambros-ingerson 
 developed an integrated planning  execution  and monitoring system called ipem and introduced the idea of run-time variables for sensing. olawsky and gini  focused on the tradeoffs and strategies in choosing when to sense and when to plan. etzioni et al. l1  developed a language for representing incomplete information and etzioni et al. l1  built an integrated system for planning  execution  and sensing called xii that can represent and reason about locally complete information. we have built on many of the ideas from the earlier work within the partial-order planning paradigm 
1 	planning 
and extended them to support simultaneous planning and execution and build an integrated system for information gathering. 
¡¡the other aspect to this work is the application of the planner to the problem of information gathering. the xii planner  etzioni et a/.  1   which is used in the unix softbot  etzioni and weld  1   also supports execution and sensing for information gathering. compared to sage  the softbot reasons about the information at a different level of granularity. instead of representing general actions for manipulating data  each operator corresponds to a unix command. the advantage of their approach is that it provides finer-grained control and reasoning of the information. the disadvantage is that it would be impractical to efficiently reason about and manipulate large amounts of information. information gathering is also similar to conventional query processing in databases. these systems generate a query access plan and then execute it  jarke and koch  1 . there is no choice of which information source is used and no capability for interleaving the planning and execution  performing sensing operations  replanning due to failures  or handling additional goals. 
1 	discussion 
this paper presented a planning system  called sage  which tightly integrates planning and execution  runs continuously and handles new goals as they arrive  performs sensing actions  and recovers from failures that arise  all while continuing to execute actions already in progress. the contributions of this work are twofold. first  we extended the previous work by tightly integrating these components and adding the capability to execute actions simultaneously with the planning  replanning  and sensing. second  we demonstrated that the resulting planner can be effectively applied to the problem of information gathering from distributed and heterogeneous information sources. 
¡¡in this work we started with a real-world planning application and identified the issues that had to be addressed to solve this problem. while there is a significant amount of previous work on planning that we could build on  the emphasis and assumptions in previous work do not closely match the problems that arise in this domain. for example  in terms of generating plans  the interactions between actions do arise  but they are not the dom-

in ant problem. issues that are important in this domain are finding high quality plans  exploiting parallelism in the plans  and planning and executing simultaneously to support planning for new goals  replanning and sensing. in order to put all of this work together and turn it into a practical planning system  the resulting planner makes some simplifying assumptions that may not hold in other domains. however  the basic architecture is quite general and has been demonstrated in a real-world application. 
   sage serves as the underlying query planner for the sims information mediator  arens tt ai  1; knoblock ct ai  1   the goal of sims is to provide flexible and efficient access to large numbers of information sources. we have implemented the planning  execution  replanning  and sensing as described in this paper. the current system has been used in the domains of logistics planning and trauma care and provides access to data stored in a variety of systems that  are distributed at various sites. 
acknowledgments 
thanks to the other members of the sims project  yigal arens  wei-min shen  chin chee  chun-nan hsu  jose-luis ambitc  and sheila tejada  for their work on developing the rest of the system. also  thanks to yolanda gil  kevin knight  qiang yang  sheila coyazo  and the anonymous reviewers for their comments on earlier drafts of this paper  
