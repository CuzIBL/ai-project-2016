
in this paper  we present a multi-agent control method for a large-scale network system. we propose an extension of a token-based coordination technique to improve the tradeoff between two conflicting objectives of the network system: reducing the lead time and increasing throughput. in our system  cabs  information about an agent's urgency of jobs to fulfill demanded throughput and to maintain its utilization is passed from downstream agents in the network so that upstream agents can provide necessary and sufficient jobs to bottleneck agents whose loss of capacity degrades the total system performance. we empirically evaluate cabs performance using a benchmark problem of the semiconductor fabrication process  which is a good example of a large-scale network system.
1 introduction
network systems have multiple resources that collectively perform a desired task that is not atomic but rather comprises a set of steps to be accomplished in a specific sequence. queueing theory  allen  1  has addressed analysis and control of network queueing in its steady state. nevertheless  to understand and control its dynamic behavior is considered critically important for realizing smooth operations of today's complicated network system. transportation  communication and manufacturing are typical examples of such large networks  for which uninterrupted and stable operations are required. in this paper  we use a manufacturing problem as a benchmark for controlling a large-scale network system.
　in queueing theory  little's law  little  1  states that the expected inventory of work in process  wip  equals the average lead time multiplied by the average throughput. therefore  with a fixed throughput  reducing the lead time requires wip to be reduced. however  with a variable and unpredictable manufacturing environment  reducing wip tends to decreasethroughputby cutting back job stocks of machines so that machine downtimes have a high probability of forcing idle time of other machines because of a lack of jobs to process. in this paper  we are concerned with improving the tradeoff between the lead time and the throughput in a manufacturing system with unpredictable machine failure.
　in a network system  because of connectivity of the steps to be processed  even if a system might have many overcapacity resources  the final throughput of the system is limited by the resource that has the smallest capacity  called a bottleneck . maximizing throughput of the system therefore means keeping the maximum utilization of the bottleneck resource. high utilization of the bottleneck resource is ensured by maintaining a sufficient amount of jobs before it as a safety buffer against random events that might cause its starvation. hence  to improvethe tradeoffbetween lead time and throughputof a manufacturing system  several methods have been developed to regulate wip at the lowest safe level that prevents starvation of bottleneck machines  fowler et al.  1 . however  those methods subsume that the bottleneck machines in the system are identifiable by preliminary static analyses of the problem and do not evolve over time. however  in the course of manufacturing  the bottleneck machines might shift temporarily because of unexpected random events such as machine failures that disturb the smooth flow of jobs. this phenomenon is called wandering bottlenecks. most existing solutions to the problem are rather philosophical and managerial  such as kaizen  imai  1  and theory of constraint  toc   goldratt and cox  1   with a few exceptions of identifying wandering bottlenecks  roser et al.  1 .
　to prevent starvation of bottleneck machines  lot release control to regulate workload in front of the bottleneck machines by controlling the entry of jobs in the system  glassey and resende  1  has been widely used in practice. nevertheless  it has achieved limited success because its centralized decision-making mechanism at the job entry point cannot respond to dynamics of the manufacturingsystem  such as wandering bottlenecks . rather than controlling the job entry  it is desired that jobs are processed and requested dynamically by every machine in the system as to maintain a steady flow of jobs leading to the bottleneck machines. the desired control  lot flow control  is possible only through coordinated operations of the machines. centralized control of all the machines shares the same weak point with the lot release control. a decentralized coordination method is required so that every machine decides its job request and job processing in harmony with other machines as an intelligent agent.
　in a time-critical manufacturing environment  no machine  i.e. agent  can afford to search and gather all necessary information of other machines for deciding its actions. consequently  many coordination techniques proposed in multiagent systems  jennings et al.  1; sandholm  1; faltings and nguyen  1; durfee  1  are inappropriate for our purpose. just-in-time  jit   ohno  1  is a method of the distributed manufacturing control by exchanging tokens  kanban cards  among the machines to controlflows and amounts of work  wip  in the system. in fact  jit and its extensions are instances of token-based coordination  wagner et al.  1; xu et al.  1; moyaux et al.  1  and have been widely used in manufacturing and other related fields. however  because of its simplicity  jit succeeds only in stable and leveled environments.
　in this paper  we propose an extension of the token-based coordination method: coordination for avoiding bottleneck starvation  cabs  for improving a tradeoff between a lead time and a throughput in a large-scale and uncertain network system. in cabs  agents coordinate with other agents to maintain the adequate flow of jobs to satisfy the various demands by preventing starvation of bottleneck agents. that coordination is achieved by efficient passing of messages in the system. the message includes information that enables agents to identify the bottleneck agents and hence coordinate with other agents by maintaining the desired flow of jobs to the bottleneck agents. in section 1  we explain a generic manufacturing problem and the semiconductor fabrication process used for experiments. the details of algorithms in cabs are explained in section 1. section 1 illustrates basic behaviors of cabs using an example manufacturing scenario. section 1 shows results of simulation experiments and validates the higher effectiveness of cabs than other conventional manufacturing control methods. finally  section 1 concludes the paper.
1 problem
in this section  we first describe a general model of a manufacturing problem and then introduce a semiconductor fabrication process as an exampleof the most complicatedsystems in the current manufacturing industry.
1 definition
the manufacturing problem requires processing a set of jobs j = {j1 ... jn} by a set of workstations  which are modeled as agents a = {a1 ... am} in this paper. each job jl consists of a set of steps to be processed according to its process routing that specifies precedenceconstraints among these steps. every lot of the jobs flows through agents according to its process route. each agent aj has identical pj machines to process its tj tasks. each job jl has a demand rate drl  which is the number of lots of jl to be completed in one hour. furthermore  when an agent aj processes its task tij  it takes a process time ptji. a task of the agents corresponds to a step in the jobs. hence  precedence constraints among steps create a complicated directional network of agents. presume an agent aj's task tqj is a step sil. a preceding agent of the agent aj in terms of the task tqj  apre j q   is in charge of a step and a succeeding agent  asuc j q   processes a step.
　in addition to the agents that model the workstations  two types of synthetic agents exist. one is a sink-agent for each kind of job  which receives the completed lots from the last agent of the job's process route. another synthetic agent  a source-agent  releases every job in the system by transferring it to the agent processing the first step of the job.
1 semiconductor fabrication process
semiconductor fabrication is among the most complex manufacturing processes. for example  the production steps for semiconductor manufacturingusually number a few hundred  with numerous repetitive reentrant loops. its lead time extends over a couple of months  atherton and atherton  1 .

figure 1: network of agents in a semiconductor fab
　for empirical validation of cabs  we used the measurement and improvementof manufacturingcapacity  mimac  testbed datasets of the wafer fabrication processes  fowler and robinson  1   available from arizona state university  http://www.was.asu.edu/ masmlab/home.htm . the data set specifies the production steps of semiconductor manufacture. the factory model that we have chosen for our experiments represents a factory with 1 workstations. two products  product1 and product1  are produced in the system. product1 has 1 processing steps and product1 has 1 steps. many cycles exist in the process routes involving both products. the total process time for product1 is 1 min  1 h ; for product1  it is 1 min  1 h . figure 1  which depicts the process flows of products through the workstations in the experiment problem  can be viewed as a complex network of agents.
1 coordination through requirements
in cabs  actions of the agents are coordinated using the messages transmitted among agents. an agent uses requirement information in the incoming messages from succeeding agents for making lot processing decisions and for generating messages to send to its preceding agents.
1 action selection
the cabs system utilizes token-based coordination so that an agent selects its lot-processing actions based on requirements from its succeeding agents in the process flow. cabs realizes a pull mechanism like a jit system that does not process jobs until they are  pulled  by downstream agents.
　each agent aj periodically receives a requirement for processing a task tqj from a corresponding succeeding agent asuc j q . the requirement consists of the following three types of information  detailed definitions will be given later in section 1 : time limit: time by which agent asuc j q  needs another lot for the next step of the task tqj. request rate: rate at which agent asuc j q  needs the lots for the next step of the task tqj  starting at time limit. criticality: criticality of the agent asuc j q .
　in addition to the requirement information from the succeeding agents  for each task tqj （ tj  an agent aj is assumed to have local information such as the demand rate  current wip and a total number of lots already produced.

algorithm 1 selecttask  message im      of agent aj
1:	as current wip of task tij
1:
1: sort	according to time limit  i.e.  im   .tl  of tasks
1: set fetj as the first task in etj 1: loop
1:
1:
j
// im   .cr decides criticality of a task
1:	if
1:	remove fetj from etj
1:	set fetj as the first task in etj
1:	else
1:	return fetj
1:	end if
1: end loop

　agent aj uses the requirement information from its succeeding agents for choosing the next lot to process  i.e. dispatching  when any machine of the agent aj becomes free. algorithm 1 describes the dispatching algorithm for the agent aj. it returns a task with the earliest time limit whose dispatching will not delay a task of any higher criticality beyond its time limit. in algorithms of the paper  im   .tl  im   .rr and im   .cr respectively denote requirement information of time limit  request rate and criticality for the corresponding tasks in the incoming messages of the agent. in addition  tasks mutually overlap when an intersection exists in their processing periods  i.e.   time limit - process time  of one overlaps with  current time + process time  of other .
1 message passing
dispatching of agents in cabs is decided solely on requirements from succeeding agents. hence  information in the requirement is a key to coordination among agents.
　an agent tries to meet the requirements of succeeding agents for all of its tasks. aside from meeting the requirements of succeeding agents  the agent must also minimize its workload deficit at all times for satisfying the demand rates of jobs. for example  aj's workload of a task tqj is the time required to process one lot of the task  i.e. ptjq . each agent has aggregated workloads of all of its tasks based on the demand rates of jobs. the difference between the workloads and the total processing time of the tasks that have been processed is a current workload deficit of an agent.

algorithm 1 calccriticality    of agent aj
1:	as current wip of task tij
	j	 i（{1 ，，， tj} t wijptji/pj 
// earliest time to finish current wip
1:  i （ {1 ，，， tj} set tdeji until tftj
1:	i （ {1 ，，， tj} set t pri
as total production of task tij until current time
1: j    tprij + twij  ptji
// current estimated workload deficit of
1:	j	j	 i（{1 ，，， tj}	job ti   i	j
// surplus capacity of aj
1: return twldj/scj

　an agent can recover its workload deficit by processing more lots than demand rates of jobs. the time needed to recover the deficit depends on the amount of deficit and surplus capacity available to the agent. algorithm 1 calculates an agent's criticality as a ratio of its workload deficit and surplus capacity. in cabs  an agent with a large criticality is considered a bottleneck agent. dynamic change of an agent's criticality represents wandering of bottlenecks.
　to maintain a continuous lot flow of a task tij to asuc j i  at the requested rate im i .rr  the agent requires an incoming lot flow at the same rate from the corresponding preceding
agent apre j i . however  the agent itself might need the jobs earlier and at a higher rate in order to recover its workload deficit. the agent requires jobs immediately and at the maximum rate at which it can process materials to recover the deficit rapidly. based on the requirement from the succeeding agent and its current workload deficit  the agent generates a consolidated outgoing requirement for its preceding agent. algorithm 1 describes calculation of outgoing requirement messages by the agent aj. for each tij （ tj  a requirement tuple  om i .tl om i .rr om i .cr  is generated and sent to the preceding agent apre j i .
　the agent acts to satisfy the requirement of its succeeding agent when agent aj is not critical  i.e.  its workload deficit is less than that of asuc j i   or has enough wip of other tasks to process. in this case  the agent can postpone the time algorithm 1 makerequest  message im      of agent aj

1:  i （ {1 ，，， tj} set twij as current wip of task tij
	j	j
1:
// earliest time to get starved
1: 
1: for all
1:	t	i ○ current time + t wi   pti	j
　　// earliest time to get starved of tij 1: ttlij ○ im i .tl   ptji + twij/im i .rr // time to replenish tij based on request from asuc j i 
1:	if  tcrj   im i .cr  ‥  ttlij   t ftj  then
1:	om i .tl ○ max tftji t tlij 
1:	om i .cr ○ max im i .cr tcrj 
1:	om i .rr ○ min im i .rr p	j 
1:	om   	○	j
1: om i .cr ○ tcrj 1: om i .rr ○ pj/ptji
1:	end if
1: end for 1: return om   

limit of requesting many tasks tij beyond the earliest possible timing when the current wip is emptied  i.e.  t ftji  until the last timing when the succeeding agent's request exhausts the current wip  i.e. ttlij . this situation realizes lean manufacturing  which is intended to reduce the amount of wip and shorten lead times. as for criticality  agent aj intends to pass the highest criticality along the process route by choosing a higher value of itself or its succeeding agent. the request rate is truncated only when the requested value is greater than the maximum capacity of agent aj.
　the agent prioritizes recovering its workload deficit over satisfying the succeeding agent's requirement when agent aj is critical and has no sufficient wip to process. hence  as a requirement to its preceding agent  the agent sends the values of its own time limit  criticality and request rate for the purpose.
1 simplified example scenario

figure 1: example production system
　the behavior of the algorithms mentioned above is illustrated using a simple scenario of a production system  which produces three job types  a  b  c  according to the process routes shown in fig. 1. five workstation agents  labeled one to five  and their utilization according to the demand rate of jobs is shown with the attached percentage. two failures occur in the system around the same time. agent1 fails at time 1 and recovers at time 1. agent1 fails at time 1 and recovers at time 1.

figure 1: finished job inventory

figure 1: criticality of agents
　the achieved production of the products w.r.t. to the demand is shown in fig. 1. the criticality of three agents along time is shown in fig. 1  the criticality of the other two agents is unimportant this scenario . the time line is divided into six sections  as shown in the figures.
　in the second time section  when agent1 stops receiving jobc because of a failure on agent1  its criticality rises and it requests the other job  joba  at a higher rate from agent1 to meet its workload requirement. agent1 propagates this request to agent1.
　then  in the third time section  when agent1 stops requesting jobb because of its failure  this information is also propagated by agent1 to agent1. on receiving these updated requirements  agent1 stops processing jobb and uses its full capacity to meet the requirement of agent1 by processing joba at a higher rate. because agent1's requirement of joba at a high rate is consistently met  its criticality remains low until the recovery of agent1  at time 1 . although the utilization of agent1 is higher than agent1 according to the demand rate  agent1's criticality rises during the failure and it becomes more critical  i.e. bottleneck  than agent1.
　in the fourth time section  after recovery  at time 1  agent1 requests jobb at a higher rate to recover its workload deficit. at time 1  agent1 stops dispatching joba  which has a lower criticality  of agent1  in its requirement  and uses its full capacity to dispatch jobb  which has a higher criticality  of agent1 . as agent1 starts receiving jobs instead of agent1  agent1's workload deficit and criticality decrease and those of agent1 increase.
　in the fifth time section  when criticality of agent1 and agent1 become equal at time 1  agent1 uses its capacity to produce both joba and jobb for balancing the respective criticalities of agent1 and agent1. then  criticalities of agent1 and agent1 rise at the same rate until agent1 restarts processing jobc after its recovery at time 1.
　in the sixth time section  because agent1 has a large deficit of jobc  agent1 dispatches jobc exclusively to recover this deficit and reduce its own criticality at the same time. as agent1 stops getting requests for additional joba  it stops processing joba and starts processing jobb. consequently  agent1 recovers the inventory deficit of jobb and also reduces the criticality of agent1. the system therefore recovers the deficit of all the jobs and returns to normal by time 1. although agent1 has the highest utilization in this example  it is not relevant because it is unaffected by any failure and its criticality remains low at all times.
1 experiment
we evaluated performance of cabs using data of the semiconductor manufacturing process described in section 1.
　a simulation system is developed to model a manufacturing process with agents to test the proposed algorithms in cabs. the system is built using spades  riley and riley  1  middleware  http://spades-sim.sourceforge.net   which is an agent-based discrete event simulation environment. it provides libraries and apis to build agents that interact with the world by sending and receiving time-based events.
1 experimental results
in the experiments  we induced random failures of all the workstations. the failures occurbased on the exponentialdistribution with the mtbf value as 1 min and the mttr value as 1 min. because of dynamic changes of workstations' capacity  bottleneck workstations shifted temporarily  i.e. criticality of agents changed dynamically .
　we compared the performances of cabs to those of a conventional manufacturing control method: constant releasing with earliest due date first  edd  dispatching. we were unable to make a comparison with more sophisticated methods such as those in  fowler et al.  1  because they are inapplicable to problems with wandering bottlenecks.

figure 1: throughput and lead time of product1

figure 1: throughput and lead time of product1

figure 1: aggregated result of two products
　figure 1 shows the result of throughputs and lead times for product1 with different demand rates. when demand rates are high  some agents become bottlenecks and regulate a throughput of the system when they become starved. in such cases  cabs achieved approximately equivalent throughputs with the conventional method  but required much less lead time  therefore  much less wip .
　figure 1 depicts the results of throughput and lead times for product1. this result shows that the performance of cabs is slightly worse than that of the conventional method. but because both products have similar demand rates and product1 has much longer processing time than product1  the result of product1 must have a greater impact on the performance of the entire manufacturing system. furthermore  the result shows that cabs produced product1 more than demanded because cabs tried to prevent a loss of agents' capacity caused by failures; the failures did not stop during the experiments. over-productionof product1 should be decreased thereafter if the failures cease at some time point.
　in fig. 1  the aggregated processing time is calculated as  and the aggregated lead time is calculated as. because
leadtime = processtime + waittime  this result shows that as an aggregate performance of the manufacturing system  cabs required less wait time than the conventional system  which means that cabs has less wip than the conventional method to produce comparable outputs. in other words  cabs prevented starvation of bottleneck agents  i.e.  achieving a high throughput  without increasing wip in the system  i.e.  achieving a short lead time .
1 conclusion
in this paper  we investigated coordination techniques for a large-scale agent network system. the proposed system  cabs  coordinates the action of agents through a messagepassing mechanism that is similar to other token-based coordination methods. by passing and utilizing the information of criticalities and job requirements of downstream agents  cabs can produce high throughput by preventing starvation of wandering bottleneck agents and  simultaneously  achieve short lead times by reducing the amount of inventories in the system. in experiments using data of a semiconductor fabrication process  we have validated that cabs can better improve the tradeoff between throughput and lead time than a conventional manufacturing control method can. we believe that the mechanism of cabs is suitable not only for manufacturing  but also for other network systems.
　in the current implementation of cabs  agents might change their requests to the preceding agents drastically based on the small fluctuations of information they possess. therefore  performance of cabs tends to be unstable during its execution. we plan to make agents decide their requests using a probabilistic threshold so that the behavior of cabs becomes more moderate and controllable.
