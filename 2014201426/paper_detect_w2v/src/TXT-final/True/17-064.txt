 
       this paper describes the design of a general purpose deduction engine for use in expert systems. it represents an extension of a natural deduction theorem prover that has eliminated the negation symbol in favor of c e r t a i n t y factors and has an improved method of s p l i t t i n g problems into subproblems. formulas are object-centered and are stored at nodes which are designed to control and provide sharper focus to the search. these nodes e i t h e r are pointed to by words in a d i c t i o n a r y or are created by the deduction engine in i t s attempt to solve a s p e c i f i c problem. 
1. 	i n t r o d u c t i o n 
       this paper 	describes the design of 	a general purpose deduction engine for use in expert systems. it goes beyond mycin 	  1     	 	in u t i l i z i n g more of the power 	of predicate 	l o g i c   while 	at the 	same time  	i t s treatment 	of c e r t a i n t y 	factors is 	not i n t e r t w i n e d with a p a r t i c u l a r search strategy 	 such 
as the backward chaining 	gathering of evidence for c e r t a i n t y f a c t o r evaluation used by mycin . 
       the present system employs natural deduction      1      a  which offers some advantages over r e s o l u t i o n  in that 1  it does not convert to clause form  thereby making i t s representation closer to that used by humans and saving p o t e n t i a l l y h e u r i s t i c i n f o r m a t i o n   and 1  it is easier to s p l i t a problem i n t o subproblems since expressions do not get   m u l t i p l i e d out  during the conversion to clause form. 
       the system maintains a d i c t i o n a r y of words  each word p o i n t i n g to one or more subject areas  w i t h each subject area containing formulas relevant to the subject. this enables it to process a large 
number of formulas by focusing on subject areas relevant to the query. the system has a deduction 
module whose 	primary purpose is to 	obtain answers to queries 	and w i l l 	have a 	knowledge a c q u i s i t i o n module whose purpose is to 	add new formulas to the data base and update the d i c t i o n a r y . 	this paper is concerned p r i m a r i l y with the deduction module. 
this research was supported in part by the national science foundation under grant dcr-1. 

1 	a. nevins 
children:c  is a formula-frame that is targeted for node n  and has formula f for i t s d e f i n i t i o n   and a l i s t of parents p and a l i s t of children c. although each formula is stored in the data base as part of a formula-frame  we usually w i l l just use the word  formula  as it can be tedious to keep 
making this d i s t i n c t i o n . 
	a 	substitution 	is 	a 	property 	l i s t 
 x  1 : t  1    x  n : t  n    where x  1    x  n  are variables and t   l     t n  are terms. if s is a s u b s t i t u t i o n   x   l   : t   1     x   n   : t   n     and f is a formula  then s f  is the formula which results from s u b s t i t u t i n g t   i   for x   i   in formula f  for each i = 1    n . 
       two elementary formulas pi 1  and p1  can be f u l l y   p a r t i a l l y   unified by s u b s t i t u t i o n s if pi   1  p1   1 and object 1  called the negative object  can be f u l l y   p a r t i a l l y   u n i f i e d with object 1  called the positive o b j e c t   . 
substitution s w i l l f u l l y   p a r t i a l l y   unify negative object 1 with positive object 1 if for every a t t r i b u t e : t e r m a l : t l in 1  or  for p a r t i a l u n i f i c a t i o n   at least two attribute:terms in 1 including a t t r i b u t e name  there exists an a t t r i b u t e : t e r m a1:t1 in 1 such that a1 - a1 and either  1  s   t l   - s t1  or  1  negative object t1 i s f u l l y u n i f i e d with positive object t1 by s u b s t i t u t i o n s  or  1  s tl  is of the form f r  where f is an executable function symbol and execution of f s t1  r  returns true. we w i l l refer to a u n i f i c a t i o n as p a r t i a l only if it is not f u l l . when substitution s unifies negative object 1 with p o s i t i v e object 1  it produces a residual which is empty if s 1  and s 1  are f u l l y u n i f i e d by s. otherwise  this residual is an object with the same 
name as s 1  and contains also any a t t r i b u t e : t e r m from s 1  that could not be u n i f i e d with a corresponding a t t r i b u t e : t e r m from s 1   
       for example  s u b s t i t u t i o n  x:j1hn  y:atlanta  p a r t i a l l y unifies -l name:x  age .-greater-than  1    flies: name:verb  tense:past  dest:y  with  name:john  flies: name:verb  tense:past  dest:atlanta   and would produce as output -1  where 1 is the residual  name:john  
age:greater-than 1  . 
                     however  the 	negative object would have been 	f u l l y u n i f i e d 	with  name:john  	age:1  flies: name:verb  	tense:past  	carrier:delta  
dest:atlanta  during:1   assuming that the execution of greater-than a1  returned true. 
1. 	inference rules 
       rules that are prefixed with the l e t t e r r are replacement rules and operate on a single input. rules prefixed by t involve two inputs whereas rules prefixed by s involve the s p l i t t i n g of a d i s j u n c t i o n f /g. since formula p f  w i l l be regarded as equivalent to f when p - 1  any rule which applies to p f  when p - 1 w i l l apply also to formula f. 

t1: if pl 1  and p1  are fully unified by the substitution s  where p1   1 and p1   1  then produce the iolution triple  w s ol  s  where w equal! min |p1| p1 . w is called the value of the t r i p l e . this iolution triple w i l l be targeted for some node n  as described in section 1  and then w i l l be compared with previous solution triples from node n. 
       we say that solution triple  a b .c  subsumes solution triple  dfe f  i f   treating c and f as property l i s t s   we can f u l l y unify -1 c  and f without instantiating any variables of substitution f. 

       each previous s o l u t i o n t r i p l e  a b c  of node n f i r s t is examined to see if it is subsumed by the current t r i p l e  w s 1  s . if  w s 1  s  subsumes  a b c  where a   1 and these two t r i p l e s do not have the same independent ancestor  then a in the t r i p l e  a b c  is replaced by a + w - a*w and the revised t r i p l e  a b c  i n h e r i t s the independent ancestors of  w s 1  s . after a l l previous solutions have been examined in t h i s manner  they then are reexamined to see if any subsume the current t r i p l e . 
       if the reexamination shows that  d e f  subsumes  w s 1  s  where w   1 and these two t r i p l e s do not have the same independent ancestor  then w in the current t r i p l e  w s 1  s  is replaced by d + w - d*w and the current t r i p l e i n h e r i t s the independent ancestors of  d e f . after a l l previous s o l u t i o n t r i p l e s have been reexamined in t h i s manner  the current t r i p l e is added to the l i s t of solutions for node n if it is not subsumed by a previous s o l u t i o n whose value was as great as the updated value w of the current t r i p l e  else the current t r i p l e is discarded . 
t1: if pi 1  and p1  can be p a r t i a l l y u n i f i e d   where p1   1 and p1   1  then produce as output p 1  where p - -1*min |pi| p1  and 1 is the residual of the u n i f i c a t i o n . 
t1: suppose pl 1 - b and p1  are in the data base for pl*p1   1. let p  m i n   | p 1 |   | p 1 |   . if s u b s t i t u t i o n s f u l l y u n i f i e s -1*p1  and 
p1   then produce as output p s b  . if p1   1 and s u b s t i t u t i o n s p a r t i a l l y u n i f i e s 
-1*p1  and p1   then produce as output p 1 - s b  where 1 is the residual created by the u n i f i c a t i o n . 
　　　the matcher w i l l examine the a t t r i b u t e : t e r m s from the negative object in order of occurrence  except that a p p l i c a t i o n of an a t t r i b u t e : t e r m from the negative object is delayed if the term involves an executable function symbol . when given a choice  it w i l l i n s t a n t i a t e a v a r i a b l e from the p o s i t i v e object rather than the negative object  except when a f u l l u n i f i c a t i o n is required. if a 
　　　f u l l u n i f i c a t i o n is not required  then once an a t t r i b u t e  other than name  from the negative object has one of i t s variables constrained  the i n s t a n t i a t i o n of variables associated w i t h subsequent a t t r i b u t e s of the negative object w i l l not be allowed. for example  u n i f i c a t i o n of 
 name:j  a l : x   a1:y  a1:x  a1:b  with -1 name:j  al:w  a1:d  a1:c  aa:w  for variables w x y and constants b   c   d   j would set x - w  y - d but would not i n s t a n t i a t e either x - c or w - b since s e t t i n g e i t h e r x = c or w - b would necessitate i n s t a n t i a t i o n of v a r i a b l e w from the negative object and v a r i a b l e w already was constrained to equal x by the previous a t t r i b u t e a l . instead  it would produce the residual -1 name:j  a1:c  a1:w  which l a t e r could be u n i f i e d with  name:j  a l : x   a1:y  a1:x  aa:b  for x - c and w - b. 
	a. nevins 	1 
s1: replace formula-frame  definition:   node:p  . . . .   by f i r s t creating two nodes nl and n1 where nl i n i t i a l l y i s  formulas:nil  solutions-.nil  pform:   pnode:p  
next-case:g  sibling:n1  and n1 i n i t i a l l y if  formulas:nil  solutions:nil  pform: pn1de:p  next-case:nil  sibling:nl . pn1de:p indicates that node p is the parent of t h i s node and pform:  indicates t h a t i s the formula which produced t h i s node. formula f is created and targeted for node n l . any s o l u t i o n produced by way of formula f is added to the solutions a t t r i b u t e of node n l . as soon as a single s o l u t i o n is found  the formula g w i l l be created and targeted for node n1. any v a r i a b l e 
appearing in both f and g is s u i t a b l y tagged and referred to as a labeled v a r i a b l e . a v a r i a b l e   whose value is sought as an answer to the o r i g i n a l question  is also tagged as a labeled v a r i a b l e . when attempting to u n i f y a labeled variable with an ordinary v a r i a b l e   it w i l l be the ordinary v a r i a b l e which gets i n s t a n t i a t e d . both rule tl and the subsumption tests of rule t1 are not allowed to i n s t a n t i a t e 
a labeled v a r i a b l e . each formula-frame has an a t t r i b u t e called substitution whose value is the s u b s t i t u t i o n that r e f l e c t s a l l bindings of labeled variables along the path which led to the formula. in order for a two-input inference rule to be successful  it must be able to reconcile the s u b s t i t u t i o n s i n h e r i t e d from each of i t s two inputs. the r e c o n c i l i a t i o n is accomplished by u n i f y i n g the values of corresponding variables in these s u b s t i t u t i o n s and then merging the s u b s t i t u t i o n elements to produce a consistent s u b s t i t u t i o n s. for example  if the two s u b s t i t u t i o n s were  u:z  v : f   1     w:1  and  u:y  v : f   z     x:a1  for variables u v w x y and z  then the reconciled s u b s t i t u t i o n s would be  u:1  v : f   1     w:1  x:1  y:1  z : 1   . the reconciled s u b s t i t u t i o n s then would be merged with any bindings of additional labeled variables produced by the inference r u l e to form the value of a t t r i b u t e substitution associated with the output of the r u l e . 
s1: if 	a new 	s o l u t i o n 	is added 	to 	node n  	and 
sibling is not an a t t r i b u t e of node n  then t h i s s o l u t i o n represents an answer to our o r i g i n a l question. otherwise  the solutions on the sibling node of n are examined. in p a r t i c u l a r   we use the r e c o n c i l i a t i o n process described at the end of rule s1 in order to make the s u b s t i t u t i o n associated with t h i s new s o l u t i o n consistent with the s u b s t i t u t i o n associated with a s o l u t i o n on the sibling node. if the r e c o n c i l i a t i o n is successful for some s u b s t i t u t i o n s and the two solutions had values wl and w1 r e s p e c t i v e l y   then a new s o l u t i o n t r i p l e  w h s  would be produced  where w * min w1 w1  and h is value of a t t r i b u t e pform of both n and i t s s i b l i n g m. at the pnode of n and m  the new t r i p l e would undergo the examinations described in r u l e t1 and it it at t h i s pnode that the new s o l u t i o n t r i p l e  w h s  would be assigned. it is possible that the 

1 a. nevins same solution from n might be reconciled with 
　　more than one solution on the sibling node. however  if  1  the reconciled solution  w h s  had a value w which was  = a threshold  determined from the statement of the problem  and  1  either substitution s did not instantiate any labeled variables or its instantiation of labeled variables occurred prior to the processing of n and its sibling  then this pnode and all its descendants would be designated as inactive and no more formulas involving these nodes would be processed. a node also would be designated as inactive once both its children were designated as inactive. a. control structure 
　　　the inference engine begins with a global l i s t called unprocessed  consisting of formulas that have not yet been processed by any of the inference rules. one of the unprocessed formulas on this global l i s t could be the denial of the theorem to be proved. whenever an inference rule creates a new formula  it is sent immediately to the unprocessed l i s t . while global l i s t unprocessed is non-empty  the inference engine will remove formulas from unprocessed and apply the replacement rules rl through r1. the input of a replacement rule is discarded whenever the rule is successful. any formula which survives a l l the replacement rules is applied to rule t1 and then  if it survives rule tla  is applied to rule t1. upon completion of rule t1  the formula would be transferred to a global l i s t called survivors. 
　　　when a formula is transferred to survivors  it is also transferred simultaneously to the node associated with the formula   i . e .   value of attribute node of its formula-frame . each of the i n i t i a l formulas on the unprocessed l i s t is targeted for a special node called temporary. the output of a replacement rule is targeted for the same node as the formula being replaced. however  for a formula to get sent to its node  it must f i r s t reach the survivors l i s t by completing rule t1. 
　　　the replacement rules were designed so that any formula which reaches the survivors l i s t must be either a procedural formula  a disjunction  an elementary formula  or a production rule whose premise is an elementary formula. when the unprocessed l i s t is empty  the top ranked formula is removed from the survivors l i s t and applied to the inference rules. if this top ranked formula is a procedural formula  then it is executed as a procedure  possibly sending some output formulas to the unprocessed l i s t   and then discarded. if the top ranked formula is a disjunction  then it is applied to splitting rule s1. 
　　　otherwise  it is applied to the two-input rules t1 and t1  as it earlier had been applied to tl and t1. in both instances  this formula is designated as the primary input. the attempt to apply the two-input inference rules to the primary input is called a cycle and proceeds without interruption. this attempt requires a search for secondary inputs since each of these rules requires two inputs. once a primary input has completed its cycle for t1 and t1  it is used only as a secondary input. the search for a secondary input is confined to 1  the same node as the primary input  1  nodes that are ancestors of the node associated with the primary input  and either 1  a l l nodes pointed to by the dictionary from key words in the primary input if the primary input is an elementary formula  or 1  a l l nodes pointed to by the dictionary from key words in the premise of the primary input if the primary input is a production rule. the output of a two-input inference rule  and this includes the solution triples of t1  is always targeted for the same node as the primary input. 
1. 	some observations 
　　　the object-centered representation and the a b i l i t y to unify arbitrarily nested property lists enables us to combine some of the expressiveness of semantic nets  with the deductive power of predicate logic. since a certainty factor is computed automatically for the output s  of each inference rule  useful information is thereby immediately made available to help control the search. rules t1b and t1 allow us to combine independent sources of evidence  but instead of doing it via the backward chaining gathering of evidence employed by mycin  it is done in a more incremental manner. 
　　　the splitting rules insure that problems can be decomposed without sacrificing f l e x i b i l i t y of control. the use of nodes as control elements helps to avoid the combinatorial explosion and backtracking that can result when a solution to a case forces a hopeless search of the subsequent case. it accomplishes this by generating solutions to the cases independently and resolving conflicts with the companion case only when a new solution is discovered. however  unlike   it does not attack each case in succession and then attempt to resolve conflicts afterward. it avoids a precommitment to any case by attacking the cases in parallel and resolving conflicts as they are found. 

