 
     despite the long history and descriptive simplicity of the propositional calculus  practical aspects of its implementation on the computer remain an active area of study. we propose a representation of the propositional calculus which is straightforward  yet compact and sufficiently flexible to circumvent the combinatorial difficulties posed by many problems. the methodology does not involve term-rewriting  production systems  or similar  symbol-oriented approaches  but  rather  relies on a non-canonical representation in disjunctive normal form. it has been implemented in pascal  and efficiently solves what are described in the literature as  difficult  problems. the approach  which is simple and highly structured  and perhaps more procedural than many others  may be recommended for its ease of interpretation and for incorporation as a tool in larger systems. 
1 introduction 
     despite the long history and descriptive simplicity of the propositional calculus  practical aspects of its implementation on the computer remain an active area of study   -  . boolean logic has always been a powerful tool in its own right  and  more recently  boolean modules have come to play an integral role in constraint logic programming         . the methodology described in this paper differs from these others; it does not involve term-rewriting       production systems     or similar  symbol-oriented approaches   . rather  it is somewhat of a throwback  relying on a representation in disjunctive normal form. however  the representation is not canonical  not unique   and  in exchange  it possesses a flexibility which overcomes many of the combinatorial problems associated with truth tables and such techniques  c.f.   . the algorithm  which has been implemented in pascal  successfully solves what are 
 this work was funded by code 1  nusc  newport  ri under ont code 1 program element 1n. 
automated deduction 
described in  to be  difficult  problems. furthermore  its highly structured nature lends itself well to maintaining consistency and  it is hoped  also to tracing reasoning. 
     before proceeding further  let us be a bit more specific as to the type and context of the problems which we expect to solve. we visualize a universe of discourse consisting of a set of boolean variables  predicate letters  a  b  c  etc.  each with a range of values {1  1}. a proposition p may be input by writing a formula employing letters  or variable names  and the connectives ~  a  v  =   and = in the standard fashion of the propositional calculus. such a formula is viewed  in the representation described below  as a constraint on the values of the variables. having been given a set  { p i   of propositions  that is  a knowledge base or the premise of a theorem   we shall be interested in 
 a  reducing the knowledge base: that is  providing a succinct representationof the  set of  
variable values for w	h	i	*     holds. 
 b  answering queries q: does  does p 

 c  solving boolean equations: for example  given p = p a  b  c   solve for a in terms of b and c   . we shall not treat this topic in this paper  but we note that it involves the task of describing the constraint set of  a  in a particular manner. 
in short  the critical issues are the choice of a representation for a set of propositions  i.e.  the knowledge base   and the ease with which it lends itself to the subsequent extraction of information  namely the answering of queries and the expression of the constraints relating variables. 
     a fairly naive  but reasonable  first approach to implementing these concepts might proceed as follows: one assigns a binary digit to each boolean 
모a preliminary version solves several combinatorially difficult problems in times comparable to the boolean module for prolog iii as cited in . for example the salt and mustard problem of lewis carroll  for which  according to   a solution by saturation would generate 1 clauses  takes about 1 seconds on an apollo 1 workstation. 
variable so that  for example  in a universe of three variables the elementary conjunction a b c  a and b and not c  is internally represented by the three digit binary word 1. a disjunction   or   of elementary terms is represented by a list of words  and boolean manipulations of these expressions are accomplished by applying bitwise  and  to pairs of words and concatenating lists. however  a moment's reflection reveals that  even for relatively simple problems  the combinatorial burden can become enormous. for example  in the above context  the simple proposition a  i.e.  a is true  would require four terms for  its representation  a = a b c v a b c v a b c v a b c   while in a universe of n variables it would result in 1 n-1 terms. in contrast  one's intuitive notion of the proposition a might read:  a  a = 1 and  b  the other variables are  don't care . we propose to formalize this description by introducing a new symbol * which means  any   i.e.  1 or 1. the proposition a then takes the more succinct form 1  * *  or n *'s if there are n variables . the   1   is underlined because it no longer represents a single binary digit; each place in this representation must allow for at least three symbols  1  1  or *. although not obvious  it turns out that this representation is sufficiently compact to overcome the combinatorial difficulties faced in solving most practical problems. 
1 representation 
모모모we introduce four symbols e  1  1  and * which  semantically  are intended to stand for  inconsistent  empty     false    true   and  any  true or false   with respect to a single boolean variable. more precisely  they represent sets of values which the variable may assume1 

implementation on a computer requires four numbers which we assign by means of two binary digits: 
모one could use the symbol 붯 instead of e to reflect that this is the null set; however  in  1   e is visualized as one of four symbols describing the constraints put on the range of a single boolean variable. we reserve for 붯 the more general meaning of the null set of values in the  vector space  of all the variables. 
		 1  
some useful computational aspects of the representation  1  will be described later. for the moment  we note that it was specifically chosen to possess the following property: set intersections in  1  correspond to a bitwise   a n d   of two-digit binary words in  1 . that is  

where a is taken to mean either set intersection or bitwise a n d   depending on whether we are speaking of the interpretation   1   or of the internal representation   1 . more precisely  let a two-bit computer word wa represent the set of values of a and wb those of b  then the set of values of a a b is represented by wa a n d w b . 
모모모more generally  we shall be dealing with n variables  each represented by a  digit  of the form  1  giving a total of n quaternary digits  1n binary digits . as described in the introduction these digits are interpreted as a conjunction   anding   of the corresponding variables. for  example  with n = 1  the statement ac a b takes the form 
1 a * 1 * = 1. denoting these words by lower case letters  we write general propositional expressions in the form x 1 v x 1 v x 1 . . . and store them as lists of words xi. this is simply a disjunctive normal form with conjunctions of variables  terms  represented by words  and a disjunction of terms stored as a list of those words. thus  if p and q are two propositions given by p = vxj -  list of x1 and 

where xiyi is the bitwise a n d of xi and yj  and the arrow stands for  is represented by.  
모모모the actual construction of a proposition in the computer is straightforward. negation is passed through to predicate letters which are realized by 
 1a   1b  
where ak is the kth variable. the expression itself is built up  recursively  by performing a and v operations on subexpressions according to  1a  and  1b . equals and implication are replaced by an appropriate combination of ~  a  and v. there is also some merging of terms as described in the next section. 
	shensa 	1 


automated deduction 

since we may employ the equivalent statement -qap = 붯. often p will be a knowledge base which has already been input  and reduced . in that case various queries q can be checked by forming ~q  intersecting it with p  and checking whether the resulting expression is 붯. more generally  we can also intersect p with q  to obtain one of three conclusions   q follows    ~q follows   or  q may neither be proved true nor false from the data p.  such a system evaluates expressions as logically valid  logically false  or satisfiable but not valid; thus  negation as failure never becomes an issue. 
     there is a projection procedure which allows one to consider only the relevant variables in proving a proposition and which has the potential to speed up processing  particularly in the presence of a large number of variables. we note that if x contains a variable not appearing in y  i.e.  whose digit in y is *   then the intersection of the two digits is not e and  hence  may be omitted in the determination of whether x y = 붯. consequently  one would expect to simplify the proof of p =  q by projecting p and q onto their common variables. this removes irrelevant constraints and  hopefully  a number of terms. in the presence of a large number of variables requiring several computer words for their representation  computational gains at a more basic level may also be achieved. 
     formalizing the above suggestion  we define the varset of a word x to be the set of variables active in  constrained by  x and denote it by 
		 1  
 note that the null set 붯  conceived as a word containing all e's  has all its variables constrained; each variable's set of values is empty.  next  the varset of an expression is defined as the union of the varsets 
of its words 

     aside from reducing the number of variables in a proof  projections may be used in their own right. an interesting example lies in their application to the so-called fields of production which were introduced in . to get all statements q which follow from p and which only contain certain variables or contain a particular number of variables  e.g.  at most three predicate letters   one simply projects p onto the desired variable space. other methods for speeding up deductions  such as the special treatment of binary relations between primitives  e.g.  a= b and a=b   have not yet been pursued; however  the bare skeleton  just with inclusion and no projections  seems adequate for solving many  or even most  practical problems efficiently. 

		 1  
the projection of a proper  non-null  word x on a varset v is defined by 
		 1  
that is  it retains the constraints only on those variables which are in v. the others become unconstrained; they do not appear when the expression is written as a function of predicate letters  this is best illustrated by an example. let x = a c = 1. then the active variables in x are a and c  and 
vx = { 1   1}. now  suppose that we wish to project x on the varset vc = {1}  we have i i v ac = 
ii{1} !*q  = **1 - c. proceeding to propositions  we simplify things by supposing that the words in an expression are always proper; i.e.  all words equivalent to 붯 are removed as they occur. we then 
1 software notes 
     it is clearly important that the various operations described in this paper be efficiently implemented. one of the most frequent  but less obvious  is testing a word for the presence of the digit e. to facilitate this test our software employs two words of n bits each rather than one word of 1n bits to represent n variables. we designate these words by x뫢 and xc to indicate the odd and even digits of x. under such an implementation  one has 
  1  
모such a scheme is advisable since it results in much more efficient computation. by p - 붯 we shall mean the empty list. note that a proposition reduces to 붯 if and only if it contains a contradiction. 

	shensa 	1 
where or is bitwise  or . this representation is also useful for projection. a varset is implemented as a single binary word v of n bits with a bit of 1 indicating the presence of a variable. the even and odd parts of the projection of x onto v are then given by  x뫢 or ~v  and  xe or ~v  respectively. finally  recognizing an inclusion is straightforward: xcy if and only if  x or y  = y; i.e.  this relation must hold for the even and odd parts of x and y respectively. 
1 conclusion 
     we have presented a practical  structured representation for the propositional calculus. the notation is such that a given expression may be interpreted as a symbolic formula  as a union of sets  or as a list of binary  quaternary  words implemented on a computer. the workability of our methodology  however  is empirical. it springs from the fact that  despite its naivete'  the implementation is sufficiently powerful to circumvent the combinatorial difficulties posed by many problems. it is felt that this approach  which is simple and highly structured  and perhaps more procedural than many others  may be recommended for its ease of interpretation and for incorporation as a tool in larger systems. 
