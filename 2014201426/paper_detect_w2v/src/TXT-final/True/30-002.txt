 
we present a methodology for achieving cooperation between already existing theorem provers employing different proof paradigms and/or different search controls  and using different but related logics. cooperation between the provers is achieved by periodically interchanging clauses which are selected by so-called referees. by employing referees both on the side of a sending prover and a receiving prover the communication is both success- and demanddriven  which results in a rather small communication overhead and synergetical effects. 
we report on experiments regarding the cooperation of the provers spass  setheo and discount in domains of the tptp library and with problems stemming from an application in software component retrieval. the experiments show significant improvements in the number of problems solved as well as in the solution times. 
1 	introduction 
search is a central problem solving method employed in ai systems. for most problem areas there exist many systems based on different search paradigms like branchand-bound  evolutionary algorithms  or problem decomposition. all these paradigms have different strengths and weaknesses and much effort has been invested in implementing systems suitable for dealing with hard and interesting problem instances. 
　an example for such a problem area is automated deduction. the paradigms used are problem decomposition in analytical provers and  intelligent  enumeration of logical consequences in saturation-based provers. for each paradigm there are several calculi and for each calculus different implementations  typically with many parameters allowing for different incarnations of a prover. 
　many experimental studies and prover competitions have shown that it is very difficult to find a priori the best prover for a given problem instance. therefore competition approaches where several incarnations of one prover or several provers run on different machines until 
1 	automated reasoning 
one prover is successful have been proposed  see  ertel  1  and are used in applications. however  from an economical point of view such approaches are not very efficient  since only one machine contributes to solving the instance. a cooperation of the provers would be more interesting and should also lead to finding solutions faster by achieving synergetical effects. 
　there are approaches for cooperation of homogeneous search systems that have been used for coupling different incarnations of the same prover. further  sutcliffe  proposed a concept for heterogeneous provers but failed to deliver convincing results the problems to solve in order to achieve a successful cooperation of different provers are  1  finding appropriate types of results to interchange   1  selecting useful results out of the large number of produced results  and  1  having efficient implementations of the provers. 
　in this paper  we present a general approach for achieving cooperation between search systems using different paradigms that tackles the problems mentioned above for automated deduction. our techs approach  teams for cooperative heterogeneous search  allows us to use existing provers with only small modifications  limits the amount of communication by filtering the results of a sending prover  does not unnecessarily disturb the work of receiving provers since received data is filtered with respect to current and future needs  and has the ability to integrate specialized provers. 
　our experiments with three state-of-the-art provers  namely spass  setheo and discount  show that their cooperation indeed outperforms the simple competition approach for all tested domains and all time limits. in the tested domains of the tptp   sutcliffe et al  1   techs solves up to twice as many hard problems as can be solved by the individual provers taken together. 
1 	the techs approach 
the general idea of the techs approach is to interchange selected results between the search agents of a search team in regular time intervals. the search agents are incarnations of the search systems that have been integrated into the distributed system by enhancing them with communication facilities. if there is more than one 

incarnation of a search system in the team then the incarnations have to differ in their search control. we call the phases where the search agents independently work on their problem working phases  the phases where information is exchanged cooperation phases. 
　to start the team  each agent is given either the whole problem instance to solve or the parts of the instance it can work with. the selection process of results takes place both on the side of a sending agent  by a so-called send-referee  and on the side of the receiving agent  by a so-called receive-referee. each search agent may have between 1 and n - 1 send-referees  if there are n agents in the team  and 1 or no receive-referee. 
　the task of a send-referee is to select results from the current search state of its agent that should be communicated to the other agents the send-referee is responsible for. the criteria used by a send-referee are either totally based on the success the results have had for its agent or include some general knowledge about the demands of the receiving agents. if a send-referee is responsible for the selection of results for more than one receiving agent  in most cases only success-based criteria can be used. typically send-referees evaluate results with respect to their syntactic structure and the search steps the results were involved in. 
　the task of a receive-referee is to select those results sent to its agent that are considered useful for its agent in its current state or in future states. therefore the criteria used by receive-referees either reflect the current demands and needs of its agent or try to anticipate future demands and needs. because an agent receives only a small number of results  the criteria used by receiveagents can involve more expensive computations  like the impact of a result on the current search state  than in the case of send-referees. 
1 	techs in theorem proving 
in theorem proving  the techs approach requires different provers running in parallel on different computing nodes. proof problems are specified in first-order clausal logic. the provers employ either calculi which are complete for first-order logic  universal provers  or calculi which are complete for a sub-logic of first-order logic  specialized provers . we allow the use of saturationbased and analytic calculi. 
　in the following  we first introduce the saturationbased calculi superposition and unfailing completion  and the analytical connection tableau calculus. this is because we employ provers based on these calculi in our experiments. after that  we explain in detail how the techs concept can be instantiated for provers based on the introduced calculi. since clauses are to be exchanged between the provers we must at first cope with the topic of how to extract clauses from the proof search. after that  we proceed by introducing several methods for selecting clauses  i.e. we describe possible send- and receive-referees. finally  we explain how a prover can integrate received clauses into its search state. 
1 	basics of theorem proving 
the superposition calculus   bachmair and ganzinger  1   contains several inference rules which can be applied to a set of clauses that constitute a search state. generally  its inference rules are expansion inference rules  superposition left and right  equality resolution  and equality factoring . these rules allow the generation of new clauses that are added to the search state. all inference rules are well-suited for handling equality  i.e. no equality axioms are needed. in addition to expansion rules contraction rules like rewriting or subsumption can be employed. these rules delete redundant clauses or replace clauses by simpler ones. 
　in order to show the inconsistency of a clause set c  starting with c derivations of clause sets have to be performed until a set v is derived which contains the empty clause. a theorem prover based on superposition usually maintains a set  of so-called passive clauses from which it selects and removes one clause c at a time. this clause is put into the set  of activated clauses. activated clauses are  unlike passive clauses  allowed to produce new clauses via the application of some inference rules. the inferred new clauses are put into 
initially   and  the search stops if the empty clause is derived. the indeterministic selection or 
activation step is realized by heuristic means. a heuristic associates a number  in with each and the with the smallest weight wc is selected. 
　the unfailing completion procedure   bachmair et a/.  1   essentially is a restriction of superposition to unit equations and allows for the development of efficient provers for pure equational logic. 
　the connection tableau calculus  ctc for short  works on connection tableaux for a clause set c  see  letz et a/.  1  . it employs three inference rules in order 
to transform one tableau  tree of literals  into another. the start rule attaches the literals of an input clause beneath the unmarked root node. tableau reduction unifies a literal s at the leaf of an open branch with the complement of a literal  on the same branch  and applies the substitution to the whole tableau. hence  by reduction branches can be closed. if a literal of an input clause is unifiable with the complement of the leaf literal of an open branch  extension can attach the literals of the input clause beneath the leaf literal. since the tableau must remain connected after the extension step  each non-leaf literal must be identical to the complement of one of its immediate successors in the tree  the tableau must be instantiated with this unifier  see  letz et a/.  1  . because the ctc has no specific rules for handling equality  equality axioms must possibly be added to the axiomatization. 
　in order to show the inconsistency of a set c  all tableaux derivable from the trivial tableau have to be enumerated until a closed tableau appears. this search space can be represented by a search tree. normally  tableaux enumeration procedures apply consecutively bounded iterative deepening search with backtracking  {korf  1  . in this approach iteratively larger 
	denzinger and fuchs 	1 

finite initial parts of the search tree are explored with depth-first search. 
1 	extraction of clauses 
the first step of an exchange of information is the extraction of clauses from the search states a prover has produced in a working phase. we distinguish between saturation-based and ctc-based provers. 
　the extraction of valid clauses from search states of saturation-based provers is very easy because search states are sets of clauses. even more  a theorem prover can take all interesting clauses to be selected from the actual search state at the beginning of a cooperation phase. this is because the provers only derive new clauses  delete unnecessary clauses  or simplify clauses. hence  the sequence of produced search states  clause sets  is not needed. it is sufficient to consider the most recently derived clause set. we restricted ourselves to the extraction of active clauses since these clauses are maximally contracted w.r.t. the current clause set. 
　ctc-based provers conduct a search with iterative deepening and backtracking in the search tree of all connection tableaux. a single search state is only one of these tableaux. hence  it is only possible to extract information on one proof attempt from a search state. if the proof attempt represented by the search state does not lead to a proof it might be that all clauses which can be extracted from it are unnecessary. then  sendreferees might have to chose from a pool consisting of unnecessary clauses only. this shows that clauses must be extracted from all search states enumerated during a working phase  i.e. they must essentially be extracted from the search tree of all tableaux. 
　because of the fact that the search tree of all tableaux is in general not given explicitly  clauses must be extracted from the enumerated tableaux during the search process. a possible method to do this is to utilize bottomup lemma mechanisms  see  e.g.   letz et ai  1   of connection tableau-based theorem provers. we used a second variant and extracted top-down lemmas  so-called subgoal clauses  see  fuchs  1a    from a tableau. a subgoal clause is the clause of the open leaf literals of a tableau. before a send-referee is applied to the set of extracted clauses it is reasonable to compute a minimal clause set by eliminating subsumed clauses. 
1 	realization of send-referees 
a send-referee in a system based on the techs approach consists of a pair of a filter predicate s and a selection function the prover that receives the results of the send-referee obtains those clauses in the cooperation phases that pass through the filter and that are selected by  the filter predicate s limits the set of clauses that are eligible for transmission. typically  clauses are filtered out that are redundant w.r.t. the receivers. redundant means that a receiver cannot use the clauses in its inference mechanism due to its specific logic. the selection function  can employ several 
1 	automated reasoning 
judgment functions  these functionsas-
sociate a natural number with each clause c  and c is considered the better the higher the value  c  is. 
eventually selects the clauses with the best judgments. firstly  we have developed a judgment function which considers syntactic features of clauses. it computes a weighted sum of the number of variables and two times the number of function symbols of a clause and hence prefers general short clauses which contain many variables and only few function symbols. these clauses are useful for saturation-based provers because they might often take part in contracting inferences  subsumption  rewriting . they are often also useful for ctc-based provers because open tableau branches might be closed by extending the branches with them and closing the introduced literals with reduction steps. 
　secondly  function judges the role of clauses in the search process conducted so far. it is defined by 
 ＊sub c   for a saturation-based prover  sub c  denotes the number of clauses subsumed by c  txp c  is the number of expansion inferences c was involved in. for a ctc-based prover  sub c  is the number of clauses subsumed by c after the extraction and exp c  is the number of extension or reduction inferences applied to  instances  of literals of c. if the receiver of clauses is a saturation-based prover the idea is to select clauses which may reduce the search space by subsuming other clauses without simultaneously introducing many new clauses by expanding inferences. the criterion is also sensible for receiving ctc-based provers because an uncontrolled increase of the search space caused by the additional clauses might be prevented. 
　finally  we employ the function  that judges the derivation tree of  clause w.r.t. its possible useful-
ness for the receiver. the derivation tree of a clause taken from a clause set of a saturation-based prover can partially be constructed by tracing back the inferences needed to infer the clause as far as possible  recall that clauses may be deleted during the derivation . the derivation tree of a subgoal clause of a ctc-based prover is represented by the tableau the clause was extracted from. if a clause is selected for a saturation-based prover utilizing heuristic the function considers whether clauses with a high heuristic weight regarding are part of the derivation tree. if this is the case  it might be difficult for the receiver to infer the clause on its own and hence the proof search can drastically be reduced if the clause is needed in a proof. if the receiver of a clause is a ctc-based prover and the sender a saturation-based prover  we consider whether the clause is the result of an equality inference like superposition  such clauses are especially useful for ctc-based provers since they have difficulties handling equality. if sender and receiver are ctc-based provers  such subgoal clauses are useful whose respective tableaux can only be inferred by the receiver if a high resource value is employed. then  high speed-ups can occur if such clauses can be used in a proof. 

　due to lack of space we cannot describe the referees in detail. exact descriptions of send-referees for superposition and unfailing completion provers can be found in  fuchs and denzinger  1   descriptions of sendreferees for ctc-based provers in  fuchs  1a  and  fuchs  1 . 
1 	realization of receive-referees 
a receive-referee is a selection function  which also uses judgment functions for measuring the quality of clauses. 
   our first function judges whether a received clause may be part of a proof that can quickly be found. for a saturation-based prover  is defined by judges whether both c 
and c contribute to a proof. e.g.  for superpositionbased provers  judges whether many short clauses can be derived from c and c. exact definitions of the function  for superposition and unfailing completion provers can be found in  fuchs and denzinger  1 . in our approach  ctc-based provers employ receivereferees only if they receive clauses from saturationbased provers. then  we define  as follows. if s is the set of extracted subgoal clauses of the receiving prover   there   judges 
whether c might contribute to close the tableau represented by the subgoal clause c the function simply computes the difference of the number of tableau branches which can be closed by c and the number of branches that remain open. 
   the second judgment function  prefers clauses which need not be part of a proof but are nevertheless able to decrease the search effort in future  we use this function for saturation-based provers only. the function  produces higher values if many contracting infer-
ences are possible with a clause. again  exact definitions can be found in  fuchs and denzinger  1 . 
1 	integration of clauses 
the integration of clauses into the search state of a superposition-based prover is very simple since it works on sets of clauses. thus  a clause can be integrated by adding it to the set of active clauses and performing all inferences possible with it  see  fuchs  1b  . 
　for the integration of clauses into the search state of a 
　ctc-based prover there exist two possibilities. the first is to add the new clauses to the old axioms and to perform a re-start of the proof run. the second is to avoid a re-start  to add the new clauses to the old axioms  and to continue the search at the current choice point. the first variant has the disadvantage that the whole search of a ctc-based prover is lost and must possibly be repeated. however  the variant has the advantage that it can be implemented very easily. moreover  in contrast to the second variant it guarantees that during the iterative deepening process a proof can be found in a minimal segment of the search space. since the segments usually grow exponentially  despite the repetition of parts of the work done so far proofs may then be found faster. therefore  we decided to employ the simple first variant. 
1 	experiments 
in order to reveal the power of our cooperation approach we conducted experimental studies with the well-known theorem provers spass  setheo  and discount running on different workstations of a prover network. we have chosen two different test areas: on the one hand several domains from the tptp problem library v. 1.1..  on the other hand problems stemming from an application in software component retrieval. in the following  all time limits or intervals are measured as wall clock time  which means that for the cooperative runs also the time needed for communication is included. communication was implemented in the simplest way possible  via reading from and writingin files. 
1 	experiments with t p t p domains 
we have chosen the domains boo  cat  col  and grp as our test domains. these domains cover a large number of problems with different difficulty. most problems contain unit equations so that the equational prover discount can at least obtain parts of the proof problems. 
　we coupled the provers spass  setheo  and discount in the following way. spass and setheo run in their standard settings  that were used for the cade competition casc-1 . since the discount standard heuristic addweight is very similar to that of spass  we used a goal-oriented heuristic for discount as described in  denzinger and fuchs  1 . this heuristic is not as powerful as the addweight heuristic when working alone but is well-suited for cooperation purposes. we allowed for a bidirectional information exchange between spass and setheo and between spass and discount every 1 seconds. setheo and discount did not exchange information. this is because subgoal clauses of setheo are mainly non-unit clauses which are useless for discount. further  it is not sensible to add too many equations to the input set of setheo because this increases the branching rate of the search tree too much. the referees were parameterized as follows. spass and discount selected 1 clauses for each other via send-referees  1 of these clauses were finally selected by their receive-referees. for achieving cooperation between spass and setheo  their send-referees selected 1 clauses. then  their receive-referees selected from these clauses 1 clauses in the domains col and grp  1 clauses in the domains cat and boo. 
　table 1 presents the results obtained in form of the number of hard problems solved within a certain time limit. a problem is 'hard' if none of the provers alone can solve it within 1 seconds. table 1 displays the results of the single provers  of a competitive parallel system consisting of the three provers  comp   and the results of cooperative systems consisting of spass and setheo  sp-se   spass and discount  sp-di   and of all provers  all . 
　in all tested domains  the cooperation of all provers outperforms the competitive approach for all time limits  for domain cat it even solves twice the number of problems. even with only one cooperation phase  i.e. 
	denzinger and fuchs 	1 


table 1: experiments with the tptp library: numbers of hard problems solved 

with a  1s time limit  the results are already better than the results of the single provers and the competitive approach. the boo and grp domains show that all systems contribute to the improvement in performance. it should be noted that the performance of discount alone  and in comp  is very bad due to the fact that the results of the goal-oriented heuristic are reported. but even if we  cheat  and report the results of add weight  the results of comp still are worse than the techs cooperation  while the results in cat and col would remain unchanged  for boo 1 and for grp 1 problems would be solved within the 1 seconds . 
1 	experiments w i t h software component retrieval 
besides the use of tptp domains  we have evaluated techs with problems stemming from a concrete application  namely software component retrieval. these problems are generated by the nora/hammr tool that tries to retrieve software components with deductive techniques  see  schumann and fischer  1  . there  we have the following situation. software components are available in a software library and specified by their pre- and postconditions. queries are also formulated by pre- and postconditions. in order to find a suitable library component for a given query proof tasks are constructed that check for each library component whether or not it matches the query  via plug-in compatibility . we have chosen a library and queries of list processing functions and constructed several proof problems from it. all in all  we tackled 1 provable problems. 
　in order to solve these problems  we coupled spass  discount  and setheo in the following way. we used all provers in their standard settings. whereas spass and discount were coupled in a bidirectional manner as before  we only allowed spass to send selected clauses to setheo. the integration of subgoal clauses of setheo into the search states of spass and discount decreased the performance. again  we let the provers cooperate every 1 seconds. the referees were parameterized as for domains cat and boo. 
　table 1 presents the results obtained in form of the number of problems solved within certain time limits. again  we observe a significantly better performance by the cooperation of all systems than by the competitive approach. while the competitive approach can merely 
1 	automated reasoning 
slightly increase the number of problems solvable in the time limit  all cooperative combinations significantly increase the success rate. note again that the best performance is achieved if all systems are working together  
1 	related work 
distribution and cooperation concepts for search systems have mainly been developed as homogeneous concepts. this is also true for automated theorem proving  as several overview paper indicate  see  for example   bonacina and hsiang  1  . a concept  that is by many considered heterogeneous  is a-teams  see  talukdar et a/.  1  . a-teams is a shared-memory  data flow architecture like approach in which agents working on the same type of results use the appropriate part of the shared memory as a common search state. so far  no effort has been undertaken to include tree- or graph-based search paradigms in a-teams. also  the cooperation of a-team agents is much closer than the cooperation of techs agents  since an a-teams agent communicates the results of each search step it has performed. this does not allow to use existing search systems as agents easily. in a-teams there is also no referee concept for limiting communication. 
　another concept  that has a certain heterogeneous flavor  is teamwork  denzinger  1 . teamwork has been developed to distribute automated deduction  denzinger et a/.  1  and has some similarities to techs. in teamwork  periodically the work of the search agents is evaluated by referees that use success-based criteria to judge the whole agent and to select good results. in contrast to techs  for all agents a new common start state is generated by using the state of the best agent and the selected results of the other agents. so  most of the agents are different incarnations of one search systems. other agents  called specialists  can only contribute certain results that are used to direct the search of all agents. due to the common new start state  there is no use of demand-based criteria for selecting results. 
　a truly heterogeneous search system was presented in  hogg and williams  1  for solving graph coloring problems. the system consisted of a tree-based search agent that heuristically constructed the possible colorings and a repair agent  that worked on inconsistent colorings in order to generate a consistent one. the agents communicate via a blackboard on which partial color-

tmax secs  spass setheo discount competitive sp-se sp-di all 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 table 1: experiments with software component retrieval: numbers of problems solved 

ings  called hints  are written in random intervals. the tree-based agent also randomly reads hints and chooses its node that fits to the hint to work on instead of the node its heuristic would choose. whenever the repair agent is stuck  it uses with a certain probability a hint to generate a new coloring instead of generating a random one. obviously  a knowledge-based selection using referees is not included in this approach. 
　in  sutcliffe  1  a heterogeneous cooperation concept for automated deduction was proposed. the central concept was a distributed implementation of a shared memory  a so-called tuple-space   in which each agent wrote all formulas generated by it. no selection process was involved and no existing provers could be used. therefore the experiments were not convincing. 
1 	future work 
we have presented a cooperation methodology for existing search systems and we have demonstrated that this methodology yields significant improvements in the area of automated deduction. besides testing the methodology for other areas of search  cooperation of genetic algorithms with branch and bound  for example   future work will also be directed to using other types of information than clauses. these other types include selected negative results and various control information. 
　negative results of an agent may be used by other agents to either avoid producing such results or to remove them from their search states. control information can mostly be used by agents of the same type so as to improve their search focus or to avoid searching in the same parts of the search space. but also agents of different types may gain from certain control information. 
