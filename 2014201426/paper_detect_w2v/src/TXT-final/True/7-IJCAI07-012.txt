
conditional constraint satisfaction problems  ccsps  are generalizations of classical csps that support conditional activation of variables and constraints. despite the interest emerged for ccsps in the context of modelling the intrinsic dynamism of diagnosis  structural design  and product configuration applications  a complete characterization of their computational properties and of their expressiveness is still missing. in fact  the aim of the paper is precisely to face these open research issues. first  ccsps are formally characterized in terms of a suitable fragment of first-order logic. second  the complexity of some basic reasoning tasks for ccsps is studied  by establishing completeness results for the first and the second level of the polynomial hierarchy. finally  motivated by the hardness results  an island of tractability for ccsps is identified  by extending structural decomposition methods originally proposed for csps.
1 introduction
constraint satisfaction is a static framework in its original formulation that cannot be used to model and solve decision problems in scenarios where uncertainty and dynamism come into play. indeed  a constraint satisfaction problem  csp  instance  e.g.   dechter  1   is basically a triple  var u c   where var is a finite set of variables  u is a finite domain of values  and c = {c1 c1 ... cq} is a finite set of constraints  where each ci is a pair  si ri   in which si   var is called the constraint scope  and ri   u|si| is called the constraint relation. then  by solving a csp instance  we simply mean determining whether there is a substitutionthat satisfies all constraints.
모to remove the assumption that all the variables  the domains of values  and the constraints are known beforehand and do not change over time  several generalized csp frameworks have been already proposed in the literature  see  e.g.   verfaillie and jussien  1  and the references therein . in this paper  we focus on the core of these extensions  by considering the framework for conditional constraint satisfaction problems  ccsps .
모indeed  ccsps  proposed with the name of dynamic csps in  mittal and falkenhainer  1   are csps tailored to support conditional activation of variables and constraints  which have been used in model diagnosis  structural design  and configuration problems. as an example application  one may think of an automated personal computer  pc  configurator devoted to assemble several pc components. conditional constraints may require other components to be added to the current configuration  depending on the choices made for the others. e.g.  if the motherboard does not embed a video-card  then a compatible one should be added.
모despite the interest emerged for the ccsps framework and the efforts spent in the design of specialized algorithms for their efficient solution  e.g.   soininen et al.  1; bowen and bahler  1; sabin et al.  1; gelle and faltings  1; keppens and shen  1    many aspects have not yet been investigated and several research questions are  in fact  still open. for instance  both the expressiveness and the complexity issues arising in this setting have only partially been studied in the literature  soininen et al.  1; bowen and bahler  1; mittal and falkenhainer  1 . and  more importantly  differently from the case of classical csps where several classes of instances that are efficiently solvable have been singled out  e.g.   pearson and jeavons  1; gottlob et al.  1    no island of tractability is known for ccsps  whose identification is instead crucial for applications in real world scenarios.
모the aim of this paper is precisely to shed lights on these aspects and to face the above research questions. to make our analysis formal  we shall exploit the logic-based characterization of a csp instance  cf.  kolaitis and vardi  1   as a pair  뷋 d   where d is the constraint database  i.e.  the set of all the constraint relations ri  for each constraint ci =  si ri   and 뷋 is a  fo뫇 + sentence  i.e.  an existentially quantified first-order formula with no negations or disjunctions  over the relational vocabulary consisting of the atoms ri si . within this framework  we investigate the class of those constraint satisfaction problems build over the  fo뫸 뫇 + fragment of the first-order logic  which consists of all the formulas obtained extending  fo뫇 + with the implication connective  뫸 . the rationale of this approach is that enhancing  fo뫇 + with the implication connective is a mathematically well-founded approach to model conditional activation of variables  as for it is next exemplified.
example 1. consider again the pc configuration scenario.
then  the  fo뫸 뫇 + formula:
 m motherboard m  뫇  hasnovideo m  뫸
 v c fit m v   뫇 cost v c  
states  intuitively  that a motherboard m is needed to assemble a pc; moreover  if m has no embedded video  then a video-card v fitting the requirements of m has to be chosen
 and  c is the additional cost .	
모in fact  we show that  fo뫸 뫇 + formulas characterize  in a precise  logical sense  the class of ccsps. based on this result  we then embark on a systematic study of  fo뫸 뫇 +. in summary:
 we investigate the expressive power of ccsps by depicting  in section 1  a clear picture of its relationships with other logic-based csp formalisms. the results of this comparison are graphically summarized in figure 1.
 in section 1  we study the computational complexity of some basic reasoning tasks for ccsps. we considered both the case where one is interested in finding a generic solution and the case where solutions are refined by means of some pro-orders. from our analysis  summarized in figure 1  it emerges that reasoning with ccsps is intractable  with hardness and membership results being established for various classes at the first and the second level of the polynomial hierarchy.
 motivated by the above complexity results  in section 1  we turn to identify tractable classes of  fo뫸 뫇 + formulas  by issuing restrictions on the constraints interactions. as a bad news  we show that decomposition methods for traditional csps do not guarantee the tractability of ccsps.
indeed  the np-hardness of the satisfiability problem also holds for the class of ccsps whose constraints interactions can be modelled with an acyclic primal graph  see  e.g.   dechter  1  .
 the major reason for the failure of traditional decomposition methods is that the primal graph obscures the real nature of the interactions occurring in ccsps due to the variables activation. hence  in section 1  we introduce a special graphical representation for ccsps  called implication graph  and show that satisfiability is feasible in logcfl and hence in polynomial time  over instances whose implications graphs are acyclic or have  more generally  bounded treewidth  robertson and seymour  1 .
1  fo뫸 뫇 + formulas: syntax and semantics
in this section  we propose a framework for modelling conditional activation of variables and constraints in csps  which is based on an extension of the fragment  fo뫇 + with the logical implication  as formalized next.
모an  fo뫸 뫇 + sentence  overa vocabularyr of constraint relations  is a formula  where belongs to the fragment fo뫸 뫇 + of first-order logic  defined as follows:
-  true  and  false  are in;
- any atom of the form r x   r 뫍 r  is in fo뫸 뫇 +;
- if	are in fo뫸 뫇 +  then is in
- if	  then
the set of all the variables in 뷍 is denoted by v 뷍 .
example 1. the following formula 뷍1 뫍  fo뫸 뫇 + adds some further requirements to the configuration constraints in example 1  names have been shortened  for simplicity :
 m m m  뫇  h m  뫸  v c f m v   뫇 c v c  
뫇  e m  뫸  b m  뫸  h g m h   
here  we have v 뷍1  = {m v c h}.	
모given a constraint database d and an  fo뫸 뫇 + formula 뷍  we denote by  뷍 d  the constraint satisfaction problem instance of deciding an assignment for variables in 뷍 that satisfies all the constraints over d.
모note that because of the presence of the implication connective  differently from the standard csps  a formula 뷍 뫍  fo뫸 뫇 + can be satisfied by partial assignments over v 뷍 . formally  a partial assignment 붿 for  뷍 d  is a mapping from a subset of v 뷍  to values in d. then  the 붿-reduct of 뷍 is the formula 붿 뷍  resulting from 뷍 by  1  applying all the substitutions in 붿 to the variables in 뷍  and  1  by replacing all the atoms in which a variable in v 뷍    v 붿  occurs with  false   where v 붿  denotes the variables in the domain of 붿. a solution for  뷍 d  is a partial assignment 붿 such that 붿 뷍  evaluates to true over d  denoted by d |= 붿 뷍 .
example 1. consider the database d1 containing the relations: m = { m1   m1 }  h = { m1 }  f = { m1 v1 }  c = { v1 c1   v1 c1 }  e = { m1 }  b = { m1 } and g = { m1 h1 }. then  the followings assignments are partial: 붿1 = {m/m1 v/v1 c/c1} 붿1 = {m/m1 h/h1}
모note that 붿1 is not a solution for  뷍1 d1 . on the other hand  the 붿1-reduct of 뷍1 evaluates true over d1. 
1 expressiveness of  fo뫸 뫇 + formulas
the first crucial questions for ccsps are how they relate with other approaches to deal with conditional activation of variables and constraints  and whether they are more expressive  in a precise logical sense  than classical csps. both the questions are answered in this section.
모let f be a csp formalism  i.e.  a formalism for modelling constraint satisfaction problems e.g.  a subset of fo   and let d be a constraint database. for a formula 뷋 뫍 f  let s 뷋 d  denote the set of all the solutions  and for a set of variables v  let s 뷋 d  v  denote the set obtained from s 뷋 d  by restricting each solution over the variables in v.
모let f1 and f1 be two csp formalisms. we say that f1 weakly simulates f1 if for each 뷋1 뫍 f1 there exists 뷋1 뫍 f1 such that for each constraint database d  s 뷋1 d  = s 뷋1 d  v 뷋1  . we say that f1 is more expressive than f1 iff f1 simulates f1 but f1 does not simulate f1. if f1 simulates f1 and viceversa  f1 and f1 are equivalent. if f1 does not simulate f1  and f1 does not simulate f1  we say that f1 and f1 are incomparable.

figure 1: expressiveness of  fo뫸 뫇 +.
모armed with the notions above  we compared the expressiveness of  fo뫸 뫇 + with conditional csps  ccsp s  with  fo뫇 + and with the positive existential disjunctive fragment  fo뫈 뫇 + of fo. results are summarized in figure 1.
1 comparison with conditional csps
a ccsp specification 뷇 is a tuple   where var is a set of variables  vari   var is a set of initial variables  intuitively  of the variables that are initially  active    and where the set of constraints is partitioned into compatibility  cc  and activity  ca  constraints.
모compatibility constraints are constraint atoms  as in traditional csps   while activity constraints are of the following kinds: require variable  rv : c v1 ... vk 뫸rv v ; always require variable  arv : {v1 ... vk}arv뫸 v ; require not  rn : c v1 ... vk 뫸rn v ; always require not  arn : {v1 ... vk}arn뫸 v   with {v1 ... vk v }   var.
모a ccsp instance is a pair  뷇 d   where 뷇 is a specification and d is a constraint database. a legal assignment for  뷇 d  is a partial mapping 붿 from variables in var to domain values in d. a solution is a legal assignment such that:  1  vari   v 붿 ;  1  붿 satisfies every active compatibility constraints  i.e.  those compatibility constraints whose variables are in v 붿 ; and  1  붿 satisfies every activity constraint:
  warv뫸v is satisfied if w   v 붿  implies v 뫍 v 붿 ;
  c v1 ... vk 뫸rvv is satisfied if {v1 ... vk}   v 붿  and  붿 v1  ...붿 vk   뫍 c  in d  implies v 뫍 v 붿 ;
;
  c v1 ... vk 뫸rnv is satisfied if {v1 ... vk}   v 붿  and ;
as usual  the set of all the solutions is denoted by s 뷇 d .
모we next show that  fo뫸 뫇 + formulas are  in fact  an elegant  mathematically-founded characterization of ccsps.
theorem 1.  fo뫸 뫇 + simulates ccsp.
proof  sketch . let. we build an
 fo뫸 뫇 + formula 뷍뷇 =  var vari vc뫍cc뫋ca 뷋c  where 뷋c is obtained as follows:
  if c is the compatibility constraint c v1 ... vk   then
;
  if c is the activity constraint c v1 ... vk 뫸rvv   뷋c is given by c v1 ... vk  뫸 dom v  .
note that other activity constraints can be  in fact  simulated by rv and compatibility constraints  cf.  mittal and falkenhainer  1  . moreover  w.l.o.g.  we have assumed the existence of a monadic relation dom listing all possible values for the variables - without this relation  the simulation is also possible  but would have required a much intricate construction for 뷍뷇.
모it is possible to show  details omitted for lack of space  that  for every constraint c of 뷇  a legal assignment 붿 satisfies c iff the correspondingpartial assignment 붿 of 뷍뷇 satisfies the subformula 뷋c. hence   d  it is: s 뷇 d  = s 뷍뷇 d . 
모not surprisingly  ccsps have been previously simulated by means of different logic-based frameworks. for instance   bowen and bahler  1  expressed ccsps by means of the fof logic; and   bacchus and walsh  1  discussed a rich formalism where implications can be simulated by negations and disjunctions  by introducing a specific propagation method and characterizing when this method enforces generalized arc-consistency. yet  the precise logical characterization of ccsps was unknown  which is made clear below.
theorem 1. ccsp simulates  fo뫸 뫇 +.
 proof  sketch . let 뷍 be an  fo뫸 뫇 + formula. we build a ccsp 뷇뷍 as follows.	first  all the atoms are converted into compatibility constraints.	then  for each subformula  where  and where y = {y1 ...ym}  we create m뫄k fresh variables yij  activation constraints of the form   and m arv constraints of the form {yi1 ... yik}arv뫸yi. it can be shown that for each database d  s 뷍 d  = s 뷇뷍 d  v 뷍  .
모interestingly  if 뷍 is such that the left-hand side of any implicative formula is a constraint atom only  the encoding can be adjusted not to use fresh variables. hence  we can show a stronger kind of simulation:  d  s 뷍 d  = s 뷇뷍 d . 
corollary 1. ccsp and  fo뫸 뫇 + are equivalent.
모before leaving the section  note that in  mittal and falkenhainer  1  solutions to ccsps are also required to be subset-minimal. in fact  the simulation techniques of theorem 1 and 1  in the case left sides of implications are constraint atoms  established a one-to-one correspondence between solutions of ccsps and assignments for  fo뫸 뫇 + formulas. hence  further properties on the solutions are preserved as well  but formal results are omitted.
1 comparison with other logics for csps
a comparison between csps and ccsps has been proposed in  soininen et al.  1   by focusing on a knowledge representation perspective. indeed  it is shown that ccsps are not modular representable by standard csps  i.e.  intuitively  that small changes in a ccsp may result in significant changes in any corresponding csp  which is an encoding for it.
based on the logical equivalence between ccsps and
 fo뫸 뫇 +  we can now formally compare ccsps with csps  and in fact prove that there are ccsps  formulas in  fo뫸 뫇 +  that cannot be  simulated  in  fo뫇 +. the argument is that there is no way to encode the  뫸  connective by means of conjunctions. in turn   뫸  cannot encode disjunction of atoms. thus  the following relationships hold1.
theorem 1.  fo뫸 뫇 + is such that:  1  it is more expressive than  fo뫇 +; and   1  it is incomparable with  fo뫈 뫇 +.
1 the complexity of reasoning with ccsps
let  뷍 d  be a ccsp instance. the intrinsic complexity of some basic reasoning tasks for  뷍 d  has been studied in  soininen et al.  1; mittal and falkenhainer 1 . in particular  it is known that the satisfiability problem  does there exists a partial assignment 붿 such that 붿 is a solution for  뷍 d    is np-complete.
모however  there are other important reasoning tasks that often come into play with csps  and whose complexity has not been investigated for ccsps. in this section  we explorethese issues  by focusing on the following problems:
  checking: given a partial assignment 붿  is 붿 a solution for  뷍 d  
  relevance: given a variable x  is x contained in v 붿  for some solution 붿 for  뷍 d  
  necessity: given a variable x  is x contained in v 붿  for every solution 붿 for  뷍 d  
모when moving to ccsps  these problemscan be specialized to take care of those solutions that are partial assignments. indeed  knowing whether there are solutions in which some variable is not  active  may be quite relevant. for instance  in product configuration  one may be interested in finding the configuration with the minimum number of  additional  components that  yet  meets the users' requirements.
모in order to model scenarios as above  it is convenient to refine the notion of solutions by means of some pre-order   on the set of all the possible partial assignments. accordingly  a solution 붿 for  뷍 d  is said  -minimal if for each solution 붿  it holds:. in particular  we next consider  -minimal solutions  where   is one of the following pre-orders1:
subset minimality    : 붿1  v 붿1 iff v 붿1    v 붿1 . minimum cardinality  뫞 : 붿1 뫞 붿1 iff |v 붿1 | 뫞 |v 붿1 |. weighted cardinality   : a weight w is attached to each variable  and
.
모next  we depict a complete picture of the complexity figures arising in the ccsp setting.
theorem 1. the complexity of checking  relevance  and necessity and of their variants for  -minimal solutions  is as shown in figure 1.
proof  sketch . when no pre-order is considered  results easily derive from standard results on csps. due to space limitations  we next only report the proof sketches for the variants of checking.
checking  is co-np-complete:  membership  let  뷍 d  be a ccsp instance  and let 붿 be a partial assignmentsuch that 붿 |= 뷍. consider the complementary problem of deciding whether there is an assignment 붿 such that is a solution for  뷍 d  and  does not hold. clearly  붿 can be guessed in np  while  i  and  ii  can be checked in p.
모 hardness  deciding whether a boolean formula in conjunctive normal form 붯 = c1 뫇 ... 뫇 cm over the variables
-    뫞   checkingin pco-np-cco-np-cco-np-crelevancenp-c-cpnp o logn  -cpnp-cnecessityco-np-cco-np-cpnp o logn  -cpnp-cfigure 1: complexity of ccsps  'c' stands for complete .
x1 ... xn is not satisfiable  i.e.  deciding whether there exist no truth assignments to the variables making each clause cj true  is a well-known co-np-complete problem.
모we build a ccsp instance  뷍 붯  d 붯   as follows. for each clause cj  which is w.l.o.g. of the form tj1 뫈 tj1 뫈 tj1  where tj1 is a variable xi or its negation  xi  d 붯  contains the relation rcj = { t1 t1 t1  | ti 뫍 { true   false } s.t. cj is not satisfied when tji = ti  i}. then  for each variable xi in 붯  d 붯  contains the relation rvi = {  true     false  }. finally  unsat = { 1 } is in d 붯   and no other relation is in d 붯 . the formula 뷍 붯  is of the form
  where
is a variable such that xji occurs in cj.
모let x be a truth value assignment for the variables in 붯. let 붿x denote the assignment for  뷍 붯  d 붯   such that:is mapped to  true   resp.   false   in 붿 x  iff xi is true  resp.  false  x  and such that z/1 is in 붿x iff x is not satisfying.
then  any solution is such that
; moreover  z may not occur in if and
only if there is a satisfying assignment x for 붯 such that 붿x. to conclude the proof  we can hence take an assignment xu that does not satisfy 붯 and notice that 붿xu is  -minimal   there is no satisfying assignment for 붯.
checking뫞 and checking	are co-np-complete: memberships can be shown with similar arguments as above. the hardness of checking뫞 can be shown by observing that  in the above reduction  붿xu is in fact 뫞-minimal   붿xu  minimal   there is no satisfying assignment for 붯. finally  the hardness of checking  follows by assigning unitary weights to all the variables of 뷍 붯 . 
1 restricted classes of ccsps
in the light of the intractability results of the previous section  it is relevant to single out classes of ccsps that can be efficiently solved. to this aim  we next investigate how to adapt the approaches used in traditional csps  where tractable classes are identified by structural decomposition methods  e.g.   pearson and jeavons  1; gottlob et al.  1  .
1 the hardness of acyclic structures
let 뷍 be a fo formula. the structure of constraints interactions in 뷍 can be represented by the primal graph g 뷍  =  v 뷍  e   where two variables occur in some edge of e if they appear together in a constraint atom in 뷍. we next focus on classes of primal graphs having bounded treewidth.
a tree decomposition of a graph g =  v e  is a pair
  where t =  n f  is a tree  and 뷌 is a function assigning to each vertex p 뫍 n a set of vertices 뷌 p    v   such that the following conditions are satisfied:  1   b 뫍 v    p 뫍 n such that b 뫍 뷌 p ;  1   {b d} 뫍 e   p 뫍 n such

figure 1: an exact-cover-by-1-sets instance.
that {b d}   뷌 p ;  1   b 뫍 n  the set {p 뫍 n | b 뫍 뷌 p } induces a connected subtree of t. the width of maxp뫍n |뷌 p   1|  and the treewidth of g  short: tw g   is the minimum width over all its tree decompositions.
모let l be a subset of fo. we denote by cspbtw l  the class of all the csp instances  뷋 d   where 뷋 is in l and where tw g 뷋   is bounded by a fixed constant. it is wellknown  see  e.g.   gottlob et al.  1   that satisfiability can be solved in polynomial time on cspbtw  fo뫇 + . we next show that this is not the case for cspbtw  fo뫸 뫇 +   even when further restricted on the class of acyclic instances  i.e.  those having treewidth 1 .
theorem 1. satisfiability is np-hard  even when restricted on the class cspac  fo뫸 뫇 + .
proof. let i = {i1 ... in} be a set of elements  and let s = {s1 ... sm} be a number of sets each one containing exactly three elements in i. recall that the exact-cover-by-1sets problem of deciding whether there exists a set c  
{s1 ... sm} such that
  is np-complete.
모as an example instance  figure 1 shows  on the left  the sets s1 = {i1 i1 i1}  s1 = {i1 i1 i1}  and s1 =
{i1 i1 i1}. a solution consists of the set {s1 s1}.
모we build a ccsp instance  뷍 i s  d i s   as follows. for each item ii  d i s  contains the relation rii = { sj  | sj 뫍 s and ii 뫍 sj}. for each set sj and item ii 뫍 sj  d i s  contains the relation rsji = { sj }. and  no other relation is in d i s . moreover  the formula 뷍 i s  is of the form:

. importantly  given that constraint relations in 뷍 i s  are unary  g  뷍 i s  d i s    does not contain any edge and  hence  it is trivially acyclic.
모we now claim that: there exists an exact cover of i with sets from s    뷍 i s  d i s   admits a solution.
모    let c be an exact cover. consider the assignment 붿c build as follows:  1  v 뷍 i s   = v 붿c ; and  1  xi is mapped to sj if and only if ii 뫍 sj and sj 뫍 c. note that the conjunction is satisfied by 붿c  by construction of the relation rii in d i s . hence  it remains to show that each implication of the form  is satisfied as well. we distinguish two cases. if xi is not mapped to sj  then rsji xi  evaluates false over the database  and the implication is trivially satisfied. otherwise  i.e.  if xi is mapped to sj  we must have that withis mapped to sj as well  which in fact holds by construction of 붿c.
모    assume there is a solution 붿 for  뷋 i s  d i s  . we first notice that the following properties hold on 붿:  p1  v 붿  = {x1 ... xn}; and  p1  if xi is mapped to sj in 붿  then  is mapped to sj  for each. then  we can build the set c붿 = {sj |  xi that is mapped to sj in 붿}  and notice that it is an exact cover. 
1 tractable classes
since classical approaches fail in isolating classes of tractable ccsps  we next propose and study a decomposition strategy specific for  fo뫸 뫇 + formulas. we shall focus on plain formulas  where nesting of the implication connective is not allowed. formally  a plain  fo뫸 뫇 + formula is of the form:

모모모모모모모모모모모모1뫞i뫞n where n 뫟 1  and 뷋  bi  hi are in fo뫇 +.
모in fact  arbitrary formulas can be made plain by iteratively substituting each subformula  with
; this transformation preserves
the set of all the solutions  and is feasible in quadratic time.
모let 뷍 be a plain  fo뫸 뫇 +. constraint interactions in 뷍 can be represented with the implication graph ig 뷍  =  v e   where v = v 뷍  뫋 {b1 ... bn} 뫋 {h1 ... hn} and edges have the form:  x y   between pairs of variables occurring in the same atom;  x bi  if x occurs in some atom of bi;  x hi  if x ; and  bi hi   for each subformula  bi x  뫸  yihi x yi  . e.g.  a portion of the implication graph for the exact-cover-by-1-sets instance in the proof of theorem 1  which reveals the  hidden  intricacy of the problem  is reported in figure 1   and refer to the implication
모then  the class csp i btw  fo뫸 뫇 +  is defined as the set of all the ccsps instances  뷍 d   where 뷍 is a plain formula in  fo뫸 뫇 + such that tw ig 뷍   is bounded by a fixed constant. an algorithm  called decidesolutionk  deciding whether an instance in csp i btw  fo뫇 +  has a solution is reported in figure 1.
모the algorithm works on an tree decomposition of ig 뷋  of width k  whose shape is t =  n f . roughly  it is based on a recursive procedure findsolution that receives in input a vertex v 뫍 n. each vertex is equipped with some nodes associated with variables of 뷋  denoted by v v   as well as with nodes from {b1 ... bn} and {h1 ... hn}. the sets of these nodes are denoted by b v  and h v   respectively.
모basically  findsolution guesses for each child c of v  in f   a partial assignment 붿c for v c   conforming with the assignment for 붿v   and two  states  bc and hc. the state bc  resp.  hc  is a mapping from b c   resp.  hc  to the values
{t f willf wasf}. the mapping bc bi  = t states that the conjunct must be true. in fact  when bc bi  = t  it must be the case that the atoms in bi restricted over the assignment forv are satisfied in d  short: d |= 뷇bi v  in b1 . note that the information that bc bi  = t is propagated to all
input:  뷋 d   and a k-width tree decomposition
                 of ig  뷋 d   with t =  n f ; output: true iff there is a solution 붿 for  뷍 d ;boolean function findsolution v : vertex in n; 붿v : partial assignment;bv : state for b v ; hv : state for h v  ;
begin
for each c s.t.  v c  뫍 f guess: a partial assignment 붿c for v c ; a  state  bc for b c   and a  state  hc for h c ;
check that the following conditions hold:
v 1 : d |= 뷇뷋 v ;
v 1 : for each c 뫍 n s.t.  v c  뫍 f
붿v conforms with 붿c;
b1 : for each bi 뫍 b v  bv bi  = t   d |= 뷇bi v ; b;
b1 : for each bi 뫍 b p  s.t. bp bi  = t
  v c  뫍 f  bi 뫍 b c    bp bi  = t;
b1 : for each bi 뫍 b p  s.t. bp bi  = f 뫈 wasf
       v c  뫍 f  bi 뫍 b c    bp bi  = wasf; b1 : for each bi 뫍 b p  s.t. bp bi  = willf
t;
  v c  뫍 f s.t. bi 뫍 b c  뫇  bc bi  = willf 뫈 f ;
h1 : for each hi 뫍 h v  hv hi  = t   d |= 뷇hi v ; h; h1 : for each hi 뫍 h p  s.t. hp hi  = t
  v c  뫍 f  hi 뫍 h c    hp hi  = t;
h1 : for each hi 뫍 b p  s.t. hp bi  = f 뫈 wasf;
       v c  뫍 f  hi 뫍 h c    hp hi  = wasf; h1 : for each hi 뫍 h p  s.t. hp hi  = willf
t;
  v c  뫍 f s.t. hi 뫍 h c  뫇  hc bi  = willf 뫈 f ;
i1 : for each  bi hi  뫍 b v  뫄 h v  bv bi  = t   hv hi  = t;
r1 : for each c 뫍 n s.t.  v c  뫍 f 
findsolution c 붿c bc hc ;
if this check fails then return false; else return true; end;begin  * main *  let v be the root of t; guess the sets 붿v  bv  and hv;
모check conditions  v 1    b1    h1   and  i1 ; if this check fails then return false; else return findsolution r 붿v bb hv ; end.figure 1: algorithm decidesolutionk.
the children  b1   so that all the atoms in bi are eventually satisfied. on the other hand  when bc bi  = f the algorithm must find an atom which is not true in the database  b1 . moreover  all the children are advertised that bi is false  by putting them into the state wasf in  b1   which is basically a do not care state - this is also done when bp bi  = wasf  to propagate this knowledge in the tree. note that  it may happen that bi will be made false during the computation but not in the current node v. for these cases  we use the state willf  which forces  b1  that none of its children are in state t and that there is at least a children with state willf or f. similar considerations apply to the mapping hv. eventually   i1  checks whether the implications are satisfied  while  v 1  checks whether the pure conjunctive part is satisfied.
모the proof of correctness of decidesolutionk is omitted. for the running time  we can adapt the techniques in  gottlob et al.  1  to show the following.
theorem 1. on csp i btw  fo뫸 뫇 +   satisfiability is in logcfl  hence  tractable and highly-parallelizable.
acknowledgments
this work was supported by a royal society wolfson research merit award  allowing g. gottlob to invite g. greco and t. mancini to oxford.
모in addition  g. greco's work was supported by m.i.u.r. under project  tocai.it: tecnologie orientate alla conoscenza per aggregazioni di imprese in internet .
references
 bowen and bahler  1  j. bowen and d. bahler. conditional existence of variables in generalised constraint networks. in proc. of aaai'1  pages 1  1.
 bacchus and walsh  1  f. bacchus and t. walsh. propagating logical combinations of constraints. in proc. of ijcai'1  pages 1  1.
 dechter  1  r. dechter. constraint processing. morgan kaufmann  los altos  1.
 gelle and faltings  1  e. gelle and b. faltings. solving mixed and conditional constraint satisfaction problems. constraints  1 :1  1.
 gottlob et al.  1  g. gottlob  n. leone  and f. scarcello. a comparison of structural csp decomposition methods. artif. intell.  1 :1 1.
 gottlob et al.  1  g. gottlob  n. leone  and f. scarcello. computing logcfl certificates. tcs  1-1 :1  1.
 keppens and shen  1  j. keppens and q. shen. compositional model repositories via dynamic constraint satisfaction with order-of-magnitude p