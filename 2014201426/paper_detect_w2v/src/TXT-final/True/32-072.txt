 
recently  we showed that for traditional bidirectional search with  front-to-end  evaluations  it is not the meeting of search fronts but the cost of proving the optimality of a solution that is problematic. using our improved understanding of the problem  we developed a new approach to improving this kind of search: switching to unidirectional search after the search frontiers meet for the first time  with the first solution found . this new approach shows improvements over previous bidirectional search approaches and  partly  also over the corresponding unidirectional search approaches in different domains. together with a special-purpose improvement for the tsp  this approach showed better results than the standard search algorithms using the same knowledge. 
1 introduction 
linear-space search algorithms such as dfbb  depth-first branch-and-bound   lawler and wood  1  or 
 iterative-deepening-  korf  1  can solve very difficult problems because they face no real space limitations. however  they have large search overheads if there are many distinct cost values  and if the problem graph is not a tree. so  whenever sufficient memory is available  traditional best-first search may be the best choice  since it expands the fewest nodes among all admissible algorithms using the same cost function  zhang and korf  1. since machines with larger and larger memories are becoming available  this approach can be applicable for many problems in practice  e.g.  route planning . 
　due to the optimality result of over unidirectional competitors in  dechter and pearl  1   the question may arise what to improve here. however  there is some renewed interest in bidirectional heuristic search  which can both expand fewer nodes and be faster than   kaindl and kainz  1 . still  there is some drawback involved with this kind of search: the big effort for proving the optimality of solutions found. the issue is to satisfy the specific termination condition of such searches. we address this issue by proposing a new approach that switches to unidirectional search immediately after the bidirectional search finds the first solution. 
1 	search 
　this paper is organized as follows. in order to make it selfcontained  we sketch some background material on bidirectional heuristic search. then we propose our new approach to bidirectional search that switches to unidirectional search once a solution is found. after describing a more specialpurpose improvement  we finally demonstrate both the practical relevance of some theoretical bounds derived in  kaindl and kainz  1  and the efficiency of our new search approach through presenting experimental results. 
1 	background 
first  let us be precise on what constitutes a bidirectional search. when there is one goal node explicitly given  such a search proceeds both in the forward direction from the start node s to t and in the backward direction from t to s  pohl  1 . bidirectional search is possible if for a given node n the set of parent nodes  can be determined for which there exist operators that lead from  to n. searching backwards means generating parent nodes successively from the goal node t  see  e.g.   russell and norvig  1  . in other words  backward search implements reasoning about the operators in the backward direction. 
　　bidirectional search also works correctly in cases where the costs of inverse arcs between any two nodes are different: the backward search implements reasoning in the backward direction but takes account of the cost of going in the forward direction. more formally  is the cost of an optimal path from is the cost 
of an optimal path from 
convenience only.1 all the bidirectional search algorithms dealt with in this paper work correctly under these conditions and do not require that the operators are reversible or that the cost of a path is the same in either direction. 
　　in this paper we focus on the kind of traditional bidirectional search with  front-to-end  evaluations: the heuristic evaluation functions  estimate the cost of an optimal path to the appropriate endpoint uses  as the target for the forward search  and uses s as the target for the backward search . so  we do not technically deal here with those algorithms with  front-to-front  evaluations  that perform a wave-shaping strategy: neither with 

the traditional bhffa  de champeaux and sim  1  nor with the more recent approach to non-traditional bidirectional search called perimeter search  dillenburg and nelson  1; manzini  1 . also the more recently proposed nontraditional bidirectional search with  front-to-end  evaluations  kaindl el al.  1; kaindl and kainz  1  is not dealt with in this paper. 
　so  it is sufficient here to sketch the essentials of traditional bidirectional search with  front-to-end  evaluations. we can view such a search essentially as two a*-type searches in opposite directions.1 these are performed quasisimultaneously  i.e.  on a sequential machine one node is expanded after another  but the search direction is changed at least from time to time. the decision for searching in the forward or backward direction is made anew for each node expansion  most often according to the cardinality criterion  pohl  1 : search in the direction with fewer open nodes. 
　the typical representatives of traditional bidirectional heuristic search with  front-to-end  evaluations are the two algorithms bhpa  pohl  1  and bs* |kwa  1. while bhpa explores part of the search space twice  bs* can avoid this due to its major improvements over bhpa. 1 both bhpa and bs* are admissible if  is consistent.1 we assume the availability of a consistent heuristic evaluation function  in both directions. 
　whenever the search frontiers meet at some node n  a solution is found. its cost is the cost of the path found by the forward search from s to n  plus the cost of the path found by the backward search from n to /. even when the two parts of such a solution of the forward and the backward search are optimal  however  the concatenated solution path is not necessarily optimal. therefore  such an algorithm requires a special termination condition for guaranteeing optimal solutions. the termination condition of bhpa is as follows: 
 1  
this condition essentially means that the cost of the best  least costly  complete path from s to t found so far is not larger than an estimate computed from the  in both 
search frontiers. if the heuristic used for these estimates is admissible  this path must already be an optimal solution in or-

1
   the origin is clearly bhpa  pohl  1  which can be intuitively viewed to consist of two hpa searches in opposing direc 
tions. for admissible but not consistent heuristic functions  the option to move nodes back from closed to open is important  if a new better  is found. as long as the heuristic function used is consistent  we can ignore the specific differences for our discussion here. 
1these improvements are the following: 
 i  nipping: if a node is selected for expansion which is already closed in the opposite search tree  it can just be closed without expansion. 
 ii  pruning: in the same situation  descendants of this node in the opposing open list can be removed. 
	 is said to be consistent if 	for 
all nodes m and n. if for any goal node 
that  is admissible  i.e.  the heuristic function never overestimates the minimal cost. 
der to satisfy this termination condition. implicitly this is also the condition for successful termination of the improved algorithm bs*  kwa  1   which removes all nodes whose and terminates when 
is empty. 
　since understanding this condition is important for this paper  we discuss shortly how it can be achieved  this issue is dealt with more formally in  kaindl and kainz  1  . if there is a solution path from .s to /  bhpa or bs* will terminate successfully  i.e.  by finding an optimal path  if and only if both the following conditions are satisfied: 
1.an optimal solution must have been found  that is  and 
1. at least in one of the search frontiers d of bhpa or bs* the minimum /-value must have been raised at least to the value of an optimal solution c*  that is. 
   the minimum 	of 	are at first the values and 	respectively- s i n c e i s consistent they do not exceed 	the minimum 	of 	increase 
only gradually until all the nodes with of at least one search frontier are expanded  or nipped or pruned by bs* . since the maximum of those values is used  only one of them must become  during the search  
always holds  and when an optimal solution is found  
1 switching to unidirectional search 
because of the issue of satisfying the termination condition  we devised an approach of switching from bidirectional search to unidirectional search once a solution is found. depending on the concrete instantiation of this approach  the termination condition may be satisfied earlier  or a different condition of the unidirectional search algorithm used may apply directly. 
　the first instantiation actually amounts to a simple modification of bs*. when the search frontiers meet for the first time  the search direction d with 
		 1  
is selected and kept until the end of the search. according to this condition  it chooses the open set with the higher value  and directs the whole effort of the search after the first meeting towards achieving a minimum  in that 
open set. in case of equality  the cardinality criterion is used as a tie-breaker. we call this algorithm switch-a*. 
　the second instantiation is a variant of switch-a* that utilizes the max method for dynamically improving heuristic values according to i kaindl and kainz  1. so  we call it max-switch-a*. in order to make good use of this method  the differences in one frontier used for improving the heuristic values in the other should be as high as possible. therefore  it is useful to have reached the next level of   for improving the search in the other direction. that is why max-switch-a* docs not change its search direction according to the cardinality criterion  but whenever the next level of 
	kaindl et al. 	1 


figure 1: an example of complementary nodes. 
/-values is reached in the current search direction. also after the first meeting of the search frontiers  the current search direction is kept until this condition is fulfilled. in effect  this amounts to a delay of switching. only then  the final decision for the search direction is made by max-switch-a*. 
　the third instantiation can be implemented as follows  we call it switch-dfbb-trans : 
1. perform a*-type searches in opposite directions as in bhpa or bs*  i.e.  change the search direction according to the cardinality criterion. 
1. when the search frontiers meet for the first time  determine the search direction d according to condition  1 . 
1. switch to and initialize its upper bound with 
1. perform a search with dfbb-trans in direction d  utilizing the hash table entries from the previous searches and starting from the frontier of  until its normal termination condition holds. 
　this instantiation strives to be faster  since dfbb-trans does not have to maintain a priority queue like a*. in addition  dfbb-trans does not expand nodes  in the sense of generating all the children of the expanded node at once   so it can save the generation of certain nodes that a* generates 
during node expansion. 
　other instantiations are easy to construct  since in principle this approach may switch to any unidirectional search. when  for instance   plain  dfbb or ida* is used  only linear storage is needed for the remaining search. still  the information already stored in the hash table of the bidirectional search can be used to improve efficiency  e.g.  as in bai  kaindl el a/.  1 . 
1 bidirectional search for the tsp 
we also present here another approach for improving bidirectional search that is more specific for domains where a fixed number of items is to be sequenced. in the tsp  traveling salesman problem  these items are the cities. in such a domain  it is possible to save the expansion of nodes through recognizing complementary paths in the search graph. in the following  we explain this idea specifically for the tsp while it is possible with some additional book-keeping to apply this approach to the asymmetric tsp  steiner  1  we explain here the simpler case of the symmetric tsp. 

1
　　dfbb-trans was first mentioned in  kaindl el a/.  1. it simply utilizes the approach of improving heuristic values through a transposition table  reinefeld and marsland  1 in dfbb. 
1 	search 

figure 1: a graph of bidirectional search for a tsp example. 
　the key idea is to perform a unidirectional search  that stores nodes  and to interpret every node both as a partial tour in the forward direction that it represents directly  and concurrently as a complementary tour in the backward direction. so  in just one explicitly stored search frontier  implicitly two frontiers are contained. the search must be able  of course  to identify those nodes that represent complementary tours - we call them complementary nodes. 
the example in figure 1 illustrates complementary nodes. 
let us assume that some node represents the best partial route found so far between some start city a and some currently visited city  say b  that goes through certain other cities  e.g.  let us take the set of all these cities  e.g.  and compute its set complement  e.g.  
           then the complementary node is the one that represents the best partial route found so far between the same start city  1 and the same currently visited city  in this example 1  that goes through this complementary set of cities  in this example 
　figure 1 illustrates an example of a tsp search that utilizes this idea. the graph in the left part of this figure defines the problem  and the graph in the right shows a snapshot of a corresponding search.1 the important point is that the node abd is complementary to the node a c d   and so the search can already recognize the meeting of the corresponding partial tours and therefore a complete solution. 
　apart from admissibility  the most important theoretical result about this approach is dominance over a*. that is  all the nodes expanded by either bhpa/tsp or bs*/tsp  that include this approach  must be expanded by a*. the corresponding proofs can be found in  steiner  1. 
1 experimental results 
our experiments showed promising results in several domains: mazes  like those used in  kaindl and kainz  1    route planning  like in  kwa  1j   tsp  and 1-puzzle. in all these domains  the new  switching  approach gives better results than bs* in terms of both generated nodes and running time. these results are statistically significant. in 

  
　　ln this paper we use the minimum spanning tree of the cities not yet visited as the heuristic function 

addition  we gained empirical evidence that the conjecture in  kwa  1  that bs* would become generally superior to a* for more difficult problems is invalid. in the following  we focus on the domains tsp and 1-puzzle  which are also very interesting in regard to the theoretical results presented in  kaindl and kainz  1   tsp is a domain where the  naive  approach of implementing bhpa leads to nearly twice of the node expansions compared to a*  the theoretical upper bound. the 1-puzzle with the manhattan distance heuristic  however  is a domain with very few different /values  where according to the theory in i kaindl and kainz  1  comparably many node expansions can be saved by the traditional approach of bidirectional search using  frontto-end  evaluations. so  our results are consistent with this theory and they illustrate that the bounds derived there are reasonable in practice. 
1 euclidean tsp 
first we present here our experimental results on the euclidean tsp these experiments did not attempt to achieve the best ever results in this particular domain  but they were intended to compare our new algorithms with the standard heuristic search algorithms. all the compared algorithms use no domain-specific knowledge about the euclidean tsp other than the minimum spanning tree heuristic. figure 1 shows the results for 1-city problems.1 we selected these particular results for presentation since they are reproducible using any standard pc with 1mbytes of main memory. on average  a* generated 1 nodes in 1 seconds for solving one problem instance. 
　on such problem instances  both bhpa  result is rounded to 1%  and bs* expand close to twice the number of nodes compared to a*. bs* can save only 1% of the node expansions compared to bhpa. in fact  the naive implementations explore the same space twice  and so they treat the tsp as a perfectly a*-symmetric domain as defined in  kaindl and kainz  1 . 
　the versions bhpaatsp and bs*/tsp that recognize complementary nodes as described above expand half of the nodes compared to the  naive  implementations. so  they are 

　　we do not include here results from perimeter search  since according to our experiments this approach appears not to work satisfactorily in this domain  like for maze problems as shown in i kaindl and kainz  1  . 
slightly better in terms of node expansions than a*  as they dominate a*'   hut they are actually slower than a*. 
   the best results in terms of running time achieves switchdfbb trans as presented above. after 1% of its overall node generations  it switches to dfbb-trans. at this time it has on average found a solution with cost 1 x c  which is used as the initial upper bound by dfbb-trans. note  that due to its depth-first search dfbb-trans cannot make use of complementary nodes and really works unidirectionally. while overall switch-dfbb-trans generates more nodes than a* or bs*/tsp  it is faster than both of them due to the fact that dfbb-trans is faster per node searched. 
　the only other algorithm competing here is dfbb-trans itself. however  the initial bound gained through the nearestneighbor heuristic is worse than the bound gained through the bidirectional approach running first  and within the time required for finding the better bound by switch-dfbb-trans  dfbb-trans alone cannot achieve such a good bound on its own. 
　it is intersting to compare this bidirectional approach with unidirectional approaches that first find an approximate solution and continue the search until they find an optimal solution igent and walsh  1; korf  1. for instance  in the number partitioning problem such an algorithm may often know from the solution itself that it is already optimal. our approach does not need such a domain -specific property. 
it gradually raises the minimum f-values of opend until the termination condition  1  is satisfied. while this is time consuming  our  switch  approach improves the efficiency. 
　in summary  switch dfbb-trans is better in terms of running time than all these competitors  which include the standard search algorithms that have the same knowledge available. this result is statistically significant. for example  the probability that the improvement of the running time over dfbb-trans is due to chance fluctuation is 1 percent according to a test that compares the means of the paired samples of the absolute running times  and it is even much smaller according to the same test for the data relative to the difficulty of each instance  1 percent  as well as according to the sign test  1 percent .1 in comparison with a*  this chance is even smaller than 1 percent for all these statistic tests. 

1
    for more details on the statistic tests used we refer the interested reader to  kaindl and smetana. 1. 
	kaindl et al. 	1 

1 1-puzzie 
now let us have a look on specific experimental results for finding optimal solutions to a set of  sliding-tile  1-puzzle problems.1 we compare algorithms that achieve the best published results in this domain with ida* and bs* as well as switch-a* and max-switch-a*  as presented above . all the compared algorithms use no domain-specific knowledge about the puzzle other than the manhattan distance heuristic.1 the main storage available on a convex c1 was up to 1 mbytes. 
　within this given amount of storage. a*  bhpa  bs* and max-bai-trans ikaindl and kainz  1 can store a maximum of 1 million nodes in our implementations. bida*  manzini  1  requires more storage per node  so it can store a maximum of 1 million perimeter nodes within 1 
mbytes.1 
　while max-bai-trans and bida* can find optimal solutions to all of the given instances  the traditional bestfirst searches cannot  with this amount of storage and the manhattan distance as the only knowledge source : a* solves 1 and bs* 1 from the given set of 1 problem instances  for bhpa we did not gather the complete data since they would be clearly worse than those of bs* . 
   switch-a* solves 1 instances of this set under these constraints  so in this regard it is better than both a* and bs*. on the set of 1 problem instances solvable by a*  switch-a* just expands 1% of the nodes expanded by a* and needs 1% of its time. max-switch-a* solves 1 problems of the set of 1 instances. 
　on the set of 1 problem instances solvable by both bs* and switch-a*  the latter expands 1% of the nodes expanded by bs* and needs 1% of its time.1 on average  switch-a* finds the first solution after 1%; of its overall time  and the average cost of these solutions is 1 x c*. for the overall data see table 1. this table shows that on this set of instances  our new algorithm switch-a* is as good as the best published approaches so far ikaindl and kainz  1; manzini  1 while the precise mean data might even suggest a slight improvement  statistic tests tell us that there table 1: comparison on the 1-puzzle  results relative to bs* in % . 
nodes generated running time bs* 1 1 ida* 1 1 bida*  depth 1  1 1 max-bai-trans 1 1 switch-a* 1 1 max-switch-a* 1 1 is a high chance fluctuation. so  we cannot reject the null hypothesis that switch-a* and max-bai-trans are equally good. in fact  the difference amounts to less than 1%  in effect  less than 1 second  per problem instance on average. 
　max-swilch-a*  however  improves the performance on these problems. it expands only 1 % of the nodes expanded by bs*  but due to the overhead of applying the max technique  it needs 1% of its time. still  this result is better than the results of the previously best methods bida* and max-bai-trans both in terms of the mean and the median values. it is statistically significant according to the sign test and a test that compares the means of the paired samples of the absolute running times. 
　still  the question may arise  whether the application of the max technique directly in bs* could not be better. this application was also studied in  kainz  1  and achieved improvements  but for a good utilization of this technique the search direction should stay constant at least for a while. finally  it turned out that the switching approach presented in this paper is the limit of what can be achieved by the application of max in the context of bs*. 
　the major issue with this approach is that it was not able to solve all the problem instances. however  machines with larger and larger memories are becoming available now. in contrast to several approaches to memory-bounded search like ma*  chakrabarti et al.  1   mrec  sen and bagchi  1   sma*  russell  1 and its  ghosh et al.  1  our approach showed clear improvements in running time over ida*. 
　moreover  using much improved heuristic functions like those developed by  culberson and sehaeffer  1; korf and taylor  1  would make it possible to run switch-a* and max-switch-a* even with smaller available memory. we conjecture that also switch-a* would be better under these conditions than both bida* and max-bai-trans  since these approaches perform dynamic improvements of the heuristie during their search  which may not be as effective for such improved heuristics as it is for the manhattan distance heuristic. 

plementation by manzini  in e-mail communication with him we were given some hints about it  and there was agreement about the overall effect on the relative running times due to the different implementations of ida*. the data for bida* and max-bai-trans in this table are also not exactly those reported in  kaindl and kainz  1   since not all of the problem instances are included. 

1 conclusion 
the major problem of traditional bidirectional search with 
 front-to-end  evaluations as exemplified by bhpa and bs* is the cost of satisfying the termination condition. so  we addressed this problem and developed a new approach to improving this kind of search: switching to unidirectional search after the search frontiers meet for the first time  with the first solution found . this new approach shows improvements over previous bidirectional search approaches and partly also over the corresponding unidirectional search approaches in different domains. 
appendix  glossary of notation 
start node and goal node  respectively. current search direction index; when search is in the forward direction d = 1  and when in the backward direction d=1. cost of an optimal path from s to t. cost of an optimal path from m to n if d = 1  or from n to m if d = 1. 
 cost of an optimal path from .s  to n if d = 1  or from n to t if d = 1. 
 cost of an optimal path from n to t if d - 1  or from s to n if d = 1. 
estimates of  and 
static evaluation function: 
cost of the best  least costly  complete path found so far from s to t. 
the set of open nodes in search direction d. 
the set of closed nodes in search direction d. 
