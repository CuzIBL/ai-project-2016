 
in this paper  we address a critical problem in conversation systems: limited input interpretation capabilities. when an interpretation error occurs  users often get stuck and cannot recover due to a lack of guidance from the system. to solve this problem  we present a hybrid natural language query recommendation framework that combines natural language generation with query retrieval. when receiving a problematic user query  our system dynamically recommends valid queries that are most relevant to the current user request so that the user can revise his request accordingly. compared with existing methods  our approach offers two main contributions: first  improving query recommendation quality by combining query generation with query retrieval; second  adapting generated recommendations dynamically so that they are syntactically and lexically consistent with the original user input. our evaluation results demonstrate the effectiveness of this approach.   
 
1 introduction 
mixed initiative conversation systems allow users to interact with computers using speech or natural language. however  these systems have not been used widely in practice mainly due to their limited input understanding capabilities. when interpretation errors occur  a user frequently gets stuck and cannot recover. figure 1 shows an example in which the user cannot recover from repeated interpretation errors. 
  
u1: show the mean home price and household income of pleasantville. 
s1: sorry  i don't understand you. please rephrase your request. 
 s1': sorry  i don't understand. do you mean  show the average home price and household income of pleasantville   
u1: show the median house price and household income of pleasantville. 
s1: sorry. i don't understand. please rephrase your question.  
u1 :show the mean home price and the mean household income of pleasantville 
s1: sorry  i still don't understand .... 
:  an example 
this simple dialog demonstrates two typical problems in dialog systems: limited input understanding capability and a lack of proper guidance when errors occur. limited input understanding capability is what got the user into trouble originally. in u1  the system was not able to understand  mean . moreover  from u1-u1  without any guidance from the system  the user tried twice to recover from this problem without much success. instead  if the system had responded with s1'  it would be much easier for the user to rephrase successfully.     
　to enhance a user's experience and improve the robustness of human-computer interaction  most existing approaches focus on improving a system's interpretation capability directly. nonetheless  such improvements may still be limited since they would never cover the entire range of user expressions for any non-trivial application. alternatively  we propose to improve the robustness of system-user interaction by providing proper guidance on what the system can do so that users know how to adapt their queries to those within the system's capability. figure 1 summarizes our approach. assume u contains all the possible user expressions in an application and s has all the expressions a system understands. since s is usually a subset of u  when a user query u1 is outside of s  it will cause interpretation errors. when this occurs  our system will provide proper guidance on what the system can do so that users know how to revise u1 to s1.  
 

 
　 to make a system's interpretation capability apparent to a user in context  we propose a hybrid query recommendation framework in which we combine a retrieval-based approach with dynamic query generation. as a result  the hybrid system not only recommends queries based on the examples from a query corpus. it also dynamically composes new queries so that it can recommend queries that are close to the user's original intent  which might be beyond the scope of pre-stored examples.  
     our approach is embodied in an intelligent multimodal conversation system supporting four different applications including a real estate application that helps potential buyers to search for residential properties  zhou et al.  1 . in this system  users may enter their queries using multiple input modalities such as speech  text  and gui.  in this work  we focus on queries typed in as text. to respond to a user's request  the system dynamically generates a multimedia presentation that includes automatically generated spoken utterances and graphics. when interpretation errors occur  the system dynamically generates several recommendations so that the user can select one of them to replace the original query or make further revisions if desired. 
　in the rest of the paper  after a brief discussion of related work  we explain the technical details of our approach. we then present our evaluation results. 
 
1 related work 
 previously  many approaches have been proposed to make a conversation system's capability apparent to users  such as tutorials or context-sensitive help. tutorials  kamm et al.  1  are often too brief to cover all valid queries. even if they manage to do so  users may not be able to remember and apply them to the current task. alternatively  contextsensitive help systems  hastie et al.  1  stein  1  present relevant examples in context. however  existing approaches for context-sensitive help have limitations. for example  finite state machine-based approaches  walker et al  1  do not scale well. depending on the granularity of the predicted classes  a decision tree-based help  hastie et al.  1  may be too coarse to provide guidance on the exact wording. moreover  retrieval-based recommendation has been used in applications like spelling recommendations in google spell check  google  1 . we have also used retrieval-based query recommendation in conversation applications  pan et al.  1 . however  depending on the coverage of the examples in a system  the most relevant prestored example may not be close enough to be helpful. in contrast  the approach we propose here combines retrievalbased approach with dynamic query generation to provide scalable  fine-grained context-sensitive help based on the current user query. 
　our work on dynamic recommendation generation also offers several contributions to the area of natural language generation. for example  traditionally  content selection is done either based on domain heuristics  mckeown et al.  1  or content models learned from a corpus  duboue and mckeown. 1  barzilay and lapata  1 . in contrast  our content selection is done based on the analysis of the current user query as well as the categorization of an interpretation error. for sentence generation  in addition to the grammaticality of generated sentences  shaw. 1  langkilde. 1  walker et al.  1  we also focus on using a cascade model to minimize the unnecessary difference between the original user query and system's recommendations.  
　in the following  we first explain the hybrid query recommendation approach  and then provide evaluation results. 
 
1 hybrid query recommendation    
to achieve robust  scalable  fine-grained query recommendation  we extend our previous work on retrieval-based query recommendation  pan et al.  1  with dynamic query generation. there are two independent recommenders in our system: a retrieval-based recommender and a generation-based recommender. the retrieval-based recommender produces recommendations by selecting from pre-stored examples while the generation-based recommender dynamically constructs recommendations based on the current user input. after combining the results from both  the hybrid recommender is able to recommend queries beyond the scope of the pre-stored examples. in the following  to explain the hybrid approach  first we summarize the retrievalbased approach  and then we focus on the new generationbased method. 
1 retrieval-based recommendation 
the main knowledge in retrieval-based recommendation is a query corpus containing typical query examples a system can understand. for each example in the corpus  the system stores not only the query itself  but also its semantics produced by a semantic interpreter as well as contextual features derived from the conversation history. when a problematic user query is encountered  the system searches for the most relevant examples from the corpus. the relevance of an example to a user query is defined as the weighted combination of three similarity scores: the string similarity score  the semantic similarity score and the context similarity score. based on the total relevance score for each example in the corpus  the system will recommend the top n queries to the user. 
 this approach works effectively when the system stores almost all the valid query combinations in the query corpus. however  in any non-trivial conversation system  the number of queries a system can understand is huge due to combinatorial explosion. for example  in a real estate application in which there are 1 attributes associated with a house  a system would need to store at least 1 examples just to cover queries related to searching for a house using any combination of the attributes as search constraints. thus  it is often impossible to collect and pre-store all the queries ahead of time. to solve this problem  we propose to dynamically compose new queries based on the current user request so that the system can recommend queries beyond the scope of pre-stored examples. 
1 generation-based recommendation 
dynamic query generation offers a significant advantage over the retrieval-based approach because the system is able to generate a large number of queries based on a small set of query examples.  in general  it is difficult to cover all the combinations of concepts and attributes in a corpus. it is not difficult however  to cover each concept or attribute in at least one of the examples. in the following example  assume there are seven concepts {a  b  c  d  e  f  g} and four query examples {abe  cd  efg  dfg}. when receiving a new user inquiry  abdf  in which    is unknown to the system  a retrieval-based recommender may not be able to produce any good recommendations because none of the existing examples is close enough to the user query. using generation-based recommendation  however  the system can produce a query more similar to the user's problematic query.  for example  based on the partially understood results and the system's guess that the meaning of    is  g   the system may decide to generate a sentence conveying  abdfg  which is closer to the user query than any of the existing examples.  
    

　to explain the generation-based recommendation method in detail  let's follow the flow in figure 1. when a problematic user query  e.g. with unknown words  is received  the interpreter produces an error code plus partial interpretation results in the form of an incomplete semantic graph. from the user query and the partial interpretation results  the feature extractor automatically derives a set of syntactic and semantic features characterizing the unknown word in the user query. based on the extracted features and annotated examples in the problematic query corpus  the classifier selects one or more content selection operators.  then the content selector revises the partial semantic graph using the selected operators to formulate the content of a recommendation. finally  the sentence generator takes the revised semantic graphs and produces grammatical sentences as the recommendations. the following section explains this component in detail  starting with classification-based content selection.  
1.1 classification-based content selection 
content selection is critical in recommendation generation.  it is an attempt for the system to restore the semantics of problematic user inputs based on the system's knowledge about the application domain  the current user input  and the conversation context. depending on the type of interpretation errors  the system may add new content or remove existing content to produce a recommendation. currently  we employ a classification-based approach to categorize the interpretation problems and to derive proper content selection operators. since most problems that an interpreter can reliably identify involve unknown words  in this study  we focus on unknown word classification.    
　in the next section  we describe how to categorize each unknown word using a set of semantic and syntactic features.  later we explain how to build multiple classifiers to select appropriate content selection operators.  
 
	no 	name 	definition 	example 
1 elesynrel the relationship between the problem modifier  element and the element anchor head 
1 prelepos 	the part-of-speech  pos  of the 	adjective 
problem element 
1 prelerole 	the role played by the problem ele-	modifier 
ment in its relationship with its anchor 
1 prele 	further classification for  the unknown 	na 
	classification 	word  
1 ancelepos 	the pos for the anchor element 	np 
1 ancelerole the role played by the anchor element head in its relationship with  the problem element 
1 anceletype 	the semantic type associated with the 	knownanchor element 	concept 
1 prsegsyn- the syntactic relation between the modifierrel problem and the anchor segment head 
  
1 prsegpos 	the pos for the problem  segment 	np 
1 prsegrole 	the role played by the problem seg-	modifier 
ment in its relationship with its anchor 
1 ancsegpos 	the pos for the anchor segment 	noun 
1 ancsegrole the role played by the anchor segment head in its relationship with the problem segment 
1 ancsegtype 	the semantic type associated with the 	knownanchor segment 	concept 
1.1 classification features 
to categorize the problem associated with each unknown word and to derive proper content selection operators for recommendation  we extract a feature vector containing thirteen semantic and syntactic features for each unknown word. the rationale for selecting these features is to establish a connection between the unknown words and their context. if the system can understand some words that have direct relationships with the unknown word  the system may be able to infer the semantics of the unknown word. most of these features are defined based on the following four concepts: problem element  anchor element  problem segment and anchor segment. a problem element is the basic token that contains the unknown word. an anchor element is a syntactic constituent that has a direct relationship with the problem element in a syntactic tree. for example  if the problem element is a modifier in a noun phrase  the anchor element will be the head of that noun phrase; or if the problem element is a syntactic object  the anchor element will be the verb of that object. similarly  a problem segment is the most specific syntactic constituent that contains the problem element. the anchor segment is the closest syntactic constituent of the problem segment. we generally ignore function words when defining these concepts.  
　in the following example   show houses in unified school district   we assume  unified  is the unknown word. based on our definition  the problem element is  unified   element anchor is  school district ; problem segment is  in unified school district ; and anchor segment is  houses .  table 1 summarizes the definitions of the classification features.  
1.1 content selection operators 
in the classification training corpus  after a feature vector is extracted for each unknown word in a sentence  we also assign one or more content revision operators for each vector  indicating proper ways to revise the partial understanding results to formulate the semantics of a recommendation. to define the set of content selection operators  we analyzed a set of problematic user queries. table 1 listed four commonly used content revision operators in structured information seeking applications like real estate database search. 
name description example opcon-
straintontology replace an unknown word with constraints that are  compatible with the word and the ontology replace  unified  in  unified school district  with all the school district constraints  e.g.  
pleasantville school district. op- con-
straintattribute replace an unknown word with constraints that are compatible with the current 
attribute replace  fair  in  houses with fair tax  with a constraint on the house attribute: annualtax  e.g. 
tax less than $1 op- 
attributeontology replace an unknown word with attributes  that are compatible with the ontology replace  dimension  in  the dimension of the house  with an attribute of house  based on the ontology  e.g. square footage. op- operator- 
ontology replace unknown word with a known operator  replace  preserve  in  preserve 
the houses  with  a known operator like  save   
1.1 classification results   
our training examples for classification are collected from a wizard-of-oz  woz  user study. in total  we have collected 1 conversation segments and ~1 user requests. among these requests  our system detected 1 unknown words. for each unknown word  a feature vector  described in table 1  was extracted automatically from the interpretation results. in addition  for each feature vector  we manually assigned a yes or no tag for every content selection operator defined in table 1.  in total  we have trained four content selection classifiers. currently  we use jrip  witten and frank  1   a java implementation of the ripper classifier  cohen  1  in our experiment.  
classifier accuracy majority classification opconstraintontology 1% 1% opconstraintattribute 1% 1% opattributeontology 1% 1% opoperatorontology 1% 1%  
　table 1 shows the performance of each classifier based on ten-fold cross validation. we compare it with the performance of majority-based classifiers in which the classifiers always predict  no . the results indicate that content selection can quite reliably help the system in recovering the semantics of unknown words. 
1.1 applying content selection operators 
if a content selection operator is chosen  it is used to revise the semantic graph of the original user query. three knowledge resources are used in this process: the domain ontology  the query corpus and the response corpus. for example  if the operator opattributeontology is selected to revise the unknown word in  show the xxx of the houses in pleasantville   the system will retrieve all the attributes associated with the anchor concept  house  from the ontology.  for each retrieved attribute  the system generates one semantic graph  resulting in many possible recommendations.  in addition to the ontology  both the query corpus and the response corpus are also used when applying the other content selection operators. in the next example  if opconstraintattribute is chosen to revise the user query  show houses with fair tax  in which  fair  is the unknown word  the system will search both the query corpus and the response corpus to find all distinct query constraints that use the house attribute  annual tax   such as  houses with annual tax below $1 . similarly  for each distinct constraint retrieved  the system generates one semantic graph.   after applying content selection operators  the results contain a set of semantic graphs  each representing the content of a recommendation. in the following section  we explain how to generate a sentence that not only conveys the semantics in the semantic graph faithfully but also is syntactically and lexically consistent with the original user query.  
1.1 cascade model for sentence generation  once the content of a recommendation is determined  it is sent to the sentence generator to be realized as grammatical sentences. here we implemented an instance-based sentence generator that selects and dynamically composes new sentences from examples in an instance corpus.  
　one critical issue in recommendation generation is to adapt a sentence's surface form to be as similar to the expressions in the original user input as possible so that it is easier for a user to identify the changes between them. for example  when the original user query  show xxx houses in pleasantville with 1 sq ft.  can not be understood by the interpreter  it is more desirable if the system recommends  show 1 bedroom houses in pleasantville with 1 sq ft  than  show 1 sq ft houses with 1 bedrooms in pleasantville  even though both convey the same semantics. 
　in the following  we describe an instance-based sentence generation approach that matches and selects words and phrases from a cascade of instance corpora so that the system can reuse as many expressions similar to the user's as possible. we start with a brief introduction on instancebased sentence generation. 
 1.1 instance-based sentence generation in instance-based sentence generation  all the semantic and syntactic knowledge needed for sentence generation is encoded in an instance corpus.  each instance in the corpus is represented as a pair of semantic graph and realization tree. the semantic graph represents the concepts and relations conveyed in a sentence and the realization tree represents how the concepts and relations are realized using words and phrases. during generation  the input semantic graph from the content planner is matched against all the semantic graphs in the corpus and the closest matching one is retrieved with its associated realization tree. moreover  if the matching is not perfect  based on the difference  a set of adaptation operators are derived so that new sentences can be generated by deleting unneeded content from  or adding new content to the associated realization tree. more details on instance-based sentence generation can be found in  pan and shaw 1  pan and shaw 1 . in the following  we focus on the new cascade model which is designed to maximize the syntactic and lexical consistency between the original user query and the generated recommendations.  
1.1 cascade model for instance selection the essence of instance-based sentence generation is to reuse as many words  phrases or even the entire sentences in the instance corpus to convey desired semantics. as a result  the size and style of the instance corpus can significantly impact the generation quality. sufficient coverage ensures that there always exist proper words or phrases in the instance corpus to convey any given semantics. using instances similar in style maximizes the chance for reusing large chunks of the corpus material in a new sentence. the larger the reused chunks are  the fewer adaptations are required  and the better the generation quality is.  
　to balance the needs for good coverage and similar style  we use three types of instances available in our system: the current user input  the examples in a query corpus and the examples in a response corpus. the current user input only contains one pair of semantic graph and realization tree automatically derived from the partial interpretation results. since the system may make mistakes  it can be incorrect. however  it is the only source containing the content and form of the current user query. the query corpus contains typical queries our system understands. each request in the query corpus is manually annotated with a semantic graph and a realization tree. style-wise  it is similar to the recommendations to be generated. however  since the size of the query corpus is small   to improve the coverage  we also use the response corpus. the response corpus is designed initially for response generation. it is clean but with a somewhat different style. for example  query corpus contains users' requests for data  while instances in the response corpus are descriptions of query results. nonetheless  they still share a significant amount of vocabulary.  
　in the cascade model  to ensure that the output sentences convey the desired semantics  instances are only selected from the two clean sources: the query corpus first  followed by the response corpus.  but  to generate recommendations as close to the original user query as possible  we adapt the generation results based on the features extracted from the user query.  overall  three input features are extracted: the 
                                                 
   there are 1 examples in the query corpus.    
realization order  the realization form and the presence of discourse cue phrases. table 1 shows the effects of adaptation using these features. in the first example  based on the interpretation results of q1  the system knows that in r1 the house bedroom constraint should come before the bathroom and the city constraints. it is also aware that the bedroom and bathroom constraints should be realized as premodifiers instead of post-modifiers. without taking input order and form into consideration  however  the system might generate a recommendation like r1 which is considered worse than r1. in the next example  assume q1 and q1 are two consecutive user queries. since the system interprets user query in context  the interpretation results of q1 is equivalent to q1'. without discourse cue phrase adaptation  the system will recommend r1 which is less coherent and context appropriate than r1.  
 
: show 1 bedroom 1 bathroom houses in xxx cities. 
　: show 1 bedroom 1 bathroom houses in cities with less than 1 people. 
   in cities with less than 1 people  show 1 bathroom houses with 1 bedrooms. 
 show 1 bedroom houses  
:just those in xxx cities 
q1' show 1 bedroom houses in xxx cities 
:show 1 bedroom houses in cities with less than 1 people  
: just those in cities with less than 1 people 
1 merging recommendations 
after the retrieval-based and the generation-based recommender produce two sets of recommendations independently  we merge the results. currently given the maximum number of recommendations to display on the recommendation panel  we take the number of results proportionally from each recommender. for example  if the maximum number of recommendations allowed is five  the generationbased recommender produces eight results  and the retrieval-based recommender produces two results  the final five recommendations contain four recommendations from the generation-based system  one result from the retrievalbased system.   
 
1 evaluations 
we perform an evaluation to verify the usefulness of the proposed approach. through this evaluation  we want to gather two results. first  we want to see whether the hybrid approach can improve recommendation quality over a baseline system. second  we want to verify that recommendations dynamically generated by our approach are valid queries that can be understood by our system. otherwise  users may be frustrated due to subsequent rejections of the recommendations by the interpreter.  
　in the first evaluation  we use the retrieval-based recommender as the baseline. based on our previous study  pan et al.  1   systems aided by retrieval-based recommendation were more effective than the same system without any recommendations. overall  users achieved higher task success rate and also spent less time and fewer turns to complete their tasks. in addition  in their survey  users also reported that the system understood them better and they also had better idea on what to ask. to verify that the new hybrid system can perform better than the retrieval-based system  we collected about 1 unique queries from previous user study logs  not including the woz queries . among them  1 sentences contained unknown words. from them we randomly selected 1 test queries. for each test query  each system  hybrid or retrieval  generated a maximum of five recommendations  top1 . after mixing results from both systems and after redundancy removal  we randomly ordered all the recommendations and presented them to two human judges who had no knowledge about this work. for each recommendation  we asked them to decide whether the recommendation is useful for a given user request. a recommendation is useful if the judge knows how to revise the unknown words after seeing the recommendation. if a recommendation was selected by a judge  the approach that produced the recommendation scored one point. the system with higher overall score is the one that produced more useful recommendations. in addition  we also let the judges choose the best recommendation among all the useful ones  top1 . table 1 summarizes the results. based on the results  among the five recommendations produced for each user query  the hybrid approach produces 1 useful recommendations on average versus 1 by the retrieval-based approach. the difference is statistically significant using pair-wised t test. the hybrid system also performed significantly better than the retrieval-based system based on the top1 evaluation result  1 versus 1 . the difference is also statistically significant.   
 

 
to verify whether the recommendations dynamically generated can be understood by the interpreter  we run all the generated recommendations through the interpreter. our results show that 1% of them can be interpreted successfully.  overall  our evaluation indicates that the hybrid recommender not only improves the query recommendation quality by generating recommendations beyond the scope of pre-stored examples but also maintains the same level of query interpretability as the retrieval-based approach. 
 
1 conclusions 
in this work  we designed and implemented an approach to recommend context appropriate query alternatives when a user's query cannot be understood by the system.  we developed a hybrid recommendation strategy that extends the retrieval-based query selection with query generation. it provides a solution to one major problem in retrieval-based recommendation: scalability. this makes query recommendation more feasible for practical conversation applications. 
moreover  since our approach dynamically generates recommendations on the fly  this makes it possible for the system to adapt the surface form of the recommendations so that they are lexically and syntactically consistent with the original user query. our evaluation results confirmed the effectiveness of this approach.   
 
