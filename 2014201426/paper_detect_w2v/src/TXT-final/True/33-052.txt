 
　　handling exceptions to general rules is a persistent and difficult problem in systems for representing knowledge. in semantic networks  this often takes the form of cancelling some item of information  such as membership in a class  that would otherwise be inherited from a higher level description in the type hierarchy. some conceptually clean approaches to cancellation lead to great inefficiency in accessing the information in the network  and can negate much of the speed advantage that would otherwise be possible in a parallel network system such as netl. in this paper we explore some of the interactions between cancellation and parallelism in semantic networks  and we propose a cancellation scheme that appears to be workable for netliike systems. 
i. introduction 
　　every practical scheme for representing knowledge must provide some way to represent general statements about classes of objects   all elephants are gray   and to perform the inferences necessary for this information to be inherited by the individual members of the class. such inheritance machinery makes it possible to represent a body of knowledge much more compactly than if every property of every individual were represented explicitly. as the size of the knowledge base grows  however  inheritance can become costly to implement; in a complex hierarchy it may require a great deal of computation and search to answer apparently simple questions. the netl system  performs these searches by propagating markers in parallel through the nodes and links of a hardware semantic network. 
     in much of mathematics and in many games and puzzles  general statements about the members of a class can be treated as inviolable  but in most real world domains it is necessary to make occasional exceptions to general statements:  elephants are gray  except for royal elephants  which are white.  if there were no way to cancel or override the application of a general statement that would otherwise be inherited  we would be faced with two very unattractive choices: either remove the general 

'fannie and john hertz foundation fellow. 
thia research was sponsored by trie defense advanced research protects 
agency  ooo   arpa order no. 1. monitored by the air force avionics laboratory under contract f1c 1. 
　the views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies  either expressed or implied  of the defense advanced research protects agency or the us government. 
statement about elephants being gray and state the color individually for each elephant  or remove royal elephants from the class of elephants and describe their elephant like properties from scratch. as we accumulate large amounts of information in our knowledge base  this dilemma is encountered more frequently; if we know hundreds or thousands of facts about the typical elephant  the probability that a given elephant will be typical in all of these respects becomes vanishingly small. we just happen to live in a universe in which there are regularities too important to ignore  but in which every general statement has some exceptions  including this one . 
　　the current interest in nonmonotonic logics  is in large part due to a realization that traditional  monotonic  logics cannot handle generalizations and default reasoning in the presence of exceptions  and that such reasoning is'critically important in realworld systems. however  the majority of work in nonmonotonic logic has been aimed at developing a useful  consistent  and mathematically tractable notation and the associated rules of inference. little work has been done on how to make nonmonotonic inference systems efficient enough for practical use  and even less on the possibility of performing the necessary inferences in parallel. 
　　most existing al knowledge-base systems either decline to handle exceptions at all  1  or handle them by a system of local masking  in which more local information   royal elephants are white   masks and supersedes any conflicting information   elephants are gray   found at more abstract levels of the hierarchy  1 . this system of masking has several serious problems. first  it is often hard to determine whether the local information conflicts with the inherited information  and therefore supersedes it  or whether it is intended as additional information. second  in a system whose type hierarchy allows multiple upward branches from a node  it may not be possible  or even meaningful  to determine which of two statements inherited along different paths is the more local. third  the masking system works only for determining the properties of a given subtype or individual; it does not lend itself to the complementary problem of finding those individuals with a certain property. finally  the masking system works only for properties; it does not extend naturally to the situation where inherited membership in a class is to be cancelled. these problems can be greatly reduced if the information to be superseded is explicitly cancelled. 
　　the netl system  originally included a scheme for handling explicit cancellations in parallel during the normal marker propagation operations of the network. the scheme  as originally proposed  was able to handle the trivial cases that were considered at the time  but it began to break down as more complex situations were considered. after a considerable period 
　　
1 
　　
of wrestling with the problem  we developed some new insights into the nature of cancellation and a better system for handling cancellation in netl. we believe that these insights and methods win be of value to other workers in the area of knowledge representation  even those working on inference systems that are not designed for parallel implementation. 
　　in the discussion that follows  we confine our remarks to the case where the information being cancelled is the inherited membership of some individual in a class or the inclusion of some class in a more abstract and general class. this is the hardest sort of cancellation to handle: it exhibits all of the problems that we have found in cancelling inherited properties  plus some more. also  it subsumes the other cases  since in a system like netl one can always transform a predicate like gray or likes peanuts into a class like gray-objects or peanut likers the real advantage of limiting the discussion to class membership cancellation  however  is that we can describe our approach purely in terms of is-a links and the various sorts of cancel links and avoid a discussion of roles  mapping  and quantification in semantic networks    a complex set of topics beyond the scope of this paper. 
ii. some design considerations 
　　before we look at the ways in which the obvious cancellation schemes fail  we must describe what we want a successful parallel scheme to do. 
　　in designing a system like netl  we cannot separate the design of the elements  nodes  links  flag bits  from the design of the parallel marker-passing algorithms  called scans  that locate information in the network; the representation and the algorithms 
must work together. two scans will concern us here. the upscan starts with a mark on a single node and attempts to mark all of that nodes superiors in the tangled type hierarchy -- that is  all of the superior type-nodes from which the starting node is to inherit properties and statements. in the absence of cancellation  this scan consists simply of propagating markers across is-a links  these are called *vc links in  1    in the upward direction  following the arrow  only. because of the parallelism in the network  this operation can be done in time proportional to the length of the longest isa chain to be followed  regardless of how many nodes are marked due to branching in the network. upscans are used very frequently for all sorts of access in the knowledge base  so any proposed cancellation scheme must preserve their parallel nature or pay a very heavy price in performance. 
　　the downscan is used to mark all of the subtypes and individuals that lie below the starting type-node in the isa hierarchy; these are the nodes that inherit properties from the starting node. a downscan is like an upscan  except that the markers propagate downwards across isa links  against the arrows   not upwards. this scan  too  is used very frequently  as it plays an essential role in all recognition operations. again  the time taken is independent of the number of nodes marked  and this parallelism must be preserved when cancellation is added to the system. for the system to function properly  the upscan and downscan operations must be complementary: if an upscan from node x marks node y  a downscan from y should mark node x  and vice versa. 
　　in addition to working smoothly with the above scans  a cancellation scheme must allow for cancellations to be revoked. consider the following set of assertions  which we would like our system to handle in a natural way: 
1. a mollusc is a shell-bearer. 
1. a cephalopod  octopus  squid  etc.  is a mollusc  but is not a shell-bearer. 
1. a nautilus is a cephalopod  but is a shell-bearer. 
　　note also that we need the ability to add information to -the knowledge base in any order. as we will see  the addition of a seemingly innocuous assertion can sometimes clash with assertions that are far away in the network. this must be detected and dealt with  perhaps by cancelling some of the conflicting information. 
iii. a simple cancellation scheme and how it fails 
　　let us now consider the membership-cancellation scheme proposed in  and see how it fails this scheme uses a special cancel link  called 'canvc in the original work  to represent the cancellation of an inherited class membership. in fig. 1  we see a 
　　network  actually a fragment of the complete network knowledge base  in which this cancel link is used. according to this network  a d is a c  but is not a b or an a because of the cancel link. e inherits the class memberships of d. to perform an upscan from node e in this network  proceed as follows: 
1. first select an activation marker for marking the superiors of node e; select a second marker for cancellations. suppose we select markers m1 and m1 for these roles. begin by putting marker m1 on the starting node  e. 
1. if any cancel link has m1 on the node at its tail  put an m1 on the node at its head. 
1. if any isa link has m1 on its tail  and has neither m1 nor m1 on its head  put an m1 on the node at its head.  the effect of this is that the activation markers propagate upward  but will not enter or pass through a node with a cancellation marker.  
1. repeat steps 1 and 1 in alternation until step 1 no longer generates any activity. if there are no nodes with both m1 and m1 markers present  stop. m1  the activation marker  is now present on all of the nodes from which the starting node  e  is supposed to inherit properties. 
1. if in step 1 a node is found with both m1 and m1  the network contains a lost race: a cancellation marker has arrived at a node too late to prevent an activation marker from passing into and through that node. in such cases  rare in practice  but possible  the scan must be run a second time. remove all m1 markers  leaving the m1 markers in place. then put m1 on e  and run the entire scan again.  note: when they are detected  race conditions can be eliminated by adding a redundant  more direct cancel link to the network this will get the cancellation marker to the disputed node sooner  in time to stop the activation marker from getting by it.  
　　fig. 1 shows the result of this scan. e inherits from 1 and c  but not from b and a. if we had started the upscan at node g  no cancellation would have occurred; g inherits from f  c  b  and a. 
1 　　the algorithm for oownscan ie identical  but the direction is reversed: cancellation markers flow down cancel links  and activation markers flow down isa links.  they move in the 


direction opposite to the arrows drawn on the links  fig 1 shows the result of a downscan from a in the same network: b  c  f  and g inherit from a; d and e do not inherit because the cancel link places m1 on node d and this blocks any m1 from entering or passing through that node. 

figure 1: the result of a downscan from a 
　　the inadequacy of this cancellation scheme can be seen in the example of fig. 1. if we perform an upscan from g  we mark f  e  c  b  and a  but not node d  which is cancelled. since the upscan says that a is a superior of g  a downscan from a should mark g. this is not the case  however; a downscan from a will mark nodes b  c  d  and e  but will not mark f and g because of the cancellation marker on f. we cannot fix this by arbitrarily 

figure 1: a case where downscan fails 
deciding that downscans should not send cancellation markers downward; in many cases  such as the one in fig. 1  these cancellation markers are essential. 
　　a similar problem can occur in upscans. consider the network of fig. 1. it is clear that a downscan from g will mark f  e  c  b  and a  but not d. using the algorithm above  an upscan from a will reach b  c  d  and e  but not f and g. in a case like this  it is not clear what should happen. members of class c inherit membership in f  while members of class d explicitly do not. what about members of class a  which are members of both c and d  should the inheritance or the cancellation take precedence  if the upscan is to be complementary to the downscan in this example  inheritance along a non cancelled path must take precedence over the cancellation  but it is not clear how to implement that policy in a parallel scan. 

figure 1: a case where upscan fails 
iv. the nature of the problem 
　　at first we viewed these problems as minor bugs in our scanning algorithms. we tried a number of fixes  such as cancelling particular isa links rather than cancelling class membership directly at the node  but the same kinds of problems kept appearing no matter what we tried. gradually  it became clear to us that the problem was a fundamental one  owing more to the nature of marker-passing parallelism and nonmonotonicity than to the details of our various notations and scans. consider 
　　
1 
　　
again the case in fig. 1. what we really want here is for the cancellation marker at node f to stop those activation markers that arrive by way of node d  and not to stop any activation markers that arrive via the uncancelled path through node c in other words  we need to know not only the result that a is an f  but also how we established that fact is proving .that a is a 1 an essonlial part of the proof that a is an f. or is there some other path available  obviously  our single bit markers do not carry such information 
　　one could imagine a parallel system in which such information is recorded and used. each cancel link would  paint  a marker that passes one of its ends  and would block any marker so painted from entering the node at its other end. to prevent errors due to interactions between different cancel links  each cancel link would require its own color of paint  and a marker might have to carry many colors at once. this would solve the cancellation problem  but at a heavy cost: we are no longer passing around single bit markers  but arbitrarily complex information structures; each parallel element of the network must now be a complex processor  capable of storing  comparing  and modifying an unbounded number of these  marker  structures.  that is. the number of colors could be as large as the number of cancel links in the network  which is theoretically unbounded.  
in the netl system  we have chosen to provide only a small  fixed number of single-bit markers; this results m a system which we know how to build relatively cheaply . 
　　our problems with cancellation  then  are a direct consequence of our decision to use a very simple kind of parallelism in netl. a more complex parallel system would not exhibit these problems  but it would be orders of magnitude more costly and difficult to build. 
　　we should note that this difficulty with cancellation is not the only problem arising from our choice of simple marker passing parallelism. for example  to locate in parallel every known instance of a son who is hated by his own father* we need the same kind of painted markers. we can start from the father nodes and mark their sons. a second mark can be placed on all the people that fathers hate. we can then locate in parallel the set of all sons who are hated by someone's father. but without the paint  we cannot be sure that the son of marker and the hates marker came from the same father. we have produced a list of suspects  but we must now look serially at each suspect to see if he is. in fact  a member of the class in question. painted markers could also be used to eliminate the copy confusion problem discussed in   section 1. 
　　despite these arguments  there are ways to cope with cancellation in netl without going to more complex hardware. these involve introducing some amount of serial behavior into the operation of the network    in essence  achieving the effect of many-colored markers by using simple markers in a number of separate scans. for example  we could send  suspicion marks  rather than cancel marks down the cancel links during a downscan. every node that receives both a suspicion and an activation marker might be cancelled. we check this by doing an upscan from that node. once all of these possible cancellations have been checked  and cancellation markers have been placed on the appropriate nodes  we can then do a final downscan to locate the true  uncancelled descendants of the starting node. 
 this pioblem was put to us by brian smith 
　　note that what was a single parallel downscan has now become a group of scans  one for each cancel link that the original downscan touched. in most real world systems  a single downscan will only initiate a few cancel testing scans  but in principle there is no limit  just as there was no limit on the number of colors we needed earlier. many variations on this theme are possible  but they all result in additional scans  one for each cancel link that might alter the results of the scan being performed. 
　　another approach we can take is to perform these additional cancel-checking scans every time the network is modified  and to record the results in the network in the form of additional links. this allows the upscan and downscan algorithms to be simple parallel scans  as they were initially  but requires that a potentially large number of cancel checking scans be run whenever any link is added to the network or removed from it this move is advantageous  since we anticipate that in the normal operation of the knowledge base the ratio of accessing to modifying operations will be large. 
　　a second advantage of this pre processing scheme is that in many situations  as in the example of fig 1 above  it is not clear whether the user intends that an inherited cancellation should apply or should be overridden. if we locate such ambiguous situations at the time the network is modified  we can ask about how to resolve them while the knowledge base builder is still present; if we wait until access time to discover the problem  we might be dealing with a different user who could shed no light on the intent of the knowledge base builder note that the builder  and the  user  of this knowledge base might be programs instead of humans  but it is still the builder's job to resolve ambiguities 
　　this idea of checking all possibly affected cancel links with individual scans at the time of any modification to the network  and of keeping the network in this pre tested  unambiguous   consistent  state is the basis of the scheme described below. preserving such consistency across all possible changes can be a tricky business  especially when complications such as multiple contexts are brought into the knowledge base we have not  at the time of this writing  dealt with many of these possible complicating factors. that is why we refer to this as a  partial  solution to the problem. however  we are reasonably confident that some combination of pre testing and access-time testing of cancel links can be made to do the job. 
v. a partial solution 
　　we begin with the notation and the algorithm from  described in section 1 above. cancel links run from node to node and place cancellation markers during upscans and downscans these cancellation markers prevent any activation markers from entering or passing through the nodes that they occupy. in this scheme cancel links are stronger than isa links. 
　　in this sort of scheme  we need some way to explicitly override a cancel link in order to handle the mollusccephalopod nautilus problem described earlier. we cannot just add an is a link from nautilus to shell bearer  since the cancel link from cephalopod to shell bearer takes precedence. instead we must use both an is a link and a new link whose effect is to turn off a cancel link lor a particular subclass that would otherwise inherit the cancellation. we call this new link an uncancel link. the resulting network is shown in fig. 1. 
　　
1 
　　

　　the algorithm for upscan is unchanged  except that we select an extra marker  m1  for use by the uncancel links  and step 1 is replaced by the sequence of step 1a and step 1b as shown below. 
1a. if any uncancel link has m1 on the node at its tail and does not have m1 on the cancel link at its head  put an m1 on this cancel link. if the cancel link being marked has an m1 on the node at its head  remove the m1 marker from that node. 
1b. if any cancel link has m1 on the node at its tail and does not have m1 on its body  put m1 on the node at its head. 
　　fig. 1 shows the result of this new upscan algorithm when used to mark upward from nautilus in fig. 1. no cancellation marker is placed because the uncancel link places an m1 on the cancel link  turning it off. a nautilus is therefore a cephalopod  a mollusc  and a shell-bearer  according to this network. 

　　note that the running time of this scan still depends only on the length of the longest is a chain  not on the branching facto/ or the number of nodes in the network. the addition of uncancel links increases the running time of the basic upscan by a small constant factor. 
　　note too that cancel and uncancel are sufficient; there is no need for un-uncancel links. if we want to create a subtype of nautilus  the naked-nautilus  that is nor a shellbearer  we simply add this node to the network below nautilus and run a new cancel link from it to shell-bearer. as shown in fig. 1. the old cancel link and its uncancel are left alone. 
　　recall from the example of fig. 1 that the difficulties for upscans arise in those cases in which some node lies below the tail node of a cancel link  node d in this case  and also lies below the head node of the cancel link  node f  by an independent path  one that does not pass through d . node b in 

this example is such a node  which we call a merge point below this particular cancel link. in this case it is unclear whether b is to be a member of class f or whether the cancellation of f is to prevail. 
　　we propose to deal with such ambiguous cases by excluding them from the network. the structure in fig. 1 is declared to be 
 inconsistent  or ill-formed. every merge point below a given cancel must have an uncancel link from it to the cancel. 
therefore  the network of fig. 1 is legal  since the merge point at 
nautilus has an uncancel link. this network will function properly for both upscans and downscans. fig. 1 is legal as well. 
another way to make fig. 1 legal would be to run a new 
cancel link directly from b to f. in this case  b is not a merge point  since it is not below f by the normal rules of inheritance. thus  if we see an illegal merge point like b about to be created  we can give the user a choice: is b an f  or is it not  if it is  we insert an uncancel; if it is not  we insert a new  direct cancel link from b to f. 
　　note too that by fixing the problem at node b  we also fix it for node a in general  therefore  we need only to locate and fix the uppermost merge points below a given cancel link  not every node that lies anywhere below both the head and tail. since the is-a network is not a total ordering  there may be a number of uppermost merge points below a cancel  but we expect this number to be small. 
　　it is not difficult to find all of the uppermost merge points below a single cancel. call the node at the head of the cancel link a and the node at the tail of the cancel link b. the procedure is as follows: 
1.with one triplet of markers  m1 for activation  m1 for cancellation  and m1 for inactivation  perform a normal downscan from node b  observing all cancel links as the downscan proceeds. 
1. with a second triplet of markers  m1  m1  and m1. perform a downscan from node a. because of the cancel link  m1 will be placed on node b  so m1 markers will not flow down  through that node. 
1. we must now find the uppermost nodes with both m1 and m1. have every is-a link in the network examine the node at its head  if this node contains both m1 and m1  place an m1 mark on the node at the tail of the is-a. every node that ends up with m1 and m1 but not m1 is an uppermost merge point: it has no merge point above it. 
　　
1 
　　
1. to handle some difficult cases property  we also must find and fix any merge points that lie below the uppermost merge points found in step 1. but that have independent upward paths to both a and b. by  independent  we mean 
that neither of these paths go through the uppermost merge points found earlier. to find these nodes  we re run 
steps 1 above  but first we put cancellation markers  m1 and m1  on all of the uppermost merge points we have found already. repeat these scans until no new merge points are found. 
　　so far  this section has only dealt with the difficulties encountered in upscans and what to do about them; as we saw earlier  downscans have problems as well. these problems occur understand what the unexclude links are doing. the best way to visualize this is to think of the downscan as a query about which nodes are members of the class represented by the starting node of the scan. in fig. 1. the cancel link excludes f and its descendants from membership in class d  and from any class superior to d. the unexclude in fig. 1 lifts this exclusion for 
class b. so that we can state that f is a b without having the cancel link take precedence. 
in situations like those in fig. 1  which is just fig 1 turned upside there are no guarantees. therefore  we must endeavor to keep 　　we have now placed a new set of constraints on the set of legal networks: all cancel links must have the appropriate merge points covered by uncancel or unexclude links. if the network is legal in this sense  upscans and downscans will work properly.  in fact  there will never be a race condition  so step 1 of the scan can be eliminated.  if the network is not in this state  
　　
down : somewhere above the cancel link from f to d  there is a merge point. b. it is unclear whether f should be a b or not. this symmetry suggests a solution  we need a form of uncancel link  called an unexclude link  from the cancel to the merge point at node b. fig. 1 shows the network of fig 1 with this unexclude link added. during a downscan from node b or above  the unexclude link places marker m1 on the cancel link  turning it off. lust as the uncancel link turned off the cancel link during upscans. because of this  the downscan from b does reach nodes f and g; upscans and downscans in this network are exactly complementary to one another. 

　　in order for a network to be considered legal under this scheme  there must be an unexclude link to every lowermost merge point above a given cancel link. the procedure for finding these points is exactly like the procedure described above for finding uncancel points  except that the markers all go upward rather than downward. once the upward merge points are found  we have the option of adding an unexclude link or of adding a new. direct cancel link  depending on what we want the network to say. the operation of upscans and downscans  of uncancel and unexclude links  is now quite symmetrical. 
however  since every node must have some uncanceled path upward to the thing node  there is guaranteed to be at least one merge point above any cancel link  and therefore at least one unexclude; since there is no single lowermost node in the isa hierarchy  many cancel links will have no merge points and no uncancel links below them. 
　　it seems to be easy for people to understand intuitively what the role of the uncancel link is  but somewhat harder to the network in this legal state this requires that we do a certain amount of work every time a cancel or is-a link is added to or removed from the network.  this is similar to the work that must be done to detect other kinds of inconsistency in netl  such as the violation of split conditions.  
　　we have already described how to find the illegal merge points above and below a single cancel link. the act of adding an isa link to a network can cause some new merge points to appear for cancel links that are already present. in order to be sure that the network is returned to a consistent state  we must examine every cancel link that might be affected by this addition. this is done by performing an upscan from the top of the new is a and processing any cancel which has either end attached to one of the activated nodes: then we perform a downscan from the lower end of the new is a  and again process any cancel links that are touched by the scan the same procedure must be performed if an is-a link is removed  and if a cancel link is added or removed. any of these operations might create new merge points in processing the cancel links  we must also look for uncancel or unexclude links that no longer point to merge points. these can cause trouble later and should be removed. 
　　all of this is a good deal of work  but as we noted earlier  we assume that the network is modified relatively infrequently we believe that it is better to try to keep the network consistent in this way than to require extra scans to check each cancel link every time an upscan or downscan is performed. we expect that the number of uncancel and unexclude links will be no more than a few times the number of cancel links in the network  depending on how tangled the network is. 
　　an obvious question is whether we can detect that the consistency of the network has broken down  and how to correct it. this could happen  for instance  if the demands on the network are such that the consistency checking for a change cannot be done to completion.  if we record such events  we can come back later and finish the checking.  some inconsistencies  perhaps most of them  will result in networks with race conditions: a normal upscan or downscan will result in a cancellation marker arriving at a node which already contains an activation marker. this should never happen in a consistent network  so it can alert us to the existence of an inconsistency local to the cancel link which loses 'he race. such races will not occur for all inconsistencies  however  so this is not an infallible indicator. in fact  the only way to be really sure that a network is consistent in this sense is to recheck all of the cancel links  one by one. perhaps the system can do this in its spare time. 
　　
1 vi. concluding remarks 
　　in summary  we have argued that cancellation is an essential operation in semantic networks  that the simple scheme of  1  is not sufficient to handle all cases  and that the roots of the problem are deep in the nature of the marker-passing style of parallelism that we use in netl. we have presented two ways of coping with this problem within netl: check every relevant cancel link during every upscan and downscan  or keep the network consistent by adding or deleting auxiliary links every time the network is modified. either solution is cosily  but perhaps not as costly as introducing a more powerful kind of parallelism into our knowledge base system. 
　　we do not yet have a firm theoretical understanding of the kinds of problems that can be handled efficiently by markerpassing parallelism. in this work  we have explored one small set of problems in this new domain. we believe that much more exploration of the possible kinds of parallelism and their limitations will be needed in the years to come. 
