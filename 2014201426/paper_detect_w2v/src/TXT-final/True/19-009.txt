 
   this paper reports on a quite large experience in implementing a procedurally introspective system  pis   alice  in which a well known problem is faced: the integration between lisp and horn clauses. this exercise is motivated by a recognized lack of experience in implementing piss to deal with actual a.i. programming problems. alice is composed of two procedurally introspective languages based on lisp and on horn clauses  respectively. the integration is achieved by means of a new kind of reflection called mutuai reflection. the design of alice required the generalization of several concepts and mechanisms introduced in 1-lisp. the discussion is completed with a set of general retrospective considerations. 
i introduction 
   the mcta-levcls architectures  p.maes and d.nardi  1  constitute one of the most interesting research lines in the field of knowledge representation. in this kind of systems  some  meta  knowledge about the structure and the role of the domain knowledge can be explicitly represented. the problem solving activity is thus carried on by alternating the use and the transformation of domain and meta knowledge. an interesting subclass of the meta level systems is constituted by the introspective systems. in this case  in the system is explicitly available a description of the structure and of the behaviour of the system itself. the system is thus able to reason about itself in some ways. 
   a quite general definition of introspective systems is proposed in  b.c.smith 1 . it is given by means of three conditions that have to be satisfied by a candidate introspective system  i  the system must embody in itself a description of the system which can be consulted and modified by means of tools available in the system  ii  the description has to be causally connected to the system structure and behaviour. any event and relation in the system must have a corresponding representation in the description and any modification in the description must cause a modification in the structure and behaviour of the system  iii  the description must have a proper vantage point. it has to represent the system at a right level of detail to the extent of introspection.  the definition in  p.maes 1  is more detailed  but for our work the above structural definition is accurate enough . 
   the first proposal for an introspective system  with respect to the definition above  was 1-lisp  b.c.smith 1 . 1usp  as well as brown  m.wand and d.p.friedman  1   arc procedurally introspective systems. they restrict their 
1 	architectures and languages 
attention on procedural knowledge. so the relevant aspect in computational processes is the behaviour to achieve. in such a framework  the expressions of a language are description about how to manipulate domain objects and a language is described by its interpreter. this restriction is useful to concentrate the efforts on the design of the basic mechanisms for introspection. in these systems  an explicit representation of the interpreter for the language is available and causally connected to the behaviour of the system itself. reflection is the mechanism by which the user can change the focus of attention from the domain level to the interpreter level to inspect and influence the current computation or to modify the interpreter's code. reflection can be used during meta level operations  thus the user can make access to a virtually infinite tower of causally connected interpreters each interpreting the one below. piss actually are a first step toward general introspection. 
   the 1-lisp approach to introspection  although constrained to the procedural aspects  is elegant and very powerful. nevertheless  this kind of ideas have had a relatively limited spreading in the a.i. applications community and a very small set of relevant examples of introspective programming are available. in our opinion  these problems are caused by the lack of a general understanding of the power of piss and of a pragmatical experience on them. in fact  i  1lisp and brown are quite difficult to use  due to the unusual power of reflection as a programming tool; ii  few piss have been developed on languages different from lisp; iii  the 1lisp and brown implementations are quite complex to understand and they arc based on a set of innovative concepts. it is currently difficult to abstract and export the basic mechanisms of procedural introspection. 
   so  all we need is experience in implementing procedural introspection and in exploring its capabilities while facing actual a.i. programming problems. 
   the alice system is an attempt to deal with the integration of lisp and horn clauses in a conceptually clean way in the framework of piss using reflection as a tool for integration. the currently available solutions are based mainly on the implementation of a horn clauses resolutor embedded in the lisp environment  j.a.robinson and e.e.sibert  1   cmellish and s.hardy  1 . we want to achieve the goal without privileging a single language to which all the representations eventually collapse in  and without introducing an ad hoc communication language. alice was developed at the university of milano and a complete running version of it is currently available in franz lisp on a vax 1. 
   as alice is mainly an exercise in procedural introspection  the focus of attention is on the experience in using and implementing piss. this paper briefly presents the work on alice in this perspective. we follow a step by step approach. firstly  a new procedurally introspective dialect of lisp is presented.then  an independent pis  based on horn clauses  is introduced. finally  the two languages are integrated into a single pis. this requires a new point of view on self description and the introduction of the mutual reflection mechanism. due to space problems  the presentation is very schematic and all the details are omitted. a complete report on alice can be found in  r.ghislanzoni  l.spampinato and 
g.tornielli 1    r.ghislanzoni  l.spampinato and 
g.tornielli 1 . we assume the reader knows the ideas in 
 b.c.smith 1  and we don't undertake a presentation of this theory and we use the smith's notation in his same sense. 
ii step one: a procedurally introspective lisp a little more general than 1-lisp 
   the lisp part of alice is based on 1-lisp  of which we adopt all the basic concepts but for two points: the use of explicit data structures instead of closures to represent continuations and the introduction of reflecters instead of lambda-reflect 
   the first choice de-couples the processed language from the language in which the processor is written. the onelanguage choice binds strictly introspective actions with structures of the particular implemented language. in the perspective of mutual reflection  the representation of the future of the normalization process must be abstracted from the implemented language. 
   in the lisp part of alice  a reflection is achieved by means of a reflecter: a new type of pair  notated as a pair but preceded by a ~   which indicates that the function application has to be performed one level above the current one. so  there are only simple lambda expressions which are possibly reflectible. for example  in 1-lisp: 
 define quit  lambda reflect  q env cont  'quit!   1-uspl  quit  1-usp1 'quit! 
in alice lisp: 
 define quit  lambda   env com  'quit!   alice-lisp 1  - quit  alice-lisp 1   quit     alice-lisp 1  'quit! alice lisp 1   'quit! 
   in pis we consider three concepts about procedures: procedure definitions describe manipulations on structures  procedure applications describe which manipulation on which structures and reflecters describe at which level the manipulation has to be realized. in 1-lisp the first and the third mechanisms are too strictly coupled. reflection is not a static property of a procedure but a particular way to use it 
   the implementation of the alice lisp is very similar to the 1-lisp one. the finiteness criteria presented in  b.c.smith and j.des rivifcres 1  apply directly to our modified processor definition  reflecters are treated by the normalize function . 
ill step two: a procedural introspective system for logic programming 
the second part of alice is called logic. logic  as an independent system  is a simple programming language  in which programs arc sets of horn clauses. the basic idea is to recover as much as possible of the clear and simple initial concept of logic programming  r.a. kowalski 1 . we are willing to obtain at least the power of current prolog  l.sterling and e.shapiro 1  by means of introspection. the goal is to build a system based on 'pure' refutation at domain level and on explicit procedural import at meta level. from this point of view  logic can be considered yet another proposal in the set of horn clauses based languages with meta level programming  k.a.bowen and r.a.kowalski 1 . 
   sentences  clauses  conjunctions and variables are represented with new types of structures added to the structural field of the lisp part. the structures of the lisp 
part are terms for logic. 
   we define the procedural import  1st factor    and the designation  1nd factor 1    b.c.smith 1  of logic with respect to refutation realized with the sld resolution procedure. thus  the designation of a sentence is the truth value true or false whether it can be proven in the current theory with the defined procedure. the refutation by sld procedure defines the behaviour of logic: it actually constitutes the normalization process. thus sentences normalize to the boolean $t or $f whether the procedure refutates them or it doesn't. 
   in order to make logic semantically flat we defined a category alignment for it  r.ghislanzoni  l.spampinato and g.tornielli 1   following the way traced by b.c.smith. 
   logic contains the code of a metacircular processor as the description of its own behaviour. it is the code  in logic  of an implementation of the refutation by sld resolution procedure. the state of the normalization process is explicitly represented by a search tree and an environment  which is the structure representing the current theory. the resolution tree is a complex rail in the structural field with construction and selection primitives. 
   reflective acts are represented in logic with logic reflecters. their notation is similar to sentences' one but with a - at the beginning. the basic idea of reflection is the same of the lisp part: the atomic sentence in the reflecter is modified to include the terms for the representation of the environment and the tree and it is processed as it were inserted in the processor's code at a defined point. 
   the implementation of logic is also based on a shifting processor which recognizes the need of a reflection  makes explicit  reifies  the state of the computation  and shifts up to process the processor code augmented with the user reflective code. if it realizes it is processing a part of the processor code  it shifts down to directly process the user code  after recording the state of the upper level for a potential successive reflection. 
   the precondition for the realization of a shifting processor is the finiteness of the metacircular processor which describes the system. the point  in the context of logic  is the creation of the representation of the search tree to be used by the processor at the level n+1 when a reflection takes place carrying the computation from level n to level n+1. we need a standard way to produce a search tree for the state of a 
   processor processing itself. otherwise  we have to provide the state of the processor at any level and a finite implementation can't be afforded. 
   as for continuation in 1-lisp  it is possible to verify that the search tree of the processor processing the processor is always the same. the tree must not change when considered at 
	ghislanzoni  spamplnato  and tornielll 	1 
any two successive resolutions involving a processor's clause. in  r.ghislanzoni  l.spampinato and g.tornielli 1   we introduce a concept of invariance for the resolution tree of logic. we also provide an informal proof of the invariance of the logic processor tree while processing itself. 
   the construction of a new pis  based on a language so different from lisp  has revealed very interesting and stimulating although not completely straightforward. it lead us to the following considerations. 
1  the crucial points are the choices of a proper representation of the normalization process' state and the way reflection is described in the processor's code. the first choice has to be made in the perspective of the system actual use. in logic  the representation of the search tree was designed to achieve the power of current logic programming systems by means of reflection. for sld a stack is enough  but a richer representation allows the user to profoundly influence the search strategy writing simple reflective code. 
1  the mechanism which restarts the computation after each input-normalize-output loop  is quite difficult to design. in logic  the generalization of the reply-continuation approach of 1-lisp  required several attempts and the exploitation of some tricky properties of the resolution tree representation. 
1  the finite nature of the processor can be a little painful to verify also if it is easy to guess. the notion of tail recursion must be considerably generalized to be applied to interpretation structures more complex than a stack. 
iv 	step three: integration and mutual reflection 
   we introduce mutual reflection with two observations about the preconditions for procedural introspection. 
1  only when introspection takes place  by means of a reflective act   it is necessary to explicitly know the formalism in which the processor is written. if a program does not introspect  it is processed by an implicit processor the description of which has not a role in computation. in other words  the actual form of the processor description has to be fixed when some reflective code makes access to it. 
1  the description of the system itself  which a pis embodies  must: i  completely describe the reflection mechanism; ii  be suitable for a finite implementation  shifting processor ; iii  be completely processed by the processor it defines. such requirements are implicitly satisfied by 1-lisp and by every pis based on a single language. nevertheless  it is not mandatory for the selfdescription of a pis to be homogeneous with respect to the representation formalism. 
   with mutual reflection the formalisms in which the processor currently running is explicitly represented can be chosen dynamically at each reflective act. 
   in alice the user can employ  at the starting level  lisp or horn clauses starting the normalization of a program in the chosen formalism; let's say lisp. if there are no reflections  the running program is normalized by a lisp processor whose description is unspecified. in the user program lisp or logic reflecters can be freely used. the normalization of a lisp reflecter forces the current processor to be represented in lisp and the reflective user code is merged in it. the second level 
1 	architectures and languages 
processor is a lisp one but its representation remains unspecified. the normalization of a logic reflecter at the starting level forces the processor at the first level to be a lisp one represented in logic and the reflective user code  a sentence  is merged in it. so the second level processor is a processor for logic but its representation remains unspecified. when starting from logic the same holds with logic for lisp and vice versa. as alice is a pis  reflective acts give access to the representation of a normalization process' state. 
   this behaviour can be obtained if the descriptions of four processors are available: one for each pair representation language - normalized languago. the normalization of a lisp reflecter in a lisp program gives access to the lisp in lisp processor. a logic reflecter in a logic program gives access to the logic in logic one. the normalization of a lisp reflecter in a logic program gives access to the logic processor written in lisp and a logic reflecter in a lisp program gives access to the lisp processor written in logic. in this sense we speak about mutual reflection. 
   interaction is now easy. when the user introduces a reflection  whatever reflecter she may use  she can both get the state of the current normalization of her code in the starting language and start a new normalization process with respect to the other language. in this way she is given a simple and powerful tool to construct the 'bridge' between horn clauses and lisp more convenient for each specific application. 
   the alice description available  in alice  is composed of two parts. the first consists of the code of the two processors written in lisp  the lisp description . the second consists of the two processors written in logic  the logic description . each description represents the two normalization processes. thus  each of the normalizations has a double description. the choices in the representation of the state of the normalization process are the same for the corresponding descriptions. this makes it possible to keep the representation of the state independent from a normalization process and from the particular language the processor is written in. 
   the lisp description represents the way lisp reflecters are processed  reflection mechanism  when they are inserted both in lisp and in logic code. the logic description represents how logic reflecters are processed symmetrically. in this sense  the two descriptions are complementary in describing the whole system. alice is procedurally introspective as a whole but its model of itself is decomposed in two parts. it has a single polymorphic introspective ability. 
   a finite implementation is possible due to the finiteness of the whole alice description as informally proved in  r.ghislanzoni  l.spampinato and g.tornielli 1 . 
v examples 
   in alice it is possible to move the computation above the current level and start an interaction with the chosen processor. the reflectible function quit  as defined above  allows to move in the lisp description of the current level: 
	'lisp 1    quit  	'horn 1    quit  
	'lisp 1= 'quitted 	'lisp 1= 'quitted 
one can also move in the logic description of the current level: 
{clauses: {quit :x :y :z}} 
	 hornl  ~{quit} 	*lisp1  '{quit} 
	'horn1=$f 	'horn1  $f 
   a reflectible alice lisp function to be used in lisp reflecters within logic programs follws. it asks about the provability of a sentence when it cannot be proven otherwise. 
 define ask  lambda   to-prove  env tree  
 let   unif  unif-env-and  and-level tree     
 cond   prove env  make-tree to-prove unif   
 prove env tree   
 $f  block 
 output 'can-be-proven   
 output  expand to-prove unif   
 if  =  input  'yes  
 prove env tree  
 prove env 
 clcar-and-level tree          
for example: 
'horn 1   {a 1} 
horn 1 = $f horn 1  ~ ask{al}  
'can-be-proven  '{a 1} yes 
'horn 1   $t 
the last example is a couple of logic reflectibe predicates to be used in logic reflecters within a lisp expression. it is the definition of the well known *catch-*throw control structure. 
 clauses: {rule {*catch :args xatch-env xatch-cont :result} 
{lst:args:tag} 
{1nd :args xatch-body} 
{up xatch-cont :upped-catch-cond} 
{bind :tag xatch-cont xatch-env :augmented-env} 
{normalize :catch-body :augmented-env xatch-cont :result}}} 
{clauses: {rule {*throw :args :throw-env :throw-cont :result} 
{1st :args :tag} 
{1nd :args :throw-exp} 
{binding :tag :throw-env :upped-catch-cont} 
{down :upped-catch-cont xatch-cond} 
{normalize :throw-exp :throw-env xatch-cont :result}}} 
they can be used as follows: 
 define member  lambda  atm list  
-{ catch stop 
 mapc  lambda  x  
 if =xatm  
~{*throw stop $t}   
list }   
vi conclusions 
   the experience of the alice project lead us to a couple of general consideration about the actual development of piss. 
1  the shifting processor approach can actually help in embodying procedural reflection in systems more complex than 1-lisp. moreover  the method - implicit in it - of incremental generation of the explicit representations when they are needed  make it possible to use reflection as a powerful tool for the integration of different formalisms. 
1  mutual reflection can be extended to any set of procedural languages  provided that each of them can be implemented in a pis and a new reflecter type can be added to its structures. this extended alice system would have n descriptions of itself   for n involved languages . each of the descriptions would contain an interpreter for each language and describes the system when only reflecters of the language in which is written are used. all the descriptions together would constitute the self description of the system which would be procedurally introspective as a whole. in this sense  alice can be seen as an achitectural proposal for systems in which many different formalisms are integrated in a modular way. 
acknowledgements 
we are grateful to g.degli antoni  b.c.smith and j.des 
rivieres for the discussions which were of great help in making clear to us the role of our work. we would also thank d.friedman for his encouraging comments . 
