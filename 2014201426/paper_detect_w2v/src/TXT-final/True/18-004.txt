  implementation independent specification of semantics is worthwhile in that it provides a simple way to understand the complexity of the actual system. 
   using first order logic  most of the intended meaning of dlog descriptions can be specified in a relatively straightforward way. the individual descriptions  definite and indefinite  are specified as above; sets can be axiomatized with a set relation and a set membership relation   dlog set theory is finite  thus very simple . however  lambda terms rely on semantic notions foreign to first order logic; their definition here requires the use of meta language concepts. 
   contextual definitions for set descriptions are defined as follows. the sentence 
 1  
contains no set variables-the term   describes a set consisting of all individuals a such that is true. in a first order language that distinguishes set variables x1 x1  x1 ...  the definition of sentence  1  is rendered as 

this can be read as  there is a set x1 that has property ¦µ  and all individuals x  in the set have property £¤.  because the only defining property of a definite set is the property attributed to each of its members  its uniqueness is easy to establish. in contrast to definite individuals  there is only one extension for each definite set so a further specification of uniqueness is not required. 
   the contextual definition of indefinite sets can be approached in a similar way. we can view 

as having the definition 

this says that  some set x1 that has the property o and whose elements each have property  also has property ¦µ.  intuitively  the indefinite set construction specifies a set that fits the description  similar to the way that an indefinite individual specifies an individual that fits its description. 
   dlog lambda constants provide the user with a method of asserting axioms about unary predicate abstractions  intuitively interpreted as regulations. for example  the assertion 
can be interpreted as asserting that the property  is true of the regulation named by  . these terms are useful because they allow a user to assert relations about properties. intuitively  lambda constants are most reasonably interpreted as a special kind of constant  indexed for retrieval by the terms they appear with. however  they cannot be manipulated without the definition of an application mechanism. this definition relies on a meta relation satisfies  which is defined in terms of the provability meta relation derivable  cf.  bowen1  . the satisfies meta predicate then provides a method for testing whether an individual satisfies the relation denoted by a dlog lambda constant. that is  

for any individual constant a of a dlog database db  
 holds in db. an 
assertion of the form 
	  	 1  

is interpreted to mean that  in the current database  
 1  
is derivable. indeed  1  is a clumsy alternative to  1   but by using lambda constants in this way  we not only provide a way of asserting axioms about regulations  but also a way of using those regulations in question answering. the satisfies predicate provides the mechanism for applying lambda constants as unary predicates of the current database. 
   an example will illustrate. the experimental ddb domain requires the description of degree requirements  which can often be expressed as lambda constants  e.g.  the assertion 
	enrolment 	-requirement 	 bsccs  	 1  

states that  an enrolment requirement of the bsccs degree is that the candidate's age is greater than or equal to sixteen.  the lambda constant format allows the requirement to be asserted and queried  and the satisfies predicate provides the mechanism to pose a query like 
		 1  
that can be read as  has john satisfied an enrolment requirement for the bsccs program   
   notice that  in the ddb domain  degree requirements are most naturally conceived as conditions which must be satisfied. since degree programs are distinguished by their various requirements  it is most straightforward to describe degree program requirements as relations on degree names and conditions to be satisfied-in dlog  as lambda terms. 
   of course there are alternatives to the use of this special term. for example  the meaning of sentence  1  might be rephrased in. terms of a standard first order language as 
		 1  
where we would use bsccs as the name of a degree program and modify the predicate satisfies to correspond more closely to our intuition regarding what one must do with degree requirements. this alternative has a more straightforward meaning since there are no  special  forms. but now there is no way of asking what the requirements of the bsccs program are  short of providing another non-first order primitive for manipulating sentences. for example  to answer the equivalent of query  1  in the alternative notation  we require an operation that retrieves a sentence of the 

1 r.goebel 
form  1  from the current database  and then returns the consequent of that sentence as an answer 
   lambda terms can be manipulated with a standard  sorted  proof procedure to answer existential queries about requirements; they are simply retrieved and bound to existential lambda variables as in normal answer extraction. furthermore  they can be used in conjunction with the satisfies predicate to determine if an individual has satisfied a particular requirement. 
the case for higher order semantics 
   the clear disadvantage of first order semantics is an inability to directly deal with higher order concepts. though dlog domains are restricted to be finite and no abstraction is permitted in the dlog proof mechanism  the specification of certain dlog expressions in a first order way is contorted and mitigates against the desired semantic simplicity. this is most obvious in the way that lambda terms must be explained in terms of meta relations. 
   one alternative is to use a second-order intensional logic  as used by montague to explain such concepts as  obligation    event   and  task   for example  montague's formalization of the concept of obligation  montague1  p. 1ff.  corresponds well with the use of lambda terms in the ddb application of dlog. 
   montague's system provides a natural semantics for dlog's lambda terms  and is obviously powerful enough to be used to describe the rest of dlog's descriptive terms  individuals  sets . only dlog lambda terms require this treatment  but montague's system provides a rather more uniform treatment of dlog's semantics than is possible in weaker systems. 
   the complete picture of montague's system requires careful study  but the essence can be explained in a relatively straightforward manner. an essentia  concept is the classification of individuals into categories of two different kinds. each n place predicate constant has an associated type  s1 su ' ' ' sn-1-  that indicates the kind of object that can appear in each term position:   -1 
specifies a standard* individual; s  -1 specifies a proposition; and si specifies a si -place predicate.** 
   for example  a predicate constant p of type  -1  takes individual constants in its first position and unary predicates in its second. in the department data base domain  the satisfies predicate constant has type  -1   e.g.  the assertion satisfies /red xx  completed  x  cs 1    
has an individual constant 'fred' in the first argument position  and a lambda constant in the second argument position. the first denotes an individual object  the person with name 'fred'   and the second denotes a predicate specifying the property of  x complete ing the course cs1.  
   the meaning of the above assertion is assigned in a way that introduces the second and most important difference of montague's system. the assignment of truth values to sentences is an inherently two phase process. as montague explains  montague1  p. 1   an interpretation assigns intensions to symbols  and a model assigns extensions. extensions include the standard objects well-known from traditional tarksian semantics  as well as sets of sequences of individuals. intensions are functions from possible worlds to the universe of individuals. they are introduced in order to distinguish the sense or abstract meaning of a predicate from its denotation in a particular possible world. 
   the complexity of montague's complete system can be perplexing  the essence of the system provides a rich specification language for dlog's complex objects. some of the complexity dissolves because of the simplicity of dlog theories: they are finite  and the 
* here  standard individual  means the usual notion of an individual in a first order model. 
   see |montague1  p. 1|. the notion of predicate used in this context is sometimes caed a  relation in intension.  
intended interpretation is over a highly restricted domain. this simplicity constrains the number of possible worlds that can serve as interpretations for dlog theories  thus  for example  providing a restricted interpretation of  ¡õ  . in the ddb example  the intended interpretation together with partial knowledge of each particular student identifies the intended possible world for semantic interpretation. 
   in montague's second order logic  the meaning of dlog lambda expressions is given by expressing them as unary predicate constants. for example  the dlog formula 
		 1  
is written as 
	 1  in general  the ¦µ syntax is shorthand for 

montague uses the symbols 'a' and v for 'v and '1'  respectively. 
he also uses brackets where parentheses arc typical  e.g.  p x  for p x . in addition montague employs the symbols hp and ¦µ'  read as  the  and  necessarily   respectively. these latter symbols are used to form names of predicates. dlog's lambda symbol 'x' plays the same role as montague's    symbol. 
   formula  1  is intended to mean  a requirement of the bsccs program is to bear the relation completed to the course cs1.  the intensional semantics provides a way of admitting different intensions for the completed relation  e.g.  completing a course might have different meanings in different passible worlds. in the case of dlog  the particular possible world in which symbols are assigned extensions is fixed to be the departmental database. 
   the second order power of montague's logic provides the expressive ability to assert relations on predicates: it is the property of completing cs1 that bears the requirement relation to the program bsccs  and not any particular extension of the property. again  the application of lambda terms can be explained with the aid of a relation called satisfies. however  in montague's language satisfies is a predicate constant of type  -1  and is interpreted  in a possible world t in a structure  i u f   as a relation  i u  i u  where / is the set of possible worlds and u the universe of possible individuals.  so  1  u  is a unary relation  
 i u u  is a binary relation  etc.  
computing with descriptions by extended unification 
   the mechanism for manipulating dlog descriptions is implemented in the horn clause logic of prolog. adopting one of the above approaches to semantics means to adopt the corresponding view of what the dlog proof procedure is doing. the simplest way to view the dlog proof procedure is as a horn clause prover extended with meta relations to handle the non-horn features of dlog. however  we speculate that the theoretical foundation of a higher-order proof procedure based on unification due to jensen and pietrzykowski  jensen1  will provide the corresponding view for the montague system. here the intuition is to consider the dlog implementation as a restricted implementation of their unification procedure for general type theory. we have not yet investigated the possibility of adapting jensen and pietrzykowski's procedure for use in an intensional logic. 
   instead of extending prolog's horn clause theorem prover to handle the expressions that arise from any method of contextual definition  the unification algorithm can be augmented to provide the correct matching of descriptive terms. as others have observed 
 e.g.   clark1  van emden1    any assertion of the form 



where the xi 1 i n are new variables not occuring in the original formulas. in dlog  the equality expressions arising from this transformation are determined from within unification. in a sense  some of the complexity of derivation is off-loaded to the  pattern matcher   cf.  reiter1  . 
   the idea of extending a resolution proof procedure's power by augmenting unification was first suggested by morris  morris1   who proposed that equality be manipulated with so-called  eunification.  there have been many other related proposals including stickel  stickel1   morgan  morgan1   and kahn  kahn1l   of related interest is the representation language krl  bobrow1a  bobrow1b  bobrow1   which relies on a complex  mapping  process on several different kinds of object descriptions called  descriptors.  we argue elsewhere that krl's mapping can best be understood as a elaborated unification scheme  goebel1 . 
   returning to the handling of descriptive terms by augmenting unification  we cite rosenschein on the advantage of embedded terms: 
...the data object is kept small and  hierarchical  so that where an exhaustive match must be performed  failure can occur quickly. that is  deep  heterogeneous structures are preferred to broad  homogeneous structures. for example  {  {    }} is better than {{}{}{}{}}! 
we view rosenschein's claim as support for the interpretation of descriptions as embedded terms  rather than as their contextual definition by rewriting. 
   the dlog unification algorithm is invoked by the dlog derivable predicate  similar to the way prolog's derivation procedure uses a built-in unification algorithm. intuitively  whenever a unification must be performed and there are special dlog terms to be matched  standard unification is intercepted  and dlog unification is used. for example  suppose that the two terms ex p x  and fred are to be unified. the applicable dlog unify axiom is 

where apply binds the symbol  fred  to the lambda variable  x  and invokes derivable. 
   the dlog unification definition uses an organization similar to the loglisp system of robinson and sibert  robinson1  robinson1 . loglisp consists of a logical proof theory embedded within lisp  and allows the invocation of lisp by the theoremprover  and the theorem-prover by lisp. similarly  the dlog derivable procedure can invoke the standard prolog proof procedure  and both are accessible from with dlog's unification matcher. 
¡¡in general  the correct  unification  of the dlog extensions requires a derivation procedure more powerful than that provided by prolog. for example  the equivalence of two lambda expressions  e.g.  can only be established if it can be shown that follows from the current database. the current dlog unification procedure uses a local context mechanism to derive this equivalence. it is also the case that disjunctive terms require a more general proof mechanism  since a proof of 
  cannot be handled by the current implementation  although a special heuristic will use a notion of partial proof to retrieve facts relevant to such a query  goebel1|. t |roaenschein1  p. 1 . 
	r.goebel 	1 
   bobrow and winograd's description of krl's matching framework  see  bobrow1a  ¡ì1   also uses the notion of partial match. their discussion about what is deductive and what is heuristic is sufficiently interesting to pursue here because dlog already provides some of the features of krl's  flexible  matching. 
   recall that the basic data type of krl is a frame-like structure called a  unit.  a unit is a collection of  descriptors  that attribute various properties to the unit in which they appear. of interest here are the various ways in which units can be related by matching their descriptors. for example  consider krl's matching by  using properties of the datum elements   bobrow1a  pps. 1 : 
consider matching the pattern descriptor  which owns  a 
dog   against a datum which explicitly includes a descriptor  which owns pluto . the self description in the memory unit for pluto contains a perspective indicating that he is a dog. in a semantic sense  the match should succeed. it can only do so by further reference to the information about pluto. 
this form of matching already exists in dlog. for example  the krl descriptors  which owns  a dog   and  which owns pluto  might be rendered as  and 
  respectively if we have the fact that pluto is 
a dog  i.e.  the assertion dog pluto    dlog unification will successfully unify the above pair by recursively proving that dog pluto  follows from the knowledge base. 
   several other forms of krl matching fall into similar categories  where a recursive proof will provide the inferences required to demonstrate the equality of descriptions. the only clear instance in which partial matches arise are due to resource limitations. again the partial results determine whether the current line of reasoning is to continue  perhaps given further resources   or to be abandoned. 
concluding remarks 
   we have argued that there may be more to the meaning of descriptions than their traditional tarskian semantics  especially as regards the way that they are manipulated within a logic-based representation language. we briefly outlined the kinds of descriptive terms included in the prolog-based dlog representation system  and discussed various ways in which those terms could be interpreted. lambda terms  useful in a particular application  do not have an obvious formal meaning and suggest the need for higher-order semantics. regardless of which semantic specification is selected  the notion of extended unification can be used to manipulate embedded descriptions. with some effort  the extended procedure can be viewed as providing either metalogical or higherorder proof theory extensions. 
   finally  it is important for representation systems to exploit the computational as well as the traditional denotational meaning of descriptions. the proceduralists have been saying this for years; we claim that logic can contribute to an understanding of the computational use of certain kinds of descriptions. 
acknow lodgements 
david poole suggested many improvements to an earlier draft of this paper. richard robinson pointed out the relationship between dlog's lambda terms and montague's formalization of obligation. 
