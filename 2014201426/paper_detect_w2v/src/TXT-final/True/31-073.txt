 
     a common technique for bounding the runtime required to solve a constraint satisfaction problem is to exploit the structure of the problem's constraint graph  dechter  1 . we show that a simple structure-based technique with a minimal space requirement  pseudo-tree search  freuder & quinn  1   is capable of bounding runtime almost as effectively as the best exponential space-consuming schemes. specifically  if we let n denote the number of variables in the problem  w* denote the exponent in the complexity function of the best structure-based techniques  and h denote the exponent from pseudotree search  we show h   {w* + 1   lg n  + 1  . the result should allow reductions in the amount of real-time accessible memory required for predicting runtime when solving csp equivalent problems. 
1 	introduction 
the constraint satisfaction problem  csp  is a combinatorial search problem whose occurrence in ai and other domains is well documented. briefly  a csp consists of a set of variables to which values must be assigned without violating constraints that disallow certain value combinations. in the general case  the csp is np-hard  and worst-case runtime of a csp algorithm is typically exponential in the number of variables. improved bounds arc achieved on some problems by algorithms that exploit problem specific features. a common technique is to exploit the structure of the problem's constraint graph  dechter  1 . the constraint graph of a csp graphically depicts constraint relationships by representing each variable with a vertex and each constraint with edges connecting the restricted set of variables. in general  the more sparse the constraint graph  the tighter the bound on runtime. for instance  problems with noncyclic constraint graphs can be solved in time linear in the size of the problem  dechter & pearl  1; bayardo & miranker  1 . 
       this paper investigates the extent of a space-time trade-off in solving the csp. it is often assumed that extensive use of space is necessary to reduce the potentially r ad behavior of backtrack search  seidel  1 . we show here that this assumption may be ill-founded. we compare the effectiveness of pseudo-tree search  freuder & quinn  1   a polynomial space-consuming technique for solving the csp  to that of the best structure-based schemes. dechter  dechter  1  has demonstrated that the best structure-based techniques all have worst-case time and space bounds exponential in a parameter known as induced width  w* . while the exponent in the runtime complexity function of pseudotree search  pseudo-tree height  or h   is always greater than induced width for any particular instance  we show that it is always within a logarithmic factor of induced width despite its low space requirement. specifically  we demonstrate that h   w*+ 1   lg n +l . 
       we foresee the result having applications in realtime ai. runtime prediction in production systems is sometimes accomplished by improving the complexity of the rule match phase  barachini  1 . tambe and rosenbloom  show that complexity of the production match phase can be improved using structure-based constraint satisfaction techniques. our result could allow reductions in the amount of real-time accessible memory required for predicting runtime in hard real-time systems solving problems equivalent to the csp. such reductions could prove critical in systems operating on large knowledge bases where domain size  the base of the exponent  is proportional to the amount of knowledge. 
       the paper begins with a more formal definition of the csp and constraint graph  and provides a description of backtrack search for solving the csp. we then review the concepts of pseudo-tree search and pseudo-tree arrangements of a constraint graph. the next section presents the definitions of induced graph and relates it to partial k-trees. finally  we establish the above-mentioned relation between pseudo-tree height and induced width and close with concluding remarks. the paper assumes the reader is familiar with elementary graph concepts and terminology  even  1 . 

this research was partially supported by an at&t bell laboratories ph.d. fellowship. 
1 	constraint satisfaction 
1 constraint satisfaction problems and back- the original edges from the graph appear dashed in the tracking pseudo tree to illustrate that adjacent vertices always appear 
　　　　　　　　　　　　　　　　　　　　　　　　within the same branch. note that while a depth-first search a constraint satisfaction problem  csp  is a set of variables tree is a pseudo tree  a pseudo-tree is not necessarily a depthand a set of constraints. each variable is associated with a first search tree. for instance  the pseudo tree appearing in finite value domain  and each constraint consists of a subset the figure is not a depth-first search tree. 
of the problem variables called its scheme and a set of mappings of domain values to variables in the scheme. an assignment is a mapping of values to a subset of the problem 
variables where any value mapped to a particular variable belongs to the domain of the variable. an assignment a satisfies a constraint c with scheme x if a restricted to the variables in x is a mapping in c. a partial solution to a csp is an assignment that satisfies every constraint whose scheme consists entirely of variables mentioned in the assignment. a solution to a csp is a partial solution men-
tioning every variable. 
the constraint graph of a csp has a vertex for each 
variable and the property that the variables in the scheme of a 
constraint are completely connected. this is referred to as the primal-constraint graph in  dcchter  1  when there are constraints with more than two variables in their schemes. 

without loss of generality  we assume problems have connected constraint graphs. if it were otherwise  we could simply view the disconnected instance as a set of instances  one for each connected component. 
a naive method for solving constraint satisfaction 
problems is chronological backtrack. chronological backtrack maps values to variables along an ordering of the variables until some constraint is violated by the working assignment. when a constraint is violated  the variable most recently to have been assigned a value is assigned another value from its domain. if ever the values in the domain of a variable are exhausted  a backtrack takes place to the previous variable along the ordering. the procedure continues until either the last variable is successfully assigned a value  in which case a solution has been found   or until all values from the domain of the initial variable are exhausted  in which case no solution exists . if we let k bound the number of values in any domain and n denote the number of variables  then chronological backtrack has a runtime complexity of 1 exp w   because a variable can be assigned a value up to k times. 
1 pseudo-tree arrangements and pseudo-tree search 
freuder and quinn  introduce the concept of a pseudofigure 1. a height-1 pseudo-tree arrangement of a chain with 1 vertices. 
pseudo-tree search  freuder & quinn  1  exploits 
pseudo-tree arrangements  and has a worst-case complexity function that is exponential in the height of the pseudo tree  h  . rather than explain pseudo-tree search in its full detail  we instead describe how to modify chronological backtrack so that it exploits pseudo trees in a similar fashion. given a pseudo-tree arrangement of the problem's constraint graph  we order the variables of the problem according to a depthfirst traversal of the pseudo tree.1 now  whenever a backtrack is necessary  instead of backing up to the previous variable in the ordering  we backtrack to the pseudo-tree parent of the current variable  possibly skipping over many variables in the process. this backtrack policy does not sacrifice completeness because  due to the structure of the pseudo tree  the assignments made to the skipped variables are irrelevant with respect to the current failure. we call this algorithm pseudo-tree backtrack. 
given the pseudo-tree arrangement  pseudo-tree 
backtrack has runtime complexity 1 exp h   since each variable can be assigned a value a maximum of kh times. the space requirement of this technique is a mere 1 n  beyond the size of the problem input to maintain domain value iterators and the variable ordering. 
　　　　　　　　　　　　　　　　　　　　　　　　bounding runtime  it requires a pseudo-tree arrangement tree arrangement of a graph. a pseudo-tree arrangement of a with shallow height. an efficient algorithm for finding the graph is a rooted tree with the same set of vertices as the 
original graph and the property that adjacent vertices from the original graph must reside in the same branch of the rooted tree  hereafter called the pseudo tree . a branch is simply a path from the root to some leaf. the concept is illustrated in figure 1  where a vertex in the rooted tree corresponds to the vertex directly above it in the original graph. note that the variable ordering need not be static since there are typically many different depth-first orderings. dynamic variable ordering involves modifying the unassigned portion of the ordering during backtrack  and can improve average-case performance  haralick & elliot  1; frost & dechter  1   	bayardo and miranker 	1 in order for pseudo-tree backtrack to be effective at minimum-height pseudo-tree is not known. though a proof eludes us  we suspect the problem is np-hard due to its similarity to various well-known np-hard problems including minimizing depth-first search tree height. 
       freuder and quinn  provide the following method for heuristically constructing a pseudo-tree arrangement: find a small set of vertices s whose removal from the constraint graph disconnects it  such a set is called a cutset . these vertices will form the first  s  levels of the tree. the remaining levels are formed by recursively applying the procedure to the remaining graph components in order to spawn branches  one for each component  beginning at level |1| + 1 . it is easy to verify that the resulting structure is indeed a pseudo-tree arrangement. the pseudo-tree from figure 1 can be constructed in this manner by selecting the middle vertex in each chain at each step to disconnect the remaining graph. 
       depth-first search can also be regarded as a heuristic technique for pseudo-tree arranging a graph. although  we have found it unlikely to find an arrangement with small height even when additional heuristics are applied. for example  consider an n vertex chain graph. any depth-first search tree has height at least !~  whereas a pseudo-tree arrangement always exists with neight at most lg n  + 1  e.g. as implied by figure 1 . 
1 	induced width 
dechter  demonstrates that the best structure-based algorithms for solving the csp are exponential-in both time and space-in a constraint graph parameter called induced width  w* . the actual exponent in the complexity function of these schemes  e.g. adaptive consistency  dechter  1   is w* + 1 . the parameter is obtained from the constraint graph 
after imposing a variable ordering on which the algorithm operates. a child of a vertex in a graph with an ordering of its vertices  an ordered graph  is an adjacent vertex that follows it in the ordering. a parent is an adjacent vertex that precedes it. the induced graph of an ordered graph g is an ordered graph with the same ordered set of vertices as g and the smallest set of edges to contain the edges of g and enforce the property that any two vertices sharing a child are adjacent. we can build the induced graph of g by iteratively connecting any nonadjacent vertices that share a child. finally  the induced width of an ordered graph g is the maximum number of parents of any vertex in the induced graph of g. 
       figure 1 illustrates the process of creating the induced graph. the ordering is assumed to be from top to bottom. edges added to form the induced graph are dashed. note that the graph has an induced width of 1. 

       like schemes exploiting pseudo trees  the effectiveness of techniques exponential in induced width depends upon the quality of the constraint graph arrangement. minimizing induced width is np-hard  arnborg  1   so heuristic techniques are typically applied to produce the ordering. 
       we can always order a graph so that its induced width is less than the height of any pseudo-tree arrangement. given a pseudo-tree arrangement of a graph g with height h  ordering the vertices of g according to a depth-first tra-
versal of the pseudo tree produces an ordered graph with induced width w*   h - 1 . this is because when creating the induced graph from such an ordering  no edge can be added between vertices in different branches of the pseudo tree. the number of parents of any vertex in the induced graph is thus bounded by the number of its pseudo-tree ancestors. 
       the above establishes that techniques exponential in induced width can always be made as effective in bounding runtime as techniques exploiting pseudo trees. in fact  for certain classes of problems  induced width is usually better. for instance  any noncyclic graph can be ordered to have an induced width of 1  but pseudo-tree arrangements of chain graphs must increase at least logarithmically with the number of vertices. 
       in the next section  we bound how much more effective induced width techniques are in the general case. before proceeding  we review a useful fact relating induced width to k-trees. a graph is a k-tree  beineke & pippert  1  if: 
  the graph has k vertices and is complete  said to be a trivial k-tree   or 
  there is a vertex of degree k whose neighborhood induces a complete graph  and the graph obtained by removing the vertex is a k-tree. 
note that a connected noncyclic graph is a 1-tree. a partial k-tree is a partial graph of a k-tree. the following is due to 

1 	constraint satisfaction 

freuder: 
       theorem 1: an ordered graph with induced width w* is a partial w* -tree. 

1 	relating pseudo-tree height and induced 
width 
we now show that given an ordered graph  we can construct a pseudo-tree arrangement of the graph where h is within a logarithmic factor of w*. this implies that no matter how effective we can make induced width techniques solve particular classes of problems  we can make pseudo-tree search solve them almost as effectively without the added burden of an exponential space requirement. 
       the idea behind our approach is to generalize the case for 1 -trees to that of general graphs by making use of ktree embeddings. it is easy to establish that a 1-tree of n vertices can be split into components that contain at most u vertices by removing a single vertex. we can therefore generate a pseudo-tree arrangement with h   lg n  + 1 of any 1 tree using the heuristic arrangement method from section 1. the idea is to always select for the cutset a vertex whose removal splits the remaining graph into components whose sizes  number of vertices  are at most half that of the original. since such a vertex always exists  splitting recurses at most lg rt  + 1 levels deep  generating a pseudo-tree arrangement with height at most  g{n  + 1 . 
       we now generalize to arbitrary graphs. consider an ordered graph g with induced width w*. we know from theorem 1 that this graph can be embedded into a w* -tree with the same number of vertices. we establish how to find the appropriate vertices for splitting k-trees  thereby allowing us to generalize the previously described algorithm for pscudo-tree arranging 1-trees. 
       a clique of size /' is said to be adjacent to another clique of size / if they share /' - 1 vertices. define depthfirst search on a non-trivial k-tree to traverse adjacent k + 1 cliques instead of adjacent vertices. figure 1 illustrates a 
       depth-first search tree resulting from traversing a 1-trec in such a manner. we refer to such a depth-first search tree as the clique tree of the k-tree. while there may be more than one clique tree depending on where the depth-first search begins and what tie-breaking rule is applied  any clique tree is sufficient for the upcoming claims. 
       each node of the clique tree corresponds to some clique in the k -tree  and the edges represent their interconnection. we now state two properties of clique trees  leaving the proofs as exercises. given a non-trivial k-tree g with n vertices and a clique tree t of g : 
  t has exactly n-k vertices. 
  given a vertex v whose removal from t leaves behind connected components of size j  the clique represented by v  when removed from g  leaves behind components of size at most j. 
we next use these properties to establish the following lemma: 
       lemma 1: given a non-trivial k -tree g with n vertices  there exists k + 1 vertices in g whose removal leaves behind connected components of size at most 1. 
　　　proof: we have already noted that a 1-tree can always be broken into components of a size at most half that of the original graph by removing a single vertex. from a clique tree t of the k -tree  we can therefore find a vertex v 
　　　whose removal splits t into components of size n-k/1   n. the k + 1 vertices in the clique represented by v  when removed from the k -tree  must therefore leave behind connected components of size at most n. d 

　　　this method for breaking apart k-trees allows us to bound the size of the cutset required for splitting arbitrary graphs and the size of the resulting components: 
       corollary 1: given an ordered graph g with induced width w*  n   w*  there exists w* + 1 vertices in g whose removal leaves behind components with size at most n/1. 
　　　proof: theorem 1 tells us we can embed the graph into a w* -tree with the same number of vertices. because n   w*  the w* -tree is non-trivial and the claim thus follows immediately from lemma 1. d 
　　　we lastly apply the above fact to define a pseudotree arrangement procedure  thereby allowing a bound on pseudo-tree height. 
       theorem 1: given an ordered graph with induced width w*  there exists a pseudo-tree arrangement of the graph with h    w* + 1   lgw + 1  . 
　　　proof: for n - w*  the claim is trivially satisfied by linearly arranging the vertices. otherwise  by corollary 1  we can find w* + 1 vertices whose removal leaves behind components with less than half the vertices of the original graph. we can use such a set to form the first w* + 1 levels of a pseudo-tree. the resulting components must have induced width of w* or less  they are simply subgraphs of the original graph . thus  the remaining variables can be pseudo-tree arranged by applying the procedure recursively on each component. a new pseudo-tree branch is thereby spawned for each remaining component as is done by the heuristic pseudo-tree arrangement procedure from section 1. 
       now  each stage of the recursion leaves behind components whose size are at most half that of the previous graph. therefore  recursion depth can be bounded by lg n  + 1 . since each level of the recursion adds at most 
	bayardo and miranker 	1 
w* + 1 new levels to the tree  the resulting pseudo tree has 
height at most  w* + 1   lg n  + 1  . d 
       theorem 1 tells us we can always make the exponent in the complexity function of pseudo-tree backtrack within a logarithmic factor of that of the best exponential space-consuming schemes. our proofs are constructive and describe a polynomial time-bounded procedure for accomplishing the task. while we did not describe a  polynomial time  procedure for finding the k-tree embedding  such a procedure appears in  freuder  1 . 
1 	conclusions 
we have demonstrated that while the best structure-based techniques require exponential space  they are capable of bounding worst-case performance only slightly better than pseudo-tree search  a simple polynomial space-bounded scheme. attempting to trade space for time is therefore of limited benefit. interestingly  we have a similar case with respect to average case performance as well. for example  frost and dechter  have found that algorithms performing unlimited constraint recording during search  thereby consuming exponential space  barely outperform polynomial space-bounded constraint recording algorithms. 
       we lastly note the open problem of either  a  finding a polynomial space algorithm that runs in time exponential in induced width  or  b  proving no such algorithm exists. current approaches for achieving the runtime bound fundamentally require exponential space since they record high-arity constraints or generate all solutions to certain subproblems. on the other hand  proving no such algorithm exists seems like a p = np related task. we therefore feel that solving the problem will be difficult if not impossible. 
