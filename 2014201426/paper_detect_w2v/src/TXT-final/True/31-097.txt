 
an essential component of an intelligent agent is the ability to notice  encode  store  and utilize information about its environment. traditional approaches to program induction have focused on evolving functional or reactive programs. this paper presents mapmaker  a method for the automatic generation of agents that discover information about their environment  encode this information for later use  and create simple plans utilizing the stored mental models. in this method  agents are multi-part computer programs that communicate through a shared memory. both the programs and the representation scheme are evolved using genetic programming. an illustrative problem of 'gold' collection is used to demonstrate the method in which one part of a program makes a map of the world and stores it in memory  and the other part uses this map to find the gold the results indicate that the method can evolve programs that store simple representations of their environments and use these representations to produce simple plans. 
1 introduction 
the ability to notice  encode  store  and utilize information about the environment is an essential component of intelligent behavior. storing a model or map of the environment increases the problem solving capacity of an intelligent agent. however  much of the research on the artificial induction of computer programs has focused on reactive programs with no use or only a minimal use of state. these programs  although generated by an artificial process  do not themselves learn or produce plans of action. 
　genetic programming  koza 1  is a variant of the genetic algorithm in which the genetic population consists of computer programs rather than of fixed length bitstrings or other fixed data structures. the initial population of programs consists of randomly generated programs represented as parse trees that are composed of the available simple programmatic ingredients. genetic programming then breeds these programs using the darwinian principle of survival of the fittest and the crossover operation  which is similar to sexual recombination in nature. tackett  1  provides analysis that genetic programming can be viewed as a method of stochastic beam search. 
　this paper presents mapmaker  a method for the automated generation of computer programs that discover information about their environment  encode this information  store it  and then utilize this information to produce plans of action. these programs are evolved using genetic programming and the structures of the evolving programs are constrained so as to facilitate the development of learning and the use of memory. the method evolves solutions to the gold collection problem  where the agent must learn the positions of gold in each of several worlds  store this information in a usable fashion  and then later utilize this information to produce simple plans to collect the gold. several evolved solutions to the problem are discussed that generalize perfectly to worlds on which they have not been trained. in addition  the mental models created by these successful individuals are understandable and clearly represent models of the world. also  evidence is presented that random search could not find even partial solutions to the problem in any reasonable time. 
1 background on genetic programming 
as described in john koza's seminal work  1   genetic programming is a method that breeds populations of computer programs  such as those shown in fig. 1 . the genetic programming performed in this research employs steady-state selection  syswerda 1   a minor variant on koza's methods  koza 1 . genetic programming with steady-state selection consists of the following steps: 
 1  create an initial population by randomly generating programs composed of the primitive functions. 
 1  execute each program in the population and determine its fitness based on its ability to solve the problem. 
 1  loop over the following until either a complete solution or a satisfactory result is found  or a limit on the number of reproductions is exceeded. 
 a  create two new offspring by applying the crossover operation. crossover creates two new programs by swapping randomly chosen subtrees of two existing programs  the parents - fig. 1 . the parents are selected probabilistically based on high fitness. programs with high fitness will be selected often  programs with low fitness will seldom be selected. 
 b  kill two members of the population to provide space for the two new children. choose these individuals probabilistically based on poor fitness. 
 c  evaluate both children and determine their fitness. 
　although the programs expressed in fig. 1 are simple  genetic programming can evolve much more complex programs  utilizing complicated programmatic structures. genetic programming can evolve programs utilizing iteration and subroutine calls  as discussed in koza  1 . automatically defined functions  adfs  are subroutines that are co-evolved with the main program  and can increase the power of genetic programming  koza 1 . for more information on genetic programming  see kinnear  1   which reviews advances in genetic programming. 
	andre 	1 

1 	related work 
the acquisition of mental models and the automatic synthesis of agents that learn are not new areas for the field of evolutionary computation. neural network learning methods have often been combined with genetic algorithms that specify the layout of the network and/or the initial weights  belew et. al. 1; ackley and littman 1 . however  these methods do not use explicit representations of state - the 'memories' learned are stored in the weights and are thus closed both to introspection and to human understanding. additionally  the role that the neural net plays in the individual is often pre-specified  and thus the learned representations can only be used in limited ways. in genetic programming  the use of branching operators that depend upon the state of the environment is common  kinnear 1 . when an evolved program combines several actions and branching statements through the use of progn statements it incorporates an implicit use of state. however  this state represents at best only an implicit representation of the world  is not available for introspection  and often can be difficult to comprehend. occasionally  gp applications allow the evolving programs to use a few variables of state  andre 1b; koza 1   but this is hardly representational memory. 
　one successful use of evolved representational structures is teller's  1a  on work on using indexed memory in genetic programming. teller evolved programs that could solve a simple problem - that of pushing blocks up against the boundaries of a world. teller used an interesting strategy to facilitate the use of memory in his evolving programs; he strictly limited the function sets so that the evolved programs could move only once per evaluation and receive only limited sensory feedback. without using memory  only minimal fitness was possible. in addition  teller has proved that his indexed memory paradigm is 
turing complete  teller 1b . although it is valuable work  teller's indexed memory scheme poses several flaws for the study of the evolution of agents utilizing mental models. first  the evolved representations developed by his programs are difficult to interpret. second  teller's representation allows individuals to perform well using only indirect models of their world  such as simple counters. 
　in some preliminary work with the mapmaker method  we demonstrated that agents could evolve to solve the gold collection problem when programs had access to only one memory cell for each world location  andre 1a . this previous work used the same multi-module mapmaker architecture used in the current work  but the evolved agents utilized a two-dimensional memory that simplified the computation. the function set was too complex: movement in memory was hard-coded to movement in the world to reduce the demands on evolution. the evolving representations were constrained so that they exactly matched the structure of the world. 
the present research addresses these issues by extending 
teller's  1a  indexed memory scheme. indexed memory allows for a wide variety of representations. in addition  because the system uses a multi-module architecture for the evolving programs and a multi-phasic fitness environment in which the input and output processes of the individual programs are kept separate  the evolved representations of the world are easily available and comprehensible. 
1 	the mapmaker architecture 
　one problem inherent in investigating the use of memory and internal representation in program induction is that many problems can be solved without state. solutions using memory may be less complex than those not using memory  but may be harder to evolve. genetic programming is known for exploiting loopholes  and thus to evolve the use of memory  one must constrain the fitness environment in order to promote its evolution. teller  1a  required the use of memory by restricting the building blocks and the sensory inputs. the mapmaker architecture   fig. 1a   depends on multi-modularity and sensory deprivation to force the evolution of memory. each individual consists of two modules  each of which is executed separately with different inputs and outputs. the first module  the mapmaker  can examine sensory information and may store and read information in memory  but may not act in the world. the second module  the map-user  is blind with respect to the world; it must use only its stored representation to produce a plan. the plan is then evaluated and its fitness determined. assuming that the task requires specific knowledge about the current world  memory representations of the world are required to achieve good fitness  because of the separation of perception and action into the two modules. 
　the mapmaker architecture facilitates in understanding the representations used by the evolving agents because it provides an opportunity to examine the exact internal state that represents the world: the information contained in memory at the moment after the map-maker is executed is all the information the map-user may use in creating a plan  and thus represents the entire representation of the world. another aspect of the mapmaker approach is that it parallels the stages often used in psychological studies of memory - stimulus  delay  and retrieval. 


1 	genetic algorithms 


figure 1 a  the mapmaker architecture  b  toroidal worlds for the gold collection problem 

　in this architecture  the fitnesses for both modules of the individual are determined only by the output of the mapuser. this is an extension of the credit assignment problem inherent in program induction - which part of the program caused the high or low fitness  although this sort of indirect fitness is normally encountered when multi-part programs are evolved  it is especially salient in this approach because the two modules are executed separately  and the behavior of the map-maker only affects fitness if the mapuser utilizes information from memory. 
1 the gold collection problem 
the goal in the gold collection problem is to dig up all the gold  without digging on squares that have no gold. the agent operates in an nxn toroidal world  fig. 1b . the squares in the world can be identified by the vector of integers modulo  1v-1  of the form  i j  where 1 these can be stored and manipulated as a single integer when n   1. thus  1 is the square  1   and 1 is the square  1 . this representation was used to allow the programs access to their position and still allow the functions to always return integers. the agent initially starts off in square 1. an individual interacts with the world as follows  fig. 1a  . first the map-maker module of the individual is iteratively allowed to observe the positions of each gold in the world  one gold at a time. this module can store this information in memory. then  the map-user module is allowed to examine the contents of memory  and to output actions into the plan this plan is then executed  and the numbers of golds collected and erroneous digs performed are calculated and used to determine the fitness of the individual. each evolving individual is evaluated on several worlds with different arrangements of gold to promote solutions that will generalize well to worlds not used in evolution. 
though many world sizes and gold densities are possible  we used world sizes of 1  1  and 1. the number of gold in the worlds is approximately half the number of squares in the world  with the exception that in the 1 world  gold densities of 1  1  and 1 golds per world were also investigated. although it may seem that these world sizes are trivial to map  such is not the case. in order to succeed  the map-maker and the map-user must evolve to agree on a representation. the map-maker must evolve to store all gold positions in memory in some fashion  and the map-user must evolve to use this information to constrain and guide its digging and movement actions. although in the 1 world with 1 gold there are only 1 possible configurations of gold  there are infinitely many ways to encode this information and the map-user and the map-maker must evolve a shared representation. evolving a map-user to select what the plan for gold collection should be is not trivial because there are infinitely many plans that attempt to dig only once  infinitely many that dig n times on the same square  etc. the map-user must also evolve the code to move around the world to the squares with gold. if the map-user takes the simplest option and avoids path planning by visiting every square  then it must solve koza's lawnmower problem  koza 1 . koza found this problem to be difficult when no adfs were used  and straightforward  although not trivial  when adfs were used. solutions are thus not easily generated  even for the tiniest worlds. the 1 world is also similar to square world  a problem in the ai literature used to illustrate planning strategies  genesereth and nourbakhsh 1 . 
1 algorithmic details 
　there are four steps in preparing to use genetic programming on any problem  namely specifying the architecture of the programs to be evolved  the set of primitive programmatic ingredients  the fitness function  and the parameters for controlling the run. 
　the architecture of the evolving programs is shown in fig. 1. the map-maker module has an easier task than the map-user; because it is directly shown the positions of the gold  it must only store the gold locations in some fashion that the map-user can comprehend. therefore  adfs  subroutines  are not needed in the map-maker  but are in the map-user. the adfs in the map-user are arranged hierarchically; the result producing branch for the mapuser  rpbu  can call both of the adfs  and adfu1 can call adfu1. both adfs take a single argument. 



　the set of primitive programmatic ingredients must be specified prior to a run of genetic programming. these ingredients are the basic building blocks for the programs to be evolved. for the gold collection problem  we choose the functions shown in table 1. 
　each module and adf of the program has a slightly different function set to account for the varied behaviors allowed in each. the map-maker has no access to functions for motion  for example  but has access to view the world through the goldpos function. additionally  some functions are constrained to occur only in the adfs to engender their widespread  consistent use. previous work  andre 1a  indicated that runs that had no such restrictions were largely unsuccessful. restricting key functions to an adf forces that adf to be used when the behavior produced by those functions is needed. when the adf is changed  the modifications occur in all places where the functionality is used. 
　the function sets for each of the different branches for the gold collection problem are shown in table 1  1  and 1 are constants chosen for their usefulness in this problem because  for example  1 represents the vector  1  which is one step in the x direction. r refers to the ephemeral random constant  ephemeral random constants provide a method for creating constants in gp  koza 1 . adfu1 and adfu1 are one-argument functions that call the appropriate adf  subroutine . arg l is a zeroargument function that contains the dummy variable  formal parameter  passed to an adf. 
　the add and sub functions act on a pair of integer vectors. these operations use digit by digit arithmetic modulo the size of the world. for example  in a 1 world   add 1  = 1. not returns a 1 if its argument evaluates to 1  otherwise it returns a 1. progn evaluates both its arguments and returns the value of the second argument. self returns the individual's current location in the world. dignow outputs a 'dig' command to the plan. 
jump  a  outputs a command to the plan that changes the agent's position by a displacement of a in the world. for example  if an individual were at position 1 in the world   jump 1  would move the individual to position  1  in the world. 
　goldpos     used by the map-maker  returns the position of the gold that the map-maker is currently allowed to view. repeat  a b  takes the result of its first argument a  modulo the size of the world  and iteratively executes the second argument b that many times. repeat returns the value of the last execution of the second argument b. repeati a b  is much like repeat  excepting that repeat index    is set within repeat 1. the repeat index    is equal to the current iteration number. putmexn a b  puts b into memory cell a and returns the previous value of cell a. readmem a  returns the value of cell a. incmem a  increases cell a by 1. the fitness function in the gold collection problem is straightforward. the goal is to collect all of the gold in each of several worlds without making any incorrect digs. thus  to attain a perfect score  the individual acting in the 
1 world must collect all 1 golds - one from each of 1 worlds - without any false-digs  and the individual acting in the 1 world with 1 golds per world must collect 1 golds - 1 from each of 1 worlds. the golds were distributed randomly in each world. the fitness of an individual is a weighted sum of the number of golds not picked up and the number of false digs. in addition  there is a large penalty for picking up no golds. thus the fitness function is equal to the following expression  where lower fitness is better. 
1*gold remaining+1*num of falsedigs+ 
 1 if gold=1 . 
　the next step in preparing to run genetic programming is to choose values for various parameters of the run. tournament selection  goldberg and deb 1  with a tournament size of 1 was used to choose parents for crossover. to choose parents to be removed from the population to make room for the newly created children  tournament selection with a tournament of size 1 was used. larger tournament sizes for the removal operation result in overly greedy evolution. the population size and maximum number of generation equivalents for the presented research are shown in table 1. one generation equivalent is defined as the number of reproductions necessary to create as many children as there are individuals in the population. 


table 1. function sets for the branches of the evolving programs  and the argument structure for each of the functions. 
1 	genetic algorithms 

1 	results 
the runs were performed on a variety of machines  including sun sparc 1's  a dec alpha  and 1 machines. runs took an average of 1 days to complete. in all world sizes  approximately 1 of the runs produced solutions. on the non-successful runs  nearly correct individuals emerged that collected most of the gold and dug on very few squares with no gold. successful results for each world size will be briefly discussed. on the 1 world  four solutions emerged out of ten runs. one such solution emerged after processing 1 1 individuals. the behavior of this individual was straightforward. the map-maker would fill memory elements directly corresponding to locations in the world with the value 1  and then would reset these cells to 1 if a gold was found there. additionally  the symbol 1 was also used to signify a non-gold. memory traces from four worlds after the map-maker has been executed are shown in table 1. when golds were at  1  and  1   for example  memory cells 1 and 1 are set to 1  whereas cells 1 and 1 are set to 1. the map-maker also stores some redundant information that is not used by the map-user. for example  whenever there is a gold in position  1   memory cell 1 is filled with a 1. it seems that the process of development might be that the map-maker first evolves to store information about the world in many redundant ways  and then the mapuser learns enough of one of these representations to be able to achieve a better fitness. 
　on other successful runs on the 1 world  representation schemes were similar  although different symbols were used. in one scheme  the map-maker stored the representation for locations in the memory cell corresponding to the square one square to the left of the location. this offset was learned by both the map-maker and the map-user  and changed the notion of what correspondence to the world meant. 
　one of the 1% correct solutions to the 1 world evolved after 1 individuals had been processed. the program code for this individual is shown below: 

　although this individual looks complicated  its behavior is actually quite simple to understand  because of the mapmaker architecture. not only can the behavior be largely understood from the output plan and the state of memory between the execution of the modules  the code can also be understood through analysis. this individual stores a 1 in the memory cells corresponding to gold positions in the world  a scheme similar to that shown in the 1 solution. however  the map-user in this world shows some other interesting uses of memory. the map-user in this case learned a single route over the 1 world and checked its memory at each square to see if it should dig. however  the route it learned overlapped  so it would pass over some squares more than once. to avoid digging on squares that had already been dug  the map-user stored a 1 in memory at each cell after having been there. in addition  it stored a '1' in the memory cell corresponding to the initial square. 
　the learned world representation not only allowed communication between map-maker and map-user  but allowed the map-user to use memory to avoid redigging at any locations. this individual's solution to the 1 world with 1 golds was completely general as well; although only trained on 1 different combinations of 1 golds per world  the individual collects without error any and all gold that is given to it in the 1 world. the ability of this individual to collect gold on all 1 worlds is shown in two ways: 1  it was tested experimentally on 1 worlds not included in the original evolution  and 1  is also a provable consequence of the code. 
 successful individuals emerged at all four gold concentrations examined in the 1 world. when there was only one gold per world  one evolved individual - found after processing 1 individuals - utilized a quite different representation scheme than did the solutions to the 1 and 1 worlds. the individual stored the position of the gold in a hard coded memory location  cell 1  and then used this information to choose where to dig. 

the actual code that evolved contained a great deal of code that was never executed  and the actual executed code is quite simple to understand; such a simplified version is shown in fig. 1. the individual stores the correct gold position in cell 1  calculates the displacement from the starting position to the gold's location  jumps to that square  and digs.thus  the individual evolved to be a planner that produces optimal plans for a single gold. although the output behavior is simple  evolving such a behavior in the space of all possible plans is not.in addition  this individual was only trained on 1 worlds  with a gold at a different space in each world. this evolved individual generalized correctly to all 1 possible 1 worlds with 1 gold. 
successful individuals evolved for the 1 worlds with 1  
1  and 1 golds that used memory schemes similar to those used by the solutions to the 1 worlds. andre  1c  contains more detailed analysis of these results.. one successful individual on the 1 worlds with 1 golds evolved to use a memory scheme similar to that used by the solution discussed for the 1 worlds.lt uses a 'i' to represent a gold  and a '1' to represent a non-gold.after digging each gold  the corresponding memory cell is reset to a '1'  so no multiple digs occur. the individual is provably a correct solution for all 1 worlds  with any gold distribution  even though it had been trained on only 1 worlds with 1 golds in each. 
　overall  the experiments indicate that the mapmaker method can successfully evolve individuals to solve the gold collection problem. many of the solutions were completely general - they extended perfectly to any number and arrangements of gold in their world  even though they were trained on a small subset of the possible worlds. in the case of the 1 world with 1 gold per world  an individual evolved that produced optimal plans of action for obtaining the gold. many different representation systems emerged; these are shown in table 1. all of these representation schemes are evolved models of the world; importantly  these models differ from the models evolved in the previous work with the mapmaker architecture  andre 1a  in that the exact mapping between memory and the world is evolved  rather than forced by the function set. many of the solutions involve a direct mapping  but several utilize offsets  translations  or exchanges of cells that are more complex. in addition  preliminary research indicates that general solutions will evolve even if the direct mapping is prohibited by limited memory damage  andre 1 . 
　thus  mapmaker can evolve programs to control a simple agent that uses indexed memory to store information and then uses this information to create simple plans. 
1 comparison to random search 
　many researchers  when first encountering genetic algorithms  often wonder if the results are due to a modified version of random search. although koza  1  has shown that genetic programming performs much better than random search for many problems  it is important to rule out random search as a possibility for mapmaker's success. 
　to test this possibility  twenty million random individuals that followed the mapmaker architecture were created and evaluated on the 1 worlds with 1 golds per world. this version of the gold collection problem was chosen because it required the least computational effort to solve for mapmaker using genetic programming  and was thus felt to be the easiest of the problems  see andre 1c for more explanation . the best of these twenty million randomly generated individuals only collected 1 golds out of 1  and incurred 1 penalties for digging on squares with no golds. the individual did store some information about the world; an 1 was stored in some but not all squares with gold. . although the map-user looked at several memory locations per world  the map-user used a different 'language' than the map-maker as to when it expected a gold  and thus   failed to correctly plan its actions even for the golds that were stored in its memory. 
　in comparison to the twenty million individuals that were evaluated for random search  which found only a 1% correct solution  mapmaker required processing fewer than six hundred thousand individuals to find a 1% correct solution on the 1 worlds with 1 golds per world. random search thus seems unable to discover  in any reasonable amount of time  the cooperation between the map-maker and the map-user  the development of a shared representational system  and the programs to control both modules that are all required to solve the gold collection problem. 


1 	genetic algorithms 

1 	conclusions 
　this paper has presented mapmaker  a method for the automatic generation of programs that observe their environment  store information  and then later use this information to formulate simple plans of action. the experiments with the gold collection problem indicated that mapmaker with genetic programming could generate solutions that were generalizable  robust  and in some cases optimal solutions to the problem. future work will examine more complex representational schemes  more difficult problems  the possibility of memory structure that itself evolves  and cooperation among multiple agents. 
　the gold collection problem is  of course  a toy problem  and the solutions generated by mapmaker are not exemplary in and of themselves. however  what is noteworthy is that the solutions were created automatically through the artificial evolution of programs following the mapmaker architecture. the mapmaker architecture was successful at generating agents that discover information about their environment  encode this information for later use  and create simple plans using the stored mental models. 
acknowledgments 
　i would like to thank john koza and nils nilsson for their help  advice  and many comments regarding this work. 
