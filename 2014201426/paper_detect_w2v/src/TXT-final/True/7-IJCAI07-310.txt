
the pddl1 specifications include soft goals and trajectory constraints for distinguishing highquality plans among the many feasible plans in a solution space. to reduce the complexity of solving a large pddl1 planning problem  constraint partitioning can be used to decompose its constraints into subproblems of much lower complexity. however  constraint locality due to soft goals and trajectory constraints cannot be effectively exploited by existing subgoal-partitioning techniques developed for solving pddl1 problems. in this paper  we present an improved partition-andresolve strategy for supporting the new features in pddl1. we evaluate techniques for resolving violated global constraints  optimizing goal preferences  and achieving subgoals in a multi-valued representation. empirical results on the 1th international planning competition  ipc1  benchmarks show that our approach is effective and significantly outperforms other competing planners.
1 introduction
as plan quality is a major issue in many planning problems  traditional quality criteria in pddl1 planning  like makespan  are inadequate. inspired by real applications  soft goals and trajectory constraints have been introduced in the pddl1 specifications  gerevini and long  1 .
　soft goals can be used for modeling goal preferences. for instance  one may prefer storing crate1 in depot1 to storing crate1 in depot1  since the latter leads to a higher violation cost in the plan metric value. planning with soft goals entails the selection of an appropriate subset of the soft goals when it is infeasible to achieve all of them. in the worst case  an exhaustive search is needed to identify the best subset.
　trajectory constraints  on the other hand  are hard or soft constraints over intermediate states during plan execution. they are used to express temporal logic in planning and to identify a good path among the many feasible paths to a goal state. informally  for a plan trajectory   where si is the inter-
mediate state at time ti  a trajectory constraint can be defined by a logical formula  respectively  at the end of  to be always true in  some time in  some time before t of  or at most once in the trajectory. a trajectory constraint can also defined to enforce one formula before another  or to enforce two formulas within time t in the trajectory. clearly  trajectory constraints pose more challenges on planning  even when the number of actions or facts is not increased.
　in view of the new features in pddl1 problems  we study in this paper a partition-and-resolvestrategy for solving these problems efficiently. for a planning problem  we represent the actions scheduled as variables and identify constraints on mutual exclusion  mutex   goal state  and trajectory for actions in a given  possibly infeasible  plan. we then partition the constraints into subproblems  solve the subproblems individually by an existing but modified planner  and resolve those violated global constraints across the subproblems.
　constraint partitioning has been demonstrated to be a very effective technique for solving large planning problems  chen et al.  1 . because each subproblem only has a fraction of the original constraints and is a significant relaxation of the original problem  it is of much lower complexity as compared to that of the original problem. the technique  however  leads to global constraints across the subproblems  which can be effectively resolved using the extended saddlepoint condition  wah and chen  1 .
our constraint partitioning approach has four components:
i  problem representation  ii  attributes used for partitioning  iii  partitioning algorithm  and iv  subproblem formulation. the design of each component depends on the problem representation and the planner used for solving the subproblems. note that the variables and the constraints of a planning problem studied are not determined beforehandbecause the length of its solution plan is not known. hence  we cannot directly partition its constraints by a clustering algorithm. instead  we identify some problem-dependent attributes that can be used to characterize constraint localities in an initial  but possibly infeasible  plan. we then use these attributes to partition the constraints of the initial plan into subproblems with good localities before solving the subproblems.
　for ipc1 benchmarks represented in pddl1  edelkamp and hoffmann  1   our original partition-and-resolve strategy in sgplan1  chen et al.  1  partitions the con-

figure 1: the constraint-variable structure depicting a strong constraint locality when the constraints of the ipc1 roverspropositional-1 instance is clustered by its subgoals.
straints of these benchmarks by their subgoals. the goals of many of these benchmarks are a conjunctive list of facts  with a strong locality of the mutex constraints by the subgoals of each problem. here  constraint locality is measured by the fraction of constraints that are global  which span across multiple subproblemsafter the problemhas been partitioned. figure 1 shows a strong locality after clustering the constraints of the ipc1 rovers-propositional-1 instance  gerevini et al.  1  by its subgoals. the approach works well because the goal is indeed a conjunctive list of facts.
　subgoal partitioning  however  is not always effective for pddl1 domains. the presence of soft goals and trajectory constraints may lead to constraint localities that are different from those observed in pddl1 domains. figure 1a depicts the constraint-variable distribution after clustering the constraints of the tpp-qualitativepreferences-1 instance by its soft goals. because trajectory constraints are not considered in clustering  the result leads to a poor constraint locality.
　in clustering constraints of ipc1 instances  we observe that the propositional representation of binary facts in sgplan1 usually requires superfluous facts and obscures many mutexes. for example  the location of truck1 in the tpp domain is represented by several binary facts  like at truck1  market1   ...  at truck1  market1   with some implicit constraints for enforcing their consistency. to represent these constraints more compactly  we use a multi-valued domain formulation  mdf  in this paper based on the sas+ formalism  ba：ckstr：om and nebel  1 . mdf has been used in several planners for the previous versions of pddl  including fast downward  helmert  1  and the ip planner  van den briel et al.  1 . this representation makes implicit mutexes explicit and reduces the number of global constraints across the subproblems. for instance  the location of truck1 can now be denoted by one variable with multiple values.
　our main contributionsin this paper are the design of a new strategy for clustering and for partitioning the constraints of pddl1 planning problems and the demonstration of its success in a prototype planner. based on the constraint locality observed  we partition mutexes and hard and soft trajectory constraints of a planning problem into loosely related subproblems by some multi-valued state variables. we study various design options in partitioning and demonstrate their improvements in constraint locality. to handle the features in pddl1  we develop new techniques  both at the global and the subproblem levels  for optimizing goal preferences and for resolving trajectory and mutex constraints.
1 partitioning strategy
in this section  we first illustrate the constraint locality of a pddl1 problem when it is partitioned by its trajectory constraints and soft goals. we then present our partitioning algorithm and the results on some ipc1 benchmarks.
1 constraint locality by trajectory constraints and soft goals
as is shown in figure 1a  clustering the constraints of a pddl1 problem by its subgoals does not lead to high constraint locality. our goal in this section is  therefore  to identify new problem-independent attributes that allow pddl1 problems to be partitioned with better constraint locality.
　recall that a solution plan for a pddl1 problem is represented in multi-valued variables and satisfies mutex  trajectory  and goal-state constraints. we have found that constraint locality can be improved when some state variables in goalstate constraints  called guidancevariables  are used for clustering the constraints into subproblems. since the goal-state representation is also a conjunction of facts  our partitionand-resolve approach in sgplan1 can be applied directly.
　figure 1b illustrates the constraint-variable distribution when we cluster the mutex constraints  in red points  in tppqualitativepreferences-1 by the five guidance variables that represent the stored quantity of the five products. although constraint locality is greatly improved over that in figure 1a  the result is still unsatisfactory because there are a number of soft constraints  in blue points  that are not localized.
　to address this issue  we further cluster the soft constraints by the same guidance variables. figures 1c shows that all the constraints are now clustered well  leading to a good constraint locality. note that we may have constraints that involve a limited number of guidance variables yet exhibit strong constraint locality. in the next section  we study the granularity of partitioning in order to further reduce the number of global constraints.
　in addition to good locality  one advantage of using guidance variables is that they can be converted into classical planning goals. this greatly reduces the efforts of implementing a planner for solving a subproblem because current planners can only solve subproblems with nonempty and conflictfree goals. this also explains why we cannot arbitrarily construct subproblems with inconsistent goals or constraints using direct graph partitioning.
1 proposed partitioning algorithm
based on our observation that constraint locality is associated with some guidance variables  we present in this section our algorithm for identifying the guidance variables  selecting a suitable number of partitions  and clustering the constraints by these variables. as the algorithm requires all the constraints to be expressed in mdf  we have implemented a preprocessing engine by following the techniques in  helmert  1  for translating a pddl representation into mdf. the use of mdf does not introduce new types of constraints because any mutex in mdf must also be a mutex in pddl.

         a  na： ve clustering by soft goals b  clustering mutexes by guidance variables c  clustering mutex and trajectory constraints figure 1: the constraint-variable distributions  after some rearrangement  of the tpp-qualitativepreferences-1 instance that show the different degrees of constraint locality using three ways of clustering the constraints.　we first define the guidance variables to be the set of variables in the goal-state constraints. once the values of these variables have been determined by satisfying all the hard goal constraints and by minimizing to some extent the penalties of the soft goal constraints  we define the goal of a subproblem to be a partial assignment of the set of guidance variables. we also specify the maximum number of partitions to be the number of guidance variables.
　the number of partitions is an important parameter of our partitioning algorithm. although it is desirable to enumerate different numbers of partitions and to study their tradeoffs  it is not the best approach here because there are some problem-dependent features that can be utilized. we employ a logical choice through the identification of bottleneck variables. in various planning domains  some limited objects are the sources of mutexes because actions want to concurrently access them. they can be treated as bottleneck resources that limit parallelism. specifically  we search for a group of state variables of the same type  called bottleneck variables  that the changes of other state variables must depend on. for example  the locations of vehicles in the transportation domains are bottleneck variables because every action asserts the location of one vehicle. our strategy is to set the number of partitions to be the smaller of the number of guidance variables and the number of bottleneck variables.
　in addition to mdf analysis  we also identify and remove accompanying state variables in order to eliminate possibly redundant guidance and bottleneck variables. these are state variables whose values can be inferred from the values of other state variables. for example  on crate1  depot1-1  implies in crate1  depot1   given that in depot1-1 depot1  is true  where depot1-1 is a storage area in depot1 . this identification is possible because action add on crate1  depot1-1  must also add in crate1  depot1   whereas delete in crate1  depot1  must also delete on crate1  depot1-1 . for each candidate state variable  we test if all its values have the above relationship with the values of other state variables.
　table 1 shows the trade-offs in granularity on the ipc1 trucks-timeconstraints-1 instance. when the instance is partitioned with respect to the bottleneck variables  the result confirmsour claim in section 1 that the time forsolving a subproblem decreases by three orders of magnitude  whereas the number of partitions  and the number of global constraints  is increased by a small number. however  as the number of partitions is increased further  when partitioning is done with respect to the guidance variables   there is diminishing reduction in the time to solve a subproblem  whereas the number of global constraints is increased dramatically. in this case  partable 1: trade-offson the numberof partitions forthe truckstimeconstraints-1 instance.
partitioning strategyno partitioningbottleneckguidance# partitions11# global constraints11avg. # local const. per subproblem11time/subproblem 1 sec.1 sec.1 sec.bottleneck: # partitions = min # bottleneck var.  # guidance var. 
guidance: # partitions = # of guidance variables subgoal: subgoal partitioning
titioning is best done with respect to the bottleneck variables.
　finally  we cluster the guidance variables by formulating a graph partitioning problem. we define a node in the graph to be a guidance variable  and an edge between two nodes when there is a constraint on these variables. we do not include those constraints that are automatically satisfied by the values of the guidance variables. for example   imply  stored goods1 level1   stored goods1 level1   is true if we have determined the value of stored goods1  to be level1  and the value of stored goods1  to be level1. for preferences on soft constraints  we set the weight on an edge to be the violation cost of the corresponding soft constraint. last  we apply any competent graph partitioning software  such as metis  http://glaros.dtc.umn.edu/gkhome/ views/metis/   to cluster the constraints into groups that are related by a minimal number of global constraints.
1 results on some ipc1 benchmarks
in this section  we report the evaluation results of our proposed partitioning strategies on some ipc1 benchmarks. we have chosen the qualitativepreferences track whose instances have both soft goals and trajectory constraints. table 1 shows the average fraction of all constraints that are active global constraints initially for three partitioning strategies. some entries in the table are zeroes because no partitioning was done for those domain-strategy combinations.
　the result shows that partitioning based on guidance variables leads to better constraint locality than that of subgoal partitioning. further  our strategy for controlling granularity can avoid exorbitant resolution overheadswhen the locality is weak and when a subproblem is too complicated to be solved without partitioning. we address this issue in section 1 using subproblem-level decomposition techniques. note that all three partitioning strategies work well for the storage dotable 1: fraction of constraints that are active global constraints initially averaged over all the instances of each ipc1 qualitativepreferences domain under three partitioning strategies.  see the keys in table 1. 
domainbottleneckguidancesubgoaltpp111openstacks111trucks111storage111rovers111
figure 1: architecture of sgplan1.
main because its constraint locality is very strong. however  since the instances in this domain have a huge number of constraints  even a small fraction of violated global constraints would need to be resolved in many iterations.
1 architecture of sgplan1
sgplan1 partitions a planning problem into subproblems  each with a goal state  and finds a feasible plan for each  figure 1 . in the global level  it partitions the problem by its guidance/bottlenecek variables and resolves any violated global constraints. in the local level  it calls a modified metric-ff planner for solving each subproblem  using the violated global constraints and the global preferences as biases.
1 global-level search
sgplan1 solves a planning problem formulated in one objective and one or more constraints. using a penalty function of the objective and the transformed constraint functions weighted by their penalties  it looks for extended saddle points  esps  of the function  wah and chen  1 . in each iteration  the planner solves a subproblem by generating a feasible plan that satisfies the local constraints as well as to minimize the weighted violations of the global constraints.
　the planner first decides on the values of the partitioning guidance state vector x before partitioning the constraints. the metric value for each assignment is estimated by solving the following relaxed problem:

subject to		 1  and	
where defines the plan trajectory  h π  is the set of hard constraints  and r x  is the value of the reachability test. the metric function consists of jx whose value can be wholly inferred from x  and jπ whose value is calculated by evaluating the plan trajectory. without additional restriction on π  we prune those cases in which the violation of h can be deduced from x.
　we find the best x by a heuristic search with backtracking. since jπ π  is unknown until planning ends  we use   the plan metric value of the relaxed plan for x  to estimate . this relaxed plan is provided by the basic planner  modified metric-ff  and is used for reachability tests as well. if jπ π  is zero  then the above search reduces to an enumeration of all reachable assignments of x. in that case  the solution is optimal when the best x for  1  is found. in general  our strategy does not guaranteeoptimality because the basic planner does not ensure the optimality of jπ π .
　sometimes the search can be decomposed by the goal-state constraints  and the corresponding variables can be partitioned into disjoint sets. however  since the number of reachable assignments is exponential with respect to x  we generally limit the number of assignments explored when the space enumerated is still too large after the decomposition.
　the handling and enumeration of general trajectory constraints is difficult because it involves a number of intermediate states rather than one final state. further  due to the large feasible space  inconsistencies between constraints are difficult to detect. our approach is to divide the trajectory constraints into local and global constraints. hard local constraints are enforced by the basic planner whereas globalconstraints are resolved by the penalty method. we follow a similar procedure for resolving mutexes when handling globallevel trajectory constraints. since soft constraints do not have to be always satisfied  we compute the plan metric at the end of each iteration and record the incumbent. note that the penalties used for resolving constraint violations differ from the preference weights used for computing the metric value.
1 subproblem-level search
our basic planner mainly follows metric-ff's heuristic algorithm  hoffmann  1   but employs a new heuristic function to better handle the new features in pddl1. using mdf  we have implemented a new heuristic that is similar to that in fast downward  helmert  1 . our minimum causal dependency-cost  mcdc  heuristic employs a complete recursive depth-first search for generating a heuristic plan with the minimum cost and without pruning the causal graphs. in contrast  the fast downward heuristic is incomplete since it prunes arcs from the causal graphs. although mcdc provides a more accurate heuristic plan  its efficiency cannot compete with metric-ff's  ignore-delete-lists  heuristic function. we only use mcdc as a better dead-end detector r x  and metric-value estimator j  x π .
　we have implemented the parser and the preprocessor for supporting pddl1 domains. to synchronize the checks of constraints and the evaluation of violation costs  we encode each constraint  resp. preference value  by an artificial predicate  resp. function . all constraints are grounded  and quantifiers are compiled away. during state transitions  the values of these artificial fluents are derived from the existing trajectory using axioms. having the above encoding and modification allows us to perform a breadth-first search  bfs  in satisfying the constraints or in optimizing the preferences.
　to improve the efficiency of bfs  we incorporate new heuristics for constraint satisfaction into metric-ff's heuristic function. our solution is to add artificial facts of local constraints into the goal state of a subproblem  and compute the combined heuristic value as the sum of the heuristic value for the constraints and that for the subgoal. since it is not meaningful to sum the heuristic values for hard and soft constraints  we penalize soft- or global-constraint violations by iteratively increasing their weights.
　before solving a partitioned subproblem  we can often eliminate many irrelevant actions in its search space. we identify relevant actions by traversing the causal graphs in mdf and by ignoring those actions that are not useful for achieving the current subgoal variables. we also prioritize actions that do not cause an inconsistent assignment of mdf variables. this is done by first finding the set of bottleneck variables and by applying the helpful-action idea in ff  hoffmann and nebel  1  to defer those actions that concurrently change the value of the bottleneck variables.
　with the subproblems generated  it is possible that a subproblem is too complicated to be solved  especially when the proposed partitioning strategy chooses a small number of partitions. reducing the grain size further would not be effective due to the complexity of resolving the global constraints. for instance  all the subproblems in the ipc1 openstacks domain are trivial to solve  but the challenge is to resolve the global constraints. in case that the basic planner fails to find a feasible subplan  we use incremental planning  hsu et al.  1  or landmark analysis  hoffmann et al.  1  to further decompose a subproblem into more manageable units.
1 experimental results
we first evaluate the performance of our proposed partitioning strategy  which selects the number of partitions to be the minimum of the number of bottleneck variables and the number of guidance variables. we test our proposed strategy on a number of large ipc1 instances. we do not select instances from domains with preferences  since most of them can be readily solved by relaxing all their soft constraints.
　table 1 shows the slowdowns of solving each instance using some fixed number of partitions with respect to our proposed partitioning strategy. it shows that our proposed strategy is usually the best  except in solving the openstacks-metrictime domain. although openstackstable 1: slowdowns of solving some large ipc1 instances by some fixed number of partitions with respect to our proposed partitioning strategy.
ipc1 instanceproposed strategy# of partitions g b min g b 11gtpp-pr-1 1 1  111tpp-mt-1 1 1 1111tpp-mtc-1 1 1 1   openstacks-pr-1 1 1.1.1.1.1.1openstacks-mt-1 1 n/a 1.1.1.1.1.1storage-pr-1 1 1  111storage-ti-1 1 1  111storage-tc-1 1 1.1.1.1.1.1trucks-pr-1 1 1.1.1.1  trucks-ti-1 1 1.1.1.1.1.1trucks-tc-1 1 1 111 pathways-pr-1 1 n/a 1.1.1.1.1.1pathways-mt-1 1 n/a 1.1.1.1.1.1rovers-pr-1 1 1	 	1	1	1	1rovers-mt-1 1 1	 	 	 	1	 pipesworld-pr-1 1 1	 	1	1	1	1pipesworld-mt-1 1 1	 	1	1	1	1b:	# of bottleneck variables;	g:	# of guidance variables ' ':	cpu time exceeding 1 minutes;	n/a:	no bottleneck variables
table 1: number of instances solved by sgplan1 with respect to the total number of instances  in parenthesis  in each variant.    means no instances in that domain. mettime for tpp and openstacks includes both metric and metrictime. 
domainprop.mettimesimp.	qual.	comp. const.tpp1 1 1  1  1  1 openstacks1 1 1  1   	 trucks1 1 1  1  1  1 storage1 1 1  1  1 	1 pathways1 1 1    1   rovers1 1 1  1   	 pipesworld1 1  	  1 	1 metrictime has a similar problem structure as that of openstacks-propositional  our strategy fails to detect its weak locality because it does not find any bottleneck variables. moreover  the benefit of partitioning in this domain is not tangible because its instances are rather easy.
　table 1 summarizes the statistics of the ipc1 instances solved by sgplan1 and shows that it can solve about 1% of all the instances. most of the unsolved instances are in the metrictimeconstraint track and the pipesworld domain.
　for the metrictimeconstraint track  the weak performance of sgplan1 is due to the ineffective heuristics for handling trajectory constraints when one logical formula is before another  either quantitatively or qualitatively.
　for the pipesworld domain in which sgplan1 does not perform well  we have observed two interesting features. in this domain  the set of guidance variables overlaps with that of the bottleneck variables  and  unlike other domains  the bottleneck  resp.  guidance  variables have strong causal dependencies with each other. the identified locality is also weaker because the density of the shared resources is higher.
	plan metric	openstacks-metrictime  1 inst. 
 1 1 1 1 1 1
	rovers-qualpref  1 instances 	plan metric	pathways-complexpref  1 inst. 	plan metric	trucks-timeconstraints  1 inst. 
	sgplan1  1  solved 	
 1 1 1 1 1 1 1 1
figure 1: performance comparison on selected domains of sgplan1 and other competing planners in the 1th international planning competitions  reproduced from the results posted in  gerevini et al.  1  .  the x axis shows the instance number. 　finally  figure 1 compares the performance of sgplan1 on six domainvariants with that of other competing plannersthat participated in ipc1. all the experiments were conducted on a 1-ghz intel xeon linux computer under a time limit of 1 minutes and a memory limit of 1 gbytes. the results show that sgplan1 is much faster and can solve many more instances  when compared to other competing planners that do not use constraint partitioning. with respect to the plan metric value  sgplan1 is clearly the best planner. for pddl1 domains  with the aid of new domain analysis techniques and a good partitioning strategy  sgplan1 can either solve more instances  storage-propositional or achieve better plan quality  openstacks-metrictime .
　the complete results at the ipc1 web site  gerevini et al.  1  show that sgplan1 ranks first  resp.  second  in 1  resp.  1  of the domain variants. the other competing planners that rank first/second in at least one of the domain variants include downward  1   mips-bdd  1   mips-xxl  1   hplan-b  1   and yochanps  1 .
　in the future  we like to enhance the efficiency of evaluating trajectory constraints. we will improve the heuristics in sgplan1 for handling complex trajectory constraints. we will also consider using the techniques in  edelkamp  1  that translates trajectory constraints into some automata in order to more efficiently check the satisfaction of constraints.
references
 ba：ckstr：om and nebel  1  c. ba：ckstr：om and b. nebel. complexity results for sas+ planning. computational intelligence  1-1  1.
 chen et al.  1  y. x. chen  b. w. wah  and c. w. hsu. temporal planning using subgoal partitioning and resolution in sgplan. j. of artificial intelligence research  1-1  august 1.
 edelkamp and hoffmann  1  s. edelkamp and j. hoffmann. classical part  1th international planning competition. http://ls1-www.cs.uni-dortmund.de/  edelkamp/ipc-1/  1.
 edelkamp  1  s. edelkamp. on the compilation of plan constraints and preferences. in icaps  pages 1  1.
 gerevini and long  1  a. gerevini and d. long. plan constraints and p