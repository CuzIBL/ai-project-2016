: it has been claimed that production systems have several advantages over other representational schemes. these include the potential for general self-augmentation 
 i.e.  learning of new behavior  and the ability to function in complex environments. the production system language  ops  was implemented to test these claims. in this paper we explore some of the issues that bear on the design of production system languages and try to show the adequacy of ops for its intended purpose. 
i. introduction 
         much of the work that has been done with production systems during the past few years has had as its primary goal the development of systems that are expert in some particular task. the tasks so far addressed include: chemical inference  buchanan and lederberg  j 1   medical diagnosis  davis  buchanan  and shortliffe  1   discovery in mathematics  lenat  1   speech recognition  erman and lesser  1; mccracken  1   and automatic programming  barstow  1 . although many of these systems have shown impressive power in the particular task for which they were designed  there remains a question of how suitable the production system representation is for large general problem solving programs. 
the instructable production system  ips  project at 
cmu  rychener and newell  1  is attempting to answer this question. it has been claimed that production systems are capable of learning in a non-trivial way. if this is true  a production system should be able to learn not only facts  but also new behaviors. it should be able to generalize easily; something learned in one context should be readily accessible in other  only remotely similar  contexts. the learning mechanisms should not be complex; in particular  they should not need to know much of the structure of the rest of the system. it has also been claimed that production systems are capable of functioning in complex environments. if this is true  a production system should be interruptable. it should be able to recognize and react immediately to important changes in its environment  and afterward  to return to its previous task with no loss. while these claims are not without support  some of the expert systems mentioned above are capable of learning  for example   they certainly have not yet been established. the ips project is attempting to build a production system that displays both characteristics as fully as possible. 
1 this 	work 	was 	supported 	in 	part 	by 	the 	defense 
	advanced 	research 	projects 	agency 
 f1-c-1  and monitored by the air force office of scientific research. 
         the first phase of this project involved designing a production system language whose features support generality. to our knowledge  no one has enumerated or systematically attempted to justify a set of characteristics that are appropriate for such a language  though newell  and davis and king  have suggested sets of dimensions that can be used to distinguish production system languages from one another  and lenat and harris  have argued that a language designed to support tasks within a particular domain should have characteristics that exploit the features of that domain. this paper first discusses some of the more significant alternatives open to the designer of a production system language  and then describes ops1 and argues that it is a suitable language for the purposes of the ips project. 
ii. the alternatives 
         the members of the class of production system languages share only a few common characteristics. all make use of conditional statements called productions  and their interpreters all have similar high level functions. the interpreters have access to two memories  production memory and data memory. production memory is a place to store the productions and any static relations  e.g.  a linear ordering  between productions. data memory is a 
         place to store the data processed by the productions and any static relations between the data. most production system languages require the maintenance of some information in addition to that in these two memories  e.g.  the name of the last production to fire . in this paper it will be assumed that all this information is stored in a third structure that we will call state memory. the interpreter functions by repeatedly matching the productions against a subset of the information held in the data and state memories  selecting one or more of the productions with true antecedent conditions  and then allowing the selected productions to execute and effect changes to data memory. if changes to state memory are necessary  the interpreter itself makes these. this sequence of operations constitutes what is called the recognize-act cycle. 
         beyond this set of common characteristics  production system languages have diverged from one another in many ways. in some  for example  production 
1 a. newell and m. rychener  together with the authors  designed ops. ops contains many of the features found in psg  newell and mcdermott  1   psnlst 
 rychener  	1   and rete  a system designed by forgy. 

languages & systems-1: forgy 
1 

memory can be partitioned to give an effect something like subroutines in conventional languages  e.g.  newell and mcdermott  1 . data memory can be partitioned in some others and different access mechanisms provided for each partition  lenat and harris  1 . some languages allow every satisfied production  that is  e /ery production whose antecedent condition is true  to fire on each cycle  mccracken  1   others use a few simple decision procedures to choose one or a few productions to fire  anderson  1; newell and mcdermott  1   and others use complex decision procedures to choose with some care which productions to fire  erman and lesser  1 . an automatic backtracking search mechanism is included in some interpreters  these are the  deductive  production systems like rita  anderson and gillogly  1  and mycin  davis  buchanan  and shortliffe  1    while the others make it necessary to program all searches explicitly. differences such as these can be viewed as creating a space of possible production system languages. 
　　　　the remainder of this section presents arguments for one region in this space. because the goals of the ips project differ from the goals of most projects that use production systems  the arguments differ from those that might be made for other production system languages. we will consider each of the four components of a production system language  the interpreter and the three memories . 
the interpreter 
　　　　perhaps the most fundamental consideration in the design of a production system language is the amount of processing that will occur during a recognize-act cycle. existing production systems vary widely in this. 
productions in the hsii system  erman and lesser  1   for example  accomplish far more in one firing than do the productions in mycin  davis  buchanan  and shortliffe  1 . the production system language should not force a discipline on the user  i.e.  it should not force him to perform a fixed amount of processing on each cycle   but it should provide features that make it easy for the user to adopt whatever discipline he finds appropriate. 
　　　　the amount of processing that will be appropriate on any one cycle is dependent on the current task of the system. if some production is very knowledgeable about a particular situation  it is appropriate that the production take powerful actions. in chess  for example  if a 
　　　　production recognized a book position in the opening  the production should be able to make the move and avoid the interference of other productions that are less able in this situation. if there is no production that understands the situation  however  the system should be more cautious in its processing. if it takes a big step and that step is wrong  it will progress far down the incorrect path before it has a chance to recognize its mistake. moreover  a big step will make the system less able to use whatever store of information it has about similar tasks because it will be skipping over so many of the points where that information could be appropriate. it will be less likely to notice events such as the sudden feasibility of a new approach to the current task  the arrival of a more important task  or the unexpected satisfaction of a pending task. it can be expected that a large task will be diverse; it will have some sub tasks that are well understood by the production system and others that are difficult or poorly understood. the appropriate amount of processing  then  can vary greatly from minute to minute even in the performance of a single task. 
　　　　thus the production system language should neither make it impossible to perform complex actions nor make it economically infeasible to perform simple actions. unfortunately  these requirements tend to conflict. if the monitor supports complex actions and powerful patterns  there is likely to be significant overhead to the recognize-act cycle. to perform only a few simple actions when the overhead is high may not always be economically feasible. the production system language must therefore incorporate some compromise between unlimited power and potential for short cycle times. 
　　　　the recognize part of the cycle is potentially more of a problem  but current technology provides a reasonable solution. the problem with using powerful recognition criteria is that even though the productions that contain the more powerful patterns may fire only infrequently  the patterns must be tested on every cycle. powerful actions  in contrast  have a cost only when they are executed. a solution to this problem is provided in the methods now available that allow quite powerful patterns while making the time to perform recognition almost independent of the number of productions in the system  forgy  1; mcdermott  newell  and moore  1 . these methods do have one major limitation: they do not allow the use of variables in data memory.1 
　　　　in summary  the production system language should allow antecedent conditions that are as powerful as possible given the constraint that the time required to perform recognition must be independent of the sizes of data and production memories. the power that should be allowed in the actions is less easy to characterize. while there is not the same efficiency issue here as there is in the case of antecedent conditions  actions have a cost only when they are executed   actions whose power is incommensurate with the power of the match would appear to be unusable. if there are limits to the power of antecedent conditions  it will not be possible to describe the character of a situation fully enough to insure that an ultra-powerful  and hence ultra-specific action  is applied only at appropriate times. 
　　　　another choice facing the designer of a production system language is whether to include the backtracking * search feature of the deductive production systems. certainly search is important in the types of programs most often written in production systems  and for many environments an exhaustive depth first search is appropriate. it seems not to be appropriate for systems that must search through large spaces or that must learn to modify old behavior. if the system is to modify old behavior  including old search methods  the old methods must be accessible to the system  not hidden inside the interpreter. 
languages & systems-1: forgy 
1 1 perhaps the methods could be extended to allow variables in data memory  but since the necessary studies have not yet been made  we are unsure. 
data memory 
         complex environments are best handled by systems that use a single uniform data memory of limited size. any system that is able to function intelligently in many different situations will have available a great quantity of knowledge  much of which will be useful in more than one situation. if the system is not to be impossibly slow in its response to changing situations  it must have means whereby the information relevant to a new situation can be located immediately. the interpreter provides one such means in the mappings performed during the recognition phase of the cycle. all long term information can be stored in productions whose antecedent conditions express the character of the situations in which the information is potentially relevant. when a new situation arises or an old situation is transformed  the relevant information is found and possibly  that is  if the interpreter so chooses  brought into data memory. since this approach to storing long term information makes data memory essentially an attention focusing device  there is little advantage to having more information in data memory than can be usefully attended to all at once  
         partitioned data memories are often useful  but the same purposes can be served by the more general mechanism of tagging data. consider  for example  how a partitioned memory might be used in a deductive production system. in these systems  before execution of each production a new partition can be created  and any assertions made by the production affect only the new partition. if the interpreter later needs to back up and undo the effects of the production  it can do so simply by deleting the appropriate partition and its contents. a production system that performs its own searches can achieve similar results with an unpartitioned data memory by tagging the data to indicate that it is contingent  to indicate what it is contingent upon  to indicate why it is contingent  e.g.  that it is a goal or that it is hypothesized but not yet accepted   or any other purpose that might arise. in contrast  since they are supplied with a fixed set of mechanisms for the manipulation of the partitions and their contents  partitions on data memory are often difficult to use for purposes other than those that appeared useful at the time the language was designed. 
production memory 
         production memory should  like data memory  be a single uniform structure; unlike data memory  it should have no size limit. the system would be unable to learn if both data and production memories were limited. it should be a single uniform structure to insure that all potentially relevant knowledge is accessible to the system at all times. since a system functioning in a complex environment can never know what the state of the world will be from cycle to cycle  it makes no sense to exclude some set of productions from consideration during a particular cycle. to exclude productions is to limit the amount of knowledge that the system can bring to bear. 
state memory 
         if production memory is large and if the environment is complex  considerable intelligence will be required to select the most appropriate productions to fire on each cycle. while most of the information on which the selection should be made is found in data memory  the information that is available in state memory  e.g.  the set of all currently satisfied productions and information about the past actions of the production system  should not be ignored. because this information is hidden from the production system in most existing production system languages  the interpreter has to make the final decision of which productions to fire. but certainly the interpreter is less well-suited for such decision making than the production system itself; production systems are  after all  better suited than conventional programs for making quick decisions based on large amounts of data and involving many complex criteria. thus productions should be allowed to read state memory as well as data memory so that they can have as large a role as possible in the selection process1. 
iii. a description of ops 
         in the previous section we indicated a set of characteristics that seem appropriate for a production system language that is to be used for building production systems capable of generality. in this section a particular language  ops  is described. with one exception  ops has these characteristics; the exception is that ops does not give the production system access to state memory. in the description that follows  we attempt to justify our lower level design choices. 
the data 
         the data processed by ops are autonomous  constant list structures. the elements are constant because  as explained above  we do not yet know an economical way to handle variables in data memory. the data elements are autonomous structures for reasons of simplicity. because variables are allowed in productions  it is possible to implicitly link two assertions simply by including the same unique constant in both. thus  to allow explicit links between elements would add no expressive power to the language. 
         the ops data memory is a set of limited size. the set nature of memory is maintained by automatically deleting elements when identical new elements are asserted. the limited size is maintained by automatically deleting elements when they have been in data memory for some fixed amount of time. because data are deleted after only a short stay  data memory is a temporary workspace that focusses the system's attention on knowledge that is currently relevant. there is no great significance to the 
1 mycin  with its meta-rules  is one of the few systems to allow this  see davis  1 . 
1 a full description of ops is given in forgy and mcdermott . 
languages & systems-1: forgy 1 the amount of time  measured in actions executed  is specified by the user; the default is 1 actions. 
decision that data memory should be a set; there are styles of programming that can be adopted when data memory allows multiple occurrences of elements and other equally good styles that can be adopted when it does not. 
the match 
         the search performed by the ops interpreter is complete; every legal instantiation of every production is found. this makes ops quite different from its predecessor  psg  newell and mcdermott  1 . because it does not perform exhaustive searches  the psg interpreter may fail to find an instantiation of a production even though one exists. psg's match algorithm is dependent on the order in which a production's condition elements occur. it was decided that this dependence on order is unacceptable for a production system that is to grow through the acquisition of new productions; to add a suitable production is difficult enough without having to contend with the problem of specifying an order on its condition elements that would be appropriate for any situation that the system might encounter. 
         the antecedent of an ops production is composed of one or more condition elements  each of which is a form to be instantiated by one element from data memory. the expressive power of ops condition elements is greater than that of condition elements in languages like psg. it is possible to give either exact or  somewhat  inexact specifications for both the shape and content of the data to be matched. condition elements are  like data elements  list structures. generally  the shape of a condition element must correspond exactly to that of a data element for the two to match. two means are provided  however  to allow the matching of the head of a list without fully describing its tail. the symbol  ...  is used to specify that the tail of a list is to be ignored in the match. for example  the following condition element will match any data element that begins with  a b  
 a b ...  
the symbol  .  makes it possible to specify that a tail is to be matched and then to give information about the content of the tail by following the  .  by a pattern. 
         several elementary pattern types  called match functions  are allowed in ops. the most basic match function is the constant  which will match only itself. this is seen in.the example above where the condition element will match only those data elements whose first subelement is an  a  and whose second subelement is a  b  it is also possible to specify that a data subelement must be equal to one of a group of constants  be not equal to a constant  
or be not equal to any one of a group of constants. the any function provides the first of these capabilities; the 
notany function  the other two. for example  the following condition element will match any data element composed of two subelements where the first subelement is one of  a    b   and v and where the second 
subelement is not a  d  
   any a b c   notany d    
notany with no arguments is particularly useful; it will match any sublement. thus  the condition element 
　　　　　　　   notany   notany    will match any data element with two subelements. 
         because data elements can be arbitrarily complex list structures  the need was felt to be able to specify something about the contents of data elements. the contains and notconta1ns functions were included to fill this need. as their names imply  the former allows the specification that the subelement contain  at any level  at least one occurrence of one of some set of specified constants  and the latter that the subelement not contain any occurrences of any of the specified constants. the following condition element  which uses  .  as described above  will match any data element of two or more subelements provided the constant  a  occurs somewhere after the first subelement 
   notany .  contains a    
         two means are provided for specifying the relationship among condition elements. simply writing an antecedent without putting separating marks between the condition elements indicates that all condition elements must be satisfied simultaneously in order for the antecedent to be satisfied. for example  the antecedent 
 a ...   b ...  
will be satisfied if there is an element in data memory beginning with  a  and another beginning with  b . the not match function allows another kind of grouping  negated conjunction. an antecedent composed of one condition element and one negated condition element is satisfied when the non-negated condition element is satisfied and the negated condition element is not. thus  the following antecedent  
 a ...   not  b ...     
ir which   b ...   has been negated  is satisfied only if data memory contains a data element beginning with  a  and no element beginning with  b . negated conjunctions may of course involve more than just two condition elements. any group of condition elements  including groups containing other negated condition elements  may be negated and conjoined to any other group. the antecedent condition 
 a ...   not  b ...   c ...    
is satisfied when there is a data element in working memory beginning with  a  but not both a data element beginning with  b  and a data element beginning with  c . when nots are nested  evaluation proceeds from the innermost level outward. 
         variables make it possible to specify that the content of a condition element is dependent on the content of other condition elements in the same antecedent. there are four types of variables in ops. the most important type  denoted by preceding the variable name with  =   is the  simple  variable. all occurrences of such a variable must have equal bindings. thus the antecedent 
languages & systeros-1: forpy  a . -x   b . =x  
will match two elements  the first of which begins with  a   the second of which begins with  b   and both of which have identical tails. the second form of variable  denoted by preceding the variable name with  』   may not be used unless there is a simple variable with the same name elsewhere in the same antecedent. any data matching one of these not-variables must differ from the data matching the simple variable. for example  the antecedent 
=x  not 』x   
will be satisfied only if there is exactly one element in data memory. the final two forms of variables  denoted by preceding the variable names with     and      are used in comparing numbers. like the variables preceded by 'v   use of these is legal only if there is a simple variable of the same name elsewhere in the antecedent. a variable preceded by     will match numbers greater than the number matched by the simple variable; a variable preceded by      numbers less than the number matched by the simple variable. thus  the antecedent 
=x  not  x   
will bind x to the largest number in data memory. 
         it is often useful to be able to give multiple specifications for a data element. for example  one may want to specify that a data element be one of a set of constants and then bind a variable to the element so that the exact value may be determined; this can be denoted using the symbol  $ . for example  
 any a b c d e  $ =x. 
the symbol  $  indicates that the two condition elements that it separates are both to match the same data element. as other examples  the antecedent 
=x - y $  x  not  y s  x   
will bind x to a number and y to the next larger number; the antecedent 
=x =y $ 』x  not 』x 1 』y   
will succeed if there are exactly two elements in data memory. 
         finally  ops provides a quote function so that the match functions can be used as constants. for example  to use   not x   as a constant  one would write 
 quote  not x    
conflict resolution 
         on each cycle ops selects a single production instantiation to execute. the selection is a two step process in which first the set of all legal instantiations of all productions are found and then one instantiation chosen from that set. the second step  called conflict resolution. must be performed solely by the interpreter because state memory  which holds the information on which the selection 
languages & 
is made  is closed to the productions. the decision not to allow the productions to access state memory war. based on our  since reformed  belief that sufficiently general selection rules could be built into the interpreter to allow it to function adequately in all situations. conflict resolution is performed in five steps using a different rule on each step. the first rule is absolute in its effect; if there is no instantiation that meets its condition  the system halts. if a set of instantiations do meet its condition  then the remaining rules are applied  in the order given below  until all but one have been rejected. 
1. no instantiation may be executed more than once. 
1. the instantiations containing the most recently asserted data are given preference. in comparing two instantiations  the rule first compares the most recent data element of each. if these elements differ in recency  the rule selects the instantiation containing the more recent element. if both elements are of equal recency  the next most recent elements are compared  and so on. if the data contained in one instantiation is exhausted before that contained in the other  the instantiation containing more data is chosen. only if both instantiations are exhausted simultaneously and no elements of differing recency are found are the two instantiations considered equal under this rule. 
1. the instantiations of productions with the greatest number of condition elements are given preference. negated condition elements  including nested negated condition elements  are taken into account. 
1. the instantiations of the most recently created production are given preference. 
1. an instantiation is selected at random. 
         these rules  because they make use of a variety of state information that is not available to the productions  provide considerable additional discriminative power. briefly  the first rule helps insure that the system will consider information that has not yet been taken into account. the second rule  by giving preference to more recent information  encourages the system to continue to attend to whatever task it is currently engaged in; in addition  if given a choice among several productions which are relevant to the same situation  it prefers the most discriminating. the third rule simply extends the definition of  discriminating  implicit in the second rule. the fourth rule provides a way in which the system can mask older productions with newer  more adequate ones.1 
1 recall that reasserting a data element will result in the deletion of the existing element. the instantiations containing the new element will have no inhibitions even though they may be identical to instantiations that have already fired. 
1 for a more complete discussion of how these rules provide support for domain-independent systems  see mcdermott and forgy . 
systems-1: forgy 
1 
the actions 
         after a production is chosen  it is executed by individually executing each of its actions in order. the actions are simple functions that can modify the contents of data memory  modify the contents of production memory  or interact with the system's environment. 
         there are only two methods by which the contents of data memory may be modified; an action may assert a new data element or delete an existing element. this is a 
         complete  if primitive  set of actions. the means by which the elements to be asserted or deleted are constructed are equally primitive. on the action side of a production there are a number of elements similar in form to condition elements. the execution of an action involves instantiating the element  performing whatever operations are specified by the element  and then if a value results  asserting that value. 
         if variables occur in an action element  they are replaced by the values to which they were bound during the match. the ability to bind variables in the antecedent provides a quite general extractor mechanism. the ability to recover the bindings while instantiating a form provides a general constructor mechanism. the list manipulation abilities of ops are comparable to those of lisp. for example  to extract the car and cdr of a list  one writes the condition element 
 =car . =cdr  
to extract other subelements  one can write condition elements like 
 =car  =caadr ...  ...  
variables and  .  may also be used in action elements in order to build lists. in an action element   .  has the effect of stripping away the top level of the following list structure and leaving the etements of the list. thus  the production 
 a . =x  -    a . -x  
will do nothing but reassert the matched element. more complex processing is of course possible. for example  the transformation of data performed by the production 
　　　　　　　ox . =y  -    . =y =x  is similar to that of 
 append  cdr z   list  car z   . 
self modification 
         since extensive use may be made of ops's list processing capabilities in manipulating productions  only three functions are provided expressly for this purpose. one of these  readp  takes as its argument the name of a production and causes a copy of that production to be deposited in data memory. once in data memory the production can be processed as any other data element. a second function  buil d  takes a data element having the form of a production as its argument and adds it to production memory. the third function  excise  takes the name of a production as its argument and deletes that production from production memory. this is  again  a primitive but complete set of functions. these three functions give the system the capabilities of creating new productions and of modifying existing productions. to modify an existing production  the system would bring the production into data memory with readp  delete the existing production with excise  modify the copy using the general processing capabilities of ops  and then place the modified production in production memory using build. 
input and output 
         as with the other capabilities  only a minimal set of functions are provided for interaction with the outside world. there are two functions  read and write. write instantiates one or more forms and writes them on user's terminal. read .accepts one or more list structures from the user and deposits them in data memory. 
iv. concluding remarks 
         ops has been in use for more than a year. during that time it has been the primary tool of a research group that has as its goal the construction of an instructable production system whose production memory will eventually contain several thousand productions. ops has proven to be basically satisfactory  but it has not been without its problems. three problems have been particularly irksome; ops is slow  it is somewhat inflexible  and the information in state memory is hidden from the system. on a kl version of the pdp-1  ops executes about 1 actions per second  this figure is almost independent of the number of productions in the system . in the successor to ops  which is scheduled to be completed in the summer of 1  we expect a speed increase of at least one order of magnitude. the inflexibility of ops has caused trouble in several ways. no mechanism was provided to make it easy for a user to modify the set of match functions or the set of conflict resolution rules. yet it became apparent rather quickly that neither the set of match functions nor the set of conflict resolution rules was completely satisfactory. some of the match functions  e.g.  contains and notcontains  received almost no use  while other functions that appear to have promise have not yet been implemented. in the first version of ops  a mechanism was provided that allowed the user to add his own action functions. in the second version of ops this mechanism is being expanded to allow adding new match functions as well. unfortunately  no solution to the problems with conflict resolution strategies has been found. a number of sets of conflict resolution rules have been tried  but no universally appropriate set has emerged. simply allowing the user to modify the conflict resolution rules at will is not a solution; it now appears that the problems with conflict resolution have resulted  at least in part  from the decision not to allow productions to read the information in state memory. 

languages & systems-1: forgy 1 

acknowledgements 	and 	f. 	hayes-roth  eds   	pattern-directed 	inference 

         the development of many of the ideas discussed above owes much to the members of the instructable production system project at carnegie-mellon university. the members of this project  in addition to the authors  are j. laird  p. langley  a. newell  k. ramakrishna  p. 
rosenbloom  and m. rychener. 
