 
　　this paper describes an initial implementation of an interactive programming assistant system called the programmer's apprentice  pa . the pa. is designed to be midway between an improved programming methodology and an automatic programming system. the intention is that the programmer will do the hard parts of design and implementation while the pa will assist him wherever possible. one of the major underpinnings of the pa is a representation  called a plan  for programs which abstracts away from the inessential features of a program  and represents the basic logical properties of the algorithm explicitly. 
　　the current system is composed of four parts: an analyzer that can construct the plan for a program; a coder that can create program text corresponding to a plan  a library of plans for common algorithmic fragments; and a plan editor which makes it possible for a programmer to modify a program by modifying its plan. the greatest leverage provided by the system comes from the fact that a programmer can rapidly and accurately build up a program by referring to the fragments in the library and from the fact that the editor provides commands specifically designed to facilitate program modification. 
i. introduction 
　　the programmer's apprentice  pa  is an interactive system tor assisting programmers with the task of programming. it is intended to act as a junior partner and critic  keeping track of details and assisting in the documentation  verification  debugging  and modification of a program while the programmer does the hard parts of design and implementation. in order to cooperate with a 
　　programmer  the pa must be able to understand what is going on. from the point of view of artificial intelligence  one of the central developments of the programmer's apprentice project has been the design of a representation  called a plan  for programs and for knowledge about programming which serves as the basis for this understanding. 
　　rich and shrobe  1  laid out the initial design for the pa and for plans  see section iii . the author  designed a limited system intended to operate in the domain of mathematical fortran programs and extended the idea of a plan by developing a theory of how plans could be segmented  1   see section iv . more recently rich  1  has further developed the plan formalism  see section ix  and designed a library of plans representing many of the standard cliches in non-numerical programming. 
this report describes research done at the artificial intelligence laboratory of the massachusetts institute of technology. support for the laboratory's artificial intelligence research has been provided in part by the advanced research projects agency of the department of defense under office of navel research contracts 
n1-c-1 and n1-c-1  and in part by national science foundation grant mcs-1. 
the views and conclusions contained in this paper are those of the author  and should not be interpreted as necessarily representing the official policies  either expressed or implied  of the department of defense  the national science foundation  or the united states government. 
　　this paper describes an initial implementation of the pa recently completed by the author. this system is an editor which allows a programmer to build up a program from prototypical fragments  and to modify a program in terms of its logical structure. in both cases the system gains most of its power from the fact that all of these actions are performed on the plan for the program rather than on the program text. it should be noted that the current system is intended as a pre-prototype proof of principle. it is neither efficient nor robust. however  it demonstrates the feasibility of some of the basic ideas behind the pa. 
　　section ii outlines the architecture of the system. the plan formalism which underlies the system is briefly discussed in section iii sections iv-vil describe the four components of the system section viii gives a scenario of the use of the system section ix discusses the weaknesses of the current system  and how these problems will be addressed in the second implementation of the pa which is now under way. 
ii. outline of the current system 
　　the current system is composed of four modules as shown in figure 1. given the text for a piece of a program  the analyzer module can construct a plan corresponding to it the coder module performs the reverse transformation  creating program text corresponding to a plan. the plan library contains common program fragments represented as plans the plan editor makes it possible for the user to modify a program by modifying its plan. 

　　the system maintains two representations  program text and a plan  for the program being worked on. if the programmer uses the plan editor to change the plan  then the system uses the coder to determine what the new program text should be if the programmer uses an ordinary text editor to change the program text  then the analyzer is used to determine what the resulting plan should be. it should be noted that the existence of the analyzer means that the system can be used to modify programs that were not originally constructed using the system. 
　　the leverage provided by the system comes primarily from two things. first  the programmer can rapidly and accurately build up a program be referring to the fragments in the plan library. second  the editor provides a variety of commands specifically designed to facilitate program modification. 
　　there is a similarity between this system and a programming language syntax editor  such as mentor   the cornell program synthesizer   or gandalf   in that the user operates on an underlying representation for the program rather than on its textual representation. in both cases many simple errors are prevented because it is no longer possible to even state them. 
　　there are however three key differences between this system and a programming language syntax editor. first  this system does not depend on the syntax of any particular programming language. 
all of the operations of the system are performed on plans. 	except 
   
1 
   another important feature of the plan representation is that it tries to make things as local as possible. for example  each data flow arc represents a specific communication of data from one place to another and  by the definition of what a data flow arc is  the other data flow arcs in the plan cannot have any effect on this. the same is true for control flow arcs. this leads to the property of additivity. it is always permissible to put two sections of a plan side by side without their disturbing each other. if there is no data flow or control flow between the sections  then they can have no effect upon each other. 
   additionally  intermediate segmentation breaks a plan up into regions which can be manipulated separately due to the fact that the plan representation is designed so that nothing outside of a segment can depend on anything inside that segment. this leads to the property of substitutability. it is always permissible to replace any segment with another segment as long as the two are externally indistinguishable. 
iv. the analyzer 
   the analyzer  described in  and more fully in   automatically produces a plan corresponding to a program. this is done in three steps: source translation  surface analysis  and segmentation. in the source translation step  a language specific module parses the program text and converts it into a lisp-like intermediate form. source translators currently exist for fortran and for cobol. none is needed for lisp. 
   the surface analyzer runs over the intermediate form like an evaluator creating a surface plan as it goes. a surface plan is composed solely of a large number of terminal segments corresponding to primitive operations  such as '+' and  o grouped into one large segment and connected by data flow and control flow. the surface analyzer has detailed knowledge of the constructs which implement data flow and control flow. however  it does not have any knowledge of what the primitive functions do except how many inputs and outputs they have. 
   a surface plan is flat in that it has no hierarchical structure. the segmentation step introduces intermediate segmentation reflecting the logical structure of the plan. the primary goal of this process is to group segments which interact heavily close together  and keep segments which interact little  if at all  far apart. the segmentation is done in terms of six basic configurations called plan building methods  pbms . it proceeds bottom up based on the topology of the control flow and data flow by locating minimal configurations which can be grouped together inside intermediate segments in accordance with the pbms. 
   in general  the pbms correspond to basic structured programming constructs: expressions  complex predicates  conditional expressions  and loops. the primary innovative feature is that loops are analyzed as compositions of fragments of looping behavior communicating by means of temporal sequences  streams  of values  rather than as repetitively executed pieces of straight-line code. for example  the loop in figure 1 would be analyzed as a composition of four loop fragments as shown in figure 1. 
   the first fragment  a generator  counts up by 1 from 1 creating an unbounded temporal sequence of values {1 ...}. the second fragment  a terminator  tests the sequence of integers produced by the generator and stops the loop when an integer greater than n is found. this has the effect of truncating the sequence of integers to the sequence {1 ... n}.  both of these fragments are part of the 1 construct.  the third fragment  a filter  restricts the truncated sequence of integers by selecting only those integers which correspond to positive elements of the vector a. the last fragment  an accumulator  computes the sum of the elements of a corresponding to the integers in the restricted sequence produced by the filter. in the loop as a whole  the four fragments are cascaded together so that the loop computes the sum of the positive members of the first n elements of a. 
1i  
   
   from the point of view of the system being described here  this analysis is important because it provides very convenient intermediate segmentation. for example  if the programmer wanted to change the loop above into one which computed the product of all of the elements in the vector  he would only have to remove the filter  and replace the summation accumulator with a product accumulator. 
v. the coder 
the coder takes in a segmented plan and creates the code for a 
lisp program corresponding to it. this process is relatively straightforward. the structure of the program produced closely follows the structure of the segmented plan. in general  each terminal segment in the plan is implemented as a function call  and etch non-terminal segment in the plan is implemented using a 
syntactic construct corresponding to its pbm. for example  * segment whose pbm is conditional will usually be coded using a cond. there are only two areas of real difficulty: determining how to implement the data flow in the plan  and dealing with loops. 
   the data flow is a problem because the plan formalism deliberately does not represent much information about how data flow should be implemented. the coder is forced to discover how to use variables and nesting of function calls in order to implement the required data flow. in order to get mnemonic variable names  the plan contains explicit suggestions for what variable names to use when variables are required. 
   when deciding how to implement the data flow in a plan  the coder first identifies every place where the nesting of function calls can be used. it then identifies related groups of data flow arcs that can be implemented using the same variable. its basic goal is to use the smallest number of variables possible. when picking names for these variables  it uses any suggestions recorded in the plan. it has to be particularly careful to make sure that there is no conflict when the same name is suggested for two different groups of data flow arcs. 
   in order to produce lisp code for a loop analyzed as a composition of loop fragments  the fragments must first be combined together into a single loop. this process  see   is designed so that the validity of the simple logical analysis in terms of composition will be preserved. the fragments ere taken apart  and their pieces ere reassembled into the resulting loop. the arrangement of the pieces in the loop is dictated by the data flow communicating temporal sequences of values between the fragments. the key idea is that if a piece of one fragment uses a temporal sequence created by a piece of another fragment  then the consuming piece should be placed after the producing piece in the resulting loop. the action of   filter is produced by placing the pieces which receive its outputs within the scope of a conditional predicated on the filter's test. similar problems have been attacked by the people working on compilers for api  see for example   . 
vt. the plan library 
   the plan library is a collection of plans for common algorithmic fragments. there are fragments corresponding to the six pbms  eg conditional  predicate  loop  etc. . in addition  there are a variety of more specific programming cliches such as those in figure 1  i.e counting up  stopping at a given number  selecting out the positive elements  and summing up . it should be noted that this is more usefut than a collection of fragments represented in a programming language for three reasons. first  the plan fragments are more canonical. a given plan can be realized as code in many different ways. second  many fragments ere so fragmentary that they do not correspond to any syntactically reasonable section of code. third  due to the additivity property of plans  having the fragments represented as plans makes it easier to combine them. the system does not have to worry about issues like variable name conflicts  because there are no variables. 
   the library makes two basic things available to the user. first  he can include a fragment in the program he is constructing by referring to it by name  e.g.  conditional*   count    summation   etc. . second  etch fragment has named parts some of which may be unspecified. for example  a conditional has some unspecified test  a summation has tn  accumulation  part which is specified to be +  and it has a sequence part  the temporal sequence to oe summed; which is unspecified. when a fragment is instantiated its part names are carried over as well. the programmer can then use them when referring to the program he is constructing  e.g.  test of conditional   accumulation of summation    sequence of summation  . 
vii the plan editor 
   the plan editor provides a set of commands which a programmer can use to modify the program he is working on  by modifying its plan. he communicates with the plan editor using an ll1 pseudo english. the central feature of the system is the vocabulary that the programmer uses. the semantics of this vocabulary is based on the plan notation and the plan fragments in the library. 
   the basic objects known to the system are the objects in a plan: segments  input and output ports of segments  data flow  and control flow. various adjectives are available for referring to particular kinds of objects. for example   constant segment    function call segment    first segment    tree variable input   or  side-effect output . part name expressions refer to the relationships between objects. for example   subsegment of segment    input of segment    use of output   or  source of data flow . as discussed above  the fragments in the plan library and their parts can be referred to by name. 
   a programmer can refer to a specific part of the plan for the program he is working on by using the word  the   e.g.  the test of the program foo  . complex references can be built up by nesting simple ones  e.g.  the use of the side-effect output of the action of the program foo  . these phrases make it possible for the programmer to treat his program as an algorithmic structure  rather than a syntactic one he can identify parts of the program based on their role in the algorithm  rather than based on their location in the text  or by their relationship to the parse tree for the program  as in a programming language structure editor. as a convenient method of reference  the pronoun  it  is used to refer to the object which is the current focus of the system's attention. in addition  program names and variable names can be used to refer to the associated objects. 
   the word  a  is used to create an instance of something. for example   a summation   or  a side-effected free variable output tbi . the programmer can also use literal pieces of program text  such as 
  eg  car current  symbol   in order to create a new fragment of plan.  the analyzer is used to convert the text into a plan.  
   the editor provides a variety of verbs which specify actions to be performed. two of these:  define   a new program  and  implement   an unspecified part a plan fragment   are used to build up a program by combining prototypes from the library as this is being done  the system annotates the resulting plan so that it embodies an analysis of the program in terms of the fragments used to create it. 
   another group of commands  such as  add   some object to the plan    remove   some object from the plan    replace   some object with another    share   two segments together as a single instance   etc.  are used to modify a plan. the primary leverage here is that it is much easier to make changes to a plan without causing unwanted side-effects  than it is to make changes to program text without causing unwanted side-effects. this is due to the fact that in a plan things are represented explicitly  locally  and irredundantly so that in general if some feature of the plan is changed  it doesn't effect any other feature of the plan. in contrast consider the use of variables in a programming language. using a variable to implement a data flow in one place can have arbitrary effects on other data flows that happen to be implemented using the same variable. 
   note that the process of modification interacts strongly with the process of constructing a plan from prototypical fragments. as mentioned above  the plan embodies an analysis of the program in terms of the fragments used to create it. once an orthogonal modification is made to the program  it must be reanalyzed in order to determine what fragments correspond to its new structure. whenever possible this reanalysis is done incrementally so that only the immediate neighborhood of the change is effected. if complete reanalysis is required  then information about the specific library cliches used to build up the plan is lost due to the fact that the current analyzer can only analyze a program in terms of the pbms. 
   
1 
   
   the plan editor also makes available several commands for displaying information to the programmer. tor example  he can ask what parts of the plan are still incomplete  he can ask the system to describe parts of the plan  or he can ask the system to display the parts of the program which correspond to a part of the plan. 
viii. a scenario 
   this section presents a brief scenario showing an actual interaction with the current system. the programmer is constructing a function delete which will delete  by side-effect  an occurrence of a symbol from a set implemented as a hash table. as shown in figure 1  the hash table is a vector of lists  called buckets . each symbol in the set is placed in one of the buckets. in order to simplify the deletion process  the hash table is implemented using buckets which have special header cells of nil. 

   the programmer has already coded the function in figure 1 which takes in a symbol  and returns the appropriate bucket of the hash table. the function works by generating a unique number corresponding to the symbol  taking the remainder of this number after dividing by the size of the table  and then using this remainder to index into the table. note that the hash table itself  tbl  as well as its size  tblsizo are free variables. 

   the programmer communicates with the system by typing at a video terminal the screen of the terminal is divided into two regions  see frame 1 . the top region shows what the programmer types. the lower region is used by the system to display code for the program being worked on the part of the program that the system's attention is focused on  it  is highlighted on the display  this is indicated by underlining in the figures below . the last line of the lower region is a part expression identifying the highlighted section each frame in this scenario corresponds to a screen image seen by the programmer. 
   the first frame shows the programmer starting to build up his program by combining fragments from the library. first  he begins the definition of the function  specifying its parameter. he then implements the program as a trailing-pointer-list-enumeration. 

frame 1 
   the reader might well complain at this point that  trailing-pointerlist-enumeration  is a  /ery cumbersome name and that no one would want to have to remember it or use it. there are several points to be made. first  the actual name itself is not important. what is important is that the process of moving a pointer  here current  down a list starting at the second element while maintaining a second  trailing  pointer  here prev  pointing to the preceding list element  see figure 1  is a common algorithm that is known both to programmers and to the system. second  there has to be some way to refer to it so that the programmer can pull it into his program when he wants it. just as in interlisp a programmer has to know the names of the functions in the manual in order to use them  the user of this system has to know the names of the prototypes in the library. third  section ix shows how the next implementation of the pa will reduce the need for the programmer to know idiosyncratic names like this. 

   the lower part of frame 1 shows the code produced by the coder based on the plan constructed by the user's commands. the coder uses a psetq  parallel assignment  in the code it produces because that is easier than trying to figure out what order the assignments should be done in. the plan  and therefore the code  is fragmentary because the programmer's description of the program so far is fragmentary. the coder is specifically designed so that it will produce legible  though perhaps not runnable  code for a plan no matter how fragmentary the plan is. the code in the display serves as a summary of what has gone on so far in the editing session. the symbol  . .initial-list ..  is used to represent the  so far unspecified  initial-list part of the trailing-pointer-list-enumeration fragment. 
   in frame 1  the programmer fills in the initial-list slot by implementing it as the expression   hash symbol  . through the ability to pull in fragments from the library  and then fill in their unspecified parts with pieces of code  or other fragments from the library  the system supports the top down construction of a program. 

frame z 
   the next two frames illustrate a completely different mode of interaction with the system: modification. typically program construction  and certainly debugging  involves a lot of modification as the program evolves into an acceptable implementation. in frame 1 the user has decided that he doesn't like the algorithm for trailing pointer list enumeration used by the system because it contains an unnecessary instance of cor. he asks the system to get rid of this by sharing the two instances of cdr. this is a good example of a modification which is easy to state  but which is not so easy to perform on program text. the main problem is that looking simply at the text  it is not easy to tell whether or not the sharing is possible. the whole program must be checked to see that there are no side-effects or modifications of the variables involved which prevent the sharing. the system gets considerable leverage on this because these questions are easy to answer in the plan representation due to the fact that all of the data flow is represented as explicit arcs. 
   once it has been determined that the sharing is permissible  relatively global changes may have to be made in the code. for 
   
example  a temporary variable may have to be introduced. here things are particularly complicated due to the fact that the cor in the loop has to be shifted around to the top of the loop before it can be shared with the coff in the initialization. here again the required tasks are easier to perform on a plan than on program text. the coder is used to create the new text after the plan is modified. 
 share the coff in the initialization with the cor in the bump of the generator. 
 define delete  symbol   prog  current prev  
 setq prev  hash symbol   
lp  setq current  cor prev   
 cono   null current   return n i l       
 setq prev current  
 go l p       
the bump of the generetor of delete. 
frame 1 
   in frame 1 the programmer adds a second terminator into the loop. this causes the loop to have two exits. the system responds to this by embedding the loop as the test of a conditional. this reflects the assumption that the programmer intends to perform separate  unspecified  actions corresponding to the two loop terminations  otherwise he would have combined them into one termination with a compound test   and that he intends to join the control flow after these two distinct actions  and simply return from the function in either case. the system notifies the user of this change because it is a somewhat non-obvious one  and because it changes the way things can be referred to by adding an additional level of nesting into the plan. 
   the second programmer request in frame 1 specifies the test of the additional terminator. the test stops the loop if an element identical to the input symbol is found. note that the programmer simply gave a little piece of code because that was easier than specifying what he wanted any other way. 
 add a t e r m i n a t o r i n t o the loop a f t e r the f i r s t t e r m i n a t o r of 	the 	loop 
	since the loop now hes two e x i t s . 	i assume that 
delete is a c o n d i t i o n a l w i t h the loop as i t s t e s t . 
  implement the test of the terminator as ' eo  car current  symbol . 
 define delete  symbol   prog  current prev  
 setq prev  hash symbol   
lp  setq current  cor prev   
 cono   null current   return . a c t i o n . .        cono   eq  car current  symbol  
	 return 	a c t i o n   .       
 setq prev current  
 go l p       
	the t e s t of the second terminator of the t e s t of 	. . . 
frame 1 
   at this point  in order to demonstrate another capability of the current system  the programmer asks what needs to be done  see frame 1 . the system keeps track of all of the aspects of the plan which are incomplete. it replies that the two actions still need to be implemented. the programmer then specifies these actions. note that he refers to the simple programming cliche  splice-out . 
 what needs to be done  
	implement 	the f i r s t e c t i o n of delete 
implement the second e c t i o n of delete. 
  i m p l e m e n t the second a c t i o n of the program as a s p l i c e - o u t of 	'prev 
	  i m p l e m e n t the f i r s t a c t i o n of the program as 	n i l 
 define deiete  symbol   prog  current prev  
 setq prev  hash symbol   
lp  setq current  cur prev   
 cono   null current   return n i l       
 cond   eq  car current  symbol  
 rplacd prev  coor prev   
 return nil     
 seto prev current  
 go l p       
the nil a c t i o n of delete 
frame 1 
   the last frame demonstrates some other capabilities of *he current system. in response to the request  describe   the system can report out simple features of the plan. here  the programmer asks for a description of the inputs and outputs of the program. note that the system has figured out that tbl and tblsize are free variable inputs to delete since they are free variable inputs to hash. 
  d e s c r i b e the ports of deiete 
the symbol parameter 
the tbl free v a r i a b l e input 
the tblsize f r e e v a r i a b l e input 
the r e t u r n value 
the tbl s i d e - e f f e c t output 
 dissplay the source of the tbl output 
 define delete  symbol   prog  current prev  
 setq prev  hash symbol   
lp  setq current  cor prev   
 cono   null current   return n i l       
 cono   eo  car current  symbol  
 rplacp prev  copr prev   
 return n i l       
 setq prev current  
 go l p       
the tbl s i d e - e f f e c t output of the rplaco a c t i o n of 
   more interestingly  the system realizes that tbi is also an output of delete the system deduces this  even though it is not at all obvious from the way the programmer built the program up  because it has a simple model of side-effects which allows it to understand many common situations where side-effects are used. it knows that if a program side-effects some part of a structure  then the structure as a whole is also side-effected. here  the rplaco potentially changes prev which through a chain of cdrs is part of the list returned by 
 mash symbol . because hash has already been defined the system knows that this list is part of the vector tbl and that therefore this  input to delete is potentially modified. it is very important that the system be able to make this kind of deduction  because much of what goes on in the system depends on the fact that the data flow is correct. if some more complex side-effect were going on the user would have to tell the system about it so that the effect would not be overlooked. as his last request  the programmer asks the system to show him where the side-effect output comes from  and the system highlights the call on rplaco indicating the source 
   
ix. the next implementation of tht pa 
　　figure 1 shows the commands from the scenario above which were necessary in order to construct the program delete one important way to evaluate these commands is to consider the level of understanding exhibited by the current system. there are four classes of things that it understands. it understands the basic plan notions  segments  inputs  outputs data flows etc.  and how they can be referred to. it understands the pbms  expression  conditional  loop  etc. . it understands the verbs in the commands  define  implement  add  etc. . finally  it understands the fragments in the plan library  trailing-pointer-list-enumeration  splice-out  etc.   but only in that it can recall them by name  and interpret references to their parts. 
	 define 	a program delete w i t h a parameter symbol 
	 implement 	it 	as 	a 	t r a i l i n g - p o i n t e r 	- list-emimeration 
	 implement 	the 	i n i t i a l - l i s t 	as 	' hash symbol  
	 add 	a 	t e r m i n a t o r 	into 	the 	loop after 	the 	f i r s t 
	t e r m i n a t o r 	of 	the 	loop. 
	  mplement 	the 	test 	of 	thr 	terminator 
	as 	' co  car current  symbol   . 
	 lmplemcnt 	the 	second action of 	the program as 	a 
	s p l i c e 	out 	of 	'prev 
	 lmplemenl 	the 	f i r s t 	a c t i o n of 	the program as 	'nil 
figure  1: the commands used to construct delete. 
　　however  there are three very important things that the current system does not understand. first  it does not understand anything about data structures. prior to the scenario  the hash table was described for the benefit of the reader  but the programmer said nothing about it to the system. he just chose the correct algorithmic fragments for working on the data structure he had in mind. second  the current system understands nothing about specifications. again  the programmer just chose the correct fragments to implement the specifications he had in mind. third  the current system understands nothing about interrelationships between the fragments in the library. 
the original design of plans included the notion of specifications. 
however  this feature was not used in the current system. rich  1  has extended the plan formalism so that it can be used to represent knowledge about data structures and about interrelations between plans for data structures  plans for algorithmic structures  and specifications. he has also designed and is implementing a comprehensive plan library of common programming cliches in the domain of non-numerical programming using the improved plan formalism together with the components described here  this new library will serve as the basis for the next implementation of the pa. 
　　using the next implementation of the pa  the programmer will be able to create the program delete using a sequence of commands like the ones shown in figure 1. first  since the system understands data structures and specifications  the user tells it about them. before constructing the program hash the programmer tells it about the data structure being used by saying  tbi implements   set as a hash table whose buckets are lists with header cells of nil . this command refers to several data structure terms  i.e. set  hash table  bucket  part of hash table   list  header cell  part of list   nil . the system understands these terms due to the presence of plans for common data structures in the new plan library. based on this description the system builds up a plan for the data structure. 
before c r e a t i n g hash. 
 tbl implements a set as a hash table whose buckets are l i s t s w i t h header c e l l s of nil. 
 the f u n c t i o n hash mops symbol into the corresponding bucket in tbl 
	in o r d e r 	to create 	delete: 
	 define 	a program delete with a parameter symbol. 
	 deleu removes symbol 	from tbl . 
 implement deieu so that it searches the bucket in tbl corresponding to symbol and splices out the occurrence of symbol  if there is one. 
f i g u r e 1. commands needed in the next implementation 
　　the programmer then gives a specification for hash  the function hash maps symbol i n t o the corresponding bucket 1n tbl*. this r e f e r s to a number of specification terms understood by the system  i.e. map  corresponding . based on this  the system constructs specifications for the function hash. 
	once 	hash is constructed  the programmer starts to construct 
delete by setting up the outer segment  define   program delete w i t h 
  parameter symbol   and giving its specifications  delete removes symbol from tbl  
he then describes the algorithm to be used by using the command 
 implement delete so that 1t searches the bucket in tbl c o r r e s p o n d i n g to symbol and splices out the occurrence of symbol  if there is one . 
this final command corresponds to the last six commands in figure 1. he is able to be more concise here because  due to the interrelationships in the new library  the system will be able to reason about how the choice of one fragment determines the choice of other fragments. 
　　the programmer specifies that he wants to search  the bucket in tbl corresponding to symbol . because of the specifications the programmer gave for hash  the system knows that this bucket can be calculated by calling  hash symbol . 
　　 search  is an abstract fragment that specifies that in order to search something a program must enumerate the things in the structure and check each item to see if it is the one desired. there are two exits from the searching loop depending on whether the desired item is found or not. due to the fact that the programmer said that the buckets in the hash table were lists  the system knows that it must do a list enumeration in order to search it. the programmer specifies that the predicate he wants to use in the search is one which tests for an  occurrence of symbol . 
　　finally  the programmer specifies that what he wants to do when he finds the occurrence of symbol is  splice   i t   out . the system has the same fragment for splice out that is used  n figure 1  but additionally it knows that in order for a splice out to work  there has to be a trailing pointer. as a result  it reasons that it needs to do a trailing pointer list enumeration  a special kind of list enumeration  in the search. 
　　note that because the new system will be able to do the above kind of simple reasoning  the user will not have to use specific fragment names such as  trailing-pointer-list-enumeration   but rather can  in general  rely on more abstract terms such as  search . another important benefit to be gained from this kind of reasoning is that the system can do simple consistency checking  and complain whenever the user tries to combine incompatible fragments. the current system only complains when the user violates the basic semantics of a plan. 
　　another major improvement which is being made to the system  is the strengthening of the analyzer. brotsky  is working on adding a fourth stage to the analysis component of the system so that it can analyze a program in terms of all of the fragments in the library  not just in terms of the six pbms. the fact that analysis in terms of pbms is done first should simplify this task because it breaks the program up into a number of small pieces. the recognition process should be able to avoid combinatorial explosion by looking at each piece separately  rather than searching through the entire program at once. once complete analysis is possible  the system will be able to apply the full force of the knowledge in the plan library to bear on a program whether or not it was originally built up using the system  and whether or not it has been modified. 
　　looking further in the future there are several other kinds of knowledge which should be added to the pa. for example  both the current system and the next one are oriented toward understanding how a program does what it does. there is little or no representation of why it does it the way it does as opposed to some other way. this problem can be addressed by adding knowledge of efficiency issues into the system. in addition  the current plan representation is oriented toward representing single programs and small clusters of programs. it needs to be extended so that it can represent large scale system organizations. finally  the knowledge now being represented is limited to general knowledge about programming. in order to be more useful to a programmer in a particular domain  the library will have to be extended so that it contains a variety of fragments pertaining to the particular domain of use. in the long run  as the pa gains more and more knowledge in more and more areas  it will be able to take on increasingly large portions of the programming task. 
   
