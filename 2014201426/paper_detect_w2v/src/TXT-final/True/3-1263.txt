
we describe a strong connection between maximally satisfiable and minimally unsatisfiable subsets of constraint systems. using this relationship  we develop a two-phase algorithm  employing powerful constraint satisfaction techniques  for the identification of conflicting sets of constraints in infeasible constraint systems. we apply this technique to overconstrained instances of the disjunctive temporal problem  dtp   an expressive form of temporal constraint satisfaction problems. using randomly-generated benchmarks  we provide experimental results that demonstrate how the algorithm scales with problem size and constraint density.
1 introduction
many ai problems can be cast in terms of constraintsatisfaction problems  csps   and a large number of systems have been developed to efficiently compute solutions to sets of constraints. however  not every set of constraints is satisfiable. this paper reports on a technique for efficiently identifying sets of conflicting constraints in an overconstrained problem. we focus on temporal constraint problems  which play a prominent role in planning  scheduling  and other applications of interest in ai. our approach is particularly wellsuited to temporal problems  in which conflicts among constraints can be resolved by weakening  rather than completely abandoning  constraints.
¡¡we build on our previous work  liffiton and sakallah  1  on identifying minimally unsatisfiable subsets of constraints  muses . given a set of constraints c  an mus of c is a subset of c that is  1  unsatisfiable and  1  minimal  in the sense that removing any one of its elements makes the rest of the mus satisfiable. each mus thus provides information about a conflict that must be addressed to solve the given csp. in general  an arbitrary csp may contain multiple muses  and all of them must be resolved by constraint relaxation before the csp can be solved. identifying the muses of a csp makes it possible to reason about how to weaken conflicting constraints to make a solution feasible.
¡¡prior work on muses has largely been restricted to algorithms for finding a single mus. in addition  these algorithms have been specific to particular types of constraint systems  e.g.  boolean satisfiability   bruni and sassano  1; zhang and malik  1; oh et al.  1  and others  or linear programming  chinneck  1   and the techniques developed often cannot be readily generalized to other types of constraints. in contrast  we explore a deep connection between maximal satisfiability and minimal unsatisfiability to develop techniques that can be used to find all muses of a constraint system  regardless of constraint type. in this paper  we demonstrate the approach by applying it to disjunctive temporal problems  dtps   stergiou and koubarakis  1   a particularly expressive form of temporal constraints. our previous work focused on finding muses of boolean satisfiability instances  which have applications in circuit design and verification. dtps provide a richer space for using muses  specifically because their constraints can be relaxed without any change in structure  something that is not possible with boolean variables and constraints.
¡¡in section 1 of the paper  we define dtps and discuss the motivation for finding their muses further. section 1 describes the relationship between maximal satisfiability and minimal unsatisfiability. section 1 contains the specific algorithms we employed to exploit this relationship for finding muses of dtps. empirical results are given in section 1  and section 1 closes with conclusions and directions for future work.
1 disjunctive temporal problems
a disjunctive temporal problem  dtp  is a constraint satisfaction problem defined by a pair hx ci  where x is a set of real variables  designating time points  and c is a set of constraints of the form: ci1¡Åci1¡Å...¡Åcin  where each cij is of the form x   y ¡Ü b; x y ¡Ê x and b ¡Ê  . dtps are thus a generalization of simple temporal problems  stps   in which each constraint is limited to a single inequality  dechter et al.  1 . a solution to a dtp is an assignment of values to time points such that all constraints are satisfied.
¡¡several algorithms have been developed for solving dtps  stergiou and koubarakis  1; armando et al.  1; oddi and cesta  1; tsamardinos and pollack  1 . typically  these algorithms transform the problem into a metacsp  in which the original dtp is viewed as a collection of alternative stps. using this approach  the algorithm selects a single disjunct from each constraint of a given dtp. the resulting set forms an stp  called a component stp  which can then be checked for consistency in polynomial time using a shortest-path algorithm. clearly  a dtp d is consistent if and only if it contains at least one consistent component stp. furthermore  any solution to a consistent component stp of dtp d is also a solution to d itself. consequently  it is standard in the dtp literature to consider any consistent component stp to be a solution of the dtp to which it belongs.
¡¡a number of pruning techniques can be used to focus the search for a consistent component stp of a dtp. these include conflict-directed backjumping  removal of subsumed variables  and semantic branching. the dtp solver epilitis  tsamardinos and pollack  1  integrated all these techniques  in addition to no-good recording. epilitis  and other traditional dtp solvers  perform total constraint satisfaction-that is  their objective is to find a solution that satisfies all the constraints of a dtp. in the event that a dtp is inconsistent  these solvers are capable of detecting such infeasibility  but incapable of providing partial solutions that come close to satisfying the problem. in response  the dtp solver maxilitis  moffitt and pollack  1  was designed to find solutions that maximize the number of satisfied constraints.
¡¡sometimes the number of satisfied constraints is not the best measure of a solution; it may instead be important to reason about exactly which constraints are violated  as well as the extent to which they have been violated. we illustrate with the following very small dtp  which we use as an example throughout the paper:
c1 : {c1 :  x   y ¡Ü 1 }
c1 : {c1 :  y   x ¡Ü  1 }
c1 : {c1 :  y   x ¡Ü  1 } ¡Å {c1 :  z   y ¡Ü 1 } c1 : {c1 :  y   z ¡Ü  1 }
¡¡note that this dtp is unsatisfiable. the set of constraints {c1 c1} is inconsistent  and the same is true for {c1 c1 c1}. a standard dtp solver would simply report that the problem was unsatisfiable  while a system like maxilitis would find a solution that maximizes the number of satisfied constraints-in this case  a solution that satisfies {c1 c1 c1} and not c1. but for many applications  it might be important instead to maintain some control over the relationship between x and y that is expressed in c1. if we knew the source of the conflict involving c1  we could reason about how to weaken c1 and the constraints with which it conflicts. for example  we could decide to change the bound on c1 to 1  or to change the bounds on both c1 and c1 to 1. we could reason about similar relaxations of c1  c1  and c1 to make them jointly feasible. but in order to do this  we must have identified which constraints are in conflict with one another  and this is precisely what the muses tell us.
¡¡this ability to relax constraints without completely removing them makes dtps a much more interesting domain for finding muses than  for example  systems of boolean constraints. an infeasible boolean satisfiability instance may be made feasible by completely removing constraints  and such changes are indicated directly by techniques that identify a maximal satisfiable subset of constraints. an infeasible dtp  however  can be made consistent by altering the bounds of inequalities  without modifying the structure of the problem. muses provide information needed to determine these changes.
1 maximal satisfiability and minimal unsatisfiability
our techniques for extracting muses are derived from a deep relationship between maximal satisfiability and minimal unsatisfiability. the maximal constraint satisfaction problem  max-csp  is an optimization problem on a constraint system c that has the goal of finding an assignment to the variables of c that satisfies as many constraints as possible; this is the solution that maxilitis finds  e.g.  {c1 c1 c1} for our example problem .
¡¡while max-csp is defined in terms of the cardinality of a satisfiable subset of constraints  the definition can be relaxed to have inaugmentability as the goal instead. thus  while we can define max-csp c  as {m   c :
|m| is maximal  m is satisfiable}  we can define a new problem  maximally satisfiable subset  mss . the definition of the set of msses follows  with the set of muses defined similarly for comparison:
m   c : m is satisfiable  and	 msses    =  c ¡Ê  c m   m ¡È {c} is unsatisfiable
m   c : m is unsatisfiable  and muses    =
 c ¡Ê m  m {c} is satisfiable
¡¡each mss is a subset of c that is satisfiable and inaugmentable; adding any other constraints in c to such a subset will render it unsatisfiable. notice from the definition that msses c  and muses c  are essentially duals of one another! an mss is satisfiable and cannot be made larger  and an mus is unsatisfiable and cannot be made smaller. this relationship is more than cosmetic; we will show how one set is actually an implicit encoding of the other. note also that any max-csp solution is also an mss; maximal cardinality implies inaugmentability. however  msses may not all have maximal cardinality  as illustrated in the example dtp. one mss of the example is {c1 c1 c1}  corresponding to the max-csp solution. {c1 c1} is another mss  adding either c1 or c1 makes it unsatisfiable   though smaller. now consider c1  the constraint not included in the maxcsp solution to our example. removing c1 from the dtp makes the remaining system satisfiable. in general  given any mss  the set of constraints not included in that mss provides an irreducible  fix  for the original infeasible system; removing these constraints makes it satisfiable. therefore  we define a  comss  as the complement of an mss  and the set comsses c  as:
comsses c  = {m   c :  c m  ¡Ê msses c }

comsses c c1c1c1c1
muses c c1c1c1c1{c1 c1}xx{c1 c1 c1}xxxmuses c  =  c1  c1 ¡Å c1  c1 ¡Å c1 comsses c  =  c1 ¡Å c1  c1 ¡Å c1 ¡Å c1 = c1 ¡Å c1c1= c1 ¡Å c1 ¡Å c1= {{c1 c1} {c1 c1 c1}}= {{c1} {c1 c1} {c1 c1}}figure 1: covering problems linking comsses c  and muses c ¡¡this complementary view of msses c  reveals a more meaningful connection between maximal satisfiability and minimal unsatisfiability. recall that the presence of any mus in a constraint system c makes c infeasible. therefore  to make c feasible  every mus in c must be neutralized by relaxing or removing at least one constraint from it. any comss is one such set: a comss m is an irreducible set of constraints whose removal makes c satisfiable. thus  every comss contains at least one constraint from every mus of c. for temporal problems  achieving satisfiability may not require removing every constraint in a comss  but it does require relaxing all of them. of course  removing a constraint is equivalent to extreme relaxation  in which the bound of an inequality in the constraint is set to infinity.
¡¡every comss is inherently a solution to a covering problem on muses c . specifically  it is a solution to the hitting-set problem  garey and johnson  1  on muses c . given a set c  and a collection of subsets of c  a hitting set of the collection is a subset of c that contains at least one element from each subset in the collection. in this case  the set c is the set of constraints in a constraint system  the collection of subsets of c is the set muses c   and the hitting set of muses c  is a comss of c. additionally  in line with the  duality  of msses and muses  every mus is a hitting set of the set of comsses. this is the key to extracting all muses of a constraint system: first compute the set of comsses of c  then extract muses by finding hitting sets of the comsses.
¡¡figure 1 illustrates the relationship with covering problems that link comsses c  and muses c  for our example dtp. the left table represents the covering problem of finding muses that cover the comsses to generate muses c . each column is a constraint from the dtp  and each row is a single comss. we can say that a constraint  covers  a comss  marked with an 'x' in that row  if it is contained in the comss. each mus is then an irreducible subset of the columns that covers all of the rows. in the example  these are found in a manner similar to petrick's method from boolean logic minimization: each row becomes a disjunction of the columns that cover that row  and the disjunctions are conjoined and simplified by the distributive rule. the right half of the figure shows how comsses c  can be generated in the exact same manner from muses c .
¡¡if we are interested primarily in finding an arbitrary set of constraints to relax in order to make an overconstrained set c feasible  then we could simply compute comsses c : each element of comsses c  represents one set of constraints that  if sufficiently relaxed  will result in c being feasible. but if we instead want to reason about how to weaken particular constraints  we need to identify the individual sets of conflicting constraints  i.e.  muses c . in practice  it is eas-
simplified-musilitis-comsses a  u 

1. newcomss
1. comsses ¡û comsses ¡È {newcomss}
1. backjump-to- true
1. return
1. c ¡û select-constraint u   u' ¡û u - {c}
1. for all values c ¡Ê d c 
1. a' ¡û a ¡È {c ¡û c}
1. if consistent a' 
1. simplified-musilitis-comss a'  u' 
1. if  backjump-to- = true  return

1. unless  assignment-subsumed a' comsses  
1. simplified-musilitis-comss a'  u' 
1. backjump-to- false
figure 1: a simplified version of an algorithm for finding the
comsses of a dtp
ier to find maximally satisfiable subsets  and thus  comsses  than to find muses directly. this follows from the relative simplicity of problems in np  i.e.  sat  as compared to those in co-np  i.e.  unsat . thus  our approach will be to compute comsses c  and then find its irreducible hitting sets.
1 algorithm details
we now describe the details of our algorithm for finding muses. we use a serial decomposition of the task. first we find all of the comsses of a dtp using an algorithm that borrows heavily from maxilitis; this algorithm could be readily generalized for other types of constraints. second  we use techniques for extracting muses that operate completely independently of how the comsses were generated and the types of constraints involved. the two phases combine to form a solver  which we name musilitis  that is capable of diagnosing the infeasibility of any given dtp. the solver is both sound  in that the sets of constraints it returns are all muses  and complete  in that it will find all muses of the given constraint system.
1 finding comsses c 
in figure 1  we present a simplified version of an algorithm for finding the set of all comsses of a dtp. this backtracking search resembles in many ways the branch-and-bound algorithm employed by maxilitis  in that it effectively searches through the space of all partial assignments of disjuncts to constraints.  recall that we convert each disjunctive constraint in the original dtp into a meta-level variable  whose domain is the set of disjuncts.  the set a contains the current partial assignment  and the set u contains those constraints that have not yet been instantiated. whenever a constraint is instantiated with an empty assignment  i.e.  it is purposefully chosen to be left unsatisfied   such an assignment is labeled by the symbol .
¡¡to understand the algorithm  consider an example with 1 constraints. suppose that we begin the search and find a solution in which two constraints  say c1 and c1  have been left unsatisfied. at this point  the search can prune any other solutions that would necessarily leave c1 and c1 unsatisfied  as such candidates would be incapable of leading to an irredundant comss. we handle this in our algorithm by means of a backjump flag that causes the search to immediately backjump to the deepest point at which the assignment to one of the unsatisfied constraints was made.
¡¡lines 1 through 1 handle the case when a particular solution with all constraints instantiated has been found. the set of unsatisfied constraints  those assigned   is a comss  and it is added to a global list of comsses  initialized to  . at this point  the flag backjump-to- is toggled to avoid any further search within the current subtree whose solutions would be subsumed by the comss just found.
¡¡if one or more constraints remain uninstantiated  line 1 selects a constraint to satisfy  and lines 1 - 1 attempt various disjuncts with which to satisfy it. however  if one of the recursive calls finds a solution  the backjump-to- flag may be enabled  causing the algorithm to bubble up the search tree until the deepest assignment of  is reached.
¡¡line 1 is where the algorithm attempts the empty assignment. if this assignment is not subsumed by any comsses found in prior solutions  line 1   the algorithm will pursue this partial assignment  line 1   afterwards resetting the backjump flag in the event that a solution below was discovered  line 1 . it should be noted that this version of the algorithm is not guaranteed to find only irredundant comsses  but any redundancies can be easily removed in a postprocessing step.
¡¡a slight variation on this approach is to find comsses in increasing order of size. by blocking comsses found in increasing order  the algorithm ensures that all subsequent comsses found are irredundant. such an incremental algorithm can easily be achieved by setting an upper bound on the number of constraints violated  and repeatedly calling the given algorithm  each time increasing the upper bound by 1 until the problem is no longer satisfiable. while many searches are performed  the pruning allowed by the smaller comsses may potentially save time otherwise spent finding redundant comsses. this incremental algorithm proved to be extremely effective in maxilitis  where the goal was simply that of maximal constraint satisfaction.
¡¡if implemented exactly as shown  the algorithm shown in figure 1 would perform rather poorly. the pseudocode does not illustrate the use of forward checking  a vital tech-
musilitis-extractmus comsses 
1. mus ¡û
1. while  comsses is not empty 
1. curcomss ¡û pop comsses 
1. newconstraint ¡û pop curcomss  1.	mus ¡û mus ¡È newconstraint
1. for all testconstraint ¡Ê curcomss
1. for all testcomss ¡Ê comsses
1. if testcomss contains testconstraint
1. remove testconstraint from testcomss
1. for all testcomss ¡Ê comsses
1. if testcomss contains newconstraint
1. remove testcomss from comsses
1. return mus
figure 1: extracting a single mus from comsses c 
nique used in all dtp solving algorithms. it also does not demonstrate the use of two pruning techniques called removal of subsumed variables and semantic branching  armando et al.  1  that are known to greatly improve the power of dtp solvers. luckily  these methods remain available when finding comsses of a dtp  and they are integrated into our musilitis solver. other common issues  such as variable and value ordering heuristics  also play a large role in guiding the search  although we do not discuss them here due to space limitations.
1 obtaining muses c 
every mus of c is an irreducible hitting set of comsses c . the decision version of the hitting-set problem  deciding if there exists a hitting set of cardinality less than or equal to k  is np-complete  karp  1   but in this case we are interested in irreducibility  not cardinality. combined with the property that no comss is a subset of any other  this allows us to extract a single mus via a greedy approach in polynomial time  without resorting to search. figure 1 provides pseudocode for the algorithm.
¡¡the construction works by sequentially adding constraints to a forming mus. intuitively  an mus is a set of constraints containing at least one constraint from every comss such that every constraint is an essential element of the set. by  essential  we mean that removing a constraint from the mus will leave at least one comss unrepresented. thus  every time a constraint is added  the remaining problem is modified to enforce the requirement that the constraint be essential. this is done by ensuring that the new constraint is the only representative of at least one comss.
¡¡lines 1 and 1 of musilitis-extractmus choose a comss from the set and a single constraint  newconstraint  from that comss. newconstraint is added to the mus  and the remaining lines ensure that it is essential. lines 1 through 1 remove the remaining constraints in the chosen comss from all other comsses in the input set. this prevents any of those constraints from being added in later iterations  which could make newconstraint non-essential. then  lines 1 remove any comsses containing newconstraint  because they are now represented in mus. following the modifications to comsses  the algorithm iterates. when comsses is empty  the constructed set of constraints is a complete  exact mus.
¡¡extracting all of the muses from comsses c  requires searching for all irreducible hitting sets of comsses c . due to the potential combinatorial explosion  the number of muses may be impractically large; however  in many cases the result is tractable.
¡¡one method for generating the complete set of muses from comsses c  uses the general form of the musilitisextractmus algorithm in figure 1. the particular mus generated by that algorithm depends on the order in which comsses and constraints are selected from comsses c ; thus  by branching on those two decisions  lines 1 and 1   all possible muses can be generated. this can be accomplished with a recursive function that takes as input a  the remaining set of comsses and b  the mus currently being constructed in each branch of the recursion  these are initialized to comsses c  and the empty set  respectively . the branching is not ideal  and duplicate branches are both possible and quite common in practice  so pruning heuristics can be employed to reduce the search space.
1 experimental results
we benchmarked both phases of the mus generation process  finding comsses c  and extracting muses c  from it  using dtps created by a random dtp generator used in testing previous dtp solvers  stergiou and koubarakis  1 . we collected performance data and analyzed the sets of comsses and muses for dtps over a range of dtp generator parameters.
¡¡the test case generator takes as arguments the parameters hk n m li  where k is the number of disjuncts per constraint  n is the number of time points  m is the number of constraints  and l is the constraint width  i.e.  a positive integer such that for each disjunct x   y ¡Ü b  b ¡Ê   l l  with uniform probability. in our experiments  we set k = 1  n ¡Ê {1 1}  and l = 1. a derived parameter r  the ratio of constraints over variables  m/n  was varied from 1 to 1. for each setting of n and r  1 random problems were generated.  for example  we generated 1 problems for the case where n is 1 and r is 1; those problems have 1 temporal variables and 1 constraints each . these problems are likely to be highly overconstrained  with 1 constraints on only 1 time points. the size of these problems is dwarfed somewhat by those which maxilitis can solve  e.g.  n = 1   although one must keep in mind that the objective of maximal constraint satisfaction is much easier to achieve. the domains of the variables are integers instead of reals  which again is standard in dtp literature. our implementation of musilitis was developed in java  finding comsses  and c++  extracting muses   and our experiments were conducted in linux on a 1ghz opteron processor with 1gb of ram.
¡¡first  we compared the runtime of the two versions of the musilitis-comss algorithm described in section 1-one which uses a single backtracking search to find all comsses  and another which does so incrementally. the former requires an additional postprocessing step to remove all redundant comsses  a procedure whose runtime was found to be

figure 1: median runtimes for finding comsses c 

figure 1: distribution of comss sizes  n = 1 
negligible. figure 1 shows the median runtimes for both algorithms on all problem parameters. not surprisingly  runtime increases both with size  n  and density  r . however  notice that the times for the single backtracking algorithm  labeled 'backtracking'  tend to be roughly an order of magnitude faster than those for the incremental method  labeled 'incremental' . this contrasts with the results reported in  moffitt and pollack  1   where the opposite effect was observed. the difference is that maxilitis can stop at any iteration where a solution is found  as only a single solution of maximal cardinality is needed. even though multiple searches are performed in the incremental mode  substantially more is pruned than in a single search that has no upper bound. in our case  iteration must continue until all comsses of any size have been found. the combined runtime of these separate searches can easily exceed that of a single backtracking search.
¡¡figure 1 shows the distribution of sizes of comsses found by the musilitis-comss algorithm for the cases where n = 1 and r ranges from 1 to 1. because our dtps were randomly generated  these results are not particularly useful alone; however  they do provide valuable information when one considers the runtime of the mus extraction phase of

figure 1: runtimes of extracting muses c  vs |muses c |
the musilitis algorithm  since the set of comsses is the input to this procedure. in the graph  we have taken the total frequency of each size of comss found in all instances and divided this count by 1  the number of problem instances . as one would expect  both the number and size of comsses increases with the constraint density r.
¡¡the runtime of extracting all muses depends mainly on the number of muses present. in the extremely overconstrained benchmarks used here  this number is often very high  reaching into the hundreds of thousands. figure 1 shows the runtime of the mus extraction algorithm versus the number of muses found for instances with n = 1. runtimes for any given number of muses are clustered within an order of magnitude of each other.
¡¡in some benchmarks  the mus extraction reached a 1minute timeout without finishing. in that time  however  it found as many as one million muses. the algorithm for extracting muses is inherently an anytime algorithm; muses are output as they are found  and if not all muses are required  it can be stopped at any time. our experiments showed that the algorithm has reasonably good anytime properties: in one typical highly-constrained instance with n = 1 and r = 1  it generated more than 1 muses in the first minute  and the rate then gradually slowed. this property could be exploited in a system that interleaves mus identification with constraint relaxation. generally  if the constraint system is highly overconstrained  resolving one mus is likely to resolve many others  since the same constraints are likely to appear in multiple muses.
1 conclusions and future work
we have presented algorithms for deriving minimally unsatisfiable subsets of constraints in any infeasible constraint set  building on a strong relationship between maximal satisfiability and minimal unsatisfiability. the techniques are general  in that they are applicable to any type of constraint  and we have implemented them for disjunctive temporal problems. the flexibility permitted by the constraints involved in these problems presents the opportunity for relaxation to be more fine-grained than simple constraint elimination  and muses provide the information needed to support this type of relaxation.
¡¡the connection between maximal satisfiability and minimal unsatisfiability we describe has been independently noted by  bailey and stuckey  1   who applied it to the problem of type-error diagnosis in software verification. their implementation  however  differs from ours  in that they employ different algorithms in an interleaved approach as compared to our serial  two-phase algorithm. in  liffiton and sakallah  1   we performed an experimental comparison of their approach  adapted to boolean satisfiability  with our own. we found that ours was consistently faster  and we identified several ways to combine ideas from both techniques for further improvements.
¡¡further work also includes enhancing the efficiency of our algorithms. one possible direction would be to investigate tradeoffs between runtime and completeness or correctness. the requirements of finding all muses or of finding exact muses could be relaxed to decrease the runtime of the algorithms. techniques exploiting domain knowledge or features of particular types of constraints could help improve the efficiency as well. more generally  it will be important to conduct studies that examine the performance of musilitis on dtps representing real-world problems  as opposed to the random problems studied in this paper. we currently have experiments underway to evaluate musilitis on job-shop scheduling problems  and we will also be studying problems taken from the domains of schedule management and medical protocols.
¡¡the relationship between maximal satisfiability and minimal unsatisfiability is deserving of further attention. our algorithms for extracting all muses are just one way of exploiting this relationship. further understanding of infeasibility in constraint satisfaction problems  such as rich links between conflicts in basic constraints and in the high-level problem they represent  could result from additional research.
¡¡finally  an important future goal is to employ the algorithms developed in this paper in a mixed-initiative constraint relaxation system that provides a user with the information needed to make principled decisions about how to weaken constraints so as to achieve feasibility.
acknowledgments
this material is based upon work supported by the national science foundation under itr grant no. 1  the defense advanced research projects agency  darpa  under contract no. nbchd1  and the air force office of scientific research under contract no. fa1-1. any opinions  findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of the national science foundation  nsf   darpa  the department of interior-national business center  or the united states air force.
