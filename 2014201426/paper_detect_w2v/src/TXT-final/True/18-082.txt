taking advantage of stable sets of variables 
in constraint satisfaction problems 
eugene c. freuder and michael j. quinn* 
department of computer science  university of new hampshire  durham  nh 1 
a b s t r a c t 
     binary constraint satisfaction problems involve finding values for variables subject to constraints between pairs of variables. algorithms that take advantage of the structure of constraint connections can be more efficient than simple backtrack search. some pairs of variables may have no direct constraint between them  even if they are linked indirectly through a chain of constraints involving other variables. a 
set of variables with no direct constraint between any pair of them forms a stable set in a constraint graph representation of a problem. we describe an algorithm designed to take advantage of stable sets of variables  and give experimental evidence that it can outperform not only simple backtracking  but also forward checking  one of the best variants of backtrack search. potential applications to parallel processing are noted. some light is shed on the question of how and when a constraint satisfaction problem can be advantageously divided 
into subproblems. 
	1 	direct i n d e p e n d e n c e of variables 
     constraint satisfaction problems involve finding values for variables subject to constraints  or relations among the variables. often      in this paper we propose taking advantage of the  relative independence'1 of variables to ameliorate the search complexity. we term two variables directly independent if there is no direct constraint  between them  even if they may be indirectly related by a chain of 
constraints passing through intermediate variables. 
     the basic insight is illustrated by the example in figure 1. the problem involves three variables  each with three possible values  and a constraint graph  figure la  lb  links in the graph represent con-
straints; nodes represent variables note that there is no direct constraint between variables y and z. if we approach the problem with a straightforward backtracking algorithm  we might have to examine almost 1 x  1 x 1  or 1 possible triples of values before hitting upon a solution in the rightmost branch of the search tree. more than 1 
tests on pairs of values would be performed  figure  c . 
     now let. us take into account the relat ive independence of variables y and z. having chosen a value for x  we can go ahead and choose a value for y and a value for z independently there will be at most 1 values to consider  1 for each  before we succeed or fail if we fail  we repeat the process for the next x value. at most we will perform 1x  1 + 1  or 1 tests on pairs of values  figure id . these constraints are restricted to being binary relations between two variables  we shall consider binary constraints here. standard backhack search can be used to solve such problems. in general the upper bound on the complexity of the search is exponential in the number of variables 
     
ii pseudo-tree search a l g o r i t h m 
     given a constraint graph partitioned into stable .sets  we would like to take advantage of direct independence not only on one maximal stable set  or an approximation thereof   but on all the stable sets. for example  we would like to use the stable sets identified in figure 1 as  levels  in a generalized backtrack algorithm that employed the basic  additive  insight of section 1 at each level. 
     this can be done  up to a point  in a straightforward way proceeding down through the levels  each variable at a given level can be considered independently. however  a problem arises in backtracking. if two variables at one level have a constraint path down to a single variable at a lower level  as in figure 1b   all combinations of values for the two higher level variables may need to be tried before finding one compatible with the lower level variable thus  we again have a  multiplicative  rather than an  additive  effect. 
     definition: a pseudo-tree is a rooted tree t  v. e  augmented with zero or more additional edges / '' such that all edges between some vertex v and vertices closer to the root be along the path in t from v to the root the level of a variable in a pseudo-tree is its level in the underlying rooted tree 
     a pseudo-tree structured constraint graph supports an algorithm that avoids the  multiplicative backtracking   problem cited above. it also makes it easy to determine what variables need to be modified during backtracking thirdly  the pseudo-tree property makes the constraint satisfaction problem more amenable to solution on a 
     multiprocessor  because a processor could try to assign values to a variable and all its descendenis without having to communicate with other processors freuder and quinn  1 
pseudo-tree search algorithm 

     the following lemma proves that the pseudo-tree search algorithm has a complexity bound exponential in the number of levels in the pseudo-tree  rather than in the number of variables in the problem in the next section we present an algorithm for transforming an arbitrary constraint satisfaction problem into an equivalent  metaproblem  with a pseudo-tree constraint graph structure. 
	e. freuder and m. quinn 	1 
     lemma: given a pseudo-tree t and a variables at level m in t  each variable capable of taking on b values  the search algorithm backtracks at most bk times to level rn before backtracking to level rn 1. 
     proof: the first time the search algorithm reaches level m  the value of every variable at that level is initialized as low as possible. the search algorithm backtracks from level rn - 1 in t when there exists at that level a variable v that cannot be given a value that does not violate constraints with the values of ancestor variables in t. by the pseudo-tree property  all of the variables constraining v lie along a simple path from v to the root of t. in order to try all combinations of values that might lead to an allowable value of v  only vaiiables along this path need to have their values changed hence every time the search backtracks to level rn  exactly one of the variables w at level m must have its value modified. the value of w cannot be decremented: all lowei values were previously held by w and led to a backtracking lower in the tree. because it is only necessary to reset the value of w when one of its ancestors has its value incremented  the value of no variable at level m will lowei until the search backtracks from level m. since there are k variables  each with b possible values  the maximum number of values variables at level m can take on before one variable has no more possible values is bk  
     theorem: given a pseudo-tree t with rn levels  each level / containing a:  variables capable of taking on b  values  the worst-case time complexity of our algorithm is 
     corollary; given a pseudo-tree t our algorithm can find one assignment of values to variables that satisfies the constraints  if one exists  but it cannot be used to find all solutions that satisfy the constraints. 
ill deriving pseudo-tree m e t a p r o b l ems 
     a constraint graph can be subdivided into subproblems  where each subproblem involves satisfying a subset of the original variables the problem of satisfying all the subproblems simultaneously may then be regarded as a metproblem  with the subproblems as metavariables 
     it has long been recognized that partitioning a constraint  satisfaction problem into subproblems may simplify the problem. however  little guidance is available as to how and when to subdivide problems. one criterion for considering a problem subdivision is the felicity of the structure of the resulting metaproblem. for example  if the metaproblem has a tree structured constraint graph on the metavariables  then it c an be solved in time linear in the number of metavariables ; mack worth and freuder  to appear here we present a method lor producing a metaproblem where the metavariables are organized into stable sets forming levels in a pseudo-tree constraint structure. recall that the previous section presented an algorithm for pseudotree-struct ured problems  with a complexity bound exponential in the number of pseudo-tree levels. 
the original problem is partitioned into a metaproblem as follows: 
1 find a cut set in the constraint graph; i.e.  a set of vertices whose removal divides the graph into two or more unconnected subgraphs. the cut set s corresponds to s variables in the metaproblem; these- metavariable*will form the first  s  levels of the pseudo-tree the unconnected subgraphs temporarily become metavariables and are children of the variable in s deepest in the  tree   
1 apply this process recursively to each of the children  terminating when the- subgraph being examined cannot be split further. 
     the algorithm will not necessarily produce an  optimal  pseudotree we would like to be certain of efficiently transforming a given constraint graph into a pseudo-tree structure which takes optimal  or nearly optimal  advantage of direct independence  this remains an area for f urt her work. 
	iv 	e x p e r i m e n t a l 	results 
     to experimentally verify the efficiency of this algorithm  we have used it to try to color graphs with three colors the performance of our algorithm is contrasted with two others. the first algorithm performs simple backtracking  where the order in which the variables are searched is randomly chosen. the second algorithm uses forward checking haralick and elliott. 1   which haralick and elliot showed to be superior to several other variants of backtracking under certain experimental conditions the order in which variables are considered corresponds to a level-by-level traversal of the pseudo-tree. 
     
1 	e. freuder and m. quinn 
¡¡¡¡the form of the test graphs is shown in figure 1. notice that we have created constraint graphs that have the pseudo-tree property  which avoids the previously-mentioned problem of efficiently transforming constraint graphs into pseudo-trees. we have tested the three algorithms on a large number of graphs. for each problem size ranging from 1 to 1 variables  we have generated 1 random pseudo-trees. we have run the three search algorithms on all 1 graphs  measuring the number of constraint checks made by each algorithm. each result has been put into one of two categories  depending upon whether the graph is three-colorable or not. this is because unsuccessful searches require many more constraint checks on average. figure 1 displays the mean number of constraint checks performed by the three algorithms for successful and unsuccessful searches of the various graphs. not only does our algorithm outperform standard backtracking  it also performs substantially fewer constraint checks than the forward checking algorithm on both colorable and uncolorable graphs.  we have also computed the median number of constraint checks performed by the three algorithms our algorithm outperforms standard backtracking and forward checking on unsuccessful searches and standard backtracking on successful searches. however  the median number of constraint checks performed by forward checking on successful searches is a few percent lower than the number performed by our algorithm.  
¡¡¡¡certainly our search algorithm will not outperform other algorithms  such as forward checking  in all situations. the constraints must fit a certain pattern in order to benefit from our exploitation of direct independence. for example  if our methodology were applied to the eight-queens problem  placing eight queens on a chess board so that no queen can attack another   the pseudo-tree would have eight levels  and the search algorithm would degenerate into standard backtracking. 
     in fact  much of the experimental work on backtrack search has been done in the context of the eight-queens problem. this is actually a very specialised type of problem: the constraint graph is complete  all constraints are the same  and all variables have the same domain. direct independence in a constraint graph is in a sense the opposite of completeness; it involves subsets of variables  which  far from forming complete subgraphs  form stable sets  where no variable is connected to any other. 
v conclusions 
¡¡¡¡we have presented an algorithm tailored to solve constraint satisfaction problems on constraint graphs that have the pseudo-tree property. we have also described an algorithm for turning any constraint graph into a constraint'graph with the pseudo-tree property experimental evidence indicates there exist constraint graphs for which our algorithm outperforms not only standard backtracking  but also forward checking. 
acknowledgments 
¡¡¡¡this paper is based in part upon work supported by the national science foundation under grant mcs 1. 
