 
in previous work  levesque proposed an extension to classical databases that would allow for a certain form of incomplete first-order knowledge. since this extension was sufficient to make full logical deduction undecidable  he also proposed an alternative reasoning scheme with desirable logical properties. he also claimed  without proof  that this reasoning could be implemented efficiently using database techniques such as projections and joins. in this paper  we substantiate this claim and show how to adapt a bottom-up database query evaluation algorithm for this purpose  thus obtaining a tractability result comparable to those that exist for databases. 
1 introduction 
as argued in  levesque  1   there is only one deductive technique efficient enough to be feasible on knowledge bases  kbs  of the size seemingly required for common-sense reasoning: the deduction underlying classical database query evaluation. and yet  databases by themselves are too restricted to serve as the representational scheme for commonsense reasoning  since they require  among other things  complete knowledge of the domain. levesque proposed a generalization of databases called proper knowledge bases  which allow for a limited form of incomplete knowledge. despite the limitations  however  the deduction problem for proper kbs is no longer even decidablc. levesque proposed an alternative reasoning procedure v for proper kbs that was logically sound and  when the query was in a certain normal form  logically complete. moreover  he argued that it should be possible to implement v for very large kbs using database techniques. however  no proof was given. 
　in this paper  we examine proper kbs and the v procedure more closely  and we prove a tractability result for this type of logical reasoning that are comparable to those that exist for classical database query evaluation. in particular  we adapt a bottom-up database retrieval algorithm to the case of proper kbs. thus  what we show here is that in some cases it is indeed possible to reason efficiently with incomplete knowledge in a logically sound and complete way  or at least as efficiently as we can with a database. 
　the rest of the paper is organized as follows. in the next section  we review proper kbs and v  prove a new property of v  i.e. locality  and define answers to open queries. in section 1  we review the complexity of database query evaluation  and present a polynomial time algorithm for evaluating k-guarded formulas. in section 1  we show how to use this algorithm to evaluate queries wrt proper kbs and hence obtain a tractability result. in section 1  we illustrate this query evaluation method for proper kbs with some example queries. finally in section 1  we describe some future work. 


automated reasoning 	1 

1 	automated reasoning 

1 	the complexity of database queries 
1 	an overview 
the complexity of query evaluation has been one of the main pursuits of database theory. traditionally  there are two complexity measures: combined complexity and data complexity  vardi  1 . combined complexity is measured in terms of the combined size of the database and the query. chandra and merlin  proved that the combined complexity of conjunctive queries  queries expressed by first-order formulas that are of the form  where a  are atoms  is np-complete; vardi l1  proved that the combined complexity of first-order queries is pspace-complete. however  the main factor responsible for this high complexity is the size of the query and not the size of the database. this is contrary to the situation in practice where we normally evaluate small queries against large databases. data complexity measures the complexity of query evaluation solely in terms of the size of the database and treats the size of the query as a constant. a folk result is that first-order queries can be evaluated in time no 1  where n is the size of the database and / is the size of the query. thus the data complexity of first-order queries is in pt1me. however  such a complexity can hardly qualify as tractable even if the exponent is small  say 1. 
　yannakakis  1 was the first to suggest that parameterized complexity  downey and fellows  1  might be an appropriate complexity measure for database query evaluation. query evaluation is fixed-parameter tractable if there is a computable function / : n -  n and a constant c such that the problem can be solved in time / /    nc  where / and n are the size of the query and the database  respectively. however  papadimitriou and yannakakis  proved that the parameterized complexity of conjunctive queries is w l -complete and thus most likely not fixed-parameter tractable. we refer the reader to  grohe  1  for a survey on parameterized complexity in database theory. 
　therefore database query evaluation in general is hard with respect to both combined and parameterized complexity. and yet  database queries do work quite well in practice  even for very large databases. a careful examination of the hardness results show that they often depend on queries that are somewhat atypical in applications  e.g. databases representing graphs and queries asking for the existence of cliques. 
automated reasoning 
　naturally  many research efforts have gone into finding classes of queries that can be proven tractable  even in the worst cases. the earliest result of this form  due to yannakakis   showed that acyclic conjunctive queries can be evaluated in polynomial time. this result has been extended in several ways. the first extension  due to chekuri and rajaraman   showed that conjunctive queries with bounded tree width are tractable. later  gottlob et al.  introduced the notion of hypertree width and showed that conjunctive queries with bounded hypertree width are tractable; bounded hypertree width generalizes the notions of acyclicity and bounded treewidth. recently  flum et al  generalized the notions of acyclicity and bounded treewidth from conjunctive queries to nonrecursive stratified datalog  nrsd   which is known to have the same expressive power as all of first-order logic  and showed that acyclic and bounded treewidth nrsd are tractable. inspired by their work  gottlob et al  extended the notion of hypertree width to nrsd  and obtained a nice logical characterization of hypertree width: they showed that the k-guarded fragment of first-order logic has the same expressive power as nrsd of hypertree width at most k. thus k-guardcd first-order logic turns out to be the largest tractable class of queries so far. 
1 	an evaluation algorithm 
　in this section  we introduce the k-guarded fragment of ♀  and explicitly present a polynomial algorithm for evaluating k-guarded formulas against databases and analyze its complexity. we will use this algorithm to evaluate k-guarded formulas with respect to proper kbs. 
note that any /c-guarded sentence is strictly k-guarded. 
　the evaluation algorithm below will take a strictly kguarded formula as the query. it turns out that any formula 
1 


1 	automated reasoning 


automated reasoning 	1 


1 	conclusions 
in this paper  we have shown how a bottom-up query evaluation procedure for databases can be used to answer queries for kbs with a certain form of incomplete knowledge. although this procedure can be impractical for k-guarded queries where a: is large  they would be impractical for databases too. 
a number of questions remain to be addressed. first of all  
lakemeyer and levesque  have proposed an extension to proper kbs that allow disjunctions in the kb. it would be interesting to see how much of the database retrieval mechanism could be preserved in this case. we can also imagine other extensions to proper kbs  such as relaxing the unique name assumption over constants  or allowing a limited use of function symbols. also  as suggested in the first section  we can imagine a dynamic scenario where at any given point what a robot or agent knows about the current situation is expressible as a proper kb. it would then be useful to amalgamate regression-based techniques for reasoning about change from  reiter  1  with the database techniques considered here. among other things  this would require determining those cases where the successor state axioms guarantee that a proper kb remains proper after an action has been performed  perhaps along the lines of  petrick and levesque  1 . it would also be interesting to investigate the relationship between proper kbs and other subsets of logic to see if the complexity results presented here can be further generalized. two immediate candidates are datalog programs and stratified logic programs that include some form of classical negation. finally  we note that additional optimizations can be made to our query evaluation procedure that do not change the worst-case performance  but would improve its behaviour in practice. 
acknowledgments 
we would like to thank leonid libkin for pointing us to the relevant database literature. financial support was gratefully received from the natural sciences and engineering research council of canada. 
