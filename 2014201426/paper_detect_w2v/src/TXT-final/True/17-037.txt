 
　a new class of maintenance tool is presented  designed specifically for enhancement of knowledge representation systems. these tools are based on the structure of a domain model and the ways it can be changed. a complete language for changing domain models is presented. associated with each change is an explicit assumption in the previous model that is violated. a complete analysis is presented of how existing knowledge representation frames and the associated operations on those frames must be updated to correct these assumption violations introduced by changing the domain model. 
　such tools are an important first step towards support for an incremental development process. almost no support currently exists for enhancing knowledge representation systems. the tools described here support enhancements involving modification to the domain model. support for the remaining enhancements will require both more knowledgeable tools which understand the system they are manipulating  and more declarative structural specifications for such systems which facilitate that understanding. 
introduction 
　it is by now well known that maintenance is the dominant life-cycle cost for conventional software systems  often consuming 1% of the total effort. yet this life-cycle phase has received remarkably little attention or support. the few tools that exist  such as debuggers  modification audit trails  configuration managers and regression testers  have been available for a long ume and are quite stable. there is scant evidence of further progress. 
in fact  the major thrust of the last several years in the software 
engineering community has been towards reducing the need for maintenance  rather than facilitating it. this thrust has centered on reducing  or eventually eliminating  implementation bugs through improved development methods  either informal or formal and either manual or automated . this thrust has begun to bear fruit. improvements have been made in reducing the number of implementation errors. they may even be eliminated entirely via formalization and automation of the development process. 
　but this thrust begs the maintenance problem because it only addresses one maintenance activity  the correction of implemenution bugs. this activity decays rapidly after a system is fielded  and the thrust merely lowers the initial level of that activity. 
　enhancement  rather than correction of implementation bugs  is the dominant maintenance activity. it grows rather than decays over time. 
   this research is supported by the defense advanced research project agency under contract no mda1 c 1 views and conclusions contained in this report are the authors and should not be interpreted as representing the official opinion or policy of 
darpa. the us government  or am person or agency connected with them it is the source of the multi-year maintenance backlog experienced by most dp organizations. it will become even more dominant as the development improvement thrust partly reduces the need to correct implemenution bugs  and as the current trend towards release of systems in incremental stages  with enhanced functionality  accelerates. 
　there are two reasons for such enhancements. the first is that noone has enough insight to build a system correctly the first ume  even assuming no implementation bugs . the second is that the mere existence of the system  and the insight gained from its usage  create a demand for new or altered facilities. 
　rather than attempting to eliminate the need for maintenance we should recognize that enhancement  not initial development  is the central software activity  and the basis for achieving the  softness  promised in software . 
　this dominance of enhancement is even greater for knowledge based systems because they are developed via cut-and-try explority programming techniques. our software life-cycle and support environments should be rethought accordingly. 
　we have elsewhere presented our knowledge based version of such a paradigm and support environment  balzer et al 1a . this paper addresses the enhancement activity directly. it defines two types of enhancements  structural and functional  and focuses on the former. it categorizes the class of possible structural enhancements  defines a 
　complete language for specifying such enhancements  and describes an implemented set of tools for effecting these structured enhancements. it also presents an analysis of the changes to existing knowledge representauon frames and the operations on them necessitated by these structural enhancements. 
　the basis for all these capabilities is an explicit  modifiable domain model which defines the class of valid frames. the structure of this model determines the class of assumptions that can be explicitly represented. change to such an assumption should cause propagation of effects to all places in the frames and the operations on them where that assumption was relied upon. our leverage arises from the fact that the domain model forces these assumptions to be explicitly stated  and to be stated in such a way that reliance can be mechanically determined. this provides the basis for a new class of maintenance tools which support the propagation of effects into the frames and operations associated with a domain model. 
the structure of a domain model 
　we therefore begin by examining the structure of a domain model. we have a fairly conventional frame-based object model  minsky 
　
1 	r. balzer 
1  roberts 1  bobrow 1  in which the data is self-describing  i.e.  its type s  can be determined   all instances of a type can be obtained  attribute declarations are inherited along subtype links  the range of an attribute is type limited  and an attribute can be either required or optional and either single or multi-valued. our knowledge representation language is quite a bit more elaborate  balzer et al 1  but only these aspects are relevant to maintenance. 
structural enhancement 
　the set of all possible enhancements can be divided into two categones - those that change the domain model and those that do not. we call the former structural enhancements  and the latter functional enhancements. the types of structural enhancement possible are determined by the structure of the domain model. this leads fairly directly to a complete language for stating such modifications. more importantly  the explicit declarative nature of the model makes it clear what assumption is being violated by each structural enhancement. this knowledge can then be used to identify all the sites in the frames and operations which relied upon the assumption. the complete edmng language and the ability to identify all sites within the frames and operations that must be updated provides the basis for the new class of maintenance tools presented here  and the rauonale for focusing exclusively on structural enhancement. 
　there are two basic types of structural enhancement: changing the attribute structure and changing the type structure. the domain and range of an attribute can be generalized  picking a supertype of the current type   specialized  picking a subtype of the current type   or changed incompatibly  picking a type which is neither a supertype nor a subtype of the current type . the cardinality restriction can be changed from one value in the enumerated range - unique  optional  multiple  any} to another. 
　changes to the type structure involve changing the membership of some enumerated set. the kinds of changes possible are simply adding an item to or deleting an item from the enumerated set  refining an existing item into several new ones  or combining existing items into a new abstraction. these changes are handled analogously whether the  enumerated set  is the set of instances of a type  the subtypes of a type  or the attributes defined on a type. 
an example structural enhancement 
　in order to illustrate the utility of structural enhancements and the modifications involved to effect such changes  we have selected a single actual example which we will use throughout this paper. this example was completely effected by the tools described here with the exception of propagation into the operations which are not yet implemented. here we will describe the original domain model  the change we wish to make  and the modifications to the model required to effect that change. later sections will return to this example to describe the propagation of these effects into the existing frames and operations. 
　the example we've chosen arose in our work on developing an automated environment for software development  balzer et al 1b . as part of that effort we needed to represent the objects in the programming domain. a piece of this domain model is shown graphically in the top portion of figure 1. circles  or ovals  are used to represent types. the subtypes of a type are placed below it and connected to it by unlabeled links. boxes are used to indicate attributes associated with the type. we have suppressed showing the range and count specification of the attribute to avoid cluttering the diagram. 
this diagram indicates that the type program-object has 
function  variable. record  etc.. as subtypes  and component. source-text  and maintainer  as attributes. 
this type was being used to represent the individual program objects such as functions  variables  records  etc.  which had a source-text that defined them  as well as the hierarchical module structure. modules had components which were either other modules or individual program objects. the program-object type was clearly being overloaded  representing semantically different objects based on whether they had components or a source-text. we decided to make this distinction explicit  as shown in the bottom diagram of figure 1  b  refining the program-object type into individualprog ram-object  and module subtypes which respectively had source-text and component attributes. furthermore  the existing subtypes of prog ram-object should now become subtypes of individual-program-object. 
all of these changes are accomplished by a single use of the 
refine-type tool. the programmer indicates what type is to be refined  program-object   what new types  individualprogram-object and module  are to be created as subtypes of it. which attributes of the refined type are to be specialized to these new subtype  source-text to individual-program-object and component to module   and which existing subtypes should become subtypes of the new subtypes  function  variable  record  etc.. all become subtypes of individual-programobject . the refine-type tool invokes other tools to accomplish these modifications to the domain model. for instance  after the new subtypes have been created  attributes are moved to them from the supertype via the specialize-attribute-domain tool. 
one change remains. we wish to make the two moved attributes 
required instead of optional. this requires two invocations of the change-cardinality-restriction tool. 

　the effects of these changes to the domain model on the existing frames and operations will be described in the section dealing with those topics. 
propagating structural enhancements into existing frames 
　having a complete language for stating structural enhancements  and editing tools for making the necessary modifications to the domain model is a nice start. but it is only a beginning towards the goal of maintaining a system through such structural enhancements. having altered the domain model  the effects of those changes must be propagated through both the operations that use the model and the frames already created by  or for  those operations. 
　this propagation of effects is possible because the explicit declarative nature of the domain model forces the structural assumptions to be explicit. this enables us to identify which ones are violated by the enhancement. the structural nature of these assumptions allows us to detect all sites within the frames and operations which rely upon each assumption. this ability to identify the  usage  sites is the basis for the new maintenance tools presented below. this section focuses on propagating the effects of a structural enhancement into existing frames: the next section addresses propagation into operations. these 
propagation effects are summarized in figure 1. 
cardinality restriction modification 
　when the cardinality restriction of an attribute is changed  only two assumptions can be violated. the first is the assumption that the attribute is required. if an optional attribute becomes required then 
	r. balzer 	1 
instances without the attribute must have it added. if a required attribute becomes optional  then the existing frames are still valid  but the programmer may wish to remove some instances of the attribute. the second assumption that a cardinality restriction change can violate is that an attribute is single-valued. if a multi-valued attribute becomes single-valued  then instances with more than one value must be paired down to a single value. if a single-valued attribute becomes muluvalued  then the existing frames are valid but the programmer may wish to augment existing instances. 
attribute range modification 
　when the range of an attribute is changed  then only the assumption about the type of the value of that attribute is affected. if the range is generalized  then the existing data is valid  but the programmer may wish to generalize the value of some existing instances. if the range is specialized  then some instances  those whose attribute value is outside the specialization  are invalid and their attribute value must be replaced  if the attribute is not required  it can be deleted rather than replaced . if the range is changed incompatibly  then all existing instances are invalid and their attribute value must be replaced  or alternatively  deleted if the the attribute is optional . 
attribute domain modification 
　when the domain of an attribute is changed  then only the assumption of which type of object has this attribute is affected. if the domain is generalized  then the attribute is applicable to more instances. if it is required  then it must be added to the newly applicable instances. if it is optional  then the existing frames are valid  but the programmer may wish to add it to the newly applicable 
　

figure 1 
　
1 	r. balzer 
instances. if the domain is specialized  then some instances  those which are not instances of the specialization  must have the attribute removed. 
　the case of an incompatible change in the domain of an attribute is most interesting. it could simply be handled as the deletion of the attribute from the original domain and the addition of it to the new domain. this would destroy the attribute value from instances of the original domain and require the programmer to specify a value  or values  for instances of the new domain. however  we feel that the intent of such a change is almost always to move the existing attribute values from instances of the original domain to  corresponding  instances of the new domain. this correspondence is defined by a path through the knowledge base which maps an instance of the original domain mto an instance  or possibly several  of the new domain. the attribute values are moved as defined by this mapping. this path can either be specified by the programmer or heuristically determined  via the shortest path of required single-valued attributes . 
set membership modification 
　when the membership of a set changes  then only the assumption of the set of alternative values  the pigeon-hole principle  is affected. if an item is added to the set  then the existing frames are valid  attributes are added with optional as the cardinality restriction   but the programmer may wish to use the new item in place of. or in addition to  existing items. if an item is deleted  then use of that deleted item must be removed or replaced. if an item is refined  then the existing frames are valid  but the programmer may wish to substitute one of the refinements for use of the refined item  i.e.  be more specific . if items are combined to form a new abstraction  then the existing frames are valid  but the programmer may wish to substitute the new item for some uses of the combined items  i.e.  be more abstract . 
example frames propagation 
continuing with the example structural enhancement shown in 
figure 	1 	which 	refined 	the 	type 	program-object 	into 
individual-program-object and module  and specialized some of its attributes  we consider here the effect of these changes on the existing frames. first  the existing frames remain valid when a type is refined  but the programmer may wish to reclassify some instances of the refined types as instances of one of the refinements. in this example  we wish to partition the existing instances among the two subtypes  those that have a source-text are to become individual-program-objects and those that have 
components are to become modules . the refine-type tool allows such predicates to be specified and performs the indicated reclassifications. 
　second  the specialization of the domain of the two attributes may necessitate removal of this attribute from instances outside the specialized domain. in this example  since the existence of the attribute determined the reclassification  there are no such instances to update. however  the tool is unable to infer this result instead  it dutifully checks for any such instances. 
　finally  the changing of the cardinality restriction of these attributes from optional to required causes the system to check for instances that need  but do not already have  the attribute. again  this search is fruitless because the reclassification was based on the prior existence of the attributes. all of these changes to the existing frames  as well was the searches for frames requiring and/or desiring change  were performed by the frame propagation portion of the enhancement tools. 
propagating structural enhancements into operations 
　the previous section identified the assumptions that were violated by each type of structural enhancement and described how dependencies upon those assumptions could be detected and corrected in existing frames. the analysis of the deduction of on those same assumptions and their correction in existing operations is very similar. however  since this portion of the analysis has not yet been implemented  only a summary of the analysis  as shown in figure 1  is presented here. the nature of these corrections is typically to change the conditionally of the code which uses a changed portion of the domain model so that it agrees with the conditionality defined by the model. 
　the summary in figure 1 distinguishes three types of usage of an attribute: consumer  producer  and creator. consumer uses are all accesses to the value of an attribute; producer uses are all places which set  or remove  the value of the attribute  and  creator uses are the subset of producer uses which set the value of the attribute while creating an instance of the attribute's domain. 
example operation propagation 
　returning once again to the structural enhancement example shown in figure 1 which refined the type program-object mto individual-program-object and module  and specialed some of its attributes  we now consider what effects these changes have on the existing operauons. 
　first  when a type is refined  the existing operations remain  alid but the programmer may wish to replace some uses of the refined item by one of its refinements. in this case  basically all uses of programobject were replaced by uses of one of the refinements. in those places where it was not known which refinement was present  a typecase statement was inserted to make the selection. 
　second  the specialization of the domain of the two attributes causes both the the producer and consumer uses to be conditionalized. for this example  this conditionalization  after simplification  is a no-op because all uses already occur inside of the proper subtype determinauon  i.e. the necessary conditionality already exists . this results from the fact that in this example the attribute occurrence corresponds exactly to the subtype definition. 
　finally  the changing of the cardinality restriction of these attributes from optional to required causes the consumer uses  which remain valid  to be checked for unneeded conditional guards  and creates uses to include this attribute. 
　unfortunately  since none of the tools for propagating effects into operations is yet implemented  all of these checks and modifications were performed manually. 
current status 
　our goal in undertaking this effort was to obtain assistance in enhancing systems. our investigation of enhancement led to the complete categorization of structural enhancement of  a subset of  our domain modeling language and the analysis of the propagation effects of such enhancements on both frames and operauons reported here. they  in turn  form the basis for a new class of tools for performing such enhancements. implementation of these tools is well underway and consists of three phases. the first consists of tools for modifying the domain model as defined by the complete categorization presented earlier. these tools are implemented and are being used to provide structural enhancements to domain models. 
　the second phase consists of tools for propagating the effects of structural enhancements into existing frames. these tools are being implemented as they are needed. one of these tools  refining an item  has been used extensively  including the example provided in this paper  to apportion the existing instances of a refined type among its subtypes. since many such instances may need to be reapportioned  the tool uses a programmer-supplied predicate for apportionment rather than interactively querying the programmer. the built-in facility for our system to access all instances of a type  goldman 1  makes creating such tools straightforward. we anucipate no problems with the remaining tools in this phase. 
　the final phase consists of the tools for propagating the effects of structured enhancements into operations. implementation is awaiting completion of both a static analyzer capable of detecting consumer  producer and creator uses of the types  attributes  and enumerated ranges from which our domain model is composed  and a type checker capable of determining the type of each value being produced and/or consumed by the operations. once the static analyzer and type checker are available  we anucipate moderate difficulty in implementing these tools because of the syntactic and semantic variability allowed and because no-one has yet designed a suitable transformation system  as opposed to a set of ad hoc procedural manipulations  for making these kinds of modifications to operations. we believe that an important precursor to such a facility is a categorization of the types of program modification to be made  rules of composition  and rules for simplification. such a foundation always appears to be necessary for 
formal manipulation of programs. 
conclusion 
　this paper addresses the dominant maintenance activity  enhancement. it focuses on those enhancements  called structural  that change the domain model. it shows how the domain model structures the validity assumptions of the domain and forces them to be explicitly stated. the structure of the model determines the type of changes that are possible to the model. these changes have been categorized into a complete language for specifying structural enhancements. only four types of modification are possible: changing the domain  range  or cardinality restriction of an attribute  or modifying the set of items in an enumerated set  such enumerated sets include the type hierarchy  the set of attributes associated with a type  and explicitly enumerated ranges . 
　associated with each of these changes is a single validity assumption affected by the change  in the case of a cardinality restriction change there are two . the fact that reliance on these assumptions can be detected in both frames and operations provides the basis for automated tools that propagate the effects of a structural enhancement into both the frames and operations associated with the enhanced domain model. a complete analysis of these propagation effects was presented for each of the four types of structural enhancement. generally the propagation effects on the frames directly mirror the structural changes to the model  while those on the operauons are evidenced in the addition or removal of conditional guards on the producer and consumer uses of the modified structure. 
　one particularly interesting structural enhancement is an incompatible change to the domain of an attribute  as opposed to a generalization or specialization of the domain . such a change is treated as a form of indirection and a mapping is used in both the frames and operauons to locate the corresponding object specified by the indirection. this mapping can either be specified as pan of the enhancement  or heuristically determined. 
	r. balzer 	1 
　automated tools for the complete set of domain model modifications and for the propagation of effects of some of these modifications into the existing frames have been built and are being used. 
　such tools are an important first step towards support for an incremental development process  balzer et al 1a  for both conventional and knowledge based software. 
the tools described in this paper support structural enhancements. 
the remaining  functional  enhancements will be more difficult to support because they involve changing the procedural component  the operations  rather than the declarative and highly structured domain model it is our belief that such tools must understand the functional aspects of the system they are manipulating  and that this will require a more declarative structural specification for these systems. 
