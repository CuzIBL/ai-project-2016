 
many planning domains require a richer notion of time in which actions can overlap and have different durations. the key to fast performance in classical planners  e.g.  graphplan  ipp  and blackbox  has been the use of a disjunctive representation with powerful mutual exclusion reasoning. this paper presents tgp  a new algorithm for temporal planning. tgp operates by incrementally expanding a compact planning graph representation that handles actions of differing duration. the key to tgp performance is tight mutual exclusion reasoning which is based on an expressive language for bounding mutexes and includes mutexes between actions and propositions. our experiments demonstrate that mutual exclusion reasoning remains valuable in a rich temporal setting. 
1 	introduction 
for many real world planning domains  the classical 
strips model of action is inadequate - actions can be simultaneous  can have different durations  and can require metric resources. these characteristics are particularly prevelant in many nasa planning applications. for example  both spacecraft  such as ds1  and planetary rovers  such as sojourner  use heaters to warm up various components  and these warming actions may span several other actions or experiments. likewise  data compression and telemetry may overlap with other actions  and these actions may have wildly different durations  from milliseconds to hours . 
　while previous work on temporal planning has yielded some success  vere  1; pelavin &. allen  1; penberthy & weld  1; muscettola  1   past systems 
   *we thank corin anderon  keith golden  zack ives  ari k. jonsson  rao kambhampati  pandu nayak and the anonymous reviewers for helpful comments and discussion. this research was funded in part by office of naval research grant n1-1  and by national science foundation grants iri-1 and iis-1. 
1 	challenge papers 
either scaled poorly or required humans to set up elaborate temporal constraint networks and specify guidance heuristics. the use of reachability analysis and mutual exclusion reasoning in graphplan  blum & furst  1  and descendants such as ipp  koehler et a/.  1  has yielded spectacular speedup in classical planning  so it is natural to wonder if similar reasoning is extensible to the problem of temporal planning. this paper demonstrates that this extension is indeed possible in the generalized graphplan context. in particular  we: 
  generalize the planning graph representation to deal with arbitrary time instead of graph levels. to accomplish this  we change to a much more compact cyclic graph  where actions and propositions appear only once in the graph annotated by their earliest possible start times. 
  extend mutual exclusion reasoning to work for ac-tions that can have different durations and can overlap in arbitrary ways. this requires 1  a more general notion of conditional mutex involving time bounds  and 1  mutex relationships between actions and propositions. 
  describe the temporal graphplan  tgp  algorithm  which operates incrementally on the generalized 
planning graph introduced above  and employs extended mutual exclusion reasoning on that graph. 
  present empirical evidence that 1  these generaliza-tions do not significantly degrade performance  and 1  mutual exclusion remains valuable  and perhaps vital  in a richer temporal setting. 
1 	graphplan review 
we briefly summarize the graphplan algorithm  blum & furst  1   because it forms the basis for tgp. graphplan solves strips planning problems in a deterministic  fully specified world. both the preconditions and effects of its action schemata are conjunctions of literals  i.e.  denoting the add and delete lists . graphplan alternates between two phases: graph expansion and solution extraction. the graph expansion phase extends a planning graph until it has achieved a necessary  but in-

sufficient  condition for plan existence. the solution extraction phase then performs a backward-chaining search for an actual solution; if no solution is found  the cycle repeats. 
　the planning graph contains alternating levels of proposition nodes  corresponding to ground literals  and action nodes. the zeroth level consists solely of the 
propositions that are true in the initial state of the planning problem. nodes in an action level correspond to action instances; there is one such node for each action instance whose preconditions are present  and are mutually consistent  at the previous proposition level. directed edges connect proposition nodes to subsequent action nodes whose preconditions reference those propositions. similarly  directed edges connect action nodes to subsequent propositions made true by the action's effects. persistence actions function like frame axioms: each proposition at a level is linked to its persistence action at the next level  and the action connects to the same proposition at the next level. graphplan defines a binary mutual exclusion relation  umutex   between nodes in the same level. for example  two action instances are mutex if one action deletes a precondition or effect of another or the actions have preconditions that are mutually exclusive at the previous level. two propositions are mutex if all ways of achieving the propositions  i.e.  actions at the previous level  are pairwise mutex. 
　suppose that graphplan has extended the planning graph to a level in which all goal propositions are present and none are pairwise mutex. graphplan now searches for a solution plan by considering each goal conjunct in turn. for each such proposition  graphplan chooses  backtrack point  an action a at the previous level that achieves the goal. if a is consistent  nonmutex  with all actions that have been chosen so far at this level  then graphplan proceeds to the next goal  otherwise if no such choice is available graphplan backtracks. after graphplan has found a consistent set of actions it recursively tries to find a plan for the actions' preconditions at the previous proposition level. the base case for the recursion is level zero if the propositions are present in the initial conditions  then graphplan has found a solution. otherwise  if backtracking fails  then graphplan extends the planning graph with an additional action and proposition level and tries again. 
1 	the temporal planning graph 
when talking about temporal actions  it is important to specify a clear semantics. tgp adopts a simple extension of the strips action language that allows each action to have a nonnegative start time  s  and a positive  realvalued duration  d. we adopt a conservative model of action in which: 1  all preconditions must hold at the start  .$  of the action  1  preconditions not affected by the action itself must hold throughout execution   s  s + d   and 1  effects are undefined during execution and only guaranteed to hold at the final time point s + d. this means that two actions cannot overlap in any way if an effect or precondition of one is the negation of an effect or precondition of the other. 
　one can achieve a more flexible representation of the planning graph  and at the same time avoid duplicated work during plan expansion  by exploiting the following observations: 
  propositions and actions are rnonotonically increas-ing: if proposition p  or action a  is present at one level it will appear at all subsequent proposition  action  levels. 
  mutexes are rnonotonically decreasing: if mutex m between propositions p and q is present at one level then m is present at all previous proposition levels in which both p and q appear. mutexes between action instances behave similarly. 
  nogoods are rnonotonically decreasing: if subgoals p  q  and r are unachievable at a level then they are unachievable at all previous proposition levels. 
　these observations show that one can dispense with a multi-level planning graph altogether. instead  all one needs is a graph with action and proposition nodes. arcs from propositions to actions denote the precondition relation and arcs from actions to propositions encode effects. action  proposition  mutex  and nogood structures are all annotated with a numeric label field; for proposition and action nodes this number denotes the first planning graph level at which the proposition  or action  appears. for mutex or nogood nodes  the label marks the last level at which the relation holds. 
　note that storing a single node in the graph per action does not limit the planner to a single instance of the action in a plan. solution extraction will search through the graph  adding action instances into the plan. since this backward-chaining search may traverse cycles  multiple instances of an action may be added into a plan. indeed  this compact encoding scheme has three advantages: 
1. the space costs of the expansion phase are vastly decreased  because information is not duplicated between levels. 
1. the speed of the expansion phase is increased  because it is possible to update the graph in an incremental fashion. we elaborate on this point in section 1. 
1. most important  when using this representation  there is no longer any need to have actions take unit time. instead  labels can be real numbers denoting start times instead of integers marking a planninggraph level. while this idea is conceptually simple  it hides a surprising number of subtleties  which we elaborate upon in subsequent sections. 
as an example  consider the simple domain shown in 
figure 1. actions a and b have no preconditions  and produce p and q respectively. since action c requires both p and q  it can't start executing until time 1 and so the earliest r can be produced is time 1. 
	smith and weld 	1 


	a.  action definitions 	b.  planning graph 
figure 1: the planning graph for a simple domain of three actions. arcs encode precondition and effect relations. node subscripts  which start with an open bracket  indicate the earliest time that the action  or proposition  can be executed  or achieved . 

	a.  action definitions 	b.  planning graph 
figure 1: a simple domain that illustrates the need for action/proposition mutexes. bold lines denote mutexes  regardless of type . labels on mutexes denote the conditions when the mutex holds. the oo signifies that x and -x  are eternally mutex. a is cmutex with q when a and b is cmutex with q when 1  where a =  a    q and 1 =  b    p. 
1 	generalized mutex reasoning 
this section generalizes the graphplan mutex rules in two ways: 1  by introducing action /proposition mutexes  in addition to the original mutexes between pairs of actions or between pairs of propositions   and 1  by distinguishing between mutex relations that are eternally present and those that are conditional and may expire as the graph is expanded further in time. we motivate these enhancements with the example of figure 1. because actions a and b produce x and -x respectively  they can never be executed at the same time.  we formalize this notion below as an eternal mutex  and depict it as a mutex with oo label in the planning graph.  the only way to achieve both p and q is to execute a and b in series  the order doesn't matter   so the mutex between p and q should end at time 1. but standard graphplan mutex propagation is insufficient for deducing this fact. 
　the problem stems from the fact that actions have differing durations. while the original graphplan approach works when proposition and action levels alternate in a regular fashion  actions with varying durations break this symmetry. for example  even if p is made true early and persists to time 1  the action making q true may span backwards far enough to overlap the source of p  and  indeed  if b overlaps a there is a conflict. 
　we repair this reasoning limitation by introducing the notion of an action/proposition mutex. note that in the 
1 	challenge papers 
previous example  it is impossible to have proposition p true and have an instance of action b under execution at time 1 if b started execution before p became true. intuitively  action/proposition mutexes help deduce more inconsistencies because they better connect action/action mutexes to proposition/proposition mutexes in cases where action executions overlap. we now make these notions precise. 
　we partition all mutex relations  action/action  proposition/proposition  and action/proposition  into eternal and conditional types for efficiency purposes. intuitively  an eternal mutex unconditionally persists for all time  while a conditional mutex might not always hold. formally  we say that 
　def 1. propositions p and q are eternally mutex  emutex  iff p is the negation of q  
　def 1. action a is emutex with proposition p if - p is a precondition or effect of a  or if p is an effect of a. 
　def 1. action a is emutex with action b iff at least one of the following holds: 1  a or b deletes the preconditions or effects of the other  or 1  a and b have emutex preconditions. 
　in contrast to emutex  a conditional mutex may be transitory  applying early on but expiring later due to additional support for a proposition. typically  the conditions governing when a emutex applies are inequalities referring to: 
  the duration of an action  which we write:  a  
  the time when an action  or proposition  first ap-pears in the planning graph:  a 
  the earliest possible end time of an action: a  
  t h e time when an action instance starts executing    or a proposition actually becomes true:   the completion time of an action instance: 
	note that 	  and 
that . we now state three definitions  pertaining to proposition/proposition  action/proposition  and action/action pairs. 
　loosely speaking  propositions p and q are emutex when p is emutex with all of the actions supporting q and also vice versa. the inqualities in the formalism below ensure that an action is counted as support only when it ends before the proposition starts. 
　def 1. let p and q be two propositions. for each ai supporting p let  be the condition under which ai is mutex with q  true if eternally mutex  false if no mutex  
and  is emutex with q when . for each 
supporting q let be the condition under which is mutex with p. 
let  is satisfiable  then propositions p and q are conditionally mutex  emutex  when 
　intuitively action a is emutex with proposition p when p is emutex with any precondition of a or when a is emutex with all of the actions supporting p. 

　def 1. let a be an action and p be a proposition. for each precondition qi of a  let  be the condition under which p is mutex with qi  true if emutex  . . .   . for each action bj possibly supporting p  let  be the condition under which a is mutex with bj. 
let 
if 
　loosely speaking  actions a and b are emutex when a is emutex with any precondition of b or vice versa. 
　　def 1. let a and b be two actions which are not emutex. for each precondition pi of b  let  be the condition under which a is mutex with p . for each precondition  of a  let be the condition under which 
b is mutex with qj. 	let 	= 	. if   is 
satisfiable  then actions a and b are emutex when 
　to see how these rules work  consider the example of figure 1. def 1 shows that x is emutex with ~ x. 
def 1 further concludes that a is emutex with q when also that b is emutex with p when 
1. intuitively  this makes sense - 
if a starts before 1  then it must overlap support for q  i.e.  action b   but a and b are emutex. finally  def 
1 shows that propositions p and q are emutex when 
. 	adding the action durations to 
both sides of each inequality yields the following 
condition: 	i. thus we conclude that 
  and this 
simple  symmetric condition is equivalent to a standard graphplan proposition mutex that expires at time 1. 
　in bigger examples  the situation gets more complicated and asymmetric. being able to quickly manipulate and simplify the emutex conditions is a necessary ability for doing mutex reasoning with actions of varying duration. in section 1  we describe a canonical form for these asymmetric conditions and explain how to quickly manipulate the conditions. in section 1  we present empirical evidence that mutex reasoning  while complex  yields important speedup. 
1 	incremental graph expansion 
using the compact representation described above it is possible to update the planning graph in an incremental fashion. more precisely  the planner can keep track of what has changed in the graph  and only examine those propositions  actions and mutex relationships that can be affected by the changes. in particular: 
  adding a proposition node to the graph  e.g.  as the novel effect of a newly added action  can result in new actions  i.e.  those with the proposition as precondition  being added. 
  adding an action to the graph can cause new propo-sitions  the action's effects  to be added  and/or can provide additional support for existing propositions. this new support can cause an action/proposition emutex to terminate  by def 1 . 

figure 1: the tgp algorithm uses this causation diagram to guide its processing of events. dark lines denote effects that occur later in time  i.e.  after an action execution . 
  terminating a emutex between propositions p and q can result in new actions  e.g.  actions with both 
p and q as preconditions . in addition  it can cause an action/proposition emutex to end  by def 1   e.g.  between p and a consumer  c  of q. 
  terminating a emutex between action a and proposition p can cause a proposition/proposition emutex to terminate  by def 1   e.g.  between p and an effect  r  of a. in addition  it can cause an action/action emutex to terminate  by def 1   e.g.  between a and a consumer  c  of p. 
  terminating a emutex between actions a and b can cause an action/proposition emutex to end  by def 1   e.g.  between a and an effect  r  of p. 
　these relationships are illustrated in the causation diagram of figure 1. this diagram shows the structure of an incremental approach to graph expansion which provides speed gains proportional to the space reductions afforded by the compact representation. 
　although the detailed bookkeeping is surprisingly complex  the basic tgp expansion algorithm is straightforward. starting at time 1  it moves incrementally forward in time  progressively taking care of new propositions  new actions  new support for existing propositions and terminated mutexes. persistence actions are not added explicitly. tgp keeps two main time-ordered priority queues  newsupp and endppmutex. newsupp contains triples  a p t  meaning proposition p has new support from action a at time t  and endppmutex contains pairs  m t  meaning that m is a proposition/proposition emutex that ended at time t. for efficiency  tgp also keeps a temporary list: newprops is the subset of propositions mentioned in newsupp that are new  i.e.  have no prior support . 
　given a temporal planning problem  i.e.  a set of initial conditions  list of conjunctive goals  and set of ground actions   tgp graph expansion follows a loop with the following steps: 
1. add new actions and their effects to the graph. note: tgp need only consider actions with a precondition in newprops  or with two preconditions whose emutex is in endppmutex.  at time zero  the initial conditions are added by a special instance of this step . 
1. add eternal and conditional mutex relationships for new actions; this includes both action/proposition and action /action mutexes. 
	smith and weld 	1 

1. increment time to the next interesting entry in the rewsupp or endppmutex queues. 
1. recheck propositions with new support  possibly terminating  i.e.  tightening the bound on  action/proposition  action/action  and proposition/proposition cmutexes via a recursive algorithm that traverses the causation diagram. 
1. add action/proposition and proposition/proposition mutexes  both eternal and conditional  that involve new propositions. 
1. if all goals are present in the graph  pair wise nonmutex  then call solution extraction. otherwise  and if solution extraction fails  loop. 
1 	solution extraction 
once the planning graph has been extended to a time  to  when all goals are present and are pairwise nonmutex  tgp performs a backward chaining search for a working plan. this search is implemented using two main data structures: agenda  and plan. agenda is a priority queue of  pairs  where pi is a  sub goal proposition and ti  is the time by which the goal must be true. agenda is initialized by enqueuing  for each top level goal   and the queue is sorted in decreasing temporal order. the second structure  plan  which is initialized empty  stores the plan under construction as a set of  pairs  where si  is the start time for action ai. persistence actions for a goal  denoted p e r s i s t - g   are considered explicitly since they were not added during incremental graph expansion. the tgp solution extraction loop performs the following steps while agenda is nonempty: 
1. dequeue  g t  from agenda. 
1. if t= 1 and  initially true  then fail  backtrack . if t   1 then let s equal the set of actions    such that each ai has g as an effect and 
1. choose a from s u {persist-g} such that a isn't mutex with any action in plan. add to plan  and for each precondition p of a  add  to agenda. if no such a exists  back-
track. all such consistent a's must be considered for completeness.1 
　in essence  persistence actions are really just placeholders to ensure that tgp remembers to check all relevant action/proposition mutexes. unfortunately  the presence of persistence actions adds redundancy to the space of plans  and this can lead to increased search. for a simple example of this  consider the domain of figure 1 and suppose that the goal is to achieve both p and q. the shortest plan involves executing actions a and b and requires two units of time. it should also be clear that a could start execution at any time in the interval  1 . but tgp should not consider all such times  for 
1if
        a is the special  persist-g  action  let equal the greatest common divisor of the durations of the set of actions  and test for mutexes with proposition g. 
1 	challenge papers 
there is an uncountable number; indeed  the algorithm above restricts attention to start times which are an integral multiple of the greatest common divisor of the set of action durations  and this does not compromise completeness. for this example  the gcd restriction translates into starting a at time 1 or at time 1. 
　but tgp applies the following even stronger  completeness-preserving filter: all actions are executed as late as possible  unless this leads to a mutex inconsistency. intuitively  one may think of this as defining a canonical form for plans by taking a legal plan and  tilting it  so that all actions  slide as far right  as they can go without breaking plan correctness. this completeness-preserving heuristic can be implemented by refusing to choose a = p e r s i s t - g to support subgoal g  in step 1  unless all other choices are inconsistent. 
1 	approximating mutex conditions 
as we mentioned at the end of section 1  simplifying the logical and inequality formulae that bound the applicability of conditional mutexes is a key component of temporal reasoning and a central aspect of the tgp algorithm. since these formulae can get arbitrarily complex  we developed the asymmetric restricted form in an effort to keep the reasoning tractable. the asymmetric form limits the mutex condition to a simple conjunction of two inequalities  but allows for different bounds in each inequality. for example  x is mutex with y when 
 . in contrast with the restrictive 
symmetric form  when one plugs this representation into def 1  there is no loss of information. unfortunate!y this is not the case for def 1 and 1. for example  
　def 1a  asymmetric . let a and b be two actions which are not emutex. for each precondition 
pi of b  let  be the condition under which a is mutex with pi. for each precondition be the condition under which b is mu-
　this condition does not simplify to the cannonical asymmetric form because of the a inside the v. there are several choices here for bounding approximations  and two possibilities are: 

and 

　in practice we do something slightly more sophisticated by using the better of these max/min approximations on each successive pair of disjuncts. more precisely  the binary disjunction 



　we note that  this form gives an exact result except in two cases  1  when 
. in those two cases the result will be a rnin/max approximation. 
	def 1a  asymmetric . 	let a be an action and 
p be a proposition. 	for each precondition  of a  
let 	= 	be the condition under which p is mutex with 	for each action 	possibly supporting p  let be the condition under which a is mu-
tex with 
if is satisfiable  then action a and proposition p are cmutex when 
　as before  this condition does not simplify to our cannonical form; there are several choices here for bounding approximations  and one rnin/max argument leads to the following: 

　again  we improve on this equation by using the better of this and a symmetric max/min approximation on each successive pair of disjuncts. 
1 	experimental results 
to date our implementation has been primarily used to verify the correctness and completeness of the cmutex rules; we have put little effort into code optimization. direct comparison between tgp and other temporal planning systems is difficult for both availability and modularity reasons  hsts  muscettola  1   for example  is part of a larger embedded system and requires inputs which are radically different from classical representation . nevertheless  we plan to do direct comparison in the immediate future. 
　in this section  we report on two experiments. first  we compare the performance of tgp with that of sgp  weld  anderson  & smith  1  on plain strips problems in order to see whether tgp's general  temporal framework comes at huge cost. using a power mac g1 running macintosh common lisp 1 in 1mb memory  we solved each problem ten times with sgp  with full tgp  and also using tgp with cmutex reasoning disabled. all runs were censored after 1 seconds  and we averaged across each set of ten runs to reach a single time for each problem/algorithm combination  figure 1 . t g p generally performs much better than sgp on the harder logistics problems  sgp wins on med-bw1 and big-bw1 which are dominated by solution extraction and appear sensitive to goal ordering decisions therein. we conjecture that sgp is faster at solution extraction either 

figure 1: tgp with both cmutex and emutex reasoning beats emutex alone  and often beats sgp as well. times are in seconds. 
due to reduced overhead when checking mutexes or because of sgp's use of dynamic variable ordering  bacchus & van run  1 . 
　in our second experiment we considered tgp's performance on temporal planning problems  and again looked at the contribution of asymmetric cmutex reasoning. in the absence of a test suite of large temporal planning problems  we took 1 strips problems  mostly from att logistics domains ; for each strips problem we created 1 temporal problems by randomly assigning actions a duration from a normal distribution of integers in the range  1  x . we then ran full tgp as well as tgp without cmutex reasoning on each of the resulting temporal planning problems  censoring after 1 seconds and averaging the results. we repeated this procedure for x = 1  and 1. figure 1 displays the results clearly  cmutex reasoning provides a substantial gain in performance  especially for difficult problems. 
　we also note that tgp can handle relatively complex problems: e.g.  the solution to log-1 is a 1-action plan; with emutex and cmutex reasoning combined  generation of the plan takes about 1 seconds on average. 
1 	exogenous events &: time windows 
thus far  our description of temporal planning has focussed on handling actions of extended duration  but several other aspects are equally challenging. a general temporal planner must also handle exogenous events  e.#.  a solar eclipse or orbit perigee  and temporally constrained goals  e.g.  observations that must be performed during a time window . this section explains how the basic tgp algorithm can be extended with this functionality. 
suppose that as input the planning problem specified 
	smith and weld 	1 


figure 1: cmutex reasoning provides substantial speedup on larger problems. 
a set of  g  s  e  triples instead of a simple set of goals. we wish the planner to ensure that goal g is true at time t such that  handling this representation requires only minor changes to graph expansion and solution extraction. graph expansion need never proceed past the maximum of the goal's endpoints  and tgp can claim failure without attempting solution extraction if some goal fails to enter the planning graph by its endpoint. solution extraction is modified as follows: 
1. dequeue  g  s e  from agenda. 
1. if e = 1 and  initially true  then fail  backtrack . if e   1 then let s equal the set of actions    such that each a{ has g as an effect and 
1. if s   e then add p e r s i s t - g to 1. 
1. choose a from s such that a isn't mutex with any action in plan. add  to plan  and for each precondition p of a  add  p  1 e -  to agenda. if no such a exists  backtrack. all such consistent a'b must be considered for completeness. 
　note that this algorithm does not preclude g from being made true earlier than s and then persisting into the interval  s  e . if one wishes to ensure that g is made true during that interval  one must post as a goal in step 1. 
　there are  at least  two ways to handle exogenous events  and the first is simple. one can model exogenous events with a partial plan. each event defines a special type of  action  with no preconditions but with the event's effects. of course the agent has no choice about when these event  actions  are executed - these times are specified in the problem input. we denote the resulting set of  e    pairs with the variable events. the following simplistic approach to graph expansion now suffices. during the normal process of expanding the planning graph  whenever the time is incremented to the starting time of an event e its effects are added into the graph. similarly  solution extraction only requires minor modification: instead of initializing plan 
1 	challenge papers 
to the empty set  it is initialized to equal events. normal mutex reasoning now ensures that the events will be dealt with correctly. 
　while correct  this approach is simplistic in its treatment of recurring events  e.g.  cyclic periods of blocked communications due to satelite orbits . instead of storing a single time label on each proposition  and action and mutex  node in the planning graph  one should store a set of time intervals that dictate the times when the proposition is possibly achieveable. as we envision these extensions  the two level plan graph starts to look very much like a temporal csp network  in which propositions  actions and mutexes  come and go   i.e. are active according to sets of allowed time windows. unfortunately  efficient techniques like arc-consistency are not powerful enough to derive and propagate mutex relationships. for this  k-consistency is required. however  experience shows that general k-consistency reasoning is too unfocused to be practical. mutex reasoning is a highly-focused form of k-consistency  and we believe it will prove quite valuable in more general temporal planning problems. extending these techniques to a general temporal csp is something we have just begun to investigate. 
1 	related work & discussion 
there is a long history of research on temporal planning  but few systems have seen wide use  presumably due to performance limitations. deviser  vere  1  is an early temporal planner which required a library of htn schemata and numerous domain-specific heuristics. 
forbin  dean  firby  k miller  1  combined htn reduction and temporal projection to tackle a similar problem  but the system ran on only a few examples. ixtet  ghallab k laruelle  1  is a more recent htndecomposition temporal planner. allen et al. developed several elegant temporal planners based on temporal logic  allen k koomen  1; pelavin k allen  1; allen  1   but none supported metric durations. the zeno planner  penberthy k weld  1  used an incremental simplex algorithm to support actions with metric durations and continuous change  but performance was lacking - tgp is orders of magnitude faster. hsts  muscettola  1  plans using a dynamic  temporal csp. when the planner commits to an action  new nodes are added to the csp corresponding to the action's start and end. constraints are then added between the various time points in the csp to specify action duration and to enforce precondition and effect constraints for the action. since the result is a simple temporal network  arc-consistency is sufficient to determine overall consistency  dechter  meiri  k pearl  1 . hsts does not do any form of reachability analysis or mutual exclusion reasoning - it must commit to a particular action or event before it can do any reasoning about consistency. although it does not handle actions of varying duration  stan uses an independently developed representation akin to our compact planning graph  long k fox  1 . 

　we now discuss a method for extending graphplan to handle temporal actions without new mutex rules or our compact planning-graph representation. instead  macro-expand each action in the domain into a number of atomic pieces  each the length of the gcd of the set of action durations  and each a regular strips action. this compilation is a bit tricky since it needs to generate new propositions and add them as preconditions and effects of the different pieces in order to ensure that the pieces sequence properly and that two actions don't intercalate inappropriately. unfortunately  this approach would vastly expand the size of the domain theory  if the ratio of the g c d of action durations is small relative to the longest action - which is inevitable if there is wide variation in action durations. 
1 	conclusions 
this paper makes several contributions: 
  we describe tgp  a fast planner that handles temporally-extended actions. 
  tgp incrementally generates a compact planning graph representation. 
  the key to tgp's performance is a novel form of reachability analysis for actions with varying duration. we distinguish conditional and eternal mutexes  and introduce action/proposition mutexes. 
  we present experiments demonstrating the power of conditional mutex reasoning with an asymmetric condition representation. 
  we explain how to extend tgp to handle exogenous events and goals that must be achieved during certain time windows. 
   we believe that the ideas introduced here can be extended to deal with a richer temporal language that allows:  1  for action preconditions which need not hold throughout execution  i.e.   trigger  preconditions as well as  maintenance  preconditions    1  for effects that become true during the action  instead of just at the end   and  1  temporary effects of actions  e.g.  inexhaustible resource usage . in section 1 we discuss methods for handling  1  exogenous events  and  1  time windows on goals and actions  e.g.  for modeling scientific experiments or astronomical observations   and we wish to experiment with the efficiency of these approaches. yet  even without considering increased action expressiveness there are algorithm improvements to be made. recall that during the backward chaining solution extraction phase  if a plan is not found then tgp initiates another search starting from a time which is a single gcd increment later. a more sophisticated approach would analyze the memoized nogoods and calculate the next time point when a nogood might vanish and start solution extraction there. 
