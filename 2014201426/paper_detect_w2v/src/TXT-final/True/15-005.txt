 
　　program synthesis is the transformation of a specification of a user's problem into a computer program. a problem reduction approach to program synthesis is presented. during synthesis the user's problem is decomposed in a top-down manner into a hierarchy of subproblems. with directly solveable subproblems at the bottom. solving these subproblems results in the bottom-up composition of a program whose structure reflects the subproblem hierarchy. the program is guaranteed to satisfy the specification and to terminate on all legal inputs. we illustrate this approach by presenting the knowledge needed to synthesize a class of divide and conquer algorithms and by deriving a merge sort algorithm. 
i introduction 
　　program synthesis is the derivation of a computer program from a specification of the problem it is intended to solve. human programmers often cope with complex problems in the following top-down manner. first an overall program structure is created which fixes certain gross features of the desired program. some parts of the structure are at first underdetermined but their functional requirements are worked out so that they can be treated as relatively independent subproblems to be solved in a similar manner at a later stage. a formal counterpart to this approach involves the use of program schemas. a schema provides the overall structure of the desired program and its uninterpreted operator symbols stand for the underdetermined parts of the structure. to use a schema we require a corresponding design strategy. given a problem specification ii a design strategy derives specifications for subproblems in such a way that solutions for the subproblems can be assembled  via the schema  into a solution for n. a design strategy then is a way of generating an instance of a schema which satisfies a given specification. 
　　given a collection of such schemas and their associated design strategies the problem reduction approach to program synthesis can be described by a two phase process - the top-down decomposition of problem specifications and the bottom-up composition of programs. in practice these phases are interleaved but it helps to understand them separately. we are given an initial specification. in the first phase a design strategy is selected and applied to the initial specification thereby generating some subproblem specifications. then design strategies are selected and applied to each of the subproblem specifications  and so on. this decomposition process terminates in primitive problem specifications which can be solved directly  without reduction to subproblems. the result is a tree of specifications with the initial 
* the work reported herein was supported by the foundation research program of the naval postgraduate school with funds provided by the chief of naval research. 
specification at the root and primitive problem specifications at the leaves. the children of a node represent the subproblem specifications generated by the application of a design strategy. the second phase involves the bottom-up composition of programs. initially each primitive problem specification is solved to obtain a program  which is often a programming language operator . subsequently whenever each of the subproblem specifications generated by the application of design strategy d to specification ii have solutions  these subproblem solutions are assembled via the corresponding schema into a solution for n. 
　　a prototype synthesis system based on problem reduction has been implemented. it is capable  for example  of synthesizing a mergesort algorithm from a specification of the sorting problem. this synthesis involves the decomposition of the sorting specification into a hierarchy of specifications with four levels and thirteen nodes. in this paper we illustrate the problem reduction approach by presenting the top two levels of the derivation of mergesort. in section iii we present a schema and design strategy for a class of divide and conquer algorithms. one of the principal difficulties in problem reduction is knowing how to decompose a problem into subproblems. a formal deductive system which enables us to perform such problem decompositions is presented in sections iv and v. in section vi the design strategy for divide and conquer is used to derive a mergesort algorithm. a more comprehensive treatment of the material in this paper may be found in  smith  1b . 
ii specifications 
　　the input to a program synthesis system is a formal specification of a problem. for example  the problem of sorting a list of natural numbers may be specified as follows* 
s1rt:x = z such that bag:x = bag:z a ordered:z where s1rt:list n -l1st n . 
here the problem  named sort  is viewed as a mapping from lists of natural numbers  denoted list n   to lists of natural numbers. naming the input x and the output z  the formula bag:x = bag:z a ordered: z. called the output condition  expresses the conditions under which z is an acceptable output with respect to input x. here bag:x = bag:y asserts that the multiset  bag  of elements in the list y is the same as the multiset of elements in x. ordered.y is a predicate which holds exactly when the elements of list y are in nondecreasing order. 
generally  a specification ii has the form 
  we use the notation f:x to denote the result of applying the function  predicate  or program f to argument x. 
d. smith 1 

or more compactly  ii =  d r i 1 . we ambiguously use the symbol ii to denote both the problem and its specification. here the input and output domains are d and r respectively. the input condition 1  a relation on d  expresses any properties we can expect of inputs to the desired program. if an input does not satisfy the input condition then we don't care how the program behaves. the output condition 1  a relation on dxr  expresses the properties that an output object should satisfy. any output object z such that 1: x z  holds will be called a feasible output with respect to input x. we say program f satisfies specification ii =  d r i.1  with derived input condition /'if 

is valid in a suitable first-order theory *. if i' is the boolean constant true then we simply say f satisfies ii. in our synthesis method we attempt to derive a program f and a derived input condition i' from a given specification. in this paper  however  we focus on the derivation of f and for the sake of simplicity omit discussion of the derivation of derived input conditions. 
ill a class of divide and conquer programs 
　　the following schema represents the structure common to a class of divide and conquer programs: 
f:x = if q:x then directly solve:x else compose＜ fxf ＜decompose:x. 

   the key idea in our design strategy for divide and conquer algorithms is to use the separability condition like an equation in three unknowns  1  oc  and od   given values for any two we attempt to solve for a value of the third. initially we are given a specification ii =  d.r i 1  so we have 1. during synthesis we wish to determine the specifications of the subproblems decompose and compose - in essence od and oc respectively. one approach is to a  choose a simple known operator d as say  decompose  b  use the separability condition to  solve for  1c  then c  form a detailed specification for compose based on 1c. we turn now to a formal deductive system which enables us to derive output conditions like oc 
1 d. smith 
	 1  
note that false is a precondition of any formula. in general we are interested in preconditions which are as weak as possible yet have a structurally simple form. 
   continuing our discussion from the previous section  suppose that we are given a relation 1 on dxr and we have chosen a decomposition operator decompose with output condition 1d. we wish to derive an output condition 1c for the  as yet unknown  operator compose to do so we pose the problem of finding a {z1 z1 z1-precondition of 

holds. that is  any jz1 z1 zzj-precondition of  1  enables the separability condition to hold and thus can be used as an output condition for decompose. 
y a formal system for deriving preconditions 
     in this section we present a natural deduction-like formal system for deriving preconditions. more extensive systems are presented in  smith  1a; smith  1b . 

c. the deduction process 
     the derivation of a precondition of goal statement g can be described by a two stage process. in the first phase reduction rules are repeatedly applied to goals reducing them to subgoals. primitive rules pi and p1 are applied whenever possible. the result of this reduction process can be represented by a goal tree in which 1  nodes represent goals/subgoals  1  arcs represent reduction rule applications  and 1  leaf nodes represent goals to which a primitive rule has been applied. the second phase involves the bottom-up composition of preconditions. initially each application of a primitive rule to a goal yields a precondition. subsequently whenever a precondition has been found for each subgoal of a goal g then a precondition is composed for g according to the reduction rule employed. in a working system we have developed a single precondition is selected from amongst the alternative derived preconditions of a goal by maximizing over a heuristic measure of weakness and structural simplicity. a detailed presentation of the derivation of a precondition is provided in the following section. 
vi synthesis of a mergesort algorithm 
consider again the specification 

d. smith 1 

1 d. smith 
program f from a constructive derivation of an {x}-

vii concluding remarks 
     several of the choices made during the derivation of merge sort were arbitrary in the sense that alternatives were available which lead to other sort algorithms. if we had chosen to select a simple compose operator  say append  we would derive a quicksort algorithm. with a slight variation on the divide and conquer program schema analogous derivations lead to insertion and selection sorts. each of these four sort algorithms are derived in detail in 
 smith  1b . see  green and barstow 1; clark and darlington  1  for related derivations of these sorting algorithms. 
     our problem reduction approach is most closely related to theorem proving approaches to program synthesis  e.g. bibel  1; manna and waldinger  1 . which  given a specification n= d r i 1   extract a program f from a constructive proof of the theorem 
 1  
in contrast  the problem reduction approach extracts a precondition of  1 . the resulting precondition is the derived input condition of f. since the synthesis process itself can generate some or all of the input conditions  the task of creating specifications is made easier for the user. also  the design strategies can be viewed as complex inference rules applied in a backwards-chaining manner resulting in the decomposition of complex problems into simpler subproblems. with this approach we hope to make the synthesis process more manageable  to cope with more complex problems  and to produce larger well-structured programs. 
     the formalization of top-down programming has also been explored in  dershowitz and manna  1  where several strategies for designing program sequences  ifthen-else statements  and loops are presented. 
     in this paper we have introduced a problem reduction approach to program synthesis. if we hope to automate the synthesis of programs for solving complex problems then we must have formal methods for breaking problems into simpler subproblems. the problem reduction approach is based on decomposing problems with respect to the structure of program schemas representing various classes of algorithms. the schemas and their design strategies capture much of our knowledge about programming. in order to obtain powerful synthesis performance we need to discover those algorithm schemas which cover the important applications in some domain and devise design strategies for them. we have taken a first step in that direction with design methods for divide and conquer algorithms and a few others. a prototype system has been constructed which can perform the derivations in this and our earlier papers. 
