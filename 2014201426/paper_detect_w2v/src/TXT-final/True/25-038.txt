 
discrete relaxation is frequently used to compute the fixed point of a discrete system  where / is monotonic with respect 
to some partial order  given an appropriate initial value for x  discrete relaxation repeats the assignment  until a fixed point 
for / is found. monotonicity of / with respect to  is a sufficient  but in general not necessary  condition for iterative  hill-climbing techniques such as discrete relaxation to find the fixed point of /. 
in this paper we introduce monotonic asynchronous iteration as a novel way of implementing parallel discrete relaxation in problem domains for which monotonicity is a necessary condition. this is an optimistic technique that maintains monotonicity without limiting concurrency  resulting in good parallel performance. we illustrate this technique with the parallel implementation of a constraint satisfaction system that computes globally consistent solutions  and present performance numbers for experiments on a shared-memory implementation. the performance numbers show that it is indeed possible to obtain a reasonable speedup when parallelizing global constraint satisfaction. we believe that monotonic asynchronous iteration is applicable to parallel discrete relaxation in general. 
1 	introduction 
discrete relaxation is frequently used to compute the fixed point of a discrete system  where / is monotonic with respect to some partial order  . given 
   *ho and hilfinger are supported by nsf grant ccr-1. guesgen performed part of this work while at the german national research center for computer science  gmd . in st. augustin  germany  and the international computer science institute in berkekey  california. at the gmd he was supported by the german federal ministry for research and technology  bmft  within the joint projects tex-b  grant itw1d  and tasso  grant itw1 . 
1 	constraint satisfaction problems an appropriate initial value for x  discrete relaxation repeats the assignment  until a fixed point for 
/ is found. monotonicity of / with respect to   is a sufficient  but in general not necessary  condition for iterative  hill-climbing techniques such as discrete relaxation to find the fixed point of /  parker  1 . 
　discrete relaxation is widely used in the solution of constraint satisfaction problems  csps   and many parallel implementations of discrete relaxation for csps have been reported  kasif and rosenfeld  1; rosenfeld et a/.  1 . these attempts have all focused on csp solvers that compute locally consistent  arc consistent  solutions  which are relatively straightforward to parallelize as the computations are inherently monotonic. on the other hand  discrete relaxation algorithms used in csp solvers that compute globally consistent solutions are very difficult to parallelize because for this class of problems  monotonicity is a necessary correctness condition that is not automatically satisfied. the need to maintain monotonicity  for correctness  often limits the amount of concurrency available in a parallel implementation  degrading the performance significantly. 
　in this paper we introduce monotonic asynchronous iteration as a novel way of implementing parallel discrete relaxation in problem domains for which monotonicity is a necessary condition. this is an optimistic technique that maintains monotonicity without limiting concurrency  resulting in good parallel performance. we illustrate this technique with the parallel implementation of consat  guesgen  1   a constraint satisfaction system that computes globally consistent solutions  and describes an experiment on a shared-memory implementation. the performance numbers show that it is indeed possible to obtain a reasonable speedup when parallelizing global constraint satisfaction  and thus proving that kasif's conjecture is correct . we believe that monotonic asynchronous iteration is applicable to parallel discrete relaxation in general. 
1 	discrete relaxation 
consider the problem of finding the fixed point of a discrete system .  for our purposes  the system has the following properties: 


	ho  hilfinger  and guesgen 	1 

                                                           is considerable freedom in applying application-specific scheduling strategies for good performance. 
1 	constraint satisfaction problems 


figure 1: activations of constraint network a: each constraint being activated  leftmost column  is shown with the feasible sets of its adjacent variables after its activation. an  *  at the end of a variable means that it has not been changed in the current activation. the feasible 
set of any variable non-adjacent to the current constraint can be found by searching backwards from the current activation.  componentwise unification of full tags is the key idea behind the algorithm.  
m constraints  each full tag is an m-tuple  where the rth component  the rth subtag  indicates the tuple in the rth constraint that is part of the global solution. 
 for example  in constraint c1 of figure 1 the tuple  r b  corresponds to the subtag 1.  the special symbol  -  is the wildcard character for subtags and indicates that a tuple for the corresponding constraint has not been chosen. a subtag with a tuple number is said to be determined  while one with the special symbol  -  is said to be undetermined. as an example  consider the global solutions of constraint network a shown in figure 1. the two solutions  va vb vc  are  r g b  with full tag  1 1 1  and  r b g  with full tag  1 1 1 . an intuitive explanation of the use of tags for constraint network a is given in figure 1. 
filtering of tagged values the feasible set of a variable contains its current set of potential  tagged  values  and is initialized to the special value unconstrained  meaning the variable may take any value from the domain under consideration. the filtering function / of the constraint network uses local propagation of tagged values to eliminate inconsistent values from the feasible sets  and replaces undetermined subtags with determined subtags. guesgen showed in his thesis that filtering of tagged values is guaranteed to terminate with the globally consistent solutions of a constraint network in a finite number of steps provided that it is fair . this means each constraint is evaluated  or activated  at least once  and if a constraint changes the feasible set of any adjacent variable during filtering  other constraints adjacent to the modified variable have to be reactivated.  this is not the usual definition of fairness in the parallel programming literature.  upon termination of local propagation  each tuple of values-one per variable-with identical full tags form a globally consistent solution of the constraint network  see figure 1 . if the feasible set of any variable becomes empty  there is no solution for the constraint network. local propagation computes the fixed point of the filtering function / of the constraint network. 



figure 1: globally consistent solutions of constraint network a 
　intuitively  filtering either eliminates a tagged value if it is inconsistent  or replaces one or more undetermined subtags of a tagged value by determined subtags. a determined subtag is never replaced by an undetermined subtag or another determined subtag. a more formal explanation of why filtering of tagged values is monotonic 
	ho  hilflnger  and guesgen 	1 

with respect to   will be given elsewhere  ho  1 . 
consat as discrete relaxation in this section we show that consat is a special case of discrete relaxation as defined in section 1. 
  consat computes the fixed point of the discrete system x = f x  for the non-deterministic / that corresponds to the filtering function of the entire constraint network. this fixed point corresponds to the set of all the globally consistent solutions of the constraint network. 
  / = { 1   . . .   n  is the set of all the variables of the constraint network. 
  / may be decomposed into component functions fc for constraints  is the filtering 
function of constraint c  and eliminates value combinations inconsistent with c from the feasible sets of its adjacent variables. without loss of generality  we assume that a constraint may be uniquely identified by its set of adjacent variables. for example  /{1 1} is the filtering function of the constraint that is adjacent to variables 1  1 and 1. fc only depends on the values of variables and fc x  only differs from x for the same set of variables. the new value of any such variable i is given by 
  for is the feasible set of variable i. 
  a 1 is the initial state of the feasible sets of all the variables. all its components have the special value unconstrained. 
  the partial order   on d has been defined on page 1. 
　we have shown that consat is a special case of discrete relaxation  and have defined an application-specific monotonicity test between successive states of the relaxation. consequently  an efficient parallel implementation of consat may be obtained by using monotonic asynchronous iteration. 
performance we implemented parallel consat using clip  franz inc.  1   a commercial implementation of the multiprocessing features of spur lisp  zorn et al.  1  that currently runs on the shared memory sequent symmetry multiprocessor. to estimate the performance of parallel consat in the absence of garbage collection-an upper bound on parallel performance-we define speedup as the ratio of real time excluding garbage collection of the sequential version relative to the real time  excluding garbage collection  of the parallel version on n processors. this definition is chosen because the current clip implementation uses a sequential garbage collector that stops all but one processor each time a collection occurs. we feel our definition better models the performance of parallel consat in a parallel lisp system with a more realistic garbage collector  such as the concurrent collector in top-1 common lisp  tanaka and uzuhara  1 . 
　we measured the parallel performance of consat for a problem in machine vision  which assigns threedimensional edge labelings  convex  concave  or occlud-
1 	constraint satisfaction problems 
ing  to line drawings in a polyhedral world of trihedral vertices  horn  1 . the constraints restrict the labeling of edges meeting at a vertex to be the few combinations physically possible. in addition  each edge is constrained to have the same label at both ends  where it meets other edges . the particular scene  constraint network  chosen  stair1  has 1 variables and 1 constraints  1-variable and 1-variable constraints . 

table 1: performance of consat for stair1: p is the number of processors  and seq is the sequential implementation. all times are real time in seconds  no gc is time without garbage collection  gc is time for garbage collection  and t is the total time. speedup is based on times excluding garbage collection. both sequential and parallel versions are compiled with the highest optimization setting for speed. steps is the number of discrete relaxation steps  including non-monotonic ones. abort is the number of non-monotonic steps  re-executed . 
the results for stair1 are summarized in table 1. 
speedup ranges between 1 on one processor to 1 on six processors. the one processor time is within 1% of the sequential time  showing that the parallel implementation is reasonably efficient. the speedup is less than linear because a small number of constraint activations  relaxation steps  have to be re-executed because they violate monotonicity. serial bottlenecks in the allocation routines of the current clip implementation also prevent parallel consat from achieving better speedup. 
　an earlier parallel implementation of consat that performs the update to the feasible sets  x  in a single critical section for each constraint activation has virtually no speedup because contention for x serializes all the concurrent constraint activations. the current implementation based on monotonic asynchronous iteration performs significantly better. 
1 	related work in parallel relaxation 
the formulation of asynchronous iterations in section 1 is similar to generalized iterations defined by pohlmann in the context of parallel discrete event simulation . generalized iterations operate in the domain of infinite streams of elements  each of which corresponds to an event over time in the system being simulated. 
　parallel relaxation is also used by various schemes for solving systems of equations x  - f x  in the domain of real numbers in parallel  including chaotic relaxations defined by chazan and miranker   asynchronous iterations defined by baudet  and chaotic iterations 

with delay defined by miellou . in these systems 
/ is made up of component functions fc  and the state x of the fixed-point computation may be decomposed into a set of  potentially disjoint  components that are computed by different fc functions concurrently. each fc may be computed using multiple previous states  with a different state for each component of x  to minimize the amount of synchronization required. these schemes are optimized for the domain of real numbers by using the properties of real numbers  and their convergence criteria are somewhat analogous to the test for monotonicity used in monotonic asynchronous iterations. our formulation of asynchronous iterations for parallel discrete relaxation is a domain-independent generalization of these parallel iteration schemes. in addition  the use of an optimistic test for monotonicity for improved parallel performance is unique to our approach. 
1 	conclusion 
in this paper we proposed monotonic asynchronous iteration as a correct and efficient way of implementing parallel discrete relaxation for systems for which monotonicity is a necessary correctness condition. monotonic asynchronous iteration uses an optimistic scheme to compute a possible next state of the system. this optimistic scheme is highly efficient but is not necessarily monotonic  i.e.  correct . an application-specific test for monotonicity is then applied to the computed state. if the test succeeds  the state transition is made  atomically . otherwise  the computation is repeated using the current state. we have applied our technique to the parallel implementation of a constraint satisfaction system that computes globally consistent solutions  for which monotonicity is a necessary correctness condition that is not automatically satisfied. we believe monotonic asynchronous iteration is applicable to parallel discrete relaxation in general. it will be interesting to see if this application-specific monotonicity test is easy to derive for other discrete relaxation problems. 
1 	acknowledgements 
we thank suresh krishna for translating miellou's paper on chaotic iterations from french into english  and ed wang for explaining the subtleties of lattice theory. we also thank chu-cheow lim  ed wang  luigi semenzato and kathy yelick for their comments on various drafts of this paper. 
