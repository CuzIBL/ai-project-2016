
we consider a modified version of the situation calculus built using a two-variable fragment of the first-order logic extended with counting quantifiers. we mention several additional groups of axioms that can be introduced to capture taxonomic reasoning. we show that the regression operator in this framework can be defined similarly to regression in the reiter's version of the situation calculus. using this new regression operator  we show that the projection and executability problems are decidable in the modified version even if an initial knowledge base is incomplete and open. for an incomplete knowledge base and for context-dependent actions  we consider a type of progression that is sound with respect to the classical progression. we show that the new knowledge base resulting after our progression is definable in our modified situation calculus if one allows actions with local effects only. we mention possible applications to formalization of semantic web services.
1 introduction
the situation calculus is a popular and well understood predicate logic language for reasoning about actions and their effects  reiter  1 . it is used to provide a well-defined semantics for web services and a foundation for a high-level programming language golog  reiter  1; mcilraith and son  1 . however  because the situation calculus is formulated in a general predicate logic  reasoning about effects of sequences of actions is undecidable  unless some restrictions are imposed on the theory that axiomatizes the initial state of the world . the first motivation for our paper is intention to overcome this difficulty. we propose to use a two-variable fragment fo1 of the first-order logic  fol  as a foundation for a modified situation calculus. because the satisfiability problem in this fragment is known to be decidable  it is in nexptime   we demonstrate that by reducing reasoning about effects of actions to reasoning in this fragment  one can always guarantee decidability. the second motivation for our paper comes from description logics. description logics  dls   baader et al.  1  are a well-known family of knowledge representation formalisms  which play an important role in providing the formal foundations of several widely used web ontology languages including owl in the area of the semantic web. many expressive dls can be translated to fo1 and offer considerable expressive power going far beyond propositional logic  while ensuring that reasoning is decidable  borgida  1 . dls have been mostly used to describe static knowledge bases. however  several research groups consider formalization of actions using dls or extensions of dls. following the key observation that reasoning about complex actions can be carried in a fragment of the propositional situation calculus   giacomo et al.  1  give an epistemic extension of dls to provide a framework for the representation of dynamic systems. however  the representation and reasoning about actions in this framework are strictly propositional  which reduces the representation power of this framework. in  baader et al.  1   baader et al. provide another proposal for integrating description logics and action formalisms. they take the well known description logic alcqio  and its sub-languages  as foundation and show that the complexity of executability and projection problems  two basic reasoning problems for possibly sequentially composed actions  coincides with the complexity of standard dl reasoning. however  actions  services  are represented in their paper meta-theoretically  not as first-order  fo  terms. this can potentially lead to some complications when specifications of other reasoning tasks  e.g.  planning  will be considered because it is not possible to quantify over actions in their framework. in our paper  we take a different approach and represent actions as fo terms  but achieve integration of taxonomic reasoning and reasoning about actions by restricting the syntax of the situation calculus and by introducing additional axioms to represent a taxonomy.
¡¡because after doing longer and longer sequences of actions  solving projection problems becomes increasingly more difficult  it is beneficial to progress the initial incomplete knowledge base  kb  to represent the current state of the world. then  the subsequent projection problems can be solved with respect to a new progressed kb. the task of computing a progressed kb is called the progression problem. our paper is structured as follows. in section 1  we briefly review the reiter's situation calculus and the extension of fo1 with counting quantifiers. in section 1 we discuss details of our proposal: a modified situation calculus. in section 1 we consider an extension of regression  the main reasoning mechanism in the situation calculus . finally  in section 1 we discuss the progression problem and in section 1 we discuss briefly other related approaches to reasoning about actions.
1 background
the situation calculus  sc  lsc is a predicate language for axiomatizing dynamic systems. all dialects of the sc lsc include three disjoint sorts: actions  situations and objects. actions are fo terms consisting of an action function symbol and its arguments. actions change the world. situations are fo terms which denote world histories. a distinguished constant s1 is used to denote the initial situation  and function do a s  denotes the situation that results from performing action a in situation s. every situation corresponds uniquely to a sequence of actions. objects are fo terms other than actions and situations that depend on the domain of application. fluents are relations or functions whose values may vary from one situation to the next. normally  a fluent is denoted by a predicate or function symbol whose last argument has the sort situation. for example  represents a relational fluent in
the situation do ¦Án do ¡¤¡¤¡¤  do ¦Á1 s1 ¡¤¡¤¡¤  resulting from execution of ground action terms ¦Á1 ¡¤¡¤¡¤  ¦Án in s1. we do not consider functional fluents in this paper.
¡¡the sc includes the distinguished predicate poss a s  to characterize actions a that are possible to execute in s. for any sc formula ¦Õ and a term s of sort situation  we say ¦Õ is a formula uniform in s iff it does not mention the predicates poss  it does not quantify over variables of sort situation  it does not mention equality on situations  and whenever it mentions a term of sort situation in the situation argument position of a fluent  then that term is s  see  reiter  1  . if ¦Õ s  is a uniform formula and the situation argument is clear from the context  sometimes we suppress the situation argument and write this formula simply as ¦Õ  and also introduce a notation ¦Õ s  to represent the sc formula obtained by restoring situation s back to all the fluents and/or poss predicates  if any  in ¦Õ. it is obvious that ¦Õ s  is uniform in s.
¡¡a basic action theory  bat  d in the sc is a set of axioms written in lsc with the following five classes of axioms to model actions and their effects  reiter  1 : action precondition axioms dap  successor state axioms  ssas  dss  initial theory ds1  unique name axioms duna  domain independent foundational axioms for situations ¦².
¡¡suppose that d = duna ¡Èds1 ¡Èdap ¡Èdss ¡È¦² is a bat  ¦Á1 ¡¤¡¤¡¤  ¦Án is a sequence of ground action terms  and g s  is a uniform formula with one free variable s. one of the most important reasoning tasks in the sc is the projection problem  that is  to determine whether d |= g do  ¦Á1 ¡¤¡¤¡¤  ¦Án  s1  . another	basic	reasoning	task	is	the	executability	problem.	let	executable do  ¦Á1 ¡¤¡¤¡¤  ¦Án  s1   be	an	abbreviation	of	the	formula	poss ¦Á1 s1  ¡Ä i=1	i	¦Á1 ¡¤¡¤¡¤  ¦Ái 1  s1  .	then 	the ¦Á
executability problem is to determine whether d |= executable do  ¦Á1 ¡¤¡¤¡¤  ¦Án  s1  . planning and high-level program execution are two important settings where the executability and projection problems arise naturally. regression is a central computational mechanism that forms the basis for automated solution to the executability and projection tasks in the sc  reiter  1 . a recursive definition of the regression operator r on any regressable formula ¦Õ is given in  reiter  1 . we use notation r ¦Õ  to denote the formula that results from eliminating poss atoms in favor of their definitions as given by action precondition axioms and replacing fluent atoms about do ¦Á s  by logically equivalent expressions about s as given by ssas repeatedly until it cannot make such replacement any further. the formula g do  ¦Á1 ¡¤¡¤¡¤  ¦Án  s1   is a particularly simple example of a regressable formula because it is uniform in do  ¦Á1 ¡¤¡¤¡¤  ¦Án  s1    but generally  regressable formulas can mention several different ground situation terms. the regression theorem shows that one can reduce the evaluation of a regressable formula ¦Õ to a fol theorem proving task in the initial theory together with unique names axioms for actions: d |= ¦Õ iff ds1 ¡È duna |= r ¦Õ .
this fact is the key result for our paper: it demonstrates that an executability or a projection task can be reduced to a fol theorem proving task. however  because ds1 is an arbitrary fo theory  this type of reasoning is undecidable. two of the most common ways to overcome this difficulty is to introduce the closed world assumption or introduce the domain closure assumption  i.e.  assume the domain is finite . in many application domains these assumptions are unrealistic. therefore  we consider a version of the sc formulated in fo1  or in c1.
¡¡two-variable fo logic fo1 is the fragment of ordinary fo logic  with equality   whose formulas only use no more than two variable symbols x and y  free or bound . twovariable fo logic with counting c1 extends fo1 by allowing fo counting quantifiers  ¡Ým and  ¡Üm for all m ¡Ý 1.  pacholski et al.  1  show that satisfiability problem for c1 is decidable and recently  pratt-hartmann  1  proves that this problem is in nexptime even when counting quantifiers are coded succinctly. see additional background on dls and discussion of connections between dls with c1 in  baader et al.  1; borgida  1; gu and soutchanski  1 .
1 modeling dynamic systems in a modified situation calculus
in this section  we consider dynamic systems formulated in a modification of the language of the sc so that it can be considered as an extension to c1  with an additional situation argument .1 the key idea is to consider a syntactic modification of the sc such that the executability and projection problems are guaranteed to be decidable as a consequence of the decidability of the satisfiability problem in c1. moreover  since the modified sc has strong connections with description logics  which will be explained in detail below  we will denote this language as ldlsc .
¡¡first of all  the three sorts in  i.e.  actions  situations and objects  are the same as those in lsc  except that they obey the following restrictions:  1  all terms of sort object are variables  x and y  or constants  i.e.  object functional symbols are not allowed;  1  all action functions include no more than two arguments. each argument of any term of sort action is either a constant or an object variable  x or y ;  1  variable s of sort situation and/or variable a of sort action are the only additional variables being allowed in d  ¦² duna in addition to variables x  y.
¡¡second  any fluent in ldlsc is a predicate either with two or with three arguments  including the one of sort situation . we call fluents with two arguments  dynamic  concepts  and call fluents with three arguments  dynamic  roles. in ldlsc    static  concepts  i.e.  unary predicates with no situation argument  and  static  roles  i.e.  binary predicates with no situation argument   if any  are considered as unchangeable taxonomic properties and unchangeable classes of an application domain. moreover  each concept  static or dynamic  can be either primitive or defined.
¡¡third  apart from the standard fo logical symbols ¡Ä  ¡Å and    with the usual definition of a full set of connectives and quantifiers  ldlsc also includes counting quantifiers  ¡Ým and  ¡Üm for all m ¡Ý 1. equality = is allowed in lscdl.
¡¡the dynamic systems we are dealing with here satisfy the open world assumption  owa : what is not stated explicitly is currently unknown rather than false. in this paper  the dynamic systems we are interested in can be formalized as a basic action theory  bat  d using the following seven groups of axioms in ldlsc :
d = ¦² ¡È dap ¡È dss ¡È dt ¡È dr ¡È duna ¡È ds1. five of them  ¦² dap dss duna ds1  are similar to those groups in a bat in lsc  and the other two  dt dr  are introduced to axiomatize description logic related facts and properties  see below . however  because ldlsc allows only two object variables  all axioms must conform to the following additional requirements.
action precondition axioms dap: for each action a in ldlsc   there is one axiom of the form poss a s  ¡Ô ¦°a s   or poss a x  s  ¡Ô ¦°a x  s   or poss a x y  s  ¡Ô ¦°a x y  s   respectively   if a is an action constant  or unary  or binary action term  respectively   where ¦°a  or ¦°a x   or ¦°a x y   respectively  is a c1 formula with no free variables   or with at most x  or with at most x y as the only free variables  respectively . this set of axioms characterize the preconditions of all actions.
successor state axioms dss: there are two types of fluents in ldlsc : primitive dynamic concepts of the form f x s   fluents with exactly one non-situation argument  and primitive dynamic roles of the form f x y s   fluents with exactly two non-situation arguments . let variable vector; a ssa is specified for each fluent . according to the general syntactic form of the ssas provided in  reiter  1   without loss of generality  we can assume that the axiom has the form
	 	 1 
where the general structure of is as follows: where each variable vector respectively   i = 1..m1 j = 1..m1 n ¡Ê {1} b ¡Ê {+  }  represents a vector of object variables  which can be empty or . moreover    x  or   y  represents that the quantifier included in     is optional; and each
  respectively   is a c1 formula
with variables  both free and quantified  among x and y. note that when m1  or m1 respectively  is equal to 1  the corresponding disjunctive subformula is equivalent to false. acyclic tbox axioms dt: similar to the tbox axioms in dl  we may define new concepts using tbox axioms. any group of tbox axioms dt may include two sub-classes: static tbox dt st and dynamic tbox dt dyn. every formula in static tbox is a concept definition formula of the form
g x  ¡Ô ¦Õg x  
where g is a unary predicate symbol and ¦Õg x  is a c1 formula in the domain with free variable x  and there is no fluent in it. every formula in dynamic tbox is a concept definition formula of the form g x s  ¡Ô ¦Õg x  s   where ¦Õg x  is a c1 formula with free variable x  and there is at least one fluent in it. all the concepts appeared in the left-hand side of tbox axioms are called defined concepts. we also require that the set of tbox axioms must be acyclic  acyclicity in dt is defined exactly as it is defined for tbox  . rbox axioms dr: similar to the idea of rbox in dl  we may also specify a group of axioms  called rbox axioms below  to support a role taxonomy. each role inclusion axiom is represented as r1 x y  s    r1 x y  s   where r1 and r1 are primitive roles  either static or dynamic . if these axioms are included in the bat d  then it is assumed that d is specified correctly in the sense that the meaning of any rbox axiom included in the theory is correctly compiled into ssas. that is  one can prove by induction that  d   dr  |=  s.r1 x y  s    r1 x y  s . although rbox axioms are not used by the regression operator  they are used for taxonomic reasoning in the initial theory. initial theory ds1: it is a finite set of c1 sentences  assuming that we suppress the only situation term s1 in all fluents . it specifies the incomplete information about the initial problem state and also describes all the facts that are not changeable over time in the domain of an application. in particular  it includes static tbox axioms dt st as well as rbox axioms in the initial situation s1  if any . in addition  ds1 also includes all unique name axioms for object constants.
¡¡the remaining two classes  foundational axioms for situations ¦² and unique name axioms for actions duna  are the same as those in the bats of the usual sc. note that these axioms  as well as dap and dss  use more than two variables  e.g.  dss use action and situation variables in addition to object variables   but we will see in the next section  that these axioms will be eliminated in the process of regressing a regressable formula to a sentence that will use no more than two object variables and no other variables.
1 modified regression with lazy unfolding
¡¡after giving the definition of what the bat in ldlsc is  we   turn our attention to the reasoning tasks.
¡¡given a formula w of ldlsc in the domain d  the definition of w being regressable  called ldlsc regressable below  is slightly different from the definition of w being regressable in lsc  see  reiter  1   by adding the following two conditions:  i  any variable  free or bounded  in w is either x or y;  ii  every term of sort situation in w is ground. moreover  inwe have to be more careful with the definition of the regression operator r for two main reasons. first  to deal with tbox we have to extend regression. for aregressable formula w  we extend below the regression operator defined in  reiter  1  with the lazy unfolding technique  see  baader et al.  1   to expand defined dynamic concepts. we still denote such operator as r. second  uses only two object variables and we have to make sure that after regressing a fluent atom we still get a formula  i.e.  that we never need to introduce new  free or bound  object variables. to deal with the two-variable restriction  we modify our regression operator r in comparison to the conventional operator defined in  reiter  1 . for example  when replacing poss atom or fluent atoms about do ¦Á ¦Ò   the definition of the conventional regression operator in  reiter  1  has the assumption that the quantified variables in the right-hand side of the corresponding axioms should be renamed to new variables different from the free variables in the atoms that to be replaced. this assumption of using new variables for renaming assures equivalence of original formula and the formula after regression. to avoid introducing new variables  as required by the reiter's regression operator  and to assure defined dynamic concepts being handled  we modify the regression operator for each regressable formula. possibility of reusing variables is guaranteed by the general format of the ssas given in the previous section and the additional condition  ii  in the definition of the ldlsc regressable formula.
¡¡the complete formal definition of our r is as follows  where ¦Ò denotes the term of sort situation  and ¦Á denotes the term of sort action.
  if w is not atomic  i.e. w is of the form w1 ¡Å w1  where q represents a quantifier  in-
cluding counting quantifiers  and v represents a variable symbol  then
 
  otherwise  w is atom. there are several cases.
a. if w is of the form for some action function symbols a1 and a1  then by using axioms in duna 1 we define the regression of w as
a1 
.
¡¡otherwise  if w is situation independent atom  including equality between object constants or variables   or w is a
concept or role uniform in s1  then
r w  = w.
b. if w is a regressable poss atom  so it has the form   for terms of sort action and situation respectively in ldlsc . then there must be an action precondition axiom for a of the form  where the argument x of sort object can either be empty  i.e.  a is an action constant   a single variable x or two-variable vector
. because of the syntactic restrictions of lscdl  each can only be a variable x  y or a constant c. then 

 
or t or t x    f
formula ¦Õ obtained by replacing every variable symbol x where c is a constant and ¦Õ denotes a dual formula for
 free or quantified  with variable symbol y and replacing every variable symbol y  free or quantified  with variable symbol x in ¦Õ  i.e.  ¦Õ = ¦Õ x/y y/x .
c. if w is a defined dynamic concept  so it has the form g t ¦Ò  for some object term t and situation term ¦Ò  and there must be a tbox axiom for g of the form g x s  ¡Ô ¦Õg x s . because of the restrictions of the language ldlsc   term t can only be a variable x  y or a constant. then  we use lazy unfolding technique as follows:
¡¡if t is not variable y  f	otherwise.
d. if w is a primitive concept  a primitive role  respectively   so it has the form f t1 do ¦Á ¦Ò   or f t1 t1 do ¦Á ¦Ò   for some terms t1  and t1  of sort object  term ¦Á of sort action and term ¦Ò of sort situation. there must be a ssa for fluent f such as eq.  1 . because of the restriction of the language ldlsc   the term t1 and t1 can only be a variable x  y or a constant c and ¦Á can only be an action function with no more than two arguments of sort object. then  when w is a concept 
if t1 is not variable y 
	f	otherwise  i.e.  if t1 = y;
and  when w is a role 
	    1 rr      yx    xy == yx¡Ä¡Ä¦×¦×ff  x y ¦Á ¦Òx y ¦Á ¦Ò      	ifif tt1 == y tx t1 == yx;;
r w  =   r ¦×ff y x ¦Á ¦Ò  	orif tt1==y ty t1==xc;;  :  r ¦×f t1 t1 ¦Á ¦Ò  	otherwise.
¡¡based on the above definition  we are able to prove the following theorems.
theorem 1 supposeregressable formula  then the regression r w  defined above terminates in a finite number of steps.
proof: immediately follows from conditions  i  and  ii  of the definition of ldlsc regressable formula  acyclicity of the tbox axioms  and from the assumption that rbox axioms are compiled into the ssas and consequently do not participate in regression.	
theorem 1 suppose w is a ldlsc regressable formula with the background basic action theory d. then  r w  is a ldlsc formula uniform in s1 with no more than two variables  x and y . moreover 	d |= w ¡Ô r w  	and
	d |= w	iff ds1 |= r w .
proof: according to the definition of the modified regression operator  prove by induction over the structure of w. the first statement holds because all replacements done by r transform w to logically equivalent formula. the second statement follows from the regression theorem in  reiter 
1 .	
theorem 1 suppose w is a ldlsc regressable formula with the background basic action theory d. then  the problem whether d |= w is decidable.
proof: according to theorem 1  d |= w iff ds1 |= r w   where r w  and the axioms in ds1 are c1 formulas. therefore  the problem whether d |= w is equivalent to whether ds1 ¡Ä  r w  is unsatisfiable or not  which is a decidable problem  according to the fact that the satisfiability problem in c1 is decidable.	
¡¡this theorem is important because it guarantees that the projection and executability problems in are decidable even if the initial kb ds1 is incomplete.  gu and soutchanski  1  give some detailed examples that illustrate the basic reasoning tasks described above and reduction techniques for dealing with properties that need more than two variables  and show that using ldlsc   one can model realistic dynamic domains such as school enrollment services and on-line shopping services.
we say that the ssa for a fluent f is context-free if the
ssa for f has the form
.
then  we have the following theorem about the complexity analysis for reasoning about projection problem.
theorem 1 given a basic action theory  suppose that the ssa for a fluent f is context-free  then the computational complexity of answering the queries of the form
-nexptime  where x is a vector of object constants and ¦Ò is a ground situation term.
proof: the result follows from the complexity analysis of projection problem in  reiter  1   chapter 1   theorem 1  and the theorem in  pratt-hartmann  1  that the satisfiability problem in c1 is decidable in nexptime. 
1 progression of cnf-based kbs
the progression problem  also known as filtering and update  is how to compute the new theory in response to a given sequence of actions. in this section  we consider the progression problem for kbs in language. in this section  let

d = dss ¡È dap ¡È ¦² ¡È duna.
¡¡a formal definition of  classical  progression is given in  reiter  1 . a set of sentences ds¦Á is the  classical  progression of the initial kb ds1  wrt basic action theory d  after performing a ground action ¦Á in the situation s1 iff ds¦Á is uniform in do ¦Á s1   d |= ds¦Á  and for every model m¦Á of

d¡Èds¦Á  there is a model m of d such that m and m¦Á have the same domain and interpret situation independent predicates  function symbols  poss and all fluents about the future of do ¦Á s1  identically  in the sequel  we say that m and m¦Á have a progression relationship . the progression can be iteratively repeated if the progressed kb has the same format as the initial kb and we can consider the computed progression as the new initial kb at the next iteration.  lin and reiter  1  shows that the  classical  progression of a finite fo kb is not always fol definable  but it is always definable in the second-order logic . by using an example similar to  lin and reiter  1   one can prove
theorem 1 progression of a theory inis not always fo definable  therefore it is definitely not definable in ldlsc .
proof: we consider the theory d1 obtained by modifying the theory d given in  lin and reiter  1  as follows:  1  replace one constant symbol 1 in d by an infinite set of constant symbols {1 1 ¡¤¡¤¡¤};  1  replace function symbol succ x  = y in d by predicate succ x y  which will be true iff y is the successor of x;  1  replace the empty initial kb by the new ds1 which includes infinitely many axioms of the form for any non-identical constant symbols c1 and c1 given above and of the form where constant c is the successor of constant c in the sense of natural numbers. the rest of the proof is exactly the same as the proof given in
 lin and reiter  1 .	
¡¡notice that the proof assumes that an ldlsc theory d1 is infinite. the problem whether progression of a finite theory in ldlsc is always fo definable remains open.
¡¡now  we consider a  weaker than classical  modified progression for certain type of incomplete kbs only. for this special case of incomplete kbs  we show below that a modified progression of a kb is in ldlsc and it is sound wrt a classical progression of this kb.
¡¡first  we restrict the syntactic form of the kbs that are allowed. we use e to range over ewffs  that is  quantifier-free boolean formulas with equalities and inequalities only. for any vector x that is or a variable x  or y  and any vector of object constants b that is  or a single constant b   we write as an abbreviation for x=b1 ¡Ä y =b1  or x=b  respectively . we use to range over fluent literals  where s is a ground situation term. we call formulas of the form equality-based formulas. we define a cnf-based kb ds =kbi ¡È kbs  where kbi is a set of situation-independent formulas  including unique name axioms for object constants  i.e.  kbi is a subset of ds1   and kbs is a finite set of sentences uniform in s  where each sentence  also called clause below  is a disjunction of finitely many equality-based formulas. in particular  ds1 =kbi ¡Èkbs1. a cnf formula composed from ground fluent literals uniform in s is a simple example of kbs.
secondly  we consider an action theory d that is local-
effect.	let a ssa of a fluent f have the syntactic form
. this
ssa is local-effect if are disjunctions of formulas of the form  where a is a action function  y containsis quantifier-free. an action theory d is local-effect if each ssa
in d is local-effect. let   be + or  . consider a ground action ¦Á and a fluent fi in a local-effect action theory d of language ldlsc   then it is easy to see that the right-hand side  rhs  of ssa for has the following syntactic form:	
  where each m i is a natural number  the variables in x are among x and y  and for each k  ¦Õ ik s  is a propositional formula. this ssa is a special case of the generic ssa  1  from section 1. moreover  according to theorem 1 the problem whether d |= ¦Õ ik s  is decidable for each k and any ground situation s. we define the following abbreviations.

when there is no disjunct satisfying the condition on the context formula ¦Õ ik  the corresponding disjunction is equivalent to ¡Í. it is easy to see that all formulas above are ewffs.
¡¡the intuition behind these abbreviations is simple. for instance  add fi ¦Á s  is a collection of all those cases when fi will become true in every model if the context ¦Õ+ik s  holds in s. therefore  these cases provide support for adding the fluent fi to the new kb. if one takes all those cases when fi ceases to be true in some models
 where contexts might or might not be entailed  and removes from them those cases when negations of contexts are known to be entailed  i.e.  remove models where it is guaranteed that fi will not cease to be true   then as a result one gets delete fi ¦Á s  that represents the collections of all those objects for which fi has to be deleted from the current kb.
¡¡now consider a ground action ¦Á and a cnf-based kb ds = kbi ¡È kbs as the current kb of a local-effect bat d=d ¡È ds. assume that d |= poss ¦Á s   otherwise there is no need in progression. we provide an algorithm to compute a variant of progression  called a modified progression of ds wrt d and the ground action ¦Á executed in s  and denote the resulting kb as p ¦Á ds .
let p ¦Á ds  be the following set of sentences:
1. initialize p ¦Á ds  to
kb
.
1. for each clause in kbs of the form cj = p1 ¡Å¡¤¡¤¡¤¡Åph ¡Å¡¤¡¤¡¤  where each ph is an equality-based formula  is either fi or its negation  fi  we update this clause as follows.
	  a  initialize a temporary setb  for each	t =  .
j	j j into the set t.
  add a new clause;
otherwise  do nothing  i.e.  replace
¡¡it is easy to see that the resulting kb p ¦Á ds  remains to be a cnf-based kb in. therefore  such progression can be repeated for the next ground action  say ¦Á.
the intuition behind this algorithm is simple. the succes-
sor model of the kb after performing a ground action at the current situation should keep all the situation-independent information  add truth values for each fluent for those objects where it will definitely become true  or false   and also keep the remaining consistent information by removing conflicting knowledge for objects from the current kb. note that we detect conflicts between cases supported by ejh and cases included in the delete ljh ¦Á s  condition by using unique name axioms for constants in kbi  if necessary  to solve the entailment problem in  b .

¡¡for any given bat d = d ¡È ds and a ground action ¦Á  we say that a modified progression p ¦Á ds  is  classically  sound if any model of the classical progression of ds  wrt ¦Á and d  is a model of the modified progression. also  we say that p ¦Á ds  is  classically  complete if every model of

d ¡È p ¦Á ds  is a model of the classical progression of ds
 wrt ¦Á and d . the modified progression has the following nice properties.
theorem 1 given a bat d with the current kb ds and a ground action ¦Á then
 1  if d is consistent and rhs of ssas are consistent  then the modified progression p ¦Á ds  is also consistent.
 1  the modified progression p ¦Á ds  is  classically  sound.
proof:  1  prove by cases using the definition of p ¦Á ds .  1  according to the definition of p ¦Á ds   prove that d |= p ¦Á ds  using the rhs of the ssas for.
let m¦Á be any model of the  classical  progression of ds. then  there is a model m of d such that m and m¦Á have a progression relationship. then m is also a model of p ¦Á ds  by d |= p ¦Á ds   and then since m and m¦Á have a progression relationship we can prove that m¦Á is a model of any sentence uniform in do ¦Á s  iff m is a model of any sentence uniform in do ¦Á s . therefore  we conclude that m¦Á is a model of p ¦Á ds  because p ¦Á ds  is a set of sentences uniform in do ¦Á s . 
1 discussion and future work
the major consequence of the results proved above for the problem of service composition is the following. if both atomic services and properties of the world that can be affected by these services have no more than two parameters  then we are guaranteed that even in the state of incomplete information about the world  one can always determine whether a sequentially composed service is executable and whether this composite service will achieve a desired effect. the previously proposed approaches made different assumptions:  mcilraith and son  1  assumes that the complete information is available about the world when effects of a composite service are computed  and  giacomo et al.  1  considers the propositional fragment of the sc.
¡¡as we mentioned in introduction   mcilraith and son  1  propose to use golog for composition of semantic web services. it is surprisingly straightforward to define almost all golog operators starting from our c1 based sc. the only restriction in comparison with the original golog  reiter  1  is that we cannot define the operator  ¦Ðx ¦Ä x   non-deterministic choice of an action argument  because ldlsc regressable formulas cannot have occurrences of non-ground action terms in situation terms.
¡¡the recent paper  baader et al.  1  proposes integration of description logics alcqio  and its sub-languages  with an action formalism for reasoning about web services. we discuss that paper in  gu and soutchanski  1 .
¡¡an interesting paper  liu and levesque  1  aims to achieve computational tractability of solving projection and progression problems. the theory of the initial kb is assumed to be in the so-called proper form  i.e.  conjunctions of equality-based formulas  and the query used in the projection problem is expected to be in a certain normal form. they consider a weaker type of progression defined for proper kbs with local effect actions only and show that their progression is sound  and sometimes complete  wrt the classical progression. we also consider local effect action theories  but our cnf-based kb is a set of disjunctions of equality-based formulas. however   liu and levesque  1  considers a sc formulated in a general fol  where the entailment problem is undecidable  and impose no restrictions on arity of fluents. because of these significant differences in our approaches  it is not possible to compare them.
¡¡it is obvious that all cases from  lin and reiter  1; shirazi and amir  1; liu and levesque  1  when the progression is fol definable also can be applied to our case simply because we restrict the language to two object variables only. however  we do the disjunctive case that nobody did before. also   liu et al.  1  considers update of an abox in a dl following  winslett  1  and also mentions that update can be applied to a boolean abox formulated in c1  but their update is defined in terms of a conjunction of primitive fluent literals  i.e.  it is different from our progression because our update is defined in terms of changes in the theory due to a ground action.  giacomo et al.  1  generalized the update approach of  liu et al.  1  from alc to a more expressive dl language dl-lite which allows general inclusion assertions in tbox   showed that the result of an update is always expressible by a dl-lite abox and provided a polynomial-time algorithm that computes the update over a dl-lite kb.
¡¡the most important direction for future research is efficient implementation of practical scenarios of reasoning in ldlsc . although in general  the worst-case computational complexity for the reasoning problems in ldlsc is high  some practical scenarios may facilitate empirically efficient solutions to the projection and executability problems. we are planning to consider also the progression problem for a more general class of incomplete kbs and conditions when the modified progressions is  classically  complete.
acknowledgments
thanks to the natural sciences and engineering research council of canada and to the department of computer science of the university of toronto for partial financial support.
