 
heuristic search procedures are useful in a large number of problems of practical importance. such procedures operate by searching several paths in a search space at the same time  expanding some paths more quickly than others depending on which paths look most promising. often large amounts of time are required in keeping track of the control knowledge. 
for some problems  this overhead can be greatly reduced by preprocessing the problem in appropriate ways. in particular  we discuss a data structure called a threaded decision graph  which can be created by preprocessing the search space for some problems  and winch captures the control knowledge for prob lern solving we show how this can be done  and we present an analysis showing that by us ing such a method  a great deal of time can be saved during problem solving processes. 
1 	introduction 
heuristic search procedures are useful in a large number of problem domains. most heuristic search procedures  for example. a*. sss*  b*  ao *  and alpha beta  have been shown to be special cases of best first branch-and--
bound search   v. kumar and l. kanal   1  nau i1 . these procedures search several solution paths at the same time  expanding some paths more quickly t han others depending on which paths look most promising. 
   one source of computational overhead during such search is the time spent keeping track of the alternate partial solutions that the procedure is examining. typically  the search algorithm stores these partial solutions on a list called the agenda  open list  or activelist  in order of their estimated cost. any time a new partial solution is generated  its estimated cost must be compared with the estimated costs of the other partial solutions already on the list  in order to find the appropriate place 
   *this work was supported in part by an nsf presidential young investigator award  with matching funds provided by texas instruments and general motors research laboratories  and in part by nsf grant nsfd cdr-1 to the systems research center. 
dana s. nau* 
computer science department  
institute for advanced computer studies  and systems research center university of maryland 
	college park  maryland 	1 
to put it on the list. thus  significant computational overhead is required just to maintain the active list. 
   certain problem domains have special properties which allow us to eliminate this overhead. in particular  in some problem domains it is possible to do automatic preprocessing or  compiling ' of the search space  to extract control knowledge which can be used to do the heuristic search without having to maintain the active list explicitly. in this paper  we discuss what kind of domains allow us to do such preprocessing  how to do the preprocessing  how to use the information gat tiered from the preprocessing  and how much time can be saved by doing this preprocessing. we also present an example from a problem domain of part icular interest to us: generative process planning for the manufacture of machined parts. 
	1 	problem characteristics 
preprocessing of the search space is possible whenever the following conditions are satisfied; 
1. with the exception of feasibility/infeasibility of nodes  the search space has the same shape regardless of the particular problem instance being considered. thus  if p and p1 are two problem instances  then there is a one-to-one mapping between the nodes of their search spaces s and s'  such that if some feasible node a in s has n children b1 / = 1 . .n. then its corresponding node a' in s' will either have n children b1 for i - 1 . n such that b  corresponds to b1 or be infeasible. 
1. corresponding nodes need not have the same- cost but if two nodes a and b in s1 have- cost a    cost b   then for the corresponding nodes a1 and b1 in v. we must have cost  a1    cost. b1 . 
   nearly all heuristic search problems satisfy the first condition a.bove  but fewer satisfy the second one. how ever  there are still many problems which do satisfy it. one- example is generative process planning for the manufacture of machined parts. in our generative process planning system sips . au   1   a machinable part  is considered to be a collect-ion of machinable features. for each feat.ure  sips finds an optimal plan for that feature via a best-first branch-and-bound search in its knowledge base. sips's knowledge base- consists of information on a large number of different machining processes. 
	yang and nau 	1 
organized in a taxonomic hierarchy. for two different machinable features  different machining processes may have different costs-but if process a costs more than process b on feature /  it generally also costs more than process b on feature /' as well. 
　robotic route planning t. a. linden and j. clicksman   1  is another problem domain which also satisfies the second condition. in this domain  a route map corresponds to a graph  in which a node represents a region and an arc represents connectivity between two regions. the cost of a node can be the time needed to pass through the region it represents  and the feasibility of a node indicates whether or not the region is passable. in general  although the passability of a region may change from one problem instance to another  the relative costs of the regions stay the same. in such cases  preprocessing is possible. 
1 	threaded decision graphs 
suppose that for a given problem instance the search space is as shown in figure 1. the goal is to search for the cheapest leaf node for which all the nodes along the path from the root are feasible. in figure 1  suppose the problem solver is checking the conditions associated with node r. if c succeeds  we know that the next node to check will be /  since c must be the current minimum costly node to be checked  and f's cost is the same as rs. similarly  if c fails  the next node to check in the search space must be j. this is because at the time r is being checked  nodes a  1  d  e h and k must all have been checked  since they all have costs less than that of c's. control information like this is independent of the particular problem instances  and can be gathered before the problem solving process starts. therefore  we can assign a success thread from node r to node /  and failure thread from c to j. during the course of finding the cheapest actions to achieve a given goal  once we reach node c  if all the conditions are satisfied  we can follow the success thread of c to get to the next node to be checked. on the other hand  if they are not satisfied  then the failure thread at c can be followed to get to the next node to be checked. figure 1 shows such a structure. 
　if all the deterministic control information is gathered  it is no longer necessary to maintain an active list for storing control information. before problem solving starts  the information can be used to construct a data structure that contains one or more occurrences of each action  and for each action occurrence there is a success pointer and a failure pointer. we will call such a 
　data structure a threaded decision graph of the original search space. problem solving can then be completely guided by its threaded decision graph. figure 1 shows the threaded decision graph for the search space in figure 1. 
　two special nodes in figure 1 are worth noting. the node marked  success  is called a success node. if this node is reached through the success threads  the search process terminates with success. the path from the root node to success in the threaded decision graph contains the solution path which should be returned. the node marked  fail  is called a failure node  which marks the termination of the search process without success. 
　in the following  we first discuss in detail how problem solving is done with the help of threaded decision graphs. we then consider how such a data structure could be automatically constructed. 
1 	search with the threaded decision graphs 
 liven a search space  assume that we have constructed its threaded decision graph. a request to solve the problem would correspond to finding out the cheapest path in the tree. for the given threaded decision graph  this is done by checking the conditions associated with each node  starting from the root node. the success thread of the current node should be followed if the node is tested to be feasible  and the failure thread should be followed if it is infeasible. each node is also marked as  success  or  failure  depending on the result of its feasibility test. 
　if  during the traversal process  a success node is reached via a success thread  then the search ends with success. 


1 	automated deduction 
 fiqure 1: the search space in figure 1 with threads inserted at node c. the thick solid line is c's success-thread  and the thick dotted line its failure-thread. 

figure 1: the threaded decision graph for the search space in figure 1. in this figure  solid lines represent success threads  while the dotted ones the failure ones. 
	yang and nau 	1 

　if a failure node is reached through failure thread  then no actions satisfying the criteria exist. in this case  
search is terminated with failure. 
　after tracing down the failure thread of some node  it is possible to reach some other node whose ancestor in the original search tree failed the feasibility test. for ex ample  suppose node b in figure 1 is infeasible and node / is being checked. if / is infeasible then the next node to be checked should be j. since b is an ancestor of j which failed  no feasibility test need be done at j  and the failure thread of it should automatically be followed. in general  whenever a node n is reached via some fail lire thread  it should always be checked to see if n has any ancestor m which failed the feasibility test. if so  the failure thread of node n should be followed  without conducting its feasibility test. 
　to check if a given node has any infeasible ancestor is straightforward: we can retrieve the traversal information associated with the parent node of the given node in the original search space. it has an infeasible ancestor if its parent node is unvisited or marked as infeasible. 
1 	very large or infinite search spaces 
if the search space is very large  the time it takes to preprocess it may be prohibitive. in such cases  and in cases when the search space is infinite  we can preprocess a finite portion of it. this partial threaded decision graph can be created by running the algorithm construct for a finite number of iterations  until one or more goal states appear in the graph. 
　during the problem solving process  the threaded decision graph can be used in the same maimer as described in the previous sections  until a node which has no success and failure threads is reached. at this point  con ventional branch and-bound search can be utilized as follows: an active* list is constructed by including all of the successor nodes of the current node and the children of the feasible nodes along the path back to the root  node in the state space. this list is sorted according to the costs of its nodes  and least  costly of these is expanded. 
　the construction of the threaded decision graph may also be done with the following strategy; during search through the search space for each particular problem in-

1 the construction of threaded decision graphs 
in this section  we consider the problem of how the threaded decision graphs are constructed. for simplicity  we assume the search space is finite. later we will discuss cases where the search space is not finite. 
   with the above restrictions  the following algorithm generates the threaded decision graph. this algorithm is a modified version of best-first search. 

   during preprocessing of the search space  each node in the tree appears at the head of the active list once and only once  and the resultant threaded decision graph has the same number of nodes as the original search space. since every node has only two threads  the suc cess and the failure threads  the number of threads of the threaded decision graph is twice the number of nodes as that of the search space. the same argument also guar antees the absence of cycles of threads. 
1 	automated deduction 
stance  every time a node is tested we' will look for its success or failure threads. if they do not exist  we will use the search procedure to find out which node we should test next. the success or failure threads can then be assigned to this node. in other words  the threaded decision graph is partially built on the job. 
1 	analysis 
by gathering all the possible static control information beforehand  preprocessing of the search space can greatly improve problem solving efficiency. in order to see this claim more quantitatively  consider a simplified example. assume that the search space is in the shape of a tree with a branching factor of m and depth k  the root of the tree has a depth of 1  to see how much time the problem solver spends on manipulating the list of incomplete paths using conventional search methods  consider the following two extreme cases. 
   in the best  case  the search procedure expands only one path down the tree the time for manipulating the active list is o{km log m . 
   in the worst case  the search procedure expands the tree in a breadth first manner. the total time spent on manipulating the list in this case is bounded by in x 

   on the other hand  search with a threaded decision graph is guided completely by the success and failure threads  and no additional computational effort is needed for manipulating the search control information. therefore  the time saved by using the threaded decision graph to guide the search procedure can be between 
o km log m  and  where k is the depth of the tree and m; is the branching factor. 
1 	discussion 
in this paper we presented a technique for preprocessing search spaces in order to gather control information for 

problem solving. we also discussed a number of conditions under which the method works. through complexity analysis  we demonstrated that by using preprocessing  a great deal of computational effort is saved during the search process. 
   our idea of preprocessing search spaces has some similarity to that of threading of binary trees for tree traversal knuth  1 . however  the way such threading is done  and the way it is used  are both clearly different from our threaded decision graphs. 
   as described in the paper  our technique only works on state-space graphs. an extension of the work is to allow the search space to be an a n d / o h graph. when a n d branches are allowed  the problem can be very complicated depending on how the costs are assigned its nodes. in the worst case  the threaded decision graph can contain an exponential number of the occurrences of nodes in the original search space. an example of this situation is given in figure 1. the problem is that the ith and /' -f ith best  paths  for i = 1  . . .  are not next to each other  but on the left and right subtrees respectively. one way to tackle t his problem is to partially preprocess the search space. for example  we ran assign success and failure threads only to the nodes winch are in the first k best paths 
　another problem which needs more attention is that the relative costs of some nodes in different problems may not be the same  but may change with different situations. however  if the cost of nodes change with different situations in some predictable manner  and if the number of such changes is finite  the preprocessing technique can still be made to work. for example  it may be possible to divide the situations into separate classes  each with a different threaded decision graph. many domains satisfy this property  including process planning in automated manufacturing and robotic path planning 
