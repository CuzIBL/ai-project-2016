
the quantified constraint satisfaction problem
 qcsp  is a generalisation of the classical csp in which some of variables can be universally quantified. in this paper  we extend two well-known concepts in classical constraint satisfaction to the quantified case: problem relaxation and explanation of inconsistency. we show that the generality of the qcsp allows for a number of different forms of relaxation not available in classical csp. we further present an algorithmfor computinga generalisation of conflict-based explanations of inconsistency for the qcsp.
1 introduction
one of the disadvantages of the classical csp framework is that it lacks sufficient expressive power for modelling particular aspects of real world problems  for example  uncertainty or other forms of uncontrollability in the environment in which a set of constraints must be satisfied.
　in this paper we are concerned with the quantified csp  a generalisation of the classical csp that allows some of the variables to be universally quantified  chen  1 . the semantics of universal quantification over a variable is that the set of constraints must be satisfiable for any assignment to it. this is in contrast with classical csp  where all variables are existentially quantified  i.e. any assignment to an existentially quantified variable that satisfies the constraints is satisfactory. while the classical csp is known to be np-complete in general  the qcsp is pspace-complete  chen  1 . we consider the problem of relaxing an instance of the qcsp when it is  forexample  unsatisfiable. we proposeseveral novelforms of problem relaxation for the qcsp and present an algorithm for generating conflict-based explanations of inconsistency.
　our motivation comes from problems in conformant planning and supply-chain management. we are interested in using constraints to support the local decision-making processes of a company that must supply products to a set of customers  while managing a complex network of its own suppliers. classical csp is not sufficiently expressive to model this type of problem concisely  since some of the variables are not under the control of the decision-maker  but we can model the problem as a quantified csp. the parallels between adversarial games and qcsp are natural: we can model variables under our control using existential quantifiers and those variables outside our control using universal quantifiers  chen  1 .
　the remainder of this paper is organised as follows. in section 1 we present a formal definition of the fundamental concepts in constraint satisfaction and the quantified csp. we present several new forms of problem relaxation in section 1 that have previously not been considered due to the literature's focus on classical csp. we show how these forms of relaxation can be captured using the notion of requirement relaxation. section 1 presents an approach to generating explanations of conflict in quantified csp based on requirement relaxation. we show how an existing explanation generation algorithm for classical csps can be extended to the quantified case. we review the most related work in section 1. a number of concluding remarks are made in section 1.
1 preliminaries
definition 1  classical constraint satisfaction problem 
a constraint satisfaction problem  csp  is a 1-tuple where x is a finite set of variables
　　=  {x1 ... xn}  d is a set of finite domains d =  {d x1  ... d xn } where the domain d xi  is the finite set of values that variable xi can take  and a set of constraints c =  {c1 ... cm}. each constraint ci is defined by the ordered set var ci  of the variables it involves  and a set sol ci  of allowed combinations of values. an assignment of values to the variables in var ci  satisfies ci if it belongs to sol ci . a solution to a csp is an assignment of a value from its domain to each variable such that every constraint in c is satisfied.
a fundamental notion used in reasoning about classical csps is that of arc consistency  mackworth  1 . due to logical conjunction  any assignment to the variables that is locally inconsistent with a constraint is guaranteed not to be part of any consistent solution.
　in the classical csp we can regard all variables as being existentially quantified: we wish to show that there exist assignments for each of the variables that satisfy all constraints simultaneously. however  we can generalise further by also allowing variables to be universally quantified.
definition 1  quantified csp  a qcsp  φ  has the form
q.c = q1 （ d x1 ，，，qnxn （ d xn .c x1 ... xn 
where c is a set of constraints  see definition 1  defined over the variables x1 ...xn  and q is a sequence of quantifiers over the variables x1 ...xn where each qi  1 ＋ i ＋ n  is either an existential     or a universal     quantifier1. the expression  xi.c means that  there exists a value a （ d xi  such that the assignment  xi a  satisfies c . similarly  the expression  xi.c means that  for every value a （ d xi  
 xi a  satisfies c .
definition 1  semantics of qcsp   based on  gent et al.  1   we define the semantics of the qcsp  q.c  recursively as follows. if c is empty then the problem is true. if q is of the form  x1x1 ...qnxn then q.c is true iff there exists a value a （ d x1  such that q1 ...qnxn. c“{x1 = a}  is true. if q is of the form  x1x1 ...qnxn then q.c is true iff for every value a （ d x1  such that q1 ...qnxn. c “ {x1 = a}  is true. otherwise  q.c is false.
example 1  quantified csp  consider a qcsp defined on the variables x1 and x1 such that d x1  = d x1  = {1 1} as follows:  x1 x1.{x1   x1}. this qcsp is false. this is because for any value for variable x1 there is at least one value in the domain of x1 that is inconsistent with it. 
　the above deals only with the equivalent of the decision problem for qcsps; the analogous treatment for exemplification requires consideration of a winning strategy generalising the idea of a solution  chen  1 . of course  the order of the quantifiers in a qcsp is critical. consider the following qcsp:is false  while
 true.
1 relaxation
our motivation for studying relaxations of the qcsp relates to the observation that many real world problems are overconstrained. accordingly  we are often interested in relaxing the constraints of the problem so that we find a solution that is at least relatively satisfactory. in this scenario  problem relaxation can be seen as a way of exploring the space of alternative models for a given problem. furthermore  problem relaxations give us a language with which we can explain the over-constrainedness of a problem. moving from classical csps to qcsps provides us with a richer class of relaxations  and hence  a more expressive language for explanations.
　one of the most well known frameworks for reasoning about problem relaxation in classical csp is partial constraint satisfaction  freuder and wallace  1 . one can identify four possible ways of relaxing a classical csp: the domain of a variable can be enlarged; the relation of a constraint  the set of allowed tuples  can be enlarged; a constraint can be removed from the problem; or  a variable can be removed from the problem. note that all of these strategies can be regarded as enlarging domain or constraint relations.  and domains can themselves be formulated as unary constraints.  while all of these forms of relaxation are available to us in the
qcsp  the additional expressiveness we have access to within the qcsp gives rise to new forms of relaxation that are not available in classical csp.
1 relaxation for the quantified csp
a useful viewpoint to adopt when studying the qcsp is to consider an instance of the problem as an adversarial game between two players: a universal player who sets the universally quantified variables  and an existential player  who sets the existentially quantified variables  chen  1 . in these terms  we can regard relaxations of the qcsp as modifications to the problem that make it easier for the existential player to win. from the perspective of the universal player  a relaxation of the qcsp may restrict the ways in which this player can falsify the formula. for example  we can restrict the domain of values of the universally quantified variables. from the perspective of the existential player  a relaxation increases the set of responses that can be played to counteract the choices of the universal player. we proceed by discussing five classes of relaxation that are available in the context of the qcsp. while the first two of these are familiar from csp  the remaining three are particular to the more expressive framework  and have no direct equivalents in the unquantified case.
single constraint relaxation. this is the type of relaxation equivalent to that normally considered in classical csps. for example this is the classical approach in the pcsp framework in which allowed tuples are added to an extensionally represented constraint. in principle  this may be replacing a constraint with any logically weaker one. as mentioned earlier  complete removal of a constraint may be considered as a special case of this type of relaxation.
example 1  single constraint relaxation  consider	the following qcsp  which is false:
 x1 （ {1} x1 （ {1 1}.{x1   x1}.
if we relax the constraint between x1 and x1 from   to ＋ to get the following:
　　　　 x1 （ {1} x1 （ {1 1}.{x1 ＋ x1}  the qcsp becomes true. this is because if the existential player sets x1 to 1  the universal can no longer find an assignment that falsifies the qcsp. 
relaxation of existentially quantified domains. enlarging the domain of an existentially quantified variable is the direct equivalent of relaxing domains in the classical framework.
example 1  relaxation of existential domains  we revisit the qcsp presented in example 1. this is false because the scenario in which the universal player sets x1 to 1 is available. to counter this  the existential player must be able to play a value that is smaller than 1. a suitable relaxation is the following  which adds the value 1 to the domain of x1:
 x1 （ {1 1} x1 （ {1 1}.{x1   x1};
the relaxed qcsp is true since the existential player can set x1 to 1 and the universal player cannot falsify the formula.  relaxation of universally quantified domains. a class of relaxation not corresponding to any in classical csps is to remove values from the domains of universally quantified variables. doing so reduces the number of scenarios under which the existential player must find satisfying assignments for the existential variables  leading to a more satisfiable problem. the rationale for this may be an analysis of which 'problem values' it may be permissible to ignore  or the narrowing of a range with a probabilistic interpretation.
example 1  relaxation of universal domains  returning to the qcsp of example 1  which is false  due to the availability of the assignment of x1 to 1  for which the existential player has no satisfying counter-assignment. however  if we relax the domain of the universally quantified variable x1 so that it no longer contains the value 1 to get the following:
 x1 （ {1} x1 （ {1}.{x1   x1};
the relaxed qcsp is true since the existential player can set x1 to 1 and the universal player cannot falsify the formula. 
quantifier relaxation. a fourth form of relaxation  also with no direct equivalent in classical csp  is to reverse the quantification of a variable from universal to existential. this relaxation corresponds to achieving control over a factor previously considered to be environmental. this further relaxes the universal domain relaxation.
example 1  quantifier relaxation  we revisit the qcsp presented in example 1  which is false. if relax the universal quantifier on variable x1 to be existential to get:
 x1 （ {1} x1 （ {1 1}.{x1   x1};
the relaxed qcsp is true.	
quantifier moving. a fifth class of problemrelaxation corresponds to moving a universally quantified variable to the left in the sequence of quantifiers. equivalently  we can consider moving an existentially quantified variable to the right in the sequence of quantifiers. this corresponds to analysis or oracular knowledge of the value of an environment variable  or of delaying a decision until better information is available.
example 1  quantifier moving  we consider an example  based on one presented earlier in this paper. the following qcsp is false:

we relax this problem by moving the universally quantified variable to the left to give the following qcsp which is true:

informally  the relaxed qcsp gives the existential player the opportunity to react to the actions of the universal player. 
　it should be noted that whether each of these relaxations is sensibly possible for a given application is a modelling or knowledge engineering question. in each case  a given constraint  domain  or quantifier may be inherent to the problem  or  background   and thus not susceptible to relaxation.
　we claim that this set of relaxations is comprehensive  unless reformulation of the original problem is considered in conjunction with relaxation . it is also orthogonal  if we apply quantifier relaxation only in the case where the domain is a singleton  in the sense that all possible single-step relaxations result in problems that are mutually incomparable.
1 qcsp relaxation as requirement relaxation
we now present a uniform treatment of the relaxation of both quantifiers and constraints  that is  the first four classes of relaxation we identify above. requirements correspond to either a constraint in the qcsp  or a universal quantifier  and we frame relaxation of each as instances of requirement relaxation  over a partial order defined for that purpose.
definition 1  relaxation of a qcsp  we define the relaxation φ r  of a qcsp φ to a relaxed version of a single requirement to a new value  r  as follows:

　　　　　　　; .
this can then be extended to a set of relaxations r: φ    = φ  φ {r} “ r  =  φ r   r .
definition 1  ordering over requirement relaxations 
given the set of possible relaxations  r r   of a requirement
r  we say that  iff for any problem φ  if φ r1  is satisfiable then φ r1  is  necessarily. we further require that this partial order also be a meetsemilattice  i.e. that greatest lower bounds are guaranteed to exist: if r1 r1 （ r r   then is well-defined.
　the ordering operator and property we use to make formal the notion of relaxation per se: if   then we say that r1 is a  strict  relaxation of r1. the greatest lower bound corresponds to the unique requirement relaxation which is as constraining as both of its arguments  but no more  that is  the greatest such element of the relaxation space . the lattice property follows naturally from the relaxation spaces we shall define  and is motivated by the observation that we progressively tighten approximations downwards  and that our relaxation spaces must have a unique least element. for clarity in that respect  we will define the meet operator directly.
the partial order may be defined as  and we note that in each case it is straightforward to derive a closed form for the comparison.
　we now define the space of relaxations for constraints  the first form of relaxation we identified above. essentially  a relaxation of a constraint involves adding additional allowed tuples into its relation.
definition 1  requirement relaxation for constraints 
given a constraint we define its relaxations in terms of adding additional allowed tuples to sol c  as follows:
.
the elements of r c  form the usual lattice using intersection  that is .
we now consider universal quantifier relaxation. informally  the space of possible relaxations for a universalquantifier corresponds to restricting the quantifier to any one of the exponentially many subsets of the domain of the quantified variable  narrowing to a single choice of value  and thereafter widening to existentially quantified subsets. it therefore corresponds to the second  third and fourth forms of relaxation identified in section 1. of course  in practice  one can limit this relaxation space to a subset of tractable size.
definition 1  requirement relaxation for universals 
given a requirement  r  on a universally quantified variable x  i.e. r =   x （ d x   the set of relaxations r  x （ d x   is defined as:
.
the elements of r  x （ d x   form the following meetsemilattice:
   ;
   ;
;
note the existence of unique top and bottom points  corresponding to trivially- and un-satisfiable quantifications:
  x （    〕 =   x （   .
　we can now define the space of possible relaxations of a given qcsp in terms of its constituent requirements in the natural way  in terms of the cross-product of the available relaxations for each  and similarly the associated comparison and meet operations.
　before we consider how explanations of falsity can be computed using relaxations  we consider two special cases of relaxation: namely  1-point and 1-point relaxation spaces. the former  which we denote by r1  contains only the original constraint itself  and is useful when we wish to ensure that some constraints or quantifiers cannot be relaxed. the latter  r1  contains both the original constraint  and   the maximal relaxation; it is useful when we wish to model the case where we either maintain the requirement or completely relax it.
1 from relaxations to explanations
we now consider explanations for the qcsp. a familiar notion of explanation is that based on minimal conflicts  junker  1 . as we have considered quantification  which is not readily presentable in terms of elements of a conflict set  and further  more general relaxations of constraints than their removal  it is necessary to generalisethis notion to that of a minimally conflicting explanation  or alternatively  a maximally relaxed conflict-based explanation. we will henceforth refer to these as maximal  following the relaxation ordering previously defined. we define this notion with respect to a  typically incomplete  consistency propagation method Π  such as qac  bordeaux and monfroy  1   in a similar way to junker  junker  1 .
definition 1  maximally relaxed explanation  given a consistency propagator Π  a maximally relaxed  Πconflict-based  explanation of a Π-inconsistent qcsp φ  is a maximally relaxed qcsp  x  that is inconsistent with respect to Π; i.e. such that and for all x such that.
1 explanation algorithms
we adopt a scheme similar to that of the quickxplain 'family' of algorithms  junker  1; 1   modified and extended in the following way. we replace the removal  respectively  addition  of a constraint with a specified requirement relaxation  resp. tightening . the specified relaxations form a semilattice  as described in the previous section. this could  in principle  be every possible relaxation  but at a minimum we generally wish to consider the specified relaxations corresponding to the removal  resp. imposition  of each constraint  and the relaxation of a universal quantifier to an existential one: that is  corresponding to relaxation space r1. we may further restrict the set of specified relaxations on the basis that some constraints  and some variables  are intrinsically environmental  and that they should participate in every explanation; this corresponds to using relaxation space r1.
　as consideration of every possible relaxation is in general completely intractable  it will generally be desirable to specify a much smaller set. this may be done in broadly two ways. firstly  as part of the modelling process  an expert specifying the class of problem instances under consideration can give the sets of possible requirement relaxations that are meaningful. secondly  we can consider a user-driven refinement step  after initial exploration of the available explanations  based on a base step choice of available relaxations  when these have been found to be unsatisfactory.
1 the simplequantifiedxplain algorithm
when the set of specified relaxations are binary  i.e. requirements are either in place or fully relaxed  we can use the equivalent of junker's algorithms  modified simply to use  instead of the imposition and removalof a constraint  the choice between the original and relaxed requirement throughout. we firstly reformulate junker's replayxplain  junker  1  in terms of relaxations in algorithm 1  thereby generalising it to qcsps with  at most  one distinct relaxation available for each of the original requirements  i.e. a requirement is either present  or fully relaxed. we call this modified procedure
simplequantifiedxplain. we provide as arguments φ  a
qcsp  and r  a set of available relaxations  which here should only contain the greatest relaxations allowed for each requirement  ri  that is relaxable in the specified relaxation rs  i.e.
.
 this is only well-defined for spaces with a unique maximal relaxation.  we begin with a maximally relaxed problem  using all of the available relaxations r  then build a working set w of relaxations we then iteratively omit  until a Π inconsistency occurs. at that point we conclude that the relaxation r last added to w  that is  last removed from the subproblem  can be added to a set x corresponding to a partial conflict  and that no further relaxations need to be considered  as some subset of w must be minimal  and still yield an inconsistency. we iteratively continue doing this until the set of possible further relaxations is exhausted  at which point x can be used to relax the original problem φ to yield a maximally relaxed inconsistent problem  φ r   x   which is our explanation.
algorithm 1: simplequantifiedxplain φ r 

	input : a	φ; a set of available single-step relaxations
	1 ... 	n+m .
output: a maximally relaxed conflict-based explanation for φ.
if 〕 （/ Π φ  then return exception  no conflict ; if r =   then return φ;
x ○  ; r1 ○ r;
whiledo w ○  ;
while 〕 （/ Π φ r    x “ w    do select  any  r from r1;
w ○ w “ {r};
r1 ○ r1   {r};
x ○ x “ {r};
   r1 ○ w   {r}; return φ r   x ;

　note that we do not  as with replayxplain and junker's other explanation procedures  split the input into background and user constraints  and nor do we restrict the output to only user constraints  since the syntax of quantified problems precludes us from doing so. we are instead able to designate some constraints and some quantified variables as not relaxable  which then can be regarded as playing the same role as background constraints. thus implicitly  user requirements must have at least one available relaxation. one difference in the form of this algorithm is that the 'background' constraints are included in the explanation. background constraints may be removed from the output after the fact if desired. observe that the two are equivalent in this sense: if
replayxplain  c  u  = x  and simplequantifiedx-
plain   and xq = x “c.  assuming similar ordering of relaxations  constraints  in each case.  the remaining algorithms presented by junker may be reformulated in terms of relaxations similarly.  discussion of the correctness and complexity of this algorithm is deferred until after the presentation of quantifiedxplain  of which it is a special case. 
example 1  simplequantifiedxplain  consider the execution of simplequantifiedxplain φ r   where φ =   x1 （ {1} x1 （ {1 1}.{x1   x1} and r = 
  a trace of the progress of which is shown in figure 1. note that in this case  the explanation is unique  and identical to the original problem  as no relaxation is possible without introducing consistency. had different choices of relaxations been made  a different trace would have occurred  but the same final result. 
1 the quantifiedxplain algorithm
we now consider quantifiedxplain  algorithm 1   a more general algorithm allowing for requirement relaxation
φ1 = φ r    x “ w  〕 （ Π φ1   x1 （ {1} x1 （ {1 1}. no x1 （ {1} x1 （ {1 1}.{x1   x1}no x1 （ {1} x1 （ {1 1}.{x1   x1}yes x1 （ {1} x1 （ {1 1}. no x1 （ {1} x1 （ {1 1}.{x1   x1}yesfigure 1: simplequantifiedxplain: trace on example 1.
lattices of arbitrary size. once again we follow the basic structure of replayexplain  but now the key difference is that instead of successively adding constraints to a conflict set  or as in simplequantifiedxplain  removing available relaxations   we instead consider a current candidate relaxation comprising one element from each relaxation space  r1 ...rm+n  and use  to obtain successive approximations to a maximally relaxed explanation. we begin with a maximal relaxation of each requirement  and then progressively tighten these one at a time: we select an i such that ri may be assigned a new value strictly less than the old one  tightening by a minimal amount at each step to ensure maximality of the final relaxation of the whole problem. when an inconsistency is detected  we eliminate all relaxations tighter than or incomparable to the current approximation from future consideration  as unnecessary for a maximally relaxed explanation. at the same time  we restrict the relaxation space for the last-relaxed requirement  ri  to ensure that that requirement may not be as relaxed as the earlier value   that did not produce an inconsistency  as we have guaranteed that that value cannot take part in the explanation currently under construction. we then repeat this process with the relaxation spaces so restricted  until eventually only one possibility remains for each relaxation  thus fully determining the chosen explanation. the complexity of this algorithm  and that of simple-
quantifiedxplain  is equivalent to that of junker's re-
playxplain  given a consistency operator of similar complexity  and similar numbers of available relaxations. however  in the qcsp case  there is scope for each of those to be significantly larger.

algorithm 1: quantifiedxplain φ r 

input : a qcsp φ; a set of relaxation spaces for each quantifier and constraint  r   r φ . output: a maximally relaxed conflict-based explanation for φ.
if 〕 （/ Π φ  then return exception  no conflict ; enumerate r as r1 ...rm+n; if  i （  1 m + n |ri| = 1 then return φ; while  i : |ri|   1 do
foreach ri do choose an ri from maxima ri ; then return φ;
while 〕 （/ Π φ {r1 ... rm+n}   do choose an	;
;
	choose an ri from maxima	;
;
	foreach	;
return φ {r1 ... rm+n} ;

example 1  quantifiedxplain  consider the qcsp φ =   x1 （ {1} x1 （ {1 1}.{x1   x1} and the execution of quantifiedxplain on φ with the following relaxation spaces: r   x （ {1} ; r   x （ d x    =
         ; and. we give a trace of quantifiedxplain in figure 1. 
φ1 = φ {r1 ... rm+n} 〕 （ Π φ1  x1 （ {1} x1 （ {1 1}. no x1 （ {1} x1 （ {1}. no x1 （ {1} x1 （ {1}.{x1 ＋ x1}no x1 （ {1} x1 （ {1}.{x1   x1}yes no yes
figure 1: quantifiedxplain: trace on example 1.
　the proof of correctness of quantifiedxplain relies on the following properties  analogous to  junker  1 :
property 1 if each relaxation space has a unique top element  and  then the only maximally relaxed explanation is.
property 1 if 〕 （/ Π φ {r1 ... rm+n}    for all maximal ri  then no conflict exists  and thus no explanation.
property 1 if 〕 （ Π φ ri    and x is a maximally relaxed explanation for φ  given the relaxation spaces
  then x is also a maximally relaxed explanation for φ given the relaxation spaces
r1 ...ri ...rm+n  where.
property 1 if 〕 （ Π φ ri   and  where ri 
  then if x is a maximally relaxed explanation for φ  given the relaxation spaces   then x is also a maximally relaxed explanation for φ given the relaxation spaces r1 ...ri ...rm+n  where.
theorem 1  maximally relaxed explanations  if 〕 （ Π φ   and r is a set of available relaxations of some  all or none of the requirements of φ  and quantifiedxplain
 φ  r  = x  then: 〕 （ Π x   and if for some r （ r such that  then.
1 related work
benhamou and goualard studied quantified interval constraints  with engineering applications in mind  benhamou and goualard  1 . more recently  researchers have begun to study how classical csp concepts such as arc-consistency  satisfiability and interchangeability can be extended to the qcsp  bordeaux et al.  1 . a number of techniques for solving the qcsp have been proposed based on encodings to qbf  gent et al.  1   as well as using a systematic qcsp solver  called qcsp-solve  directly  gent et al.  1 . a variety of repair-based methods have also been proposed  stergiou  1 . a deep study of the complexity of the qcsp is also available  chen  1 . our work on relaxation and explanations is the first on these important aspects of reasoning about qcsps.
1 conclusions and future work
we have extended the concepts of problem relaxation and explanation of inconsistency to the qcsp. we showed that the generality of the qcsp allows for the definition of a number of different forms of relaxation not available in classical csp. we presented an algorithm called quantifiedxplain for computing minimally conflicting explanations for qcsps. our work on relaxation and explanations for the qcsp is the first study on these interesting and practical aspects of quantified constraint reasoning. we plan to extend the explanation algorithm to deal uniformly with the final class of relaxation  that of quantifier moving  and to establish complexity comparable to junker's quickxplain algorithm. another important area is that of preferred explanations with which it would be possible to improve the situation presented here  where an arbitrary explanation is generated from those possible.
acknowledgements. this work was supported by science foundation ireland  grant 1/ce1/i1 . we thank hubie chen  helene fargier and nic wilson for their comments.
