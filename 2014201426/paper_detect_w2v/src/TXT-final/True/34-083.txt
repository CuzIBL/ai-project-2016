 
the paper describes magma-lisp  an extended lisp system proposed as an implementation tool for a . i . languages exploiting nondeterministic techniques. the main idea informing magma-lisp is that a tree structure of conceptually indipendent computation environments  contex tree  is the supporting struc ture of any nondeterministic system. magma-lisp proposes this structure in a quite virginal form  so that the user can state his own techniques to prune  select and explore the available alternatives. in this sense  magma-lisp is to be viewed as 
a  machine language . 
the ideas of magma-lisp are contrasted with the systems that most influenced its design. the tech-
nique used in context implementation is described  showing how a very flexible context mechanism can be realized without an intolerable loss of efficien cy. in particular  in spite of the complexity of the system  garbage collection does not result much 
more time consuming than in standard lisp systems. 
1. introduction 
　　　many original features  embedded in the languages developed for a . i . so far  involve nondeterminism  1 1 . in fact  features like  pattern directed procedure invocation  and  associative data-base retrieval  give rise to situations in which many possibilities are open for the computation to proceed. such a feature is typical of nondeterministic procedures  which are characterized by the presence of choice points  where the subsequent actions are not univocally determined. 
　　　the nondeterministic behaviour of a . l . systems has been f i r s t realized by automatic backtracking. 
different alternatives are attempted one by one. whenever one f a i l s   the state of the computation is automatically restored as it was before the last choice was done  and a new one is attempted. as a matter of terminology  we say that each alternative is attempted in a newly created context  while the context in which the choice point has been encountered is  frozen  to maintain the state of the computation as when the attempt begins. 
　　　automatic backtracking  although superficially attractive  turns out to be not adequate to face the main problem with a . i . programming: that is  the ability to prune the open alternatives  hopef u l l y be exploiting informations gathered during the execution of the program i t s e l f . in fact  pure backtracking forbids the programmer's intervention in the choice policy  limiting the system to an ex haustive search of a l l the possibilities and leading to inefficient computations. a few features  like failure messages  have been proposed since planner design  1   to override this handicap. anyway  a really satisfactory solution seems to reside in the design of languages in which the programmer can state his own rules to prune  select and explore the alternatives. from this viewpoint  the a b i l i t y of transferring informations from the context of an alternative to another one turns out to be particularly important. it is this a b i l i t y   indeed  that allows to state rules not based upon a-priori knowledge only  but also upon informations gathered at run-time. magma-lisp has been designed in order to provide a nondeterministic programming frame in which these requirements are satisfied. 
   systems aiming to solve the above problem have been already proposed and realized. it is convenient to discuss briefly some characteristics of the systems that most influenced the design of magma-lisp  in order to contrast it with them. 
   bobrow and wegbreit  1  proposed a very   f l u i d   control structure that surely allows the user to define his own heuristics and policies. there is no notion of context  in the sense of a b u i l t - i n a b i l i t y to save the state of computations. the system provides instead a mechanism to save the continuation point and the anonymous partial results of procedure activations  while the user is in charge of restoring the state of the data base. 
   conniver  1  provides a b u i l t - i n mechanism cno text frame  to save and restore the data base i n crementally  supported by a control structure similar to that of bobrow and wegbreit. the gene♀ ation and the deletion of context frames are asso  ciated with procedure invocations and returns. the restoring mechanism appears  therefore  on the same level of the contrql structure  while  more generally  it should be able to save and restore the control structure i t s e l f . 
   both systems appear to lack the mechanism that  s t r i c t l y speaking  characterizes nondetermini stic programming systems  i.e. the possibility to save complete  snapshots  of computations to be resumed afterwards if needed. 
   qa1  1   on the other hand  appears to be some  what unbalanced; in fact  it is clearly oriented towards nondeterministic programming  but his nondeterministic feature are only partially controllji ble  and  besides  provides a f u l l y controllable context mechanism  that  once again  does not allow to save control informations. 
   what  in our opinion  distinguishes magma-lisp system is its simplicity of conception. the main idea underlying magma-lisp design is the notion of context  to be thought of as a complete environ ment capable of a  deterministic  computation  inclusive of the control structure. nondeterminism is attained by exploring different alternatives in different contexts. generation  deletion  switching and communication among contexts are in charge 
of the programmer  so that the choice-policy is under user's control. in other words  the user has the neat and intuitive notion of context as a basic programming concept: he can think of having a  

1 

many indipendent computation environments as he needs to attempt a l l the alternative paths to his goal. on the other hand  the system enables him to break the  apartheid*' among contexts  in order to transfer useful informations from one to another. 
1. magma-lisp: a user view 
　　　magma-lisp has been designed as an implementation support for the realization of sophisticat ed programming systems allowing nondeterminism and complex control regimes. this section sketches the main features of magma-lisp  describing its basic characterizing concepts: contexts and appli cations. 
1 the contex tree 
　　　intuitively speaking  the simplest viewpoint for the user of a nondeterministic language is the following one: at each choice-point crossing  as many new computation environments are created as the alternatives to be explored are. so  a tree of computation environments  context tree  grows and contracts according to choice-point crossings and failures. the i n i t i a l state of newly created contexts is identical to the one in which the choice point is encountered. 
　　　magma-lisp considers the context tree to be the structure underlying any nondeterministic system  brings it to the light and commits i t s control to the user. 
　　　a small set of primitives allows adding and dropping nodes to the context tree; this way  computation environments can be created and destroyed. the function newcxt cxt  creates a new computation environment  whose i n i t i a l state is that of the context identified by cxt  * . the newly created context is added to the control tree as a son of cxt. newcxt returns the identifier of the created context: context identifiers are regarded as a special data type  allowing the explicit management of contexts. 
　　　the size of the context tree can be reduced by the function contract cxt1 cxt1  whose effect is the substitution of the subtree rooted in cxtl 
by the subtree rooted in cxt1  ** . 
　　　the format of this function reflects the nondeterministic trend of magma-lisp. in fact  if cxt1 is missing  contract allows to drop contexts associatej to failed computations  while  if cxt1 is not missing and it is a leaf  contract allows to draw the final consequence of a successful computation  reducing the whole tree to the single 
n
 ＜de cxt1. any intermediate strategy can be programmed as well. 
　　　the context tree can be inspected from inside any context  using the functions son cxt  and getcxt n cxt  that return the l i s t of the context 
 *  *  cxt is missing  the context in which newcxt is executed is assumed. 
 **  cxt1 must be a descendant of c x t l ; if cxt1 is missing  the whole subtree rooted in cxtl is dropped. 
identifiers of the sons of cxt and the n -th ancestor of cxt in the context tree  respectively  * . 
1 applications and tree control structures 
　　　each node of the context tree represents a computation environment  which is essentially that of a standard lisp system. that is  adding a new node to the context tree results in creating a new computation environment  whose state is i n i t i a l l y a copy of its father  * * . computation environments provided by magma-lisp differ from that of standard lisp systems in what their nature has been extend to allow growing a tree control structure. in other words  inside each context it is possible to depart from the normal l a s t - i n f i r s t - o u t discipline of lisp in order to define 
more complex control regimes  like coroutines etc. 
　　　the basic component of tree control structures is the application  which is to be viewed as a function activation frame. in fact  an application contains: 
- a function definition; 
- a local environment  i.e. bindings and locals; 
- a return pointer  i.e. the identifier of the application to which the value of the function has be returned; 
- an environment pointer  i.e. the pointer to an association l i s t ; 
- a continuation point in the application i t s e l f . 
an application a is a son of b in a tree control structure if its return pointer is the identifier of b. applications are generated either i m p l i c i t ly by calling a function defined as an expr  or explicitely by invocation of apply. in the former case  both the return and the environment pointer are set according to the normal lifu rule. in the latter case  both pointers can be defined in the invocation of apply. 
　　　application identifiers can be obtained by the function getap n appid  that returns the identifier of the n -th ancestor of appid  **#  in the control tree. 
1 the function apply 
　　　magma-lisp is supposed to be a uniprocessor system  so  at any time  there is only one context in which the computation is proceeding  active 
context . switching among different contexts can be obtained by apply. in our system apply is generalized both to manage tree control structures and to execute switching among contexts. 
 *  if cxt is missing  the context in which the function is executed is assumed. 
 **  it goes without saying that this is only a user's view. contexts are simulated as described in sect. 1. 
 *** if appid is missing the identifier of the actual application is assumed. 
1 
　　　the format of apply is the following: apply fn argil t envp retp.cxt  where envp and retp are application identifiers and cxt a context identifier. it activates a new application to apply ♀n  to args. the new application is added to the control tree of context cxt as a son of retp  
while envp defines the environment pointer. the environment is b u i l t up appending bindings and locals to the association l i s t pointed by application envp. if the last argument is missing  the active context is assumed. 
　　　apply is the only means to execute context switching and to depart from the normal lifo rule inside any single context. then  it is the basic tool for the user to control the nondeterministic features of the system  and  at the same time  to define procedures that exploit non-standard regimes of control. 
1 communications between contexts 
　　　contexts  as they are provided by magma-lisp  must be thought of as nodes in a tree structure of indipendent environments. the computation can proceed in the leaves as well as in the other nodes. actions in any context do not affect the state of any other  unless the programmer explici t ly states the contraries. 
　　　information can be transferred between contexts via apply: in this case there is a control transfer too. to make information transmission easier  the functions put and get have been extended in magma-lisp by an additional argument  specifying the context in which properties are to be set or inspected. as a rule  changes performed by put are localized to a single context  according to the general philosophy. in many cases  
however  it seems useful that modifications be global  i.e. they propagate from a context to a l l its descendants. this happens if the additional argument of put is a l i s t  of a single context identifier  instead of a context identifier. 
1. context implementation 
　　　this section describes some techniques used in the implementation of the system. the main problems that have been faced have co do with the tree control structure and the context mechanism. here special emphasis is given to the solutions adopted to realize the context mechanism. 
　　　before discussing the details  it is worth to outline the general approach used to implement magma-lisp. the system has been realized in two quite distinct subsequent steps. f i r s t   a lisp system extended by a tree control structure was implemented  then the context mechanism has been superimposed on this basic support. 
　　　context mechanism is realized in a very simple and general way: informations having a contextual nature are referred to in an indirect way  through tnulti defined value l i s t s  mvl . mvls are l i s t s providing a l l the values in the different contexts  with a technique that somewhat recalls that of qa1  1 . mvl's organization w i l l be discussed in details  and it is such to guarantee efficient search and bookkeepirj this technique is applied throughout the whole system  control information included. in other words  there is a unique tree control structure in the system. any element of the tree may belong to more than one context. in such a case  the corresponding memory block may contain a few pointers to mvls. typically  the continuation point is a context depending information. 
　　　no sophisticated techniques have been studied in order to implement the tree control structure  using instead a straightforward l i s t organization. whenever a function is invoked  either implicitly or e x p l i c i t l y via apply  an application block is allocated to store basic information   i . e . the function d e f i n i t i o n   the return and environment pointers and the continuation point  together with a suitable amount of memory for bindings and locals. finally  auxiliary memory may be allocated during the computation for intermediate results. 
　　　memory is obtained from areas organized in free l i s t s . returning from a function application  the corresponding memory is given back to the free 1ists  in the simplest situations; otherwise  its recovery is deferred to garbage collection. 
　　　the technique of retention is quite simple: if an application a has undergone a getap  see set. 1   a and a l l the applications on the path from a to the root are retained; recovery  if that w i l l be the case  w i l l occur at garbage c o l lection time. 
1 summary of mvl techniques 
　　　whenever a piece of information  e.g. the property of an atom  has different values depending on the context  the cell which should point to the value points instead to an mvl. 
　　　an mvl is a l i s t of dotted pairs  c.v.  where c is a context identifier and j/ the value of the - information in c . when a new context is created  no memory is allocated at a l l . memory w i l l be allocated  by growing or generating mvls  only when updating is actually performed in that context. moreover  the size of an mvl depends on the number of contexts in which updating occurred; in other words  it does not depend on the number 
of existing contexts  i.e. on the size of the context tree. 
　　　it is fundamental that mvls are generated only when they are really needed  both with respect to execution time and memory space. there are two cases: the global data base and the local environments. mvls are generated to record properties in property-lists  the global data base  when the context tree is not t r i v i a l   i.e. there are more than one context. mvls are generated to record items of information in locals environments  only if the involved application is to be retained even if it is exited. by this simple technique  mvls are generated almost only when they are really needed. 
　　　to find the value corresponding to a context ♀ in a mvl  a pair  c.v  is looked for f i r s t l y ; if it does not exists  then  accordingly to the user-view of the context tree  it is enough to 

1 

look f o r the pair corresponding to the nearest ancestor of ♀. thus  the c r u c i a l point with regard to e f f i c i e n c y is to f i n d a mvl organization capable to speed up searching an element or i t s nearest ancestor a c t u a l l y present in the mvl. 
　　　the following subsections describe an organization that allows to search and update mvls with a s a t i s f a c t o r y e f f i c i e n c y . 
1 the context table 
　　　magma-lisp memorizes the context tree in an array  context table  indexed by context i d e n t i f i e r s . each row stores pointers in order to memor i z e the context tree as a binary tree. moreover  row ♀ associates context ♀ with a pair of integers  that w i l l be denoted by r   c   and s   c   : 
- r   c   	is 	the number of nodes preceeding ♀ in the preorder traversal  1  of the context 	t r e e ; 
- s c  is the r-number of the last descendant of c in the preorder t r a v e r s a l   i . e . s ct is the largest r-number among c's descendants; s c  is set to r   c   if ♀ has no descendants. 
r-numbers and s-numbers are characterized by 
the following property: 	given two context ♀* and ♀ n   ♀* 	is a descendant of ♀ m if and only if r   c       r   c '      s   c     . 
1 searching mvls 
　　　mvl1s components are l i s t e d by decreasing values of r-numbers. 
　　　the following algorithm searches a mvl f o r the value in context ♀. 
algorithm 1 
1  scan the mvl u n t i l a pair   c ' . v     is found  such that r   c '      r   c   
1  r e s t a r t i n g from   c ' . v '     scan the mvl u n t i l a pair   c   . v     such that s c m      r   c   is found. 
　　　this way  c  is either ♀ or the ancestor of ♀ w i t h the greatest r-number  i . e . the nearest ancestor of ♀  a c t u a l l y present in the mvl  is found. 
1 updating mvls 
       in updating a mvl with respect to ♀  care must be paid so that the modification does not propagate to any descendant of ♀  or does propagate to a l l i t s descendants  according to the assigning modality  see set. 	1.a . 	in the f i r s t case  f o r each son of ♀ not already in the mvl a pair must be added to preserve the old value in context c. 	in the second case a l l the descendants of c must be eliminated from the mvl. 	in both cases the operation can be performed in a single scanning of the mvl. this is obvious in the second case. in the f i r s t one the operation can be performed by algorithm 1  that needs the l i s t of sons of c ordered by decreasing r-numbers. such a l i s t can be drawn from the context table d i r e c t l y . 
algorithm 1 
1  while there are sons of ♀: search  by rnumbers  the pair corresponding to the son of ♀ with the greatest r-number; if there is no such a p a i r   insert it and push the pointer to it on a stack  say s; 
1  when a l l the sons have been considered  look f o r the value in c  algorithm 1     store it in a l l the pairs pointed by stack s  f i n a l l y update the value in c   i n s e r t i n g a p a i r   if missing . 
because of mvls1 o r d e r i n g   the search of the 
 i + l   - t h son of ♀ can r e s t a r t from the pair corre  sponding to the i - t h one. 
　　　assuming the number of accesses to the context table as a measure of the complexity of search and updating algorithms  it follows from the previous discussions that the complexity has an upper bound which is l i n e a r with the length of the mvl  whereas it does not depend on the size of the context t r e e . this is one of the most i n t e r e s t i n g advantages offered by magma-lisp 
organization. another advantage  estimable in a system designed to allow sophisticated explorations of goal t r e e s   is that switching among contexts i s p r a c t i c a l l y g r a t i s   consisting i n changing the active context i n d i c a t o r . 
　　　a small overhead is imposed in creating new contexts  since the context table must be updated. we note  however  that this task can be accomplished by a single scanning of the context t a b l e . in f a c t   the rule to update the context table in order to add a node c' as a son of c i s : 
1  l e t re and sc denote r   c   and s c  r e s p e c t i v e l y ; 
1  f o r each row: 
　　if r  rc and s sc then increment s by 1; if sc r then increment r and s by 1; 1  f i n a l l y set r   c '   and s   c f   to s   c   . 
1 garbage c o l l e c t i o n 
　　　the function contract deletes contexts only from the user's viewpoint. in r e a l i t y   contract simply marks the rows of the context table c o r r e sponding to deleted contexts  making it possible to detect attempts of f u r t h e r use of references to dropped contexts   i l l e g a l references . rearrangement of the context table is deferred to garbage collection time  as well as the rearrange ment of mvls  i . e . the actual elimination of t h e pair corresponding to deleted contexts. 
　　　the d i r e c t extension of the standard garbage c o l l e c t i o n philosophy to a system supporting a 

1 

context mechanism would result in repeated tracing of the whole system. the direct extension  indeed  is the following: f i r s t   trace and mark a l l items reachable starting from the actual  position  in the active context; then  trace the system again and again u n t i l a l l contexts whose identifiers have been found in previous tracing have been con sidered. finally go through the system once more to rearrange mvls. 
　　　magma-lisp garbage collector  1  takes instead advantage of the fact that the management 
of the control tree is completely committed to the user. the system is traced only once  since the context tree defines explicitely the context to be retained. 
　　　the main input information of the garbage collector are: 
- the l i s t of the contexts to be retained; - a l i s t oi starting points  application identifiers  in the tree control structure. 
the f i r s t l i s t is drawn from the context table. 
the second l i s t contains the identifiers of all the applications  which have undergone a getap operation and are s t i l l legally referable in one context at least. thi s l i s t is handled by the system according to the following philosophy  which defines  from the user's viewpoint  the behaviour of the tree control structure inside each context: whenever an application is exited  the subtree rooted in it is dropped from the control tree. this is only a user's view; the system has instead a mechanism to update the l i s t of starting points in the unique tree control structure actually existing in the system. 
　　　finally we note that the rearrangement of mvls is not a t r i v i a l business. in fact  it is not sufficient to eliminate the pairs corresponding to deleted contexts. in many cases  the pai r corre sponding to a deleted context c must be retained and updated with regard to the context identifier in i t   since it is possible that pairs corresponding to surviving descendants of c are not present in the mvl. the rearranging algorithm exploits the ordering by decreasing r-numbers of mvls and the fact thal the l i s t of the contexts to  be retained is ordered in the same way: mvls are rearranged in a single scan and the number of accesses to the context table is linear with the sum of the length of the mvl and the number of contexts to be re-
tained. 
conclusions 
　　　the main idea informing magma-lisp is that a tree of conceptually indipendent computation environments is the supporting structure of any programming system allowing nondeterminism. magmalisp provides this basic support in a quite virgin al form: in this sense it must be considered as a  machine language . the language has neither primitives to set up choice points in programs nor primitives to f a i l   etc.. there are  instead  primitives that add and delete nodes from the context tree and f a c i l i t i e s to switch and transfer informations among environments. so  the user can tune the power of the system to match his own requirements by the definition of a suitable set of functions  expressing his own techniques to explore the available alternatives. 
　　　experiments in this line are presently in progress. a language for nondeterministic programm ing  nd-lisp  1   has been defined. nd-lisp is 
much more problem-oriented than magma-lisp  provid  ing specific ways to set up choice points  primitives to f a i l and to suspend and resume alternatives. nd-lisp enjoys a fine structure and s t i l l allows complete freedom in the choice-policy def i n i t i o n . this is obtained f i l t e r i n g the wildness of magma-lisp  that nd-lisp users are not encourajj ed to employ d i r e c t l y   through a few functions realizing the primitives of nd-lisp. besides  a pattern-matching language  snark  1    which i s   
more generally  a formalism for the definition of symbolic interpreters  and a proof-checker  1 i 
which allows a high degree of intervention of the user in the proof  are presently being implemented in magma-lisp. 
　　　in the light of these experiments  magma-lisp shows itself as a good tool for the implementation of a . i . systems  * . this is mainly due to its nice balancing of clarity and intuitiveness of i t s basic programming concepts  on one hand  and a 
　　　reasonable level of efficiency on the other. 
