 
we deal with the moving target search problem where the location of the goal may change during the search process. the trailblazer search  tbs  chimura and tokoro  1  achieves a systematic and effective search by maintaining a map. the map stores path information about the region where the algorithm has already searched through. however  because of the growth of the map  there is a problem that the time to make decisions of search steps increases rapidly. we propose an algorithm  the trailblazer search with an abstract map tbsa   that reduces the cost of map maintenance  and hence improves the reactiveness of the problem solver. we partition the information about the problem space into local maps  and build an abstract map that controls maintenance of the local maps. in this way  the problem solver can systematically manage information about the problem space  and it can utilize the map with less cost. we evaluate the efficiency of our method  and show how significant cost reduction in map maintenance can be achieved by using a two-layered map. 
1 	introduction 
heuristic search is the process of trial and error during an attempt to reach a goal state in a certain domain. we deal with search problems for agents  considering that the agents will take actual actions in the real world. korf presented the learning real-time a*  lrta  l1  that interleaves constant time decision and actual execution of search steps. however  lrta* is a search algorithm for stationary goals. when considering the dynamic property of the real world  goals may change locations while the agents are planning to accomplish them. ishida and korf presented moving target search probem l1l . representing a goal that changes locations as a moving target  and taking a uniformly 
* sasakiqmt.cs.keio.ac.jp 
* chimura mt.cs.keio.ac.jp 
　*mario mt.cs.keio.ac.jp. also affiliated with sony computer science laboratory inc. 
weighted graph as the problem space  the aim of the problem is for a problem solver to reach a node where the target is located  namely  to capture the target. 
　moving target search {mts  ishida and korf  1  extends lrta* to tackle the search problem for moving targets. while exploring the problem space  starting from heuristic estimates  the problem solver tries to learn the exact distances between any two nodes in the problem space. once the problem solver learns the set of exact distance values  the search task is then reduced to moving to the adjacent nodes that are closer to the target. however  since the problem solver cannot learn the exact distances at once  it may re-explore the same locations many times and require many search steps to solve a problem. this occurs if the problem space is complicated as for a maze and the problem solver is trapped in deep dead ends  where the initial heuristic estimates greatly differ from the true values. 
in intelligent moving target search  imts   ishida  
1   while overlooking the motion of the target  the problem solver conducts a lookahead search to find exits of dead ends. this method significantly reduces the number of search steps of mts  since the problem solver can make decisions that widely reflect the structure of the search space. 
　in contrast  trailblazer search  tbs  chimura and tokoro  1  records the information about locations where the problem solver has already explored. due to this information  the problem solver can avoid exploring the same nodes repeatedly. furthermore  from the stored information  the algorithm creates a map that enables the problem solver to chase the target  once the target moves on a direct path found in the map. in this way  tbs significantly reduces the number of search steps. however  as the search proceeds  tbs rapidly increases its cost of map maintenance  according to the growth of the map. as a result  tbs takes an increasingly longer time to make a decision for each step. 
in this paper  we propose an algorithm  the trailblazer 
search with an abstract map  tbsa   that achieves an effective map maintenance  so as to improve the reactiveness of the problem solver. we partition the information about the problem space into local maps  and build a global layer  called abstract map  which controls maintenance of the local maps. in this way  we can systematically manage information about the problem space  and 
	sasaki  chimura  and tokoro 	1 
limit map maintenance within smaller local maps  instead of the entire map. tbsa can thus make decisions in less time. 
　we describe the hierarchical map maintenance of tbsa. we formally analyze the method  and show empirical results indicating its effectiveness. 
1 search for moving targets and the trailblazer search 
we represent the problem space as a connected and undirected graph with unit cost assigned to each edge. we represent a goal that changes location as a moving target. at any time period during the process  a problem solver and a target are assigned nodes in the graph. in alternate turns  they move to any node adjacent to their current locations. starting from separated initial nodes  the search ends when the locations of the problem solver and the target coincide. 
　we make three assumptions to assure a solution for the search. firstly  the problem solver always knows the location of the target. concretely speaking  the problem solver must know the name of the node where the target is located. secondly  the problem solver has an admissible pearl  1  heuristic function that returns an estimated distance between any two nodes in the problem space. lastly  the problem solver moves faster than the target. in the particular problem space defined above  we implement this assumption by periodically skipping the target's turn. 
　chimura and tokoro presented the trailblazer search  tbs   an algorithm for moving targets. the basic idea of tbs is to store path information about the region the problem solver has previously explored  and to exploit this information*for accomplishing the task. the problem solver records every step of itself and the target. this is done by recording an undirected edge connecting the departure and arrival nodes of the step. the problem solver organizes these records into a graph called the trail. from the trail  the problem solver calculates the routing table called the map  using dijkstra 's shortest path algorithm or floyd's algorithm aho et al.  1 . the map holds a minimum cost path from the current location of the problem solver to any node it has explored. 
　tbs separates the capturing process of the target into two distinct phases:  l the search phase  and  1 the chase phase. in both phases  the problem solver ex-
ploits the information of the map in order to achieve an effective process. the process starts from the search phase. by using the map in the search phase  the problem solver can distinguish an unexplored region from an explored region  and can thus conduct a systematic process by eliminating unnecessary re-exploration of the same nodes. once the target crosses the trail of the problem solver  or vice versa   and hence the trails of the problem solver and the target overlap  the problem solver finds a path in the map leading to the target. then  tbs enters the chase phase. the chase phase is deterministic since the values referred from the map are accurate. the problem solver simply needs to move to reduce the distance between itself and the target. 
1 	automated reasoning 
　in the search phase  either the problem solver must find the target or the trail of the problem solver and the target must overlap before exploring the whole problem space. hence  the algorithm eventually enters the chase phase. in the chase phase  according to the assumption that the problem solver moves faster than the target  the problem solver can always capture the target. thus tbs is a complete algorithm  i.e.  it terminates. in the following  we formally describe the tbs algorithm. 
　let x and y be the locations of the problem solver and the target respectively. they take values from a set of integers that identify the actual nodes in the problem space. let h x  y  be the heuristic estimate of the distance between x and y  and c x y  be the distance between x and y derived from the map. the value of c x y  is oo if there is no path found between x and y on the map. for each explored node  we assume that the problem solver records the parent node from which it has arrived to the node for the first time. 
  procedures of the problem solver when it is its own turn to move 
1. for each node x' adjacent to x  read c x'  y  to find if there is any path from x' to y. if there is no path  enter the search phase  otherwise enter the chase phase. 
a. in the search phase 
for each unexplored node x' adjacent to x  calculate h x' y   move to the node x' with minimum h x' y . ties are broken randomly. if all of the adjacent nodes have been explored  move to the node x' that is the parent node of x. 
b. in the chase phase 
move to the adjacent node x' with minimum c x' y . ties are broken randomly. 
1. record the move of the problem solver by adding an undirected edge connecting x and x' to the trail. assign the value of x' to x as the new location of the problem solver. 
1. update the routing table. 
  procedures of the problem solver when it is the target's turn to move 
1. record the move of the target by adding an undirected edge connecting y and y' to the trail  where y' is the new location of the target. assign the value of y' to y as the new location of the target. 
1. update the routing table. 
　with the map information  even if the problem space is complicated as for a maze  a problem solver executing tbs can capture the target in fewer steps than one executing ishida's mts. however  tbs requires map maintenance  whose cost increases rapidly as the search proceeds  and as trails of the problem solver and the target become more complicated. the problem solver uses the map to decide which direction to proceed next. as a result  the problem solver takes an increasingly longer time to make decisions for each step  and it becomes increasingly difficult for the problem solver to behave 


problem solver 
figure 1: the detailed map of the entire problem space 
reactively. if we consider real-world applications  such as the problem for an autonomous robot to capture a target robot  the cost of map maintenance is tolerable to some extent. the reason is that map maintenance takes computational cost  while search steps take physical cost such as the cost of the robot's move. however  for tbs  the increase in the cost of map maintenance is so extreme that it cannot be neglected  especially if we consider large scale real-world problems. 
1 the trailblazer search with an abstract map 
tbs maintains a map including all the details every time the problem solver takes a single step fig.l . this is useless since a single move results in updating the map for the entire area of the trail  even though the move will only affect the structure of the trail in a small region surrounding the location where the move took place. following the idea that the map should be locally updated  we divide the map and conduct routing in the partitions. in order to keep track of connections between partitions  we create a global map over the partitions. therefore  the problem solver hierarchically maintains the information about the problem space. we call the search algorithm that uses the hierarchical map  the trailblazer search with an abstract map  tbsa . this section describes the maintenance method and the use of this twolayered hierarchical map. 
1 	a hierarchical construction of a map 
tbsa regards the problem space as a set of exclusive partitions called the subproblem spaces. the partitions will be made by a simple function distinguishing nodes of one partition from those of the other partitions. in a subproblem space  some nodes directly connect to nodes that belong to another distinct subproblem space. we call them boundary nodes. a boundary lies between connected boundary nodes of different subproblem spaces. 
　tbsa maintains the map in two layers fig.1 :  l the local maps hold the detailed information about the corresponding subproblem space  and  1 the abstract map holds the information about how each subproblem space interconnects with one another. each local map records every search step the problem solver takes in corresponding partitions of the problem space. the abstract map only records boundary nodes and edges connecting those 

figure 1: the detailed local maps and the abstract global map 
nodes. in the abstract map  the cost of an edge is the cost of the path that connects the boundary nodes  and that is calculated from a local map. 
　due to the hierarchical map  tbs a systematically manages the information that has been acquired during the search process. as a result  the problem solver makes decisions in a shorter time for each step. 
1 hierarchical map maintenance and reconstruction of paths 
in the following  we describe   1  how tbs a constructs and maintains a hierarchical map  and  1  how tbs a calculates the distance between any two nodes according to the hierarchical map. 
　if the problem solver takes a step within a certain subproblem space  map maintenance proceeds only in a corresponding local map. if the problem solver strides across the boundary between two distinct subproblem spaces  map maintenance proceeds in the abstract map. in both procedures  we can use the same routing algorithms on each map. let pn represent a node that the problem solver reaches after taking n steps. for n being a non-negative integer  assume that the problem solver moves from a node pn-1 to a node pn on its nth step. s x  identifies a subproblem space to which each node x belongs. map maintenance proceeds differently  according to whether both pn-1 and pn belong to the same subproblem space or not. 

	sasaki  chimura  and t1r1 	1 

the grid at fixed intervals. this method for partitioning allows tbsa to create hierarchies with small overhead. for general graph-like problem spaces  however  the partitioning method becomes a major issue. later  we discuss a method that creates hierarchies in such problem spaces. 
1 	formal analysis of tbsa 
tbs and tbsa both update the map every time the problem solver or the target moves. we analyze the 

figure 1: updating of the abstract map  when a step is taken across the boundary 
to the abstract is the actual cost 
of the path between node q and node pn-1  derived from the local map of 
1. update the abstract map. 
 fig-1  
the same map maintenance is done when the target takes a step. 
　we now show how to calculate the map cost c x y  between two nodes x and y  where x is the location of the problem solver and y of the target. the function cs x  denotes the cost referred from the local map of subproblem space s x  to which the node x belongs. the function cabst denotes the cost referred from the abstract map. the distance between two nodes located in the same subproblem space can be directly referred from the corresponding local map. on the other hand  the distance between two nodes located in distinct subproblem spaces must be calculated by reconstructing the path from the local maps and the abstract map. 
here  v and w indicate any explored boundary node located inside subproblem spaces s x  and s y   respectively. 
　tbsa differs from tbs only in the way of constructing the map and of calculating the distance between two nodes on the map. tbsa follows the policy of tbs that separates the process of capturing the target into the search phase and the chase phase. thus tbsa inherits the simplicity and completeness of tbs. 
　in the following of this paper  we will analyze the search problem on a two-dimensional grid space. although grid-like space represents only some features of many problem types  the search problem on such a space is not extremely special. this is because  if we regard 
junctions as nodes and connections between junctions as edges  we can naturally convert the grid-like space to a general graph-like one. 
　in a grid-like problem space  we consider partitions of fixed size  made by horizontally and vertically dividing 
1 	automated reasoning 
worst-case time complexity of map maintenance for each step of the problem solver or the target. we consider the rectangular grid-like problem space as discussed above. let n be the total number of the nodes in the problem space. if we use dijkstra's algorithm aho et a/.  1  for routing  the stepwise worst case time complexity of map maintenance is   for tbs. if we equally partition the problem space into d subproblem spaces  each local map contains n/d nodes at most. the abstract map contains nodes at most  since each 
subproblem contains boundary nodes. hence  for each step of the problem solver or the target  the stepwise worst-case time complexity of map maintenance is  for the local map  and 1nd  = 1 nd  for the abstract map. the partitioning number d ranges between 1 and n. if we coarsely partition the problem space  i.e.  take a small d  the problem solver or the target tends to move within a subproblem space. hence  the term of  becomes dominant in the stepwise cost of map maintenance. when d = 1  the term of b e c o m e s . in this case  a single local map works as a detailed entire map. on the other hand  if we finely partition the problem space into small pieces  i.e.  take a large d  the problem solver or the target will frequently stride across boundaries. hence  the term of 1 nd  becomes dominant in the stepwise cost of map maintenance. when d = n  the term of 1{nd  becomes 
 in this case  the abstract map works as a detailed entire map. now if we let d be d both 1{ n/d 1  and 1 nd  become   which are less than the value for tbs. 
1 	experimental results of tbsa 
　we empirically evaluated the performance of tbsa  and for comparison  tbs. the problem space is a 1 x 1 rectangular grid  organized as a torus. we randomly placed obstacles on junctions  that prevent the problem solver or the target from moving to the occupying junctions. the obstacle occupation of the whole problem space was set in the range from 1% to 1% at intervals of 1%. according to preliminary experiments that tested the best division  we partitioned the problem space into 1 subproblem spaces by dividing each side of the grid equally into 1 parts. we set the speed of the target to 1 that of the problem solver by skipping the turn of the target once every five turns. we performed experiments for each tbsa and tbs  and for different strategies of targets. the strategies are   l avoid: the target moves to the furthest adjacent node from the problem solver  
 1  meet the target moves cooperatively to meet the 

problem solver  i.e.  searches for the problem solver  and  1  random: the target moves randomly. for each experiment  we randomly created 1 sample grids  and averaged the results over all the samples. for each experiment  we counted the total number of search steps and the cost of map maintenance. the cost of map maintenance is regarded as the number of references to records on the routing table for each time the map is updated. further  to evaluate the algorithm's reactiveness  we measured the cost of map maintenance for each 1 steps of the problem solver. figures 1 and 1 show the total number of steps and the total map maintenance cost. figure 1 shows the result of the cost of map maintenance for each 1 steps up to 1 steps  where the target's strategy is avoid and the obstacle ratios are 1% and 1%. 
　as shown in figure 1  tbsa shows the same tendency as tbs for the total number of search steps. this is because tbsa differs from tbs only in how the map is maintained; the policy of movement is the same for both. when the obstacle ratio increases from 1% to 1%  it becomes easier for a systematic search like tbs and tbsa to capture the avoiding targets. this shows that problem solvers can get out of dead ends faster than the targets chimura and tokoro  1 . 
　on the other hand  as shown in figure 1  tbsa significantly reduces the cost of map maintenance  compared with tbs. when the obstacle ratio is 1%  tbsa's cost of map maintenance reduces to 1 times that of tbs for the target's strategy of avoid or meet  and to 1 times for random. the cost of map maintenance is especially high when the capturing process of the target includes a long chase phase. this is because  in the chase phase  the problem solver must make a combined map of both the problem solver and the target. the chase phase tends to become shorter when the obstacle ratio increases  since avoiding targets tend to get trapped in dead ends. this explains why the avoid curve dips as the obstacle ratio increases. the chase phase is usually longer for a target with the avoid strategy than for one with other strategies. hence  the biggest improvement of tbsa against tbs appears when the target's strat-

egy is avoid. for an a voiding target and for an obstacle ratio of 1%  tbsa's cost of map maintenance is 1 times that of tbs. within a practical time  tbsa can solve much larger problems than tbs  such as the moving target problem on a 1 x 1 grid. 
　figure 1 shows that the cost of map maintenance of tbsa for each 1 steps increases slowly  while that of tbs increases rapidly  as the search proceeds. this result indicates significant improvement of the problem solver's reactiveness. we can confirm the improvement on a computer display; tbsa responds instantly  while tbs spends quite a long time to take a single step. nevertheless  the reaction time of tbsa is not constant. since the number of nodes in a subproblem space is limited to a constant  we predict that the maintenance cost of a local map is constant as well. on the other hand  since the abstract map controls local maps  and since the number of local maps is regarded as unlimited  as for the abstract map  we cannot set any plausible boundary to the cost of maintenance. however  the increase in the number of nodes included in the abstract map is so slow that maintenance cost of the abstract map has little imsasaki  chimura  and tokoro 1 
pact on the total cost of map maintenance. 
1 related research 
in the field of ai planning  there has been plenty of research dealing with hierarchical problem solving. according to  prieditis and janakiraman  1   it is a three step problem-solving paradigm: 1 abstraction   1 problem solving  and  1  reconstitution. after organizing an abstract problem space  a plan is first inferred in that problem space. the intermediate states of the abstract plan are then used as intermediate goals to guide the search for a more detailed plan. knoblock showed that this method can reduce the search complexity from exponential to linear when searching for a solution with the same length knoblock  1 . in tbsa  the phase of organizing the hierarchical map corresponds to the step of abstraction  and the phase of reconstructing paths from the hierarchical map corresponds to the steps of problem solving and reconstitution. the major issue of tbsa and hierarchical problem solving in general  is the need of a cost effective abstraction scheme. the alpine system knoblock  1  automatically forms abstraction hierarchies by analyzing the structure of the problem space before problem solving. even though this automation isn't directly applicable to the dynamic nature of map construction  the idea of learning hierarchies is useful for tbsa. for example  instead of using a predefined function for partitioning the problem space  tbsa might initially explore a small region of the search space and predict an appropriate partition for the whole problem space. this will be one way of making tbsa applicable to more general search problems other than problems on a grid. 
　hierarchical problem solving is regarded as an important technique for realizing real-time problem solving strosnider and paul  1 . we introduced the paradigm into the map maintenance of tbs in order to improve the problem solver's reactiveness. 
1 conclusions and future work 
we dealt with the problem of searching moving targets. the information about the region explored by the search algorithm is predicted to be especially useful for searching moving targets. however  the concern for this method is that the map becomes larger as the algorithm progresses. tbsa is a method that uses a hierarchical map of where the algorithm has explored. tbsa handles the problem space in partitions  called local maps. it maintains an abstract map on top of the local maps  in order to systematically manage the information of the problem space. 
　we formally and empirically analyzed tbsa in a problem where a problem solver searches for a target on a grid-like problem space with randomly placed obstacles. first  we formally showed that tbsa reduces the cost of map maintenance for each step of the problem solver from 1 n1  to 1 n1   where n is the number of nodes in the problem space. then  with results from simulations  we showed that tbsa actually reduced the cost of map maintenance. tbsa inherits the simplicity 
1 	automated reasoning 
and completeness of tbs; however  there is significant improvement in the algorithm's reactiveness. we found that  within a plausible time  tbsa could solve problems of sizes up to a 1 x 1 square grid. tbs could not solve a problem of this size within a plausible time. 
　for larger problems  it might be beneficial to construct a hierarchical map that has more than two layers. it will be useful if the search algorithm can control the number of layers adaptively. we plan to research this strategy further. 
