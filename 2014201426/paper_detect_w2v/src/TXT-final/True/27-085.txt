 
 we have developed a domain-independent systematic methodology for plan merging at the various levels of plan abstraction. this method manifests itself in the hierarchical plan graph where each level contains a complete  partially merged plan. the principle advantage of this approach is that  once external interactions between nodes on a given level have been established  the continued merging of the plan fragments in one node can take place independently of plan fragments in other nodes on that level. this provides a decomposition or divide-andconquer approach to plan merging. another advantage to this decomposition approach is that replanning effort is minimized in the presence of the selection of alternative actions at some level of the hierarchical plan graph. only those plan fragments which are in the same branch as the alternative selection need be considered for replannmg. also  an algorithm ts proposed which takes a bilateral approach to breaking cyclic dependencies between nodes in the hierarchical plan graph. we demonstrate the utility of this hierarchical approach to plan merging through examples in the process planning domain. 
1 introduction 
a common approach to planning is to make the linear assumption by decomposing the problem into subproblems and planning for each subproblem independently. the resulting subplans are combined into the final plan via plan merging techniques  hayes  1; karinthi et a/. 1 . plan merging consists of unifying separately generated plans into one global plan while obeying the constraints due to interactions within and between the individual plans. merging is typically done in a complex manner such that all actions of all the subplans are considered simultaneously 
* email: 	britanik ecc.arizona.edu 
* email: 	marefat ece.arizona.edu 
   *the support of this work by the nsf under grant ddm1 to dr. marefat is gratefully appreciated. 
in their lowest-level representation  foulser ei a/. 1; karinthi et ai  1 . 
¡¡our approach involves a hierarchical plan graph which we use to develop a domain-independent systematic methodology for plan merging at different levels of plan abstraction. the hierarchical plan graph is broken into levels  where each level contains a partially merged plan called a subplan sequencing graph. this approach decomposes the plan merging problem in that  once external interactions between nodes on a given level have been established  the continued merging of the plan fragments in one node can take place independently of plan fragments in other nodes on that level. in the presence of the selection of alternative actions at some level of the hierarchical plan graph  this decomposition approach minimizes replanning effort. only those plan fragments which are in the same branch as the alternative selection need be considered for replanning. we also develop a method for breaking cyclic dependencies between nodes in the subplan sequencing graph. 
¡¡we demonstrate the utility of this hierarchical approach to plan merging through examples in the process planning domain. the planning system consists of two major components: 1  a case-based planner which generates feature subplans  britanik and marefat  1   and 1  a plan merging component which hierarchically merges the feature subplans into a global plan. we will not discuss the case-based planner here. it is sufficient to note that the case-based planner generates process plans for each feature in the part  along with a list of interactions between the individual feature plans and plan fragments. the hierarchical plan merging component is the subject of the remainder of this paper. 
1 	definitions 
before discussing hierarchical plan merging  hpm   we need to discuss what a plan is and define our notion of plan merging. 
¡¡a hierarchical plan graph  hpg  is a directed graph of plans such that each level represents a plan at some level of abstraction. figure 1 shows a generic hierarchical plan graph. each node at a given level of the hpg represents a subplan of the plan at that level. the root node represents the initial set of individual plans. the leaf nodes represent the fully merged plan. a directed arc is drawn from node a' on level i to node y on level 
	britanik and marefat 	1 

1 	g u i d e to the paper 
to emphasize that our methodology is domainindependent  we first present the general theory in section 1. then we show how this theory can be applied through a detailed process planning example in section 1. section 1 briefly discusses how our approach can yield savings in replanning cost. section 1 reviews directly related work  and section 1 concludes the paper. 
1 	planning 
1 high-level merging algorithm 
at each merging level of the hierarchical plan graph  the same high-level merging algorithm is used to generate the next level in the graph. the algorithm involves two primary steps: 1  building a minimal subplan sequencing graph  and 1  removing any cycles from the subplan sequencing graph. 
1 generating a m i n i m a l subplan sequencing g r a p h 
a subplan sequencing graph is a directed graph  g = 
 n e   where each node  n  € n is a subplan which contains the result of merging two or more actions from the preceding node on the previous level. a directed edge e  € e is drawn from node nj to node nk if there is an external ordering o  such that some component in t j must be completed before some component in n*. 
an example of a subplan sequencing graph is shown in levell of figure 1. j1  b1  and b1 are subplans which are sequenced by the orderings oi =  ag1 -  obi  and 1 =  ab1 -  1  where a i is an action in node bi. 
¡¡the generation of the nodes in the subplan sequencing graph is dependent on the domain in two ways. first  domain-specific information is used to determine the actions to be merged at the graph level of interest. second  the criteria to determine whether two actions are mergeable are also domain specific. assuming we have such information  we can use the following 1-step algorithm for generating a near-minimal number of nodes in the subplan sequencing graph: 1  generate a set of maximal nodes that cover all possible mergings of actions from the previous level in the hpg  1  produce a near minimal covering of the actions from the previous level  1  generate edges which correspond to external orderings between nodes. 
¡¡to generate the set of maximal nodes  first a new node is created for each action type or mergeability type to be considered at this level. next  components or plan fragments from the previous level are placed in each node  provided they are mergeable with that node's action type. 
¡¡we now have a set of nodes  each of which contains plan fragments that can be merged together. a greedy approach is used to find the near-minimal covering of plan fragments in the maximal nodes1. first the largest node  ie: the node which contains the largest number of plan fragments  is chosen. each plan fragment contained in the largest node is removed from all other nodes. then the next largest node is chosen  and so on until there are no non-empty nodes remaining unselected  until a covering is achieved by all of the selected nodes . figure 1 shows the algorithm to generate a minimal covering from the set of maximal nodes using this greedy approach. 
¡¡we can improve the above greedy algorithm by checking for the case where all of the plan fragments in a node are mergeable with other nodes in the minimal covering. we take advantage of the following lemma. 
   'in  britanik 1   we compare this approach with two optimal approaches. this greedy approach was found to be efficient and near-optimal. 

1 r e m o v i n g cycles f r o m a subplan sequencing g r a p h 
cycles prevent us from determining an ordering between plan fragments; therefore  they must be removed. but before cycles can be removed  they must first be detected and enumerated. the cycle enumeration algorithm is a straight-forward depth-first search algorithm which explores each edge of the subplan sequencing graph and reports cycles when it encounters a node more than once along a path. this algorithm runs in o e  time  where e is the number of edges  external orderings  in the graph  since every edge in the graph is explored exactly once. once we have found all of the cycles in the subplan sequencing graph  we need to remove them by deleting or relocating specific edges in the graph. this is done by moving plan fragments from one node to another node. the choice of which edge to break in a cycle depends on three factors: 1  the number of cycles to which the edge belongs  1  the number of plan fragment moves required to remove the edge  and 1  the number of references to the plan fragment that would be moved. a reference to a plan fragment is simply the appearance of that fragment in the label of another edge in the graph. consider the example subplan sequencing graph of figure 1. we 

 the edge break set which has the largest value of this function is the one most favorable to break. breaking an edge requires that fragments be moved from the nodes involved to other nodes  but it may be the case that a fragment cannot be merged with any other node. another problem that would prevent one from breaking an edge is if moving a fragment to another node induces a 
 new cycle in the graph. 
¡¡in summary  the following must be true for each fragment to be moved to an alternate node in the subplan sequencing graph to break an edge: 1  the fragment  and any fragments which have an identical-merge-action interaction with this fragment1  must be mergeable into the new node; that is  it is contained in that node's corresponding maximal node  1  moving the fragment  and any fragments which have an identical-merge-action interaction with this fragment  to the new node does not induce a new cycle in the subplan sequencing graph  and 1  the fragment must not have been placed in the new node in a previous attempt to break the edge  avoids infinite loops . if it is the case that a cycle can not be broken by moving fragments to alternate nodes in the subplan sequencing graph  then there are two other approaches to removing the cycle: 1  use an alternate minimal covering  and 1  add additional nodes to the original graph. 
1
¡¡¡¡two fragments have an identical-merge-action interaction if they must be merged in the same node at some level of the hierarchical plan graph. 
	britanikand marefat 	1 


¡¡a cycle in the subplan sequencing graph can be broken by adding one node to the graph if the following are true: 1  there exists a break set  b  which contains all s-fragments or all d-fragments  and 1  all fragments in b can be moved to the new node. to break a cycle by adding a single node to the subplan sequencing graph  it is first necessary to find a break set that meets the above enumerated criteria. this can be done by scanning the break sets in order of cost  see section 1 . let e represent the edge being removed and b represent the break set being used. a new node  n'  is created with the same rnergeability type as the source node of e if b contains all s-fragments  or the destination node of e if b contains all d-fragments. all of the fragments in b are then moved from their original node to n'. finally  the edges are updated by removing all edges from the graph and rebuilding them incorporating n'. figure 1a shows a subplan sequencing graph which contains a cycle. a list of the break sets is as follows  ranked left to right: {fl}  {f1}  {fb  f1}  {f1  f1}. and the following are the orderings among the plan fragments:  fl ¦Á f1    fl ¦Á f1    fl ¦Á f1    f1 ¦Á f1    f1 ¦Á fb    f1 ¦Á f1    f1 ¦Á f1   and  f1 ¦Á f1 . each of the fragments in the nodes of the graph can be contained only in their current node. for example  fragment fl can not be moved to node b to break the cycle. since none of the fragments can be moved to another node currently in the graph  a new node must be added. {fl} is an eligible break set; hence a new node  c  is created which has the same rnergeability type as node a. f  is placed in node c and the edges of the graph are regenerated to yield figure 1b  and the cycle has been broken. 
¡¡if breaking the cycle by adding one node to the graph is not possible  then it may be possible to break the cycle by adding two nodes. note that if it is possible to break a given cycle  then that cycle can be broken by the addition of at most two nodes to the graph1. we can simply duplicate the two nodes at the ends of an edge in the cycle and move the fragments inducing the edge. this is a similar process to that of adding one node to the graph as discussed above. 
¡¡if the cycle can not be broken by creating one or two new nodes in the subplan sequencing graph or by moving fragments to alternate existing nodes in the graph  then an alternate minimal covering may need to be generated and/or replanning may have to be done. 
1 proof of this is presented in  britanik 1 . 
1 	planning 
1 replanning with alternate choices 
from time to time it is necessary to replan some portion of the overall plan to compensate for changing criteria or to satisfy interactive user preferences. we consider replanning in the hierarchical plan graph  hpg  on a level-by-level basis. the following will demonstrate how the decomposition approach of hierarchical plan merging reduces the amount of rework necessary due to replanning of a specific plan component. 
¡¡we approach replanning as follows. replanning at level i of the hpg implies that one or more of the nodes at level i contain plan fragments that were reworked. all of the nodes that are successors of those that were replanned must also be replanned  or remerged . we consider separately the following two cases: 1  only one node on a branch of level i contains replanned fragments  and 1  more than one node on a branch of level i contain replanned fragments. a branch of a level is the group of nodes which have a common parent at the previous level of the hpg. consider figure 1. at level 1  {c1tc1}  {c1 c1 c1}  and {c1 c1} are the three branches. 
¡¡when one node on a branch of a level is replanned  say r  then two actions will result: 1  it may be necessary to reorder the nodes within that branch  and 1  it is necessary to replan or remerge all successors of r. however  it is not necessary to replan other nodes in the same branch or in other branches on the same level. it is only necessary to replan the successors of the node that was replanned. this is a direct result of our decomposition approach in hierarchical plan merging. consider node ci in figure 1. replanning in node ci will require the consideration of only nodes c i   d1  d1  and d1. a planner which does not use this approach may have to replan at least all of level 1 and all of level 1. if we coarsely approximate the amount of replan work in each node as one unit  then our approach would yield a 1 or 1% savings in replan work  since only four nodes out of 1 would need to be reworked. 
¡¡it is sometimes the case that replanning affects more than one node of a branch in the hpg. this would occur in situations where plan fragments were moved from one node to another in the course of replanning. in this case  it would be necessary to replan the entire branch of the level that was affected. this is due to the fact that the minimal covering set of nodes may have changed due to the relocation of plan fragments. consider the second branch of level 1 in figure 1 which consists of nodes c1  c1  and c1. all the nodes of this branch as well as their successors would have to be replanned; however  the effect of replanning this branch is still decoupled from the other branches in level 1. using the same cost assumptions as above  this decoupling yields a savings of 1 or 1% over a planner that would reconsider all of the nodes on level 1 and level 1. 
¡¡if nodes in more than one branch of a level are affected by replanning  then each branch of that level can be considered as one of the two cases enumerated above  and replanning can propagate on a branch-by-branch basis. 


figure 1: hierarchical process plan graph incorporating the tooling subplan sequencing graphs into the tooling level  level 1 . 
1 hierarchical process plan merging 
in this section we demonstrate an application of hierarchical plan merging in the domain of process planning. as previously discussed  we assume the availability of a process planner which will generate subplans for the individual features of a part. the output of such a planner is a set of feature subplans and a set of orderings between the subplans. examples of this type of planner can be found in  marefat and kashyap 1; britanik and marefat 1   
1 	a p p r o a c h 
our approach to hierarchical process plan merging is a three level approach as shown in figure 1. level 1 is the output of the planner  a sequenced list of feature subplans. level 1 is the grouping of feature subplans into common fixtures. each mergeability type  node  at this level is a unique fixture specification. each feature subplan which is a member of a given node in level 1 can be executed in the fixturing setup specified by that particular node. directed edges between nodes implies that the fixtures represented by the source nodes of the edges must be sequenced before the fixtures represented by the destination nodes of the edges. level 1 establishes a minimal set of fixturings and their appropriate sequence for executing the global plan. each fixturing naturally decomposes into a set of toolings for that fixture. level 1 is the grouping of feature subplan fragments into common tooling groups. each mergeability type at level 1 
is a unique tooling for the branch  fixturing parent from level 1  the node is in. each subplan action that is a member of a node in level 1 can be executed using the tooling specified by that particular node. directed edges between nodes in level 1  toolings  implies that certain toolings must be executed before other toolings in the current fixturing setup. level 1 establishes a minimal set of toolings necessary to execute the plan fragments in the particular parent fixturing. 
¡¡figure 1b shows an interaction graph for the object in figure 1a. 

figure 1:  a  an example object with several interacting features and  b  its associated interaction graph. in the graph  solid edges represent strong constraints  while dashed edges represent weak constraints. an edge label of c represents a containment interaction and an edge label of p represents a perpendicularity interaction. an edge label of f represents a fixturing identical-mergeaction interaction. 
¡¡for our planner  we will focus on generating fixture positions for a parallel vise-clamp type fixture. however  the hierarchical plan merging mechanism is not limited to the simplified fixture model we will present. we use this simple model to facilitate clear exposition of the process planning domain application. along with the clamp-type fixture  we will assume a vertical-type machine; that is  the tool chuck approaches the part from above the fixture. given this physical description  we can model a fixture setting as a two-tuple   ca 1    where ca is the clamping axis and o is the orientation of the part about the clamping axis. the ca is specified as the direction parallel to the principle normal  in the part's local coordinates  of the faces to which the clamp is applied. o is the direction of the principle normal of the part surface that is facing up towards the tool chuck. 
1 	process p l a n m e r g i n g 
we will now discuss our application of hierarchical plan merging to process planning. first we describe the subplan sequencing graph at the fixturing level  then at the tooling level. 
fixturing level 
once we know from which fixtures a feature can be machined  we can construct the fixture subplan sequencing 
	britanik and marefat 	1 


graph. first we build a list of features applicable to each fixture. we call these lists common fixture sets  cfs . the common fixture sets for the part in figure 1a are shown in figure 1. notice that a feature may appear in more than one cfs  demonstrating alternative fixtures from which the feature may be machined. also note that common fixture sets correspond directly to the set of maximal nodes as discussed in section 1. 
¡¡the next step in building the fixture subplan sequencing graph is to generate a minimal covering of nodes; that is  a minimum set of fixturings. this corresponds directly to our desire to minimize the number of fixture changes while machining the part. the minimal covering for the example part consists of the two nodes: f +x +z  = {f1 f1 f1 f1} and f +y +z  = {f1.f1}. 
¡¡since our minimal covering algorithm really only generates a near-minimal covering  we next check to see if we can can remove any unnecessary nodes as described in section 1. by observing the minimal covering and figure 1  we see that there are no redundant nodes which can be subsumed by nodes of lesser cardinality. 
¡¡with this minimal set of fixtures  we now determine the sequence by which the fixtures are used in machining the part. this sequence is constrained by the strong interactions between features in different fixtures. using the interaction graph in figure 1b  we have an explicit list of orderings  strong interactions   and can generate the edges for the fixture subplan sequencing graph as discussed in section 1. we simply examine each strong interaction  represented by solid arrows in figure 1b   and include it in the fixture subplan sequencing graph as an edge if its source and destination features are in different fixture nodes  ie: it represents an external ordering . the fixture subplan sequencing graph after edge generation is shown in figure 1a. note that this graph has a cycle; hence  cycle removal is necessary. the list of break sets is as follows  ranked left to right. { f l }   {f1}  {f1  f1}  and {f1  f1} the first approach of moving one or more plan fragments  feature subplans  to other nodes in the graph would be unsuccessful since only f1 can be moved to another node in the graph  this can be seen by observing the common fixture sets in figure 1   but there is no break set which contains only f1. hence  the second approach of node addition to the graph will be attempted. by observing the ranked list of break sets  we see that all of the break sets contain nodes that are either all s-fragments or all d-fragments. if it is possible to break the cycle  it can be done by adding only one node to the fixture subplan sequencing graph. break set {fi} has the highest ranking and is an eligible break set; hence node a of figure 1a is duplicated with the fragment fl as its contents. using the interaction graph of figure 1b  the edges of the fixture subplan sequencing graph are regenerated incorporating the new node. the resulting cycle-free fixture subplan sequencing graph is shown in figure 1b. 
¡¡now that the fixturing subplan sequencing graph  that is  the fixturing level of the hierarchical process plan graph  is complete  it is necessary to build the tooling level by generating tooling subplan sequencing graphs 
for each fixture node in the fixturing level. 
tooling level 
to proceed with plan merging at the tooling level  we need to refine our definition of a plan fragment for this level. for the purposes of our example  we consider each feature subplan to consist of an ordered set of tool applications  one for each process used to machine the feature. we represent the application of tool tl in feature subplan fl as fl .tl. if fl consists of applying tool tl followed by applying tool t1  then fl contains two plan fragments  namely f1.t1 ¦Á f1.t1. it is these plan fragments that will be merged into common tooling sets in the tooling subplan sequencing graph. since the prismatic features in figure 1a  features fl through fb  are relatively similar  we assume that they all use the same rough cut tool  tl  and finishing cut tool  t1. the round hole  feature f1  uses tool t1 as its rough cut tool and t1 as its finishing cut tool. note that there is a strong constraint which sequences tool tl before tool t1 in each of the first five feature subplans  and t1 is sequenced before t1 in f1. this ordering is due to the common sense fact that the rough cut must precede the finishing cut. with this information  we are now ready to generate the tooling subplan sequencing graph for node a in figure 1. the generation of the tooling subplan sequencing graphs for the other nodes of level 1 in the hierarchical process plan graph is a similar process and will not be shown explicitly. 
first we need to generate the set of maximal nodes. 
one node is generated for each specific tool used in the feature subplans. the following is the set of maximal nodes for the tooling subplan sequencing graph:  tl:f1.t1 f1.t1    t1:f1.t1 f1.t1    t1:f1.t1   and  t1:f1.t1 . since all fragments in all nodes are unique  the set of maximal nodes is also the minimal covering in this case. also  there are no redundant nodes which can be removed from the minimal covering. to generate the edges in the tooling subplan sequencing graph  we utilize the orderings in the interaction graph in figure 1b as well the orderings implied by the specification that rough cuts precede finishing cuts. the result of adding the appropriate edges is the cyclefree tooling subplan sequencing graph shown in level1 of figure 1  which is the final hierarchical process plan graph. 
¡¡now that the hierarchical process plan graph is complete  we can generate an outline of the final plan  it is an outline in the sense that we do not include specific motions and dimensional data etc. . the plan is shown below with the execution sequence from top to bottom and then left to right: 
setup f i x t u r e  +x +z  setup f i x t u r e  +x +z  setup tool tl setup tool tl 

	{ do actions } 	{ d o actions } 
1 	planning 

setup t o o l t1 setup tool t1 { do actions } { do actions } setup f i x t u r e  +y +z  setup tool t1 	setup tool 	t1 { do actions } { do actions } setup tool t1 setup tool t1 
{ do actions } { do actions } 1 related work 
our work is somewhat complementary to that of karinthi et al.  karinthi et a/.  1 . their interesting work focuses on generating an optimal global plan from all possible alternatives of feature subplans in process planning via state-space search. our focus has been on merging one specific set of feature subplans such that replanning effort is minimized when alternatives are selected. however  in a sense we also consider many alternative plans during the merging process at the fixturing level. 
¡¡the work of foulser et al.  foulser et ai  1  presents a formal treatment of the complexity of domainindependent plan merging using strips-style operators. an optimal algorithm for plan merging utilizing dynamic programming methods has been developed. since practical implementation of the optimal algorithm is infeasible for larger inputs  several greedy-based approximate  near optimal  algorithms are also developed along with their worst-case and average-case complexities for large inputs. it is also empirically shown that the approximate algorithms performed well for larger inputs. yang et al.  yang et al 1  generalizes some of these algorithms to handle a wider range of interaction types. 
¡¡hayes  llayes 1  has developed the machinist system which considers operator overlap in process planning. the approach uses  cues  in the problem specification to search for mergeable operators. like our nearminimal covering algorithm  machinist uses a greedytype algorithm to group operators into a near-minimal number of set-ups  fixturings . 
¡¡hutcapp  mantyla and opas 1  is a generative process planner for prismatic parts. a lattice algebra is used to find a minimal covering of work directions to machine all features in the part. this work inspired our lattice algebra approach to generating an optimal minimum covering from the set of maximal nodes. this algorithm and another optimal algorithm are analyzed in  britanik 1 . 
1 conclusions 
we have developed a systematic methodology for uniform plan merging at the various levels of plan abstraction. this method manifests itself in the hierarchical plan graph where each level contains a complete  partially merged plan. the principle advantage of this approach is that  once external interactions between nodes on a given level have been established  the continued merging of the plan fragments in one node can take place independently of plan fragments in other nodes on that level. this provides a decomposition or divide-andconquer approach to plan merging. another advantage to this decomposition approach is that replanning effort is minimized in the presence of the selection of alternative actions at some level of the hierarchical plan graph. only those plan fragments which are in the same branch as the alternative selection need be considered for replanning. 
¡¡rather than considering mergings which result in cyclic dependencies to be infeasible  an algorithm is proposed which takes a bilateral approach to breaking cyclic dependencies between nodes in the subplan sequencing graph. the first approach is to maintain the same number of nodes and remove the edge of the cycle by relocating plan fragments to other nodes. if this approach fails or is inappropriate according to the priorities of the planner  then a second approach which considers adding at most two nodes to the subplan sequencing graph may be used. if these two approaches have failed  then the merging which resulted in the cyclic dependency will be considered infeasible and replanning will be necessary. 
¡¡we have demonstrated the utility of this hierarchical approach to plan merging through examples in the process planning domain. it was shown that the merging of fixtures  fixture level  and the merging of tools  tooling level  can be done in a systematic and uniform fashion. 
