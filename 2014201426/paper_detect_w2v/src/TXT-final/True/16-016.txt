 
mundane discourse abounds with utterances referring to other utterances. these meta-language utterances appear with surprising frequency in task-oriented dialogues  such as those arising in the context of a natural language interface to an operating system. this paper identifies some simpler types of dialogue-level metalanguage utterance and provides a computational framework to process such phrases in the context of a case-frame parser exploiting strongly-typed domain semantics. 
1. introduction 
　ivteta-language utterances  i.e. utterances about other utterances in the discourse context  have received little attention in the computational linguistic literature. yet  as a recent attempt  to create a taxonomy of discourse-level metalinguistic devices shows  such utterances are ubiquitous in all kinds of dialogues  including task-oriented man-machine dialogues through a natural language interface. indeed  in a recent informal experiment with a simulated natural language command interface to a computer operating system  we found that one out of every twelve inputs was a metalanguage utterance of one type or another. 
　meta language utterances fall into two primary categories  intra sentential and extra sentential  dialogue level  utterances. the former class may be divided into referential and interpretive meta-linguistic devices. for instance: 
 load  read and rewind the tape in that order.  is a typical referential intra-sentential meta language utterance of the kind that has received some attention in the linguistics literature  1  1 .  in that order  refers to the surface structure sequencing of the lexical items denoting the commands. interpretive metalanguage utterances make a statement about how another portion of that utterance should be interpreted  for instance: 
 metaphorically speaking  john's ideas are out of this world.  
　discourse-level metalinguistic utterances refer to utterances or portions of utterances outside the scope of the immediate sentence. for instance  the third utterance in the dialogue fragment below is essentially a correction of a previous utterance. 
	user: 	print gauss.rel on the diablo printer. 
	system: 	gauss.rel is not a printable file. 
	user: 	oops  i meant gauss.for 
this paper focuses on developing a process model for certain classes of dialogue-level metalanguage utterances  which occur in task-oriented dialogues with greater frequency than intrasentential ones. with the exception of the analysis and classification of dialogue-level metalinguistic utterances in  there is little prior analysis of this phenomenon  although work in discourse focus  1  1  and indirect speech acts  1  1  is of direct relevance in analyzing the general phenomenon. 
　we currently have no general process-level theory for metalanguage comprehension  but we have developed a framework for dealing with an important common subset of discourse-level meta language utterances: those that repair errors or misunderstandings that arose earlier in the dialogue  such as 
 i meant to say transfer  not copy   or 
 cancel that! . in respose to an undesired action or a misinterpretation. 
　this class of utterances  which we call correction utterances  is particularly important for applied natural language because  at the present state of the art  we must expect a natural language interface to misint1rpret its user from time to time  and in any case  a friendly interface should always provide its user with an easy way to change his mind. in fact  in the informal experiment mentioned above  corrections accounted for more than half of all the metalanguage utterances. 
　the rest of this paper  then  will describe a framework for the recognition and interpretation of correction utterances in applied natural language systems  making clear the assumptions on which it is based that make it less than adequate as a model of correction in unrestricted dialogue. the techniques described here apply in the context of a case-frame parser with bottom-up constituent recognition and strong semantic typing  such as those described in  1  1 . 
1. types of correction and their interpretation 
　suppose the following interaction occurs with a natural language interface to a computer operating system: 
	user: 	transfer report.mss to the backup directory 
system: report.mss inserted in the backup  and removed from the current directory. user: i meant copy not transfer 
the intention of the user's second input is clear: he wishes the system to behave as though his previous input had been  copy report.mss to the backup directory . to comply with this wish  the system has not only to execute the new command the user is specifying  but it also has first to undo the consequences of the original command that is being overridden. we call this kind of correction a replacement. the general form of a replacement is that the user specifies an earlier command and a change to be made to it  and the corresponding response from the system is to undo the effects of the specified command and to execute the changed version. 
　note that while this response is the appropriate one from the computer system in this situation  this would not be the case in general. an instructor trying to teach the user how to use the system or a casual observer would react in quite different ways to 

the same utterance. in general  as carbonell  observes  the response to a meta-language utterance will be determined by many factors including the relative social roles of the dialogue participants and their relative capability for action. in our framework for interpreting correction utterances  we avoid having to deal with these complications by assuming the frozen social relation of master/slave between user and computer  and assuming that the computer is the only one with direct capability for action. it is these built-in assumptions that make the framework we are presenting somewhat less than a general solution of the interpretation of referential inter-sentential correction utterances  much less all metalanguage utterances. however  the simplifying assumptions do enable us to develop a computationally tractable model for a subset of meta-language constructions of considerable practical importance. 
　means of identifying prior utterances and signalling desired replacement operations are not always as straightforward as in the example above. consider  for instance: 
	user: 	transfer report.mss to the backup directory 
system: report.mss inserted in the backup  and removed from the current directory. user: i meant report.press 
in this case  the command to be replaced is the same  but the user identifies it and the change to be made to it implicitly. a paraphrase of what he intended is  i meant to type 'report.press' instead of 'report.mss' in the previous command . it is very common to specify a replacement by mentioning a replacement object without mentioning the command in which the replacement is to be done  and often as in the example above without even mentioning the object to be replaced. in general  this can provide rather difficult reference problems requiring the use of intention modelling and focus tracking  but for applied natural language systems where the objects typically fall into one of a small number of distinct semantic types  the reference problem is considerably simplified. our method for finding an object to be replaced where none is mentioned simply consists of selecting the last mentioned object whose semantic type is compatible with the replacement object  and selecting the utterance in which it participates as the one on which the replacement is to be done. this process is analogous to henndrix's simple method of resolving ellipsis ; in the ladder/lifer data-base query interface . 
　a second broad class of correction utterances is that of cancellations. examples are: 
	user: 	transfer report.mss to the backup directory 
system: report.mss inserted in the backup  and removed from the current directory. user: no  cancel that transfer! 
just like replacements  cancellations refer to a previous command which the user wishes undone  the difference being that there is no new changed command to be executed in its place. in both cases  the reference may either be explicit or by mention of an object that was part of the command or  for replacements  by mention of an object of similar type. 
1. implementing the framework 
　this section presents our plans for an implementation to deal with correction utterances in the context of a limited-domain natural language system. the algorithm we propose has four main steps: 
1. identify the input as a replacement or cancellation  and isolate the specification of what is to be replaced or cancelled. 
1. identify the earlier input upon which the replacement or 
p. hayes and j. carbonell 1 
cancellation operation will be performed. and  in the case of replacement  determine what part of the utterance should be replaced. 
1. determine whether the earlier input caused lasting effects  and undo them if possible and necessary1. 
1. in the case of a replacement  redo the earlier input after making the appropriate modifications. 
let us consider each of these steps in turn. 
　to identify meta-language utterances and isolate their important constituents  we plan to use the same case-frame based parsing procedure we have been developing for general use in restricted domain natural language interfaces  1 . essentially the parser combines a top-down case frame instantiation process exploiting strongly typed semantic constituents in restricted domains  with a flexible bottom-up pattern matcher that recognizes individual constituents according to the semantic constraints attached to the slots of the case frames. the pattern matcher may recurse in its constituents  thereby providing at least the power of a contextfree grammar. 
　for correction utterances  there would be two case frames  replace and cancel  which would be identified by sets of patterns instantiated by phrases such as  i meant to say    it should have been  for replace  and  forget it    i didn't intend to  for cancel. replace has two slots  replacement and tobereplaced; the former is mandatory and unmarked; the latter is optional and marked by such phrases as  in place of  and 
 rather than . 	cancel has only one optional unmarked slot  tobecancelled. 
　the parsing process would involve translating inputs with phrases that identified them as one of the two types of correction utterances into instantiated versions of these case frames  thus  i meant edit rather than delete  would result in 
	 caseframe: 	replace 
	replacement: 	  e d i t   
	tobereplaced: 	  d e l e t e     
while  forget it!  would result in 
	 caseframe: 	cancel 
	tobecancelled: 	unspecified-referent  
the details of the notation are not important here  just the observation that the relevant parts of the input are being isolated. 
　after parsing  the next step is to identify which prior input is being replaced or cancelled  and in the case of replacement to decide how it should be modified. the procedure is different depending on whether the tobereplaced  tobecancelled  slot of the input parse is specified. if this slot is specified  then the previous input being modified is taken to be the last one in which the slot filler was mentioned  and for a replace  the input is modified by replacing tobereplaced by replacement. thus for  i meant foo.bar rather than bar.foo   the last operation involving bar.foo would be replaced by one with foo.bar substituted in place of bar.foo. while for  i didn't mean to delete it   the last delete operation would be indicated. if  on the other hand  the tobereplaced  tobecancelled  slot is not specified  there are several possible methods of identifying the input to be modified: 
  if it is a replace  take the most recent input involving an object of the same semantic type as the replacement slot  which must always be specified  and substitute the replacement for that object. so in  i meant to say 
　　if the user wanted a different directory typed and has so specified via his meta utterance  no 'undoing' operation is required. however  if he wanted a different file copied  the new copy of the file should be deleted in order to undo the consequences of the previous action. 

1 	p. hayes and j. carbonell 
foo.bar   the replacement is foo.bar  a file  and so the input to be modified is the last input mentioning a file  and the modification is to substitute foo.bar for that file. 
  if there is a recent error message  modify the input that generated the error message  replacing the object of corresponding semantic type in the parse of the input utterance that generated the error. so  if  edit bar.foo  generates the error message  non-existent file: bar.foo   an input of  i meant to say foo.bar  would modify the edit operation by replacing the offending object  bar.foo  with the replacement filler  foo.bar. 
  otherwise  modify the last input. in a case like  i didn't mean that   there seems little other choice. 
　after identifying and. if appropriate  modifying the relevant previous input  the next step is to undo any lasting effects of the action taken. just what this means will vary depending on the operation specified by the input  and we will maintain a table of inverse operations  so that determination of the appropriate inverse will be straightforward. there are three main classes: 
c there is no inverse and there are no harmful side-effects  
e.g. type  a file on the terminal . 
  there is a direct inverse  e.g. copy  a file  would have deleting the copy as its inverse. in this case  there would also be a mapping specifying how the arguments of the inverse operation would correspond to those of the original operation. 
  the operation had significant  lasting side-effects that cannot be undone  e.g. list  a file on the line printer . in this case  the only thing that can be done is to tell the user the sad news  and ask if he wants to proceed with the modified operation anyway. 
　the final step in the overall algorithm applies only to replacements  and not to cancellations. it simply consists of executing the modified operation that was constructed in the second step. because of the heuristic nature of the entire procedure  this execution of the modified operation and/or the undoing of the consequences of the modified operation should always for safety's sake be preceded by a request for the user's approval. 
1. problems 
　the procedure described in the previous section will handle as it stands most of the replacements and cancellations that we have encountered. nevertheless  there are still many loose ends 
to be tied down and some problems to be solved  such as: 
  deep semantics of actions: a few instances of metalanguage utterances require a much deeper understanding of non-linguistic actions and reasoning about their consequences than our present systems can handle. for instance  consider the following dialogue fragment: 
	user: 	list gauss.for in the diablo printer. 
system: gauss.for queued for printing. 
	user: 	is gauss.for being printed  
system: gauss.for is 1th on the queue. 
	user: 	forget it then! 
the action that must be 'forgotten' is printing the file  not the last request for information about the status of the print queue. clearly  knowledge of pending actions with irreversible consequences versus completed actions without physical consequences is necessary to resolve this example. 
  scope of the undoing: if the user has performed several consecutive operations on file foo.bar  and says   no  i meant bar.foo   he probably intends the whole sequence of operations to be undone and repeated for bar.foo  rather than just the last one. while this would be relatively straightforward modification to the existing scheme  there are more difficult cases. whai happens  for instance  if all the operations on foo.bar are not consecutive  
  undoing versus repetition: if the user says  use foo.bar instead of bar.foo   does he mean that the last operation on bar.foo should be undone  or merely repeated using foo.bar in place of bar.foo  it is clear that a system at the level we are proposing cannot hope to make the appropriate selection in a consistent manner  where 'appropriate' is defined to be the choice made by a human in the same situation. however  if all the alternate.s in an ambiguity are recognized and represented  user queries to resolve the interpretation problems could be generated in a focused manner . 
  level of ellipsis: with such a facility  a user might be tempted to use ellipsis at a level below the normal lexical level of the parser. for instance  he might follow  delete foo.mss  with  no  i meant .press   meaning undelete foo.mss and delete foo.press. here .press may well be a 
unit smaller than the lexical items the system is capable of handling. he might even say   no  i meant the press file   the proper processing of which would entail the system knowing that files with extensions '.mss' are often processed into files with the same name  but extension '.press'  by a certain text formatting program  and that the latter kind of files are called press files. 
1. 