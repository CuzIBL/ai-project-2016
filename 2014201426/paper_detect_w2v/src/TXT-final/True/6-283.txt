 
automated verification is one of the most successful applications of automated reasoning in computer science. in automated verification one uses algorithmic techniques to establish the correctness of the design with respect to a given property. automated verification is based on a small number of key algorithmic ideas  tying together graph theory  automata theory  and logic. in this self-contained talk i will describe how this  holy trinity  gave rise to automated-verification tools  and mention some applications to planning. 
1 introduction 
the recent growth in computer power and connectivity has changed the face of science and engineering  and is changing the way business is being conducted. this revolution is driven by the unrelenting advances in semiconductor manufacturing technology. nevertheless  the u.s. semiconductor community faces a serious challenge: chip designers arc finding it increasingly difficult to keep up with the advances in semiconductor manufacturing. as a result  they are unable to exploit the enormous capacity that this technology provides. the international technology roadmap for semiconductors suggests that the semiconductor industry will require productivity gains greater than the historical 1% per-year to keep up with the increasing complexity of semiconductor designs. this is referred to as the  design productivity crisis . as designs grow more complex  it becomes easier to introduce flaws into the design. thus  designers use various validation techniques to verify the correctness of the design. unfortunately  these techniques themselves grow more expensive and difficult with design complexity. as the validation process has begun to consume more than half the project design resources  the semiconductor industry has begun to refer to this problem as the  validation crisis . 
　formal verification is a process in which mathematical techniques are used to guarantee the correctness of a design with respect to some specified behavior. automated 
   * supported in part by nsf grants ccr-1  ccr-1  iis-1  iis-1  and eia-1  by bsf grant 1  and by a grant from the intel corporation. formal-verification tools  based on model-checking technology  clarke et al  1; lichtenstein and pnueli  1; queille and sifakis  1; vardi and wolper  1  have enjoyed a substantial and growing use over the last few years  showing an ability to discover subtle flaws that result from extremely improbable events  clarke et al  1 . while until recently these tools were viewed as of academic interest only  they are now routinely used in industrial applications  resulting in decreased time to market and increased product integrity  kurshan  1 . it is fair to say that automated verification is one of the most successful applications of automated reasoning in computer science  clarke and wing  1 . 
1 basic theory 
the first step in formal verification is to come up with a formal specification of the design  consisting of a description of the desired behavior. one of the more widely used specification languages for designs is temporal logic lpnucli  1 . in linear temporal logics  time is treated as if each moment in time has a unique possible future. thus  linear temporal formulas are interpreted over linear sequences  and we regard them as describing the behavior of a single computation of a system.  an alternative approach is to use branching time. for a discussion of linear vs. branching time  see  vardi  1 .  
　in the linear temporal logic ltl  formulas are constructed from a set prop of atomic propositions using the usual boolean connectives as well as the unary temporal connective a    next    f   eventually    g   always    and the binary temporal connective u   until  . for example  the ltl formula g request  f grant   which refers to the atomic propositions request and grunt  is true in a computation precisely when every state in the computation in which request holds is followed by some state in the future in which grant holds. the ltl formula g request -   request u grant   is true in a computation precisely if  whenever request holds in a state of the computation  it holds until a state in which grant holds is reached. 
　ltl is interpreted over computations  which can be viewed as infinite sequences of truth assignments to the atomic propositions; i.e.  a computation is a function 
1prop that assigns truth values to the elements of prop at each time instant  natural number . for a computation tt and a point i  the notation  indicates that a formula 

invited speakers 	1 

　designs can be described in a variety of formal description formalisms. regardless of the formalism used  a finite-state design can be abstractly viewed as a labeled transition system  i.e.  as a structure of the form m =  w  w1  r  v   where w is the finite set of states that the system can be in  
w is the set of initial states of the system   is a transition relation that indicates the allowable state transitions of the system  and  assigns truth values 
to the atomic propositions in each state of the system.  a labeled transition system is essentially a kripke structure.  a path in m that starts at u is a possible infinite behavior of the system starting at a  i.e.  it is an infinite sequence of states in w such that uq = u  and for all the sequence is a computation of m that starts at u. it is the sequence of truth assignments visited by the path  the language of m  denoted l af  consists of all computations of m that start at a state in wq. note that l{m  can be viewed as a language of infinite words over the alphabet 1prop. l m  can be viewed as an abstract description of a system  describing all possible  traces . we say that m satis-
fies an ltl formula 	if all computations in l m  satisfy 
that is  if models when m satisfies we also say that m is a model of which explain why the technique is known as model checking  clarke et al.% 1 . 
　one of the major approaches to automated verification is the automata-theoretic approach  which underlies many model checkers  e.g.  spin  holzmann  1 . the key idea underlying the automata-theoretic approach is that  given an ltl formula it is possible to construct a finite-state automaton on infinite words that accepts precisely all computations that satisfy the type of finite automata on infinite 
words we consider is the one defined by buchi 1. a biichi 
automaton is a t u p l e w h e r e is a finite alphabet  s is a finite set of states  s is a set of initial states  f i s a nondeterministic transition function  and is a set of accepting states. a run of a over an infinite w o r d i s a sequence where and for all a run 
is accepting if there is some accepting state that repeats infinitely often  i.e.  for some there are infinitely many i's such that the infinite word w is accepted by a if there is an accepting run of a over w. the language of infinite words accepted by a is denoted l a . the following fact establishes the correspondence between ltl and buchi automata  vardi and wolper  1   for a tutorial introduction for this correspondence  see  vardi  1  : 
theorem 1 given an ltl formula one can build a biichi automaton where and 
             such that is exactly the set of computations satisfying the formula 
this correspondence reduces the verification problem to 
an automata-theoretic problem as follows  vardi and wolpcr  1 . suppose that we are given a system a/ and an ltl 
formula we check w h e t h e r m o d e l s as follows:  1  construct the automaton that corresponds to the negation of the formula  1  take the cross product of the system m and the automaton to obtain an automaton and  1  check 
whether the language is nonempty  i.e.  whether accepts some input. 
theorem 1 let m be a labeled transition system and be an ltl formula. then m satisfies 
if is empty  then the design is correct. otherwise  the design is incorrect and the word accepted by is an incorrect computation. model-checking tools use algorithms for checking emptiness of buchi automata  emerson and lei  1; courcoubetis et al.  1  to check emptiness of in case of nonemptiness  the incorrect computa-
tion is presented to the user as a finite trace  possibly followed by a cycle. thus  once the automaton is constructed  the verification task is reduced to automata-theoretic problems  namely  intersecting automata and testing emptiness of automata  which have highly efficient solutions  vardi  1 . furthermore  using data structures that enable compact representation of very large state space makes it possible to verify designs of significant complexity  burch et al  1 . 
　the linear-time framework is not limited to using ltl as a specification language. forspee is a recent extension of ltl  designed to address the need of the semiconductor industry  armoni et al  1 . there are those who prefer to use automata on infinite words as a specification formalism  vardi and wolper  1 ; in fact  this is the approach of cospan  kurshan  1   in this approach  we are given a design represented as a finite transition system m and a property represented by a buchi  or a related variant  automaton p. the design is correct if all computations in l m  are accepted by this approach is called the language-containment approach. to verify m with respect to p  we:  1  construct the automaton pc that complements p   1  take the product of the system m and the automaton pc to obtain an automaton am p  and  1  check that the automaton am p is nonempty. as before  the design is correct iff am p is empty. thus  the verification task is again reduced to automata-theoretic problems  namely intersecting and complementing automata and testing emptiness of automata. 
1 concluding remarks 
over the last few years  automated formal verification tools  such as model checkers  have shown their ability to provide a thorough analysis of reasonably complex designs  goering  1 . companies such as at&t  cadence  fujitsu  hp  ibm  intel  motorola  nec  sgi  siemens  and sun are using model checkers increasingly on their own designs to reduce time to market and ensure product quality  cf.  beer et al  1 . 
1 	invited speakers 　there has recently also been an fruitful interaction between model checking and planning in ai. on one hand  the usage of satisfiability technology to solve planning problems  kautz and selman  1  has been adopted into model checking 
 biere et al.  1; copty et al.  1 . at the same time  symbolic techniques from model checking have been adopted into ai planning  cimatti and roveri  1 . finally  temporal logic and the automata-theoretic perspective has shown to be useful for planning with temporally extended goals  bacchus and kabanza  1; 1; giacomo and vardi  1; calvanese et a/.  1 . 
