an inductive database for mining temporal patterns in event sequences
alexandre vautier  marie-odile cordier and rene뫣 quiniou
irisa - dream project campus de beaulieu 1 rennes cedex  france
{alexandre.vautier marie-odile.cordier rene.quiniou} irisa.fr
모
1 introduction
data mining aims at discovering previously unknown and potentially useful information from large collections of data. the discovered knowledge  in the form of patterns  is extracted without any extra information about data. a pattern is a representation of a concept  rules describing properties of data  clusters in databases  etc.  that generalizes some data in a database.
모imielinski and mannila  imielinski and mannila  1  designed a data mining formalization framework named inductive database  idb . the main goal of idbs is to manage knowledge discovery applications just as database management systems successfully manage business applications. idbs contain patterns in addition to data. the data mining process is modeled as an interactive process in which users can query data as well as patterns. idbs represent also a good way to take advantageof the efficiencyof database algorithms by using jointly data mining and database algorithms.
모some idbs implementations  lee and de raedt  1 use sequences of symbols as data and complex sequences of symbols as patterns  sequences with gaps . in many problems one often needs to discover patterns which are more sophisticated than a simple sequence of symbols. to this end  we propose to extend idb patterns by adding numerical constraints. in this proposal  the data are event sequences and the patterns are chronicles. a chronicle is composed of events and numerical temporal constraints  in the form of numerical intervals  on delays between their occurrences. figure 1 illustrates a chronicle c1 and an event sequence l1.
모a chronicle is recognized in an event sequence as follows: a set oi of events of the sequence l1 instantiates the chronicle c1 if every event of c1 is instantiated by an event of oi respecting type and temporal constraints. a set oi is called a chronicle instance of c1. for example  the event sequence l1 has six instances of the chronicle c1: |ic1 l1 | = 1.
1 time in data mining
several solutions have been proposed to tackle the problem of time integration in data mining. some pattern extraction techniques use symbol ordering as a model of time. for instance  winepi and minepi  mannila et al.  1  extract patterns represented by serial or parallel sequences of symbols. seqlog  lee and de raedt  1  extracts ordered sequences

figure 1: a chronicle c1 of size 1: intervals labeling edges represent bounds on the distance between event times as  1 뫞 tb  ta 뫞 1. right  1 instances of c1 in a sequence l1.
of symbols with gaps. parallel and serial notions can also be expressed in chronicles. in addition  they can state numerical constraints on delay between events.
모time can be also represented by a special numerical attribute. for instance  yoshida  yoshida et al.  1  extracts frequent itemsets containing a temporal feature. their algorithm extracts  delta-patterns  that are ordered lists of itemsets with time intervals between two successive itemsets  as for instance: // // which specify the numerical temporal constraints between the itemsets. however  interval bounds of delta-patterns are always positive whereas interval bounds of chronicles can be negative.
모our goal is to discover chronicles that are frequent in some event sequences and infrequent in other ones. for instance  let l1 and l1 be the event sequences of figure 1. a complex query such that freq c l1  뫟 1 뫇 freq c l1  뫞 1 asks for the set of chronicles that are frequent in l1 and infrequent in l1 according respectively to thresholds 1 and 1. chronicles cs and cg  fig. 1  satisfy this query because both cover three instances in l1 and only one in l1.
	//	//


instance of cs or cg in l1: {  a 1   b 1  }
figure 1: chronicles search under frequency constraints furthermore  we introduce a generality relation between chronicles: a chronicle c is more general than a chronicle c1  noted c v c1  if there is a match between c and c1 such that every event of c is matched to an event of c1 and the temporal constraints of c contains the corresponding constraint in c1. thus  we can note that cg v cs  fig. 1  and that there is no solution chronicle more specific than cs or more general than cg.
1 frequency of chronicles in a sequence
the most used interest measure for patterns mining is based on frequency. the use of a generality relation makes chronicle search based on frequency easier  but only on the condition that constraints on frequency satisfy monotonicity or anti-monotonicity properties. let c be more general than c1. the threshold constraints on frequency satisfy one of these properties if the frequency of c is equal or greater than the frequency of c1 in an event sequence. to ensure these properties for some frequency measure  we introduce a recognition criterion q that specifies how instances of some chronicle are selected in a sequence and consequently how the frequency of this chronicle is computed.
모some recognition criteria have been defined in the literature. the minimal occurrences criterion  mannila et al.  1  selects all the shortest instances of an episode  a partially ordered collection of events occurring together . the earliest distinct instances criterion  qe&d  dousson and duong  1   selects all the instances such that two instances of a same chronicle have no common events and occur as early as possible in the event sequence according to a total order on instances. let freqqe&d c1 l1  be the frequency of c1 computed on the event sequence l1  fig. 1 . the recognition criterion qe&d recognizes the set of instances e = {o1 o1 o1} and the value of freqqe&d c1 l1  = |e| = 1.
1 queries on event sequences
let p and n be two sets of event sequences and t be a set of frequency thresholds. every event sequence l has a threshold tl. if l is an element of p  resp. n  then tl is a minimum  resp. maximum  frequency threshold. our goal is to extract some phenomenon in the form of chronicles. these are frequent in at least one event sequence of p and infrequent in every event sequence of n. a query has the general form:

모the computation of frequent and maximally specific chronicles fmcq l tl   in an event sequence l accordingto a thresholdtl is performedbythe levelwise algorithmof face  dousson and duong  1  that we have adapted to the task. the method consists in computing all the fmcsfrom the different event sequences separately  with face   memorizing them  and merging them to get the solutions of the query: this method is efficient if we consider a set of queries that use the same sets t and  p 뫋n . we use mitchell's algorithm to merge thesefmcs. this algorithmis extensively used to compute the version spaces of symbol sequences  de raedt and kramer  1 . it computes the bounds of the version space from a conjunction of constraints. query  1  is rewritten in such a way as to use mitchell's algorithm:

 1 
where fmcq e t  = sl뫍e fmcq l tl .
모for each chronicle from fmcq p t   the version space of a conjunction of constraints is computed by mitchell's algorithm. the union of these version spaces gives the solutions set to query  1 . one of the main interests of this method is that it needs to compute only once thefmcsin each sequence.
1 conclusion
we have presented an original method that extracts temporal information in the form of patterns named chronicles. these patterns use numerical temporal constraints on events. furthermore  they provide a way to express sequentiality and parallelism between events and they generalize temporal patterns used by mannila and de raedt  mannila et al.  1; lee and de raedt  1   among others. chronicles are extracted by querying an idb that contains event sequences and chronicles. the user sets the minimum or maximum frequency thresholds of searched chronicles in event sequences.
모our contribution introduces the notion of recognition criterion that generalizes the specification of pattern frequency computation on temporal data. furthermore  we use a generality relation on chronicles that enables us to adapt version space algorithms to manage numerical temporal constraints. these algorithms require the prior computation of frequent and maximal chronicles for each event sequence used in the query. this computation is performed by a data mining tool that we have adapted to the task. our approach can compute the complete and correct set of solutions.
