 
a new formalism for building network models in prolog is proposed. it is based on a new semantic interpretation of the prolog variables and clauses  which are used to represent the network links and nodes respectively. the problem of attribut ed gra ph mod el of polyhedral objects is used as an application area  where the proposed methods are examined. 
l. introduction 
graph models are commonly used in ai. their expressive power makes them suitable in almost all ai fields. however  in the framework of prolog programming graph algorithms have a restricted meaning of graph searching techniques. searching graphs is a fundamental technique for solving many ai problems as state-space represented problems  game playing  planning etc. howeve r  the re are other opera tions o n graphs not less useful in the context of ai. such are for example graph isomorphism 
 graph matching  and constraint satisfying  constraint propagation . graph models can be viewed more generally as network models  such as neural networks  knowledge representing networks  semantic networks  frames  and many other distributed comput ational models g rouped a round th e term connectionism. 
1 	tools 　the present paper deals with a graph model of a class of visual objects polyhedra. the prolog implementation of the problem inspired a new concept for representing graphs and networks. the proposed representation scheme requires some extensions of the standard prolog mechanisms  which are introduced in an experimental version of the language developed by the author. 
1. attributed graph representation of polyhedra 
the polyhedra are a large class of graphical objects frequently used in geometric modeling and vision. they can be used for modeling curved objects as well by approximation. this class is suitable for object recognition since there exist well developed methods for extracting linear features from real images. this aspect of the problem is discussed in 
 engelbrecht and wahl  1 . the prolog based approach for polyhedron recognition is described in  markov and risse  1 . in the field of cad the class of polyhedral objects is used for the 1-d interpretation of 1-d sketches. this problem is recently considered in the framework of network models  which we discuss in the next sections. here we outline only the basic ideas concerning polyhedral modeling in prolog  which are used later for building an alternative network model of the same problem domain. 
　a polyhedron can be considered as a structured collection of its parts - vertices and edges. for example a four-side figure can be expressed in prolog by the list 
　 edge l 1  edge 1  edge 1  edge 1 l    where the structure edge m n  represents an edge connecting the vertices m and n. the above list represents a too large class of geometric figures. to obtain a sub-class  e.g. parallelogram  rhombus etc.  we should introduce more geometrical information. in our model this means some constraints i.e. 

attributes attached to each edge. for this purpose the following form of the edges can be used: 
　edge vl  v1 slope .length  using this notation a parallelogram can be represented as: 
　  edge l 1 1  edge 1 1   edge 1 1  edge 1 1    the edges of the above figure are separated in 1 groups  distinguished by their slopes and lengths. these groups are implicitly defined by edge attributes having equal values  which we call same-valued classes. a very important feature of this representation scheme is the possibility to define a class of such figures  using variables instead of fixed names or values standing for the vertex names and attributes. the above shown list representing an instance of a 
　parallelogram can be transformed in the following form: 
  edge a b sl ll  edge b c s1.l1 . 
     edge c d sl ll  edge d e s1 l1    in this list the equal names or values are replaced by shared variables. using variables as arc attributes ensures that the class representation is free of any specific geometric properties as size  orientation  etc. the only fact taken into account is the equality or inequality of the attributes  and this is provided by the built-in prolog unification mechanism. the real values of the attributes can be of any type and measurement units. since parallelism and same length are properties  preserved by the parallel projection  this class representation can be used for 1-d polyhedra. 
　our aim now is using the described representation scheme to define a procedure  which can check whether an instance belongs to a certain class. in the graph terminology this is called graph isomorphism or graph matching. we propose a graph matching procedure based on the following idea: a graph is a subgraph of another graph  if and only if the set of all arcs of the first graph is a subset of all arcs of the second graph. during the subset operation the variables  representing the class nodes and attributes are successively instanti ated to the corresponding instance nodes and attributes. then the consistency of these instantiations is checked and possi bly backt ra cki ng oc cur s. the wh ol e process is hidden in the recursion used in the definition of the predicate match  which is a slight modification of the predicate subset  described in  clocksin and mellish  1 . 
match  a!x  y :-member a y  match x y . 
match    --l. 
membekedge x y s l   edge x y s l ij . member edge x y s l   edge y x s l ij . 
member x   it  :-membekx t . 
	the pure subgraph 	matching problem is 
np-complete. however  in some cases a proper representation may be found to make the graph matching algorithm applicable in practice. the aim is to minimize the number of the backtracking steps occurring in the  bad  ordering combinations obtained enumerating the graph arcs. in our case the use of attributes in the graph improves the efficiency as it is shown in  markov and risse  1 . however  there is a  secondorder  problem  which appears in practice where more than one class is used. the overall efficiency in such a case depends very much on the order of the selected classes to be recognized  since a possible matching between the instance and each one of the classes is tested sequentially. a solution of this problem can be found in matching the instance against all classes simultaneously. such a scheme is proposed in the next section. 
1. database representation of attributed graphs 
as we mentioned in the previous section the problem of the different ordering combinations of the edges in the class and in the instance is solved by involving set operations. besides the lists  the prolog database is also suitable for storing set elements. an element belongs to such a set if its activation as a goal succeeds. thus a subset operation is just an execution of a conjunction of goals. for example the following program checks whether an instance of a rhombus belongs to the class of all rhombuses. 
	markov 	1 

/  an instance of a rhombus */ edge  1 1 . edge 1 1 . edge 1 1 . edge 1 1 . 
/x the class of all rhombuses  / 
 - edge a b sl l  edge b c s1 l   edge c d sl  l  edge d a s1 l . 
the above scheme is much more efficient than the corresponding subset operation on lists  since two prolog built-in mechanisms are directly used - database access and backtracking. however  it is impossible using this representation to check a subgraph to graph isomorphism  with missed edges in the instance  e.g. hidden edges in a real image . that is a substantial shortage  which makes this approach inappropriate for our model. to avoid that we introduce an extension of prolog  which allows shared variables among different clauses in the database. 
　the proposed extension  which we call  net-clause   is syntactically a prolog structure with the functor  :  and arguments normal clauses. the clauses contained in a net-clause form a special domain in the prolog database  which has the same semantic as the normal prolog clauses  taking into account the special behavior of the variables contained. 
　a natural semantic interpretation of the proposed net-clause is a network  where the nodes are represented by clauses and the connections - by shared variables. the nodes can be used as processing units and the connections - as channels for information transfer. this interpretation is our basic paradigm  which will be elaborated further in the paper. 
　the features of the net-clause variables are used to improve the attributed graph model of polyhedra. besides for representing the topology and geometric constraints shared variables are used to represent the part-of hierarchy between the vertices and the objects they constitute  so that after a successful matching of an instance  the instantiated variables  vertices  indicate the corresponding class  where they belong. the network illustrating this idea is shown in figure 1. 

figure 1. an example network for representation of polyhedra  the topology and the 
 part-of'' links are shown in different line styles  
the following program implements the network from figure 1.  the use of a special prolog extension  ensuring all different variables to be bound to different objects  is essential in this example. such an extension is also available in prolog iii.  
/* edges of the figures  / edge a b sl ll : edge b c s1 ll : edge c d sl ll : edge d a s1 ll : edge b e s1 l1 : edge e.f sl ll : edge f a s1 l1 : edge e g s1 l1 : edge g a s1 l1 : 
/* classes of figures  / class four side figure a b e g : class parallelogram a b e f : class rhombus a b c d . 
/* network activation  / 
 - edge l 1 1  edge 1 1   edge 1 1  edge 1 l 1   class name x y z p  nonvar x   nonvar y  nonvar z  nonvar p -

name=parallelogram 
1 	tools 

　the network from figure 1 has a shortage inherited from the static behavior of described model. let us explain this. the facts edge can be considered as inputs and class - a s outputs of the network. to obtain an answer we should activate both the inputs and the outputs  call them as goals  specifying the i n p u t / o u t p u t values as arguments . this scheme is good as long as we know the outputs previously. but that is not the case in our example. we enter a pattern  the instance  and then scan all possible classes to find which one is matched. in other words if we have many outputs in the network we should check all of them to find which one is active. 
　to make the net-clause network more dynamic we extend the semantics of the clauses to local processing units  which are activated on certain conditions. in terms of prolog this means the possibility to activate the goals in the body of the clauses. at the normal prolog computation a clause is activated when the current goal unifies its head. in our case there is no current goal  instead there are instantiated variables and we can use them as an indication that some processing unit has enough information to do its work. so  we define the following activation rule: a clause body is activated w h e n the clause head is  enough  i n s t a n tiated. the quantitative measure of the clause head instantiation is the number of its uninstantiated variables - arguments. 
　an implementation of the above idea is the built-in predicate activate n   supported by our experimental prolog version. it activates all clause bodies  whose heads have less than n uninstantiated variables - arguments. in this way the variables in the head of a clause can be viewed as activati ng links. we introduce also inhibitory l i n k s   represented syntactically as unary minus followed by the variable name  e.g. ~x. such links are interpreted by the activation procedure as a negation of the instantiation condition  i.e. if x is instantiated  ~x is treated as an uninstantiated variable and vice versa. 
　the best suited computational scheme for the outlined network model is the parallel one. since we could not avoid the sequential activation of the clauses we simulate the functional behavior of a parallel execution based on the following features: 
　 a  multiple s c a n n i n g t h e net-clause database and executing each time a l l active clauses  so that each clause is executed successfully just once. this scheme ensures a special activation order guided only by the activation rule 
　 b  delaying the execution of the active clauses w h i c h have failed. this rule is based on the assumption that an active clause may fail due to some conditions in the network  not present at the current pass through the net-clause database. that is a way to synchronize the work of the hidden network units or to organize switching between branches of the network. functionally the same effect could be reached using inhibitory links. in fact the two mechanisms reflect the two paradigms - logic programming and network modeling  integrated in the proposed formalism. 
　 c  according to  a  and  b  the clauses are checked repeatedly and those of them which satisfy the activation condition are executed. this process terminates when no more variable instantiations have been done during a pass through the net-clause database. 
　 d  executing all active clauses in a common environment. this feature of the activation procedure is very important  since it ensures that all newly established connections between the clauses  variable instantiations  are kept until all active local procedures in all units of the network are executed. 
　using the newly defined predicate activate  the program representing the network for recognition of planar figures  shown in figure 1 can be modified by replacing the facts class with the following clauses: 
four side figure a b e g :write 'four side figure matched' : 
parallelogram a b e f :-
write 'parallelogram matched* : 
rhombus a b c d :-
write 'rhombus matched' . 
now initiating the network by the question 
 - edge l 1 1  edge 1 1   edge 1 1  edge 1 1   activate o . parallelogram matched 
	markov 	1 
we obtain as an answer the name of the class  which the entered pattern belongs to. 
　in the 1-d polyhedral model the instance may contain less edges than the class  e.g. hidden edges . in this case the activate predicate should be used with an argument greater than 1  allowing in such a way  fuzzy  matching. 
　the above examples are in fact one-layer network models where the local processing capabilities of the network are not used. this is because the patterns to be recognized are quite simple. the basic properties of the characteristics specifying them are only two - equality and inequality. however there are some geometric properties  which can not be expressed in terms of equality and inequality. for example such a property is the perpendicularity of edges. to check it some calculations are required  which can be performed by intermediate nodes  hidden units  in the network. using the edge facts from figure 1 and adding the following clauses we obtain an extended network  capable to recognize rectangulars and squares too. 
/* general case of four-side figures */ four side figure a b e g :-
write 'four side figure matched* : 
/* calculating perpendicularity */ perpendicular sl  s1 :-done-ok  
 1 is  s1-s1  mod 1  p=ok;true : 
/* non-perpendicular figures */ parallelogram a b e f done ~p :-
write 'parallelogram matched1 : 
rhombtis a btc d done ~p :-
write 'rhombus matched' : 
/* figures with perpendicular edges */ rectangular a b e f p :-
write 'rectangular matched1 : 
square a b c d p :-
write 'square matched1 . 
the clauses representing the classes of parallelogram and rhombus are modified according to the use of the hidden unit perpendicular. they become candidates for activation only after the check for perpendicularity has been done  the variable done is instantiated . this check actually distinguishes the two groups of classes - with 
1 	tools 
and without perpendicular edges  indicated by the variable p  which is used respectively as an activating or an inhibitory link. 
1. connectionism in prolog 
the described results in network modeling in 
prolog may be naturally discussed in the more general framework of connectionism. that is a field focusing a growing interest  characterized mainly by the quite old idea that hard problems could be solved interconnecting simple processing units. connectionism may be characterized by several features  arbib  1   which we discuss in connection with the features of our network  described in the previous section. 
　 a  the use of networks of active computing elements  with programs residing in the structure of interconnections. the active computing units in our model are the clauses  activated on certain conditions or unconditionally. the procedure specifying the way the patterns are processed  matched  actually resides in the structure of shared variables  i.e. the structure of interconnections  representing the topology and the geometry of the polyhedra. 
　 b  massive parallelism  with no centralized control. the proposed here network formalism is implemented in a sequential computational environment. however it is designed in such a way that the sequential implementation affects minimally the network properties. although the processing of the entered in the network pattern is based on backtracking  this process is hidden and the result does not depend on the order of the subgoals specifying the pattern. thus the process of setting up the inputs/outputs of the network can be viewed actually as a parallel one and the one-layer models without hidden units can be considered parallel too. 
　the features of the activation rule  described in the previous section are in a 
　sense steps toward simulating parallelism in multi-layer networks. the functional behavior of a parallel computation is fully reached when the network satisfies two quite natural requirements: 
　1. the execution of the active clauses has no  side effects   in prolog terminology ; 

　1. the network is consistent. clauses  which  undo  what have been done by other clauses  and never-fulfilled conditions may be considered as network inconsistencies. 
　the described network computational scheme can be viewed in the framework of the parallel computation as one without centralized control and synchronization. act u a l l y t h i s is a  shared memory architecture   where the role of the common memory is played by the shared variables in the net-clause. 
　 c  the encoding network semantics either by single network units  localized representation  or by patterns of activity in a population of such units  distributed representation . the use of the two representations is essential in the described example of a polyhedron recognition network. the semantics of the classes is locally represented by some of the network nodes and the patterns representing the class characteristics are distributed in the interconnections of the network. as it is mentioned in  arbib  1  the distributed representation is based on the principle  letting the features fall where they may   which actually is the main principle of the polyhedron recognition network too. 
1. conclusion 
the aim of the present paper is to outline the basic concepts of using prolog as a framework for building network models. for lack of space we have skipped the implementation details  though they are critical for the applicability of the proposed formalism in practice. in fact the only source of inefficiency could be the activate predicate  which involves some notion of a sec ond- order logic i gnor ing the c laus e functors as an access rule. however the activation rule ensures that only the clauses  which could do some  useful  work are activated  and all others are simply skipped. thus  formally speaking the effectiveness of the net-clause network and a normal prolog program must be the same  as in both cases only the  useful  clauses are executed  of course  if both models are  enough  adequate to the problem domain . 
　the network programming in prolog could be a feasible tool for some applications as vision  e.g. polyhedron recognition  1d interpretation of 1d sketches etc.   semantic networks  production systems and other schemes for knowledge representation  and natural language processing. 
　further research in the above-listed fields of application needs at first deepening of the proposed formalism  which we see focused toward the following topics: 
　 a  extending the functionality of the connections allowing not only equality and inequality to be propagated through the shared variables  but some calculations to be performed during the unification  solving equations  constraint satisfying etc. . this means transferring some of the hidden unit semantics to the network links. 
　 b  using other activation schemes  e.g. activation by need  when a variable instantiation is required by a processing unit  the clause  capable to instantiate it  is activated . 
　 c  developing learning procedures suited to the proposed network representation. 
acknowledgments 
i owe special thanks to l. sinapova for her support in preparing the paper. i am also grateful to d.dochev and g.agre for the helpful discussions about network modeling in prolog. 
