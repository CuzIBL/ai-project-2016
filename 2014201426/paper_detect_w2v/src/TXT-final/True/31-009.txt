 
with increased processor speed and improved robotic and ai technology  researchers are beginning to design programs that can behave intelligently and interact in the real world. a large increase in processing power has come from parallel machines  but taking advantage of this power is challenging. in this paper we address the issues in designing planners for real-time ai and robotic applications  and provide guiding principles. these principles were designed to minimize the difference between the new real-time model and the standard off-line model. applying these principles yields a better-structured application  easier design and implementation  and improved performance. the focus of the paper is on a design methodology for implementing effective planners in real-world applications. using ephor  our runtime environment   and applying the described planner principles  we demonstrate improved performance in a real-world shepherding application. 
1 	introduction 
with increasing processor power there has been growing interest and research work in designing intelligent applications that interact with the real world. combining real-world requirements with uncertain and complex cognitive activities leads to issues of resource allocation and decision-making in real time not previously encountered in ai or robotics applications. we call intelligent parallel applications with unpredictable aspects and a complex mixture of competing and cooperating demands soft parallel real-time applications  or sparta s. building spartas is difficult because it involves 
　*this material is based upon work supported by nsf research grant number cda-1  darpa research 
grant mda1-j-1  and onr research grant number n1-1. robert wisniewski was supported in part by an arpa fellowship in high performance computing administered by the institute for advance computer studies  university of maryland. the government has certain rights in this material 
not only designing the intelligent portion of the application  but also handling both soft real-time constraints  e.g. robot planning   and hard real-time constraints  e.g. a balance subsystem . 
　if a sparta programmer is oblivious to real-time issues when designing an application  poor or incorrect behavior may result. tension arises due to the discrepancy between how an ai programmer wants to design an application and the requirements of planning and acting in the real world. we have developed ephor1  a runtime environment1 to support sparta development and execution. our goal is to provide as much of the off-line programming model as possible  so that the standard techniques available for designing intelligent robotic applications can be applied to spartas. 
　in this paper we focus on techniques for implementing effective planners1 in parallel real-world applications. previously  designing a planner for a sparta meant tracking resource allocation  timing tasks  and handling other concerns of interacting in the real world. the combination of ephor and our model of planning in spartas considerably sirnplies design. 
　a key observation we will leverage throughout our discussion is that in a dynamic real-world environment it is important to be able to adapt. while this may be intuitive  its implications for planner  and runtime  design are significant. the importance of adapting holds both for the action taken by the application as well as how the application decides on that action. more concretely  in later sections we discuss the advantages of having several planners  with the same goal  varying in resources consumed  and thus quality of result . this diversity is useful because it allows an adaptive decision to be made during execution when the application needs a particular goal solved. in part  the principles for designing sparta planners are motivated by what tools/mechanisms the underlying runtime environment 
ephor was the name of the council of five in ancient greece that effec-
tively ran sparta. 
1 
   a runtime environment is a combination of library calls and system code working together for a specific purpose  e.g.  a lisp interpreter can be thought of as a runtime environment. 
   throughout   planning  refers to all forms of cognitive reasoning  problem-solving  and decision-making techniques for deciding what to do next  from simple random choice through sophisticated modern planners. and operating system can provide to the application programmer. creating a happy marriage between what can be supported  from the system's point of view  and the ideal ai programmers' model  is extremely important to implementing successful robotic real-world applications. 
　throughout  we use the specific application domain of shepherding to provide concrete examples of our principles  and to demonstrate their effectiveness. the shepherding application domain is flexible and maps onto a large class of real-world ai applications that involve uncertain actions  uncertain sensing  real-time constraints and responsibilities  planning and replanning  dynamic resource management  dynamic focus of attention  lowlevel reflexive behaviors  and parallel underlying hardware  e.g. purposive vision  autonomous vehicle control and navigation . a real-world shepherding implementation runs in our robotics laboratory  ballard and brown  1  von kaenel and wisniewski  1   see figure 1   but the results in section 1 are from a real-time simulator that allows greater flexibility in experimentation. the implementation consists of self-propelled lego vehicles   sheep   that move around the table   field   in straight lines but random directions. each sheep moves at constant velocity until herded by the robot arm   shepherd    which redirects it towards the center of the field. a second robot arm   wolf   can encroach on the field and remove   kill   sheep if not prevented. the shepherd has a finite speed and can affect only one sheep at a time. the goal of the shepherd is to keep as many sheep on the table as possible  and the more powerful the sheep behavior-models and look-ahead  the better the results. 
figure 1: the real-world shepherding application  camera overhead  
　general approaches to designing spartas are only now beginning to emerge  and usually individual solutions do not generalize well. we believe this is a two part problem. first  underlying support for developing a general framework is needed. secondly  the principles in designing effective planners for these types of applications must be understood. in other work we have addressed the first concern. in this paper we address the second by providing principles for sparta planner design that yield a better structured application  simplify design  and improve performance. we start by providing a model of spartas in section 1. section 1 lists and describes in detail the principles involved in designing effective planners for spartas. this section is the focus of the paper. in section 1 we provide a quick overview of our application and support  and results demonstrating the effectiveness of the planner principles. section 1 provides conclusions and describes continuing work. 
1 	a model of spartas 
this section is devoted to discussing models for designing spartas. we describe the model we have chosen and therefore its applicable domains. there are two disparate approaches to designing real-world ai and robotic applications. a subsumption model  brooks  1   brooks  1  claims intelligent behavior will emerge from low-level reactive modules. while our model includes reactive modules as part of its real-time component  the allowance for time-constrained high-level reasoning places it in the second  more traditional ai camp. as in a modular architecture  fodor  1   we assume different  loosely coupled mechanisms for lowlevel reaction-perception and high-level reasoning. 
1 
analysis  etc.. with a traditional run-time and underlying operating system  the most significant differences between applications occur at the executive level. unfortunately it is this level that is most task-dependent and has the fewest standard formalisms. researchers have approached this aspect of spartas from different angles. both  gervasio and dejong  1  and  hadavi et a/.  1  describe planners effective in handling varying environmental factors. hoogeboom and halang  hoogeboom and halang  1  propose a more general approach suggesting that  in anticipation of a deadline at which some task must be fulfilled  it should be possible to choose from different program segments the one that maintains optimum performance.  we concur. 
　a goal in our work  and implicit in the planner specifications  is the desire to design a general architecture rather than just one for a specific application. while there are accounts of specific applications  brown and terzopoulos  1  that have clear design principles and correct behavior  it is difficult to extract useful code from these programs to help design another sparta. some other work that  has looked at dynamic tradeoff decisions is schwuttke and gasser's  schwuttke and gasser  1  dynamic trade-off evaluation algorithm that decide which data to monitor in a spacecraft. durfee  durfee  1  suggests a more general method of supporting individual cooperating components. other prominent work in this area of developing general mechanisms for supporting spartas is by gopinath and schwan  gopinath and schwan  1  who suggest objects that can move along a continuum of resource use and describe mechanisms for scheduling these objects in a distributed system. 
1 planner design and necessary 
support 
1 	background 
let a goal be something the application wishes to accomplish  e.g.  save sheep  and a technique be a method or algorithm for accomplishing a goal  e.g.  planner a . figure 1 illustrates the model of the program structure for a sparta. throughout a program's execution it will need to solve many goals and frequently will need to solve the same goal repeatedly. if each goal has only a single  sequential  fixed technique to solve it  then there will be no flexibility in choosing a technique for solving a goal and thus the program will have sacrificed an entire dimension of adaptability  it can only choose different goals indicating a different course of action . 
　interacting with the real world implies coping with the unknown and the uncertain. goals may be generated in regards to unexpected environmental stimuli. as a specific example from our real-world shepherding application consider the entry of a wolf into the field; a high priority goal   kill wolf  must be solved. some goals may take longer or shorter than expected because of a change in the environment or because of varying amounts of available resources  if while solving the  find next sheep to save  goal on seven processors  six of them are preempted for other tasks  this goal will take consider-

ably longer than originally expected to solve . an unpredictable environment can also cause additional goals to be needed while no longer requiring the results of others. for example  if while in the middle of solving the  save sheep goal   the robot arm is allocated to killing a wolf  there is no reason to continue to solve the  save sheep goal  since the robot arm will not be available  instead the processor s  could be freed and given to another goal. clearly  the internal state of a sparta application  runtime  and operating system will be highly variable over time. to make efficient use of resources the application must cooperate with the underlying runtime to allow the whole system to adapt dynamically to varying conditions. using worst case analysis to pre-configure the system is too inefficient  paul et a/.  1l  strosnider and paul  1 . 
　with our model  the sparta programmer can still conceptualize their program in terms of goals that need to be solved and techniques for implementing those goals. the only difference between previous models for off-line applications and the model described by our planner principles for spartas is the emphasis on specifying several ways of solving a given goal. of course  to take advantage of this new model  underlying support is required  see  wisniewski and brown  1    and the ability to inform the underlying support about the goals and techniques. we have developed a simple scheme that allows the programmer to communicate a sparta's program structure to the underlying runtime environment  which we briefly describe in section 1. convinced that we can support such a model we devote the rest of this section to discussing the details and giving examples of the our planner principles. 
1 	designing a suite of planners 
it is essential for spartas to maintain as much flexibility as possible both in their ability to choose different courses of action based on the environment and their ability to have multiple ways  techniques  for determining a particular course of action. below we list  in order of increasing effectiveness  a set of principles for planner design. after the list we describe each item in detail and provide examples. the more of the principles that are followed when designing a sparta planner the better the program's performance will be. 
1. provide techniques that can vary in completion time  e.g.  anytime algorithms  liu et a/.  1  . 
1. provide multiple techniques that: 
a  use different resources  e.g.  infrared 
sensor/binocular vision  
b  vary  significantly  in quantity of resources 
used  cpu time  etc. . 
1. provide parallel planners that: 
a  use a  bag of tasks   processor farm  model 
b  use different resources 
c  vary in quantity of resources used. 
　the intent of these recommendations is to provide flexibility of resource allocation in as many dimensions as possible. the more flexibility designed at this level the more adaptable the program will be to unforeseen events since the underlying runtime environment  ephor  will be able dynamically to select from a more diverse set of techniques and thus will more likely be able to find an appropriate technique for a given situation. 
1 description of planner principles following the outlined planner principles yields an adaptable program that the allows the runtime to adjust to unexpected events and thus achieve increased performance. for each principle above we provide a detailed description and give an example from the shepherding domain described in the introduction. 
　1  provide techniques that can vary in completion time 
　a method for meeting the challenge of time variability is to design a planner that can move along a continuum of completion times as suggested by gopinath and schwan  gopinath and schwan  1 . such a technique is similar to the motivation behind anytime algorithms or imprecise computations  liu et a/.  1l  in which after a certain minimum time the program's result improves until a final completion time. these methods allow the underlying system dynamically to allocate the maximum amount of time available to the goal while still allowing for early termination if processor cycles are needed by other goals. 
　an example from our shepherding application is the vision processing goal of determining the centroid of each  circularly marked  sheep. a quick approximation of the centroid may be found by scanning a horizontal and then vertical line  von kaenel and wisniewski  1 . after this initial phase we have a reasonable centroid. continuing by searching every pixel and using a weighted mean to determine will provide more accurate results  and given time  would be preferred. 
　1a  provide multiple techniques that use different resources to achieve the same goal 
　ideally  these techniques would have non-intersecting resources  but techniques using different but not unique sets are still useful. for example  having one technique that uses processing time  a camera  and the robot arm  and another that uses processing time  an infrared sensor  and the robot arm. during execution  when this goal needs to be solved  the runtime will still be able to solve the goal even if the infrared sensor is allocated to another technique by running the technique that uses the camera. 
　as a specific example consider a mobile robot that has two techniques it can use to find the distance to a wall. it has an infrared sensor that may provide a fast response and a pair of binocular cameras it can also use. if both resources are free when it needs to solve the getdistance-to-wall goal  then it prefers to use the infrared sensor because it is faster. however  if the high-level executive decides it is time to obtain the distance to the wall when the infrared sensors are being used to avoid an object  the runtime can still solve the goal by running the technique that uses binocular vision. 
　1b  provide multiple techniques that vary in quantity of resources used 
　make the techniques differ in the amount of resources they use and consequently the quality of the result they produce. the most straightforward example is the amount cpu time consumed. anytime algorithms capture this notion and are supported by ephor  but even more significant differences yield greater adaptability. for example: emergency or reflexive 1  algorithms  heuristic o n1or1  algorithms  or brute force search 1n  algorithms. concentrate on designing tasks within constant factors of the expected time available for this task. this dimension of flexibility allows the runtime dynamically to select the best technique based on the internal load on the sparta's resources. there may be periods of time when the application desires many goals to be solved simultaneously and other periods of relative inactivity. we have found a diversity of planners provides the best overall behavior for a given goal  because during quiet periods a higher quality technique can be run and during periods of high demand a simple technique can still be run  as opposed to being unable to run any technique . 
　for example  in the shepherding application we have implemented a simple planner that just looks for the first sheep it finds moving away from the center and computes the intercept to save it. we also have implemented three variations of another planner varying in the amount of lookahead performed. one looks two sheep saves into the future when considering a move. the others look three and four moves. lookahead is useful because  for example  it may be the case that by letting the farthest sheep from the center go and moving to the other side of the field two sheep can be saved. these different planners are extremely valuable because they provide alternatives to ephor. we provide results in section 1 that show with a variety of planners  we can achieve better behavior  more sheep confined  in the shepherding application. we have also implemented a depth n search  where n is the number of sheep   but in practice it never has enough time to run for n   1. 
1 

　1a provide parallel planners that use a  bag of tasks  model 
　as mentioned in the introduction  spartas contain parallel and distributed components that bring a new level of complexity and a new set of issues to designing real-world applications. however  this parallelism also brings new opportunities for adaptation. there are many models of parallel computation  e.g. data parallelism is natural in low-level vision . programming a technique to have a fixed number of tasks on a fixed set of processors is counterproductive since it does not allow for any adapting. instead  a model of parallelism is needed that can easily and quickly change in light of varying and unpredicted environmental stimuli. our experiments show that if the application is programmed with a  bag of tasks  model  the runtime can provide considerably better performance. in a  bag of tasks  model  work is divided up into reasonable size pieces  of the problem  and placed in a central repository. each process removes a piece from the bag  processes it  and possibly updates shared information with the result. examples of this model of parallelism are the uniform system  thomas and crowther  1  or the problem-heap paradigm  cok  1; moller-nielsen and staunstrup  
1 . this paradigm provides tremendous flexibility since the runtime can choose to run any number processes to work on this technique. 
　an example from the shepherding application is a parallel planner we designed. this planner looks at the next n  for our experiment it was four  possible sheep saves in order to determine the best next move. another way to cast the planning problem is to look at all permutations of the sheep in the field and count the number of sheep still confined at the end of the sequence of sheep saves and the amount of time taken to do so. this representation nicely fits the  bag of tasks  model since now we put into the bag a set of all the possible permutations. each  identical  process pulls a permutation out of the bag computes the information above and updates a central location  holding the best permutation seen so far  if it determines it has found the best option so far. we give results from applying the  bag of tasks  model to the shepherding domain in section 1. 
　1 provide parallel planners that: b  use dif-ferent resources c  vary in quantity of resources used. 
　design parallel planners that either use distinct resources or that vary greatly in the quantity of resources consumed. the arguments and benefits are analogous to those we discussed for sequential planners in 1a and 1b. 
　1 supporting results 
in this section we examine the effectiveness of our planner principles. the evaluation is accomplished by using ephor  our runtime environment   and real-time primitives from irix  the operating systems of our 1 processor sgi challenge . first  we briefly explain the application-ephor interface  which is how the application informs ephor of its goals  techniques  and task. then  vision proc goal * ephor create goal ephor periodic  true  ephor priority  1  ephor goal name  ''vision proc''  ephor.rate  1  null ; /* 1 hz */ 
temp tech = ephor create technique vision proc goal  ephor cpu time  1  null ; 
vision proc id ＊ ephor create task vision proc goal  temp.tech  ephor.imp function  vision processor  null ; 
figure 1: application-ephor interface 
we provide results demonstrating improved performance using adaptable planner principles. we concentrate on two specific principles. we show that application behavior improves when multiple techniques accomplishing the same goal are available to the runtime and when a parallel planner it used that can adapt the number of processes. 
　at startup  the application informs ephor of its goals  the different techniques it has for solving those goals  and the specific function s  that implement the techniques. throughout the programs' execution  when it wishes to solve a goal it informs ephor. the application can also specify periodic goals. once ephor knows about the application's goals  techniques  and tasks  it dynamically selects the most appropriate technique when the application informs ephor it wants to solve a goal. 
　as a simple example from the shepherding application  figure 1 shows how the vision processing goal is defined. the first call ephor create goal returns a handle to the vision processing goal. if this goal was not periodic  i.e.  called in response to the environment  then ephor periodic would be false  and the program would call ephor run goal vision proc goal  when it wanted this goal run. 
1 	a suite of techniques 
the first planner principle we evaluate is the usefulness of generating different techniques for accomplishing the same goal. here we will examine the performance of two planners  planner a and b  - a more thorough analysis of these tradeoffs may be found in  wisniewski and brown  1 . both these planners figure out the next sheep to save but differ in how long they take to run and how many sheep are contained  in steady state  when running on an unloaded cpu. to guarantee accurate measurement  no competing load  for this experiment  we dedicate one processor to the planner function. a sheep can travel from the center to the edge of the table in 1 seconds and the shepherd in about 1 of a second. 
　planner a computes a list of all the sheep moving away from the table center that the shepherd has time to reach  sorted by distance from the center. it then determines the best order for saving the next four sheep: this requires future prediction of sheep movements. the best sequence is the one maximizing the number of sheep saved. among the orderings that save equal number of sheep  preference is given to the ordering taking less 

time. the first sheep in the sequence is saved and the planner starts over. planner a performs the best un-
der no load but takes the longer time to run  about one second . planner b is a reactive  no look-ahead strategy  that simply tries to save the sheep farthest from the center. it runs much faster than a  about 1 milliseconds  but does not perform nearly as well under no load: if by letting the farthest sheep go  it is possible to save the next two and otherwise not  a will save the two sheep while b will save only one. 
　to compare the different planners under simulated conditions of parallel activity in other parts of the sheep speed  units/sec  
sparta  a controlled load was placed on the processor that the planner was running on. since we were using figure 1: fixed versus adaptable parallel planners a multiprocessor we could vary the load experienced by the planner process without affecting any of the other the second planner principles we evaluate is the  bag processes in the system. we also had tight control over of tasks   see section 1a  model for parallel planner 
1 

design. as we have mentioned  a key aspect of performing well in the real world is being able to adapt. this adaptability applies both to the runtime and the application. our principle of using a  bag of tasks  model is motivated by the fact that it provides considerable flexibility when considering the amount of processing power to allocate to a planner. 
　in this experiment we again assume a model of varying load as would be observed in a real application. the parallel planner has been written using a  bag of tasks  model. the planner looks four saves into the future. the possible permutations for the next four sheep saves are placed into a central queue where they are removed by as many processes as the runtime has decided to invoke in this particular goal instantiation. this planner is qualitatively different from the planners discussed in section 1 and the environment is quantitatively different  so the results should not be compared. 
　the results appear in figure 1. the load of the application allowed for between 1 and 1 processors to be available to the save-sheep goal at different points throughout its execution. the  fixed  bar represents the application's behavior assuming it could not adapt and adjust to use the extra processors available at various points throughout the execution  i.e.  it always used one processor. this would be required if the planner could not adapt to the number of processors it could use  otherwise it would not have been able to run in times of slightly heavier load. the variable bar represents when ephor was allowed dynamically to allocate more processors for the parallel planner when they were available. we vary the response time expected from the planner by varying the rate the sheep move. notice that when the response demands placed on the application increase  it becomes more important for the planner to have been designed allowing for differing number of processes to be used. this figure illustrates the benefit of using a flexible parallel planner. when the sheep are moving around quickly  the adaptable parallel planner can confine over three times as many sheep as the fixed parallel planner. the important aspect of this discussion is not that parallel planners  versus sequential ones  can improve the performance of applications  rather that in real-world applications we need planners that can dynamically vary the number of processors they use. and equally important  we need a system such as ephor  that can support this desired behavior. 
　this graph represents the interesting part of the state space for the save-sheep planner. if the sheep move very slowly  1 units/sec  then either planner will have enough time to do something reasonable  and similarly if the sheep are moving extremely quickly  greater than 1 units/sec  neither planner will have enough time to do anything. achieving perfect speedup when running on seven processors  versus one  would allow the planner to run seven times as fast. this does not however  translate into a seven-fold improvement in application behavior. in fact there may be some programs that do not benefit or benefit very little from decreased running time. however  many real-world applications will be able to benefit from being able to perform more computation in 
1 	action and perception 
less time. exploiting the parallel dimension of programming a sparta can substantially improve application behavior. 
1 	conclusion 
we described sparta characteristics and set of general design principles for planners and parallel planners in real-world applications. we presented qualitative arguments for some  and for others we presented results indicating significant performance improvement  as much as 1 percent on our system . in all cases we showed the key to good  parallel  planner design in spartas was the ability to adapt  by offering a set of techniques to solve a particular goal. 
　we have found it very productive to work on both the high level application and runtime system simultaneously. their interactions are nontrivial and hard to anticipate. our current and future emphasis is on investigating and expanding the runtime support for sophisticated parallel planners and decision-makers. we are also continuing to develop better measures for how well the implemented support meets the need of the high-level planner. 
