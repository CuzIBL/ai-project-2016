 
　　the representation used in a domain-independent planning program that supports both automatic and interactive generation of hierarchical  partially ordered plans is described. an improved formalism for representing domains and actions is presented. the formalism makes extensive use of constraints  offers efficient methods for representing properties of objects that do not change over time  allows specification of plan rationale  allows specification of resources for efficiently detecting and remedying harmful parallel interactions  and provides the ability to express deductive rules for deducing the effects of actions. 
1. overview 
　　the automation of planning in a computer program involves representing the world  representing actions and their effects on the world  reasoning about the effects of sequences of such actions  reasoning about the interaction of actions that are taking place concurrently  and controlling the search so that plans can be found with reasonable efficiency. planners designed to work efficiently in a single problem domain  though desirable  often depend on the structure of that domain to such an extent that the underlying ideas cannot be readily used in other domains. this paper discusses domain-independent planners that are of particular interest  since they yield planning techniques that are applicable in many domains and provide a general planning capability. such a commonsense planning capability is likely to require different techniques from those used by an expert planning in his particular domain of expertise  but it is nonetheless essential for people in their daily lives and for intelligent programs. of course  a general planner should provide representations and methods for including domain specific knowledge and heuristics. this paper describes an implemented planning program that expands the core of domain-independent planning techniques as it builds on and extends such previous domain-independent planning systems as sacerdoti's noah   tate's nonlin   sridharan's planxio   vere's deviser   and sri's strips . 
*the research reported here is supported by air force office of scientific research contract f1o-1-c-1. 
　　we have designed and implemented  in interlisp  a system  sipe  system for interactive planning and execution monitoring   that supports domain-independent planning. the program has produced correct parallel plans for problems in four different domains  the blocks world  cooking  aircraft operations  and a simple robotics assembly task . the system allows for hierarchical planning and parallel actions. development of the basic planning system has led to several extensions of previous systems. these include the development of a perspicuous 
formalism for encoding descriptions of actions  the use of constraints to partially describe objects  the creation of mechanisms that permit concurrent exploration of alternative plans  the incorporation of heuristics for reasoning about resources  mechanisms that make it possible to perform simple deductions  and advanced abilities to reason about the interaction among parallel actions. sipe can automatically generate plans  but  unlike its predecessors  sipe is designed to also allow interaction with human users throughout the planning and plan execution processes  if this is desired. the user is able to watch and  when he wishes  guide and/or control the planning process. 
　　in sipe  a plan is a set of partially ordered goals and actions  which is composed by the system from operators  the system's description of actions that it may perform . by simply applying operators  plans that do not achieve the desired goal may sometimes be generated  so the system has critics that find potential problems and attempt to avert them. in particular  most of the reasoning about interactions between parallel actions is done by the critics. the plans are represented in procedural nets   primarily for graceful interaction between man and machine. invariant properties of objects in the domain are represented in a tree-structured sort hierarchy  which allows inheritance of properties and the posting of constraints on the values of attributes of these objects. the relationships that change over time - and therefore all goals - are represented in a version of first-order predicate calculus that is typed and interacts with the knowledge in the sort hierarchy. operators are represented in an easily understood formalism  developed by us  

in which the ability to post constraints on variables is a primary feature. each of these parts of the system will be described in more detail later. 
　　it should be noted here that  like most domain-independent planning systems  deviser being an exception   ours assumes discrete time  discrete states  and discrete operators. these assumptions are acceptable in many real-world domains  even though they are restrictive and prevent many real-world phenomena from being adequately represented. for example  sophisticated reasoning about time and modelling of dynamic processes are not possible within our present framework. few artificial intelligence programs have addressed these problems  mcdermott's recent work being a notable exception  . 
　　the planning-representation problem involves representing the domain  goals  and operators. operators are the system's representation of actions that may be performed in the domain or  in the hierarchical case  abstractions of actions that can be performed in the domain. an operator includes a description of how each action changes the state of the world. in a logical formalism such as rosensebein's adaptation of dynamic logic to planning   the same representational formalism may be used for representing the domain  goals  and operators; however  in many planners more concerned with efficiency  including sipe  there is a different representation for each. the goal is to have a rich enough representation so that many interesting domains ran be represented  an advantage of logical formalisms   but this must be measured against the ability of the system to deal with its representations efficiently during the planning process. 
　　this paper describes sipe's solution to the problem of representing the domain  goals  and operators.  other aspects of the system are described in .  a central concern in designing a representation for a planning system is how to represent the effects an action has on the state of the world. this means that the frame problem  l  must be solved in an efficient manner. since we intend that many domains will be encoded in the planning system  it is also necessary that the solution to the frame problem not be too cumbersome. for example  one does not want to have to write a large number of frame axioms for 
each new action that is defined. 
1. representation of domain and goals 
　　the system provides for representation of domain objects and their invariant properties by nodes linked in a hierarchy. this permits sipe to incorporate the advantages of frame-based systems  primarily efficiency   while retaining the power of the predicate calculus for representing properties that do vary. invariant properties do not change as actions planned by the system are performed  e.g.  the size of a frying pan does not change when you cook something in it . each node can have attributes associated with it  and can inherit properties from other nodes in the hierarchy. the values of attributes may be numbers  pointers to other nodes  key words the system recognizes  or any arbitrary string  which can only be used by checking if it is equal to another such string . the attributes are an integral part of the system  since planning variables arc also nodes in the hierarchy and contain constraints on the values of attributes of possible instantiations. constraints are an important part of the system and are discussed in considerable detail later. there are different node types for representing variables  objects  and classes  but these will not be discussed in detail here  since they are similar to those occurring in many representation formalisms - for example  semantic networks and units. 
　　a restricted form of first-order predicate calculus is used to represent properties of domain objects and the relationships among them that may change with the performance of actions; it is also therefore used to describe goals as well as the preconditions and effects of operators. quantifiers are allowed whenever they can be handled efficiently. universal quantifiers are always permitted in effects  and over negated predicates in preconditions. existential quantifiers can occur in the preconditions of operators  but not in the effects. disjunction is not allowed. these restrictions result from using  add lists'' to solve the frame problem.  why this is so is described in the next section . by representing the invariant properties of the domain separately  sipe reduces the number of formulas in the system and makes deductions more efficient. there is currently no provision for creating or destroying objects as actions are executed  although in some domains this would be useful  e.g.  after an omelet has been made  do the original three eggs still exist as objects  . 
1. representation of operators 
　　operators representing actions the system may perform contain information about the objects that participate in the actions  represented as resources and arguments of the actions   what the actions are attempting to achieve  their goals   the effects of the actions when they are performed  and the conditions necessary before the actions can be performed  their preconditions . before sipe's representation is described in 
detail  some basic assumptions made by sipe about the effects of actions need to be presented. 
　　determining the state of the world after actions have been performed  e.g.  the planner must ascertain whether the intended goals have been achieved   involves solving the frame problem. here we make what waldinger  has called the strips assumption  which is that all relations mentioned in the world model remain unchanged unless an action in the plan specifies that some relation has changed. in strips  an action specifies that a relation has changed by mentioning it on an  addlist  or  deletelist . alternatively  relations that change might be deduced from general frame axioms as long as the 
deduction is tightly controlled. 
　　muking this assumption imposes requirements on the formalism used for representing the domain  since it must support the strips assumption. while the strips assumption may be very limiting in the representation of rich domains  such as automatic programming  there are many domains of interest for which it causes no problems. for example  the fairly simple environments in which robot arms often operate appear adequately represent able in a system embodying the strips assumption. si pic currently makes the closed-world assumption: any negated predicate is true unless the unnegated form of the predicate is explicitly given in the model or in the effects of an action that has been performed. this is not critical; the system could be changed to assume that a predicate's truth-value is unknown unless an explicit mention of the predicate is found in either negated or unnegated form.  although in large domains  there may be an enormous number of predicates that are not true.  deduction in sipe does not violate the closed-world assumption; it is used only to deduce effects of an action when the action is added to a plan  thus sparing the operator that represents the action from having to specify these effects . 
　　many features combine to make sipe's operator description language an improvement over operator descriptions in previous systems. these features will be presented by discussing the sample operator given in figure 1  with subsections devoted to the more important features. the sipe system has produced correct parallel plans for problems in four different domains  one of which is the blocks world  described in   for which many domain-independent planning systems  e.g.  nonlin and noah  have presented solutions. to facilitate comparison with these systems  a puton operator for the blocks world in the sipe formalism is shown in figure 1. 
　　the operator's effects  preconditions  and purpose are all encoded as first-order predicates on variables and objects in the domain.  in this case  block1 and objectl are variables.  negated predicates that occur in the effects of an operator essentially remove from the model a fact that was true before  but operator: puton 
arguments: block 1  objectl is not block1; purpose:  on block1 objectl ; plot: 
parallel branch 1: 
goals:  cleartop objectl ; 
　　arguments: objectl; branch 1: 
goals:  cleartop block 1 ; 
　　　　arguments: blockl; end parallel 
process 
action: puton.primitive; 
arguments: objectl; 
resources: blockl; 
effects:  on blockl objectl ; 
end 
figure 1 
a puton operator in sipe 
is no longer true. 
　　operators contain a plot that specifies how the action is to be performed in terms of actions and goals at either the current level or some lower level of the hierarchy. like plans  plots are represented as procedural networks. when used by the planning system  the plot can be viewed as instructions for expanding a node in the procedural network to the next level. the plot of an operator can be described either in terms of goals to be achieved  i.e.  a predicate to make true   or in terms of processes to be invoked  i.e.  an action to be performed .  noah represented a process as a goal with only a single choice of action.  encoding a step as a process implies that only the action it defines can be taken at that point  while encoding a step as a goal implies that any action can be taken that will achieve the goal. another less explicit difference between encoding a step as a goal or as a process is whether the emphasis is on the situation to be achieved or the actual action being performed. 
　　during planning  an operator is used to expand an already existing goal or process node in the procedural network to produce additional procedural network structure at the next level. for example  the puton operator might be applied to a goal node in a plan whose goal predicate is  on a b . operators may specify preconditions that must obtain in the world state before the operator can be applied.  the operator in figure 1 has no precondition.  operators contain lists of resources and arguments to be matched with the resources and arguments of the node being expanded. in our example  a and b in the goal node are matched with blockl and objectl in the puton operator when the operator is used to expand the node. the plot of the operator is used as a template for generating two coal nodes and one process node in the plan. 
　　operators in sipe provide for posting of constraints on variables  specification of resources  and the use of deduction to determine the effects of actions. each feature is described below in some detail. sipe also provides the ability to explicitly represent the rationale behind each action  this is mentioned briefly below   and to apply the plots of operators iteratively to 
sets  this is not discussed in this paper . 
1 sife's constraint language 
　　sipe's ability to construct partial descriptions of unspecified objects is one of its most important advances over previous domain-independent planning systems. this ability is important both for domain represention  e.g.  objects with varying degrees of abstractness can be represented in the same formalism  and for finding solutions efficiently  since decisions can be delayed until partial descriptions provide more information . almost no previous domain-independent planning systems have used this approach  e.g.  noah cannot partially describe objects  so the constraints in sipe will be documented in some detail. 
　　planning variables that do not yet have an instantiation ran be partially described by setting constraints on the possible values an instantiation might take. this allows instantiation of the variable to be delayed until it is forced or until as much information as possible has been accumulated  thus preventing incorrect choices from being made. constraints may place restrictions on the properties of an object  e.g.  requiring certain attribute values for it in the sort hierarchy   and also require that certain relationships exist between an object and other ob-
jects  e.g.  predicates that must be satisfied in a certain world state . sipe provides a general language for expressing these constraints on variable bindings so they can be encoded as part of t the operator. during planning  the system also generates constraints that are basted on interactions within a plan  propagates them to variables in related parts of the network  and finds variable bindings that satisfy all constraints. 
　　the allowable constraints in sipe on a variable v are listed below: 
　  class. this constrains v to be in a specific class in the sort hierarchy. in sipe's operator description language there is implicit typing based on the variable name; therefore  in the puton operator in figure 1  the variable created for block1 has a class constraint that requires the instantiation for the variable to be a member of the class blocks. similarly  the 
object1 variable has a class constraint for class objects. 
　  not-class. v must be instantiated so that it is not a member of a given class. 
　  pr ed. v must be instantiated so that a given predicate  in which v is an argument of the predicate   is true. this results in an explicit number of choices for v's instantiation  since all true facts are known  by the closed-world assumption . 
　  not-pred. v must be instantiated so that a given predi-cate  in which v is an argument of the predicate   is not true. 
　  same. y must be instantiated to the same object to which some other given variable is instantiated. 
　  not-same. y must not be instantiated to the same ob-ject to which some other given variable is instantiated. in the puton operator in figure 1  the phrase  is not block 1  results in a not-same constraint being posted on both block 1 and ob.jectl that requires they not be instantiated to the same thing. thus  if sipe is looking for a place to put block a  it will not choose a as the place to put it. 
　  ins tan. v must be instantiated to a given object. this could be represented by using same applied to objects as well as variables  or using pred with an eq predicate   but instantiation is a basic function of the system and warrants its own constraint for a slight gain in efficiency. 
　  not-in stan. v must not be instantiated to a given ob-ject. 
　  optionai -same. this is similar to same  but merely specifics a preference and is not binding. for example  one would prefer to conserve resources by making two variables be the same object  but  if this is not possible  then different objects are acceptable. 
　  optional-not-same. this is similar to not-same  but is not binding. if sipe notices that a conflict will occur between two parallel actions if two variables are instantiated to the same object  then it will post an optional-not-same constraint on both variables. if it is possible to instantiate them differently  a conflict is avoided. if it is not  they may be made the same but the system will have to resolve the ensuing conflict  perhaps by not doing things in parallel . 
　  any attribute name. this requires a specific value for a specific attribute of an object. for example  the puton operator could have specified  block 1 with color red . this would create a constraint on block 1 requiring the color attribute  in the sort hierarchy  of any possible instantiation to have the value red. for attributes with numerical values  
 greater than  and  less than  can also be used. in planning an airline schedule  for example  the operator used for crosscountry flights might contain the following variable declaration: 
 planel with range greater than 1'' 
　　constraints add considerably to the complexity of the planner because they interact with all parts of the system. for example  to determine if a goal predicate is true  sipe must verify whether it matches predicates that arc effects earlier in the plan. this may require matching variables that are arguments to the two predicates  which in turn involves determining whether the constraints on the two variables are compatible. in a similar way  constraints also interact with the deductive capability of the system  to be described later . constraints also affect critics  since determining if two concurrent actions interart may depend on whether their constraints are compatible. sipe must also solve a general constraint satisfaction problem with reasonable efficiency  though how to control the amount of processing spent on constraint satisfaction is an open and important question. sipe's method of propagating and checking constraints is described in more detail in . 
　　the use of constraints is a major advance over previous domain-independent  planning systems. noah  for example  would have to represent every property of an object as a predi-
cate and then  to get variables properly instantiated  would have each such predicate as either a precondition of an operator or a goal in the plan. in sipe an operator might declare a variable as  cargoplanel with range 1  and the plan using this variable can assume it has the proper type of aircraft. in noah  goals similar to  cargoplane x  and  range x 1  would have to be included in the operator and achieved as part of the plan. this makes both the operators and plans much longer and harder to use and understand. in addition to syntactic sugar  constraints in sipe improve efficiency and expressibility. the optional-same and optional-not-same constraints used in resource reasoning cannot be expressed as goals or preconditions in a system like noah. the constraint satisfaction algorithm used in sipe takes advantage of the fact that invariant properties of objects are stored directly in the sort hierarchy. the lookup of such properties in sipe is much more efficient than the process of looking through the plan to determine which predicates are currently true  as would have to be done in systems like noah and nonlin. 
　　some domain-dependent systems make use of constraints. stefik's system   one of the few existing planning systems with the ability to construct partial descriptions of an object without identifying the object  operates in the domain of molecular genetics. our system extends stefik's approach in three ways.  1  we provide an explicit  general set of constraints that can be used in many domains. stefik does not present a list of allowable constraints in his system; moreover  some of them that are mentioned seem specifically related to the genetics domain.  1  constraints on variables can be evaluated before the variables are fully instantiated. for example  a set can be created that is constrainable to be only bolts  then to be longer than one inch and shorter than two inches  then to have hex heads. this set can be used in planning before its members are identified in the domain.  1  partial descriptions can vary with the context  thus permitting simultaneous consideration of alternative plans involving the same unidentified objects  see  . 
1 resources 
　　parallelism is considered beneficial since optimal plans in many domains require it.  two segments of a plan are in parallel if the partial ordering of the plan does not specify that one segment must be done before the other.  the approach used in sipe  therefore  is to keep as much parallelism as possible and then to detect and respond to interactions between parallel branches of a plan. sipe provides the ability to reason about resources  which is a powerful mechanism both for detecting 
parallel interactions and remedying them. 
　　the formalism for representing operators in sipe includes a means of specifying that some of the variables associated with an action or goal will actually serve as resources for that action or goal  e.g.  block 1 is declared as a resource in the puton.primitive action of the puton operator in figure 
1 . resources are to be employed during a particular action and then released  just as a frying pan is used while vegetables are being sauteed in it. reasoning about resources is a common phenomenon. it is a useful way of representing many domains  a natural way for humans to think about problems  and  consequently  an important aid to interaction with the system. 
　　sipe has specialized knowledge for handling resources; declaration of a resource associated with an action is a way of saying that one precondition of the action is that the resource be available. mechanisms in the planning system  as they allocate and deallocate resources  automatically check for resource conflicts and ensure that these availability preconditions will be satisfied. 
　　resources enable sipe's operators and plans to be more succinct and easier to understand than similar operators and plans in domain-independent parallel planning systems  such as noah and nonlin. in the latter systems  resource availability would hav  to be correctly axiomatized  checked  and updated in the preconditions and effects of the operators. it is not clear that it would be possible to do this so that the critics would recognize only the intended conflicts. if it were indeed possible  the resource reasoning in s1pe would be much more efficient than such an axiomatization in the other systems. for example  in noah  he resolve-conflicts c/itic would eventually have to notice that posted  available-resource  effects are in conflict. this could be done only after the entire plan had been expanded and the critics applied. even then  conflicts between uninstantiated variables might not be detected  since only in an attempt to instantiate them would an actual conflict arise. in sipe it is known which resources an operator needs before it is applied  so conflicts can be detected even before the plan is expanded. this can result in choosing operators that do not produce conflicts  thereby pruning the search space. sipe avoids not only the immediate incorrect operator expansion  but also both the entire expansion to the next level and the application of the critics after that. the savings can be considerable in domains that use resources heavily. sipe can also detect conflicts between uninstantiated variables; if a plan requires two arms as resources and only one arm exists in the world  sipe can detect this 
conflict even though the two arm variables have not been instantiated. 
　　this section only summarizes the resource reasoning abilities provided by slpe's representation. details of how resources are actually implemented are given in  ll  and . these papers include examples of problems solved with and without reasoning about resources  as well as a general description of the parallel interaction problem and sipe's solution to it. 
1 plan rationale 
　　sipe provides more flexibility in specifying the rationale behind a plan than many domain-independent planners.  the rationale for an action in a plan is  why  the action is in the plan.  this is needed for determining how long a condition must be maintained  what changes in the world cause problems in the plau  and what the relationship is among different levels in the hierarchy. sipe constructs links  both between the levels of a plan and within a level  that help express the rationale behind t he actions. the system has reasonable defaults for constructing these links  but also provides the flexibility for operators to specify how these links should be constructed  thus permitting a larger class of phenomena to be represented . this is described in more detail in . 
1 deductive operators 
　　in addition to operators describing actions  sipe allows specification of deductive operators that deduce facts from the current world state. this provides a deductive capability that is useful  but nevertheless keeps deduction under control by severely restricting the deductions that can be made. as more complex domains are represented  it becomes increasingly important to deduce the effects of actions from axioms about the world  rather than explicitly representing these effects in operators. for example  the puton operator in figure 1 lists only  on block 1 objectl  as an effect. it does not mention which objects are or are not now cleartop  since that is deduced by deductive operators. because deductive operators in sipe may include both existential and universal quantifiers  they provide a rich formalism for deducing  possibly conditional  effects of an action. effects that are deduced in sipe are considered to be side effects.  operators can also specify effects as either main effects or side effects.  knowing which effects are merely side effects is important in handling parallel interactions. 
　　figure 1 shows one of the deductive operators in the sipe blocks world for deducing cleartop relationships. deductive operators are written in the same formalism as other operators in sipe  thus permitting the system to control deduction with the same mechanisms it uses to control the application of operators. this also allows constraints to be used and  as this example shows  they play a major role in sipe's deductive capability. 
　　all deductions that can be made are performed at the time an operator is expanded. the deduced effects are recorded in the procedural net  and the system can proceed just as if all the effects had been listed in the operator. deductions are not attempted at other points in the planning process. deductive operators have triggers for controlling their application. the dclear operator in figure 1 is applied when objectl is placed on object1. deductive operators have no instructions for expanding a node to a greater level of detail. instead  if the precondition of a deductive operator holds  its effects can be added to the world model  in the same context in which the precondition matched  without changing the existing plan. this may  achieve  some goal in the plan  by deducing that it has already been achieved   thereby making it unnecessary to plan actions to achieve it. in figure 1  matching the precondition will bind block1 to the block that objectl was on before it moved to object1. since object1 is constrained to be in the existential class  see below  and is constrained to not be objectl  the precondition will match  and cleartop of block1 deduced  only if objectl is the only object on block1  just before moving objectl to object1 . 
　　the method used for specifying variables as existentially quantified  i.e.  constraining them to be in the existential class  does not provide scoping information. since only certain types of quantifiers are permitted for efficiency reasons  sipe indeduct1ve.operator: dclear 
arguments: objectl  1bject1  
block1 is not object1  
objectl class existential is not objectl; 
trigger:  on objectl object1 ; 
precondition:  on objectl block1   
 nut  on object1 block1  ; 
effects:  clear block1 ; 
         figure 1 a deductive operator in sipe 
terprets preconditions according to defaults that are somewhat non-standard. the scope of each existential variable appearing as an argument in a predicate is local to that predicate. each predicate effectively gets a different existential variable. 
in addition  negated predicates are interpreted as having the quantifier within the scope of the negation. thus  the variable is effectively universally quantified for negated predicates. as an example  with x declared existential  the precondition p 1 a-q x  is interpreted as 1 x.p x  a -1 x.q x   or equivalently  1.p{x  a vz. -  q x   . these restrictions make use of sipe's representation  e.g.  the fact that negated predicates are treated differently  to permit handling quantifiers efficiently. 
　　besides simplifying operators  deductive operators are important in many domains for their ability to represent conditional effects. in noah's blocks world  only one block may be on top of another; consequently  whenever a block is moved  the operator for the move action can be written to state explicitly the effect that the block underneath will be clear. in the more general case in which one large block might have many smaller blocks on top of it  there may or may not be another block on the block underneath  so the effects of the action must be conditional upon this. since systems like noah and nonlin must mention effects explicitly  universally or existentially quantified variables are not allowed in the description of effects   they cannot represent this more general case with a single move operator. these systems would need two move operators - one for the one-block-on-top case  another for the many-blocks-on-top case. furthermore  the preconditions for separation of the cases would add an undesirable complication to the representation of the operators. 
　　as the above example shows  sipe's deductive operators allow certain quantifiers and are powerful enough to handle this case. since sipe can deduce all the clearing and unclearing effects that occur in the blocks world  the operators themselves do not need to represent them. as domains grow to include many operators  this becomes very convenient. deductive operators provide a way to distinguish side effects  which can be important. by using deduction  more complicated blocks worlds can be represented more elegantly in sipe than in previous domain-independent planners. 
1. performance of sipe 
　　sipe has been tested in four different domains: the blocks world  cooking  aircraft operations  and a simple robotics assembly task. these domains do not have large branching factors or search spaces so that the automatic search can find solutions. the cooking domain was encoded to demonstrate resource reasoning. sipe operators naturally represented requirements for frying pans and burners during the cooking of a dish. problems such as cooking four dishes with three pans on two burners were handled efficiently by the resource reasoning mechanisms in sipe. handling a problem means producing plans for cooking as many dishes as possible in parallel  with 
enough serialization to get the task accomplished with the available resources. such plans consisted of dozens of nodes in our 
simple cooking world. 
　　the standard blocks world was encoded in sipe  with some enrichments  e.g.  more than one block could be on top of another . use of deductive operators made the puton operator more readable. resource reasoning enabled sipe to quickly find and correct parallel interaction problems. a number of other problems involving properties of the blocks and quantifiers were also handled elegantly  making use of the constraints in sipe . for 
example  the problem of getting some red block on top of some blue block is easily represented and solved.  sipe will choose a red block and a blue block that are already clear  if such exist.  
1. conclusion 
　　sipe's operator description language was designed to be perspicuous  to enable graceful interaction  while being more powerful than those found in previous domain-independent planners. constraints  resources  and deductive operators all contribute to the power of the representation. deductive operators allow quantified variables and can therefore be used to make fairly sophisticated deductions  thus eliminating the need to express effects in operators when they can be deduced. they are also useful in distinguishing main effects from side effects. 
　　one of the most important features of sipe is its ability to constrain the possible values of variables. it is well known that this enables more efficient planning  since choices can be delayed until information has been accumulated. other advantages of constraints  however  are also critical. a key consideration is that constraints allow convenient expression of a much wider range of problems. constraint satisfaction finds variable in-

1 d. wllkins 
stand ations efficiently by taking advantage of the fact that invariant properties of objects are encoded in the sort hierarchy. constraints also help prevent harmful parallel interactions. 
　　sipe provides the ability to reason about resources which is important both for representation of domains and the handling 
of parallel interactions. combined with the system's ability to post constraints  resource reasoning helps the system avoid many harmful interactions  helps it recognize sooner those interactions that do occur  and helps the system solve some of these interactions more quickly. sipe's handling of interactions is also improved by its ability to differentiate side effects and to correctly determine the rationale behind actions. 
acknowledgments 
many people influenced the ideas expressed in this paper. 
special thanks go to ann robinson who helped design and implement sipe  and to nils nilsson  mike georgeff  and stan roscnschein for many enlightening discussions. 
