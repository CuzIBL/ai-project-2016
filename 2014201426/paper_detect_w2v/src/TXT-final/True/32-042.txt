 
plan libraries are the most important knowledge source of many plan recognition systems. the plan decompositions they contain provide information about how a plan has to be executed to actually achieve its associated goals and be recognized by the system. this paper presents an approach to the automatic acquisition of plan decompositions from sample action sequences. in particular a clustering algorithm is introduced that allows groups of  similar  sequences to be discovered and used for the generation of plan libraries. empirical tests indicate that these libraries can indeed be successfully used for plan recognition purposes. 
1 	introduction 
plan libraries are the most important knowledge source of many plan recognition systems. they not only contain all possible types of plans  or goals  to be recognized by such a system-thus delimiting the search space of possible plan hypotheses-  but also represent the details of how these plans have to be executed to actually achieve their associated goals. these  recipes -the so-called plan decompositions-are necessary to map observed actions onto the plan hypotheses available which is one of the central steps within the plan recognition process. 
　although they are being widely used  the question of how to actually construct plan libraries that support the recognition process in an optimal way has only recently been investigated more thoroughly  e.g.  lesh and etzioni  1  . in  bauer  1  a method was introduced that allows abstract plan decompositions to be generated from action sequences logged while observing test subjects interacting with an application system. what makes this approach attractive is the fact that it does not rely on the existence of formalized domain knowledge  although it can use possibly available information to improve its results. 
   * supported by the german ministry of education  science  research  and technology under grant itw 1. 
ss1 	planning and scheduling 
　this join procedure can be considered an instance of a supervised learning algorithm  that is  it requires its training instances to be labeled with their respective class memberships  the domain goals associated to the various action sequences in this case . often  however  only unlabeled interaction data are available that are very tedious to classify by hand as they contain a huge number of irrelevant details like spurious actions. this paper extends the approach from  bauer  1  for the acquisition of plan libraries by a clustering algorithm that determines sets of similar action sequences in unlabeled training data that can be forwarded to the join algorithm to compute plans to be used in the library. analyzing these library entries and labeling them with the domain goals they seem to achieve-such that they can actually be used for plan recognition purposes-is then relatively easy as the small number of plans generated represents the essential aspects of the original action sequences only. furthermore the resulting libraries can be expected to support the plan recognition process particularly well as they contain abstractions of actual users' behaviors rather than idealized plans designed by a knowledge engineer. 
　the rest of this paper is organized as follows. section 1 reviews the basic notions introduced in  bauer  1 . sections 1 and 1 introduce the new clustering algorithm and present empirical findings  respectively. finally  section 1 discusses related work before section 1 summarizes the results. 
1 	joining action sequences 
a plan decomposition-or simply  a plan-is a tuple 
 p  ap cp  where p is a unique identifier  ap is a set of actions-either concrete or abstract-  and cp is a set of constraints representing additional details about the internal structure like temporal ordering of the elements of ap. to optimally support plan recognition  a plan decomposition should not be too restrictive by containing irrelevant constraints that unnecessarily restrict the number of recognizable user interactions. on the other hand  being too  fuzzy  by leaving out too many details implies the danger of not being able to discriminate between competing hypotheses. a good compromise is to concentrate on those aspects of a plan-i.e. actions 

and constraints describing its internal structure-that axe absolutely necessary to achieve the associated domain goal. obviously a component of a plan is necessary 
just in case it occurs in all action sequences that form a valid instance of this plan. as it is hardly ever possible to enumerate all possible ways to actually carry out a plan  this notion of necessity has to be approximated by collecting a limited number of action sequences and determining what they have in common. these training data are obtained by fixing a set of domain goals to be covered by the plan library and observing a number of test subjects trying to achieve these goals. the action sequences executed are recorded  grouped according to common domain goals  and forwarded to the  join  algorithm as described in  bauer  1 . that is  in contrast to the situation considered in section 1  there exists a unique labeling of the input data with their associated domain goals. 
　let be the set of action sequences belonging to some goal each of these sequences consists of a set of temporally ordered actions  where 
here 	is the action type this in-
stance belongs to  like is or cp in a unix context   and the various  are constants representing the domain objects being manipulated  the action parameters . 
　besides these action sequences the join procedure can make use of various types of domain knowledge without depending on their actual availability. as will become clear  a logical theory d containing general domain knowledge can be used to infer structural relationships among the elements of an action sequence. furthermore  an action type hierarchy  and an object type hierarchy  representing abstraction relations among action and object types  respectively  will play a central role in the abstraction step of the join procedure. given a set x of concepts from either or the operation msa computes the most specific non-trivial abstraction of all members of x within the corresponding abstraction hierarchy. note that the result is undefined if the root concept is the only one subsuming all of x  in this case the elements of x can be considered to have nothing in common . for a precise definition of msa the reader is referred to  bauer  1 . 
　in a first step  these action sequences are transformed into labeled graphs making the interrelationships among the constituents of explicit. while the action instances contained in form the nodes  there are two 
types of edges. an edge 	represents the tem-
poral order between both actions  in this case occurs before while an edge 
represents the fact that relation p holds between the action arguments then has the form 
temporal edges 
structural edges 	  if 
d =  i.e. if virtually nothing is known about the do-

figure 1: two sample action graphs. 
main  only the equality of two objects can be recognized and made explicit within  
given two action sequences in the form of action their 
then and 
　that is  the abstract representation of the common information contained in two action instances and is a new action instance the type of which is the msa of both action types-if defined-and the arguments of which are either a concrete domain object represented by a constant oi  if both actions had the same object as a parameter in the same place  or a newly introduced variable the type of which is determined from the types of the originally occurring domain action arguments. if and can only be joined if  
　a temporal or structural edge is considered to be common to both  iff the corresponding action 
nodes to which the edge is incident could be joined using the above criterion. that is  
if 
otherwise. the join of two structural edges with identical labels is defined analogously. 
　summarizing  the join of two action sequences represented as action graphs =  a  tus  where . = 
	t 	= 
	1 	= 
in many cases the above result 
resent a plan decomposition with the desired properties as some actions may be used several times to create a new action node. a maximum subgraph of  in which each action of  is joined at most once with another action is called a valid join. the set of all valid joins can be ordered using the measure 

	bauer 	1 


　　　figure 1: the valid joins of called the degree of restrictiveness. is the set of primitive actions contained in a  i.e. those that do not abstract another domain action in the abstraction hierarchy pa and a are obviously identical. 
the non-negative numerical weights assess the relative influence of the various components of a plan decomposition. as the most restrictive valid join  i.e. the one containing the maximum amount of details regarding plan execution  and thus maximizing  is the one to be used in the experiments described in section 1  it will be identified with  throughout the rest of this papa:. obviously  the resulting action graph can be easily retransformed into a plan decomposition tuple of the form  
example: 	consider the action graphs  
from the cooking domain as depicted in figure 1. for sake of simplicity  only structural and direct temporal edges connecting subsequent actions are shown. that is  temporal edges like the one between and are left out. action arguments like  spagjt refer to particular domain objects.  contains information about the abstract actions make-pasta  subsuming make .spaghetti and make jettucini  and make jsauce  subsuming make-pesto and mak marinara . the action graphs  as depicted in figure 1 represent the two valid joins contained in  both are partially ordered plans  i.e. the temporal order among the actions is only partially defined  made up of one concrete and two abstract actions each. they mainly differ in the inclusion of either al b1 or al b1  including both of them simultaneously would violate the abovementioned  valid join  condition . the number of temporal and structural edges is an immediate consequence of this choice  cf. the rule on how to join edges . using the numerical weights and = 1-a combination that proved to yield reasonable results in experiments-  the degree of restrictiveness of becomes 1 while the value for is 1. as a consequence the latter would be the representative for  
1 	the clustering algorithm 
the approach to the acquisition of abstract plan descriptions presented in the previous section relies on the training data being labeled with their respective classes  i.e. their associated domain goals. often  however  all we can get is an unlabeled collection of interaction data. in such a situation it is necessary to first identify groups of  similar  action sequences that can be forwarded to the 
1 	planning and scheduling 
join algorithm. the members of such a group are expected to also achieve similar domain goals. the resulting abstract plans-that are reduced to their essential components-can then be classified by a domain expert  thus providing the basis for plan recognition. this section introduces a clustering method based on a frequent set analysis of the action types occurring in the training data. 
　assume a set of action sequences s= are given. the crucial idea is to identify sets of action types that co-occur frequently and join only those action sequences containing all of them. the approach taken here is similar to the cluster mining algorithm introduced in  perkowitz and etzioni  1  that is used to detect groups of web sites that are frequently visited in the same session. the algorithm works as follows. 
1. let a =  be the set of all action types occurring in s. construct a complete graph  i.e. each pair of nodes is connected by an edge  with nodes 
and label each edge connecting two nodes 	and 	with 
the numerical value which represents the minimum co-occurrence probability of ai and a  in the sequences currently in s. 
1. determine all maximum size cliques within this graph containing only edges the label of which is  the effect of the parameter  the  clustering factor   will be discussed below. 
1. for each clique c-which represents a set of action types all of which co-occur frequently in the training data-determine the set s c  of action sequences containing each of its members. 
1. compute the join of each maximum size cluster s c -it will be used as one library entry-  remove the members of s c  from s  and repeat this procedure 
starting from step 1 until 
the higher the value of cf  the smaller the size of the cliques of action types co-occurring with probability cf becomes. consequently the size of clusters of action sequences containing these cliques grows  the smaller a set of action types  the higher the probability to find an action sequence containing it   and the number of clusters-and thus  plans in the library-decreases. simultaneously  the plans become less complex  i.e. the degr values go down as each plan represents the aspects common to a larger set of action sequences. a small value for cf has the opposite effect of producing many clusters each of which consists of few action sequences only and yields a plan with high  value. example: assume the training set contains the following action sequences  for sake of simplicity  only the action types contained are listed and both action parameters and constraints are omitted ; = 
with the 
value cf = 1 the trivial clique {ai} is identified that 
　　1 a clique is a complete subgraph of a graph  i.e. every two nodes must be connected by an edge in a clique. while this problem is known to be np-complete  the removal of ail edges with label cf usually reduces the graph to a tractable size. 

leads to the cluster for cf = 1  the algorithm successively detects the cliques and with associated clusters and  
the results of joining the members of these clusters are 

these results correspond to what could be expected after the above discussion. 
1 	experiments 
a total of 1 action sequences from the unix domain containing up to 1 steps and belonging to 1 different domain goals formed the basis of the experiments reported about in this section. typical goals were the search for files with certain properties or status checks for printers. for unbiased results  no additional domain knowledge was used  i.e.  the objective of the experiments was to determine the impact of varying clustering factors on the clusters of action sequences computed and the feasibility of plan libraries created from them for plan recognition purposes. to this end the following experiments were performed using a 1-fold cross validation strategy1 with the value of the clustering factor ranging from 1 to 1 in steps of 1. 1. compute a clustering of the training data as described in section 1. 
1. for each resulting cluster compute the join of all its elements as described in section 1. 
1. tvy to recognize the test action sequences using the plan library containing all plans created in step 1. 
remarks: 1. the plan computed in the second step is labeled to belong to the prevailing class among the action sequences contained in the cluster. in case of a tie-i.e. two or more classes occur with the same  highest  frequency-a corresponding number of copies of this plan is included in the plan library  each marked with one of these classes.1 labeling the plan library entries- usually the task of a domain expert-is an important prerequisite for the plan recognition process. the plan recognizer's task consists in identifying all plans within the library that are completely instantiated by the current action sequence-i.e. the sequence contains all of the plan's actions and satisfies all of its constraints-and assigning their respective classes  as plan hypotheses  to this sequence. 
1. note that a plan library does not necessarily contain just one plan for each class  goal . 
1. to produce unbiased results in the third step  a purely consistency-based  incremental plan recognizer was used that applied no focusing heuristic to discard unwanted plan hypotheses. instead  consistency of observed ac-
   1 that is  the set of action sequences was randomly partitioned into 1 subsets of about equal size. in each of the 1 repetitions of the experiments  1 of these subsets were used as training data whereas the respective remaining subset formed the set of test data. 
   1  of course the class memberships of the training data were not used during the clustering process. 
tions with the plan decompositions was the only criterion to decide whether or not to maintain a hypothesis. 
　as a comparison  alternative clusterings ware computed using cobweb  fisher  1 . cobweb incrementally constructs a hierarchy of clusters containing  similar  instances. finally each node of the tree represents a concept  i.e. an intensional description of the class of instances subsumed in terms of the attribute values occurring within this class. while the leaves of this hierarchy contain the various instances  the root represents the most general class containing all instances encountered during the learning process. as cobweb expects its input to be described in terms of attribute values  each action sequence was encoded as a vector of 1 boolean values  each indicating the  non-  occurrence of one particular command within the sequence. to enable a fair comparison with the clustering procedure described in section 1  a particular class of concepts was selected from the cobweb hierarchies the subsumed instances of which form a partition of the training set while containing a  reasonable  number of elements. 
remark: the leaf concepts would have been inappropriate as they only contain one instance each  while very abstract concepts  i.e. those being close to the root of the hierarchy  increase the danger of producing  bad  clusters containing instances from many different classes. 
　a class c  represented as a node in the tree  is said to be  appropriate  iff 
  c is not a leaf  
  none of the siblings of c is a leaf  and 
  none of the descendants of c  as a node in the tree  is appropriate. 
the clustering used in the experiments then corresponds to the collection of sets of instances subsumed by the appropriate classes. 
　the analysis of the empirical findings has to take into account several different aspects the first of which concerns the clusters detected. 
how  good  are the clusters  obviously  an optimal cluster contains only elements belonging to the same class  i.e. action sequences achieving the same domain goal. the degree of  disorder  within a cluster c can be measured by the entropy e c  defined as 
		 1  
where c ranges over the possible classes  goals  an instance  sequence  can belong to and pc is the relative frequency of instances belonging to class c among all instances contained in c. this numerical value can be used to quantitatively assess how well a cluster is  sorted   note that e c  assumes its minimal value of zero when all instances contained in c belong to the same class . in order to allow the results of experiments with varying numbers of classes to be compared  we use a relative measure of entropy by dividing the values obtained by  1  by the entropy of the original set of instances  action sequences  such that a value close to 1 corresponds to 
	bauer 	1 

figure 1: relative degr and cluster entropy. 
a random selection of sequences from the training data. figure 1 depicts the average values of this relative entropy measure along with the average values of the relative degree of restrictiveness. the latter corresponds to the degr values of the plan library entries created divided by the average degr value of the original action sequences contained in the training data.1 as could be expected  an increasing value of cf yields clusters with high entropy values  the larger the cluster  the higher the probability to include sequences from more than one class  and the complexity of the plans produced-measured by degr- decreases. it can be seen that the cf values between 1 and 1 offered the best compromise between reducing the complexity of plan descriptions-without being over-restrictive or trivial-and maintaining a relatively low cluster entropy. 
　the results for cobweb indicate that even the small clusters used in this comparison  most of them contained only 1 or 1 action sequences  have a relatively high entropy  i.e. these clusters are not  well sorted . as a consequence  joining the action sequences contained in these clusters produced an average of 1  void  plans containing no actions or constraints in each repetition of the experiment  i.e. the sequences within such a cluster were highly incompatible with each other. 1 these plans were removed from the library before starting the plan recognition process. the relative degr and entropy values when ignoring void plans are 1 and 1  respectively. the high degr values result from the small number of elements per cluster. 
　the second-and in this context even more important-question is how good are the plan libraries produced  to answer this question  the abovementioned plan recognition experiment was conducted the results of which are depicted in figures 1 and 1. here coverage stands for the percentage of action sequences for which the plan recognizer produced a non-empty result  correct  unique  is the percentage of sequences recognized 
correctly  correctly and uniquely1 . plan hypotheses as-
1
 all values computed with wa = wp = wt = 1 and ws = 1. 
　　1 note that the clustering method introduced in section 1 never lead to void plans. 
1
　　note that in many cases more than one plan hypothesis from the library proved compatible with the current action 
1 	planning and scheduling 
figure 1: results of plan recognition experiment - i. 
signed measures the average number of plans  recognized  by the system  that is  assigned to a single action sequence in the test data   while library entries measures the number of plans within the library. 
　to summarize the results  a clustering factor of about 1 yielded the best results for this domain  other domains may require different values for cf . here almost 1% of all action sequences where covered  more than 1% were correctly recognized  and for more than 1% this result was even unique. the results for the libraries generated using the cobweb clustering  1%  1%  and 1%  are similar to those for the clustering factor 1. note  however  that the degree of ambiguity measured by the number of plan hypotheses assigned is significantly higher for the cobweb-based libraries than for all other competitors. with cf = 1  for example  each action sequence is assigned at most two hypotheses while the average in the cobweb case is almost 1  out of 1 different classes . additionally  for ef = 1 the plan recognizer worked about ten times as fast as for cf = 1 or cf = 1 which is a direct consequence of the large number of library entries of high complexity  degr values  in these cases  while the cobweb-based libraries slowed down recognition even more. the smaller libraries obtained for very high cf values speed up this process even more  but the recognition results are relatively poor. 

figure 1: results of plan recognition experiment - ii. 
1 	related work 
abstracted versions of previous problem solutions have been studied both in the fields of ai planning  e.g. sequence-cf. figure 1. 

 minion  1   and programming by demonstration  e.g.  cypher  1 . in the former case they are reused for efficient planning from second principles  in the latter they enable a system to autonomously perform certain tasks on behalf of their users. as in both cases the aim is to generate an executable procedure  exact characterizations of actions  including preconditions and effects  as well as general domain laws are required. in contrast to this  the joining of action sequences as presented in this paper aims at producing recognizable structures and does not presuppose any domain knowledge. 
　in the plan recognition context  the explanation-based learning  ebl  procedure described in  mooney  1  and the machine-learning inspired approach presented in  lesh and etzioni  1  have to be mentioned. in the first case the objective is to detect the general plan underlying a short narrative. as ebl is a very knowledgeintensive method  rich domain knowledge has to be available in order to produce generic structures that can be used to analyze similar  unknown stories. in the latter case the goal and plan libraries are only implicitly defined by a set of goal predicates and actions and corresponding biases that allow the search space to be enumerated. as 
a consequence  only certain classes of domain goals can be handled and the system requires complete planning knowledge. 
　the ipam algorithm presented in  davison and hirsh  1  is a knowledge-free method to construct a probabilistic model of action patterns contained in action sequences that is used to predict future actions. this is in contrast to  yoshida and motoda  1  where information about 1 relationships among unix commands is exploited to produce a probabilistic predictive model. unlike ipam  this graph induction method needs relatively few training data to successfully make predictions. both approaches do not explicitly mention plans  but try to detect regularities in user behaviors. 
　clustering algorithms on the basis of shared subsequences  e.g.  zaki et al.  1   are not able to abstract from the observed temporal relations among the actions in the training sequences. as a consequence they are not feasible for the task of generating abstract plans for plan recognition libraries. 
1 	conclusion and future work 
this paper introduced a clustering method that allows groups of similar action sequences to be detected that can be used to generate plan library entries  even in the complete absence of domain knowledge. the empirical findings indicate that the libraries produced by this clustering algorithm in combination with the join algorithm can indeed be successfully used for plan recognition purposes. at least for certain values of the clustering factor the results were better than those produced by using cobweb to compute a clustering of the training data. it is important to note that the library entries generated are not necessarily executable  recipes   but structures that can be used to recognize the underlying domain goal. the recognition process is particularly well supported as these planrreflect the actual user behavior represented by the interaction samples used in the training data  including suboptimal and faulty behavior  while hand-coded libraries often concentrate on optimal or at least correct plans. another application of the clustering/joining procedure is the generation of alternative decompositions for one single class in situations where the training data are already labeled with their respective class memberships  but contain strongly diverging ways of achieving the same goal. 
　future work will include the application of the methods presented to additional domains and the investigation of the impact of various degrees of domain knowledge that could be used to improve the quality of plans and support the domain expert labeling the library entries. furthermore  comparisons with other clustering algorithms will be performed. 
