
tracking the movements of a target based on limited observations plays a role in many interesting applications. existing probabilistic tracking techniques have shown considerable success but the majority assume simplistic motion models suitable for short-term  local motion prediction. agent movements are often governed by more sophisticated mechanisms such as a goal-directed pathplanning algorithm. in such contexts we must go beyond estimating a target's current location to consider its future path and ultimate goal.
we show how to use complex   black box  motion models to infer distributions over a target's current position  origin  and destination  using only limited observations of the full path. our approach accommodates motion models defined over a graph  including complex pathing algorithms such as a*. robust and practical inference is achieved by using hidden semi-markov models  hsmms  and graph abstraction. the method has also been extended to effectively track multiple  indistinguishable agents via a greedy heuristic.
1 introduction
many interesting applications require the tracking of agents that move in a complex fashion through an environment in which only partial observations are possible. examples include real-time strategy games  aerial surveillance  traffic  visual tracking with occlusion  and sensor networks. related problems have been well-addressed in robotics and vision domains where approachesoften start by assuming a known motion model that characterizes the movement in question. for example  monte carlo localization usually employs a motion model for short-term predictions  capturing simple movements via some tractable mathematical formulation. unfortunately  in many applications  the movements of agents may be quite complex and involve long-term goals governed by sophisticated algorithms such as goal-directed path-planners. traditional tracking approaches that rely on simple motion models may not prove effective. furthermore  one may wish to draw inferences about the long-term behaviour of the agent rather than simply track its current location.
¡¡as an example  consider real-time strategy  rts  games  a popular genre of commercial video games in which users control armies consisting of tens or even hundreds of units. the units are largely autonomous and the user provides only high-level instructions to most units. for instance  a unit can be commanded to move to a new location simply by specifying the destination. a pathfinding routine then computes the actual path to reach this destination and the unit travels there automatically. another key feature of these games is the socalled fog of war-a limitation whereby the user can only observe activity in the immediate vicinity of their own units. this limited field of view means that enemy movements can only be observed when they occur close to an allied unit. this results in a series of short  disconnected observations of enemy movements. additionally  most units of a given type  e.g.  tanks  are indistinguishable from one another  so it may be uncertain whether or not two separate observations pertain to the same unit. several interesting strategic questions can be asked in relation to these observations. how many enemy units are there  which observationscorrespond to which unit  where is an enemy when unobserved  where was an enemy unit coming from and going to 
¡¡the method we propose and demonstrate facilitates inference using complex motion models in the form of a  black box . given two points  the motion model need only return a path; the algorithm producing that path can be arbitrary and unknown. our method infers answers to several of the above questions  employing abstraction to efficiently handle large numbers of possible paths and probabilistic models to robustly handle inaccurate motion models or noise in the observations. it is important to emphasize that the approach does not learn a model of the opponent's motion. instead  we use existing motion models to infer complex behaviour. we demonstrate our results in a rts-like context and discuss its use in real world domains.
1 related work
while there is a great deal of work on tracking  we are unaware of any work that employs complex black box motion models in the manner we describe here. the work of bruce and gordon on tracking human movements for robotic obstacle avoidance is close in spirit inasmuch as it works with the assumption that humans will follow optimal  and therefore potentially complex  paths  bruce and gordon  1 . another closely related project is work on learning goal-driven human movements from gps data  liao et al.  1 . this work also employs hidden semi-markov models and abstractions of the environment  although the details differ substantially. similarly  the work described in  bennewitz et al.  1  attempts to model complex human motion as a hidden markov model learned from past observations. however  all of these examples relied on previous examples of movements and/or goals in order to learn models. our work uses an existing but potentially very complex motion model and can be readily applied to new environments. the indistinguishable multi-agent task we identify here is very similar to that explored by  sidenbladh and wirkander  1  but they assume simplistic motion models. work on multiple hypothesis tracking  reid  1  and goal recognition also addresses similar issues. finally  bererton has applied a particle filtering approach to track human players in games to achieve realistic behaviours for game enemies  bererton  1 .
1 formalism
motionmodels to formalizethe discussion  we start with a known environment described by a graph g =  v e   where the vertices v = {v1 ¡¤¡¤¡¤  vn} correspond to a set of locations and the set of edges e indicates their connectivity. we assume the availability of a parameterized motion model m : ¦È g ¡ú p  where ¦È are the parametersand p is a sequence of vertices from v that specifies a directed path through g. specifically  we will consider endpoint motion models that take parameters of the form ¦È =  vi vj   where vi vj ¡Ê v are endpoints. figure 1  a  shows an example graph and path. any target we seek to track is assumed to be using m with some specific  but unknown  endpoint parameters. the model m is treated as a  black box  and the mechanism by which m generates paths is unimportant. we need only be able to query m for a path  given some endpoints.
¡¡the availability of such motion models for rts is quite immediate as the game provides an algorithm for this purpose. other applications might require constructing or learning a motion model  as in  bennewitz et al.  1    but in some domains reasonable models may already be available. for example  the various online mapping services can provide road paths between travel locations. another avenue is to assume some cost-sensitive pathing algorithm such as a* search-a very reasonable choice in the case of rts where most pathing algorithms are variants of a*. note that most useful pathing algorithms require edge costs or other information beyond the graph itself. any such extra information is assumed to be available along with the graph.
observations time is treated as advancing in discrete steps. at each time step t  the observations made are described by a set of vertex-result pairs  ot. the observation results for a vertex vi can be negative  nothing was seen there  or positive  a target was seen . for example  o1 = { v1 +   v1   } would mean that  at the third timestep  vertices v1 and v1 were under observation  and a target was seen at v1 while no target was seen at v1. all other vertices were not under observation. this arrangement allows for the fact

	 a 	 b 
figure 1:  a  path from an endpoint motion model.  b  noisy version of the proposed path.
that our observer s  may be moving through the environment and/or have a varying field of view. we use o1:t to denote the sequence of observations made from timestep 1 to timestep t.
1 inference with complex motion models
we seek to infer details of target movements given our observations and the parameterized motion model. the overall approach we adopt is bayesian inference. for now  we will consider only a single target and return to the multiple target case presently. we assume that the target is using the motion model m with two unknown parameters  the endpoints . if we can estimate these parameters  we can characterize the motion of the agent.
1 prior and posterior
we start by assuming a prior over endpoint parameters  p ¦È   where ¦È is a pair specifying the origin and destination vertices. in many applications we may have well-informed priors. for example  in rts games  targets typically move between a handful of locations  such as the players' bases and sources of resources. in all results presented here  we employ a uniform prior over endpoints  although our implementation accepts more informative priors. much may be gained by exploiting prior knowledge of potential agent goals.
¡¡at any given timestep t  we compute the posterior distribution over endpoints  given all past observations  p ¦È|o1:t . by bayes' rule  p ¦È|o1:t  ¡Ø p o1:t|¦È p ¦È   giving an unnormalizedversion of the target distribution by computingthe probability of the observations given the parameters. note that for many purposes  the unnormalized distribution is perfectly acceptable  but normalization can be applied if necessary. we compute the full posterior distribution in our work here but it is straightforward to compute the max a posteriori estimate of the parameters to identify a  most probable  path. in the simplest scenario  p o1:t|¦È  can be computed for all possible endpoints ¦È. we will address the obvious scaling issues with this approach shortly.
1 hidden semi-markov model
we must now explain how we will compute p o1:t|¦È  for one particular setting of ¦È. the black box m is used to generate the proposed path p corresponding to ¦È. an obvious method for calculating the probability would be to perform exact path matching  testing to see whether the observations o1:t exactly match what we would expect to see if the target traversed p. this results in a probability of 1 or 1. however  this approach is not robust. if our model m is not perfectly correct-perhaps because we do not have access to the true pathing routine but only an approximation-it will lead to problems. also  in real-world domains we may have the additional problem of noisy observations  such as erroneously seeing or not seeing the target  or incorrectly identifying its exact location when seen. finally  variable movement rates can result in observations inconsistent with p.
¡¡in order to compensate for these potential inconsistencies  we use p as the basis for a noise-tolerant observation model instead of using it directly. this model is a hidden semimarkov model  hsmm  based on p. a hsmm is a discrete time model in which a sequence of hidden states  s1 ¡¤¡¤¡¤  st  is visited and observations are emitted depending on the hidden state  see  murphy  1  for a good overview . hsmms extend the common hidden markov model by allowing for a distribution over the time spent in each distinct hidden state. more precisely  a hsmm consists of:
  a set of hidden states  the vertices v in our case 
  a prior over initial hidden state  p s1 = vi    vi ¡Ê v
  a transition function-a distribution over successor states given that a transition occurs at time t  p st+1 = vi|st = vj   vi vj ¡Ê v
  an observation function-a distribution over observations  for each state  p ot|st = vi   vi ¡Ê v
  a duration function-a distribution over the time to the next transition  for each state  p dt|st = vi   vi ¡Ê v .1
for each proposed endpoint pair ¦È  we build a corresponding hsmm whose parameters  the above distributions  we will denote by ¦È . we use the distribution of the observations given these ¦È  parameter settings as a noise-tolerant  unnormalized estimate of the distribution over the original ¦È parameters  p ¦È|o1:t  ¡Ø p o1:t|¦È p ¦È  ¡Ö p o1:t|¦È  p ¦È    where p ¦È   = p ¦È . we will defer explanation of how we construct ¦È for now  and explain how we compute the probabilities first.
inference inference in hsmms can be achieved using the forward-backward algorithm  murphy  1 . only the  forward  part is required to compute most of the distributions of interest. the forward algorithm computes the joint probability of the hidden state and the history of observations  p st o1:t|¦È    for each time step t  which we will abbreviate by ¦Át : v ¡ú  1 . each function ¦Át is a function of earlier functions  ¦Ás s   t  so the probability can be efficiently updated after each new observation. setting ¦Á1 vi  = p s1 = vi   vi ¡Ê v   the remaining ¦Á's are computed as

note that the ¦Á's and the distributions used to compute them are all specific to a single hsmm  ¦È . the conditioning on ¦È  was omitted for readability. by computing the ¦Á functions for all ¦È 's  we can obtain answers to some of our original questions  so we explicitly condition on ¦È hereafter.
endpoint and filtering distributions one interesting strategic question was  where is the target going to and coming from . we can obtain the unnormalized distribution over endpoints by marginalizing out the hidden state variable st

¡¡another interesting question was  where is the target now -the current hidden state of the target. this is often called the filtering distribution and can be computed as

1 building the hsmms
we still need to specify how to generate a hsmm ¦È  from a proposed path p based on ¦È. in the simplest case  one could construct the transition function so it deterministically generates p  the observation model to give 1 probabilities for  not  observing the target where p dictates  and the duration distribution to give probability 1 to a duration of 1. this is equivalent to the exact path-matching model. importantly  by changing the distributions that make up the hsmm  we can relax the exact matching in several ways to achieve robustness. we describe such a relaxation for handling inaccurate black boxes and noisy real-world observations immediately below. however  relaxations can also facilitate approximations that are computationally motivated  such as the abstracted graph approximation described in section 1.
noisy pathing
one way to deal with inaccuracies in m  i.e.  differences between true paths and proposed paths  is to introduce some noise into the transition functions of the hsmms. this creates a noisy version of the original model m. in our implementation  we introduce a small probability of straying from the exact path proposed by m to vertices neighbouring the vertices in the path  with a high probability of returning to vertices on the path. this creates a probabilistic  corridor  so that small deviations from m will be tolerated. figure 1  b  shows an example of this idea.
¡¡there are many other possibilities for introducing noise  e.g.  make the probability of error related to the edge weight of neighbours or distance from vertices in p . we explore only this simple transition noise here. another  quite distinct  option is to introduce noise into the observation function instead. uncertainty in real-world applications may come from m  or the observations  or both. practically speaking  noisy transition functions and observations functions can serve to address either source of error  e.g.  treating errors in proposed paths as though they were observation errors . we have not experimentedwith noisy observation functionsbut they might offer advantages by keeping the hsmm transition functions sparse  reducing memory usage and computation.
1 abstraction
we can perform exact inference simply by considering all endpointpairs. if the numberof possible pairs is prohibitively high  we could approximate by monte carlo sampling or even employ a form of particle filtering. the former is fairly straightforward and the latter is certainly possible. however  we will not expand on these options here.
¡¡a complementary strategy for reducing computational cost is to abstract the original base graph g that describes the environment to obtain a smaller abstract graph g  =  v    e   that more coarsely models locations in the environment. an abstraction ¦Õ g  maps every vertex in v to some member of the smaller set of abstracted vertices v   thereby reducing the set of possible endpoints. this effectively scales down the number of hsmms to store and compute. if the motion model m requires any additional information such as edge costs  these must be abstracted as well. in the work presented here we use clique abstraction  sturtevant and buro  1   which averages edge costs from g to produce edge costs for g   but our implementation accepts any graph abstraction provided. for many purposes the resulting loss in precision is an acceptable tradeoff  e.g.  it suffices to know that an enemy's goal is  near  some location .
¡¡some flexibility is required to handle graph abstraction. first  each vertex in v  corresponds to a set of vertices in v   some of which may have been under observation and the rest unobserved. we abstract our observations o1:t from the vertices in the base graph to observations o 1:t = {o 1 ... o t} such that we record a positive observation at an abstracted vertex if a target was seen in any of the corresponding base vertices under observation. these partially-observed abstract vertices introduce uncertainty when a negative observation is made; it is still possible that a target is in one of the unobserved base nodes. fortunately  the use of hsmms means that we can incorporate this uncertainty readily by changing the observation function. we use a simple and obvious model where the probability of a negative observation at some abstracted vertex  given that a target is actually at that vertex  is equal to the proportion of base vertices that are unobserved.
¡¡similarly  the grouping of base vertices into a single abstract vertex means that  even if movements at the base level take unit time  movementthrough an abstracted node can take variable amounts of time. again  we need only change the duration function for our hsmm to approximately account for this. we build this distribution for each abstract vertex by generating all base paths covered by the vertex and counting the number of paths of each length. we then assume a uniform distribution over paths through the abstract vertex.
¡¡the abstraction of graphs and observations may lead to discrepancies between abstracted observations and proposed paths  because the set of proposed paths is computed by m within g   while a target's actual path is computed within g. as a result  there may be mismatches between the actual path and abstracted path due to details in m's algorithm and  particularly  the abstraction of extra information such as edge cost. on the other hand  abstraction can serve to mitigate minor differences between the true motion model and our assumed motion model m since many base level paths will conformto a single path in g . thenoisy pathing described earlier is one possible remedy for the former situation.
1 multiple targets
in general  we expect multiple targets in the world. however  as mentioned earlier  it may not be possible to distinguish one target from another. we therefore seek to establish which agents generated which observations. we use the following natural grouping of observations as a starting point. while a target is in view  it is assumed that it can be accurately tracked  and so all consecutive positive observations of a target are taken to be a single trajectory.1
¡¡we now wish to associate these trajectories with targets. consider a set of integer  labels  {1 ¡¤¡¤¡¤  m}  where m is the number of trajectories  and a labelling l that maps every observed trajectory onto the set of labels. in place of our earlier notation for observations  we here denote the trajectories associated with a single label j under labelling l  by yl j .1 conceptually  each label corresponds to a distinct target that generates the trajectories associated with that label. some labellings will propose grouping a set of trajectories under one label that could not have been generated by a single target. such labellings will have a zero posterior probability. other labellings will be consistent but will differ in how well they explain the observations. ideally then  we want to find a labelling that gives the best explanation-one that maximizes the posterior probability of the observations

where p l  is a prior over labellings. this formulation effectively assumes that the targets associated with the labels generate observations independently  an approximation we accept for the sake of reducing computation.
¡¡maximizing over all possible labellings of the trajectories is still expensive  however  so we use the following greedy approximation. we start with the labelling l  which gives each trajectory a unique label  essentially claiming that each was generated by a separate target and that there are m targets   and then proceed iteratively. at each step  we select a candidate pair of labels j and k to merge  by which we mean that the trajectories of both labels are now associated with one of the labels. this gives us a new labelling  l such that
. next  we compare
the likelihoods of the labellings  rejecting the merge if l is more likely  or keeping the new labelling otherwise. we then select a new candidate pair and repeat.
¡¡we heuristically order the candidate label pairs by computing the kl divergence of the endpoint distributions for all pairs of labels and selecting 
 if a pair is
merged  we update the kl divergences and repeat. if a pair is rejected for merging  we select the next smallest divergence  and so on. merging stops when no candidates remain.
¡¡intuitively this heuristic proposespairs of labels whose trajectories induce similar endpoint distributions  i.e.  it prefers two hypothesized targets with similar origins/destinations given their separate observations . if the pair's observations were in fact generated by one target's path  then the merge should produce high posterior probability. however  it is also possible that there really were two targets and that when the observations are combined  an inconsistency is detected  e.g.  two similar paths that overlap in time and so cannot be a single target . the divergenceis simply intended to propose candidates in an order guided by the similarity of likely paths.
1 experimental results
we have implemented our approach on top of the hog framework for pathfinding research  sturtevant and buro  1 . it provides the simulation  visualization facility  pathfinding routines and abstractions. the clique abstraction we use is hierarchical  providing a succession of abstractions  each abstracting the graph from the previous level. abstraction level 1 is the original  unabstracted base graph  level 1 is an abstraction of that  1 is abstraction of level 1  etc. the baseline case-no abstraction and a perfect motion model- obtains the true posterior distributions given the observations made. the usefulness of even the baseline case is necessarily limited by the available observations. if a target is never observed  or observed only at points in the trajectory that are consistent with a wide variety of paths  then the conclusions will be correspondingly vague.
¡¡experiments were run to gauge the impact of the approximations involved in abstraction and the mechanisms used to handle noise. as we are unaware of any alternative method that performs inference with complex motion models of the

1
¡¡¡¡kl divergence is not symmetric so we adopt the common symmetrized version.

figure 1:  a  penta map showing target's path from at top right to bottom centre  b  superimposed images of origin and destination posterior distributions
kind we discuss here  our experiments are focused on showing that the approximations we use compare well to the baseline and improve on computational costs. we use four different maps for the most exhaustive tests. the first map  penta  shown in figure 1 a   is a 1 ¡Á 1 map created for our experiments specifically to demonstrate how endpoints can be accurately inferred. the other three maps  adrenaline  1 ¡Á 1   harrow  1 ¡Á 1   and borderlands  1 ¡Á 1   are all maps found in the commercial rts game  warcraft 1 by blizzard entertainment  see figures 1  1  and 1 . supplemental colour images and animations are available at http://ijcai1.googlepages.com/.
¡¡within these environments we place observers and targets. observers have a 1 ¡Á 1 field of view centered at their location. targets move using the pra* pathfinding algorithm described in  sturtevant and buro  1   a fast variant of a* that generates sub-optimal paths similar to a* paths. we can test the effect of inaccurate models by comparing the use of pra* for the modelling  a correct assumption  vs. a*  incorrect . in each trial  endpoints are randomly selected for the targets and observers are placed randomly along the paths  guaranteeing at least one observation. the simulation runs until all targets reach their destinations  plus an additional ten steps. endpoint and filtering distributions are computed at every timestep and results averaged over 1 trials.
¡¡an example of the posterior distributions over the origin and destination of a target on penta is shown in 1 b   ten time steps after the target  black dot  has completed the journey  viewed by two different observers  white dots  on the way. for compactness  the two distributions are superimposed- the shading at the top right is the origin distribution and the shading at the bottom center is the destination distribution.
¡¡to assess what might be called the  accuracy  of the method in the single target case  all paths are ranked according to their posterior probability at the end of the trial. we report the percentile ranking of the target's true path  averaged over all trials  higher is better . results are reported for several abstraction levels  for the different modelling assumptions  correct: pra* vs. incorrect: a*   and for noisy/nonnoisy transition functions. this captures the penalty suffered by abstraction and an inaccurate model. we highlight the baseline case  no abstraction  no noise  and accurate model  

1
http://www.blizzard.com/war1/

figure 1: adrenaline map

figure 1: harrow map with observers and a target
the best one can achieve given the observations. the number of vertices for each abstraction is also reported. we also report the average time per trial in seconds.
¡¡results for the penta map in table 1 show high accuracy in all cases  but this map is very small. when the modelling assumption is correct  pra* modelled by pra*   the noisy transition function damages results  even at higher abstractions. the incorrect modelling assumption  pra* modelled by a*  does further damage  but noisy transitions mitigate this slightly at the highest abstraction level. while all very similar  the averaged results do not capture the fact that a low percentile ranking on an individual run is often because the actual path was given 1 probability. under noisy transitions  results tend to be smoother and failures less catastrophic.
¡¡the other three maps are too large to run the baseline or first level of abstraction. having evidence from the penta map
|v |avg time
per step  s pra* by pra*pra* by a*normalnoisynormalnoisyno abs1.1.1.1.1.1abs 111111abs 111111abs 111111abs 111111table 1: penta map: percentile of actual path

figure 1: borderlands map
|v |avg time
per step  s pra* by pra*pra* by a*normalnoisynormalnoisyabs 111111abs 111111abs 111111abs 111111¡¡¡¡table 1: adrenaline map: percentile of actual path that results at the second level are quite close to the baseline  we present tables 1  1  and 1 to evaluate performance on real rts maps. in all cases  performance degrades gracefully as abstraction increases  with harrow showing the greatest loss  probably due to its less structured layout. note that even under the correct modelling assumption  the noisy transitions can mitigate the effects of abstraction in harrow although noise typically damages higher abstraction levels. the same noise parameters are used for all abstractions and were never tuned. the level of noise is simply too high for the very crude harrow abstractions where a path deviation of one vertex is comparatively large. these results show that effective inference can be performed even at fairly high abstractions.
¡¡runtime improves dramatically for early abstraction levels but exhibits diminishing returns as the number of vertices grows very small. currently the speed exceeds what is necessary for real-time tracking of a single target in rts and more optimization is possible. the average runtime per step of the simulation is reported and these times reflect the costliest mode of running at a given abstraction  i.e.  noisy transitions with a* modelling  which is the slowest mode .
¡¡finally  we test the multiple target trajectory association by measuring how often trajectories are correctly identified as coming from the same target. in each case  two targets with random paths are observed by two observers. the association is computed at the end of the trial. table 1 shows the
|v |avg time
per step  s pra* by pra*pra* by a*normalnoisynormalnoisyabs 111111abs 111111abs 111111abs 111111abs 111111abs 111111table 1: harrow map: percentile of actual path
|v |avg time
per step  s pra* by pra*pra* by a*normalnoisynormalnoisyabs 111111abs 111111abs 111111abs 111111abs 111111table 1: borderlands map: percentile of actual path
pra* by pra*pra* by a*normalnoisynormalnoisyno abs1111abs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1table 1: penta map: trajectory association accuracy
percentage of correctly classified trajectories  i.e.  correctly associated with any trajectories generated by the same target   averaged over all trials on the penta map  giving overall high success rates. the results for adrenaline  harrow  and borderlands in tables 1  1  and 1 reflect the single agent results. harrow is clearly the most difficult  with the wide-open spaces allowing for many possible interpretations of observations. interestingly  noise is more damaging to association results overall  suggesting than any  blurring  of goals can easily lead to misassociations. the robustness to abstraction seen on most maps shows that good associations are obtainable even at high abstractions unsuited to endpoint inference.
1 conclusions
we have presented a method for inferring the movements and intentions of moving targets given only partial observations of their paths. the target can be governed by complex motion models incorporating long-term  cost-sensitive objectives. given a black box m that describes the motion  a hidden semi-markov model is constructed for each candidate path generated by m. using hsmms lets the system accommodate uncertainty in observations  paths  and the duration of each move. the implementation also supports inference on abstractions of the original map  allowing its use even on complex maps from real-time strategy games. the method has been tested using a complex motion model based on a* pathfinding. finally  a greedy approximation has been proposed for associating observed trajectories with multiple  indistinguishable agents based on the posterior probability of joint observations and tested with good results. future work includes monte carlo and particle filtering-allowing weak hypotheses to drop in favour of the stronger; better approxi-
pra* by pra*pra* by a*normalnoisynormalnoisyabs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1table 1: adrenaline map: trajectory association accuracy
pra* by pra*pra* by a*normalnoisynormalnoisyabs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1table 1: harrow map: trajectory association accuracy
pra* by pra*pra* by a*normalnoisynormalnoisyabs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1abs 1.1.1.1.1table 1: borderlands map: trajectory association accuracy
mations for the multiple agent case; and parameterized motion models that include parameters other than the endpoints. even without these improvements  this approach has demonstrated great potential for addressing complex applications involving agents with long-term goals.
acknowledgments
this research was funded by the alberta ingenuity centre for machine learning. the authors offer warm thanks to nathan sturtevant for developing and abundantly supporting the hog pathfinding platform used in this research.
