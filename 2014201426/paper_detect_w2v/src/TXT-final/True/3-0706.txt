
a basic reasoning problem in dynamic systems is the projection problem: determine if a formula holds after a sequence of actions has been performed. in this paper  we propose a tractable1 solution to the projection problem in the presence of incomplete first-order knowledge and contextdependent actions. our solution is based on a type of progression  that is  we progress the initial knowledge base  kb  wrt the action sequence and answer the query against the resulting kb. the form of reasoning we propose is always logically sound and is also logically complete when the query is in a certain normal form and the agent has complete knowledge about the context of any context-dependent actions.
1 introduction
in the area of knowledge representation and reasoning  there is a well-known tradeoff between the expressiveness of the representation language and the computational tractability of the associated reasoning task. at one extreme  we have databases for which queries can be efficiently evaluated. but databases are too limited for many ai applications because they require complete knowledge about the domains. levesque  proposes a generalization of a database called a proper kb  which allows a limited form of incompleteknowledge equivalentto a  possibly infinite  consistent set of ground literals. since the deduction problem for proper kbs is undecidable  levesque proposes an evaluationbased reasoning procedure called v that is logically sound and  when the query is in a certain normal form called nf  also logically complete. moreover  later liu and levesque  show that despite the incomplete knowledge  database techniques can be used to implement v efficiently.
¡¡in this paper  we apply the procedure v to reasoning in dynamic systems where the state of the world changes as a
¡¡result of the actions of agents. for such applications  a basic reasoning problem is the so-called projection problem: given an action theory that specifies the preconditionsand effects of actions  and an initial kb  determinewhether or not a formula holds after a sequence of actions is performed. two settings where this problem arises naturally are for planning and for high-level program execution  levesque et al.  1 . a prerequisite to planning is the ability to determine if a goal is satisfied after a sequence of actions. to execute a high level robotic program such as  while there is a block on the table  pick up a block and put it away   one needs to determine after various sequences of actions whether there is still a block on the table.
¡¡in practice  there are two ways to deal with projection: we can progress the initial kb wrt the action sequence and answer the query against the resulting kb; or we can regress the query wrt the action sequence and answer the resulting query against the initial kb. progression has at least two advantages: first  it avoids a duplication of effort when multiple queries need to be answered wrt the same action sequence  and especially when that sequence is long. second  in a robotics setting  a robot can use its  mental idle time  to compute a progression while it is busy performing physical actions. projection via progression has three main computational requirements: the new kb must be efficiently computed  its size should be at most linear in the size of the initial kb  to allow for iterated progression   and it must be possible to answer the query efficiently from the new kb. lin and reiter  give a formal study of progression. they show that progression is not always first-order definable  and identify a few importantcases where progression is first-order definable and computationally tractable. however  the third requirement is not addressed in their paper.
¡¡in this paper  we propose a tractable  sound  and sometimes complete solution to the projection problem in the presence of incomplete first-order knowledge and context-dependent actions. we restrict our attention to actions with only  local  effects  and where incomplete knowledge is in the form of a proper kb. we define a version of progression where a proper kb remains proper afterward  and where applying v to the progressed kb and the query returns the same value as applying v to the initial kb and a regressed query. we prove that when the query is in nf and the initial kb has complete knowledge about the context of any context-dependent actions  our solution is logically complete. it is also logically complete when the query is in nf and there are sensing actions that provide dynamic information about the context of the relevant context-dependent actions.
1 preliminaries
in this section  we review proper kbs  v  and nf. also  we briefly review the situation calculus  and formally define local-effect action theories and regression for them.
1 proper kbs  v  and the normal form nf
we use a standard first-order logical language l cwith equal-1 ...}  and ity  a countably infinite set of constants c = {c1 no other function symbols. we restrict our attention to standard interpretations  where equality is identity  and there is a bijection between the set of constants and the domain of discourse. this restriction can be captured by a set of axioms e  consisting of the axioms of equality and the set of formulas
{we say  predicate    atom  or  literal   we exclude equality.ci =1	cj | i =1	j}. since we treat equality separately  when
¡¡we use ¦Ñ to range over atoms whose arguments are distinct variables. we use e to range over ewffs  that is  quantifier-free formulas with only equalities  i.e. no predicates . we use  ¦Õ to denote the universal closure of ¦Õ. we write ¦Õxc to denote ¦Õ with all free occurrences of x replaced by constant c. we write ¦² |=e ¦Õ to denote e ¡È ¦² |= ¦Õ. definition 1 a kb ¦² is proper if e ¡È ¦² is consistent and ¦² is a finite set of formulas of the form   e   ¦Ñ  or   e    ¦Ñ .
it is not hard to see that the problem of determining whether a sentence is logically entailed by a proper kb is undecidable  since when the kb is empty  this reduces to classical validity. levesque  proposes an evaluation-based reasoning procedure called v instead. given a proper kb and a query  v returns one of three values 1  known false   1  known true   or   unknown  as follows:
      1
1. v  ¦² p ~c   =if there is ain ¦² such that  e ~xv  ¦²  ep ~c ~x   = 1   if there is a   e ~x     p ~x  in ¦² such that v  ¦² e ~c   = 1
otherwise
1.is identical to c1  and 1 otherwise;
1. v  ¦²  ¦Õ  = 1   v  ¦² ¦Õ ;
1. vv  ¦² ¦²  ¦Õ x¦Õ¡Å   =¦×  = maxmax{cv¡Êh ¦²+¦² ¦Õvor  ¦² v¦Õ ¦Õ  and an extra constant. ¦²xc ¦×   where }; h+ is the union of the constants in
this v procedure is logically sound and  when the query is in a certain normal form called nf  also logically complete:
theorem 1   levesque  1   let ¦² be proper. then
1. for every ¦Õ ¡Ê l  = 1  if thenv  ¦² ¦Õ¦²  = 1|=e  then¦Õ. ¦² |=e ¦Õ; and if v  ¦² ¦Õ
1. for every ¦Õ ¡Ê nf  = 1  iffv¦² ¦²|= ¦Õe  = 1 ¦Õ. iff ¦² |=e ¦Õ; and v  ¦² ¦Õ
¡¡for the interested readers  the following is the definition of nf from  levesque  1 :
definition 1 a set ¦£ of sentences is logically separable iff for every consistent set of ground literals l  if l ¡È ¦£ has no standard model  then l¡È{¦Õ} is inconsistent for some ¦Õ ¡Ê ¦£. definition 1 the normal form nf is the least set such that
1. if ¦Õ is a ground atom or ewff  then ¦Õ ¡Ê nf;
1. if ¦Õ ¡Ê nf  then  ¦Õ ¡Ê nf;
1. if ¦Õ1 ... ¦Õn ¡Ê nf  and {¦Õ1 ... ¦Õn} is logically separable  then ¡Ä¦Õi ¡Ê nf;
1. if ¦£   nf  ¦£ is logically separable  and for some ¦Õ  ¦£ = {¦Õxc | c ¡Ê c}  then  x¦Õ ¡Ê nf.
the intuition behind nf is that different parts of a formula must be logically independent. a simple example of a formula not in nf is  p ¡Å p   where p is atomic. in the propositional case  a cnf formula is in nf if its clauses are nontautologous and closed under resolution.
¡¡liu and levesque  show that v can be implemented efficiently using database techniques  projections  joins  etc . here we present a cleaner variant of this result.
¡¡let lk denote the set of formulas from l that use at most k different variables. let r = {~c1 ... ~cm} be a finite set of n-tuples. we use ~x ¡Ê r to denote ~x = ~c1 ¡Å ... ¡Å ~x = ~cm.
definition 1 let l be p or  p for some predicate p. the ewff defining l in a proper ¦²  denoted by ¦Îl  is the disjunction of all e such that   e ~x    l ~x   ¡Ê ¦². we can write ¦Îl in the form of ~x ¡Ê il ¡Å el ¡Ä ~x ¡Ê1 ol so that il and ol are finite relations with as many tuples as possible  and el is an ewff. the e-size of ¦² is the maximum size of an el in ¦².
then a corollary to theorem 1 in  liu and levesque  1 : corollary 1 let ¦² be proper  and let ¦Õ ¡Ê lk. then v  ¦² ¦Õ  can be computed in time o lmnk   where l is the size of ¦Õ  m is the e-size of ¦²  and n is the size of ¦².
although the time complexity scales exponentially with k  this is typical even of queries over ordinary databases  and so is perhaps as good as can be expected.
1 situation calculus
our account of action and change is formulated in the language of the situation calculus  mccarthy and hayes  1; reiter  1 . we will not go over the language here except to note the following components: there are three disjoint sorts for actions  situations  and objects; there is a special constant s1 denoting the initial situation  namely the one in which no actions have yet occurred; there is a distinguished binary function do a s  denoting the successor situation to s resulting from performing action a; relations whose truth values vary from situation to situation  are called  relational  fluents  and are denoted by predicate symbols taking a situation term as their last argument; and there is a special predicate poss a s  stating that action a is executable in situation s.
¡¡we relate the language of the situation calculus to l as follows: there is a set of constants of sort object which are constants of l. the situation-independent predicates and relational fluents are predicates from l. that is  if p ~x  is a situation-independent predicate  and f ~x s  is a relational fluent  then p ~x  and f ~x  are predicates from l.
¡¡we extend the language l to l+ by allowing equalities involving action functions. let ¦Õ ¡Ê l+  and let ¦Ó be a situation term. we use ¦Õ ¦Ó  to denote the situation calculus formula obtained from ¦Õ by taking ¦Ó as the situation arguments of all fluents mentioned by ¦Õ. we use ¦Á to range over ground actions  and we use ¦Ä to range over sequences of ground actions.
let ¦Ä = h¦Á1 ... ¦Áni. we use do ¦Ä s1  to denote the end situation of ¦Ä  that is  do ¦Án do ¦Án 1 ...do ¦Á1 s1 ...  .
¡¡a particular domain of application will be specified by a basic action theory of the following form:1
d = dap ¡È dss ¡È duna ¡È ds1  where
1. dap is a set of action precondition axioms  one for each action function a  with form poss a ~x  s  ¡Ô ¦°a ~x  s  1 where ¦°a ~x  ¡Ê l.
1. dss is a set of successor state axioms  ssas   one for each fluent  of the form f ~x do a s   ¡Ô ¦µf ~x a  s   where ¦µf ~x a  ¡Ê l+. usually  ¦µf ~x a  has the form ¦Ãf+ ~x a  ¡Å  f ~x  ¡Ä  ¦Ãf  ~x a  .
ssas take the place of the so-called effect axioms  and provide a solution to the frame problem.
1. duna is the set of unique names axioms for actions:
¡¡¡¡a ~x  =1 a1 ~y   and a ~x  = a ~y    ~x = ~y  where a and a1 are distinct action functions.
1. ds1 is of the form {¦Õ s1  | ¦Õ ¡Ê ¦²1}  where ¦²1   l.
¦²1 is called the initial kb.
in this setting  the projection task can be defined as follows: determine if d |=e ¦Õ do ¦Ä s1    where ¦Õ ¡Ê l  and ¦Ä is a sequence of ground actions.
¡¡as a running example  we will use a simple blocks world.1we use a single action  move x y z   moving a block x from block y to block z  treating the table as just another block . we use three fluents: clear x s   block x has no blocks on top of it; on x y s   block x is on block y; eh x s   the height of block x is even. we have the following action precondition axiom and successor state axioms:
poss move x y z  s  ¡Ô clear x  ¡Ä on x y  ¡Ä clear z .
clear x do a s   ¡Ô   y z a = move y x z  ¡Å
;
on x y s  ¡Ä    z a = move x y z ;
eh x do a s   ¡Ô   y z  a = move x y z  ¡Ä  eh z s   ¡Å eh x s  ¡Ä    y z  a = move x y z  ¡Ä eh z s  .
1 local effect action theories and regression
actions in many dynamic domains have only local effects in the sense that if an action a ~c  changes the truth value of an atom f d~   then d~ is contained in ~c. this contrasts with actions having universal effects such as exploding a bomb  which kills all those near it. we can define this as follows:
definition 1 a successor state axiom is local-effect if both ¦Ãf+ ~x a  and ¦Ãf  ~x a  are disjunctions of formulas of the form  ~z a = a ~y  ¡Ä ¦Õ ~y    where a is an action function  ~y contains ~x  ~z is the remaining variables of ~y  and ¦Õ  called a context formula  is a quantifier-free formula from l. an action theory is local-effect if each ssa is local-effect.
our blocks world example above is clearly local-effect.
¡¡the notion of a successor state axiom being local-effect is a generalization of that of being strictly context-free defined by lin and reiter . an ssa is strictly contextfree if ¦Ãf+ ~x a  and ¦Ãf  ~x a  are disjunctions of formulas of the form  ~z a = a ~y    where a  ~y  and ~z are as above. for instance  the ssa for fluent on is strictly context-free  while that for fluent eh is not.
¡¡by using the unique names axioms  the instantiation of a local-effect ssa on a ground action can be significantly simplified . suppose the ssa for f is local-effect. let ¦Á = a ~c  be a ground action  and let   be + or  . then ¦Ãf   ~x ¦Á  is equivalent to a formula of the following form:
 
where is a vector of constants contained in ~c  and ¦×i is a sentence. we will use to denote the above formula  and we will write  d ¦×  ¡Ê ¦Ãf   ¦Á  to mean that ~x = d~¡Ä ¦× is one of the disjuncts. also  we will use ¦µf  ¦Á  ~x  to denote ¦Ãf+ ¦Á  ~x  ¡Å  f ~x  ¡Ä  ¦Ãf  ¦Á  ~x  . in the case of our blocks world  instances of the ssas can be simplified as follows: clear x do move c1 c1 c1  s   ¡Ô x = c1 ¡Å clear x s  ¡Ä   x = c1 .
on x y do move c1 c1 c1  s   ¡Ô x = c1 ¡Ä y = c1 ¡Å on x y s  ¡Ä   x = c1 ¡Ä y = c1 .
eh x do move c1 c1 c1  s   ¡Ô x = c1 ¡Ä  eh c1 s  ¡Å eh x s  ¡Ä   x = c1 ¡Ä eh c1 s  .
¡¡an important computational mechanism for reasoning about actions is regression  reiter  1 . here we define a one-step regression operator for local-effect action theories.
definition 1 let ¦Õ ¡Ê l. we use r¦Á ¦Õ  to denote the formula obtained from ¦Õ by replacing each fluent atom f ~t  with ¦µf  ¦Á  ~t . we call r¦Á ¦Õ  the regression of ¦Õ wrt ¦Á.
note that r¦Á ¦Õ  remains in l. let ¦Ä = h¦Á1 ... ¦Áni. we use r¦Ä to denote r¦Á1   ¡¤¡¤¡¤   r¦Án. we now state a simple form of the regression theorem  reiter  1 . recall that ¦²1 is the initial kb of d. theorem 1  the regression theorem  for every ¦Õ ¡Ê l  d |=e ¦Õ do ¦Ä s1   iff ¦²1 |=e r¦Ä ¦Õ .
this theorem shows that regression is a sound and complete solution to the projection problem. in this paper  we prove all our results about progression by using regression as a bridge.
1 progression of proper kbs
in this section  we define a variant of classical progression  and show how to compute it for local-effect action theories. first consider classical progression. suppose we have a kb ¦². let m be a possible state of ¦²  that is  a model of ¦². let ¦Á be a ground action. then the successor state of m wrt ¦Á is the model m1 such that for any ground fluent atom f ~c   m1 |= f ~c  iff m |= ¦µf ¦Á  ~c . a kb ¦²1 is a progression of ¦² wrt ¦Á if the models of ¦²1 are exactly the successor states of models of ¦² wrt ¦Á. a basic property of progression is: suppose that ¦²1 is a progression of ¦² wrt ¦Á. then for every ¦Õ ¡Ê l  ¦²1 |=e ¦Õ iff ¦² |=e r¦Á ¦Õ . it is in this sense that we say classical progression preserves classical entailment.
¡¡it would be nice if the classical progression of a proper kb were proper  so that we could use it and v to solve the projection problem. however  this is unfortunately not the case even for very simple action theories. consider the following example from  petrick and levesque  1 :
f do a s   ¡Ô a = a ¡Ä g s  ¡Å f s ; g do a s   ¡Ô g s .
then any progression of the empty kb  which is proper  wrt action a results in disjunctive information   f ¡Å  g   and hence is no longer proper. so what we will propose is a variant of classical progression where the progression of a proper kb does remain proper and the progression preserves v instead of preserving classical entailment. definition 1 let ¦² and ¦²1 be proper. we say that ¦²1 is a  weak  progression of ¦² wrt a ground action ¦Á if for every ¦Õ ¡Ê l  v  ¦²1 ¦Õ  = v  ¦² r¦Á ¦Õ  .
¡¡we now show that for local-effect action theories  it is easy to compute a weak progression of a proper kb.
definition 1 let d be local-effect and ¦² be proper.
we define p¦Á ¦²  as the set of the following sentences:
 
where f ranges over fluents  ¦Îf  resp. ¦Î f  is the ewff defining  c.f. definition 1   and
1.  
	d f = {d |  d ¦×  ¡Ê ¦Ãf+ ¦Á  and v  ¦² ¦×  = 1	};
1. 
	f	f	.
then we get the following:
theorem 1 let d be local-effect and ¦² be proper. then p¦Á ¦²  is a weak progression of ¦² wrt ¦Á.
let ¦Ä = h¦Á1 ... ¦Áni. we use p¦Ä to denote p¦Án   ¡¤¡¤¡¤   p¦Á1. by a simple induction  we have that for every ¦Õ ¡Ê l  v  p¦Ä ¦²  ¦Õ  = v  ¦² r¦Ä ¦Õ  .
the intuition behind af and d
f d~  will become true in every possible successor state  f is simple. for d~ ¡Ê af 
so we add f d~  to ¦². for d~ ¡Ê d f  f d~  may become true in some possible successor state  so we delete  f d~  from ¦². now consider our blocks world example. let ¦² = {on c1 c1  clear c1  clear c1  eh c1 }. after action move c1 c1 c1  is performed  we add clear c1    clear c1   on c1 c1   and  on c1 c1  to ¦²  and delete clear c1    clear c1   on c1 c1    on c1 c1   eh c1   and  eh c1  from ¦². we delete eh c1  because if eh c1  holds in the current state  eh c1  will become false in the successor state; similarly  we delete  eh c1 .
¡¡we now define a reasoning procedure pv to solve the projection task using weak progression and v as follows:
definition 1 let d be a local-effect action theory with a proper ¦²1. we define pv  ¦Ä ¦Õ  as v  p¦Ä ¦²1  ¦Õ .
now suppose that pv  ¦Ä ¦Õ  = 1.	then v  ¦²1 r¦Ä ¦Õ   =
v  p¦Ä ¦²1  ¦Õ  = 1. by soundness ofd |  dov  ¦Ä s¦²1   |=e r¦Ä ¦Õ . by the regression theorem  =e ¦Õ 1 . similarly  if cally sound for projection. it is easy to see thatpv  ¦Ä ¦Õ  = 1  then d |=e  ¦Õ do ¦Ä s1  . thusp¦Ápv ¦² is logi-can be computed in o n  time  where n is the size of ¦². by corollary 1  we have the following tractability result:
theorem 1 let d be a local-effect action theory with a
proper ¦²1  and let ¦Õ ¡Ê lk. then pv  ¦Ä ¦Õ  can be computed in time o pn + lmnk   where p is the length of ¦Ä  l the size of ¦Õ  m the e-size of ¦²1  and n the size of ¦²1.
thus pv provides an efficient and logically sound solution to the projection problem despite the incomplete knowledge. in the next two sections  we will explore under what conditions  pv is also logically complete.
1 a completeness result
since pv uses v   it is not surprising that we need a query to be in normal form for logical completeness. in this section  we will show that the only other thing we need is for the initial kb to have complete knowledge of the context of any context-dependent actions.
¡¡more precisely  we say that a kb ¦² is complete wrt a set g of ground atoms if for all¦² is complete wrt a predicatel ¡Ê g  eitherp if it is complete wrt all¦² |=e l or ¦² |=e  l.
a kb
ground atoms of p. now let ¦² be proper  and ¦Õ a quantifierfree sentence such that ¦² is complete wrt all atoms of ¦Õ. then it is easy to see that v  ¦² ¦Õ  is either 1 or 1.
definition 1 a kb ¦² is context-complete  wrt d  if it is complete wrt every predicate appearing in every ¦Ãf+ and ¦Ãf .
so ¦² is context-complete if it has complete knowledge about the predicates in the context of any context-dependent actions. for example  in our blocks world  a ¦² is contextcomplete if it is complete wrt eh; it may be incomplete wrt clear and on. so context-completeness still allows incomplete knowledge.
¡¡there are two useful special cases where we get contextcompleteness. an ssa is equality-only if no predicate appears in ¦Ãf+ or ¦Ãf . obviously  any ¦² is context-complete wrt equality-only ssas. indeed  many ssas we come across are equality-only. an ssa is context-free if no fluent appears in ¦Ãf+ or ¦Ãf . it is reasonable to assume that an agent has complete knowledge about situation-independent predicates. under such an assumption  any ¦² is context-complete wrt context-free ssas.
¡¡the logical completeness of pv is obtained by showing that progression preserves context-completeness and that under context-completeness  our progression coincides with classical progression.
theorem 1 let ¦² be context-complete. then
1. p¦Á ¦²  is context-complete too; 1. p¦Á ¦²  is a classical progression of ¦².
proof:  1  we prove that for every model m1  m1 |= p¦Á ¦²  iff there is a model m s.t. m |= ¦² and m1 is the successor state of m wrt ¦Á. for the only-if direction  we construct m as follows: for every fluent atom f ~c   if v  ¦² f ~c   = 1  then m |= f ~c ; if v  ¦² f ~c   = 1  then m |=  f ~c ; otherwise  f ~c . the proof uses the fact that   where   is + or  . 
so under context-completeness  our progression preserves classical entailment. now let ¦²1 be context-complete. by a
¦²simple induction  we have: for everynf1 |=ve  rp¦Ä ¦² ¦Õ . now let  ¦Õ  = 1 ¦Õ ¡Ê nfp  ¦² . by completeness of  =¦Õe¡Ê l¦Õ iff  p¦Ä¦² ¦²1|= e|=rev¦Ä¦Õ for¦Õiff 
iff . thus when the initial kb is contextcomplete and the query is in normal form  pv is logically complete for projection.
1 incorporating sensing
in many applications  it is asking too much to require complete knowledge in the initial kb about the context of the context-dependent actions. in this section  we follow de giacomo and levesque  and relax this restriction in two ways: first  we only need context-completenessrelative to the sequence of actions and the query in question; second  we can achieve this local context-completeness dynamically by resorting to sensing actions  that is  actions that get knowledge from outside the system. in other words  we show that when a history of actions and sensing results is  just-in-time  for a normal form query  pv is once again logically complete.
¡¡we first extend our account of action and change to incorporate sensing. assume that in addition to ordinary actions that change the world  we also have binary sensing actions that do not change the world but tell the agent whether some condition ¦Õ holds in the current situation. we use the predicate sf a s  to characterize what the sensing action tells the agent about the world. now our basic action theory has an extra component dsf  which is a set of sensed fluent axioms  sfas   one for each action  of the form sf a ~x  s  ¡Ô ¦Õa ~x  s   where ¦Õa ¡Ê l. we say that dsf is atomic if each ¦Õa is an atom.
¡¡for instance  we may add three sensing actions to the blocks world example: senseclear x   senseon x y   and senseeh x . the axiom sf senseeh x  s  ¡Ô eh x s  says that the action senseeh x  tells the agent if eh x s  holds.
¡¡to describe a sequence of actions and sensing results  we use the notion of a history  that is  a sequence of pairs  ¦Á ¦Ì  where ¦Á is a ground action and ¦Ì ¡Ê {1} is the sensing result: when ¦Á is an ordinary action  we simply let ¦Ì = 1. we use end ¦Ò  to denote the end situation of history ¦Ò  and sensed ¦Ò  to denote the situation calculus formula stating all sensing results of ¦Ò. formally 
is the empty history;
	¡¤	.
  sensed ¦Å  = true;
	¦Ò ¡¤ ¦Á 	¦Ò ¡Ä  	¦Ò .
¡¡naturally  we are only interested in consistent histories  that is  histories with reasonable sensing results. formally  definition 1 a history ¦Ò is consistent if e ¡È d ¡È {sensed ¦Ò } is a consistent theory. now the projection problem including sensing is formulated as deciding if d ¡È {sensed ¦Ò } |=e ¦Õ end ¦Ò    where ¦Õ ¡Ê l  and ¦Ò is a consistent history.
¡¡in the rest of this section  we assume that dsf is atomic. to prepare for the definition of just-in-time-history  we first extend our regression and progression operators to incorporate sensing. the ideas are quite simple. for example  if we regress the formula clear c1 ¡Ä eh c1  wrt  senseeh c1  1   we should obtain clear c1 . if we progress a proper kb ¦² wrt  senseeh c1  1   we should obtain ¦² ¡È {eh c1 }.
¡¡let ¦Á = a ~c  be a ground action  and let ¦Ì ¡Ê {1}. we define r ¦Á ¦Ì  ¦Õ  as follows: if ¦Á is an ordinary action  then r ¦Á ¦Ì  ¦Õ  = r¦Á ¦Õ . otherwise  let the sfa be sf a ~x  s  ¡Ô f ~x s . then r ¦Á ¦Ì  ¦Õ  is the formula obtained from¦Õ by replacing each atom f ~t  with~t = ~c¡Åf ~t  when ¦Ì = 1 and with f ~t  ¡Ä~t =1 ~c when ¦Ì = 1. we have the following extended regression theorem: theorem 1 let ¦Ò be a consistent history. then
d ¡È {sensed ¦Ò } |=e ¦Õ end ¦Ò   iff ¦²1 |=e r¦Ò ¦Õ .
¡¡now we turn to progression with sensing. let ¦² be proper. let ¦Á = a ~c  be a ground action  and let ¦Ì ¡Ê {1}. we define p ¦Á ¦Ì  ¦²  as follows: if ¦Á is an ordinary action  then p ¦Á ¦Ì  ¦²  = p¦Á ¦² . otherwise  let the sfa be sf a ~x  s  ¡Ô f ~x s . then p ¦Á 1  ¦²  = ¦² ¡È {f ~c }  and p ¦Á 1  ¦²  = ¦² ¡È { f ~c }. we have the following extended progression theorem:
theorem 1 let ¦Ò be a consistent history. then 1. e ¡È p¦Ò ¦²1  is consistent. hence p¦Ò ¦²1  is proper.
1. for every ¦Õ ¡Ê l  v  p¦Ò ¦²1  ¦Õ  = v  ¦²1 r¦Ò ¦Õ  .
another concept we need is dependency set.
definition 1 the dependency set of a formula ¦Õ wrt an ordinary action ¦Á  denoted by ds¦Á ¦Õ   is the set of ground atoms that appear in ¦Ãf+ ¦Á  or ¦Ãf  ¦Á  for some fluent f in ¦Õ.
for example let ¦Á = move c1 c1 c1 . then ds¦Á clear x   is the empty set  and ds¦Á eh x   = {eh c1 }.
definition 1 let ¦Ò be a consistent history  and ¦Õ ¡Ê l. we say that ¦Ò is a just-in-time-history  jit-history  for ¦Õ if for every division ¦Ò1 ¡¤  ¦Á ¦Ì  ¡¤ ¦Ò1 of ¦Ò such that ¦Á is an ordinary action  p¦Ò1 ¦²1  is complete wrt ds¦Á r¦Ò1 ¦Õ  .
intuitively  ¦Ò is a jit-history for ¦Õ if whenever performing an ordinary action ¦Á  the agent has complete knowledge about the context of ¦Á wrt fluents related to ¦Õ. this complete knowledge may come from the sensing actions preceding ¦Á. for example  let ¦²1 = {clear c1  on c1 c1  clear c1 }. then the history  senseeh c1  1  ¡¤  move c1 c1 c1  1  is a jit history for the formula  x clear x  ¡Ä eh x  . note that here the agent has incomplete knowledge about both fluents clear and eh. thus a jit history does not require complete knowledge about the component fluents of the query.
¡¡by a proof essentially the same as the one in the previous section  we get the following result: theorem 1 let ¦Ò be a jit-history for ¦Õ. then p¦Ò ¦²1  |=e ¦Õ iff ¦²1 |=e r¦Ò ¦Õ .
now let ¦Ò be a jit-history for ¦Õ ¡Ê nf.	then we have
d ¡È {v  p¦Ò ¦²1  ¦Õ  = 1 ¦Ò } iff|=ep¦Õ¦Ò ¦² end1  ¦Ò|=  e. thus when a history is¦Õ iff ¦²1 |=e r¦Ò ¦Õ  iff
     sensed just-in-time for a normal form query  pv is again logically complete for projection.
1 related work
as mentioned in the introduction  lin and reiter  give a systematic study of classical progression. as a part of their study  they view strips as a mechanism for computing progression and thus provide a logical semantics for strips. in this respect  they consider strictly context-free ssas and initial kbs in the form of relational databases or sets of ground literals. these are special cases of local-effect ssas and proper kbs  and our weak progression coincides with classical progression in these cases. son and baral  propose the so-called 1-approximation semantics for an extension of action language a. they define an a-state  approximate state  as a consistent set of fluent literals  and define a transition function which maps an a-state and an action into the next a-state. so 1-approximation is essentially a kind of approximate progression. however  their work is restricted to the propositional case  and our progression coincides with theirs therein. amir and russell  present efficient algorithms for  approximate  logical filtering  where filtering means updating an agent's belief state in response to actions and observations. so logical filtering is essentially progression. but again  their work is restricted to the propositional case. de giacomo and mancini  study how to exploit relational database technology to implement progression  but only when the initial kb has complete knowledge. we get to use database techniques in the incomplete case via the results in  liu and levesque  1 .
¡¡the idea of progression is widely used in planning under incomplete knowledge. most systems use propositional representations  for example  bdds  cimatti and roveri  1   and clauses  brafman and hoffmann  1 . being propositional makes it possible for them to consider arbitrary incomplete knowledgeand perform classical progression. although techniques are employed so that the systems can achieve reasonable performance in practice  there is no theoretical guarantee of the tractability of their solutions to projection. the pks system of petrick and bacchus  uses a first-order representation. the form of incomplete knowledge they consider is mainly a set of ground literals but with some other features. the general idea behind their progression is similar to ours  but without a semantical characterization of what it preserves. moreover  they do not address the issue of the restrictions they need to get completeness.
¡¡the idea of jit histories in this paper comes from  de giacomo and levesque  1 . they use jit histories to obtain complete knowledge about the component fluents of the query. however  we use jit histories only to obtain complete knowledge about the context of actions to be performed.
1 conclusions
in this paper  we have proposed a tractable  sound  and sometimes complete solution to the projection problem in the presence of context-dependent actions and incomplete first-order knowledge in the form of a proper kb. our solution is via a version of progression that preserves properness and v .
¡¡for simplicity of presentation  in this paper we require actions to have local effects only  and we make the extrarequirement that context formulas  c.f. definition 1  be quantifierfree. however  the soundness and completeness results in this paper will still hold if we relax these two requirements. the tractability result will also hold if context formulas use a bounded number of variables. as for local effects  the tractability result only needs them to ensure that the progressed kb is not much larger than the original kb. we believe that there are other ways of doingthis that would include a substantial class of actions with universal effects.
¡¡for the future  we would like to conduct experimental evaluation of our solution to projection  and apply it to first-order planning systems. also  we would like to extend our work here to deal with functional fluents and disjunctive incomplete knowledge.
