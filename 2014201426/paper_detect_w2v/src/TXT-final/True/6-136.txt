 
graphplan planning graphs are structures widely used in modern planners. the exclusion relations calculated in the planning graph extension provide very useful information  especially in temporal planning where actions have different duration. however  graphplan backward search has some inefficiencies that impose limitations when dealing with large temporal problems. this paper presents a new search process for temporal planning to avoid these inefficiencies. this search uses the information of a planning graph and shows beneficial in the scalability of the planner. moreover  our experiments show that a planner with this new search is competitive with other state-of-the-art planners w.r.t. the plan quality. 
1 introduction 
many of the current challenges in ai planning focus on increasing the functionalities of planners to deal with more real features  such as temporal capabilities  explicit management of resources  more expressive domain definition languages  heuristic techniques and optimisation criteria  etc.  fox and long  1; gerevini and serina  1; smith and weld  1 . this paper deals with three of the previous functionalities: i  planning with temporal features  actions with duration   ii  more expressive domain definition languages  pddl1  fox and long  1    and iii  plan optimisation  makespan . traditional temporal planners have adopted a conservative model of actions  where two actions cannot overlap in any way if they have conflicting preconditions or effects. this model is adequate in some planning domains  but there exist others that require a richer model of actions. level 1 of pddl1 used in ipc-1 provides a model of durative actions which allows a more accurate exploitation of action concurrency to obtain shorter makespan plans. 
　this paper describes our experiences with a temporal planning system  from now on tpsys   based on graphplan  blum and furst  1  and tgp  smith and weld  1   to manage the model of durative actions proposed in level 1 of pddl1. tpsys performs a graphplan backward search  which guarantees the properties of completeness and optimality. however  backward search has some inefficiencies that impose important limitations in large temporal problems. in these problems  the search space is vastly increased and the performance of the algorithm degrades. we suggest a new two-stage search process to overcome these inefficiencies. first  a backward search generates an initial relaxed plan. next  this relaxed plan is used as an outline for generating a solution plan by means of a non-complete heuristic process  where actions are only definitively allocated in the plan when they are applicable and no mutex  least-commitment . this allows to increase the scalability of search  producing non-optimal  but good quality  plans. 
1 a review of tpsys 
tpsys is based on a three-stage process  garrido et al  1   which combines the ideas of graphplan and tgp. this means that tpsys incrementally extends a temporal planning graph  performs a backward search through that graph and extracts a plan. 
　unlike conservative actions  durative actions present more conditions to be guaranteed for the success of the action. these conditions are sconda  econda and inva with the conditions of a to be guaranteed at the start  end and over all the execution of a  respectively. durative actions have two types of effects: seffa and eeffa with the effects to be asserted at the start and end of a  respectively. 
　the first stage of tpsys calculates the action-action and proposition-action static mutex relationships. these mutex relationships are static because they only depend on the definition of the actions and they always hold. the second stage extends a temporal planning graph which alternates temporal levels of propositions  ify  and actions  a  . unlike graphplan  levels in tpsys represent instants of time t 1 r+ in which propositions are present and actions can start/end. action-action  proposition-action and propositionproposition mutex relationships are calculated during the extension of the temporal planning graph. the third stage performs the search in a graphplan backward way  extracting an optimal plan through the planning graph. since the third stage starts as soon as all the propositions in the final situation are present  non pairwise mutex  and the plan extraction is complete  tpsys obtains the plan of optimal makespan. backward search in tpsys preserves the same properties of completeness and optimality of graphplan  but it en-

1 	planning 


figure 1: outline of the temporal planning graph for the ferry problem. shaded propositions represent the non-
pairwise mutex problem goals at time 1. mutex relations between propositions are represented by thick lines. 
tails the most time consuming stage. furthermore  this search presents some inefficiencies  inherited from graphplan  which impose important limitations in temporal problems. let us consider a simple problem from the ferry domain. 
the domain consists of transporting a number of cars from one location to another using a ferry which can carry only one car at a time. to keep the problem simple enough we assume three cars cl  c1 and c1 to be transported from location 1 to 1 by ferry / l . the actions are board sail and debark 
with durations 1  1 and 1  respectively. the optimal plan contains 1 actions  1xboard  1xsail and 1 debark  and the makespan is 1. the mutex relations are binary  so the second stage ends at time 1 and the search starts from there  see figure 1 . since every pair of actions is mutex  only one action is planned in each level. if we assume that applicable actions are selected in each level from top to bottom in the planning graph of figure 1  action a1 is firstly planned at time 1. next  actions a1 and al are planned at times 1 and 1  and so on. because no feasible plan is found  the search backs to time 1 where all permutations of actions a1  a1  a1 are planned under the same schema with no success. 
this is the first indication of inefficiency: a lot of effort is wasted trying  unsuccessfully  to plan nearly identical actions in problems with symmetry. as no plan is found from time 1  the planning graph is extended to time 1 and the search is re-started from scratch. this entails the second indication of inefficiency: no actions planned in previous stages of search are reused as a part of the current plan  committing similar failures in the new one-deeper-level search space. although memoization helps reduce the amount of failures committed during search  the way in which it prunes one branch of search does not allow to solve the real conflict until exhausting the whole level. this is the third indication of inefficiency: if one proposition becomes unsupported  no new actions supporting it are studied but that branch is discarded and the algorithm performs a backtracking stage. 
　these inefficiencies have a negative influence in graphplan-based temporal approaches. while a classical graphplan's planning graph for this problem has 1 levels  in temporal planning no plan is found until level 1 is extended and explored. particularly  in tpsys the number of levels generated depends on the dispersion of the durations of the actions. 
the worst performance happens when the gcd of the durations is 1  forcing the algorithm to generate the maximum number of levels. in consequence  the previous inefficiencies and wasted search are repeated more frequently. 
1 combining least-commitment and heuristics to improve the search process 
in this section we substitute the backward search by a twostage search to avoid the previous inefficiencies in a temporal planning approach. first  a backward chaining stage generates an initial relaxed plan from the information of the temporal planning graph. second  a forward chaining stage allocates the execution time of the actions in the relaxed plan. 
1 generation of an initial relaxed plan this stage generates an initial relaxed plan from the information of the temporal planning graph  from now on tg  to be used as a skeleton of the final plan. we define a relaxed plan ii as a partially ordered set of actions in which both the problem goals and action conditions hold. it is called relaxed because neither mutex relationships between actions nor commitment on their start time are considered. 
　a relaxed plan always contains two fictitious actions with no duration called is and fs. is achieves the propositions of the initial situation  whereas fs requires the problem goals. ii is generated similarly to the relaxed solution plan in the ff planner  hoffmann  1  with the exception that we handle durative actions  see algorithm 1 . 
1: goals 	problem goals {must hold in any plan for the problem 
1: ft {obligatory actions 
1: while goals do 
1: 	extract 	from goals 
1: 	if i is not supported in ii then 
1: 	arg min number of mutex which a* imposes in ii  
vaf which supports 
1: 	if a is the only action which supports 	is a condition of an obligatory action then 
1: 	mark a as obligatory in ii 
1: 	ii 	commitment on start time oj a yet 
1: 	goals 	goals 	sconda 
algorithm 1: generation of an initial relaxed plan ii. 
　step 1 studies the actions which support qi and selects the action which minimises the number of mutex in  in problems with multiple resources  this selection tends to use as many resources as available. for instance  in a ferry problem with two or more ferries ..  step 1 distributes the use of the ferries in a homogeneous way. if action debark cljl l1  is used for debarking the car cl  action debark c1 f1 l1  is first selected when debarking the car c1 because debark c1 flj1  is mutex with debark c 1  fl 1  and imposes more mutex in ii. this selection provides the relaxed plan more information about the structure of the problem  thus increasing the quality  number of actions in parallel  of the final plan. note that in step 1 we do not need to perform real search  or backtracking  because none of the mutexes are considered and  therefore  this strategy always leads to a solution. moreover  we introduce the term of obligatory action 

planning 	1 

a as the only action which supports a goal which must hold in any plan for the problem. this is helpful because it means that a must be always present in ii  steps 1 . obviously  both is and fs are obligatory. 
　one important property of ii is that if there is no mutex between overlapping actions  all actions in ii form a feasible  optimal plan. the proof of this is straightforward and relies on the complete extension of the temporal graph. the level in which the temporal graph extension ends indicates the minimal time in which the goals can be achieved by non-pairwise mutex actions. thus  this level provides a minimal bound of the makespan for a feasible plan and  if no mutex between actions holds  the plan is not only feasible but also optimal. unfortunately  this is not a very common situation and mutex relations break the plan relaxation. this entails to postpone the allocation of actions  and/or to plan new actions to solve the unsupported  sub goals. 
1 	planning and allocating of actions 
this stage performs the allocation in time of actions in the relaxed plan. we use a structure called set of .plans  with the search space formed by all the generated plans . actions in each are divided into two disjunctive sets: 
and contains the actions which have been allocated in time and will never be removed from 1;. relaxj contains the actions which have not been allocated yet  and so they can be removed from initially  is empty and contains all the actions in  the initial iij is the relaxed plan computed in the previous section . this stage finishes once gets empty  obtaining i n t h e actions of the plan which support all the problem goals. 
1: set.of .plans 	  generated in algorithm 1 
1: while set.of .plans 
1: 	extract the lowest cost ili from set.of .plans 
1: 	if alloa supports all the problem goals then 
1: 	exit with success 
1: 	else 	i 
1: 	priority  	' 
1: 	if a is mutex in alloci then 
1: 	if a is not obligatory then 
1: 	remove from relaxi 
1: 	else 
1: 	postpone start time of a in 
1: 	else 
1: 	if is applicable then 
1: 	allocate a in at time.of .execution! 
1: 	else 
1: 	insert new plans into set.of .plans to make a ap-
plicable 
1: 	update t ime.of.execut io 
algorithm 1: planning and allocating of actions. 
　the idea is to move forward in time  simulating the real execution of iij  progressively taking care of the actions which can start their execution  see algorithm 1 . the current time of execution in ili  time-of-execution*  is initialised to 1. the algorithm always selects the plan ftj of lowest cost from set.of-plans  step 1 . if all the problem goals are 
1 
supported the algorithm exits with success  step 1 . otherwise  actions from relaxi which can start at the current time.of-execution* are tried to be allocated  step 1 . if one action a is mutex with actions in alloci and nonobligatory  a is removed from h   step 1   delaying the fulfillment of its goals to a future time of execution. the reason to remove a non-obligatory action is that it could be a bad choice for the plan. if a is obligatory it is not removed but its start time is postponed  step 1 . if a is not mutex and applicable  a is allocated in time  step 1 . this step entails the first indication of loss of completeness. although there exist alternative actions to a  if a can be allocated those actions arc not considered in iij. step 1 is a branching point in which new actions are inserted  generating new plans  to achieve unsupported conditions of a. for each action a  supporting each condition a new plan iij is generated and inserted into set.of .plans with a j marked as obligatory in iij. it is im-
portant to note that a  is not allocated in time  but it is inserted with its earliest start time of execution extracted from the tg. this is part of the least-commitment technique performed in the allocation of actions when they are inserted into plans. step 1 moves to the next relevant time-of-execution* in which actions can start  extending the tg if necessary. 
　the algorithm has two important points of selection: steps 1 and 1. step 1 selects the plan ili with the lowest cost from set.of .plans  where the cost is estimated as follows: 

　the cost of a plan iij consists of the sum of the cost due to allod and is an estimation of the number of actions necessary to solve the unsupported conditions of  from the current time.of-execution it is estimated through the tg  ignoring the delete effects of actions  as in the heuristic used in ff   is the number of conditions of fs which supports  whereas del  fs  is the number of conditions of fs which deletes. pajmutex  fs  is the number of mutex between conditions of fs and action  this mutex information is extracted from the tg and indicates the impossibility to have simultaneously the conditions of fs and  duration represents the duration of the plan/action to take into account the makespan 
of  note that a  1 because they have a positive impact in the cost of the plan. in opposition  because it has a negative impact in the cost. 
　in step 1  the action a with the maximal allocation priority is selected to be studied at time.of -execution*. this priority is estimated as follows: 

　the allocation priority of action a depends on several local factors  succ  is the number of direct successor planning 
 dependent  actions of a in rneetsuccis the number of direct successor actions of which can start as soon as ends  i.e. which meet these two values indicate the importance of an action for the successor actions in intuitively  the more successor actions are directly supported by the more important is in the plan. similarly  the meeting successor actions indicate the number of successor actions which can be immediately executed without mutex. unsup and duration are defined as above. coefficients because they imply to select an appropriate action 
to be allocated. however  because they indicate that action is not promising enough to be allocated yet. 
　the previous evaluation functions can have many more heuristic factors  but according to our experimental analysis they are general enough for most temporal planning problems. we can also implement different heuristic methods by setting the values of the coefficients  which in our case are the same for all the domains. although the values of the coefficients can influence the search  their precise value is not as relevant as in other heuristic approaches based on local search as lpg  gerevini and serina  1 . for instance  the static cost of inserting an action in lpg is based on the number of unsupported conditions  what cannot represent the real complexity of solving each condition. on the contrary  the coefficient  deals with that complexity because it estimates the real cost to support it in the tg. 
　it is important to note that plans are incrementally generated without discarding allocated actions and with no redundancy due to symmetry. although algorithm 1 explores the complete space of actions to make actions applicable  the allocation priority imposes an order of execution and discards the rest of feasible orderings  second indication of loss of completeness . for instance  in the ferry problem of section 1  when studying the actions to debark the algorithm allocates one action and postpones the others. this avoids the complete exploration of all the permutations of a1  a1 and a1  preventing the planner from the generation of symmetric plans. 
1 experimental results 
we have implemented the previous search on top of tpsys  conducting several experiments1. the two first experiments compare the new search vs. the graphplan backward search. in the first experiment  we studied the impact of the new search in problems with a high degree of symmetry  such as the ferry and gripper  focussing on the planner scalability. figures 1-a b show the results for some problems of these domains. although it is not surprising that the leastcommitment search  tpsys-lc  is faster than graphplan backward search  tpsys-gp   it is worthy to mention that tpsys-lc scales up much better than tpsys-gp  especially in the gripper domain. moreover  tpsys-lc found optimal plans without backtracking for all the problems. 
　the second experiment deals with some problems of the simple-time track of the last ipc-1. although both approaches have difficulties to solve all the problems  see figures 1-c d e f   the least-commitment search can solve more problems. on one hand  backward search difficulties rise as a result of the redundancy in the complete  blind search process. on the other hand  least-commitment search difficulties rise as a result of: i  the heuristic  greedy approach  which can lead to the wrong path in the search  and ii  the non-complete preserving search. the zenotravel and s a t e l l i t e domains show the highest speedups. it is important to note that the best improvement is produced in the s a t e l l i t e domain  which is the only domain in the competition that exploits the end conditions of durative actions. 
　the third and fourth experiments are aimed at evaluating the quality of the plans generated by the new approach. we are mainly interested in the makespan of the plans  but we also consider the number of actions as an additional indication of the plan quality. the third experiment uses the plans generated in the experiment 1  figures 1-a b  and compares them with the plans generated by lpg1  gerevini and serina  1  and mips1  edelkamp  1 . we have chosen these two planners as they handle temporal features and showed distinguished performance in the last ipc. to date our interest has not focussed on code optimisation  so in this experiment we will not compare the execution time of the planners1 but only their plan quality. table 1 shows the comparison between the three planners taking into account the makespan and the number of actions of each plan. we have not included the results for the ferry domain because the three planners generate the same fully sequential plans. however  plans for the gripper domain can have actions in parallel  the gripper is a resource with capacity for two balls  so that the planner can exploit a better concurrency. in order to simplify the resulting plans the actions have been assigned duration 1. hence  the optimal makespan is 1 and the number of actions in an optimal plan is 1  where is the number of balls in the problem. surprisingly  both lpg or mips generate sequential plans as can be easily noticed from the fact that the makespan comes directly from the number of actions in the plan. tpsys-lc is the only of the three planners which generates optimal plans for all the problems  highly exploiting the action parallelism. 
　in the fourth experiment  we have used the plans generated in the last ipc to perform a comparison between tpsys-lc and some of the state-of-the-art planners which participated in the simple-time track. we have analysed 
http://www.dur.ac.uk/d.p.long/ipc 

planning 	1 


figure 1: comparison of the least-commitment search vs. the graphplan backward search. tests were censored after 1 s. 

problem tpsys-lc lpg mips gripper-1 1  1  1  grippcr-1 1  1  1  1  | gripper-1 1  1  1  1  1  1  gripper-1 1  1  1  1  1  grippcr-1 1  1  1  1  1  1  gripper-1 1  1  1  1  1  gripper-1 1  1  1  1  1  1  gripper-1 1  1  1  1  grippcr-1 1  1  1  gripper-1 1  1  1  table 1: comparison of the makespan  number of actions are in brackets  of the plans for the gripper domain obtained by tpsys-lc  lpg and mips planners. 
the plans generated by the domain-independent  di  planners lpg  mips and vhpop  and the domain-dependent  dd  planners shop1  talpianner and tlpian. for lpg and mips we have run the problems again and for the rest of the planners we have used the results of the competition. although sapa  tp1 and ixtet also participated in the competition we have not found enough results for the simple-time track to be considered in our comparison. figure 1 shows the results of this comparison  for lack of space we only include the domains with more problems solved . in the driverlog domain  the plans of tpsys-lc are generally longer than the rest of planners with the exception of lpg and shop1. in the s a t e l l i t e domain  tpsys-lc behaves in average better than the rest of the planners  with the only exception of tlpian. in the rovers domain  tpsys-lc generates again plans of very good quality  which are only improved by shop1 and tlpian. further  we have noticed that tpsys-lc generates plans with nearly the same  or even fewer  actions than the rest of the planners. these experimental results show that the new approach significantly improves the scalability of the graphplan backward search. 
1 conclusions through related work 
least-commitment techniques have been widely used in planning  relying on the consistency of temporal constraints  ixtet and hsts   postponing the assignment of values to variables or the order of execution of actions  etc.  weld  1 . we use a least-commitment approach to overcome the limitations of the graphplan backward search detected in previous works  fox and long  1; zimmerman and kambhampati  1 . our approach basically postpones the allocation in time of actions until they become not mutex and applicable. thus  the algorithm generates a relaxed plan similarly to ff  to be used as a skeleton of the plan. next  it allocates actions in time according to their mutex relations and to several local heuristic criteria in the line of lpg. our critical difference with lpg relies on several points. first  the planning graph is temporal and moves chronologically in time instead of planning steps. second  the tg is not only used to extract heuristic information but also to generate a relaxed plan. third  this plan is repaired in a forward chaining direction  and unlike lpg the allocated actions are never removed. fourth  the heuristics exploit better the structure of the plan and the real importance of each action in the plan. finally  tpsys-lc uses a more precise model of action mutex which implies fewer constraints on the execution of actions and a larger search space. 
this paper contributes in the way in which least-

1 	planning 


figure 1: comparison of the quality of the plans obtained by tpsys -lc and some state-of-the-art planners 

commitment can be applied in a graphplan-bascd temporal  or classical  approach  substituting the backward search by the new two-stage search. the new search combines the information calculated in the planning graph with a heuristic  greedy search process  and increases the planner scalability. the advantage is that the planner can exploit a high level of action concurrency  what leads to plans highly competitive with other state-of-the-art planners under a deterministic approach. although in temporal planning the most important criterion of quality is the makespan  the experimental results show that the new search generates plans in which the number of actions is quite good  even in problems of ipc-1 and ipo1 . the main disadvantage of this approach is that it is not complete preserving. however  although completeness and optimality are desired properties  guaranteeing them entails a huge complexity  preventing planners from producing plans with more than a few actions. the algorithm has still some limitations and our future work is to refine the heuristic functions to improve the quality of the plans  the performance and to avoid some of the inconveniences of the greedy search. 
acknowledgments 
this work has been partially supported by the spanish mcyt under projects dpi1-c1 and tic1-e  and by the universidad politecnica de valencia under projects 1 and 1. 
