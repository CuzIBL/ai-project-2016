
in this paper  a new complete technique to compute maximal satisfiable subsets  mss  and minimally unsatisfiable subformulas  mus  of sets of boolean clauses is introduced. the approach improves the currently most efficient complete technique in several ways. it makes use of the powerful concept of critical clause and of a computationally inexpensive local search oracle to boost an exhaustive algorithm proposed by liffiton and sakallah. these features can allow exponential efficiency gains to be obtained. accordingly  experimental studies show that this new approach outperforms the best current existing exhaustive ones.
1 introduction
this last decade  the sat problem  namely the issue of checking whether a set of boolean clauses is satisfiable or not  has received much attention from the ai research community. indeed  sat appears to be a cornerstone in many domains  like e.g. nonmonotonic reasoning  automated reasoning  modelbased diagnosis  planning and knowledge bases verification and validation. however  only knowing that a sat instance is unsatisfiable is often not satisfactory since we might prefer knowing what goes wrong with the instance when this latter one is expected to be satisfiable.
¡¡in this respect  the mus  minimally unsatisfiable subformula  concept can be crucial since a mus can be seen as an irreducible cause for infeasibility. indeed  a mus is an unsatisfiable set of clauses that is such that any of its subsets is satisfiable. it thus provides one explanation for unsatisfiability that cannot be made shorter in terms of the number of involved clauses. restoring the satisfiability of an instance cannot be done without fixing all its mus.
¡¡unfortunately  a same instance can exhibit several mus. actually  the number of these mus can be exponential since a n-clauses sat instance can exhibit cnn/1 mus in the worst case. moreover  computing mus is intractable in the general case. indeed  checking whether a set of clauses is a mus or not is dp-complete  papadimitriou and wolfe  1  and checking whether a formula belongs to the set  clutter  of mus of an unsatisfiable sat instance or not  is in  eiter and gottlob  1 . fortunately  the number of mus remains often tractable in real-life applications. for example  in model-based diagnosis  hamscher et al.  1   it is often assumed that single faults occur most often  which can entail small numbers of mus.
¡¡a dual concept is the notion of maximal satisfiable subset  mss  of a sat instance  and the complement of a mss in a sat instance is called a comss. the complete sets of mus and mss are an implicit encoding of the other  liffiton and sakallah  1 . specifically  a comss is a hitting set of the set of mus and represent minimal sets of clauses that should be dropped in order to restore consistency. in this paper  we are interested in exhaustive approaches to compute these correlated concepts in the boolean clausal framework.
¡¡recently  several approaches have been proposed to approximate or compute mus and mss  both in the boolean framework and for other types of constraints. some of them concern specific classes of clauses or remain tractable for small instances  only. among them  let us mention the approach in  bruni  1   where it is shown how a mus can be extracted in polynomial time through linear programming techniques for clauses exhibiting a so-called integral property. however  only restrictive classes of clauses obey such a property  mainly horn  renamable horn  extended horn  balanced and matched ones . let us also mention  bu¡§ning  1; davydov et al.  1;fleischner et al.  1   which are other important studies in the complexity and the algorithmic aspects of extracting mus for specific classes of clauses. in  bruni  1   an approach is proposed that approximates mus by means of an adaptative search guided by clauses hardness. in  zhang and malik  1  a technique is described  that extracts mus by learning nogoods involved in the derivation of the empty clause by resolution. in  lynce and marques-silva  1   a complete and exhaustive technique to extract smallest mus is introduced. in  oh et al.  1   a dpll-oriented approach has been presented that is based on a marked clauses concept to allow one to approximate mus. in  gre¡ägoire et al.  1a   a heuristic-based incomplete approach to compute mus has been introduced  which outperforms competing ones from a computational point of view.
¡¡interestingly  in  gre¡ägoire et al.  1b  the same authors have introduced a concept of inconsistent cover to circumvent the possible intractable number of mus  and presented a technique to compute such covers. roughly  an inconsistent cover of an unsatisfiable sat instance represents a set of mus that covers enough independent causes of inconsistency that would allow the instance to regain consistency if they were repaired. although an inconsistent cover does not provide us with the set of all mus that may be present in a formula  it does however provide us with a series of minimal explanationsof inconsistency that are sufficient to explain and potentially  fix  enough causes of inconsistency in order for the whole instance to regain consistency.
¡¡these latter techniques are incomplete ones in the sense that they do not necessarily deliver all mus. however  in some application domains  it can be necessary to find the set of all mus  because diagnosing infeasibility is hard  if not impossible  without a complete view of its causes  liffiton and sakallah  1 . obviously enough  such techniques can only remain tractable provided that the number of mus remains itself tractable. likewise  the number of mss and comss can be exponential in the worst case. it should be noted that many domains in artificial intelligence like belief revision  e.g.  bessant et al.  1   involve conceptual approaches to handle unsatisfiability that can require the complete sets of mus  mss  and comss to be computed in the worst case  even when additional epistemological ingredients like stratification are introduced in the logical framework.
¡¡in this paper  the focus is on complete techniques. we introduce a new complete technique to compute all mus  mss and comss of a sat instance  provided obvious tractability limitations. it improves the currently most efficient complete technique  namely liffiton and sakallah'one  liffiton and sakallah  1   in short l&s   which in turn was shown more competitive than previous approaches by bailey and stuckey  bailey and stuckey  1   and by de la banda  stuckey and wazny  de la banda et al.  1   which were introduced in somewhat different contexts.
¡¡our approach exhibits two main features. first  it is a hybridization of the l&s complete approach with a local search pretreatment. a local search technique is indeed used as an oracle to find potential comss of the sat instance  which are themselves hitting sets of mus. we show that such a hybridization can yield exponential efficiency gains. second  the efficiency of the approach relies on the crucial concept of critical clause  which appears to be a powerful ingredient of our technique to locate mus.
¡¡the rest of the paper is organized as follows. first  the reader is provided with the necessary background about sat  mus and the dual concepts of mss and comss. then  liffiton and sakallah's exhaustive approach is briefly presented. in section 1  we show how this technique can be valuably hybridized with a local search pretreatment  making use of the critical clause concept. it is shown how this pretreatment can be theoretically valuable from a computational point of view. in section 1  we compare this new approach with l&s.
1 background
in this section  we provide the reader with the basic background about sat  mus  mss and comss.
let l be the boolean logical language built on a finite set
of boolean variables  noted a  b  c  etc. the ¡Ä  ¡Å    and   symbols represent the standard conjunctive  disjunctive  negation and material implication connectives  respectively.
¡¡formulas and clauses will be noted using upper-case letters such as c. sets of formulas will be represented using greek letters like ¦£ or ¦². an interpretation is a truth assignment function that assigns values from {true  false} to every boolean variable. a formula is satisfiable when there is at least one interpretation  called model  that satisfies it  i.e. that makes it become true. an interpretation will be noted by upper-case letters like i and will be represented by the set of literals that it satisfies. actually  any formula in l can be represented  while preserving satisfiability  using a set  interpreted as a conjunction  of clauses  where a clause is a finite disjunction of literals  where a literal is a boolean variable that is possibly negated. sat is the np-complete problem that consists in checking whether a set of boolean clauses is satisfiable or not  i.e. whether there exists an interpretation that satisfies all clauses in the set or not.
¡¡when a sat instance is unsatisfiable  it exhibits at least one minimally unsatisfiable subformula  in short one mus.
definition 1. a mus ¦£ of a sat instance ¦² is a set of clauses s.t. ¦£   ¦²  ¦£ is unsatisfiable and  ¦¤   ¦£  ¦¤ is satisfiable.
example 1. let ¦² = {a   c   b ¡Å a  b   b ¡Å c}. ¦² exhibits two mus  namely {a  b   b ¡Å a} and { c  b   b ¡Å c}.
¡¡a dual concept is the notion of maximal satisfiable subset  mss  of a sat instance.
definition 1. a mss ¦£ of a sat instance ¦² is a set of clauses s.t. ¦£   ¦²  ¦£ is satisfiable and ¦¤ is unsatisfiable.
¡¡the set-theoretical complement of a mss w.r.t. a sat instance is called a comss.
definition 1. the comss of a mss ¦£ of a sat instance ¦² is given by ¦²   ¦£.
example 1. let us consider the formula ¦² from the previous example. ¦² exhibits five comss: {b}  { c  a}  { c  b¡Å a}  { b ¡Å c  b ¡Å a} and { b ¡Å c a}.
¡¡as shown by several authors  liffiton and sakallah  1   these concepts are correlated. mainly  a comss contains at least one clause from each mus. actually  a comss is an irreducible hitting set of the set of mus. in a dual way  every mus of a sat instance is an irreducible hitting set of the comss. accordingly  as emphasized by  liffiton and
sakallah  1  although minimal-hitting-set is a np-hard problem  irreducibility is a less strict requirement than minimal cardinality. actually  a mus can be generated in polynomial time from the set of comss.
1 liffiton and sakallah's exhaustive approach
liffiton and sakallah's approach  liffiton and sakallah  1  to compute all mus  in short l&s  is based on the strong duality between mus and mss. to the best of our knowledge  it is currently the most efficient one. first it computes all mss before it extracts the corresponding set of mus. here  the focus is on l&s first step since we shall improve it and adopt the second step as such.
¡¡l&s is integrated with a modern sat solver and takes advantage of it. roughly  every ith clause ci = x1 ¡Å ... ¡Å xm of the sat instance is augmented with a negated clause selector variable yi to yield. while solving these new clauses  assigning yi to false has the effect of disabling or removing ci from the instance. accordingly  a mss can be obtained by finding a satisfying assignment with a minimal number of yi variables assigned false. the algorithm makes use of a sliding objective approach allowing for an incremental search. a bound on the number of yi that may be assigned to false is set. for each value of the bound  starting at 1 and incrementing by 1  an exhaustive search is performed for all satisfiable assignments to the augmented formula  which will find all comss having their size equal to the bound. whenever one solution is found  it is recorded  and a correspondingclause forcing out that solution  and any supersets of it  is inserted. this blocking clause is a disjunction of the yi variables for the clauses in that comss.
¡¡before beginning the search with the next bound  the algorithm checks that the new instance augmented with all the blocking clauses is still satisfiable without any bound on the yi variables. if this formula is unsatisfiable  the entire set of comss has been found and the algorithm terminates.
¡¡the second part of the algorithmcomputesthe complete set of mus from the set of comss in a direct way. the approach that we shall introduce will include this second step as such.
1 local search and critical clauses
in this section  it is shown how the aforementionedexhaustive search algorithm can be improved in a dramatic manner by hybridizing it with an initial local search step  which provides valuableoracles for the subsequentexhaustivesearch process. we shall call the new approach hycam  hybridization for computing all mus .
¡¡first  let us motivate our approach in an intuitive manner. clearly  a  fast  initial local search run for satisfiability on the initial instance might encounter some actual mss. whenever this phenomenon happens  it can prove valuable to record the corresponding comss in order to avoid computing them during the subsequent exhaustive search. moreover  rather than checking whether we are faced with an actual mss or not  it can prove useful to record the corresponding candidate comss that will be checked later during the exhaustive search. obviously enough  we must study which interpretations encountered during the local search process yield candidate mss and criteria must be defined in order to record a limited number of potentially candidate comss only. in this respect  a concept of critical clause will prove extremely valuable in the sense that it allows us to state necessary conditions for being a comss that can be checked quickly. when all the remaining candidate comss are recorded  the incremental approach by liffiton and sakallah allows us to exploit this information in a very valuable and efficient way. let us describe this in a more detailed manner.
¡¡a local search algorithm is thus run on the initial sat instance. the goal is to record as many candidate comss as

algorithm 1: local search approximation

input: a cnf formula ¦²	output: set of candidate comss begin
                             #fail ¡û  1 ; i ¡û  generate random interpretation   ; while  #fail   preset #failures authorized  do
newcandidates ¡û  false ; for j = 1 to #flips do
let ¦¤ be the set of falsified clauses by i ; if  c ¡Ê ¦¤  c is critical and ¦¤ is not implied in candidates then
1 removeallsetimplied ¦¤ candidates  ;
1 candidates ¡û  ¦¤ ¡È candidates ;
1 newcandidates ¡û  true ;
1 flip i  ;
1 if not newcandidates  then #fail ¡û  #fail +1;
1 return candidates ;
1 end

algorithm 1: the hycam algorithm

	input: a cnf formula ¦²	output: all mss of ¦²
1 begin
1 cand ¡û  ls approximation ¦²  ;	k ¡û  1 ;
1 ¦²y ¡û  addselectorclauses ¦²  ;	mss ¡û    ;
1 while sat ¦²y  do
1removeallsetimplied {¦² c|c ¡Ê mss} cand  ;
1¦²y ¡û  addblockingclausesofsize k cand  ;
1mss ¡û  mss ¡È {¦² c|c ¡Ê cand and |c| = k} ;
1mss ¡û  mss ¡È sat with bound k ¦²y  ;
1k ¡û  k +1 ;
1 return mss ;
1 end

possible  based on the intuitive heuristics that local search often converges towards local minima  which could translate possibly good approximations of mss. a straightforward approach would consist in recording for each visited interpretation the set of unsatisfied clauses. obviously enough  we do not need to record supersets of already recorded candidate comss since they cannot be actual comss as they are not minimal with respect to set-theoretic inclusion. more generally  we have adapted the technique proposed by zhang in  zhang  1  to sets of clauses in order to record the currently smaller candidate comss among the already encountered series of sets of unsatisfied clauses. now  crucial ingredients in our approach are the concepts of once-satisfied and critical clauses. the latter concept has already proved valuable for locating mus and inconsistent covers using an incomplete technique based on local search  gre¡ägoire et al.  1a; 1b .
definition 1. a clause c is once-satisfied by an interpretation i iff exactly one literal of c is satisfied by i. a clause c that is falsified by the interpretation i is critical w.r.t. i iff the opposite of each literal of c belongs to at least one once-satisfied clause by i.
¡¡intuitively  a critical clause is thus a falsified clause that requires at least another one to be falsified in order to become satisfied  performing a flip. property 1 shows how this concept allows us to eliminate wrong candidate comss.

figure 1: mus of example 1
property 1. let ¦² be a sat instance and let i be an interpretation. let ¦£ be a non-empty subset of ¦² s.t. all clauses of ¦£ are all falsified by i. when at least one clause of ¦£ is not critical w.r.t. i  then ¦£ is not a comss of ¦².
proof. by definition  when a clause cf of ¦£ is not critical w.r.t. i  there exists at least one literal c ¡Ê cf whose truthvalue can be inversed  i.e. flipped  without falsifying any other clause of ¦². accordingly  ¦£ is not minimal and cannot be a comss of ¦².	
¡¡in practice  testing whether all falsified clauses are critical or not can be performed quickly and prevents many sets of clauses to be recorded as candidate comss. using these features  the local search run on the initial sat instance yields a series of candidate comss. this information proves valuable and allows us to boost l&s complete search.
¡¡l&s is incremental in the sense that it computes comss of increasing sizes  progressively. after n iterations have been performed  all comss of cardinality lower or equal than n have been obtained. accordingly  if we have recorded candidate comss containing n + 1 clauses  and if they are not supersets of already obtained comss  we are sure that they are actual comss. in this respect  we do not need to search them  and their corresponding blocking clauses can be inserted directly. moreover  we do not need to perform the sat test at the end of the n-th iteration  since we are then aware of the existence of larger comss.
¡¡it is also easy to show that the insertion of these blocking clauses can allow both np-complete and conp-complete tests to be avoided. let us illustrate this on an example.
example 1. let ¦² be the following unsatisfiable sat in-

stance and let ¦² be the corresponding augmented sat instance using l&s clauses selector variables yi.
     c1 : d  c1 : b ¡Å c  c1: a ¡Å b  c : a ¡Å c  c :  b ¡Å e  c :  a ¡Å b 
¦² =	c	: a ¡Å e 	c	:  a ¡Å e 	c : b ¡Å e 
c1 :  a ¡Å b ¡Å c  c1:  a ¡Å b ¡Å d 
	    c1: a ¡Å b ¡Å c 	c1: a ¡Å b ¡Å d 
¡¡¦² is an unsatisfiable sat instance made of 1 clauses and making use of 1 variables. it exhibits 1 mus  which are illustrated in figure 1  and admits 1 mss. assume that both l&s and hycam are run on this instance. its clauses are augmented by the  yi negated clause selector variables. assume also that the local search performed by hycam provides 1 candidate comss: {c1}  {c1 c1}  {c1 c1 c1} and {c1 c1 c1}.
¡¡if the branching variables are chosen based on the lexical order  then a and b are assigned to true and c1 is falsified. thus  l&s tries to prove that this clause forms a comss  which requires a np-complete test  because it has to find a model of ¦² { a¡Å b}¡È{a b} . on the contrary  when hycam is run  the blocking clause y1 is added before the first iteration of the complete algorithm is performed  since the local search has already delivered this comss. in consequence  when a and b are assigned true  the dpll-algorithm backtracks immediately as the {y1  y1} unsatisfiable set has been obtained  without requiring any further np-complete test.
¡¡similarly  the introduction of additional clause selector variables by hycam can reduce the number of conpcomplete tests. for example  let us assume that e is the first branching variable  that e is assigned false and that the next variables are selected according to the lexical order. when a and b are assigned true  l&s tries to prove that {c1} is a comss. since  e is tautological consequence of ¦² { a ¡Å  b}¡È{a b}  no model exists for ¦² { a¡Å b}¡È{a b  e}. clearly  such a test is in conp. thanks to the previously delivered candidate comss  hycam avoids this part of the search space to be explored. indeed  since we know that {c1} is a comss  when a and b are assigned true  no furtherconp tests are performed with respect to this partial assignment.
¡¡in fact  from a computational point of vue  the preliminary non-expensive local search eliminates nodes in the search tree  avoiding both np and conp tests.
1 experimental evaluation
hycam has been implemented and compared to l&s from a practical point of view. for both algorithms  the complete search step is based on the use of minisat  ee¡än and so¡§rensson  1   which is currently one of the best modern sat solvers. as a case study  we used walksat  kautz and selman  1  for the local search pretreatment. the number of flips and tries of walksat is related to the number of candidate comss already found. for each try  a small number of flips is performed. if no new candidate is found during a try then a counter is incremented. when this counter exceeds a threshold  experimentally set to 1   we consider that no new candidate could be found by the local search. this way to end the local search pretreatment offers a good trade-off between the number of candidates found and the time spent. besides  for all experiments  the time consumed by the local search step was less than 1% of the global time. all our experimental studies have been conducted on intel xeon 1ghz under linux centos 1.  kernel 1.1  with a ram memory size of 1go. in the following  a time-out limit has been set to 1 cpu hours.
¡¡first  in table 1a  we report experimental results about the computation of mss on pigeon-hole and xor-chains benchmarks  which are globally unsatisfiable in the sense that removing any one of their clauses makes the instance become satisfiable. obviously enough  such instances exhibit a num-
	 a 	 b 
	#comss	l&s	hycam	#comss	l&s hycam
inst.	 #v #c 	#mss	instance	 #v #c 	#mss
	cand.	act.  sec. 	 sec. 	cand.	act.  sec. 	 sec. 
randnet1-1 1 111randnet1-1 1 111randnet1-1 1 111randnet1-1 1 111randnet1-1 1 111ca1 1 111ca1 1 111ca1 1 111ca1 1 11t.o.1pipe 1 111pipe 1 ooo 1 111pipe 1 ooo 1 111pipe 1 ooo 1 111am 1 1 111c1 1 111c1 1 111bf1 1 111velev-sss-1-cl 1 111hole1 1 11.1.1hole1 1 11.1.1hole1 1 111hole1 1 111hole1 1 111x1 1 11.1.1x1 1 11.1.1x1 1 111x1 1 111  inst.  instance: benchmark name
   #v #c : numbers of variables and clauses
  #mss: number of mss of the sat instance
  #comss cand.  act.: numbers of candidate and actual comss exhibited by hycam local search pretreatment respectively
  l&s: time in seconds for liffiton and sakallah's algorithm
  hycam: time in seconds for hycam
table 1: l&s vs. hycam on globally unsatisfiable instances  a  and on various difficult sat instances  b ber of comss equals to their number of clauses  and the size of any of their comss is one. a significant time gap can be observed in favor of hycam. the efficiency gain ratio is even more significant when the size of the instance increased. for these instances  the local search run often succeeds in finding all comss  and the complete step often reduces to an unsatisfiability test. on the contrary  l&s explores many more nodes in the search space to deliver the comss.
¡¡in table 1b  experimental results on more difficult benchmarks from the annual sat competition  satlib  1  are described. their number of mss is often exponential  and computing them often remains intractable. accordingly  we have limited the search to comss of restricted sizes  namely we have set a size limit to 1 clauses. as our experimental results illustrate  hycam outperforms l&s. for example  let us consider randnet1-1. this instance contains 1 mss  with the size of their corresponding comss less than 1 . l&s and hycam deliver this result in 1 and 1 seconds  respectively. for the ca1 instance  hycam has extracted 1 mss in less than 1 minutes whereas l&s did not manage to produce this result within 1 hours. let us note that hycam also delivers comss made of 1 clauses after its computation is ended since we know that all sets of 1 falsified clauses recorded by the local search run and that are not supersets of the obtained smaller comss are actually also comss.
¡¡in table 1  experimental results on hard instances to compute the complete set of mss and mus are reported. as explained above  both l&s and hycam approaches require all mss to be obtained before mus are computed. by allowing complete sets of mss to be delivered in a shorter time  hycam allows the complete set of mus to be computed for more instances and in a faster manner than l&s does. obviously enough  when the number of mss or mus are exponential  computing and enumerating all of them remain intractable.
¡¡for instance  l&s was unable to compute all mss of the php-1instance within 1 hours cpu time  and could thus not discover its single mus. hycam extracted it in 1 seconds. on all instances exhibiting unique or a nonexponential number of mus  hycam was clearly more efficient than l&s. for example  on the dlx1aa instance  l&s and hycam discovered the 1 mus within 1 and 1 seconds  respectively. let us note that the additional time spent to compute all mus from the set of mss is often very small unless of course the number of mus is exponential.
1 conclusions and future research
computing all mss  comss and mus are highly intractable issues in the worst case. however  it can make sense to attempt to compute them for some real-life applications. in this paper  we have improved the currently most efficient exhaustive technique  namely liffiton and sakallah's method  in several ways. our experimental results show dramatic efficiency gains for mss  comss and mus extracting. one interesting feature of the approach lies in its anytime character for computing mss. mss of increasing sizes are computed gradually. accordingly  we can put a bound on the maximum size of the comss to be extracted  limiting the computing resources needed to extract them. to some extent  both l&s and hycam prove more adapted to extract complete sets of mss and comss than complete sets of mus. indeed  the procedure involves computing mss  and thus comss  first. in this respect  we agree with liffiton and sakallah that an interesting path for future research concerns the study of how mus could be computed progressively from the growing set of extracted mss.
¡¡many artificial intelligence research areas have studied various problems involving the manipulation of mus  mss and comss  like model-based diagnosis  belief revision  inconsistency handling in knowledge and belief bases  etc. these studies are often conducted from a conceptual point of view 
	#comss	l&s	hycam	#mus	mss¡úmus
instance	 #v #c 	#mss
	cand.	act.	 sec. 	 sec. 	 sec. 
mod1cage-unsat-1 1  1 1	111mod1-rand1bip-unsat-1 1  1 1	1111pipe 1  1 1 11  1time outphp-1 1  1 11time out11hcb1 1  1 11111dlx c mc ex bp f 1  1 11.1.1  1time outhwb-n1 1  1 1111hwb-n1 1  1 1111ssa1 1  1 1 1.1.11clqcolor-1-1 1  1 1 111dlx1aa 1  1 1	1.1.11addsub.boehm 1  1 1	11  1time outtable 1: l&s vs. hycam on computing all musor from a worst-case complexity point of view  only. we believe that the practical computational progresses as such as the ones obtained in this paper can prove valuable in handling these problems practically. in this respect  future research could concentrate on deriving specific algorithms for these ai issues  exploiting results like the ones described in this paper.
acknowledgments
we thank mark liffiton for making his system available to us. this work has been supported in part by the region nord/pas-¡ä de-calais.
