 
　　a plan calculus is presented which is being used to represent programs and a library of standard data and control abstractions in the programmer's apprentice. important features of this formalism include: programming language independence  additivity  verifiability and multiple points of view. the logical foundations of the representation are specified formally using a situational calculus in which side effects and overlapping mutable data structures are accounted tor. the plan calculus is comparedwith other formalisms  such as program schemas  and its advantages pointed out. 
1. introduction 
　　this paper reports on recent developments in a formalism celled the plan calculus which is being used in the programmer's apprentice  to represent and reason about programs the plan calculus was originally developed by rich and shrobe  and was subsequently elaborated by shrobe  and waters . most recently the author has extended the plan calculus by adding data abstraction and multiple points of view  as well as by providing a formal semantics. 
　　the goal of the programmer's apprentice project is to develop a knowledge-based tool for program development the programmer's apprentice attacks the complexity barrier  in programming in several ways. 
　　 i  by providing an on-line database of design decisions  documentation and descriptions of a program's design at various levels of detail; 
　　 ii  by reasoning about these descriptions to detect inconsistencies and predict the influence of incremental changes; 
　　 iii  and by providing a library of standard forms for use in program construction and analysis. 
　　this paper focusses on the representation used in building the library of standard forms. reasoning about plans will not be discussed in detail  see    other than to describe the formal system in which such reasoning takes place; nor will the detailed contents of the library be discussed  other than to show some examples. 
　　the utility of a library of standard forms in program development is motivated by the observation that expert programmers . like experts in many other fields  are distinguished from novices by their use of a much richer vocabulary of 
 1. support for the laboratory's artificial intelligence research has been provided in part by the advanced research projects agency of the department of defense under office of naval research contracts n1-c-1 and n1-c-1  and in part by national science foundation grant mcs-1 the views and conclusions contained in this paper are those of the author  and should not be interpreted as necessarily representing the official policies  either expressed or implied  of the department of defense  the national science foundation  or the united states government. 
intermediate level programming concepts the novice programmer thinks of constructing a program out of assignments  tests  arrays  do loops  etc.  whereas the expert programmer works with larger  less language-specific concepts  such as searching  accumulation  hashing  etc. there are deep reasons for this having to do with managing the complexity of the design process  1 . to the extent that the programmer's apprentice can provide a library of such standard building blocks  the programmer benefits by a reduction in the amount he needs to say to construct a program 
　　the idea of developing libraries of standard software components to gain the same benefits that the use of standard components has provided in other areas of engineering is not new . i believe that part of the reason efforts in this direction have not been more successful is because of deficiencies in the formalisms used. the plan calculus is an attempt to remedy these deficiencies. 
1. the plan calculus 
　　to a first approximation  the plan calculus may be thought of as unifying in one formalism ideas from flowchart schemas   data flow schemas   program transformations  1 1  and abstract data types  an example of a plan is shown in fig. 1. the details of the notation used in this figure can wait until later; for now the reader may note that a plan is basically a hierarchical structure made up of different kinds of boxes and arrows. the inner rectangular boxes denote operations and tests  while the arrows between boxes denote data flow  solid arrows  and control flow  hatched arrows  the chief features of this representation  as compared with previous formalisms are as follow  
　　 i  language independence to achieve some measure of canonical form  the plan calculus suppresses features of a program which stem soley from the way an algorithm must be expressed in a particular programming language. 
　　 ii  additivity. for a library to be easy to use  the rules for combining forms must be straightforward and explicit in the plan calculus  the result of combining two non-contradictory forms is always a form which satisfies the constraints of both of the original forms. 
　　 iii  verifiability. simply having a library of standard forms addresses only the low productivity part of the software crisis. the plan calculus also provides leverage on the software reliability problem by providing a methodology  in this case  an axiomatic semantics  for verification of library components. furthermore  this methodology provides a framework in which inconsistencies b e t w e e n uses of standard forms can be detected. 
　　 iv  multiple points of view. multiple and overlapping points of view are represented in the plan calculus by overlays between plans. an example of an overlay is shown in fig. 1  to be discussed further in the next section  overlays are used to express the relationship between levels of implementation  to describe overlapping module hierarchies  and to decompose data and control structures in ways which make their relationship to the 

1 

library more explicit. 
   an additional desideratum we set for representing the library of standard forms in the programmer's apprentice is that the formalism must be neutral between analysis  synthesis and verification of programs. this turns out to be of great practical importance for building an interactive programming aid  since in real program design situations all three of these activities are intermingled. a neutral representation of standard forms is also theoretically more interesting since it is more likely a priori to capture significant features of human understanding of these forms than a representation tailored specifically for analysis  synthesis or verification only. 
comparison with other formalisms 
   past efforts to construct knowledge bases for automatic or partially automated programming have used one of the following formalisms: program schemas   program transformations  1 1   program refinement rules   or formal grammars . although each of these representations has been found useful in certain applications  none combines all of the important features of the plan calculus listed above. this section will serve both to contrast the plan calculus with these other formalisms  and as the preliminary to a more careful definition of the plan calculus to follow. 
   for example  program schemas  incomplete program texts with constraints on the unfilled parts  have been used by wirth  to catalog programs based on recurrence relations  by basu and misra  to represent typical loops for which the loop invariant is already known  and by gerhart  and misra  to represent and prove the properties of various other common forms. unfortunately  the syntax of conventional programming languages is not well suited for the kind of generalization needed in this endeavor. for example  the idea of a search loop  a standard programming form  expressed informally in english should be something like the following. 
   a search loop is a loop with two exits in which a given predicate  the same one each time  is applied to a succession of objects until either the predicate is satisfied  in which case that object is made available for use outside the loop  or the objects to be searched are exhausted. 
in lisp  as in other languages  this kind of loop can be written 
figure |. plan for a search loop 
in innumerable forms  many of which are syntactically  and structurally  very different  such as: 
 prog    
lp  cond  exhausted  return nil    
 cond {{predicate current  return current    
 1 lp   
or with only one return instead of two   prog    
lp  cond  exhausted nil   t ... 
 cono   predicate current  
 return current    
 1 lp     
or even recursively  e.g. 
 ocfine search     cond  exhausted nil   t ... 
 cond   predicate current  current   t ... 
 search       
　　the problem here is that conventional programming languages ere oriented towards specifying computations in enough detail so that a simple local interpreter can carry them out. unfortunately a lot of this detail is often arbitrary and conceptually unimportant. in the plan calculus  all three of the schemas above  and many other such variations  are expressed by the single plan shown in fig. 1. 
   a new generation of programming languages descended from simula  1   such as clu and alphard  1   provide a syntax for specifying standard forms such as the search loop in a more canonical way. however  there are two more fundamental difficulties with using program schemas to represent standard program forms  which simula and its descendants do not solve. first  programs  and therefore program schemas  are not in general easy to combine  nor are they additive. this means that when you combine two program schemas  the resulting schema is not guaranteed to satisfy the constraints of both of the original schemas  due to such factors as destructive interactions between variable assignments. second  existing programming languages do not allow multiple views of the same program or overlapping module hierarchies. i believe the reason for this is that a program 


1 

is still basically thought of  from the standpoint of these languages  as a set of instructions to be executed  rather than as a set of descriptions  e.g. blueprints  which together specify a computation. 
   currently the most common way to represent relationships between standard forms  typically implementation/abstraction relationships  is via program transformations or program refinement rules . as compared to overlays  these formalisms have two serious problems which stem from their lack of neutralness between analysis and synthesis  an overlay in the plan calculus  as in fig. 1  is made up of two plans and a set of correspondences between the parts of the two plans. each plan represents a point of view; the correspondences express the relationship between the points of view. for example  in an implementation overlay the plan on the right hand side is the abstract description and the plan on the left hand side is an implementation. it is important  however  that either plan can be used as the  pattern . in a typical program synthesis step using overlays the right hand plan is used as the pattern and the left hand plan is instantiated as a further implementation conversely  in a typical analysis step  the left hand plan serves as the pattern and the right hand plan is instantiated as a more abstract description. with both program refinement rules and knowledgebased' program transformations this sort of symmetric use is not possible since the right hand side of a transformation or refinement rule is typically a sequence of substitutions or modifications to be performed  rather than a pattern. 
   a second problem stemming from the asymmetry of program transformations and refinement rules is their lack of verifiability. the correctness of an overlay in the plan calculus is verified by proving essentially that the the constraints of the plan on the left hand side  together with the correspondences  which are formally a set of equalities between terms on the left and terms on the right  imply the constraints of the plan on the right hand side. neither balzer's transformation language nor green and barstow's refinement tree notation has been adequately formalized to permit 
the question of correctness to be addressed. the recent work of broy and pepper  a  is an improvement in this direction  since their transformations have program forms on both the left and right hand sides  with associated proof rules. unfortunately  they use program schemas as the representation of the standard forms which has the difficulties discussed above. 
   another formalism some have found attractive for codifying programming knowledge is formal grammars. for example  ruth  constructed a grammar  with global switches to control conditional expansions  which represented the class of programs expected to be handed as exercises in an introductory pl/1 programming class. this grammar was used in a combination of top-down  bottom-up and heuristic parsing techniques in order to recognize correct and near-correct programs. miller and goldstein  also used a grammar formalism  implemented as an augmented transition network  to represent classes of programs in a domain of graphical programming with stick figures. the major shortcoming of these grammars from the point of view of the programmer's apprentice is their lack of a clear semantics upon which a verification methodology can be based. 
1. a situational calculus 
   before defining the plan calculus more formally  we first need to introduce the underlying logical foundations using a situations! calculus similar to the one developed by green  and used by mccarthy and mayes . a situational calculus is a variant of predicate calculus in which certain variables and constants are interpreted as denoting situations. situations can be thought of informally as  instants in time  or  states of the workf. 
 1. as opposed to the folding-unfolding and similar transformations of burst all and darlington  which are intended to be a small set of very general transformations which are formally adequate  but which must be composed appropriately to construct intuitively meaningful implementation steps. 
side effects 
   one basic issue to be addressed in the logical foundations of the plan calculus is the description of mutable objects. in programming  as in the everyday world of physical objects  objects can change their behavior  or properties  over time without changing their identity. the approach taken by green to this problem was to add an extra situational variable to the various function and relation symbols which described the time-dependent aspects of objects. so for example  for a mutable set a he would write member x a s  to assert that x is a member of a at time s. at some other time t=s  it then might be the case that  member x a t . we then say that a has been modified or that a side effect has occurred. 
   this situational notation becomes awkward  however  when one introduces defined relationships between objects. for example  suppose we wish to assert that between situations s and t some elements may have been removed from set a  but none have been added. the appropriate relation to use here is subset. in green's approach we are forced to define subset as follows  adding two situational arguments 
   subset a b s t  == vx   member x a s  d member x 1 t   . we then would then assert subset a a t s  to specify the indicated side effect. 
   this paper proposes ar  alternative situational calculus which allows us to preserve the standard algebra of set relations. mutable objects are treated formally here as functions from situations to behaviors. behaviors are mathematical domains  such as sets  in which there are no side effects  i.e. in which an axiom of extensionality similar to the one for sets applies ' a mutable set  such as a  is then formally a function from situations to sets. so for example we could write 
a s ={1 1} 
　　a t -{1} 	where s』t. and a t ♀a s  to specify the side effect discussed above. 
   this is the most straightforward example of specifying side effects. additional complexity enters in when side effects are combined with hierarchical objects  objects with objects as parts  and multiple points of view. the representation of such side effects in the situational calculus in these more complex cases will be touched upon slightly in the upcoming sections on data plans and overlays. these topics are treated in detail in  1}  shrobe  also discusses some techniques for reasoning about such complex side effects 
control flow 
   in addition to distinguishing the different behavior states of mutable objects  situations can be used to represent control information. this is achieved formally by introducing a'primitive partial order on situations  called precedes intuitively  this relation captures the notion of states occuring before or after other states. this relation also makes it possible to talk about cyclic computations in which all objects return to the same state as at some earlier time. 
   another basic feature of control flow we need to deal with in the situational calculus is conditionals. to do so formally  we introduce a distinguished constant j  into the domain of situations  such that vs precedes s.x  
   intuitively    represents a situation which is never reached. as we shall see in the following section  j  appears in the axioms for tests as a way of saying that the two branches of a test are mutually exclusive. x also gives us the power to talk about the termination of a loop. 
computations 
   given objects and situations  we can by induction construct a domain of n-tuples  and n-tuples of n-tuples  in which the base components are objects and situations. we call each such n-tuple 
 1. the axiom of extensionality for sets states that two sets are equal if and only if they have exactly the same members. 

1 

a computation. so for example  the 1-tuple  a s t  is a computation involving the object a and situations s and t. if the assertions given in the example above for a  s and t hold  then this computation involves a side effect to the mutable set a. 
　　as we shall see in the next section  a plan is formally a 
　　predicate on computations  with the syntactic variation of referring to the components of an n-tuple by selector functions rather than by numerical index . 
1 plans 
　　we are now in a position to give a formal definition of the plan calculus. in doing so  it is important to distinguish three levels of definition: 
 i  plan diagrams. 
this is the diagrammatic notation illustrated in fig. 1 and fig. 1. historically this was the first level of the plan calculus to be developed and is still the notation which is used most by the author for intuition and explanation. it is also the abstract  mental language  of the programmer's apprentice  i.e. the most natural language in which to describe its operations and strategies  there of course also has to be a concrete implementation of this language in computer memory  as discussed below   ii  formal semantics. 
a systematic method is given to translate each form of plan diagram into the axiomitization of a predicate in the situational calculus. this axiomatization provides the rules of inference on plans  veriflability and additivity  combination of plans has the same formal properties as union of axiom systems  note also that for presentation purposes the actual formulae associated with some constraints in plans will often be omitted from plan diagrams  and the existence of a constraint just indicated by an arc between the constrained parts. 
	  i i   	implementation. 
several different representations of the plan calculus as lisp data structures have been implemented and used by the author  shrobe and waters. two early versions of the implementation used a general purpose fully inverted assertional data base with pattern matching  similar to the one used in conniver   in which a separate assertion was stored to represent each feature  box  arrow  etc.  of a plan diagram a subsequent re-implementation by waters optimized this data base by providing specific access paths tailored to the specific assertion types and pattern matching that was required by the current programmer's apprentice system. most recently a third version was implemented using mcallester's t r u t h maintenance system  in which the logical axioms are represented explicitly with additional extra-logical annotation to encode the diagram level information the implementation level will not be discussed further in this paper  other than to show the external lisp form in which plan definitions are entered in the most recent version 
　　the basic idea of a plan  as used in the programmer's apprentice  comes from an analogy between programming and other engineering activities .  plans  of various kinds are used by many different kinds of engineers. for example  an electrical engineer uses circuit diagrams and block diagrams at various levels of abstraction; a structural engineer uses large scale and detailed blue prints which show both the architectural framework of a building and also various subsystems such as heating  wiring and plumbing; a mechanical engineer uses overlapping hierarchical descriptions of the interconnections between mechanical parts and assemblies 
　　programming is viewed here as a process involving the construction and manipulation of specifications at various levels of abstraction. in this view  there is no fundamental distinction b e t w e e n specifications and programs. a program  eg in lisp  is merely a specification which is detailed enough to be carried out by some particular interpreter. this view is consistent with the current trend in computer science towards wide spectrum languages. the advantage of this approach is that various parts of a program design can be refined to different degrees without intervening shifts of formalism 
　　the current plan calculus is based on a very simple model of computation  some limitations of this model and possible future extensions are discussed in the conclusions section . in this model all computations are composed out of three types of primitives: operations  tests  and primitive data objects. corresponding to each of these primitive types  there is a primitive specification form in the plan calculus. operations are specified by input-output specifications  preconditions and postconditions . tests are specified by a condition on the inputs which determines whether the test succeeds or fails primitive-data objects are specified an appropriate mathematical theory  such as numbers  sets or functions. 
　　plans are composite specifications constructed by the uniform mechanism of defining parts  called roles  and constraints. two kinds of plans are distinguished according to the types of the roles. data plans specify data structures whose roles are primitive data objects or other data structures data plans thus embody a kind of data abstraction. 
　　temporal plans specify computations whose parts are operations  tests  data structures or other composite computations. the plan for a search loop in fig 1 is an example of a temporal plan. in addition to arbitrary logical constraints between roles  temporal plans also include data flow and control flow constraints. temporal plans thus embody a kind of control abstraction since temporal plans can have embedded data plans  and the same compositional mechanism is used for both  control and data abstraction are unified in the plan calculus. the following sections describe the diagrams and formal semantics for each kind of plan in detail. 
input-output specifications 
　　in plan diagrams an input-output specification is drawn as a solid rectangular box with solid arrows entering at the top and leaving the bottom  as shown in fig. 1. each arrow entering at the top represents an input; each arrow leaving the bottom represents an output. constraints between inputs  preconditions  and between outputs and inputs  postconditions  are usually omitted in plan diagrams. 
　　the definition of set-add in the external format of the current data base implementation is shown in fig. 1 next to the diagram. set-add has two inputs old  constrained to be a set  and input 
 which may be an object of any type ; and no other preconditions. the only output of set-add is named new  a set . the postconditions of set-add specify that the new set has exactly the same members as the old set  with the sole addition of the input. in terms .of its semantics  this input-output specification is translated into a type predicate on computations  set-add  defined as shown below. 1 


1 


　　note that each input and output name becomes a function symbol which is the selector function for a component of a computation. such functions are called role functions thus inputoutput specifications  and also tests   although introduced as primitive above  are in fact composite from the standpoint of the formal semantics. input and output names are treated the same as role names in other composite plans. 
　　note two role functions in the definition above  in and out  were implicit in the defiospec form. these are situational roles which correspond intutively to the situations immediately preceding and immediately following the execution of the specified operation. the constraint between them is that the in situation precedes the out situation  and that they co-occur. co-occur is an equivalence on situations which is defined as follows 

this means that if the in situation is reached  it follows that the 
out situation is reached  i.e. the operation terminates; and conversely  if the in situation does not occur  i.e. s jl   then the out situation does not occur. this converse implication  together w i t h the axiomitizalion of tests shown in the next section  guarantees that none of the situations which follow in control flow from the failure side of a test occur 
　　finally  note the terms old axm a   and new axout a   in the definition of set-add. input and output role functions return 
objects which must be applied to the appropriate situational arguments to talk about their behavior.. thus old and new are mutable sets; however this specification makes no commitment as to whether or not the input object is added by side effect  note that we don't care about the behavior of the input object here  only its identity.  whether or not a side effect is allowed depends on the larger plan in which a particular use of set-add appears  specifically on whether the old set is used again after the operation. formally  the specification of the side effect comes d o w n to the question of equality between the old and new objects so for example  a specialized form  the specialization mechanism used here will be explained further below  of set-add can be defined by adding one more simple ppstcondition which stipulates that the addition be achieved by side effect. 
 defiospec impure-1et-a1 specialization set-aoo 
 1 input   mew  
   
      1 new    
　　the meaning of this definition is shown oelow. note that whether or not the role function is to be applied to a situational argument is encoded in the data base input notation by the presence or absence of parentheses around the role name in the constraint expression. 

test specifications 
　　in plan diagrams a test specification is drawn as a solid rectangular box with a divided bottom part  as shown in fig. 1. the inputs and outputs of a test specification and their types are indicated in the same way as the inputs and outputs of an inputoutput specification. a test also has preconditions and postconditions  just like an input-output specification. a test specification differs from an input-output specification in that two distinct output situations  named succeed and fail  are implicitly specified. which one occurs depends on whether or not a given relation  called the condition of the test  holds true between the inputs. control flow arcs originating from either the part of the test box marked s  for succeed  or the part marked f  for fail  are then used to indicate which other parts of a plan are executed depending on the test. 
　　the definition of the test specification apply-predicate written in the format of the current data base implementation is also shown in fig 1. note that this is the test specification used in the found role of the search-loop plan of fig. 1. the two exit roles of fig. 1 illustrate joins which are the mirror images of tests in the plan calculus. joins are required in conditional plans to specify what the output is in each case 
	apply-predicate has two inputs 	criterion  a predicate  and 
input  any object to which the predicate is applicable ; and no outputs. the test succeeds when the criterion is true of the input; otherwise it fails. in terms of its semantics  this test specification is translated into a type predicate on computations with three situational roles  in  succeed and fail  as shown below. 

　　from this way of defining tests it is possible to reason both backward and forward in time. for example  if the in situation is reached  i.e.   and the criterion is true  then it follows that the succeed situation is reached. conversely  if we know that the either the succeed or fail situation is reached  it follows that the in situation must have been reached. 
data plana 
　　data plans are plans whose roles are primitive data objects or other data plans. in plan diagrams primitive data objects are drawn as solid ovals; data plans are drawn as dashed ovals. data plans are used to represent standard data structure configurations which may be used in the implementation of more abstract data types. for example  the data plan indexed-sequence  shown in fig. 1  represents the common cliche of a sequence  typically implemented more concretely as an array  with an associated index pointer. this configuration is typically used to implement such things as buffers  queues  and stacks  implementation relationships are represented using overlays  which will be discussed further in an udcoming section.  
the plan indexed-sequence has two roles; base  a sequence  

 1. more complicated tests with more than two cases can be represented by composing binary tests. alternatively  the test notation may be generalized to more than two cases 

1 

  n d index  an integer ; and the constraint that the index is b e t w e e n zero and the length of the sequence. the definition of lndexed-sequence in the external format of the data base is also shown in fig. 1. 
　　data plans as a mechanism for data abstraction are similar in certain ways to to algebraic axioms  1  and abstract data types . the constraints between roles of a data plan are similar to what is called the invariant in other formalisms. from this point of view  the semantic translation of a data plan can be thought of as a data type predicate. for example  lndexedsequence  is defined as shown below. 

　　algebraic axioms and abstract data types  however  do not allow one to specify side effects on data structures -- all operations are purely functional. in the plan calculus  we single out the primitive selector operations of the data abstraction  which become the role functions. side effects are then specified in terms of changes to the roles of a data structure. note that lndexedsequence is defined as a predicate on behaviors not objects  i.e. i above is meant to denote a 1-tuple with components named base   n d index. a mutable indexed sequence is an object d such that  for example  d s -$. aspects of this formalization of mutable data structures are similar to the approaches taken by earley   by reynolds   1   for reasoning about arrays  and by guttag and horning  
　　the plan calculus also represents sharing  i.e aliasing  in composite data objects  which is not the case with algebraic axioms or abstract data types. space does not allow a full treatment of this topic here  see  ; the basic idea is that the parts of a composite data object can themselves be data objects  eg. base d s   above is a mutable sequence in this formalization a side effect to base d s   logically propagates to d s  
temporal plans 
　　temporal plans are the most general form of plan  in which both data and control abstraction can be expressed the roles of   temporal plan may be either primitive data objects  data plans  input-output specifications or test specifications the most typical constraints between input-output and test specification roles are data flow and control flow constraints an example of the diagram for a temporal plan is shown in fig. 1  note that fig. 1 earlier also illustrates a temporal plan . 
　　the bump+update plan in fig 1 has four roles: bump  a subtract one operation; update  an operation to change one term in a sequence; and old and new  which are indexed sequence data structures. this plan captures the cliched pattern of operations on  n indexed sequence in which the index is decremented and a new term is stored.  among other things  this is the implementation of ＊ push operation if the old and new indexed sequences are viewed 
 s stacks - see section on overlays . 
solid arrows in a temporal plan diagram  such as between the 
figure 1. data plan for an indexed sequance. 
output of the bump step and the index input of the update step  denote data flow  i.e. the output of bump becomes the index input of update. this notion of data flow is intuitively one of the main sources of additivity in the plan calculus. an arbitrary amount of other computation may be added between bump and update as long as the stipulated data flow is not disturbed. as we shall see below  data flow constraints are formalized logically as equalities between terms which denote the respective input and output ports. the additional solid lines in fig. 1 denote equality constraints between parts other than the input and output ports of input-output specifications. for example  the base of the old indexed sequence becomes the old sequence input to the update step; the base of the new indexed sequence is the new sequence output of the update step. 

1 　　a second feature of temporal plan diagrams introduced in fig. 1 is control flow  cross-hatched  arrows. the control flow arrow between bump and update means that the termination of the bump step precedes  and implies  the initiation of the update step. the external plan definition form for bump1update given in fig. 1 
　　summarizes all of these features. also shown below are the inputoutput specifications of the subtract-one and newterm  which are straightforward. 

this plan makes no commitment to whether or not a side effect is involved. a specialized version of bump+update can be specified in which the update step is specialized to an impure newterm specification and in which the old and new indexed sequences are constrained to be identical. also note that the input to newterm  the value of the new term  is not constrained in this plan. temporal plans are typically combined by providing data how from   n d to such ports 
　　shown below is the semantics of the temporal plan bump* update which is defined  similar to input-output and test specifications  as a predicate on computations 

　　the interpretation of this formal definition is left largely to the reader. the major complexity in translating temporal plans into their logical equivalent is in providing the appropriate situational arguments. in particular  for roles which are data plans  such as old and new above  we posit the existence of some situation  eg s and t above  in which the constraints of the data plan hold  and t h e n assert constraints between the behavior of the parts in that situation and the input and output ports to which they are connected in the plan diagram. the default situational arguments for input and output ports here are assigned the same way as in the corresponding input-output specifications  namely in for input objects and out for output objects. 
　　the bump+update plan does not illustrate an additional important feature of temporal plans  namely the use of recursion to represent loops. recent work on lisp interpreters  and compilers   1   suggests that the distinction between loops and singly recursive programs in which the recursive call is the last step of the program  so called  tail recursions   should be considered only a superficial syntactic variation. the plan calculus takes this point of view. recursion in plan diagrams  data plans may also be recursively defined  is indicated by a spiral line as s h o w n in fig. 1  the plan for a search loop  introduced earlier 
programming languages 
　　the plan calculus makes it possible to build a programmer's apprentice which is concerned with the syntactic details of different programming languages only at its most superficial interface. in order to translate back and forth between a given programming language and the plan calculus  the primitives of the programming language are divided into two categories: 
　　 i  the primitive actions and tests of the language  such as car  cor  cons  null and eq in lisp  are represented as input-output specifications and test specifications. 
　　 ii  the primitive connectives  such as prog  cono  stto  go and return in lisp  are represented as patterns of control and data flow constraints between operations and tests. 
　　the translation from standard program text to an equivalent plan representation has been implemented for reasonable subsets of lisp   1     fortran  and cobol . the translation from suitably restricted plans to lisp code has also been implemented by waters . 
1. relations between plant 
　　fig. 1 is a small excerpt from the current plan library which illustrates the the taxonomic structure of the library. a first observation to make about the nodes of the library shown in this example is that they are a mixture of both data abstractions  e.g. set  predicate  directed graph  and control abstractions  find and thread-find are input-output specifications  and in general there are temporal plans also . 
　　the four types of relations which relate nodes of the library are named in the upper right hand corner of the figure next to an example of the type of line or arrow used to represent each relation in the body of the figure. the first relation  component  simply indexes which plans are used in the definition of other plans  as for example indexed-sequence was used in the definilion of bump+update above. the next two relations are simple inheritance relationships by which a plan inherits the roles and constraints of another plan and then adds its own additional roles or constraints or both. specialization is the relation in which only constraints are added; extension involves adding roles  and usually  constraints between the new roles and the inherited ones . 
　　overlays are the most important type of relation between plans in the library because overlays represent significant additional knowledge  such as the details of how one abstraction may be implemented in terms of another. the diagram notation and semantics for overlays are explained in the following section. 
　　starting with set in fig 1  a typical question we might want to ask in the course of program analysis or synthesis is: what plans  e.g. input-output specifications  are there in the library which use sets  this type of question is answered in general by looking up the composition relation; in this example from set to find find is an input-output specification with three roles an input set  a criterion predicate and an output object; its precondition is that there exist an element of the input set which satisfies the criterion; its postcondition is that the output is such an element. 
　　overlays pointing to a node answer questions of the form: what implementations are available for find operations  in this example  one answer is that find may be implemented as threadfind  where the input set is implemented as a thread.  note that thread is a specialization of directed-graph in which each node has at most one predecessor or successor and there are no cycles.  the input-output specifications of thread-find are shown below. it has three roles similar to find: an input thread  a criterion predicate and an output object; its precondition is that there exist a node of the input thread which satisfies the criterion; its postcondition is that the output is such a node. 

1 1 　　finally  extension is a relation between plans which can be used to access useful variations of a plan. for example  in the figure an extension of thread-find is internal-thread-find. the input-output specifications of internal-thread-find are shown below. 


　　note that an additional output role  previous  has been added with the constraint that it be the predecessor of the output node in the input thread. this is a very common kind of operation on directed graphs when splicing of. nodes in and out is being performed. in order to be used properly  internal-thread-find must also have the additional precondition  from which its name is suggested  that the criterion is false for the root node of the input thread. overlays 
　　overlays provide a mechanism  n the plan calculus for representing the relationship between two different points of view  each of which is represented by a plan. overlays are similar to sussman's  slices    which he uses to represent equivalences in electronic circuit analysis and synthesis. formally  an overlay is a mapping from instances of one plan to instances of another. such mappings are a very general mechanism; the intuitive import of various overlays depends on what kind of plans are involved  whether the mapping is many-to-one or one-to-one  and how the mapping is defined. 
　　an example of an overlay between a temporal plan and an input-output specification is shown in fig. 1. intuitively  this overlay expresses how a push operation can be implemented by the bump+update plan discussed above  given that the stack is implemented as an indexed sequence. note that the diagram for an overlay is made up of a plan on the left hand side  which is the domain of the mapping   a plan on the right hand side  which is the range of the mapping   and a set of hooked lines showing a set of correspondences between roles of the two plans  which defines the mapping . in the external format of the current data base  an overlay is defined as follows 

　　notice that each overlay has a name  eg bump-fupdate push 1 which will become a function symbol in the formal semantics. correspondences between roles are either simple equalities  as in 
      = input push   input  update bump*update      which says that the input to push  the object which becomes the head of the new stack  corresponds to the input of the update step in the bump+update plan; or correspondences which defined in terms of other overlays  as in 
 =  old push    indixed-sequenced stack  old bump+update     
　　the overlay lndexed-sequence stack is an example of a manyto-one overlay between data plans. the basic idea of this overlay is that an indexed sequence may be viewed as the implementation of a stack in which the head is the term of the sequence indexed by the current index  and the tail is  recursively  the sequence w i t h index one greater. the formal definition of this overlay will not be shown here  as it is very similar to what is called an abstraction function in abstract data types the formal semantics of the bump+update push overlay is the following function definition. 

 1. this symbol is intended to be read  bump and update as push . 
　　implementation overlays such as bump+update  push and lndcxed~sequence stack are typically many-to-one. there are also one-to-one overlays in the library  which are naturally thought of as providing alternative points of view or transformations of data or control structure. for example  a lisp list can be viewed alternatively as a stack  i.e. a recursively defined data structure   as a labelled directed graph  in particular a thread  wherein the nodes are cons cells connected by the cdr relation and labelled by the car relation  or as a sequence wherein the i-th term is the car of  i-l th cdr. each of these data plans provides its own vocabulary for specifying properties of a data structure and a standard set of manipulations on it. there are one-to-one overlays in the library between them so that the appropriate point of view can be used depending on the properties and manipulations of interest  there are also one-toone overlays in the library between temporal plans  such the overlay introduced earlier in fig. 1 which captures the relationship in general between singly recursive programs which accumulate  on the way down   eg reverse copying a list  and those that accumulate  on the way up   eg. copying a list . 
　　other overlays of particular interest are those which map from temporal plans to data plans  in particular from recursive temporal plans to lists. these latter are called stream overlays and embody a kind of abstraction in which the objects filling a given role at all levels in a recursive plan are viewed as a single data structure. for example  there is a stream overlay in the library by means of which the succession of input's to the found test in the searchloop plan are viewed as a list; and if that overlay is composed with the overlay to view a list as the implementation of a set  then search-ioop can be viewed as the implementation of the find specification discussed above this method of abstraction provides a very powerful means of decomposing loops and recursions in a way which makes their behavior much clearer than the standard invariant assertion method for a further discussion of this idea see waters . 
1 　　a final point to note regarding the use of overlays is that they are not only part of the laxonomic structure of the plan library  they are also used to construct the refinement tree of a particular program. this tree encodes the design history of a program at many levels of detail. a way in which overlays differ from other refinement tree notations is that overlays permit overlapping implementations   where components that are distinct at one level of abstraction share parts at lower levels. this is a real 

feature of good engineering design and is an important way in which overlays are an improvement over previous notations. 
1. final remarks 
　　the emphasis in this paper on representation rather than reasoning has allowed no mention of an important dimension of the plan calculus in the programmer's apprentice  reasoning about plans takes place within a system  which maintains explicit dependencies between each assertion in the data base. these dependencies are crucial for supporting evolutionary design and debugging of programs. each overlay in the library has a precompiled network of dependencies between the specifications on the left and right hand sides  called its ideological structure  which is instantiated along with the parts  constraints and correspondences when it is used 
　　there are several areas in which we have found the current plan calculus deficient and hope to extend it further in the future important among these are the following: 
　　 i  performance considerations a way of formalizing time and space trade-offs is needed  both for the library and for reasoning about particular programs. 
　　 ii  error handling. the non-local flow of control typically involved in error handling code is not well represented in the current plan calculus. 
　　 iii  global shared data. programs which communicate primarily by inserting and retrieving information in a global shared data base are not well decomposed by the data flow ideas in the current calculus. 
　　finally  we intend to investigate the usefulness of the plan calculus in other planning contexts. in particular  i believe there is potential for a fruitful flow of ideas back and forth between program understanding  analysis  synthesis and verification  and robot planning  e.g. abstrips  . many of the insights underlying the plan calculus originate from work in robot planning; 
1 also believe some of the techniques developed in the plan calculus for representing and reasoning about overlapping data structures and side effects have bearing on aspects of the classical  frame problem   in robot planning. 
bibliography 
 i  p balzer   transformational implementation an example   ieee trans. on software enc  vol 1  no i  january  1 
 1  dr barstow   automatic construction of algorithms and data 
structures using a knowledge base of programming rules   
stanford aim-1  nov 1 
 1  s basu and j misra   some classes of naturally provable 
programs   1nd int. conf. on software enc  san francisco  cal  oct. 1 
 1  m broy and p pepper   program development as a formal 
activity   ieee trans. on software enc.  vol 1  no i  january  1 
 1  rm burstall ano jl darlington   a transformation system for 
developing recursive programs   j of the acm  vol 1  no i  january  1 
 1  te cheatham   program refinement by transformation   1th int 
conf. on software enc  san diego  cal   march  1 
 1  j gut tag.  abstract data types and the development of data 
structures   comm of the acm  vol 1  no 1  june 1  pp 
1 
 1  j guttag and j j horning.  formal specification as a design tool   
1th annual acm symposium on principles of programming languages  las vegas  january  1  pp 1 
 1  b liskov et. al.   abstraction mechanisms in clu   comm. of the acm  
vol 1  no 1  august 1  pp 1 
 i1  bm liskov ano 1n zilles   an introduction to formal 
specifications of data abstractions   current trends in 
programming methodology  vol. i   ed raymond yeh   prentice-hall  
1 
 1  z manna  mathematic theory of computation  mcgraw-hill  1 
 1  da mcallester. an outlook on truth maintenance   mit/aim-1  august  1 
 1  j mccarthy and p hayes.  some philosophical problems from the 
standpoint of artificial intelligence   machine intelligence 1  d 
michie and b meltzer  eds  edinburgh university press  edinburgh  scotland. 1 
 1  d mcoermott ano g j sussman   the conniver reference manual   mit/aim-1a  1 
 1  ml miller ano i goldstein   problem solving grammars as formal 
tools for intelligent cai   proc of the assoc for computing 
machinery  1 
 1  j misra   an approach to formal definitions and proofs of 
programming principles   ieee trans. on software enc  vol se-1  
no 1  september 1  pp 1 
 1  jc reynolds   reasoning about arrays   comm of the acm  vol 1  no 1  may 1  pp 1 
 1  c rich and he shrobe   initial report on a lisp programmer's apprentice '   ms thesis . mit/ai/tr-1. december 1 
 1  c rich. he shrobe  rc waters  g j sussman  and ce hewitt  
 programming viewed as an engineering activity    nsf proposal   mit/aim-1  janljary  1 
 1  c rich  he shrobe  and rc waters   an overview of the 
programmer's apprentice   proc. of 1th int. joint conf. on 
artificial intelligence  tokyo  japan  august  1 
 1  c rich   inspection methods in programming-. mit/ai/tr-1   phd  thesis   december  1 
 1  c rich   multiple points of view in mooeung programs   proc. of 
workshop on data abstraction  data bases and conceptual 
modeling  acm sigplan notices  vol 1  no i  janljary  1  pp 
1 
 1  g ruth   analysis of algorithm implementations-  mit project mac technical report 1.  phd thesis   1 
 1  ed sacerdoti   planning in a hierarchy of abstraction spaces   artificial intelligence  vol 1  no 1  1  pp 1 
 1  jt schwartz   on programming   an interim report on the setl 
project  courant institute of mathematical sciences  new york 
university. june 1 
 1  m shaw  w a wulf  and rl london   abstraction and verification 
in alphard defining and specifying iteration and generators   
comm of the acm  vol 1  no 1  august 1. pp 1 
 1  he shrobe.  dependency directed reasoning for complex program understanding    pho thesis   mit/ai/tr-1  april 1 
 1  gl steele ano g j sussman  'the art of the interpreter  or. the 
modularity complex  parts zero  one  and two   mit/aim-1  may 
1 
 1  gl steele   rabbit a compiler for scheme  a stuoy in compiler optimization   mit/ai/tr-1  may  1 
 1  g j sussman   slices at the boundary between analysis and 
synthesis   artificial intelligence and pattern recognition in 
computer aided design latombe  ed  north-holland  1 
 1  rc waters.  automatic analysis of the logical structure of programs   mit/ai/tr-1   phd thesis   december  1 
 1  rc waters   a method for analyzing loop programs . ieee trans on software eng. vol se-1. no 1. may 1  pp 1 
 1  rc waters.  a knowledge based program editor   proc of 1thint. 

 1  1 j dahl ano k nygaard  simula - an algol-based simulation 
joint conf. on artificial intelligence  vancouver  canada  august  
language   comm. of the acm  vol 1  no 1  september 1  pp 
1 
1 
                                                                                1  t winograo   break the complexity barrier  again    proc of the  1  jb dennis.  first version of a data flow procedure language . 
sigir-sigplan interface meeting  november  1 
proc of symposium on programming  institut de programmat1n  u 
	of paris  april 1  pp 1 	 1  n wirth  systematic programming  an introduction  prentice-hall  
1 
 1  j earley.  toward an understanding of data structures   comm of the acm  vol 1  no 1  october 1  pp 1 
 1  g faust   semiautomatic translation of cobol into hib1l    ms 
thesis   mit/lcs/tr-1  march  1 
  i i   sl gerhart   knowledge about programs a model ano case 
study   in proc. of int conf. on reliable software  june 1  pp 1 
 1  j a goguen  jw thatcher  ano eg wagner   an initial algebra approach to the specification  correctness  ano implementation 
of abstract oat a types   current trends in programming 
methodology  vol. iv   ed raymond yeh   prentice-hall  1 
 1  c green.  theorem proving by resolution as a basis for 
outstion-answering systems  machine intelligence 1  d michie and b meiuer  eds  edinburgh university press  edinburgh  scotland  1 
1 
